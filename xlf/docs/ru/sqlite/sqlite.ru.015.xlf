<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="8485338d9edebd1879a88fb2aa42a3b5aaf70e71" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763206f446e43106378de90da986cb3503647378" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_ENABLE_QPSG активирует или деактивирует &lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;гарантию стабильности планировщика запросов&lt;/a&gt; (QPSG). Когда QPSG активен, один оператор запроса SQL всегда будет использовать один и тот же алгоритм независимо от значений &lt;a href=&quot;../lang_expr#varparam&quot;&gt;связанных параметров.&lt;/a&gt;. QPSG отключает некоторые оптимизации запросов, которые смотрят на значения связанных параметров, что может сделать некоторые запросы медленнее. Но преимущество QPSG - более предсказуемое поведение. При активном QPSG SQLite всегда будет использовать тот же план запроса в поле, который использовался во время тестирования в лаборатории. Первым аргументом этого параметра является целое число, равное 0 для отключения QPSG, положительное значение для включения QPSG или отрицательное значение, чтобы оставить параметр без изменений. Второй параметр - это указатель на целое число, в которое записывается 0 или 1, чтобы указать, будет ли QPSG отключен или включен после этого вызова.</target>
        </trans-unit>
        <trans-unit id="e62faf35588a5d4eafe007180e96f2c0c110300b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_ENABLE_QPSG активирует или деактивирует &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;гарантию стабильности планировщика запросов&lt;/a&gt; (QPSG). Когда QPSG активен, один оператор запроса SQL всегда будет использовать один и тот же алгоритм независимо от значений &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанных параметров.&lt;/a&gt;. QPSG отключает некоторые оптимизации запросов, которые смотрят на значения связанных параметров, что может сделать некоторые запросы медленнее. Но преимущество QPSG - более предсказуемое поведение. При активном QPSG SQLite всегда будет использовать тот же план запроса в поле, который использовался во время тестирования в лаборатории. Первым аргументом этого параметра является целое число, равное 0 для отключения QPSG, положительное значение для включения QPSG или отрицательное значение, чтобы оставить параметр без изменений. Второй параметр - это указатель на целое число, в которое записывается 0 или 1, чтобы указать, будет ли QPSG отключен или включен после этого вызова.</target>
        </trans-unit>
        <trans-unit id="8bef3f5951097e41221958d251dd3bbb9ce96dee" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_LEGACY_ALTER_TABLE активирует или деактивирует устаревшее поведение команды &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; , которое ведет себя так же, как и до &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;версии 3.24.0&lt;/a&gt; (04.06.2018). См. &amp;laquo;Уведомление о совместимости&amp;raquo; в документации &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; для получения дополнительной информации. Эту функцию также можно включать и выключать с помощью &lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;оператора PRAGMA legacy_alter_table&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07c20d63d2e6b14f99d190fcacbd95a681ec8f6a" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_LEGACY_ALTER_TABLE активирует или деактивирует устаревшее поведение команды &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; , которое ведет себя так же, как и до &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;версии 3.24.0&lt;/a&gt; (04.06.2018). См. &amp;laquo;Уведомление о совместимости&amp;raquo; в документации &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; для получения дополнительной информации. Эту функцию также можно включать и выключать с помощью &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;оператора PRAGMA legacy_alter_table&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b56f76674dd3d27b6ff064c91089204d7b0e90fc" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_FILE_FORMAT option activates or deactivates the legacy file format flag. When activated, this flag causes all newly created database file to have a schema format version number (the 4-byte integer found at offset 44 into the database header) of 1. This in turn means that the resulting database file will be readable and writable by any SQLite version back to 3.0.0 (2004-06-18). Without this setting, newly created databases are generally not understandable by SQLite versions prior to 3.3.0 (2006-01-11). As these words are written, there is now scarcely any need to generated database files that are compatible all the way back to version 3.0.0, and so this setting is of little practical use, but is provided so that SQLite can continue to claim the ability to generate new database files that are compatible with version 3.0.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609f392579cb3bfb47e8225e916b400815ceda24" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_TRUSTED_SCHEMA option tells SQLite to assume that database schemas are untainted by malicious content. When the SQLITE_DBCONFIG_TRUSTED_SCHEMA option is disabled, SQLite takes additional defensive steps to protect the application from harm including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8460a489883d4335645b0e8208feef234ba632" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_WRITABLE_SCHEMA активирует или деактивирует флаг &amp;laquo;Writable_schema&amp;raquo;. Это имеет тот же эффект и логически эквивалентно установке &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA Writable_schema = ON&lt;/a&gt; или &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA Writable_schema = OFF&lt;/a&gt; . Первым аргументом этого параметра является целое число, равное 0, чтобы отключить Writable_schema, положительное значение, чтобы включить Writable_schema, или отрицательное значение, чтобы оставить параметр неизменным. Второй параметр - это указатель на целое число, в которое записывается 0 или 1, чтобы указать, включена или отключена Writable_schema после этого вызова.</target>
        </trans-unit>
        <trans-unit id="46872dc1f07ab31c88fb7c7af6f4fae5ff78bc83" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_WRITABLE_SCHEMA активирует или деактивирует флаг &amp;laquo;Writable_schema&amp;raquo;. Это имеет тот же эффект и логически эквивалентно установке &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA Writable_schema = ON&lt;/a&gt; или &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA Writable_schema = OFF&lt;/a&gt; . Первым аргументом этого параметра является целое число, равное 0, чтобы отключить Writable_schema, положительное значение, чтобы включить Writable_schema, или отрицательное значение, чтобы оставить параметр неизменным. Второй параметр - это указатель на целое число, в которое записывается 0 или 1, чтобы указать, включена или отключена Writable_schema после этого вызова.</target>
        </trans-unit>
        <trans-unit id="6b85aa8ea894875435c445b85abe99205949918e" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE Virtual Table</source>
          <target state="translated">Виртуальная таблица SQLITE_DBPAGE</target>
        </trans-unit>
        <trans-unit id="66cd1369214f0f32feaaff6ac1895398317fe842" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides direct access to the underlying database file by interacting with the pager. SQLITE_DBPAGE is capable of both reading and writing any page of the database. Because interaction is through the pager layer, all changes are transactional.</source>
          <target state="translated">Расширение SQLITE_DBPAGE реализует &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;виртуальную таблицу только&lt;/a&gt; с одноименным именем, которая обеспечивает прямой доступ к базовому файлу базы данных путем взаимодействия с пейджером. SQLITE_DBPAGE может как читать, так и писать любую страницу базы данных. Поскольку взаимодействие осуществляется через уровень пейджера, все изменения являются транзакционными.</target>
        </trans-unit>
        <trans-unit id="10bc6095f9cb7b42e8d331fa1d325222ae39eae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Расширение SQLITE_DBPAGE включено в сборках по умолчанию &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6759306b08f50bd9c66f3b5fb6678d1fa27bfe11" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option to enable the SQLITE_DBPAGE extension. The SQLITE_DBPAGE extension makes use of unpublished internal interfaces and is not run-time loadable. The only way to add SQLITE_DBPAGE to an application is to compile it in using the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">Расширение SQLITE_DBPAGE включено в &lt;a href=&quot;amalgamation&quot;&gt;объединение,&lt;/a&gt; хотя по умолчанию отключено. Используйте параметр &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_DBPAGE_VTAB, чтобы включить расширение SQLITE_DBPAGE. Расширение SQLITE_DBPAGE использует неопубликованные внутренние интерфейсы и не загружается во время выполнения. Единственный способ добавить SQLITE_DBPAGE в приложение - это скомпилировать его с использованием параметра &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_DBPAGE_VTAB .</target>
        </trans-unit>
        <trans-unit id="29d747e639293b4d0174864bbfeb0a0f144170ea" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table allows an application to view or replace the raw binary content of each page of the database file. No attempt is made to interpret the content of the page. Content is returned byte-for-byte as it appears on disk.</source>
          <target state="translated">Таблица SQLITE_DBPAGE позволяет приложению просматривать или заменять необработанное двоичное содержимое каждой страницы файла базы данных.Никаких попыток интерпретации содержимого страницы не предпринимается.Содержимое возвращается байт за байтом,как оно появляется на диске.</target>
        </trans-unit>
        <trans-unit id="f9b8d935ab9300d2651f69fa35d68c10b3cdb857" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table can participate in a join just like any other table. Hence, to see the content of the first page to all connected database files, one might run a statement like this:</source>
          <target state="translated">Таблица SQLITE_DBPAGE может участвовать в объединении так же,как и любая другая таблица.Поэтому,чтобы увидеть содержимое первой страницы во всех подключенных файлах БД,можно запустить такое утверждение:</target>
        </trans-unit>
        <trans-unit id="15d4ed3f8e0c537ab57736b4ad4d051438f525bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table has one row for each page in the database file. SQLITE_DBPAGE allows pages to be read or to be overwritten. However the size of the database file cannot be changed. It is not possible to change the number of rows in the SQLITE_DBPAGE table by running DELETE or INSERT operations against that table.</source>
          <target state="translated">Таблица SQLITE_DBPAGE имеет по одной строке для каждой страницы в файле базы данных.SQLITE_DBPAGE позволяет читать или перезаписывать страницы.Однако размер файла базы данных не может быть изменен.Невозможно изменить количество строк в таблице SQLITE_DBPAGE,выполняя операции DELETE или INSERT над этой таблицей.</target>
        </trans-unit>
        <trans-unit id="74c5162b414c69b11a7519aa50aa6d53d70b24f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table schema shown above is incomplete. There is a third &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;schema&quot; that determines which &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed database&lt;/a&gt; should be read or written. Because the &quot;schema&quot; column is hidden, it can be used as a parameter when SQLITE_DBPAGE is invoked as a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt;.</source>
          <target state="translated">Схема таблицы SQLITE_DBPAGE, показанная выше, является неполной. Существует третий &lt;a href=&quot;vtab#hiddencol&quot;&gt;скрытый столбец с&lt;/a&gt; именем &amp;laquo;схема&amp;raquo;, который определяет, какая &lt;a href=&quot;lang_attach&quot;&gt;база данных с функцией ATTACH&lt;/a&gt; должна быть прочитана или записана. Поскольку столбец &amp;laquo;схема&amp;raquo; скрыт, его можно использовать в качестве параметра, когда SQLITE_DBPAGE вызывается как &lt;a href=&quot;vtab#tabfunc2&quot;&gt;функция,&lt;/a&gt; возвращающая табличное значение .</target>
        </trans-unit>
        <trans-unit id="518c52e0806550bfb6aa69b1fed15fbc4111a9ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE virtual table read/write table that provides direct access to the underlying disk file on a page-by-page basis. The virtual table appears to have a schema like this:</source>
          <target state="translated">Виртуальная таблица SQLITE_DBPAGE для чтения/записи,которая обеспечивает прямой доступ к базовому файлу диска по страницам.Похоже,что виртуальная таблица имеет такую схему:</target>
        </trans-unit>
        <trans-unit id="c1930c1236dfcd2ca69ef991dff0ceab5ad493f1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSE означает, что сериализация базы данных в аргументе P хранится в памяти, полученной из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; и что SQLite должен стать владельцем этой памяти и автоматически освободить ее, когда он закончит ее использовать. Без этого флага вызывающая сторона отвечает за освобождение любой динамически выделяемой памяти.</target>
        </trans-unit>
        <trans-unit id="76631b67d929ebcd295444bce3ec1691bb16c502" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSE означает, что сериализация базы данных в аргументе P хранится в памяти, полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; и что SQLite должен стать владельцем этой памяти и автоматически освободить ее, когда он закончит ее использовать. Без этого флага вызывающая сторона отвечает за освобождение любой динамически выделяемой памяти.</target>
        </trans-unit>
        <trans-unit id="fffd4707786aad32f12960ea601bc8b62704db6b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database should be treated as read-only.</source>
          <target state="translated">Флаг SQLITE_DESERIALIZE_READONLY означает,что десериализованная база данных должна рассматриваться как доступная только для чтения.</target>
        </trans-unit>
        <trans-unit id="684cad9c07969122877d4a208d11cefd54e63c00" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="translated">Флаг SQLITE_DESERIALIZE_RESIZEABLE означает, что SQLite разрешено увеличивать размер базы данных с помощью вызовов &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64 ()&lt;/a&gt; . Этот флаг следует использовать, только если также используется SQLITE_DESERIALIZE_FREEONCLOSE. Без этого флага десериализованная база данных не может увеличиваться в размере, превышающем количество байтов, указанное параметром M.</target>
        </trans-unit>
        <trans-unit id="80121a4afb11422b1c8bfdaf5caf6ca8a41c2e89" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="translated">Флаг SQLITE_DESERIALIZE_RESIZEABLE означает, что SQLite разрешено увеличивать размер базы данных с помощью вызовов &lt;a href=&quot;free&quot;&gt;sqlite3_realloc64 ()&lt;/a&gt; . Этот флаг следует использовать, только если также используется SQLITE_DESERIALIZE_FREEONCLOSE. Без этого флага десериализованная база данных не может увеличиваться в размере, превышающем количество байтов, указанное параметром M.</target>
        </trans-unit>
        <trans-unit id="19352bde546497cb9c8447fd1d7dfafe9e2fb83c" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function always gives the same output when the input parameters are the same. The &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is deterministic, for example, but &lt;a href=&quot;../lang_corefunc#randomblob&quot;&gt;randomblob()&lt;/a&gt; is not. Functions must be deterministic in order to be used in certain contexts such as with the WHERE clause of &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt; or in &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt;. SQLite might also optimize deterministic functions by factoring them out of inner loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a94dcf703cfcb3aebcafb1d5511712f18433c467" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function always gives the same output when the input parameters are the same. The &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is deterministic, for example, but &lt;a href=&quot;lang_corefunc#randomblob&quot;&gt;randomblob()&lt;/a&gt; is not. Functions must be deterministic in order to be used in certain contexts such as with the WHERE clause of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt; or in &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;. SQLite might also optimize deterministic functions by factoring them out of inner loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a817ebcb8adde635efe8cf6f019a45cbccc77452" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function will always maps the same inputs into the same output. The abs() function is deterministic, for example, but randomblob() is not.</source>
          <target state="translated">Флаг SQLITE_DETERMINISTIC означает,что новая функция всегда будет отображать одни и те же входы в один и тот же выход.Например,функция abs()является детерминированной,а randomblob()-нет.</target>
        </trans-unit>
        <trans-unit id="e7795e7dba3d35d408494ba100326feff56ac8bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in schema structures such as &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;../expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt;, or &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt;. The SQLITE_DIRECTONLY flags is a security feature which is recommended for all &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, and especially for functions that have side-effects or that could potentially leak sensitive information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd921523501ad6603970193474c7602b6fd6ef1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs nor in schema structures such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, or &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;. The SQLITE_DIRECTONLY flags is a security feature which is recommended for all &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, and especially for functions that have side-effects or that could potentially leak sensitive information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfa7a3aa99efd025281e40fa4911eb7511574c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="translated">Флаг SQLITE_DIRECTONLY означает, что функция может быть вызвана только из SQL верхнего уровня и не может использоваться в VIEW или TRIGGER. Это функция безопасности, которая рекомендуется для всех &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , имеющих побочные эффекты. Этот флаг не позволяет злоумышленнику добавить триггеры и представления в схему, а затем обманом заставить приложение с высокими привилегиями вызвать непредвиденные побочные эффекты при выполнении обычных запросов.</target>
        </trans-unit>
        <trans-unit id="ad5270c7d2917dccd93322da5fb7248f9aa949c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="translated">Флаг SQLITE_DIRECTONLY означает, что функция может быть вызвана только из SQL верхнего уровня и не может использоваться в VIEW или TRIGGER. Это функция безопасности, которая рекомендуется для всех &lt;a href=&quot;create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; , имеющих побочные эффекты. Этот флаг не позволяет злоумышленнику добавить триггеры и представления в схему, а затем обманом заставить приложение с высокими привилегиями вызвать непредвиденные побочные эффекты при выполнении обычных запросов.</target>
        </trans-unit>
        <trans-unit id="ec40aca0df374578f31a734ba1f44f72205f5695" translate="yes" xml:space="preserve">
          <source>The SQLITE_DONE result code indicates that an operation has completed. The SQLITE_DONE result code is most commonly seen as a return value from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicating that the SQL statement has run to completion. But SQLITE_DONE can also be returned by other multi-step interfaces such as &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;.</source>
          <target state="translated">Код результата SQLITE_DONE указывает, что операция завершена. Код результата SQLITE_DONE чаще всего рассматривается как возвращаемое значение от &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step (),&lt;/a&gt; указывающее, что оператор SQL выполнен до конца. Но SQLITE_DONE также может возвращаться другими многоступенчатыми интерфейсами, такими как &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb790f9dfaacb5c859298fcd4607429394630f86" translate="yes" xml:space="preserve">
          <source>The SQLITE_EMPTY result code is not currently used.</source>
          <target state="translated">В настоящее время код результата SQLITE_EMPTY не используется.</target>
        </trans-unit>
        <trans-unit id="ae12a93b43b3b42e7d80f8bbf0372c74ffcd4aa7" translate="yes" xml:space="preserve">
          <source>The SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE options are not documented in &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; document because they are not officially supported. What they do is activate the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; dot-commands in the command-line shell, which provide low-level tracing output for the logic that generates code for SELECT statements and WHERE clauses, respectively.</source>
          <target state="translated">Параметры SQLITE_ENABLE_SELECTTRACE и SQLITE_ENABLE_WHERETRACE не задокументированы в документе &lt;a href=&quot;compile&quot;&gt;параметров времени компиляции,&lt;/a&gt; поскольку они официально не поддерживаются. Что они делают, так это активируют точечные команды &amp;laquo;.selecttrace&amp;raquo; и &amp;laquo;.wheretrace&amp;raquo; в оболочке командной строки, которые обеспечивают вывод низкоуровневой трассировки для логики, генерирующей код для операторов SELECT и предложений WHERE, соответственно.</target>
        </trans-unit>
        <trans-unit id="270e8d29bbaf2c173c8af4cf652d5609825ae163" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR result code is a generic error code that is used when no other more specific error code is available.</source>
          <target state="translated">Код результата SQLITE_ERROR является общим кодом ошибки,который используется,когда нет другого более специфического кода ошибки.</target>
        </trans-unit>
        <trans-unit id="98c271c04ddb7b453a82bc99e0c9a2f05fc01521" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_MISSING_COLLSEQ result code means that an SQL statement could not be prepared because a collating sequence named in that SQL statement could not be located.</source>
          <target state="translated">Код результата SQLITE_ERROR_MISSING_COLLSEQ означает,что SQL-оператор не может быть подготовлен из-за того,что не может быть найдена коллекционная последовательность,названная в этом SQL-операторе.</target>
        </trans-unit>
        <trans-unit id="ba8f59027948d8336d219d332d3588711710c0d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_RETRY is used internally to provoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; (or one of its sibling routines for creating prepared statements) to try again to prepare a statement that failed with an error on the previous attempt.</source>
          <target state="translated">SQLITE_ERROR_RETRY используется внутренне, чтобы спровоцировать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; (или одну из его родственных подпрограмм для создания подготовленных операторов) на повторную попытку подготовить оператор, который завершился неудачно с ошибкой при предыдущей попытке.</target>
        </trans-unit>
        <trans-unit id="ccb2dd2db61b6baf0b7083d2230974437265ca99" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_SNAPSHOT result code might be returned when attempting to start a read transaction on an historical version of the database by using the &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface. If the historical snapshot is no longer available, then the read transaction will fail with the SQLITE_ERROR_SNAPSHOT. This error code is only possible if SQLite is compiled with &lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt;.</source>
          <target state="translated">Код результата SQLITE_ERROR_SNAPSHOT может быть возвращен при попытке начать транзакцию чтения в исторической версии базы данных с помощью интерфейса &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; . Если исторический снимок больше не доступен, транзакция чтения завершится ошибкой с SQLITE_ERROR_SNAPSHOT. Этот код ошибки возможен только в том случае, если SQLite скомпилирован с &lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cbfe2b69087f0c646cf57766f8596a36d37fac1" translate="yes" xml:space="preserve">
          <source>The SQLITE_EXTRA_DURABLE compile-time option that used to cause the default &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting to be EXTRA, rather than FULL. This option is no longer supported. Use &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS=3&lt;/a&gt; instead.</source>
          <target state="translated">Параметр времени компиляции SQLITE_EXTRA_DURABLE, который заставлял по умолчанию &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;синхронный&lt;/a&gt; параметр PRAGMA быть EXTRA, а не FULL. Этот вариант больше не поддерживается. &lt;a href=&quot;compile#default_synchronous&quot;&gt;Вместо&lt;/a&gt; этого используйте SQLITE_DEFAULT_SYNCHRONOUS = 3 .</target>
        </trans-unit>
        <trans-unit id="b13fb7c225046a481ec4f5c3de65895a35d5a534" translate="yes" xml:space="preserve">
          <source>The SQLITE_FORMAT error code is not currently used by SQLite.</source>
          <target state="translated">Код ошибки SQLITE_FORMAT в настоящее время не используется SQLite.</target>
        </trans-unit>
        <trans-unit id="26b0edcf7878a4f55c879fd1aba1c1f540342aa6" translate="yes" xml:space="preserve">
          <source>The SQLITE_FULL result code indicates that a write could not complete because the disk is full. Note that this error can occur when trying to write information into the main database file, or it can also occur when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">Код результата SQLITE_FULL указывает, что запись не может быть завершена из-за переполнения диска. Обратите внимание, что эта ошибка может возникнуть при попытке записать информацию в основной файл базы данных или при записи во &lt;a href=&quot;tempfiles&quot;&gt;временные файлы&lt;/a&gt; на диске .</target>
        </trans-unit>
        <trans-unit id="52c86e9943e29fd3d57282b842d9c3bedce88e03" translate="yes" xml:space="preserve">
          <source>The SQLITE_HISTORY environment variable, if it exists, specifies the name of the command-line editing history file</source>
          <target state="translated">Переменная окружения SQLITE_HISTORY,если она существует,задает имя файла истории редактирования из командной строки</target>
        </trans-unit>
        <trans-unit id="e10c2e4fcb65972fbd71d50bdb5c4ac5d88e54e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_INNOCUOUS flag means that the function is unlikely to cause problems even if misused. An innocuous function should have no side effects and should not depend on any values other than its input parameters. The &lt;a href=&quot;../lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is an example of an innocuous function. The &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt; is not innocuous because of its side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a2b2609c215ba1aae8c191414849f564b054dd" translate="yes" xml:space="preserve">
          <source>The SQLITE_INNOCUOUS flag means that the function is unlikely to cause problems even if misused. An innocuous function should have no side effects and should not depend on any values other than its input parameters. The &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs() function&lt;/a&gt; is an example of an innocuous function. The &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt; is not innocuous because of its side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521e2762edbf8211c7cbb9d7bfb58da8a1f086c6" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERNAL result code indicates an internal malfunction. In a working version of SQLite, an application should never see this result code. If application does encounter this result code, it shows that there is a bug in the database engine.</source>
          <target state="translated">Код результата SQLITE_INTERNAL указывает на внутреннюю неисправность.В рабочей версии SQLite приложение никогда не должно видеть такой код результата.Если приложение все же столкнется с таким кодом результата,это свидетельствует о наличии ошибки в движке БД.</target>
        </trans-unit>
        <trans-unit id="b38d579654b4f1182c07a8a6f5867deba9d19d28" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERRUPT result code indicates that an operation was interrupted by the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface. See also: &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;</source>
          <target state="translated">Код результата SQLITE_INTERRUPT указывает, что операция была прервана интерфейсом &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; . См. Также: &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c1b9bcba49ffcf44baa9a43853834f3537e3646" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite().</source>
          <target state="translated">Свойство SQLITE_IOCAP_ATOMIC означает,что все записи любого размера являются атомарными.Значения SQLITE_IOCAP_ATOMICnn означают,что записи блоков размером nnn байт,выровненных по адресу,который является целым числом,кратным nnn,являются атомными.Значение SQLITE_IOCAP_SAFE_APPEND означает,что когда данные добавляются к файлу,то сначала данные добавляются,а затем размер файла расширяется,никогда наоборот.Свойство SQLITE_IOCAP_SEQUENTIAL означает,что информация записывается на диск в том же порядке,в котором происходит обращение к функции xWrite().</target>
        </trans-unit>
        <trans-unit id="6cfdb556dc4a2d2c3aee5156579c0505409a3242" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite(). The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that after reboot following a crash or power loss, the only bytes in a file that were written at the application level might have changed and that adjacent bytes, even bytes within the same sector are guaranteed to be unchanged. The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN flag indicates that a file cannot be deleted when open. The SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on read-only media and cannot be changed even by processes with elevated privileges.</source>
          <target state="translated">Свойство SQLITE_IOCAP_ATOMIC означает,что все записи любого размера являются атомарными.Значения SQLITE_IOCAP_ATOMICnn означают,что записи блоков размером nnn байт,выровненных по адресу,который является целым числом,кратным nnn,являются атомными.Значение SQLITE_IOCAP_SAFE_APPEND означает,что когда данные добавляются к файлу,то сначала данные добавляются,а затем размер файла расширяется,никогда наоборот.Свойство SQLITE_IOCAP_SEQUENTIAL означает,что информация записывается на диск в том же порядке,в котором происходит обращение к функции xWrite().Свойство SQLITE_IOCAP_POWERSAFE_OVERWRITE означает,что после перезагрузки после сбоя или отключения питания единственные байты в файле,которые были записаны на уровне приложения,могли измениться,и что смежные байты,даже байты в пределах одного сектора,гарантированно остаются неизменными.Флаг SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN указывает,что файл не может быть удален при открытии.Флаг SQLITE_IOCAP_IMMUTABLE указывает,что файл находится на носителе только для чтения и не может быть изменен даже процессами с повышенными привилегиями.</target>
        </trans-unit>
        <trans-unit id="d6e9041084560f5cee1cd0f7e8b2669a77b404b5" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">Свойство SQLITE_IOCAP_BATCH_ATOMIC означает, что базовая файловая система поддерживает выполнение нескольких операций записи атомарно, когда эти операции записи заключены в скобки &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; и &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb11acb1c9a7effbe4c566606f90f111aeaa51c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">Свойство SQLITE_IOCAP_BATCH_ATOMIC означает, что базовая файловая система поддерживает выполнение нескольких операций записи атомарно, когда эти операции записи заключены в скобки &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; и &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abba910b15531d36f82588d451d0981d7b760afc" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR result code says that the operation could not finish because the operating system reported an I/O error.</source>
          <target state="translated">Код результата SQLITE_IOERR говорит,что операция не может быть завершена,так как операционная система сообщает об ошибке ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="6217042802c9b2c3161cf544abc5162c5330d1de" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xAccess method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_ACCESS - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xAccess объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2437ab6f22990f68cc3c6b6ab11345e11bf39ab" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xClose method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_ACCESS - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xClose объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2cdfe432186a7333ec15fb6eebac01e4168d421" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_BLOCKED error code is no longer used.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_BLOCKED больше не используется.</target>
        </trans-unit>
        <trans-unit id="d52b5d2e176049b701cd38566a1ec537e178a582" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CHECKRESERVEDLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xCheckReservedLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_CHECKRESERVEDLOCK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xCheckReservedLock в объекте &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ad717c7b1ad0bbb8f95440fa25c68effa605b2e" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed. See also: &lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</source>
          <target state="translated">Код ошибки SQLITE_IOERR_CONVPATH - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR, который&lt;/a&gt; используется только Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; и указывает на сбой системного вызова cygwin_conv_path (). См. Также: &lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1351f2d6333fe014b3d2efb02bea78fd2458ea8" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DELETE_NOENT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object failed because the file being deleted does not exist.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_DELETE_NOENT - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий, что метод xDelete объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; завершился неудачно, поскольку удаляемый файл не существует.</target>
        </trans-unit>
        <trans-unit id="3d4ef8736b02588e9ecd702311e3b92f76c71f42" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_CLOSE error code is no longer used.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_DIR_CLOSE больше не используется.</target>
        </trans-unit>
        <trans-unit id="257039837e1e28ae4885f94438deef37c72bcb03" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fsync() on a directory. The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; attempts to fsync() directories after creating or deleting certain files to ensure that those files will still appear in the filesystem following a power loss or system crash. This error code indicates a problem attempting to perform that fsync().</source>
          <target state="translated">Код ошибки SQLITE_IOERR_DIR_FSYNC - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода на уровне &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; при попытке вызвать fsync () в каталоге. Unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; пытается открыть каталоги fsync () после создания или удаления определенных файлов, чтобы гарантировать, что эти файлы по-прежнему будут отображаться в файловой системе после отключения питания или сбоя системы. Этот код ошибки указывает на проблему при попытке выполнить эту fsync ().</target>
        </trans-unit>
        <trans-unit id="703a40890c81baa50195428ead914670c8029bb4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSTAT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fstat() (or the equivalent) on a file in order to determine information such as the file size or access permissions.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_FSTAT - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода на уровне &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; при попытке вызвать fstat () (или эквивалент) для файла, чтобы определить такую ​​информацию, как размер файла или права доступа.</target>
        </trans-unit>
        <trans-unit id="4411956ede5824f9653b6f7288932d4d59a1407a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to flush previously written content out of OS and/or disk-control buffers and into persistent storage. In other words, this code indicates a problem with the fsync() system call in unix or the FlushFileBuffers() system call in windows.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_FSYNC - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода на уровне &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; при попытке сбросить ранее записанный контент из буферов ОС и / или управления диском в постоянное хранилище. Другими словами, этот код указывает на проблему с системным вызовом fsync () в unix или системным вызовом FlushFileBuffers () в Windows.</target>
        </trans-unit>
        <trans-unit id="1a80a6afbc34a7c330788ef9f803a0b5991e12c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_GETTEMPPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is unable to determine a suitable directory in which to place temporary files.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_GETTEMPPATH - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий, что &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; не может определить подходящий каталог для размещения временных файлов.</target>
        </trans-unit>
        <trans-unit id="cb09e15d8dd94c07c078d48b512a0e609b4a1ec7" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_LOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the advisory file locking logic. Usually an SQLITE_IOERR_LOCK error indicates a problem obtaining a &lt;a href=&quot;lockingv3#pending_lock&quot;&gt;PENDING lock&lt;/a&gt;. However it can also indicate miscellaneous locking errors on some of the specialized &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; used on Macs.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_LOCK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в логике блокировки рекомендательного файла. Обычно ошибка SQLITE_IOERR_LOCK указывает на проблему с получением &lt;a href=&quot;lockingv3#pending_lock&quot;&gt;блокировки PENDING&lt;/a&gt; . Однако он также может указывать на различные ошибки блокировки на некоторых специализированных &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; используемых на компьютерах Mac.</target>
        </trans-unit>
        <trans-unit id="928b9fb773e51d9b98d4eea6c5ad41e7a120edb9" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_MMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xFetch or xUnfetch methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map or unmap part of the database file into the process address space.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_MMAP - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методах xFetch или xUnfetch объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; при попытке сопоставить или отменить сопоставление части файла базы данных в адресное пространство процесса.</target>
        </trans-unit>
        <trans-unit id="f2e769d752ed0575abbf0db74e042a1d936197ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_NOMEM error code is sometimes returned by the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer to indicate that an operation could not be completed due to the inability to allocate sufficient memory. This error code is normally converted into &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; by the higher layers of SQLite before being returned to the application.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_NOMEM иногда возвращается уровнем &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; чтобы указать, что операция не может быть завершена из-за невозможности выделить достаточно памяти. Этот код ошибки обычно преобразуется в &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; более высокими уровнями SQLite перед возвратом в приложение.</target>
        </trans-unit>
        <trans-unit id="8545169dd7924f6c6604c36309fb09b48638942a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to read from a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_READ - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода на уровне &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; при попытке чтения из файла на диске. Эта ошибка может возникнуть из-за неисправности оборудования или из-за того, что файловая система была отключена, пока файл был открыт.</target>
        </trans-unit>
        <trans-unit id="1b973a2eb159aa040eee4609af08e2a1feaa8688" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SEEK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xRead or xWrite methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to seek a file descriptor to the beginning point of the file where the read or write is to occur.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_SEEK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методах xRead или xWrite в объекте &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; при попытке поиска файлового дескриптора до начальной точки файла, где должно произойти чтение или запись.</target>
        </trans-unit>
        <trans-unit id="105abf471dd5b51825236d9c7cd0fbb3eb6cb7cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMLOCK error code is no longer used.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_SHMLOCK больше не используется.</target>
        </trans-unit>
        <trans-unit id="19454e66c26708e9c7b0cf7de58d9fc407f5f14b" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map a shared memory segment into the process address space.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_SHMMAP - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xShmMap объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; при попытке сопоставить сегмент общей памяти в адресное пространство процесса.</target>
        </trans-unit>
        <trans-unit id="2dc7d56b93948bb563eb131a1d4f4001df7a785f" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMOPEN error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to open a new shared memory segment.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_SHMOPEN - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xShmMap объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; при попытке открыть новый сегмент разделяемой памяти.</target>
        </trans-unit>
        <trans-unit id="38683c7c8ec002f5c2268623f613c65a832d0744" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMSIZE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to enlarge a &lt;a href=&quot;walformat#shm&quot;&gt;&quot;shm&quot; file&lt;/a&gt; as part of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; transaction processing. This error may indicate that the underlying filesystem volume is out of space.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_SHMSIZE - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xShmMap в объекте &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; при попытке увеличить &lt;a href=&quot;walformat#shm&quot;&gt;файл &quot;shm&quot;&lt;/a&gt; как часть обработки транзакции в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; . Эта ошибка может указывать на то, что на томе базовой файловой системы не хватает места.</target>
        </trans-unit>
        <trans-unit id="9742197ad61d509380008ae49be67afbc4a5ec72" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHORT_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that a read attempt in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer was unable to obtain as many bytes as was requested. This might be due to a truncated file.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_SHORT_READ - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий, что при попытке чтения на уровне &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; не удалось получить столько байтов, сколько было запрошено. Это могло произойти из-за обрезанного файла.</target>
        </trans-unit>
        <trans-unit id="11a04eeb47de957ef3978cba210956d9cb5d652c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_TRUNCATE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to truncate a file to a smaller size.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_TRUNCATE - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода на уровне &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; при попытке усечь файл до меньшего размера.</target>
        </trans-unit>
        <trans-unit id="fea43ead41e3ee8f14dc4f738a5d86af22fa9867" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_UNLOCK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xDelete объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0b74fa52836b69d8f9666b0cd822fdd7307145f4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to obtain a read lock.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_UNLOCK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xLock объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; при попытке получить блокировку чтения.</target>
        </trans-unit>
        <trans-unit id="c346b35d66f482df6af0e3e742d33c4546a4dc99" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xUnlock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_UNLOCK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода в методе xUnlock объекта &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8d955a87bc68c4a0c5a3d4a1efee03acc84572" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_WRITE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to write into a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open. This error should not occur if the filesystem is full as there is a separate error code (SQLITE_FULL) for that purpose.</source>
          <target state="translated">Код ошибки SQLITE_IOERR_WRITE - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR,&lt;/a&gt; указывающий на ошибку ввода-вывода на уровне &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; при попытке записи в файл на диске. Эта ошибка может возникнуть из-за неисправности оборудования или из-за того, что файловая система была отключена, пока файл был открыт. Эта ошибка не должна возникать, если файловая система заполнена, поскольку для этой цели существует отдельный код ошибки (SQLITE_FULL).</target>
        </trans-unit>
        <trans-unit id="81a8e9c53d139815a64f5839604fdd22fadaa0e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code differs from &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; in that SQLITE_LOCKED indicates a conflict on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or on a connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;) whereas &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; indicates a conflict with a different database connection, probably in a different process.</source>
          <target state="translated">Код результата SQLITE_LOCKED отличается от &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; тем, что SQLITE_LOCKED указывает на конфликт в одном и том же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; (или в соединении с &lt;a href=&quot;sharedcache&quot;&gt;общим кешем&lt;/a&gt; ), тогда как &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; указывает на конфликт с другим соединением с базой данных, возможно, в другом процессе.</target>
        </trans-unit>
        <trans-unit id="a782dd7cfb6d09bfdc0225cdd7b256e70fd078f6" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code indicates that a write operation could not continue because of a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or a conflict with a different database connection that uses a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;.</source>
          <target state="translated">Код результата SQLITE_LOCKED указывает, что операция записи не может быть продолжена из-за конфликта внутри того же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; или конфликта с другим соединением с базой данных, которое использует &lt;a href=&quot;sharedcache&quot;&gt;общий кэш&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82a5261f187f8bb18f86e6b8f8f93ccb09c0a9f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHARECACHE error code works very much like the &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error code except that SQLITE_LOCKED_SHARECACHE is for separate database connections that share a cache whereas SQLITE_BUSY is for the much more common case of separate database connections that do not share the same cache. Also, the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; interfaces do not help in resolving SQLITE_LOCKED_SHAREDCACHE conflicts.</source>
          <target state="translated">Код ошибки SQLITE_LOCKED_SHARECACHE работает очень похоже на &lt;a href=&quot;rescode#busy&quot;&gt;код&lt;/a&gt; ошибки SQLITE_BUSY, за исключением того, что SQLITE_LOCKED_SHARECACHE предназначен для отдельных подключений к базе данных, которые совместно используют кеш, тогда как SQLITE_BUSY предназначен для гораздо более распространенного случая отдельных подключений к базе данных, которые не используют один и тот же кеш. Кроме того, интерфейсы &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; и &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; не помогают в разрешении конфликтов SQLITE_LOCKED_SHAREDCACHE.</target>
        </trans-unit>
        <trans-unit id="43736bf56a426c4b58c2bec90f4d48ac9099897c" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHAREDCACHE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicating that the locking conflict has occurred due to contention with a different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that happens to hold a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; with the database connection to which the error was returned. For example, if the other database connection is holding an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;exclusive lock&lt;/a&gt; on the database, then the database connection that receives this error will be unable to read or write any part of the database file unless it has the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; enabled.</source>
          <target state="translated">Код ошибки SQLITE_LOCKED_SHAREDCACHE - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED,&lt;/a&gt; указывающий на то, что конфликт блокировки возник из-за конфликта с другим &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединением&lt;/a&gt; с базой данных, которое, как правило, содержит &lt;a href=&quot;sharedcache&quot;&gt;общий кеш&lt;/a&gt; с соединением с базой данных, на которое была возвращена ошибка. Например, если другое соединение с базой данных удерживает &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;монопольную блокировку&lt;/a&gt; базы данных, то соединение с базой данных, которое получает эту ошибку, не сможет читать или записывать какую-либо часть файла базы данных, если для него не &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;включена прагма read_uncommitted&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cda10b684d70e57b826f0fa4c4df09ccba017aa" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_VTAB result code is not used by the SQLite core, but it is available for use by extensions. Virtual table implementations can return this result code to indicate that they cannot complete the current operation because of locks held by other threads or processes.</source>
          <target state="translated">Код результата SQLITE_LOCKED_VTAB не используется ядром SQLite,но доступен для использования расширениями.Реализации виртуальных таблиц могут возвращать этот код результата,чтобы показать,что они не могут завершить текущую операцию из-за блокировок,удерживаемых другими потоками или процессами.</target>
        </trans-unit>
        <trans-unit id="e51cbf2f4ccfc41ba0ad01c890bead2935bfa934" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCK_EXCLUSIVE lock must be held by a connection that wants to transition into our out of WAL mode. Transitioning into WAL mode is, therefore, just like any other write transaction, since every write transaction in rollback mode requires the SQLITE_LOCK_EXCLUSIVE lock. If the database file is already in WAL mode (hence if the desire it to change it back into rollback mode) and if there are two or more connections to the database, then each of these connections will be holding an SQLITE_LOCK_SHARED lock. That means that the SQLITE_LOCK_EXCLUSIVE cannot be obtained, and the transition out of WAL mode will not be allowed. This prevents one connection from deleting WAL mode out from under another. It also means that the only way to move a database from WAL mode into rollback mode is to close all but one connection to the database.</source>
          <target state="translated">Блокировка SQLITE_LOCK_EXCLUSIVE должна удерживаться соединением,которое хочет перейти в наш внештатный режим WAL.Таким образом,переход в режим WAL,как и любая другая транзакция на запись,так как каждая транзакция на запись в режиме отката требует блокировки SQLITE_LOCK_EXCLUSIVE.Если файл БД уже находится в режиме WAL (следовательно,если он захочет изменить его обратно в режим отката)и если к БД есть два или более соединения,то каждое из этих соединений будет иметь блокировку SQLITE_LOCK_SHARED.Это означает,что SQLITE_LOCK_EXCLUSIVE не может быть получен,и переход из режима WAL не будет разрешен.Это не позволяет одному соединению удалить режим WAL из-под другого.Это также означает,что единственный способ перевести БД из режима WAL в режим отката-это закрыть все соединения к БД,кроме одного.</target>
        </trans-unit>
        <trans-unit id="bc70544c321ca8a14f098bcf8a7d9ab71f0f189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_COLUMN compile-time parameter is used to set an upper bound on:</source>
          <target state="translated">Параметр компиляционного времени SQLITE_MAX_COLUMN используется для установки верхней границы:</target>
        </trans-unit>
        <trans-unit id="6525988f532e320cb712d12a43eb0921bdec4dc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_EXPR_DEPTH parameter determines the maximum expression tree depth. If the value is 0, then no limit is enforced. The current implementation has a default value of 1000.</source>
          <target state="translated">Параметр SQLITE_MAX_EXPR_DEPTH определяет максимальную глубину дерева выражений.Если значение равно 0,то ограничение не устанавливается.Текущая реализация имеет значение по умолчанию 1000.</target>
        </trans-unit>
        <trans-unit id="87bafa8316c35e0283e8d900b37b61b6cd965c07" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_FUNCTION_ARG parameter determines the maximum number of parameters that can be passed to an SQL function. The default value of this limit is 100. SQLite should work with functions that have thousands of parameters. However, we suspect that anybody who tries to invoke a function with more than a few parameters is really trying to find security exploits in systems that use SQLite, not do useful work, and so for that reason we have set this parameter relatively low.</source>
          <target state="translated">Параметр SQLITE_MAX_FUNCTION_ARG определяет максимальное количество параметров,которое может быть передано в SQL-функцию.Значение по умолчанию составляет 100.SQLite должен работать с функциями,имеющими тысячи параметров.Однако мы подозреваем,что любой,кто пытается вызвать функцию с более чем несколькими параметрами,действительно пытается найти эксплойты безопасности в системах,использующих SQLite,не делает полезной работы,поэтому мы установили этот параметр относительно низко.</target>
        </trans-unit>
        <trans-unit id="189922ac7fd95f7c9bc12f9ce7e9ab04f1adf79f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_PAGE_SIZE compile-time option is now silently ignored. The maximum page size is hard-coded at 65536 bytes.</source>
          <target state="translated">Опция времени компиляции SQLITE_MAX_PAGE_SIZE теперь беззвучно игнорируется.Максимальный размер страницы жестко закодирован в 65536 байт.</target>
        </trans-unit>
        <trans-unit id="862c9c40eeff1a20092e93732416f94a8f2c333f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMDEBUG option causes an instrumented &lt;a href=&quot;malloc#memdebug&quot;&gt;debugging memory allocator&lt;/a&gt; to be used as the default memory allocator within SQLite. The instrumented memory allocator checks for misuse of dynamically allocated memory. Examples of misuse include using memory after it is freed, writing off the ends of a memory allocation, freeing memory not previously obtained from the memory allocator, or failing to initialize newly allocated memory.</source>
          <target state="translated">Параметр SQLITE_MEMDEBUG заставляет инструментальный &lt;a href=&quot;malloc#memdebug&quot;&gt;отладочный распределитель памяти&lt;/a&gt; использоваться в качестве распределителя памяти по умолчанию в SQLite. Инструментальный распределитель памяти проверяет неправильное использование динамически выделяемой памяти. Примеры неправильного использования включают использование памяти после ее освобождения, списание концов выделения памяти, освобождение памяти, ранее не полученной от распределителя памяти, или неспособность инициализировать вновь выделенную память.</target>
        </trans-unit>
        <trans-unit id="d5d3984ec504895ac3fbb00da3cebcbba9dedbe7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT Virtual Table</source>
          <target state="translated">Виртуальная таблица SQLITE_MEMSTAT</target>
        </trans-unit>
        <trans-unit id="21d4cb84411a45f761656443b3561b46a357ff18" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">Расширение SQLITE_MEMSTAT реализует &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;виртуальную таблицу только&lt;/a&gt; с одноименным именем, которая обеспечивает доступ SQL к интерфейсам &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aad795204ac31f320600f752e689de3d922a2bd2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT table appears to have the following schema:</source>
          <target state="translated">Похоже,что таблица SQLITE_MEMSTAT имеет следующую схему:</target>
        </trans-unit>
        <trans-unit id="c5c71018abf94b8f9efc3c61940d93dd9b424da6" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT virtual table is a read-only table that can be queried to determine performance characteristics (primarily the amount of memory being used) of the current instance of SQLite. The SQLITE_MEMSTATE table is essentially a wrapper around the C-language APIs &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;. If the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.c&lt;/a&gt; source file is compiled with the -DSQLITE_ENABLE_ZIPVFS option, then SQLITE_MEMSTAT will also do some &lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt; calls to extract memory usage information about the &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; subsystem, if that subsystem as been licensed, installed, and is in use.</source>
          <target state="translated">Виртуальная таблица SQLITE_MEMSTAT - это таблица, доступная только для чтения, которую можно запросить, чтобы определить характеристики производительности (в первую очередь, объем используемой памяти) текущего экземпляра SQLite. Таблица SQLITE_MEMSTATE по сути является оболочкой API-интерфейсов языка C &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; и &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; . Если исходный файл &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.c&lt;/a&gt; скомпилирован с параметром -DSQLITE_ENABLE_ZIPVFS, то SQLITE_MEMSTAT также выполнит некоторые вызовы &lt;a href=&quot;c3ref/file_control&quot;&gt;управления файлами&lt;/a&gt; для извлечения информации об использовании &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;памяти&lt;/a&gt; подсистемой ZIPVFS , если эта подсистема лицензирована, установлена ​​и используется.</target>
        </trans-unit>
        <trans-unit id="3941fc28dfa25db6c38115ec794332d498f61a67" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISMATCH error code indicates a datatype mismatch.</source>
          <target state="translated">Код ошибки SQLITE_MISMATCH указывает на несовпадение типа данных.</target>
        </trans-unit>
        <trans-unit id="545fecc55ea90185cbbd63fd3b5f04d2c005fc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISUSE return code might be returned if the application uses any SQLite interface in a way that is undefined or unsupported. For example, using a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; after that prepared statement has been &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; might result in an SQLITE_MISUSE error.</source>
          <target state="translated">Код возврата SQLITE_MISUSE может быть возвращен, если приложение использует какой-либо интерфейс SQLite способом, который не определен или не поддерживается. Например, использование &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленного оператора&lt;/a&gt; после того, как этот подготовленный оператор был &lt;a href=&quot;c3ref/finalize&quot;&gt;завершен,&lt;/a&gt; может привести к ошибке SQLITE_MISUSE.</target>
        </trans-unit>
        <trans-unit id="7378cf4ec519f0105a315e8c418689ed2c8b9d03" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time option is no longer supported. Alternative mutex implementations can now be added at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb. *** Potentially incompatible change ***</source>
          <target state="translated">Параметр времени компиляции SQLITE_MUTEX_APPDEF больше не поддерживается. Альтернативные реализации мьютексов теперь можно добавлять во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; с командой &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; . *** Потенциально несовместимое изменение ***</target>
        </trans-unit>
        <trans-unit id="b652223c3c3d5b396101734631bda4e93654d297" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time parameter is no longer recognized. As a replacement, alternative &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex implementations&lt;/a&gt; may be created at runtime using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; operator and the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="translated">Параметр времени компиляции SQLITE_MUTEX_APPDEF больше не распознается. В качестве замены альтернативные &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;реализации мьютексов&lt;/a&gt; могут быть созданы во время выполнения с использованием &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; с оператором &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; и объектом &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2c0584076e7e10d1a5a608c7c90ebdabce289b7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_NOOP implementation is a set of routines that does no real locking and is appropriate for use in a single-threaded application. The SQLITE_MUTEX_PTHREADS and SQLITE_MUTEX_W32 implementations are appropriate for use on Unix and Windows.</source>
          <target state="translated">Реализация SQLITE_MUTEX_NOOP-это набор процедур,который не имеет реальной блокировки и подходит для использования в однопоточном приложении.Реализации SQLITE_MUTEX_PTHREADS и SQLITE_MUTEX_W32 подходят для использования на Unix и Windows.</target>
        </trans-unit>
        <trans-unit id="8dd7fbf941fcd0cbf4106dee4f6ff2100d3cc081" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOLFS error can be returned on systems that do not support large files when the database grows to be larger than what the filesystem can handle. &quot;NOLFS&quot; stands for &quot;NO Large File Support&quot;.</source>
          <target state="translated">Ошибка SQLITE_NOLFS может быть возвращена на системах,которые не поддерживают большие файлы,когда база данных становится больше,чем та,с которой может справиться файловая система.&quot;NOLFS&quot; означает &quot;NO Large File Support&quot;.</target>
        </trans-unit>
        <trans-unit id="1cda63147d327bf25d081e640b795908860d57cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOMEM result code indicates that SQLite was unable to allocate all the memory it needed to complete the operation. In other words, an internal call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; has failed in a case where the memory being allocated was required in order to continue the operation.</source>
          <target state="translated">Код результата SQLITE_NOMEM указывает, что SQLite не смог выделить всю память, необходимую для завершения операции. Другими словами, внутренний вызов &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; или &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc () завершился&lt;/a&gt; неудачно в случае, когда выделенная память требовалась для продолжения операции.</target>
        </trans-unit>
        <trans-unit id="90348aff38a7fe2d16e98097b8d995eefcd13821" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is also used internally by the SQLite implementation, but those internal uses are not exposed to the application.</source>
          <target state="translated">Код результата SQLITE_NOTFOUND также используется внутри реализации SQLite,но эти внутренние использования не подвержены приложению.</target>
        </trans-unit>
        <trans-unit id="04b892d49dde78c36512aea678380b1b3cb4740c" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is used in two contexts. SQLITE_NOTFOUND can be returned by the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface to indicate that the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;file control opcode&lt;/a&gt; passed as the third argument was not recognized by the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. SQLITE_NOTFOUND can also be returned by the xSetSystemCall() method of an &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="translated">Код результата SQLITE_NOTFOUND используется в двух контекстах. SQLITE_NOTFOUND может быть возвращен интерфейсом &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control (),&lt;/a&gt; чтобы указать, что &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;код операции управления файлом,&lt;/a&gt; переданный в качестве третьего аргумента, не был распознан базовой &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . SQLITE_NOTFOUND также может быть возвращен методом xSetSystemCall () объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2006836e7cf841369d470c41165b6630c3c15ae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE result code is not returned by any C/C++ interface. However, SQLITE_NOTICE (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual operation is taking place.</source>
          <target state="translated">Код результата SQLITE_NOTICE не возвращается ни одним интерфейсом C / C ++. Однако SQLITE_NOTICE (или, скорее, один из его &lt;a href=&quot;rescode#extrc&quot;&gt;расширенных кодов ошибок&lt;/a&gt; ) иногда используется в качестве первого аргумента в обратном вызове &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log (),&lt;/a&gt; чтобы указать, что происходит необычная операция.</target>
        </trans-unit>
        <trans-unit id="02cb61634cf3f64c55c04a76d9ecf0d6931de129" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_ROLLBACK result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; is rolled back.</source>
          <target state="translated">Код результата SQLITE_NOTICE_RECOVER_ROLLBACK передается в обратный вызов &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; при откате &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;горячего журнала&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f198e3499c541e2a07f04094a1095a33b4f9550d" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_WAL result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file is recovered.</source>
          <target state="translated">Код результата SQLITE_NOTICE_RECOVER_WAL передается в обратный вызов &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; при восстановлении файла базы данных в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee291eadebc9e5d4151fc8b157f062bbbf6ed568" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK result code means that the operation was successful and that there were no errors. Most other result codes indicate an error.</source>
          <target state="translated">Код результата SQLITE_OK означает,что операция прошла успешно и ошибок не было.Большинство других кодов результатов указывают на ошибку.</target>
        </trans-unit>
        <trans-unit id="db1bbd15a81f09ee87a066e983ed6980b9d26517" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK_LOAD_PERMANENTLY return code is useful to &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; that register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;, for example.</source>
          <target state="translated">Код возврата SQLITE_OK_LOAD_PERMANENTLY полезен, например, для &lt;a href=&quot;loadext&quot;&gt;загружаемых расширений,&lt;/a&gt; которые регистрируют новые &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6becbabbe4a84dad21c1b1544eb673040cac46e2" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_* options are unsupported. By this we mean that an SQLITE_OMIT_* option that omits code from the build in the current release might become a no-op in the next release. Or the other way around: an SQLITE_OMIT_* that is a no-op in the current release might cause code to be excluded in the next release. Also, not all SQLITE_OMIT_* options are tested. Some SQLITE_OMIT_* options might cause SQLite to malfunction and/or provide incorrect answers.</source>
          <target state="translated">Опции SQLITE_OMIT_*не поддерживаются.Это означает,что опция SQLITE_OMIT_*,опускающая код из сборки в текущем релизе,может стать неработоспособной в следующем релизе.Или наоборот:ошибка SQLITE_OMIT_*,которая в текущем релизе не поддерживается,может привести к тому,что код будет исключен из сборки в следующем релизе.Кроме того,не все опции SQLITE_OMIT_*проверяются.Некоторые опции SQLITE_OMIT_*могут привести к сбоям в работе SQLite и/или неправильным ответам.</target>
        </trans-unit>
        <trans-unit id="5d47886ed69e3788c34a2d6c9a632c5948855a34" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_MERGE_SORT option has been removed. The merge sorter is now a required component of SQLite.</source>
          <target state="translated">Удалена опция SQLITE_OMIT_MERGE_SORT.Сортировщик слияний теперь является необходимым компонентом SQLite.</target>
        </trans-unit>
        <trans-unit id="2ace5bda746aeaa5497bcf0c7e8c12395a91c1c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_PERM result code indicates that the requested access mode for a newly created database could not be provided.</source>
          <target state="translated">Код результата SQLITE_PERM указывает на то,что запрашиваемый режим доступа для вновь созданной базы данных не может быть предоставлен.</target>
        </trans-unit>
        <trans-unit id="57074805a6a2909f8660b15999da8d8adc66e584" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="translated">Флаг SQLITE_PREPARE_NORMALIZE не работает. Раньше этот флаг требовался для любого подготовленного оператора, который хотел использовать интерфейс &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; . Однако интерфейс &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; теперь доступен для всех подготовленных операторов, независимо от того, используют они этот флаг или нет.</target>
        </trans-unit>
        <trans-unit id="1ad4cab077701a7da0038bd41b3f79ceedfd12d8" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="translated">Флаг SQLITE_PREPARE_NORMALIZE не работает. Раньше этот флаг требовался для любого подготовленного оператора, который хотел использовать интерфейс &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; . Однако интерфейс &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; теперь доступен для всех подготовленных операторов, независимо от того, используют они этот флаг или нет.</target>
        </trans-unit>
        <trans-unit id="a0438ba55e3894ec50e9427fa15e7d877e35f842" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NO_VTAB flag causes the SQL compiler to return an error (error code SQLITE_ERROR) if the statement uses any virtual tables.</source>
          <target state="translated">Флаг SQLITE_PREPARE_NO_VTAB заставляет SQL-компилятор возвращать ошибку (код ошибки SQLITE_ERROR),если оператор использует какие-либо виртуальные таблицы.</target>
        </trans-unit>
        <trans-unit id="68c6b699083a20e7dac515dfb0a940a1d2fa1d0a" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="translated">Флаг SQLITE_PREPARE_PERSISTENT - это подсказка планировщику запросов, что подготовленный оператор будет храниться в течение длительного времени и, вероятно, будет использоваться многократно. Без этого флага &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; предполагают, что подготовленный оператор будет использоваться только один или максимум несколько раз, а затем относительно скоро уничтожен с помощью &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; . Текущая реализация действует в соответствии с этой подсказкой, избегая использования дополнительной &lt;a href=&quot;malloc#lookaside&quot;&gt;памяти,&lt;/a&gt; чтобы не истощать ограниченный запас дополнительной памяти. В будущих версиях SQLite эта подсказка может действовать иначе.</target>
        </trans-unit>
        <trans-unit id="799dbb7451dd41ca217be627d63018af5431d1bf" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="translated">Флаг SQLITE_PREPARE_PERSISTENT - это подсказка планировщику запросов, что подготовленный оператор будет храниться в течение длительного времени и, вероятно, будет использоваться многократно. Без этого флага &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; и &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; предполагают, что подготовленный оператор будет использоваться только один или максимум несколько раз, а затем относительно скоро уничтожен с помощью &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; . Текущая реализация действует в соответствии с этой подсказкой, избегая использования дополнительной &lt;a href=&quot;../malloc#lookaside&quot;&gt;памяти,&lt;/a&gt; чтобы не истощать ограниченный запас дополнительной памяти. В будущих версиях SQLite эта подсказка может действовать иначе.</target>
        </trans-unit>
        <trans-unit id="2c11fb868fc472e55f703cb835b3c6a27d603969" translate="yes" xml:space="preserve">
          <source>The SQLITE_PROTOCOL result code indicates a problem with the file locking protocol used by SQLite. The SQLITE_PROTOCOL error is currently only returned when using &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and attempting to start a new transaction. There is a race condition that can occur when two separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; both try to start a transaction at the same time in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The loser of the race backs off and tries again, after a brief delay. If the same connection loses the locking race dozens of times over a span of multiple seconds, it will eventually give up and return SQLITE_PROTOCOL. The SQLITE_PROTOCOL error should appear in practice very, very rarely, and only when there are many separate processes all competing intensely to write to the same database.</source>
          <target state="translated">Код результата SQLITE_PROTOCOL указывает на проблему с протоколом блокировки файлов, используемым SQLite. Ошибка SQLITE_PROTOCOL в настоящее время возвращается только при использовании &lt;a href=&quot;wal&quot;&gt;режима WAL&lt;/a&gt; и попытке начать новую транзакцию. Когда два отдельных &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; одновременно пытаются запустить транзакцию в &lt;a href=&quot;wal&quot;&gt;режиме WAL,&lt;/a&gt; возникает состояние гонки . Проигравший в гонке отступает и пытается снова после небольшой задержки. Если одно и то же соединение десятки раз проигрывает в гонке блокировок в течение нескольких секунд, оно в конечном итоге завершится и вернет SQLITE_PROTOCOL. Ошибка SQLITE_PROTOCOL должна появляться на практике очень, очень редко и только тогда, когда существует множество отдельных процессов, все из которых активно конкурируют за запись в одну и ту же базу данных.</target>
        </trans-unit>
        <trans-unit id="2290c0085d649d3364cd3e13fd796218538f0c97" translate="yes" xml:space="preserve">
          <source>The SQLITE_RANGE error indices that the parameter number argument to one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; routines or the column number in one of the &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column&lt;/a&gt; routines is out of range.</source>
          <target state="translated">Ошибка SQLITE_RANGE указывает на то, что аргумент номера параметра для одной из подпрограмм &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; или номер столбца в одной из подпрограмм &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column&lt;/a&gt; находится вне допустимого диапазона.</target>
        </trans-unit>
        <trans-unit id="81db86b91239da795ab1877a821491920db31614" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY result code is returned when an attempt is made to alter some data for which the current database connection does not have write permission.</source>
          <target state="translated">Код результата SQLITE_READONLY возвращается при попытке изменить некоторые данные,на которые текущее подключение к БД не имеет права записи.</target>
        </trans-unit>
        <trans-unit id="20a2e61649ed0f39a9f887714e92e822fd9ead1d" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTINIT result code originates in the xShmMap method of a &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to indicate that the shared memory region used by &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; exists buts its content is unreliable and unusable by the current process since the current process does not have write permission on the shared memory region. (The shared memory region for WAL mode is normally a file with a &quot;-wal&quot; suffix that is mmapped into the process space. If the current process does not have write permission on that file, then it cannot write into shared memory.)</source>
          <target state="translated">Код результата SQLITE_READONLY_CANTINIT берет начало в методе xShmMap &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; чтобы указать, что область разделяемой памяти, используемая &lt;a href=&quot;wal&quot;&gt;режимом WAL,&lt;/a&gt; существует, но ее содержимое ненадежно и непригодно для использования текущим процессом, поскольку текущий процесс не имеет разрешения на запись в область разделяемой памяти. (Область общей памяти для режима WAL обычно представляет собой файл с суффиксом &amp;laquo;-wal&amp;raquo;, который отображается в пространстве процесса. Если текущий процесс не имеет разрешения на запись в этот файл, он не может записывать в общую память.)</target>
        </trans-unit>
        <trans-unit id="8cc5d69c49bd0049fa508081d686d1a3ef3d0153" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_CANTLOCK error code indicates that SQLite is unable to obtain a read lock on a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database because the shared-memory file associated with that database is read-only.</source>
          <target state="translated">Код ошибки SQLITE_READONLY_CANTLOCK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; . Код ошибки SQLITE_READONLY_CANTLOCK указывает, что SQLite не может получить блокировку чтения для базы данных в &lt;a href=&quot;wal&quot;&gt;режиме WAL,&lt;/a&gt; поскольку файл с общей памятью, связанный с этой базой данных, доступен только для чтения.</target>
        </trans-unit>
        <trans-unit id="19656bfe231a68e2b6cce42b55c5197d3d416be0" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DBMOVED error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_DBMOVED error code indicates that a database cannot be modified because the database file has been moved since it was opened, and so any attempt to modify the database might result in database corruption if the processes crashes because the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; would not be correctly named.</source>
          <target state="translated">Код ошибки SQLITE_READONLY_DBMOVED - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; . Код ошибки SQLITE_READONLY_DBMOVED указывает, что база данных не может быть изменена, потому что файл базы данных был перемещен с момента его открытия, и поэтому любая попытка изменения базы данных может привести к повреждению базы данных, если процессы выйдут из строя из-за неправильного имени &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнала отката&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41ecb30affe77245ceb751ab6c0b2e9fce929efd" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DIRECTORY result code indicates that the database is read-only because process does not have permission to create a journal file in the same directory as the database and the creation of a journal file is a prerequisite for writing.</source>
          <target state="translated">Код результата SQLITE_READONLY_DIRECTORY указывает на то,что БД доступна только для чтения,так как процесс не имеет права создавать файл журнала в том же каталоге,что и БД,и создание файла журнала является обязательным условием для записи.</target>
        </trans-unit>
        <trans-unit id="c2523ec31f0b9a2d33cf73109d61b1e043f8086c" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_RECOVERY error code indicates that a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database cannot be opened because the database file needs to be recovered and recovery requires write access but only read access is available.</source>
          <target state="translated">Код ошибки SQLITE_READONLY_RECOVERY - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; . Код ошибки SQLITE_READONLY_RECOVERY указывает, что база данных в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; не может быть открыта, потому что файл базы данных необходимо восстановить, а для восстановления требуется доступ для записи, но доступен только доступ для чтения.</target>
        </trans-unit>
        <trans-unit id="ba838fe9f900034dae5111194ba7ea1d5270d1c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_ROLLBACK error code indicates that a database cannot be opened because it has a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; that needs to be rolled back but cannot because the database is readonly.</source>
          <target state="translated">Код ошибки SQLITE_READONLY_ROLLBACK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; . Код ошибки SQLITE_READONLY_ROLLBACK указывает на то, что базу данных нельзя открыть, потому что у нее есть &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;горячий журнал,&lt;/a&gt; который необходимо откатить, но не может, потому что база данных доступна только для чтения.</target>
        </trans-unit>
        <trans-unit id="d25154fd2f20b85ded4823ebe97f48106c96d4d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ROW result code returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicates that another row of output is available.</source>
          <target state="translated">Код результата SQLITE_ROW, возвращаемый &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step (),&lt;/a&gt; указывает, что доступна другая строка вывода.</target>
        </trans-unit>
        <trans-unit id="1d91aee6732a465a4cc20090bf5eb9177f9e582c" translate="yes" xml:space="preserve">
          <source>The SQLITE_SCHEMA result code indicates that the database schema has changed. This result code can be returned from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; for a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that was generated using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. If the database schema was changed by some other process in between the time that the statement was prepared and the time the statement was run, this error can result.</source>
          <target state="translated">Код результата SQLITE_SCHEMA указывает, что схема базы данных изменилась. Этот код результата может быть возвращен из &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; для &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленного оператора,&lt;/a&gt; который был сгенерирован с помощью &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; . Если схема базы данных была изменена каким-то другим процессом между временем подготовки оператора и временем его выполнения, может возникнуть эта ошибка.</target>
        </trans-unit>
        <trans-unit id="bccaf372951fcf999b80b85d54115242255c5910" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT Virtual Table</source>
          <target state="translated">Виртуальная таблица SQLITE_STMT</target>
        </trans-unit>
        <trans-unit id="0210be179f988cfe689d56f75f4d1fa3e0b6bb8b" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;https://sqlite.org/src/file/ext/misc/memstat.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="translated">Расширение SQLITE_STMT также можно загрузить во время выполнения, скомпилировав расширение в общую библиотеку или DLL, используя исходный код на &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;https://sqlite.org/src/file/ext/misc/memstat.c&lt;/a&gt; и следуя инструкциям для как &lt;a href=&quot;loadext#build&quot;&gt;компилировать загружаемые расширения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c79456ebf36875bab38cefa2c6e55d9482f8dca7" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides information about all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Расширение SQLITE_STMT реализует &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;виртуальную таблицу только&lt;/a&gt; с одноименным именем, которая предоставляет информацию обо всех &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленных операторах,&lt;/a&gt; связанных с &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных .</target>
        </trans-unit>
        <trans-unit id="514c2473199b17afc5dd1d8c02362217c121606a" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Расширение SQLITE_STMT включено в сборках по умолчанию &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e53abd5cd3368a9c18b0e2f006747b4e8c1e98ad" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;SQLITE_ENABLE_STMTVTAB&lt;/a&gt; compile-time option to enable the SQLITE_STMT extension. The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;https://sqlite.org/src/file/ext/misc/stmt.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="translated">Расширение SQLITE_STMT включено в &lt;a href=&quot;amalgamation&quot;&gt;объединение,&lt;/a&gt; хотя по умолчанию оно отключено. Используйте параметр &lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_STMTVTAB, чтобы включить расширение SQLITE_STMT. Расширение SQLITE_STMT также можно загрузить во время выполнения, скомпилировав расширение в общую библиотеку или DLL, используя исходный код на &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;https://sqlite.org/src/file/ext/misc/stmt.c&lt;/a&gt; и следуя инструкциям для как &lt;a href=&quot;loadext#build&quot;&gt;компилировать загружаемые расширения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eff6d72f1420a16df254227915d0745e46f60ade" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table can also be used to access performance information about prepared statements, to aid in optimization an application. For example, to find out how much memory is being used by &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that have never been used, one could run:</source>
          <target state="translated">Виртуальная таблица SQLITE_STMT также может использоваться для доступа к информации о производительности подготовленных операторов, чтобы помочь в оптимизации приложения. Например, чтобы узнать, сколько памяти используется &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленными операторами&lt;/a&gt; , которые никогда не использовались, можно запустить:</target>
        </trans-unit>
        <trans-unit id="36a652edafe32e1a6a69623202e497c2b84971e5" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table is a read-only table that can be directly queried to access information about all prepared statements on the current database connection. For example:</source>
          <target state="translated">Виртуальная таблица SQLITE_STMT-это таблица,доступная только для чтения,которую можно запросить напрямую,чтобы получить доступ к информации обо всех подготовленных заявлениях по текущему подключению к базе данных.Например:</target>
        </trans-unit>
        <trans-unit id="c57e4bb46f13bf2108682321d36a64fbe9c7f037" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMTJRNL_SPILL compile-time option determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; start-time setting. That setting determines the size threshold above which &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journals&lt;/a&gt; are moved from memory to disk.</source>
          <target state="translated">Параметр времени компиляции SQLITE_STMTJRNL_SPILL определяет настройку по умолчанию для настройки &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;времени&lt;/a&gt; начала SQLITE_CONFIG_STMTJRNL_SPILL . Этот параметр определяет порог размера, при превышении которого &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;журналы операторов&lt;/a&gt; перемещаются из памяти на диск.</target>
        </trans-unit>
        <trans-unit id="53aa1b2835c1a75b5cdfb5b24f66527df47e52af" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="translated">Флаг SQLITE_SUBTYPE указывает SQLite, что функция может вызывать &lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype ()&lt;/a&gt; для проверки подтипов своих аргументов. Установка этого флага не имеет значения для скалярных или агрегированных пользовательских функций. Однако, если он не указан для пользовательской оконной функции, то любые подтипы, принадлежащие аргументам, переданным оконной функции, могут быть отброшены до вызова оконной функции (т.е. sqlite3_value_subtype () всегда будет возвращать 0).</target>
        </trans-unit>
        <trans-unit id="a9bfb18749058a748b6ef8d70f30272423e2e061" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="translated">Флаг SQLITE_SUBTYPE указывает SQLite, что функция может вызывать &lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype ()&lt;/a&gt; для проверки подтипов своих аргументов. Установка этого флага не имеет значения для скалярных или агрегированных пользовательских функций. Однако, если он не указан для пользовательской оконной функции, то любые подтипы, принадлежащие аргументам, переданным оконной функции, могут быть отброшены до вызова оконной функции (т.е. sqlite3_value_subtype () всегда будет возвращать 0).</target>
        </trans-unit>
        <trans-unit id="eebb912b265a126853dad1960970bce68414c982" translate="yes" xml:space="preserve">
          <source>The SQLITE_TMPDIR environment variable</source>
          <target state="translated">Переменная окружения SQLITE_TMPDIR</target>
        </trans-unit>
        <trans-unit id="c73fb526ebe5bd57bd3e299a92027075f6d77195" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code can also result when an oversized SQL statement is passed into one of the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interfaces. The maximum length of an SQL statement defaults to a much smaller value of 1,000,000 bytes. The maximum SQL statement length can be set at compile-time using &lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH&lt;/a&gt; or at run-time using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,...).</source>
          <target state="translated">Код ошибки SQLITE_TOOBIG также может возникать, когда оператор SQL слишком большого размера передается в один из интерфейсов &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . По умолчанию максимальная длина оператора SQL намного меньше - 1000000 байтов. Максимальную длину оператора SQL можно установить во время компиляции с помощью &lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH&lt;/a&gt; или во время выполнения с помощью &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="95a063038fc4fca17964bc0777d759cfc88b33bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code indicates that a string or BLOB was too large. The default maximum length of a string or BLOB in SQLite is 1,000,000,000 bytes. This maximum length can be changed at compile-time using the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; compile-time option, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,...) interface. The SQLITE_TOOBIG error results when SQLite encounters a string or BLOB that exceeds the compile-time or run-time limit.</source>
          <target state="translated">Код ошибки SQLITE_TOOBIG указывает, что строка или большой двоичный объект слишком велики. По умолчанию максимальная длина строки или большого двоичного объекта в SQLite составляет 1 000 000 000 байт. Эту максимальную длину можно изменить во время компиляции с помощью параметра &lt;a href=&quot;limits#max_length&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_MAX_LENGTH или во время выполнения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; , ...). Ошибка SQLITE_TOOBIG возникает, когда SQLite встречает строку или большой двоичный объект, превышающий предел времени компиляции или времени выполнения.</target>
        </trans-unit>
        <trans-unit id="b22248b709740e89a9f8d423ea84335819e1ee2a" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING result code is not returned by any C/C++ interface. However, SQLITE_WARNING (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual and possibly ill-advised operation is taking place.</source>
          <target state="translated">Код результата SQLITE_WARNING не возвращается ни одним интерфейсом C / C ++. Однако SQLITE_WARNING (или, скорее, один из его &lt;a href=&quot;rescode#extrc&quot;&gt;расширенных кодов ошибок&lt;/a&gt; ) иногда используется в качестве первого аргумента в обратном вызове &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log (),&lt;/a&gt; чтобы указать, что имеет место необычная и, возможно, непродуманная операция.</target>
        </trans-unit>
        <trans-unit id="bd54655a92d09c02b918de6e8114904fcbbd22b3" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING_AUTOINDEX result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; whenever &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; is used. This can serve as a warning to application designers that the database might benefit from additional indexes.</source>
          <target state="translated">Код результата SQLITE_WARNING_AUTOINDEX передается в обратный вызов &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; всякий раз, когда используется &lt;a href=&quot;optoverview#autoindex&quot;&gt;автоматическое индексирование&lt;/a&gt; . Это может служить предупреждением для разработчиков приложений о том, что для базы данных могут быть полезны дополнительные индексы.</target>
        </trans-unit>
        <trans-unit id="c76259d82167d5f943a68fb0352bace5b64fab37" translate="yes" xml:space="preserve">
          <source>The SQLite Amalgamation</source>
          <target state="translated">Амальгамация SQLite</target>
        </trans-unit>
        <trans-unit id="e5e12b48e05726457e7db136c89d439a466ab852" translate="yes" xml:space="preserve">
          <source>The SQLite Archive is a relatively new format. It was first described in in 2014. ZIP Archives and Tarballs, on the other hand, have been around for decades and are well-entrenched as standard formats. Most programmers know what a ZIP Archive or Tarball is, but if you say &quot;SQLite Archive&quot; you are more likely to get a reply of &quot;What?&quot; Tooling to process ZIP Archives and Tarballs is more likely to be installed on stock computers.</source>
          <target state="translated">Архив SQLite является относительно новым форматом.Впервые он был описан в 2014 году.С другой стороны,ZIP-архивы и Tarballs существуют уже несколько десятилетий и хорошо зарекомендовали себя в качестве стандартных форматов.Большинство программистов знают,что такое ZIP Архив или Tarball,но если вы скажете &quot;SQLite Архив&quot;,то скорее всего получите ответ &quot;Что? Инструмент для обработки ZIP архивов и Tarballs скорее всего будет установлен на стоковых компьютерах.</target>
        </trans-unit>
        <trans-unit id="14b38e43f93cb1f6666b258c1070654e3f60d3ab" translate="yes" xml:space="preserve">
          <source>The SQLite Bytecode Engine</source>
          <target state="translated">Движок байткода SQLite</target>
        </trans-unit>
        <trans-unit id="60d2d0a8c73ed165c49cdebcf186c3bd62509aba" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &quot;VFS&quot;</source>
          <target state="translated">Интерфейс операционной системы SQLite или &quot;VFS&quot;.</target>
        </trans-unit>
        <trans-unit id="67edc3d607c153611c830c05dc44105c120df169" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &amp;quot;VFS&amp;quot;</source>
          <target state="translated">Интерфейс ОС SQLite или &quot;VFS&quot;</target>
        </trans-unit>
        <trans-unit id="eb768474c2c960b1f80b5ec4636fc5c556432ed7" translate="yes" xml:space="preserve">
          <source>The SQLite Query Optimizer Overview</source>
          <target state="translated">Обзор SQLite Оптимизатор запросов</target>
        </trans-unit>
        <trans-unit id="656be9ece72b3b3c8af07774a0a4473889d5a0ca" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree Module</source>
          <target state="translated">Модуль SQLite R*Tree Module</target>
        </trans-unit>
        <trans-unit id="f7f3e9d21d121d5b3e8db61ea6e7dde70d17b4dd" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree module is implemented as a &lt;a href=&quot;c3ref/create_module&quot;&gt;virtual table&lt;/a&gt;. Each R*Tree index is a virtual table with an odd number of columns between 3 and 11. The first column is always a 64-bit signed integer primary key. The other columns are pairs, one pair per dimension, containing the minimum and maximum values for that dimension, respectively. A 1-dimensional R*Tree thus has 3 columns. A 2-dimensional R*Tree has 5 columns. A 3-dimensional R*Tree has 7 columns. A 4-dimensional R*Tree has 9 columns. And a 5-dimensional R*Tree has 11 columns. The SQLite R*Tree implementation does not support R*Trees wider than 5 dimensions.</source>
          <target state="translated">Модуль SQLite R * Tree реализован в виде &lt;a href=&quot;c3ref/create_module&quot;&gt;виртуальной таблицы&lt;/a&gt; . Каждый индекс R * Tree представляет собой виртуальную таблицу с нечетным числом столбцов от 3 до 11. Первый столбец всегда представляет собой 64-битный целочисленный первичный ключ со знаком. Остальные столбцы представляют собой пары, по одной паре на измерение, содержащие минимальное и максимальное значения для этого измерения соответственно. Таким образом, одномерное дерево R * имеет 3 столбца. Двумерное дерево R * имеет 5 столбцов. Трехмерное дерево R * состоит из 7 столбцов. В 4-мерном дереве R * 9 столбцов. В 5-мерном дереве R * 11 столбцов. Реализация SQLite R * Tree не поддерживает R * Trees шириной более 5 измерений.</target>
        </trans-unit>
        <trans-unit id="d26287506df7d739659f92d570a45374e9d6b203" translate="yes" xml:space="preserve">
          <source>The SQLite Zipfile Module</source>
          <target state="translated">Модуль Zip-файлов SQLite</target>
        </trans-unit>
        <trans-unit id="2a322992d7eadef1cbb665cdba826abcbe8d4bc9" translate="yes" xml:space="preserve">
          <source>The SQLite approach of storing the schema as text has advantages for an embedded relational database. For one, it means that the schema takes up less space in the database file. This is important since a common SQLite usage pattern is to have many small, separate database files instead of putting everything in one big global database file, which is the usual approach for client/server database engines. Since the schema is duplicated in each separate database file, it is important to keep the schema representation compact.</source>
          <target state="translated">SQLite-подход хранения схемы в виде текста имеет преимущества для встроенной реляционной базы данных.Во-первых,это означает,что схема занимает меньше места в файле БД.Это важно,поскольку общая схема использования SQLite заключается в том,чтобы иметь много маленьких,отдельных файлов базы данных вместо того,чтобы помещать все в один большой файл глобальной базы данных,что является обычным подходом для движков клиент/серверных баз данных.Поскольку схема дублируется в каждом отдельном файле базы данных,важно сохранить компактность представления схемы.</target>
        </trans-unit>
        <trans-unit id="4156bb8a5bb8b9775d5b39350cba56f0d4323350" translate="yes" xml:space="preserve">
          <source>The SQLite code is broken up into multiple repositories, each described in a separate section below.</source>
          <target state="translated">Код SQLite разбит на несколько репозиториев,каждый из которых описан в отдельном разделе ниже.</target>
        </trans-unit>
        <trans-unit id="50c10f7a2161303f10be1e978ecf9c20c8b5ff8a" translate="yes" xml:space="preserve">
          <source>The SQLite community has been a kind, welcoming and well-mannered community since its inception nearly two decades ago. In that time many of the qualities we've worked hard to bring to our project - safety, consistency, usability and integrity among them - have become part of our community's culture as well. Much like the care and effort we've put into securing the longevity of SQLite, we'd like to do the same for that community by clarifying our goals and expectations for all involved. To that end the SQLite project has officially adopted the &lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Mozilla Community Participation Guidelines&lt;/a&gt; as its Code of Conduct with the exception that the reporting email address is changed to &lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.org&lt;/a&gt;. While we are not doing so in reaction to any current or ongoing issues, we believe that this will be a helpful part of maintaining the long-term sustainability of the project.</source>
          <target state="translated">Сообщество SQLite было добрым, гостеприимным и воспитанным сообществом с момента его создания почти два десятилетия назад. В то время многие из качеств , мы упорно трудились , чтобы довести до нашего проекта - безопасность, согласованность, удобство использования и целостности среди них - стали частью культуры нашего сообщества , а также. Подобно той заботе и усилиям, которые мы вложили в обеспечение долговечности SQLite, мы хотели бы сделать то же самое для этого сообщества, прояснив наши цели и ожидания для всех участников. С этой целью проект SQLite официально принял &lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Руководство по участию сообщества Mozilla в&lt;/a&gt; качестве своего Кодекса поведения, за исключением того, что адрес электронной почты для отчетности был изменен на &lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.org.&lt;/a&gt;. Хотя мы не делаем этого в ответ на какие-либо текущие или текущие проблемы, мы полагаем, что это будет полезной частью поддержания долгосрочной устойчивости проекта.</target>
        </trans-unit>
        <trans-unit id="6e54c3c7cfbe74cbcff4d32cf11ceb85c2d59225" translate="yes" xml:space="preserve">
          <source>The SQLite core and its memory allocation subsystem provides the following capabilities:</source>
          <target state="translated">Ядро SQLite и его подсистема распределения памяти предоставляют следующие возможности:</target>
        </trans-unit>
        <trans-unit id="4a8db7c1ed47d07dc8525eeb4fe9e3c2cadccf8a" translate="yes" xml:space="preserve">
          <source>The SQLite core calls the xBestIndex method when it is compiling a query that involves a virtual table. In other words, SQLite calls this method when it is running &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or the equivalent. By calling this method, the SQLite core is saying to the virtual table that it needs to access some subset of the rows in the virtual table and it wants to know the most efficient way to do that access. The xBestIndex method replies with information that the SQLite core can then use to conduct an efficient search of the virtual table.</source>
          <target state="translated">Ядро SQLite вызывает метод xBestIndex при компиляции запроса, включающего виртуальную таблицу. Другими словами, SQLite вызывает этот метод при выполнении &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или аналогичного. Вызывая этот метод, ядро ​​SQLite сообщает виртуальной таблице, что ему необходимо получить доступ к некоторому подмножеству строк в виртуальной таблице, и оно хочет знать наиболее эффективный способ сделать этот доступ. Метод xBestIndex отвечает информацией, которую ядро ​​SQLite может затем использовать для проведения эффективного поиска в виртуальной таблице.</target>
        </trans-unit>
        <trans-unit id="0101337cc0cb6fad83f4b1e21e8fd59c6d10699a" translate="yes" xml:space="preserve">
          <source>The SQLite core communicates with the xBestIndex method by filling in certain fields of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure and passing a pointer to that structure into xBestIndex as the second parameter. The xBestIndex method fills out other fields of this structure which forms the reply. The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure looks like this:</source>
          <target state="translated">Ядро SQLite взаимодействует с методом xBestIndex, заполняя определенные поля структуры &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; и передавая указатель на эту структуру в xBestIndex в качестве второго параметра. Метод xBestIndex заполняет другие поля этой структуры, которая формирует ответ. Структура &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="d592f9a3c73be507b58cc4d8ef9e1e11527c40f2" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5665 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="translated">Ядро SQLite содержит 5665 операторов &lt;code&gt;assert()&lt;/code&gt; которые проверяют предварительные и постусловия функций и инварианты цикла. Assert () - это макрос, который является стандартной частью ANSI-C. Аргумент - это логическое значение, которое всегда считается истинным. Если утверждение ложно, программа выводит сообщение об ошибке и останавливается.</target>
        </trans-unit>
        <trans-unit id="7a7923d469bddb357e4bafd2e77a5357a3ce8703" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5855 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a046e08f75eaccd925ae647cf15c7aa3a8226b9" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;SQLITE_FCNTL_SYNC_OMITTED&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; to the VFS in place of a call to xSync if the database has &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF.</source>
          <target state="translated">Ядро SQLite вызывает &lt;a href=&quot;c3ref/file_control&quot;&gt;файловый элемент управления &lt;/a&gt;&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;SQLITE_FCNTL_SYNC_OMITTED&lt;/a&gt; для VFS вместо вызова xSync, если для базы данных &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;синхронный PRAGMA&lt;/a&gt; установлен на OFF.</target>
        </trans-unit>
        <trans-unit id="9454a146cdf6bd63746f75afc554dedcf8a89f3d" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes this method in order to find the value for the N-th column of the current row. N is zero-based so the first column is numbered 0. The xColumn method may return its result back to SQLite using one of the following interface:</source>
          <target state="translated">Ядро SQLite вызывает этот метод,чтобы найти значение для N-го столбца текущей строки.N-нулевой,поэтому первый столбец нумеруется 0.Метод xColumn может вернуть свой результат обратно в SQLite,используя один из следующих интерфейсов:</target>
        </trans-unit>
        <trans-unit id="81909f2a4a51a96b134a34a4888c44983e2d76d3" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these routines for thread synchronization. Though they are intended for internal use by SQLite, code that links against SQLite is permitted to use any of these routines.</source>
          <target state="translated">Ядро SQLite использует эти подпрограммы для синхронизации потоков.Хотя они предназначены для внутреннего использования SQLite,код,который ссылается на SQLite,может использовать любую из этих процедур.</target>
        </trans-unit>
        <trans-unit id="922f1172309b4b736f1e305e3916cca7c4256be1" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9334c44f83a523ef26ab7a77c74c4218d746143" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22d82769d3da3cfaaf7c30bf60dfe3d4e431d6a" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific VFS implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="translated">Ядро SQLite использует эти три подпрограммы для всех своих собственных потребностей в выделении внутренней памяти.&quot;Ядро&quot; в предыдущем предложении не включает в себя реализацию VFS,специфичную для операционной системы.В Windows VFS для некоторых операций используется нативная malloc()и free().</target>
        </trans-unit>
        <trans-unit id="310e86b319144a9b8ab497d9dda0fd59a92fa402" translate="yes" xml:space="preserve">
          <source>The SQLite core will call &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; early. The auxiliary C code file can contain an implementation of sqlite3_initialize() that registers an appropriate VFS and also perhaps initializes an alternative mutex system (if mutexes are required) or does any memory allocation subsystem initialization that is required. The SQLite core never calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; but it is part of the official SQLite API and is not otherwise provided when compiled with -DSQLITE_OS_OTHER=1, so the auxiliary C code file should probably provide it for completeness.</source>
          <target state="translated">Ядро SQLite вызовет &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; раньше. Вспомогательный файл кода C может содержать реализацию sqlite3_initialize (), которая регистрирует соответствующую VFS, а также, возможно, инициализирует альтернативную систему мьютексов (если мьютексы требуются) или выполняет инициализацию любой подсистемы распределения памяти, которая требуется. Ядро SQLite никогда не вызывает &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown (),&lt;/a&gt; но оно является частью официального API SQLite и не предоставляется иным образом при компиляции с -DSQLITE_OS_OTHER = 1, поэтому вспомогательный файл кода C, вероятно, должен обеспечивать его для полноты.</target>
        </trans-unit>
        <trans-unit id="a3389235261ef05c3ad08031ba3272b1839ea345" translate="yes" xml:space="preserve">
          <source>The SQLite core, including the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, has 100% branch test coverage under &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; in its default configuration as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;. Extensions such as FTS3 and RTree are excluded from this analysis.</source>
          <target state="translated">Ядро SQLite, включая unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; , имеет 100% тестовое покрытие &lt;a href=&quot;th3&quot;&gt;ветвлений&lt;/a&gt; под TH3 в его конфигурации по умолчанию, как измерено &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; . Такие расширения, как FTS3 и RTree, исключены из этого анализа.</target>
        </trans-unit>
        <trans-unit id="25f0f08e26b5d1ff28a9d0772acbc6ec5d4dc8bf" translate="yes" xml:space="preserve">
          <source>The SQLite database allows multiple simultaneous readers or a single writer but not both. If any process is writing to the database no other process is allows to read or write. If any process is reading the database other processes are allowed to read but not write. The entire database shared a single lock.</source>
          <target state="translated">База данных SQLite позволяет использовать несколько одновременных читателей или один пишущий файл,но не оба.Если какой-либо процесс записи в базу данных не разрешен,то никакой другой процесс не разрешен для чтения или записи.Если какой-то процесс читает базу данных,то другим процессам разрешено читать,но не записывать.Вся база данных имеет один замок.</target>
        </trans-unit>
        <trans-unit id="c9e7754ee2f8ef030d3e0c4851d0ab23e5bf681e" translate="yes" xml:space="preserve">
          <source>The SQLite database file (&quot;self2014.sqlar&quot;) is about a half percent smaller than the equivalent ODP file! How can this be? Apparently the ZIP archive generator logic in NeoOffice is not as efficient as it could be, because when the same pile-of-files is recompressed using the command-line &quot;zip&quot; utility, one gets a file (&quot;zip.odp&quot;) that is smaller still, by another half percent, as seen in the third line above. So, a well-written ZIP archive can be slightly smaller than the equivalent SQLite database, as one would expect. But the difference is slight. The key take-away is that an SQLite database is size-competitive with a ZIP archive.</source>
          <target state="translated">Файл базы данных SQLite (&quot;self2014.sqlar&quot;)примерно на полпроцента меньше,чем эквивалентный файл ODP! Как это может быть? Видимо,логика генератора ZIP-архивов в NeoOffice не так эффективна,как могла бы быть,потому что при повторном сжатии одной и той же кучи файлов с помощью утилиты командной строки &quot;zip&quot;,получается файл (&quot;zip.odp&quot;),который еще на полпроцента меньше,как видно из третьей строки выше.Таким образом,хорошо написанный ZIP-архив может быть чуть меньше эквивалентной базы данных SQLite,как и следовало ожидать.Но разница небольшая.Ключевым моментом является то,что база данных SQLite конкурирует по размеру с ZIP-архивом.</target>
        </trans-unit>
        <trans-unit id="20b6f43ea15deb4c44a24b00c6944cb60a4b8d86" translate="yes" xml:space="preserve">
          <source>The SQLite database file format is also stable. All releases of SQLite version 3 can read and write database files created by the very first SQLite 3 release (version 3.0.0) going back to 2004-06-18. This is &quot;backwards compatibility&quot;. The developers promise to maintain backwards compatibility of the database file format for all future releases of SQLite 3. &quot;Forwards compatibility&quot; means that older releases of SQLite can also read and write databases created by newer releases. SQLite is usually, but not completely forwards compatible.</source>
          <target state="translated">Формат файлов базы данных SQLite также стабилен.Все выпуски SQLite версии 3 могут читать и записывать файлы баз данных,созданные самой первой версией SQLite 3 (версия 3.0.0),восходящей к 2004-06-18 годам.Это &quot;обратная совместимость&quot;.Разработчики обещают поддерживать обратную совместимость формата файлов базы данных для всех будущих релизов SQLite 3.&quot;Обратная совместимость&quot; означает,что старые версии SQLite также могут читать и писать базы данных,созданные новыми релизами.SQLite обычно,но не полностью совместим с форвардной совместимостью.</target>
        </trans-unit>
        <trans-unit id="a9896b9f0acf4d53bbeb650db03c052b65e4b39c" translate="yes" xml:space="preserve">
          <source>The SQLite developers use an on-line checklist to coordinate testing activity and to verify that all tests pass prior each SQLite release. &lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;Past checklists&lt;/a&gt; are retained for historical reference. (The checklists are read-only for anonymous internet viewers, but developers can log in and update checklist items in their web browsers.) The use of checklists for SQLite testing and other development activities is inspired by</source>
          <target state="translated">Разработчики SQLite используют интерактивный контрольный список для координации действий по тестированию и проверки того, что все тесты проходят до каждого выпуска SQLite. &lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;Прошлые контрольные списки&lt;/a&gt; сохраняются для исторической справки. (Контрольные списки доступны только для чтения для анонимных интернет-зрителей, но разработчики могут входить в систему и обновлять элементы контрольных списков в своих веб-браузерах.) Использование контрольных списков для тестирования SQLite и других мероприятий по разработке вдохновлено</target>
        </trans-unit>
        <trans-unit id="4f35e69a2395e538db8157dc3dbb68d5b6f19b6e" translate="yes" xml:space="preserve">
          <source>The SQLite file format is cross-platform. A database file written on one machine can be copied to and used on a different machine with a different architecture. Big-endian or little-endian, 32-bit or 64-bit does not matter. All machines use the same file format. Furthermore, the developers have pledged to keep the file format stable and backwards compatible, so newer versions of SQLite can read and write older database files.</source>
          <target state="translated">Формат файлов SQLite является кроссплатформенным.Файл базы данных,написанный на одной машине,может быть скопирован и использован на другой машине с другой архитектурой.Большой или маленький,32-битный или 64-битный не имеет значения.Все машины используют один и тот же формат файлов.Более того,разработчики обязались поддерживать стабильный и обратно совместимый формат файлов,чтобы более новые версии SQLite могли читать и писать старые файлы баз данных.</target>
        </trans-unit>
        <trans-unit id="a470f0b14147aeef040dd5381d7be5b2946cd2d3" translate="yes" xml:space="preserve">
          <source>The SQLite interface elements can be grouped into three categories:</source>
          <target state="translated">Элементы интерфейса SQLite можно сгруппировать в три категории:</target>
        </trans-unit>
        <trans-unit id="d2127d3816b52817dc6b4ce63d16e29894ba0878" translate="yes" xml:space="preserve">
          <source>The SQLite library consists of 102 files of C code (as of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;Version 3.9.0&lt;/a&gt; - 2015-10-14) in the core with 32 additional files that implement the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. Of the 102 main source files, about 75% are C code and about 25% are C header files. Most of these are &quot;source&quot; files in the sense that they are stored in the &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;SQLite version control system&lt;/a&gt; and are edited manually in an ordinary text editor. But some of the C-language files are generated using scripts or auxiliary programs. For example, the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt; file contains an LALR(1) grammar of the SQL language which is compiled down into are parser in files &quot;parse.c&quot; and &quot;parse.h&quot; by the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;.</source>
          <target state="translated">Библиотека SQLite состоит из 102 файлов кода C ( &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;начиная с версии 3.9.0&lt;/a&gt; - 2015-10-14) в ядре с 32 дополнительными файлами, реализующими &lt;a href=&quot;fts3&quot;&gt;расширения FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; , &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; , &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt; , &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt; и &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; . Из 102 основных исходных файлов около 75% представляют собой код C и около 25% - файлы заголовков C. Большинство из них являются &amp;laquo;исходными&amp;raquo; файлами в том смысле, что они хранятся в системе &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;контроля версий SQLite&lt;/a&gt; и редактируются вручную в обычном текстовом редакторе. Но некоторые файлы на языке C создаются с помощью сценариев или вспомогательных программ. Например, &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt;Файл содержит LALR (1) грамматику языка SQL, которая скомпилирована в парсер в файлах &quot;parse.c&quot; и &quot;parse.h&quot; с помощью &lt;a href=&quot;lemon&quot;&gt;генератора синтаксического анализатора Lemon&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fdfec2d5c500b7ac74b77876e6dfdaa2cdecb05" translate="yes" xml:space="preserve">
          <source>The SQLite library exports the string constant named &lt;b&gt;sqlite_version&lt;/b&gt; which contains the version number of the library. The header file contains a macro SQLITE_VERSION with the same information. If desired, a program can compare the SQLITE_VERSION macro against the &lt;b&gt;sqlite_version&lt;/b&gt; string constant to verify that the version number of the header file and the library match.</source>
          <target state="translated">Библиотека SQLite экспортирует &lt;b&gt;строковую&lt;/b&gt; константу с именем &lt;b&gt;sqlite_version,&lt;/b&gt; которая содержит номер версии библиотеки. Заголовочный файл содержит макрос SQLITE_VERSION с той же информацией. При желании программа может сравнить макрос &lt;b&gt;SQLITE_VERSION со&lt;/b&gt; строковой константой &lt;b&gt;sqlite_version,&lt;/b&gt; чтобы проверить соответствие номера версии файла заголовка и библиотеки.</target>
        </trans-unit>
        <trans-unit id="3f89e1941b8b597af45ed78a7c716ad9e7232f89" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;Tcl or Tcl/Tk&lt;/a&gt; script. SQLite began as a &lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;Tcl extension&lt;/a&gt; and the primary &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt; for SQLite is written in TCL. SQLite can be used with any programming language, but its connections to TCL run deep.</source>
          <target state="translated">Библиотека SQLite разработана таким образом, чтобы ее было очень легко использовать из сценариев &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;Tcl или Tcl / Tk&lt;/a&gt; . SQLite начинался как &lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;расширение Tcl,&lt;/a&gt; а основной &lt;a href=&quot;testing&quot;&gt;набор тестов&lt;/a&gt; для SQLite написан на TCL. SQLite можно использовать с любым языком программирования, но его связи с TCL глубоки.</target>
        </trans-unit>
        <trans-unit id="f0e8965a9252a8aca8a477026acb0a17bd84805b" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a C or C++ program. This document gives an overview of the C/C++ programming interface.</source>
          <target state="translated">Библиотека SQLite разработана таким образом,чтобы быть очень простой в использовании из программы на C или C++.В этом документе дается обзор программного интерфейса C/C++.</target>
        </trans-unit>
        <trans-unit id="0602c28d1654d00a16d8fb7d7632cbb5225eb5e8" translate="yes" xml:space="preserve">
          <source>The SQLite library may need less RAM since it shares pages with the operating-system page cache and does not always need its own copy of working pages.</source>
          <target state="translated">Библиотека SQLite может потреблять меньше оперативной памяти,так как разделяет страницы со страничным кэшем операционной системы и не всегда нуждается в собственной копии рабочих страниц.</target>
        </trans-unit>
        <trans-unit id="b68ac5f0b4be242c75b75b113e85779b0d2d24fb" translate="yes" xml:space="preserve">
          <source>The SQLite library supplies the VDBE with a pointer to the callback function and the &lt;b&gt;pUserData&lt;/b&gt; pointer. (Both the callback and the user data were originally passed in as arguments to the &lt;b&gt;sqlite_exec()&lt;/b&gt; API function.) The job of the VDBE is to come up with values for &lt;b&gt;nColumn&lt;/b&gt;, &lt;b&gt;azData[]&lt;/b&gt;, and &lt;b&gt;azColumnName[]&lt;/b&gt;. &lt;b&gt;nColumn&lt;/b&gt; is the number of columns in the results, of course. &lt;b&gt;azColumnName[]&lt;/b&gt; is an array of strings where each string is the name of one of the result columns. &lt;b&gt;azData[]&lt;/b&gt; is an array of strings holding the actual data.</source>
          <target state="translated">Библиотека SQLite предоставляет VDBE указатель на функцию обратного вызова и указатель &lt;b&gt;pUserData&lt;/b&gt; . (Как обратный вызов, так и пользовательские данные были изначально переданы в качестве аргументов функции API &lt;b&gt;sqlite_exec ()&lt;/b&gt; .) Задача VDBE - найти значения для &lt;b&gt;nColumn&lt;/b&gt; , &lt;b&gt;azData []&lt;/b&gt; и &lt;b&gt;azColumnName []&lt;/b&gt; . &lt;b&gt;nColumn&lt;/b&gt; - это, &lt;b&gt;конечно&lt;/b&gt; же, количество столбцов в результатах. &lt;b&gt;azColumnName []&lt;/b&gt; - это массив строк, где каждая строка - это имя одного из столбцов результата. &lt;b&gt;azData []&lt;/b&gt; - это массив строк, содержащих фактические данные.</target>
        </trans-unit>
        <trans-unit id="bec59993baf9ef121d8c6051be0842d34bbcc286" translate="yes" xml:space="preserve">
          <source>The SQLite library was compiled with &lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI=1&lt;/a&gt;.</source>
          <target state="translated">Библиотека SQLite была скомпилирована с &lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI = 1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d0a1ae4dbbafaabd699c25677e883038d9a262" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database or against a &lt;a href=&quot;#zipdb&quot;&gt;ZIP archive&lt;/a&gt;. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d928b1fc0f8261eeda1295ec9247d5985e38f7" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="translated">Проект SQLite предоставляет простую программу командной строки с именем &lt;b&gt;sqlite3&lt;/b&gt; (или &lt;b&gt;sqlite3.exe&lt;/b&gt; в Windows), которая позволяет пользователю вручную вводить и выполнять операторы SQL для базы данных SQLite. В этом документе содержится краткое введение в использование программы &lt;b&gt;sqlite3&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c372f90b5ac62e99b6357128106b66701a0411a3" translate="yes" xml:space="preserve">
          <source>The SQLite query planner will consider using an index on an expression when the expression that is indexed appears in the WHERE clause or in the ORDER BY clause of a query,</source>
          <target state="translated">Планировщик запросов SQLite будет рассматривать использование индекса на выражении,когда индексируемое выражение появляется в выражении WHERE или в выражении ORDER BY запроса,</target>
        </trans-unit>
        <trans-unit id="6dfbc1d18bbce16026bdcc86a5bffbbe6b1beb8b" translate="yes" xml:space="preserve">
          <source>The SQLite source code and the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; are stored together in a single repository. This one repository is all that is required to build the SQLite. The source repository is public and is readable by anonymous passers by on the internet.</source>
          <target state="translated">Исходный код SQLite и &lt;a href=&quot;testing#tcl&quot;&gt;набор тестов TCL&lt;/a&gt; хранятся вместе в одном репозитории. Этот единственный репозиторий - это все, что требуется для создания SQLite. Исходный репозиторий является общедоступным и доступен для чтения анонимным прохожим в Интернете.</target>
        </trans-unit>
        <trans-unit id="038ea963840df99a058067d40caa3b0cbd33dedb" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 1084 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1097f713df32cd3a870e17f648d7622d77d22cd2" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 992 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="translated">Исходный код SQLite содержит 992 использования макроса &lt;code&gt;testcase()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="200e89ebce3af8e9c7c026a8d18cac87a1da0318" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains literally thousands of assert() statements used to verify internal assumptions and subroutine preconditions and postconditions. These assert() statements are normally turned off (they generate no code) since turning them on makes SQLite run approximately three times slower. But for testing and analysis, it is useful to turn the assert() statements on. The SQLITE_DEBUG compile-time option does this.</source>
          <target state="translated">Исходный код SQLite содержит буквально тысячи выражений assert(),используемых для проверки внутренних предположений и подпрограммных предусловий и постусловий.Эти операторы assert()обычно отключаются (они не генерируют код),так как их включение делает работу SQLite примерно в три раза медленнее.Но для тестирования и анализа полезно включать операторы assert().Опция компиляции SQLITE_DEBUG делает это.</target>
        </trans-unit>
        <trans-unit id="7203161cfe6b6f33980e05611daeaed418ec5ae9" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains multiple implementations of these mutex routines. An appropriate implementation is selected automatically at compile-time. The following implementations are available in the SQLite core:</source>
          <target state="translated">Исходный код SQLite содержит несколько реализаций этих процедур мьютекса.Соответствующая реализация выбирается автоматически во время компиляции.В ядре SQLite доступны следующие реализации:</target>
        </trans-unit>
        <trans-unit id="519e11bf2b879a67e8b0e9134459d439da57e623" translate="yes" xml:space="preserve">
          <source>The SQLite source code includes several different memory allocation modules that can be selected at compile-time, or to a limited extent at start-time.</source>
          <target state="translated">Исходный код SQLite включает в себя несколько различных модулей выделения памяти,которые могут быть выбраны во время компиляции или в ограниченном объеме во время запуска.</target>
        </trans-unit>
        <trans-unit id="b459704fa1dc2f133cc1300473552a0909311a3d" translate="yes" xml:space="preserve">
          <source>The SQLite source code provides multiple implementations of these APIs, suitable for varying environments. If SQLite is compiled with the SQLITE_THREADSAFE=0 flag then a no-op mutex implementation that is fast but does no real mutual exclusion is provided. That implementation is suitable for use in single-threaded applications or applications that only use SQLite in a single thread. Other real mutex implementations are provided based on the underlying operating system.</source>
          <target state="translated">Исходный код SQLite предоставляет несколько реализаций этих API,подходящих для различных сред.Если SQLite скомпилирован с флагом SQLITE_THREADSAFE=0,то предоставляется реализация нулевого мьютекса,которая быстра,но не делает реального взаимного исключения.Такая реализация подходит для использования в однопоточных приложениях или приложениях,использующих SQLite только в одном потоке.Другие реальные реализации мьютекса предоставляются на основе базовой операционной системы.</target>
        </trans-unit>
        <trans-unit id="4146cdfa0001cfa5a66203144506da17c3646968" translate="yes" xml:space="preserve">
          <source>The SQLite source tree actually contains multiple versions of the memory allocator. The default high-speed version found in the &quot;mem1.c&quot; source file is used for most builds. But if the SQLITE_MEMDEBUG flag is enabled, a separate memory allocator the &quot;mem2.c&quot; source file is used instead. The mem2.c allocator implements lots of hooks to do error checking and to simulate memory allocation failures for testing purposes. Both of these allocators use the malloc()/free() implementation in the standard C library.</source>
          <target state="translated">Дерево исходников SQLite фактически содержит несколько версий аллокатора памяти.Для большинства сборок используется высокоскоростная версия по умолчанию,найденная в исходном файле &quot;mem1.c&quot;.Но если флаг SQLITE_MEMDEBUG включен,то вместо него используется отдельный аллокатор памяти-исходный файл &quot;mem2.c&quot;.В аллокаторе mem2.c реализовано множество крючков для проверки ошибок и симулирования ошибок выделения памяти для тестирования.Оба аллокатора используют реализацию malloc()/free()в стандартной библиотеке Си.</target>
        </trans-unit>
        <trans-unit id="4ba1f99040a37a507011c1205b1aef886c686eaf" translate="yes" xml:space="preserve">
          <source>The SQLite version identifier returned by the &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt; SQL function and the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C API and found in the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; macro is now a 64-digit SHA3-256 hash instead of a 40-digit SHA1 hash.</source>
          <target state="translated">Идентификатор версии SQLite, возвращаемый &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;функцией&lt;/a&gt; SQL sqlite_source_id () и API &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; C и найденный в макросе &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID,&lt;/a&gt; теперь является 64-значным хешем SHA3-256 вместо 40-значного хэша SHA1.</target>
        </trans-unit>
        <trans-unit id="0c3d7b8c49e09915f93340abac558621318ffacf" translate="yes" xml:space="preserve">
          <source>The SQLite website (&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;) uses SQLite itself, of course, and as of this writing (2015) it handles about 400K to 500K HTTP requests per day, about 15-20% of which are dynamic pages touching the database. Dynamic content uses &lt;a href=&quot;np1queryprob&quot;&gt;about 200 SQL statements per webpage&lt;/a&gt;. This setup runs on a single VM that shares a physical server with 23 others and yet still keeps the load average below 0.1 most of the time.</source>
          <target state="translated">Веб-сайт SQLite ( &lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt; ), конечно, использует сам SQLite, и на момент написания этой статьи (2015 г.) он обрабатывает от 400 до 500 тысяч HTTP-запросов в день, около 15-20% из которых являются динамическими. страницы, касающиеся базы данных. Динамическое содержимое использует &lt;a href=&quot;np1queryprob&quot;&gt;около 200 операторов SQL на веб-страницу&lt;/a&gt; . Эта установка работает на одной виртуальной машине, которая использует физический сервер совместно с 23 другими, но при этом большую часть времени сохраняет среднюю нагрузку ниже 0,1.</target>
        </trans-unit>
        <trans-unit id="dc3cc55be8b0168568fc5c682e636d1909810e07" translate="yes" xml:space="preserve">
          <source>The SQLite-specific printf() supports a new flag (!) called the &quot;alternate-form-2&quot; flag. The alternate-form-2 flag changes the processing of floating-point conversions in subtle ways so that the output is always an SQL-compatible text representation of a floating-point number - something that is not possible to achieve with standard-library printf(). For string substitutions, the alternate-form-2 flag causes the width and precision to be measured in characters instead of bytes, which simplifies processing of strings containing multi-byte UTF8 characters.</source>
          <target state="translated">SQLite-специфическая функция printf()поддерживает новый флаг (!),называемый флагом &quot;альтернативной формы-2&quot;.Флаг &quot;alternate-form-2&quot; тонким образом изменяет обработку преобразований с плавающей точкой так,что на выходе всегда получается SQL-совместимое текстовое представление числа с плавающей точкой-то,чего невозможно достичь с помощью стандартной библиотечной функции printf().Для подстановок строк флаг переменной формы-2 приводит к измерению ширины и точности в символах,а не в байтах,что упрощает обработку строк,содержащих многобайтовые символы UTF8.</target>
        </trans-unit>
        <trans-unit id="ab1ef24a2c3d89dbbf816b75c5ebad085546d51d" translate="yes" xml:space="preserve">
          <source>The SUM function detects integer overflow and converts to accumulating an approximate result using floating point numbers</source>
          <target state="translated">Функция SUM обнаруживает целочисленное переполнение и преобразует его в накопление приблизительного результата с помощью чисел с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="9d27464a9b4c0f0bdd924575293003beb50c81e1" translate="yes" xml:space="preserve">
          <source>The SUM() function throws an error on integer overflow.</source>
          <target state="translated">Функция SUM()выдает ошибку при целочисленном переполнении.</target>
        </trans-unit>
        <trans-unit id="7cc003a9427832539005b297ca058e10476ece22" translate="yes" xml:space="preserve">
          <source>The Session Extension</source>
          <target state="translated">Продление сессии</target>
        </trans-unit>
        <trans-unit id="0aa8192c55de05490d2622bfdb109c271f14a02d" translate="yes" xml:space="preserve">
          <source>The Spellfix1 Virtual Table</source>
          <target state="translated">Виртуальная таблица Spellfix1</target>
        </trans-unit>
        <trans-unit id="7366e749b34cc79e46fd62658a2ec13bee8b7b92" translate="yes" xml:space="preserve">
          <source>The T argument is the name of the target database file. The A argument is the name of the RBU database file. The S argument is the name of a &quot;state database&quot; used to store state information needed to resume the update after an interruption. The S argument can be NULL in which case the state information is stored in the RBU database in various tables whose names all begin with &quot;rbu_&quot;.</source>
          <target state="translated">Аргументом T является имя файла целевой базы данных.Аргумент A-имя файла базы данных RBU.Аргумент S-имя &quot;базы данных состояния&quot;,используемой для хранения информации о состоянии,необходимой для возобновления обновления после перерыва.Аргументом S может быть NULL,в этом случае информация о состоянии хранится в БД RBU в различных таблицах,имена которых начинаются с &quot;rbu_&quot;.</target>
        </trans-unit>
        <trans-unit id="b1d051df5b386db985e4647bccdf4da6546279c0" translate="yes" xml:space="preserve">
          <source>The TCL bindings transfer data without necessarily doing a conversion to a string.</source>
          <target state="translated">TCL-связки передают данные без обязательного преобразования в строку.</target>
        </trans-unit>
        <trans-unit id="65bc381e62f8723019edd6efca853c02189bf80a" translate="yes" xml:space="preserve">
          <source>The TCL interface for SQLite is a small module that is added into the regular amalgamation. The result is a new amalgamated source file called &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot;. This single source file is all that is needed to generate a shared library that can be loaded into a standard &lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;tclsh&lt;/a&gt; or &lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;wish&lt;/a&gt; using the &lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;TCL load command&lt;/a&gt;, or to generate a standalone tclsh that comes with SQLite built in. A copy of the tcl amalgamation is included on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file in the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">Интерфейс TCL для SQLite - это небольшой модуль, который добавляется в обычное объединение. Результатом является новый объединенный исходный файл под названием &amp;laquo; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &amp;raquo;. Этот единственный исходный файл - это все, что необходимо для создания общей библиотеки, которую можно загрузить в стандартный &lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;tclsh&lt;/a&gt; или по &lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;желанию&lt;/a&gt; с помощью команды &lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;загрузки TCL&lt;/a&gt; , или для создания автономного tclsh, который поставляется со встроенным SQLite. Копия объединения tcl является включены на &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;страницу загрузки&lt;/a&gt; в виде файла в архиве &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9e41f74fbcda169959b0e1c5ad24699dcf79aca" translate="yes" xml:space="preserve">
          <source>The TEMP database file is very similar to auxiliary database files added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement, though with a few special properties. The TEMP database is always automatically deleted when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed. The TEMP database always uses the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous=OFF&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=PERSIST&lt;/a&gt; PRAGMA settings. And, the TEMP database cannot be used with &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; nor can another process &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; the TEMP database.</source>
          <target state="translated">Файл базы данных TEMP очень похож на файлы вспомогательной базы данных, добавленные с помощью оператора &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; , хотя и с некоторыми специальными свойствами. База данных TEMP всегда автоматически удаляется при закрытии &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных . База данных TEMP всегда использует настройки &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous = OFF&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = PERSIST&lt;/a&gt; PRAGMA. И база данных TEMP не может использоваться с &lt;a href=&quot;lang_detach&quot;&gt;DETACH,&lt;/a&gt; а другой процесс не может &lt;a href=&quot;lang_attach&quot;&gt;ПРИСОЕДИНЯТЬСЯ&lt;/a&gt; к базе данных TEMP.</target>
        </trans-unit>
        <trans-unit id="53f0498bc726c9a2250102fc1ce88dd0e04a9743" translate="yes" xml:space="preserve">
          <source>The TEMP or TEMPORARY keyword is removed if it occurs after the initial CREATE keyword.</source>
          <target state="translated">Ключевое слово TEMP или TEMPORARY удаляется,если оно появляется после начального ключевого слова CREATE.</target>
        </trans-unit>
        <trans-unit id="4b9ade3b04856b7f86ec94b71b3743aaff256ca8" translate="yes" xml:space="preserve">
          <source>The TEMP schema always has synchronous=OFF since the content of of TEMP is ephemeral and is not expected to survive a power outage. Attempts to change the synchronous setting for TEMP are silently ignored.</source>
          <target state="translated">Схема TEMP всегда имеет синхронный=OFF,так как содержание TEMP является эфемерным и,как ожидается,не выдержит перебоев в электроснабжении.Попытки изменить синхронную настройку для TEMP молча игнорируются.</target>
        </trans-unit>
        <trans-unit id="dd8090269fd066de5e15019d6f63ecc9dd8e6b9f" translate="yes" xml:space="preserve">
          <source>The TEMP_STORE and DEFAULT_TEMP_STORE pragmas now work.</source>
          <target state="translated">Теперь работают прагмы TEMP_STORE и DEFAULT_TEMP_STORE.</target>
        </trans-unit>
        <trans-unit id="5dbd6ac1d86267c3b2604d6573027830c458f6aa" translate="yes" xml:space="preserve">
          <source>The TH3 program generator is a TCL script named &quot;&lt;code&gt;mkth3.tcl&lt;/code&gt;&quot;. To generate a test program, one has merely to run this script and supply the names of files containing test modules and configurations on the command line. Test modules are files that use the &quot;&lt;code&gt;.test&lt;/code&gt;&quot; suffix and configurations are files that use the &quot;&lt;code&gt;.cfg&lt;/code&gt;&quot; suffix. A typical invocation of mkth3.tcl might look something like the following:</source>
          <target state="translated">Генератор программы TH3 - это сценарий TCL с именем &amp;laquo; &lt;code&gt;mkth3.tcl&lt;/code&gt; &amp;raquo;. Чтобы сгенерировать тестовую программу, нужно просто запустить этот сценарий и указать имена файлов, содержащих тестовые модули и конфигурации, в командной строке. Тестовые модули - это файлы с суффиксом &amp;laquo; &lt;code&gt;.test&lt;/code&gt; &amp;raquo;, а конфигурации - это файлы с суффиксом &amp;laquo; &lt;code&gt;.cfg&lt;/code&gt; &amp;raquo;. Типичный вызов mkth3.tcl может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="b8c8240b8bebcede58e6b71d1007e7276f3ab838" translate="yes" xml:space="preserve">
          <source>The TH3 repository also includes the &quot;multitest.tcl&quot; script, another TCL script used to automate TH3 testing on workstations. Multitest.tcl automatically compiles SQLite, then runs ./th3make repeatedly with a variety of alignments, and captures the output in a succinct summary screen. A typical multitest.tcl run generates output that looks like this:</source>
          <target state="translated">В репозиторий TH3 также входит скрипт &quot;multitest.tcl&quot;,еще один скрипт TCL,используемый для автоматизации тестирования TH3 на рабочих станциях.Multitest.tcl автоматически компилирует SQLite,затем многократно запускает ./th3make с различными выравниваниями и захватывает вывод в кратком сводном окне.Типичный запуск multitest.tcl генерирует вывод,который выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b6f9b2cda115a994b187cb0154afbb957f0c6ad7" translate="yes" xml:space="preserve">
          <source>The TH3 source tree contains a scripted name &quot;mutation-test.tcl&quot; that automates the process of &lt;a href=&quot;testing#mutationtests&quot;&gt;mutation testing&lt;/a&gt;.</source>
          <target state="translated">Исходное дерево TH3 содержит скриптовое имя &amp;laquo;mutation-test.tcl&amp;raquo;, которое автоматизирует процесс &lt;a href=&quot;testing#mutationtests&quot;&gt;тестирования мутаций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cdfe00d64176fc80b6e066f8b6b12526ed3a13b" translate="yes" xml:space="preserve">
          <source>The TH3 test harness needs to run on embedded systems that do not necessarily have the ability to spawn child processes, so it uses an in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to simulate crashes. The in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be rigged to make a snapshot of the entire filesystem after a set number of I/O operations. Crash tests run in a loop. On each iteration of the loop, the point at which a snapshot is made is advanced until the SQLite operations being tested run to completion without ever hitting a snapshot. Within the loop, after the SQLite operation under test has completed, the filesystem is reverted to the snapshot and random file damage is introduced that is characteristic of the kinds of damage one expects to see following a power loss. Then the database is opened and checks are made to ensure that it is well-formed and that the transaction either ran to completion or was completely rolled back. The interior of the loop is repeated multiple times for each snapshot with different random damage each time.</source>
          <target state="translated">Тестовый комплект TH3 должен работать во встроенных системах, которые не обязательно имеют возможность порождать дочерние процессы, поэтому он использует &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; в памяти для имитации сбоев. &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; в памятиможет быть настроен так, чтобы сделать снимок всей файловой системы после заданного количества операций ввода-вывода. Краш-тесты проходят в цикле. На каждой итерации цикла точка, в которой создается моментальный снимок, продвигается вперед до тех пор, пока тестируемые операции SQLite не будут завершены, даже не ударив моментальный снимок. В рамках цикла после завершения тестируемой операции SQLite файловая система возвращается к моментальному снимку и вносится случайное повреждение файла, которое характерно для тех видов повреждений, которые можно ожидать после потери питания. Затем открывается база данных и выполняются проверки, чтобы убедиться, что она правильно сформирована и что транзакция либо завершилась, либо была полностью откатана. Внутренняя часть цикла повторяется несколько раз для каждого снимка с разными случайными повреждениями каждый раз.</target>
        </trans-unit>
        <trans-unit id="17fbf6e9083452ddac2fd083a957049cd4961ff8" translate="yes" xml:space="preserve">
          <source>The TMPDIR environment variable</source>
          <target state="translated">Переменная окружения TMPDIR</target>
        </trans-unit>
        <trans-unit id="03b5c9a4012ba043f6ac023992fea614e9559aac" translate="yes" xml:space="preserve">
          <source>The TRUNCATE journaling mode commits transactions by truncating the rollback journal to zero-length instead of deleting it. On many systems, truncating a file is much faster than deleting the file since the containing directory does not need to be changed.</source>
          <target state="translated">Режим журналирования TRUNCATE фиксирует транзакции,усекая журнал отката до нуля вместо удаления.Во многих системах усечение файла намного быстрее,чем удаление файла,так как каталог,содержащий файл,не нуждается в изменении.</target>
        </trans-unit>
        <trans-unit id="8b6a576f2a0740b1d820bb0b389ef9405211a467" translate="yes" xml:space="preserve">
          <source>The Tcl interface to the SQLite library</source>
          <target state="translated">Tcl-интерфейс к библиотеке SQLite</target>
        </trans-unit>
        <trans-unit id="ea435d43ff01f7eaaaed2d71b4ee7a4a7d014eaf" translate="yes" xml:space="preserve">
          <source>The Tcl script language is used to help translate canonical source code into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and to manage testing. Tcl is not used directly by SQLite itself (unless requested by a compile-time option). End users of the SQLite amalgamation sources do not need Tcl.</source>
          <target state="translated">Язык сценариев Tcl используется для перевода канонического исходного кода в &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; и для управления тестированием. Tcl не используется непосредственно самим SQLite (кроме случаев, когда этого требует параметр времени компиляции). Конечным пользователям источников объединения SQLite не нужен Tcl.</target>
        </trans-unit>
        <trans-unit id="4ea1be33d0917718998fde5f34057649d7f00dc5" translate="yes" xml:space="preserve">
          <source>The Truncate Optimization</source>
          <target state="translated">Усеченная оптимизация</target>
        </trans-unit>
        <trans-unit id="663111ce13348e029be0eb29fd78279aef78534e" translate="yes" xml:space="preserve">
          <source>The UNION Virtual Table</source>
          <target state="translated">Виртуальная таблица ЮНИОН</target>
        </trans-unit>
        <trans-unit id="83a6780922b4732cbc0add9d73d09070752444e6" translate="yes" xml:space="preserve">
          <source>The UNION operator for compound queries is implemented by creating a transient index in a temporary file and storing the results of the left and right subquery in the transient index, discarding duplicates. After both subqueries have been evaluated, the transient index is walked from beginning to end to generate the final output.</source>
          <target state="translated">Оператор UNION для составных запросов реализуется путем создания переходного индекса во временном файле и хранения результатов левого и правого подзапросов в переходном индексе,отбрасывая дубликаты.После обработки обоих подзапросов индекс переходных процессов проходит от начала до конца,чтобы получить конечный результат.</target>
        </trans-unit>
        <trans-unit id="7930c62c86f89ebc6a986709239760afad2bba9f" translate="yes" xml:space="preserve">
          <source>The UNION virtual table (hereafter: &quot;union-vtab&quot;) is a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that makes multiple independent &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; tables look like a single large table.</source>
          <target state="translated">Виртуальная таблица UNION (далее &amp;laquo;union-vtab&amp;raquo;) - это &lt;a href=&quot;vtab&quot;&gt;виртуальная таблица,&lt;/a&gt; которая делает несколько независимых &lt;a href=&quot;rowidtable&quot;&gt;таблиц rowid&lt;/a&gt; похожими на одну большую таблицу.</target>
        </trans-unit>
        <trans-unit id="16da95be83b926d661aef977fab4f723fc62a011" translate="yes" xml:space="preserve">
          <source>The UPDATE and DELETE statements are coded using a template that is very similar to the SELECT statement template. The main difference, of course, is that the end action is to modify the database rather than invoke a callback function. Because it modifies the database it will also use transactions. Let's begin by looking at a DELETE statement:</source>
          <target state="translated">Операторы UPDATE и DELETE кодируются с помощью шаблона,который очень похож на шаблон оператора SELECT.Основное отличие,конечно,заключается в том,что конечное действие заключается в модификации базы данных,а не в вызове функции обратного вызова.Поскольку оно модифицирует БД,оно также будет использовать транзакции.Давайте начнем с рассмотрения оператора DELETE:</target>
        </trans-unit>
        <trans-unit id="d012a450cb6e8a62342d872acae64f627c638672" translate="yes" xml:space="preserve">
          <source>The UPDATE statement was not working when the WHERE clause contained some terms that could be satisfied using indices and other terms that could not. Fixed.</source>
          <target state="translated">Заявление UPDATE не работает,когда в клаузуле WHERE содержатся некоторые термины,которые могут быть удовлетворены с помощью индексов,и другие термины,которые не могут быть удовлетворены с помощью индексов.Исправлено.</target>
        </trans-unit>
        <trans-unit id="33c2760fb2236b7ba6d326e49f2cb15eef8f0600" translate="yes" xml:space="preserve">
          <source>The UPDATE-FROM idea is an extension to SQL that allows an UPDATE statement to be driven by other tables in the database. The &quot;target&quot; table is the specific table that is being updated. With UPDATE-FROM you can join the target table against other tables in the database in order to help compute which rows need updating and what the new values should be on those rows. UPDATE-FROM is supported beginning in SQLite version 3.33.0 (2020-08-14).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45a66b4cdc4b1cad87f2ad44961d2b0a1e7cb34" translate="yes" xml:space="preserve">
          <source>The Use Of assert() In SQLite</source>
          <target state="translated">Использование функции assert()в SQLite</target>
        </trans-unit>
        <trans-unit id="91cb86d3be85bb36d2918c344be4f7a7dbe55738" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command is transactional in the sense that the generated output database is a consistent snapshot of the original database. However, if the VACUUM INTO command is interrupted by an unplanned shutdown or power lose, then the generated output database might be incomplete and corrupt. Also, SQLite does not invoke fsync() or FlushFileBuffers() on the generated database to ensure that it has reached non-volatile storage before completing.</source>
          <target state="translated">Команда VACUUM INTO является транзакционной в том смысле,что созданная выходная БД является последовательным снимком исходной БД.Однако,если команда VACUUM INTO прервана незапланированным выключением или потерей питания,то сгенерированная выходная БД может быть неполной и поврежденной.Кроме того,SQLite не вызывает fsync()или FlushFileBuffers()на генерируемую БД,чтобы удостовериться,что она попала в энергонезависимое хранилище до ее завершения.</target>
        </trans-unit>
        <trans-unit id="122691010e5d737070edb247661b2776162b982c" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command works the same way except that it uses the file named on the INTO clause in place of the temporary database and omits the step of copying the vacuumed database back over top of the original database.</source>
          <target state="translated">Команда VACUUM INTO работает точно так же,за исключением того,что она использует вместо временной БД файл,названный в пункте INTO,и опускает шаг копирования вакуумной БД обратно поверх исходной.</target>
        </trans-unit>
        <trans-unit id="7b858ec9bacb824cb3d161c5dbed06b788759184" translate="yes" xml:space="preserve">
          <source>The VACUUM command may change the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; of entries in any tables that do not have an explicit &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">Команда VACUUM может изменять &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; записей в любых таблицах, не имеющих явного &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41696dc3c99878e16f90bac54782d308e462d0f3" translate="yes" xml:space="preserve">
          <source>The VACUUM command now works with the non-callback API</source>
          <target state="translated">Команда VACUUM теперь работает с API без обратного вызова.</target>
        </trans-unit>
        <trans-unit id="27866863317458114de851c82a30b86b318d52b6" translate="yes" xml:space="preserve">
          <source>The VACUUM command rebuilds the database file, repacking it into a minimal amount of disk space. There are several reasons an application might do this:</source>
          <target state="translated">Команда VACUUM перестраивает файл базы данных,переупаковывая его в минимальный объем дискового пространства.Есть несколько причин,по которым приложение может это сделать:</target>
        </trans-unit>
        <trans-unit id="9aa5f71406817eba130230946d703a26da25090a" translate="yes" xml:space="preserve">
          <source>The VACUUM command with an INTO clause is an alternative to the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; for generating backup copies of a live database. The advantage of using VACUUM INTO is that the resulting backup database is minimal in size and hence the amount of filesystem I/O may be reduced. Also, all deleted content is purged from the backup, leaving behind no forensic traces. On the other hand, the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; uses fewer CPU cycles and can be executed incrementally.</source>
          <target state="translated">Команда VACUUM с предложением INTO является альтернативой &lt;a href=&quot;backup&quot;&gt;API резервного копирования&lt;/a&gt; для создания резервных копий действующей базы данных. Преимущество использования VACUUM INTO заключается в том, что результирующая база данных резервных копий имеет минимальный размер и, следовательно, количество операций ввода-вывода файловой системы может быть уменьшено. Кроме того, весь удаленный контент удаляется из резервной копии, не оставляя следов криминалистической экспертизы. С другой стороны, &lt;a href=&quot;backup&quot;&gt;API резервного копирования&lt;/a&gt; использует меньше циклов ЦП и может выполняться постепенно.</target>
        </trans-unit>
        <trans-unit id="e0a189fd9e3d1e02aa0528451d9b2483299ef4e9" translate="yes" xml:space="preserve">
          <source>The VACUUM command works by copying the contents of the database into a temporary database file and then overwriting the original with the contents of the temporary file. When overwriting the original, a rollback journal or &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; WAL file is used just as it would be for any other database transaction. This means that when VACUUMing a database, as much as twice the size of the original database file is required in free disk space.</source>
          <target state="translated">Команда VACUUM работает путем копирования содержимого базы данных во временный файл базы данных и последующей перезаписи оригинала содержимым временного файла. При перезаписи оригинала используется журнал отката или файл &lt;a href=&quot;wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; WAL точно так же, как и для любой другой транзакции базы данных. Это означает, что при ВАКУУМИРОВАНИИ базы данных требуется вдвое больший размер исходного файла базы данных на свободном дисковом пространстве.</target>
        </trans-unit>
        <trans-unit id="778738485f953e3a9b76b31822d939e887b55074" translate="yes" xml:space="preserve">
          <source>The VALUE and HIWTR columns report the current value of the measure and its &quot;high-water mark&quot;. The high-water mark is the highest value ever seen for the measurement, at least since the last reset. The SQLITE_MEMSTAT virtual table does not provide a mechanism for resetting the high-water mark.</source>
          <target state="translated">Колонки VALUE и HIWTR сообщают текущее значение измерения и его &quot;отметку высокого уровня воды&quot;.Метка высокого давления является самым высоким значением измерения,по крайней мере,с момента последнего сброса.В виртуальной таблице SQLITE_MEMSTAT не предусмотрен механизм сброса метки высокого давления.</target>
        </trans-unit>
        <trans-unit id="1b2ece5b4ab8b91b62ace8f0cc0040f19a643253" translate="yes" xml:space="preserve">
          <source>The VALUES clause</source>
          <target state="translated">Клаузула VALUES</target>
        </trans-unit>
        <trans-unit id="b8a859f7de071f48cff5a7fe9193dabc82e472c2" translate="yes" xml:space="preserve">
          <source>The VALUES clause of an INSERT can now contain expressions, including scalar SELECT clauses.</source>
          <target state="translated">Оговорка VALUES в INSERT теперь может содержать выражения,в том числе и скалярные SELECT.</target>
        </trans-unit>
        <trans-unit id="222a8cea06637d3ca462a60582d77b6f51ecd46d" translate="yes" xml:space="preserve">
          <source>The VDBE code generated by the above statement looks like the following:</source>
          <target state="translated">Код VDBE,сгенерированный вышеуказанным утверждением,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="914b54584037bedb35946860061828500f1bc504" translate="yes" xml:space="preserve">
          <source>The VDBE code generated for this query is as follows:</source>
          <target state="translated">Ниже приведен код VDBE,сгенерированный для этого запроса:</target>
        </trans-unit>
        <trans-unit id="44e862e51e63dc8e6d2cfc4ebc01e6bf18bd5d5d" translate="yes" xml:space="preserve">
          <source>The VDBE implements a virtual computer that runs a program in its virtual machine language. The goal of each program is to interrogate or change the database. Toward this end, the machine language that the VDBE implements is specifically designed to search, read, and modify databases.</source>
          <target state="translated">VDBE реализует виртуальный компьютер,который запускает программу на своем языке виртуальной машины.Целью каждой программы является опрос или изменение базы данных.С этой целью машинный язык,который реализует VDBE,специально разработан для поиска,чтения и изменения баз данных.</target>
        </trans-unit>
        <trans-unit id="2dceeabf6f031eb26374896fc49e25ce44afb511" translate="yes" xml:space="preserve">
          <source>The VDBE program generated for this SQL statement is as follows:</source>
          <target state="translated">Программа VDBE,сгенерированная для этого SQL-оператора,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="80bc0b2de97d753f617c4eaf5d3c9b6776ea43cf" translate="yes" xml:space="preserve">
          <source>The VERSION table shown above has columns to record a check-in comment (presumably supplied by the user) and the time and date at which the File/Save action occurred. It also records the parent version to record the history of changes. Perhaps the manifest could be stored as a delta from the parent version, though typically the manifest will be small enough that storing a delta might be more trouble than it is worth. The SLIDE table also contains a derivedFrom column which could be used for delta encoding if it is determined that saving the slide content as a delta from its previous version is a worthwhile optimization.</source>
          <target state="translated">Таблица ВЕРСИИ,показанная выше,имеет колонки для записи комментария к регистрации (предположительно предоставленного пользователем),а также время и дату,когда произошло действие Файл/Сохранить.Она также записывает родительскую версию для записи истории изменений.Возможно,манифест может храниться в виде дельты от родительской версии,хотя,как правило,манифест будет достаточно мал,чтобы хранение дельты может быть более проблематичным,чем это стоит.Таблица SLIDE также содержит столбец derivedFrom,который может быть использован для кодирования дельт,если будет установлено,что сохранение содержимого слайда в виде дельты из его предыдущей версии является целесообразной оптимизацией.</target>
        </trans-unit>
        <trans-unit id="1b59010289d2579bd6e51282e421f222dba65ae2" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that due to an oversight, the structure of the sqlite3_vfs object changed in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not increased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0766456a2002e4475782706d0b0fb713540038a5" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that the structure of the sqlite3_vfs object changes in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not modified.</source>
          <target state="translated">Интерфейс VFS иногда расширяют, добавляя в конец новые методы. Каждый раз, когда происходит такое расширение, поле iVersion увеличивается. Значение iVersion началось с 1 в SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;версии 3.5.0&lt;/a&gt; 04.09.2007, затем увеличилось до 2 с SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии 3.7.0 21.07.2010&lt;/a&gt; , а затем увеличилось до 3 с SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;версии 3.7.6&lt;/a&gt; в 2011 году. -04-12. К объекту sqlite3_vfs могут быть добавлены дополнительные поля, а значение iVersion может снова увеличиться в будущих версиях SQLite. Обратите внимание, что структура объекта sqlite3_vfs изменяется при переходе от SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;версии 3.5.9&lt;/a&gt; к &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;версии 3.6.0&lt;/a&gt; 16 июля 2008 г., но поле iVersion не было изменено.</target>
        </trans-unit>
        <trans-unit id="9428f4f61873bedbb7fa546ce9da2878f0f6b46f" translate="yes" xml:space="preserve">
          <source>The VFS specified by a URI has the highest priority. After that comes a VFS specified as the fourth argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The default VFS is used if no VFS is specified otherwise.</source>
          <target state="translated">VFS, указанная в URI, имеет наивысший приоритет. После этого идет VFS, указанная в качестве четвертого аргумента &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . Если VFS не указана, используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="59f617b8350433543bfe3f6503e9062a84ed6414" translate="yes" xml:space="preserve">
          <source>The Virtual Database Engine of SQLite</source>
          <target state="translated">Виртуальный движок базы данных SQLite</target>
        </trans-unit>
        <trans-unit id="2fc007776417aa54116dbc71f8065ab7e3ac76ea" translate="yes" xml:space="preserve">
          <source>The Virtual Table Mechanism Of SQLite</source>
          <target state="translated">Механизм виртуальной таблицы SQLite</target>
        </trans-unit>
        <trans-unit id="4a47770692c502c7c39564cd0fc7b210860b676a" translate="yes" xml:space="preserve">
          <source>The WAL approach inverts this. The original content is preserved in the database file and the changes are appended into a separate WAL file. A &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when a special record indicating a commit is appended to the WAL. Thus a COMMIT can happen without ever writing to the original database, which allows readers to continue operating from the original unaltered database while changes are simultaneously being committed into the WAL. Multiple transactions can be appended to the end of a single WAL file.</source>
          <target state="translated">Подход WAL инвертирует это. Исходное содержимое сохраняется в файле базы данных, а изменения добавляются в отдельный файл WAL. &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; происходит , когда специальная запись с указанием фиксации добавляется к WAL. Таким образом, COMMIT может происходить без записи в исходную базу данных, что позволяет читателям продолжать работу с исходной неизмененной базой данных, в то время как изменения одновременно фиксируются в WAL. В конец одного файла WAL можно добавить несколько транзакций.</target>
        </trans-unit>
        <trans-unit id="82b1501dab1e647276daeb770adadd0f94b39bd1" translate="yes" xml:space="preserve">
          <source>The WAL file can optionally be truncated on a reset, but it need not be. Performance is usually a little better if the WAL is not truncated, since filesystems generally will overwrite an existing file faster than they will grow a file.</source>
          <target state="translated">Файл WAL может быть усечен при сбросе,но в этом нет необходимости.Обычно производительность немного лучше,если WAL не усекается,так как файловые системы обычно перезаписывают существующий файл быстрее,чем увеличивают его.</target>
        </trans-unit>
        <trans-unit id="6ee114cc7fc43aace09ed2f31fdb137fc0cc57b0" translate="yes" xml:space="preserve">
          <source>The WAL file exists for as long as any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has the database open. Usually, the WAL file is deleted automatically when the last connection to the database closes. However, if the last process to have the database open exits without cleanly shutting down the database connection, or if the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; is used, then the WAL file might be retained on disk after all connections to the database have been closed. The WAL file is part of the persistent state of the database and should be kept with the database if the database is copied or moved. If a database file is separated from its WAL file, then transactions that were previously committed to the database might be lost, or the database file might become corrupted. The only safe way to remove a WAL file is to open the database file using one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interfaces then immediately close the database using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">Файл WAL существует до тех пор, пока при любом &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключении&lt;/a&gt; к базе данных база данных открыта. Обычно файл WAL удаляется автоматически при закрытии последнего соединения с базой данных. Однако, если последний процесс, открывший базу данных, &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;завершился&lt;/a&gt; без полного отключения соединения с базой данных, или если &lt;a href=&quot;c3ref/file_control&quot;&gt;файл &lt;/a&gt;SQLITE_FCNTL_PERSIST_WALиспользуется, то файл WAL может остаться на диске после закрытия всех подключений к базе данных. Файл WAL является частью постоянного состояния базы данных и должен храниться вместе с базой данных, если база данных копируется или перемещается. Если файл базы данных отделен от своего файла WAL, то транзакции, которые ранее были зафиксированы в базе данных, могут быть потеряны или файл базы данных может быть поврежден. Единственный безопасный способ удалить файл WAL - открыть файл базы данных с помощью одного из интерфейсов &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open (), а&lt;/a&gt; затем немедленно закрыть базу данных с помощью &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79014b745cf0a5f8595085db33b3a7e639f66d1c" translate="yes" xml:space="preserve">
          <source>The WAL header is 32 bytes in size and consists of the following eight big-endian 32-bit unsigned integer values:</source>
          <target state="translated">Заголовок WAL имеет размер 32 байта и состоит из следующих восьми биг-ендианских 32-битных беззнаковых целочисленных значений:</target>
        </trans-unit>
        <trans-unit id="3ad8fc65cf4c28a6553ebe75589fa3de09b97b25" translate="yes" xml:space="preserve">
          <source>The WAL journal mode will be set on all connections to the same database file if it is set on any one connection.</source>
          <target state="translated">Режим журнала WAL будет установлен на всех подключениях к одному и тому же файлу БД,если он установлен на одном и том же подключении.</target>
        </trans-unit>
        <trans-unit id="c2da5fc09a01446274895178b9f5584cc12d72c9" translate="yes" xml:space="preserve">
          <source>The WAL journaling mode uses a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; instead of a rollback journal to implement transactions. The WAL journaling mode is persistent; after being set it stays in effect across multiple database connections and after closing and reopening the database. A database in WAL journaling mode can only be accessed by SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21) or later.</source>
          <target state="translated">В режиме ведения журнала WAL для выполнения транзакций вместо журнала отката используется журнал &lt;a href=&quot;wal&quot;&gt;упреждающей записи&lt;/a&gt; . Режим ведения журнала WAL постоянный; после установки он остается в силе при нескольких подключениях к базе данных, а также после закрытия и повторного открытия базы данных. Доступ к базе данных в режиме журналирования WAL может получить только SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии 3.7.0&lt;/a&gt; (2010-07-21) или новее.</target>
        </trans-unit>
        <trans-unit id="bbeadb5beff9552e41ebfc0aed8339e43743fd64" translate="yes" xml:space="preserve">
          <source>The WAL-index format version number. Always 3007000.</source>
          <target state="translated">Номер версии WAL-индексного формата.Всегда 3007000.</target>
        </trans-unit>
        <trans-unit id="a0470594be37c3f0ff60237d02ae37bf43150bc8" translate="yes" xml:space="preserve">
          <source>The WAL-index or &quot;shm&quot; file is used to coordinate access to the database by multiple clients, and as a cache to help clients quickly locate frames within the wal file.</source>
          <target state="translated">Файл WAL-index или &quot;shm&quot; используется для координации доступа к базе данных для нескольких клиентов,а также в качестве кэша,помогающего клиентам быстро находить фреймы в файле wal.</target>
        </trans-unit>
        <trans-unit id="3fa0bf716018ca8d2c184cf21d82cae1245d9415" translate="yes" xml:space="preserve">
          <source>The WAL_CKPT_LOCK is only locked exclusively. There is never a shared lock taken on WAL_CKPT_LOCK.</source>
          <target state="translated">БЛОКИРОВКА WAL_CKPT_LOCK блокируется только.На WAL_CKPT_LOCK никогда не производится общая блокировка.</target>
        </trans-unit>
        <trans-unit id="42d567271c4a4abf54f649e6218b2a342b7491c5" translate="yes" xml:space="preserve">
          <source>The WAL_RECOVER_LOCK is only locked exclusively. There is never a shared lock taken on WAL_RECOVER_LOCK.</source>
          <target state="translated">БЛОКИРОВКА WAL_RECOVER_LOCK блокируется только.БЛОКИРОВКА WAL_RECOVER_LOCK никогда не блокируется совместно.</target>
        </trans-unit>
        <trans-unit id="f378361895c3312e72c176b00bbf1af957e8b29d" translate="yes" xml:space="preserve">
          <source>The WAL_WRITE_LOCK is only locked exclusively. There is never a shared lock taken on WAL_WRITE_LOCK.</source>
          <target state="translated">БЛОКИРОВКА WAL_WRITE_LOCK блокируется только.На WAL_WRITE_LOCK никогда не производится общая блокировка.</target>
        </trans-unit>
        <trans-unit id="cddb2fff96db0eb2561a8fa9288188bd61c4a17a" translate="yes" xml:space="preserve">
          <source>The WHERE clause is implemented by instructions 6 through 8. The job of the where clause is to skip the ListWrite if the WHERE condition is false. To this end, it jumps ahead to the Next instruction if the &quot;two&quot; column (extracted by the Column instruction) is greater than or equal to 50.</source>
          <target state="translated">Положение &quot;ГДЕ,ГДЕ&quot; выполняется с помощью инструкций 6-8.Задание пункта,где пропустить ListWrite,если условие WHERE ложно.Для этого он перепрыгивает на следующую инструкцию,если &quot;два&quot; столбца (извлеченные инструкцией &quot;Колонка&quot;)больше или равны 50.</target>
        </trans-unit>
        <trans-unit id="29f1ffc6e309ea1c4b2ff1d0678fe7459979e894" translate="yes" xml:space="preserve">
          <source>The WHERE clause on a query is broken up into &quot;terms&quot; where each term is separated from the others by an AND operator. If the WHERE clause is composed of constraints separate by the OR operator then the entire clause is considered to be a single &quot;term&quot; to which the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; is applied.</source>
          <target state="translated">Предложение WHERE в запросе разбито на &amp;laquo;термины&amp;raquo;, где каждый термин отделяется от других оператором AND. Если предложение WHERE состоит из ограничений, разделенных оператором OR, то все предложение считается одним &amp;laquo;термином&amp;raquo;, к которому применяется &lt;a href=&quot;#or_opt&quot;&gt;оптимизация предложения OR&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67af3225970c5961856bbb922d2677740529dd45" translate="yes" xml:space="preserve">
          <source>The WINDOW clause, when one is present, comes after any HAVING clause and before any ORDER BY.</source>
          <target state="translated">Оговорка WINDOW,когда она присутствует,приходит после любой оговорки HAVING и перед любым ЗАКАЗОМ BY.</target>
        </trans-unit>
        <trans-unit id="59f006cfccb1b0c07b582f38b2b03e476dd1faa4" translate="yes" xml:space="preserve">
          <source>The WITH Clause</source>
          <target state="translated">Клаузула &quot;БЕЗ Клаузулы</target>
        </trans-unit>
        <trans-unit id="49bb3b8074d7fe6469254452d39dc417f079e333" translate="yes" xml:space="preserve">
          <source>The WITH clause cannot be used within a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;.</source>
          <target state="translated">Предложение WITH нельзя использовать в &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="469f423bf145b329a62c79e892ff06f00b735aaa" translate="yes" xml:space="preserve">
          <source>The WITH clause must appear at the beginning of a top-level &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement or at the beginning of a subquery. The WITH clause cannot be prepended to the second or subsequent SELECT statement of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;.</source>
          <target state="translated">Предложение WITH должно появляться в начале &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT&lt;/a&gt; верхнего уровня или в начале подзапроса. Предложение WITH нельзя добавлять перед вторым или последующим оператором SELECT &lt;a href=&quot;lang_select#compound&quot;&gt;составного выбора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0790118e4cc64a2949db095a0b8b9579da7d5654" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID optimization is likely to be helpful for tables that have non-integer or composite (multi-column) PRIMARY KEYs and that do not store large strings or BLOBs.</source>
          <target state="translated">Оптимизация БЕЗ РОУИДов,вероятно,будет полезна для таблиц,которые имеют неинтегрированные или композитные (многостолбцовые)PRIMARY KEYs и не хранят большие строки или BLOB.</target>
        </trans-unit>
        <trans-unit id="b74650aa10ba4b42e039edd4a2cc74f6b68fb08b" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID syntax is an optimization. It provides no new capabilities. Anything that can be done using a WITHOUT ROWID table can also be done in exactly the same way, and exactly the same syntax, using an ordinary rowid table. The only advantage of a WITHOUT ROWID table is that it can sometimes use less disk space and/or perform a little faster than an ordinary rowid table.</source>
          <target state="translated">Синтаксис БЕЗ РОУИД-это оптимизация.Он не предоставляет никаких новых возможностей.Все,что может быть сделано с помощью таблицы БЕЗ КАДРОВАЯ СИНТАКТИКСА,может быть сделано точно таким же образом,и точно таким же синтаксисом,используя обычную таблицу rowid.Единственным преимуществом таблицы БЕЗ КОЛИЧЕСТВА является то,что иногда она может использовать меньше дискового пространства и/или выполнять работу немного быстрее,чем обычная рядная таблица.</target>
        </trans-unit>
        <trans-unit id="d5d979d02523b8b3c921a385853078f31581834f" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID table that has the same structure as the t1bc index would look like this:</source>
          <target state="translated">Таблица БЕЗ РОУИДА,имеющая такую же структуру,как и индекс t1bc,выглядела бы так:</target>
        </trans-unit>
        <trans-unit id="ebd241bcb9edacf4c26a21a11fc0d3a7cc0b5d00" translate="yes" xml:space="preserve">
          <source>The X callback is invoked whenever any of the events identified by mask M occur. The integer return value from the callback is currently ignored, though this may change in future releases. Callback implementations should return zero to ensure future compatibility.</source>
          <target state="translated">Обратный вызов X вызывается всякий раз,когда происходит какое-либо событие,идентифицируемое маской M.В настоящее время целочисленное возвращаемое значение из обратного вызова игнорируется,хотя это может измениться в будущих релизах.Реализации обратного вызова должны возвращать ноль для обеспечения совместимости в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="d9560a5bff3ce71963e342a5450ede2debbbea82" translate="yes" xml:space="preserve">
          <source>The aConstraintUsage[] array contains one element for each of the nConstraint constraints in the inputs section of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. The aConstraintUsage[] array is used by xBestIndex to tell the core how it is using the constraints.</source>
          <target state="translated">Массив aConstraintUsage [] содержит по одному элементу для каждого из ограничений nConstraint в разделе входов структуры &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; . Массив aConstraintUsage [] используется xBestIndex, чтобы сообщить ядру, как оно использует ограничения.</target>
        </trans-unit>
        <trans-unit id="3276fd18c87b4e795759956677bbdc04f564672d" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array contains information about all constraints that apply to the virtual table. But some of the constraints might not be usable because of the way tables are ordered in a join. The xBestIndex method must therefore only consider constraints that have an aConstraint[].usable flag which is true.</source>
          <target state="translated">Массив aConstraint[]содержит информацию обо всех ограничениях,которые применяются к виртуальной таблице.Но некоторые из этих ограничений могут быть неприменимы из-за того,как таблицы упорядочены в join.Поэтому метод xBestIndex должен учитывать только те ограничения,которые имеют флаг aConstraint[].usable,который равен true.</target>
        </trans-unit>
        <trans-unit id="08f35e14867214bff1de15c06eccca3a8c64a445" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array records WHERE clause constraints of the form:</source>
          <target state="translated">Массив aConstraint[]записывает Ограничения формы ГДЕ:</target>
        </trans-unit>
        <trans-unit id="cb4f46690b6dce470ed710606d550164c584726b" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201991425b66ed2865e7a91ab0511b280556125f" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="translated">Возможность добавлять &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL&lt;/a&gt; , включая агрегатные и возвращающие табличное значение функции.</target>
        </trans-unit>
        <trans-unit id="a3094b48cb721d2768a7d14f0821434de8cd0a90" translate="yes" xml:space="preserve">
          <source>The ability to index expressions was added to SQLite with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). A database that uses an index on expressions will not be usable by earlier versions of SQLite.</source>
          <target state="translated">Возможность индексирования выражений была добавлена ​​в SQLite с &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;версией 3.9.0&lt;/a&gt; (2015-10-14). База данных, которая использует индекс для выражений, не будет использоваться более ранними версиями SQLite.</target>
        </trans-unit>
        <trans-unit id="e647580ce3a971bdf9683f9f823fdf4aa9345057" translate="yes" xml:space="preserve">
          <source>The ability to store BLOBs in indexed columns.</source>
          <target state="translated">Возможность хранить BLOB в индексированных столбцах.</target>
        </trans-unit>
        <trans-unit id="2b4889307c133133bf332e84c716afd8e6689ea5" translate="yes" xml:space="preserve">
          <source>The ability to use keywords as identifiers promotes backwards compatibility. As new keywords are added, legacy schemas that just happen to use those keywords as table or column names continue to work. However, the ability to use a keyword as an identifier sometimes leads to surprising outcomes. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7fcdb984584a84897317afa23740edc4a933b7" translate="yes" xml:space="preserve">
          <source>The above code creates a new table named &lt;b&gt;t1&lt;/b&gt; with columns &lt;b&gt;a&lt;/b&gt; and &lt;b&gt;b&lt;/b&gt;. What could be simpler?</source>
          <target state="translated">Приведенный выше код создает новую таблицу с именем &lt;b&gt;t1&lt;/b&gt; со столбцами &lt;b&gt;a&lt;/b&gt; и &lt;b&gt;b&lt;/b&gt; . Что может быть проще?</target>
        </trans-unit>
        <trans-unit id="1e597cdc48d987ee3a37507f5f4f64e4eebc9821" translate="yes" xml:space="preserve">
          <source>The above command should be run from the MSVC Native Tools Command Prompt. If you have MSVC installed on your machine, you probably have multiple versions of this Command Prompt, for native builds for x86 and x64, and possibly also for cross-compiling to ARM. Use the appropriate Command Prompt depending on the desired DLL.</source>
          <target state="translated">Вышеприведенная команда должна быть запущена из командной строки MSVC Native Tools Command Prompt.Если у вас на машине установлен MSVC,то,вероятно,у вас есть несколько версий этой командной строки,для родных сборок для x86 и x64,а также,возможно,для кросс-компиляции в ARM.Используйте соответствующую командную строку в зависимости от требуемой DLL.</target>
        </trans-unit>
        <trans-unit id="40e5d3c82a1f28fca2d855ebabf947c2e6309d01" translate="yes" xml:space="preserve">
          <source>The above is all you really need to know in order to use SQLite in your C or C++ programs. There are other interface functions available (and described below) but we will begin by describing the core functions shown above.</source>
          <target state="translated">Вышеперечисленное-это все,что Вам действительно нужно знать для того,чтобы использовать SQLite в Ваших программах на C или C++.Существуют и другие интерфейсные функции (и они описаны ниже),но мы начнем с описания функций ядра,показанного выше.</target>
        </trans-unit>
        <trans-unit id="e1d8b560084e958b9b180ef1ea3e4c34811a8e33" translate="yes" xml:space="preserve">
          <source>The above means that executing the 'merge' command with a negative parameter until the before and after difference in the return value of &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is less than two optimizes the FTS index in the same way as the &lt;a href=&quot;fts5#the_optimize_command&quot;&gt;FTS5 optimize command&lt;/a&gt;. However, if a new b-tree is added to the FTS index while this process is ongoing, FTS5 will move the new b-tree to the same level as the existing b-trees and restart the merge. To avoid this, only the first call to 'merge' should specify a negative parameter. Each subsequent call to 'merge' should specify a positive value so that the merge started by the first call is run to completion even if new b-trees are added to the FTS index.</source>
          <target state="translated">Вышеупомянутое означает, что выполнение команды 'merge' с отрицательным параметром до тех пор, пока разница в возвращаемом значении &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; до и после не станет меньше двух, оптимизирует индекс FTS так же, как &lt;a href=&quot;fts5#the_optimize_command&quot;&gt;команда оптимизации FTS5&lt;/a&gt; . Однако, если новое b-дерево добавляется к индексу FTS во время выполнения этого процесса, FTS5 переместит новое b-дерево на тот же уровень, что и существующие b-деревья, и перезапустит слияние. Чтобы избежать этого, только при первом вызове функции merge следует указывать отрицательный параметр. Каждый последующий вызов &amp;laquo;слияния&amp;raquo; должен указывать положительное значение, чтобы слияние, начатое первым вызовом, выполнялось до завершения, даже если новые b-деревья добавляются в индекс FTS.</target>
        </trans-unit>
        <trans-unit id="a9200726c1128b95e04b731c9b7e036f2a699198" translate="yes" xml:space="preserve">
          <source>The above two assumptions may be interpreted to mean that if a system failure occurs after file truncation but before the truncated file is</source>
          <target state="translated">Вышеприведенные два предположения могут быть интерпретированы как означающие,что если системный сбой происходит после усечения файла,но до того,как усеченный файл окажется</target>
        </trans-unit>
        <trans-unit id="63e4faf9292fbb17cef84d7ffb499ec94358865c" translate="yes" xml:space="preserve">
          <source>The above will return something like this:</source>
          <target state="translated">Вышеупомянутое вернет нечто подобное:</target>
        </trans-unit>
        <trans-unit id="0861e077c18aeb6848f0b5c9c63fbc9c90c17596" translate="yes" xml:space="preserve">
          <source>The abs(X) function returns the absolute value of the numeric argument X. Abs(X) returns NULL if X is NULL. Abs(X) returns 0.0 if X is a string or blob that cannot be converted to a numeric value. If X is the integer -9223372036854775808 then abs(X) throws an integer overflow error since there is no equivalent positive 64-bit two complement value.</source>
          <target state="translated">Функция abs(X)возвращает абсолютное значение числового аргумента X.Abs(X)возвращает NULL,если X равно NULL.Функция abs(X)возвращает 0.0,если X является строкой или блоком,который не может быть преобразован в числовое значение.Если X является целым числом -9223372036854775808,то abs(X)выдает целочисленную ошибку переполнения,так как не существует эквивалентного положительного 64-битного значения двойного дополнения.</target>
        </trans-unit>
        <trans-unit id="3eb517318225f5fe795733968275ce4a51bc681e" translate="yes" xml:space="preserve">
          <source>The absolute value of this integer argument is used as the (approximate) number of tokens to include in the returned text value. The maximum allowable absolute value is 64. The value of this argument is referred to as</source>
          <target state="translated">Абсолютное значение этого целочисленного аргумента используется в качестве (приблизительного)количества лексем для включения в возвращаемое текстовое значение.Максимально допустимое абсолютное значение равно 64.Значение этого аргумента называется</target>
        </trans-unit>
        <trans-unit id="85ca4a9788c6f1b476159c0eeb6719f0a0122577" translate="yes" xml:space="preserve">
          <source>The acctchng_magnitude index is over the account number (&quot;acct_no&quot;) and on the absolute value of the amount. This index allows one to do efficient queries over the magnitude of a change to the account. For example, to list all changes to account number $xyz that are more than $100.00, one can say:</source>
          <target state="translated">Индекс acctchng_magnitude находится над номером счета (&quot;acct_no&quot;)и на абсолютном значении суммы.Этот индекс позволяет делать эффективные запросы на величину изменения счета.Например,чтобы перечислить все изменения к номеру счета $xyz,которые составляют более $100.00,можно сказать:</target>
        </trans-unit>
        <trans-unit id="5e14d586171fc852b529e7898dae84a1afce65ec" translate="yes" xml:space="preserve">
          <source>The acronym RBU stands for &quot;Resumable Bulk Update&quot;.</source>
          <target state="translated">Сокращение RBU означает &quot;Resumable Bulk Update&quot;.</target>
        </trans-unit>
        <trans-unit id="cd26fea06f2a519581c858bc894c62df5370dfe9" translate="yes" xml:space="preserve">
          <source>The act of deleting a file is expensive on many systems. As an optimization, SQLite can be configured to truncate the journal file to zero bytes in length or overwrite the journal file header with zeros. In either case, the resulting journal file is no longer capable of rolling back and so the transaction still commits. Truncating a file to zero length, like deleting a file, is assumed to be an atomic operation from the point of view of a user process. Overwriting the header of the journal with zeros is not atomic, but if any part of the header is malformed the journal will not roll back. Hence, one can say that the commit occurs as soon as the header is sufficiently changed to make it invalid. Typically this happens as soon as the first byte of the header is zeroed.</source>
          <target state="translated">Акт удаления файла стоит дорого во многих системах.В качестве оптимизации SQLite можно настроить на усечение файла журнала до нуля байт или перезаписывать заголовок файла журнала нулями.В любом случае,результирующий файл журнала больше не способен откатиться,поэтому транзакция все равно совершает ошибку.Усечение файла до нулевой длины,как и удаление файла,считается атомарной операцией с точки зрения пользовательского процесса.Перезапись заголовка журнала нулями не является атомарной,но если какая-либо часть заголовка будет повреждена,то журнал не будет откатываться.Следовательно,можно сказать,что коммит происходит,как только заголовок достаточно изменен,чтобы сделать его недействительным.Обычно это происходит,как только обнуляется первый байт заголовка.</target>
        </trans-unit>
        <trans-unit id="eb72a7b6e0cde775aa0861a739588c085322d8b5" translate="yes" xml:space="preserve">
          <source>The action of the preupdate hook is similar to the &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; except that the callback is invoked before the change, not afterwards, and the preupdate hook interfaces are omitted unless this compile-time option is used.</source>
          <target state="translated">Действие ловушки preupdate аналогично ловушке &lt;a href=&quot;c3ref/update_hook&quot;&gt;обновления,&lt;/a&gt; за исключением того, что обратный вызов вызывается перед изменением, а не после него, а интерфейсы ловушки preupdate опускаются, если не используется эта опция времени компиляции.</target>
        </trans-unit>
        <trans-unit id="d730b41c0c65afc48bf2186d2e78971f79c0ae93" translate="yes" xml:space="preserve">
          <source>The actual remote head</source>
          <target state="translated">Фактическая удаленная головка</target>
        </trans-unit>
        <trans-unit id="d5942dd3b483843b4b3b13169967e9623c12cf60" translate="yes" xml:space="preserve">
          <source>The actual value of the automerge parameter determines the number of index segments merged simultaneously by an automatic inverted index merge. If the value is set to N, the system waits until there are at least N segments on a single level before beginning to incrementally merge them. Setting a lower value of N causes segments to be merged more quickly, which may speed up full-text queries and, if the workload contains UPDATE or DELETE operations as well as INSERTs, reduce the space on disk consumed by the full-text index. However, it also increases the amount of data written to disk.</source>
          <target state="translated">Фактическое значение параметра автомата определяет количество индексных сегментов,объединенных одновременно автоматическим инвертированным индексным объединением.Если значение установлено в N,то перед началом инкрементального слияния система ждет,пока на одном уровне не появится как минимум N сегментов.Установка меньшего значения N приводит к более быстрому слиянию сегментов,что может ускорить полнотекстовые запросы и,если рабочая нагрузка содержит операции UPDATE или DELETE,а также INSERT,уменьшить пространство на диске,потребляемое полнотекстовым индексом.Однако это также увеличивает объем данных,записываемых на диск.</target>
        </trans-unit>
        <trans-unit id="fcad8bd16dfc8bbae32259b89340b3c09c02938b" translate="yes" xml:space="preserve">
          <source>The address of the cell in the parent frame is determined by adding the value of the P1 argument to the value of the P1 argument to the calling &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction.</source>
          <target state="translated">Адрес ячейки в родительском фрейме определяется добавлением значения аргумента P1 к значению аргумента P1 вызывающей инструкции &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e600ae2c57bf2172dc311ec955786ffac68bdb53" translate="yes" xml:space="preserve">
          <source>The advantage of the table-valued function format is that the query can return just a subset of the PRAGMA columns, can include a WHERE clause, can use aggregate functions, and the table-valued function can be just one of several data sources in a join. For example, to get a list of all indexed columns in a schema, one could query:</source>
          <target state="translated">Преимущество формата табличной функции заключается в том,что запрос может возвращать только подмножество PRAGMA-столбцов,может включать в себя выражение WHERE,может использовать агрегированные функции,а функция табличного значения может быть всего лишь одним из нескольких источников данных в соединении.Например,чтобы получить список всех проиндексированных столбцов в схеме,можно сделать запрос:</target>
        </trans-unit>
        <trans-unit id="d98ae93ba70e0ca59260993947a4e24c760765d2" translate="yes" xml:space="preserve">
          <source>The advantages of doing many smaller sorts instead of a single large sort are:</source>
          <target state="translated">Преимуществом является то,что вместо одного большого сорта можно делать много меньших сортов:</target>
        </trans-unit>
        <trans-unit id="15b97dc5f9d1078668a6ce572dccbfb387883173" translate="yes" xml:space="preserve">
          <source>The affinity of a column is determined by the declared type of the column, according to the following rules in the order shown:</source>
          <target state="translated">Сродство столбца определяется объявленным типом столбца в соответствии со следующими правилами в указанном порядке:</target>
        </trans-unit>
        <trans-unit id="81c1ff1ba114ea49399c70cede12a7ccd08cc3d4" translate="yes" xml:space="preserve">
          <source>The affinity of the v1.x column will be the same as the affinity of t1.b (TEXT), since v1.x maps directly into t1.b. But columns v1.y and v1.z both have no affinity, since those columns map into expression a+c and 42, and expressions always have no affinity.</source>
          <target state="translated">Сродство колонки v1.x будет таким же,как и сродство t1.b (TEXT),так как v1.x отображает непосредственно в t1.b.Но колонки v1.y и v1.z обе не имеют сродства,так как эти колонки отображают в выражение a+c и 42,а выражения всегда не имеют сродства.</target>
        </trans-unit>
        <trans-unit id="ab16418452d7d68b0bd05abd8cefe39ddc38000d" translate="yes" xml:space="preserve">
          <source>The aggregate functions shown below are available by default. Additional aggregate functions written in C may be added using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">Показанные ниже агрегатные функции доступны по умолчанию. Дополнительные агрегатные функции, написанные на C, могут быть добавлены с помощью API &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="084c900ab7b78b8fb14c15704a0ab2585c905626" translate="yes" xml:space="preserve">
          <source>The algorithm above works quite well for most cases, but there are exceptions. These exceptions can be dealt with by making additional entries in the virtual table using the &quot;soundslike&quot; column.</source>
          <target state="translated">Вышеуказанный алгоритм работает достаточно хорошо для большинства случаев,но есть и исключения.С этими исключениями можно справиться,внося дополнительные записи в виртуальную таблицу,используя колонку &quot;звук&quot;.</target>
        </trans-unit>
        <trans-unit id="db0be7814305eaba73945c0429fa38151c410e55" translate="yes" xml:space="preserve">
          <source>The algorithm specified in the OR clause of an INSERT or UPDATE overrides any algorithm specified in a CREATE TABLE. If no algorithm is specified anywhere, the ABORT algorithm is used.</source>
          <target state="translated">Алгоритм,указанный в пункте &quot;ИЛИ&quot; окна INSERT или UPDATE,отменяет любой алгоритм,указанный в CREATE TABLE.Если нигде не указан алгоритм,то используется алгоритм ABORT.</target>
        </trans-unit>
        <trans-unit id="8f1bb5e260f6d6940f8038960690efd8a13241e0" translate="yes" xml:space="preserve">
          <source>The algorithm used by memsys5 can be called &quot;power-of-two, first-fit&quot;. The sizes of all memory allocation requests are rounded up to a power of two and the request is satisfied by the first free slot in pBuf that is large enough. Adjacent freed allocations are coalesced using a buddy system. When used appropriately, this algorithm provides mathematical guarantees against fragmentation and breakdown, as described further &lt;a href=&quot;#nofrag&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">Алгоритм, используемый memsys5, можно назвать &quot;степень двойки, первое соответствие&quot;. Размеры всех запросов на выделение памяти округляются до степени двойки, и запрос удовлетворяется первым свободным слотом в pBuf, который достаточно велик. Смежные освобожденные выделения объединяются с помощью системы друзей. При правильном использовании этот алгоритм обеспечивает математические гарантии от фрагментации и разрушения, как описано &lt;a href=&quot;#nofrag&quot;&gt;ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91caf7e2c108fa5ca12a12fe7d7f1b642ba24d6e" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_prepare_v2() function is similar, except that step 4 (resetting the statement handle) is omitted.</source>
          <target state="translated">Алгоритм,используемый функцией sqlite3_blocking_prepare_v2(),аналогичен,за исключением того,что опущен шаг 4 (сброс хэндла оператора).</target>
        </trans-unit>
        <trans-unit id="cae289508ac99f821f2b991e22b21782588d9eaa" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_step() function is as follows:</source>
          <target state="translated">Алгоритм,используемый функцией sqlite3_blocking_step(),следующий:</target>
        </trans-unit>
        <trans-unit id="ce63f03e43853b117cae180b17d7d91a1fc4423c" translate="yes" xml:space="preserve">
          <source>The alternate-form-2 flag is a non-standard extension that appears in no other printf() implementations, as far as we know.</source>
          <target state="translated">Флаг переменной формы-2 является нестандартным расширением,которое,насколько нам известно,не встречается ни в одной другой реализации printf().</target>
        </trans-unit>
        <trans-unit id="28b22ace0382822e0d79f9e1827563fce76153d6" translate="yes" xml:space="preserve">
          <source>The alternative page cache mechanism is an extreme measure that is only needed by the most demanding applications. The built-in page cache is recommended for most uses.</source>
          <target state="translated">Альтернативный механизм кэширования страниц-это крайняя мера,которая нужна только самым требовательным приложениям.Встроенный кэш страниц рекомендуется для большинства приложений.</target>
        </trans-unit>
        <trans-unit id="8b4794d01495b7d8ad2197d5e4f4f33e4044492d" translate="yes" xml:space="preserve">
          <source>The alternative query formulations shown above are conceptual only. SQLite does not really transform the query. The actual query plan is like this: SQLite locates the first possible value for &quot;role&quot;, which it can do by rewinding the &quot;people_idx1&quot; index to the beginning and reading the first record. SQLite stores this first &quot;role&quot; value in an internal variable that we will here call &quot;$role&quot;. Then SQLite runs a query like: &quot;SELECT name FROM people WHERE role=$role AND height&amp;gt;=180&quot;. This query has an equality constraint on the left-most column of the index and so the index can be used to resolve that query. Once that query is finished, SQLite then uses the &quot;people_idx1&quot; index to locate the next value of the &quot;role&quot; column, using code that is logically similar to &quot;SELECT role FROM people WHERE role&amp;gt;$role LIMIT 1&quot;. This new &quot;role&quot; value overwrites the $role variable, and the process repeats until all possible values for &quot;role&quot; have been examined.</source>
          <target state="translated">Показанные выше альтернативные формулировки запросов носят только концептуальный характер. SQLite на самом деле не преобразует запрос. Фактический план запроса выглядит следующим образом: SQLite находит первое возможное значение для &quot;role&quot;, что он может сделать, перемотав индекс &quot;people_idx1&quot; в начало и прочитав первую запись. SQLite сохраняет это первое значение &amp;laquo;роли&amp;raquo; во внутренней переменной, которую мы здесь назовем &amp;laquo;$ role&amp;raquo;. Затем SQLite выполняет запрос типа: &amp;laquo;ВЫБРАТЬ имя ОТ людей, ГДЕ роль = $ роль И высота&amp;gt; = 180&amp;raquo;. Этот запрос имеет ограничение равенства в крайнем левом столбце индекса, поэтому индекс можно использовать для разрешения этого запроса. После завершения этого запроса SQLite затем использует индекс &amp;laquo;people_idx1&amp;raquo; для поиска следующего значения столбца &amp;laquo;role&amp;raquo;, используя код, который логически похож на &amp;laquo;ВЫБЕРИТЕ роль ОТ людей WHERE role&amp;gt; $ role LIMIT 1 &quot;. Это новое значение&quot; role &quot;перезаписывает переменную $ role, и процесс повторяется до тех пор, пока не будут проверены все возможные значения для&quot; role &quot;.</target>
        </trans-unit>
        <trans-unit id="a91f523f7f1e692f775ff82bc9d632716d5637ec" translate="yes" xml:space="preserve">
          <source>The amalgamation and the sqlite3.h header file are available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file named sqlite-amalgamation-X.zip where the X is replaced by the appropriate version number.</source>
          <target state="translated">Объединение и файл заголовка sqlite3.h доступны на &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;странице загрузки&lt;/a&gt; в виде файла с именем sqlite-amalgamation-X.zip, где X заменяется соответствующим номером версии.</target>
        </trans-unit>
        <trans-unit id="c0a154d12ef5a44def7683dee324b4a87567d061" translate="yes" xml:space="preserve">
          <source>The amalgamation contains everything you need to integrate SQLite into a larger project. Just copy the amalgamation into your source directory and compile it along with the other C code files in your project. (A &lt;a href=&quot;howtocompile&quot;&gt;more detailed discussion&lt;/a&gt; of the compilation process is available.) You may also want to make use of the &quot;sqlite3.h&quot; header file that defines the programming API for SQLite. The sqlite3.h header file is available separately. The sqlite3.h file is also contained within the amalgamation, in the first few thousand lines. So if you have a copy of sqlite3.c but cannot seem to locate sqlite3.h, you can always regenerate the sqlite3.h by copying and pasting from the amalgamation.</source>
          <target state="translated">Объединение содержит все необходимое для интеграции SQLite в более крупный проект. Просто скопируйте объединение в исходный каталог и скомпилируйте его вместе с другими файлами кода C в своем проекте. ( &lt;a href=&quot;howtocompile&quot;&gt;Более подробное обсуждение&lt;/a&gt; процесса компиляции доступно.) Вы также можете использовать заголовочный файл &amp;laquo;sqlite3.h&amp;raquo;, который определяет программный API для SQLite. Заголовочный файл sqlite3.h доступен отдельно. Файл sqlite3.h также содержится в объединении в первых нескольких тысячах строк. Поэтому, если у вас есть копия sqlite3.c, но вы не можете найти sqlite3.h, вы всегда можете восстановить sqlite3.h путем копирования и вставки из объединения.</target>
        </trans-unit>
        <trans-unit id="c5760ad296baf5ccd7d73666c3833985afa715a2" translate="yes" xml:space="preserve">
          <source>The amount of payload that spills onto overflow pages also depends on the page type. For the following computations, let U be the usable size of a database page, the total page size less the reserved space at the end of each page. And let P be the payload size. In the following, symbol X represents the maximum amount of payload that can be stored directly on the b-tree page without spilling onto an overflow page and symbol M represents the minimum amount of payload that must be stored on the btree page before spilling is allowed.</source>
          <target state="translated">Количество полезной нагрузки,которая проливается на переполненные страницы,также зависит от типа страницы.Для следующих вычислений,пусть U будет полезным размером страницы базы данных,общий размер страницы минус зарезервированное место в конце каждой страницы.И пусть P будет полезным размером.Далее символ X обозначает максимальный размер полезного груза,который может быть сохранен непосредственно на странице b-дерева без проливания на страницу переполнения,а символ M обозначает минимальный размер полезного груза,который должен быть сохранен на странице дерева,прежде чем проливание будет разрешено.</target>
        </trans-unit>
        <trans-unit id="cc7c17ba1fc473503228a1ad5223b1322c93e902" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in any subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3035b3f13a8c2eedd1a82b2e759ec82828d6061b" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="translated">Количество пространства,выделяемого sqlite3_aggregate_context(C,N),определяется параметром N при первом успешном вызове.Изменение значения N при последующем вызове на sqlite3_aggregate_context()в пределах одного и того же экземпляра агрегатной функции не приведет к изменению размера выделяемой памяти.Внутри обратного вызова xFinal принято устанавливать значение N=0 при вызове sqlite3_aggregate_context(C,N)так,чтобы не происходило бессмысленного выделения памяти.</target>
        </trans-unit>
        <trans-unit id="48fa74a585edf255bca976e35bf58c2115a55266" translate="yes" xml:space="preserve">
          <source>The android performance numbers for the write experiments are omitted because the performance tests on the Galaxy S3 are so random. Two consecutive runs of the exact same experiment would give wildly different times. And, to be fair, the performance of SQLite on android is slightly slower than writing directly to disk.</source>
          <target state="translated">Номера производительности андроидов для экспериментов по записи опущены,потому что тесты производительности на Galaxy S3 настолько случайны.Два последовательных прогона одного и того же эксперимента дадут дико разное время.И,справедливости ради,производительность SQLite на андроиде несколько медленнее,чем при записи непосредственно на диск.</target>
        </trans-unit>
        <trans-unit id="ba25e29078b648c595b0c513af632a78976e2d1a" translate="yes" xml:space="preserve">
          <source>The application file is portable across all operating systems, 32-bit and 64-bit and big- and little-endian architectures.</source>
          <target state="translated">Файл приложения переносится на все операционные системы,32-битные и 64-битные архитектуры,а также архитектуры big-и little-endian.</target>
        </trans-unit>
        <trans-unit id="553858a0531981a9db580aff8d49f00f4db9f6bc" translate="yes" xml:space="preserve">
          <source>The application has made changes to the &lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTS shadow tables&lt;/a&gt; directly, without using the FTS3/4 virtual table, causing the shadow tables to become out of sync with each other.</source>
          <target state="translated">Приложение внесло изменения в &lt;a href=&quot;fts3#*shadowtab&quot;&gt;теневые таблицы FTS&lt;/a&gt; напрямую, без использования виртуальной таблицы FTS3 / 4, что привело к рассинхронизации теневых таблиц друг с другом.</target>
        </trans-unit>
        <trans-unit id="744b17ec690883f96b76e631855849a6884a7431" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Приложение должно гарантировать, что 1-й параметр sqlite3_exec () является допустимым и открытым &lt;a href=&quot;#sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a416f0180cf818dc5e0d104e2af8fd17ae77d32" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Приложение должно гарантировать, что 1-й параметр sqlite3_exec () является допустимым и открытым &lt;a href=&quot;sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9dbea7596a56ecae7226dfed468f733b0ebf473a" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">Приложение должно завершить каждый &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , чтобы избежать утечки ресурсов. Попытка приложения использовать подготовленный оператор после его завершения является серьезной ошибкой. Любое использование подготовленного оператора после его завершения может привести к неопределенному и нежелательному поведению, например, к сбою сегментирования и повреждению кучи.</target>
        </trans-unit>
        <trans-unit id="fb5d8c6646b2fcb9cbadc4a78abf91f82a6d7868" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="translated">Приложение должно завершить каждый &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , чтобы избежать утечки ресурсов. Попытка приложения использовать подготовленный оператор после его завершения является серьезной ошибкой. Любое использование подготовленного оператора после его завершения может привести к неопределенному и нежелательному поведению, например, к сбою сегментирования и повреждению кучи.</target>
        </trans-unit>
        <trans-unit id="99cabfda3eb8aea847c63c772b815f9008f98dc6" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">Приложение не должно закрывать &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, указанное 1-м параметром sqlite3_exec () во время работы sqlite3_exec ().</target>
        </trans-unit>
        <trans-unit id="0e45e1c6c5dd0bb0af2de4709122fb9b7f5aa23a" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">Приложение не должно закрывать &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, указанное 1-м параметром sqlite3_exec () во время работы sqlite3_exec ().</target>
        </trans-unit>
        <trans-unit id="1ec93d570d3944810e00416d33fc158ef0b8df22" translate="yes" xml:space="preserve">
          <source>The application must not modify the SQL statement text passed into the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="translated">Приложение не должно модифицировать текст SQL-оператора,переданный во 2-й параметр sqlite3_exec()при запуске sqlite3_exec().</target>
        </trans-unit>
        <trans-unit id="dd08aa5c98a2b87e47c47375f85e57ce41e870bc" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">Приложение не должно читать или записывать какую-либо часть блока памяти после того, как он был освобожден с помощью &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04da8df88f025325ec4119082e7436a2ab79cfbf" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="translated">Приложение не должно читать или записывать какую-либо часть блока памяти после того, как он был освобожден с помощью &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; или &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7136e470c61d513b5e2e7bb04278f687766f03e3" translate="yes" xml:space="preserve">
          <source>The application only has to load the data it needs, rather than reading the entire file and holding a complete parse in memory.</source>
          <target state="translated">Приложение должно загружать только те данные,которые ему нужны,а не читать весь файл и хранить в памяти полный синтаксический анализ.</target>
        </trans-unit>
        <trans-unit id="e521cca41ad74c95daa61ed9901e7bb27bdf7838" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;../custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">Приложение никогда не должно напрямую вызывать sqlite3_os_init () или sqlite3_os_end (). Приложение должно вызывать только sqlite3_initialize () и sqlite3_shutdown (). Интерфейс sqlite3_os_init () автоматически вызывается sqlite3_initialize (), а sqlite3_os_end () вызывается sqlite3_shutdown (). Соответствующие реализации для sqlite3_os_init () и sqlite3_os_end () встроены в SQLite, когда он компилируется для Unix, Windows или OS / 2. При &lt;a href=&quot;../compile#os_other&quot;&gt;сборке &lt;/a&gt;&lt;a href=&quot;../custombuild&quot;&gt;для других платформ&lt;/a&gt; (с использованием параметра времени компиляции SQLITE_OS_OTHER = 1 ) приложение должно предоставлять подходящую реализацию для sqlite3_os_init () и sqlite3_os_end (). Поставляемая приложением реализация sqlite3_os_init () или sqlite3_os_end () должна возвращать &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и некоторые другие&lt;a href=&quot;../rescode&quot;&gt;код ошибки&lt;/a&gt; при сбое.</target>
        </trans-unit>
        <trans-unit id="5f9522c8f8708f8f795d05750d26ac94e862ee81" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="translated">Приложение никогда не должно напрямую вызывать sqlite3_os_init () или sqlite3_os_end (). Приложение должно вызывать только sqlite3_initialize () и sqlite3_shutdown (). Интерфейс sqlite3_os_init () автоматически вызывается sqlite3_initialize (), а sqlite3_os_end () вызывается sqlite3_shutdown (). Соответствующие реализации для sqlite3_os_init () и sqlite3_os_end () встроены в SQLite, когда он компилируется для Unix, Windows или OS / 2. При &lt;a href=&quot;compile#os_other&quot;&gt;сборке &lt;/a&gt;&lt;a href=&quot;custombuild&quot;&gt;для других платформ&lt;/a&gt; (с использованием параметра времени компиляции SQLITE_OS_OTHER = 1 ) приложение должно предоставлять подходящую реализацию для sqlite3_os_init () и sqlite3_os_end (). Поставляемая приложением реализация sqlite3_os_init () или sqlite3_os_end () должна возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и некоторые другие&lt;a href=&quot;rescode&quot;&gt;код ошибки&lt;/a&gt; при сбое.</target>
        </trans-unit>
        <trans-unit id="371b08e858c1c9c61f57bffa9ac30d2c2c9616ae" translate="yes" xml:space="preserve">
          <source>The application wants to prevent other processes from accessing the database file.</source>
          <target state="translated">Приложение хочет предотвратить доступ других процессов к файлу базы данных.</target>
        </trans-unit>
        <trans-unit id="da9edea5d79c9c534eb8f394ef49ec7d996e51c8" translate="yes" xml:space="preserve">
          <source>The application_id PRAGMA is used to query or set the 32-bit signed big-endian &quot;Application ID&quot; integer located at offset 68 into the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. Applications that use SQLite as their &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt; should set the Application ID integer to a unique integer so that utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">Application_id PRAGMA используется для запроса или установки 32-битного целого числа с прямым порядком байтов со знаком &amp;laquo;ID приложения&amp;raquo;, расположенного по смещению 68 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных&lt;/a&gt; . Приложения, которые используют SQLite в качестве своего &lt;a href=&quot;appfileformat&quot;&gt;формата файла приложения,&lt;/a&gt; должны установить целое число Application ID в уникальное целое число, чтобы утилиты, такие как &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file (1),&lt;/a&gt; могли определять конкретный тип файла, а не просто сообщать &amp;laquo;База данных SQLite3&amp;raquo;. Список присвоенных идентификаторов приложений можно увидеть, &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;обратившись к&lt;/a&gt; файлу magic.txt в исходном репозитории SQLite.</target>
        </trans-unit>
        <trans-unit id="fbebe3f29ae821a203a540ede83fca7a51f6300e" translate="yes" xml:space="preserve">
          <source>The applications using this database are entitled to assume that for each row in the</source>
          <target state="translated">Приложения,использующие эту базу данных,имеют право предполагать,что для каждой строки в</target>
        </trans-unit>
        <trans-unit id="c4abdec20da55bda36a7679394be4f500b633ccf" translate="yes" xml:space="preserve">
          <source>The argc parameter specifies the number of entries in the argv array. The value of argc will be 1 for a pure delete operation or N+2 for an insert or replace or update where N is the number of columns in the table. In the previous sentence, N includes any hidden columns.</source>
          <target state="translated">Параметр argc определяет количество записей в массиве argv.Значение параметра argc будет равно 1 для чистой операции удаления или N+2 для вставки или замены или обновления,где N-количество столбцов в таблице.В предыдущем предложении N включает любые скрытые столбцы.</target>
        </trans-unit>
        <trans-unit id="b66b85dc16bc6667c3624ba8e6f64b24df3ac149" translate="yes" xml:space="preserve">
          <source>The argument N is the maximum number of bytes of the database file that will be accessed using memory-mapped I/O. If N is zero then memory mapped I/O is disabled. If N is negative, then the limit reverts to the default value determined by the most recent &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;), or to the compile time default determined by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; if not start-time limit has been set.</source>
          <target state="translated">Аргумент N - это максимальное количество байтов файла базы данных, к которому будет осуществляться доступ с помощью ввода-вывода с отображением памяти. Если N равно нулю, то ввод-вывод с отображением в память отключен. Если N отрицательно, то ограничение возвращается к значению по умолчанию, определенному самой последней &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; ), или к &lt;a href=&quot;compile#default_mmap_size&quot;&gt;значению&lt;/a&gt; времени компиляции по умолчанию, определяемому SQLITE_DEFAULT_MMAP_SIZE, если не был установлен предел времени начала.</target>
        </trans-unit>
        <trans-unit id="ab61127b621c6e57d8aaaae340d80e94025b5867" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in decimal.</source>
          <target state="translated">Аргумент представляет собой двойной,который отображается в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="7c92aff7ca85efdc01cd4da9e4f23a18dad234e0" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in either normal decimal notation or if the exponent is not close to zero, in exponential notation.</source>
          <target state="translated">Аргументом является двойник,который отображается либо в нормальной десятичной нотации,либо,если экспонента не близка к нулю,в экспоненциальной нотации.</target>
        </trans-unit>
        <trans-unit id="2096ff23b8873f39597795db4f99b816ed776fc9" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in exponential notation. The exponent character is 'e' or 'E' depending on the type.</source>
          <target state="translated">Аргумент представляет собой двойник,который отображается в экспоненциальной нотации.Символом экспоненты является 'e' или 'E' в зависимости от типа.</target>
        </trans-unit>
        <trans-unit id="11129b8da0d471f1bf24142ea87e57c0024e71a8" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to an integer. Nothing is displayed for this substitution type. Instead, the integer to which the argument points is overwritten with the number of characters in the generated string that result from all format symbols to the left of the %n.</source>
          <target state="translated">Аргумент является указателем на целое число.Для данного типа подстановки ничего не отображается.Вместо этого,целое число,на которое указывает аргумент,перезаписывается числом символов в генерируемой строке,которое получается из всех символов формата слева от %n.</target>
        </trans-unit>
        <trans-unit id="e6906c7030bdaf7b36a456360b0fbb4934d1a4ca" translate="yes" xml:space="preserve">
          <source>The argument is a pointer which is displayed as a hexadecimal address. Since the SQL language has no concept of a pointer, the %p substitution for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; works like %x.</source>
          <target state="translated">Аргумент - это указатель, который отображается как шестнадцатеричный адрес. Поскольку в языке SQL отсутствует понятие указателя, подстановка% p для &lt;a href=&quot;lang_corefunc#printf&quot;&gt;функции SQL printf ()&lt;/a&gt; работает как% x.</target>
        </trans-unit>
        <trans-unit id="e27c7fe9a83c9f08bcef3b205174fd7f4958e0c9" translate="yes" xml:space="preserve">
          <source>The argument is a signed integer which is displayed in decimal.</source>
          <target state="translated">Аргумент представляет собой знаковое целое число,которое отображается в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="9b566b967632a4d496722ab350e0797c5b50a8e6" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string that is displayed. For the %z type in C-language interfaces, &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on the string after it has be copied into the output. The %s and %z substitutions are identical for the SQL printf() function.</source>
          <target state="translated">Аргумент - это отображаемая строка с нулевым символом в конце. Для типа% z в интерфейсах на языке C &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free ()&lt;/a&gt; вызывается в строке после ее копирования в вывод. Подстановки% s и% z идентичны для функции SQL printf ().</target>
        </trans-unit>
        <trans-unit id="fcbbea9fc49916ff3eab8108379983087fe602ea" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string. The string is printed with all single quote (') characters doubled so that the string can safely appear inside an SQL string literal. The %Q substitution type also puts single-quotes on both ends of the substituted string.</source>
          <target state="translated">Аргумент представляет собой нулевую строку.Строка распечатывается с удвоением всех одинарных символов в кавычках ('),чтобы она могла безопасно отображаться внутри строкового SQL-литерала.Тип подстановки %Q также помещает одинарные кавычки на оба конца подставляемой строки.</target>
        </trans-unit>
        <trans-unit id="f7cdf0497339bca82de3b36c80d3d61e29bc5c49" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in hexadecimal. Lower-case hexadecimal is used for %x and upper-case is used for %X</source>
          <target state="translated">Аргумент представляет собой целое число,которое отображается в шестнадцатеричной системе.Нижний шестнадцатеричный используется для %x,а верхний-для %X.</target>
        </trans-unit>
        <trans-unit id="e8fcc09e116d95e79ec104c4fc555cc628b5c95b" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in octal.</source>
          <target state="translated">Аргумент представляет собой целое число,которое отображается восьмеричным числом.</target>
        </trans-unit>
        <trans-unit id="544017bf0d02198d9d372e60ce173d51892cc644" translate="yes" xml:space="preserve">
          <source>The argument is an unsigned integer which is displayed in decimal.</source>
          <target state="translated">Аргумент представляет собой беззнаковое целое число,которое отображается в десятичной форме.</target>
        </trans-unit>
        <trans-unit id="5c161c084d3e3e79567bd33437dedcb35b7796bf" translate="yes" xml:space="preserve">
          <source>The argument is the symbolic name for the desired VFS. If the argument is a NULL pointer, then the default VFS is returned. The function returns a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that implements the VFS. Or it returns a NULL pointer if no object could be found that matched the search criteria.</source>
          <target state="translated">Аргументом является символическое имя желаемой VFS. Если аргумент является указателем NULL, возвращается VFS по умолчанию. Функция возвращает указатель на объект &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; , реализующий VFS. Или он возвращает нулевой указатель, если не удалось найти объект, соответствующий критериям поиска.</target>
        </trans-unit>
        <trans-unit id="850af1642ffa208db124c3d32de875df305d3783" translate="yes" xml:space="preserve">
          <source>The argument to INTO can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filenames are enabled. URL filenames are enabled if any of the following are true:</source>
          <target state="translated">Аргументом INTO может быть &lt;a href=&quot;uri&quot;&gt;имя файла&lt;/a&gt; URI, если имена файлов URI включены. Имена файлов URL включены, если выполняется одно из следующих условий:</target>
        </trans-unit>
        <trans-unit id="5b032a307670cabd16d781ba02c89e270db9d32d" translate="yes" xml:space="preserve">
          <source>The argument to the timeout method is the maximum number of milliseconds to wait for the lock to clear. So in the example above, the maximum delay would be 2 seconds.</source>
          <target state="translated">Аргументом к методу таймаута является максимальное количество миллисекунд ожидания очистки замка.Таким образом,в приведенном выше примере максимальная задержка составит 2 секунды.</target>
        </trans-unit>
        <trans-unit id="6304247ca5d53ec4d2f27644451268a5fc4c44d5" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &quot;tokenchars=&quot; or &quot;separators=&quot; options are case-sensitive. In the example above, specifying that &quot;X&quot; is a separator character does not affect the way &quot;x&quot; is handled.</source>
          <target state="translated">Аргументы,передаваемые в опции &quot;tokenchars=&quot; или &quot;separators=&quot;,чувствительны к регистру.В приведенном выше примере указание,что &quot;X&quot; является символом разделителя,не влияет на способ обработки &quot;x&quot;.</target>
        </trans-unit>
        <trans-unit id="f42ca2142ac7440fc4af993ad46bce7740b98121" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;b&gt;sqlite_busy_handler&lt;/b&gt; are the opaque structure returned from &lt;b&gt;sqlite_open&lt;/b&gt;, a pointer to the busy callback function, and a generic pointer that will be passed as the first argument to the busy callback. When SQLite invokes the busy callback, it sends it three arguments: the generic pointer that was passed in as the third argument to &lt;b&gt;sqlite_busy_handler&lt;/b&gt;, the name of the database table or index that the library is trying to access, and the number of times that the library has attempted to access the database table or index.</source>
          <target state="translated">Аргументами &lt;b&gt;sqlite_busy_handler&lt;/b&gt; являются непрозрачная структура, возвращаемая &lt;b&gt;sqlite_open&lt;/b&gt; , указатель на функцию обратного вызова занятости и общий указатель, который будет передан в качестве первого аргумента обратному вызову занятости. Когда SQLite вызывает обратный вызов занятости, он отправляет ему три аргумента: общий указатель, который был передан в качестве третьего аргумента &lt;b&gt;sqlite_busy_handler&lt;/b&gt; , имя таблицы или индекса базы данных, к которому библиотека пытается получить доступ, и количество раз, когда библиотека попыталась получить доступ к таблице или индексу базы данных.</target>
        </trans-unit>
        <trans-unit id="6fa9f93d8e2b44eeb698d1ed1229d89e77acc71a" translate="yes" xml:space="preserve">
          <source>The argv[0] parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a row in the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.</source>
          <target state="translated">Параметр argv [0] - это &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; удаляемой строки в виртуальной таблице. Если argv [0] является SQL NULL, то удаления не происходит.</target>
        </trans-unit>
        <trans-unit id="94f42e72810bd428d0a06485b57a23695591e88c" translate="yes" xml:space="preserve">
          <source>The argv[1] parameter is the rowid of a new row to be inserted into the virtual table. If argv[1] is an SQL NULL, then the implementation must choose a rowid for the newly inserted row. Subsequent argv[] entries contain values of the columns of the virtual table, in the order that the columns were declared. The number of columns will match the table declaration that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method made using the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; call. All hidden columns are included.</source>
          <target state="translated">Параметр argv [1] - это идентификатор новой строки, которая будет вставлена ​​в виртуальную таблицу. Если argv [1] является SQL NULL, тогда реализация должна выбрать rowid для вновь вставленной строки. Последующие записи argv [] содержат значения столбцов виртуальной таблицы в том порядке, в котором столбцы были объявлены. Количество столбцов будет соответствовать объявлению таблицы, которое метод &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; или &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; сделал с помощью вызова &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; . Включены все скрытые столбцы.</target>
        </trans-unit>
        <trans-unit id="960c591f856ba7201455da5f944d6e4f1ebae33d" translate="yes" xml:space="preserve">
          <source>The arrows from the small circles labeled with &quot;*&quot; indicate the cost of running each loop with no dependencies. The outer loop must use this *-cost. Inner loops have the option of using the *-cost or a cost assuming one of the other terms is in an outer loop, whichever gives the best result. One can think of the *-costs as a short-hand notation indicating multiple arcs, one from each of the other nodes in the graph. The graph is therefore &quot;complete&quot;, meaning that there are arcs (some explicit and some implied) in both directions between every pair of nodes in the graph.</source>
          <target state="translated">Стрелки из маленьких кружочков,помеченные знаком &quot;*&quot;,указывают на стоимость выполнения каждого цикла без зависимостей.Внешний цикл должен использовать эту *стоимость.Внутренние петли имеют возможность использовать *-cost или стоимость,предполагая,что один из других терминов находится во внешнем петле,в зависимости от того,какой из них дает наилучший результат.Можно думать о *-затратах как о короткой нотации,обозначающей несколько дуг,по одной от каждой из других вершин на графике.Поэтому граф является &quot;полным&quot;,что означает,что между каждой парой вершин графа имеются дуги (некоторые явные и некоторые подразумеваемые)в обоих направлениях.</target>
        </trans-unit>
        <trans-unit id="d6a2923f627b3acd76aca2425895d68fa7fb43f5" translate="yes" xml:space="preserve">
          <source>The assert(X) macro is &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;part of standard C&lt;/a&gt;, in the &amp;lt;assert.h&amp;gt; header file. SQLite adds three other assert()-like macros named NEVER(X), ALWAYS(X), and testcase(X).</source>
          <target state="translated">Макрос assert (X) является &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;частью стандартного C&lt;/a&gt; в заголовочном файле &amp;lt;assert.h&amp;gt;. SQLite добавляет три других макроса, подобных assert (), с именами NEVER (X), ALWAYS (X) и testcase (X).</target>
        </trans-unit>
        <trans-unit id="8da4f4835817f9b4a63cc18fb5421f7207d5d808" translate="yes" xml:space="preserve">
          <source>The asynchronous I/O VFS is registered (and unregistered) by calls to the API functions sqlite3async_initialize() and sqlite3async_shutdown(). See section &quot;Compilation and Usage&quot; below for details.</source>
          <target state="translated">Асинхронный ввод/вывод VFS регистрируется (и не регистрируется)вызовами функций API sqlite3async_initialize()и sqlite3async_shutdown().Подробнее см.раздел &quot;Компиляция и использование&quot; ниже.</target>
        </trans-unit>
        <trans-unit id="535287426332e5a1ad8bec16b3d83b02751661a5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO VFS API is described in detail in comments in sqlite3async.h. Using the API usually consists of the following steps:</source>
          <target state="translated">Асинхронный IO VFS API подробно описан в комментариях в sqlite3async.h.Использование API обычно состоит из следующих шагов:</target>
        </trans-unit>
        <trans-unit id="99f2292b58193481d23d957b96b6816c332c0bd5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO extension consists of a single file of C code (sqlite3async.c), and a header file (sqlite3async.h), located in the &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; subfolder&lt;/a&gt; of the SQLite source tree, that defines the C API used by applications to activate and control the modules functionality.</source>
          <target state="translated">Асинхронного расширения ввода - вывода состоит из одного файла кода C (sqlite3async.c), и файл заголовка (sqlite3async.h), расположенный в &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; &lt;/a&gt; вложенную папку из исходного дерева SQLite, который определяет C API , используемый приложениями для активации и контроля функциональности модулей.</target>
        </trans-unit>
        <trans-unit id="fa3d3b11288ba36989fe692263c29b42026caa0f" translate="yes" xml:space="preserve">
          <source>The asynchronous SQLite is just a shade slower than MySQL on this test. (MySQL seems to be especially adept at INSERT...SELECT statements.) The PostgreSQL engine is still thrashing - most of the 61 seconds it used were spent waiting on disk I/O.</source>
          <target state="translated">В этом тесте асинхронный SQLite просто оттенок медленнее,чем MySQL.(Похоже,MySQL особенно хорошо разбирается в выражениях INSERT...SELECT.)Движок PostgreSQL все еще бьется-большинство из 61 секунды,которые он использовал,были потрачены на ожидание дискового ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="09f0791bf3a9c39b17b6897fd1eef3b3d7a8e21f" translate="yes" xml:space="preserve">
          <source>The atomic commit mechanism in SQLite has proven to be robust, but it can be circumvented by a sufficiently creative adversary or a sufficiently broken operating system implementation. This section describes a few of the ways in which an SQLite database might be corrupted by a power failure or system crash. (See also: &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt;.)</source>
          <target state="translated">Механизм атомарной фиксации в SQLite оказался надежным, но его может обойти достаточно изобретательный противник или достаточно неработающая реализация операционной системы. В этом разделе описаны несколько способов, которыми база данных SQLite может быть повреждена из-за сбоя питания или сбоя системы. (См. Также: &lt;a href=&quot;howtocorrupt&quot;&gt;Как испортить файлы базы данных&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="7497e373861cdeb1f861bd3cb7a15f476a8a4234" translate="yes" xml:space="preserve">
          <source>The author of Lemon and SQLite (Hipp) reports that his C programming skills were greatly enhanced by studying John Ousterhout's original source code to Tcl. Hipp discovered and studied Tcl in 1993. Lemon was written before then, and SQLite afterwards. There is a clear difference in the coding styles of these two products, with SQLite seeming to be cleaner, more readable, and easier to maintain.</source>
          <target state="translated">Автор Lemon и SQLite (Hipp)сообщает,что его навыки программирования на Си были значительно улучшены благодаря изучению оригинального исходного кода Джона Остерхаута (John Ousterhout)на Tcl.Хипп открыл и изучил Tcl в 1993 году.Лемон была написана до этого,а SQLite-после.Существует явная разница в стилях кодирования этих двух продуктов,при этом SQLite кажется более чистым,более читабельным и легким в обслуживании.</target>
        </trans-unit>
        <trans-unit id="b01615602e972abb3c5942edbe63b3d8efbfa2ac" translate="yes" xml:space="preserve">
          <source>The authority may be omitted, may be blank, or may be &quot;&lt;code&gt;localhost&lt;/code&gt;&quot;. Any other authority results in an error. Exception: If SQLite is compiled with &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; then any authority value other than &quot;localhost&quot; is passed through to the underlying operating system as a UNC filename.</source>
          <target state="translated">Права доступа могут быть опущены, могут быть пустыми или иметь значение &lt;code&gt;localhost&lt;/code&gt; . Любые другие полномочия приводят к ошибке. Исключение: если SQLite скомпилирован с &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY,&lt;/a&gt; тогда любое значение полномочий, кроме &amp;laquo;localhost&amp;raquo;, передается в базовую операционную систему как имя UNC-файла.</target>
        </trans-unit>
        <trans-unit id="939e9fe5172b44eee1c6df02720143adc80675d6" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратный вызов авторизатора не должен делать ничего, что изменило бы соединение с базой данных, которое вызвало обратный вызов авторизатора. Обратите внимание, что &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="cd0b9544f8e0ba2efe9de0f3a90df70febb9c84b" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратный вызов авторизатора не должен делать ничего, что изменило бы соединение с базой данных, которое вызвало обратный вызов авторизатора. Обратите внимание, что &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; оба изменяют свои соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="861ac52bff28d8b37d00f46c9e8ab0bcdffeef17" translate="yes" xml:space="preserve">
          <source>The automatic indexing capability can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;. Automatic indexing is turned on by default, but this can be changed so that automatic indexing is off by default using the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. The ability to create automatic indices can be completely disabled by compiling with the &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option.</source>
          <target state="translated">Возможность автоматического индексирования может быть отключена во время выполнения с помощью &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;прагмы automatic_index&lt;/a&gt; . Автоматическое индексирование включено по умолчанию, но это можно изменить, чтобы автоматическое индексирование было отключено по умолчанию с помощью параметра &lt;a href=&quot;compile#default_automatic_index&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_AUTOMATIC_INDEX . Возможность создания автоматических индексов может быть полностью отключена путем компиляции с параметром &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_OMIT_AUTOMATIC_INDEX .</target>
        </trans-unit>
        <trans-unit id="ea88f1175fb0f90865a8970907b5e05e253378e5" translate="yes" xml:space="preserve">
          <source>The avg() function returns the average value of all non-NULL</source>
          <target state="translated">Функция avg()возвращает среднее значение всех не-NULL</target>
        </trans-unit>
        <trans-unit id="c29cb183c63bdd561faeb944d923a238a65c8f1b" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two kinds of b-trees are used by SQLite. The algorithm that Knuth calls &quot;B*-Tree&quot; stores all data in the leaves of the tree. SQLite calls this variety of b-tree a &quot;table b-tree&quot;. The algorithm that Knuth calls simply &quot;B-Tree&quot; stores both the key and the data together in both leaves and in interior pages. In the SQLite implementation, the original B-Tree algorithm stores keys only, omitting the data entirely, and is called an &quot;index b-tree&quot;.</source>
          <target state="translated">Алгоритм b-tree обеспечивает хранение ключей / данных с уникальными и упорядоченными ключами на устройствах хранения, ориентированных на страницы. Для получения дополнительной информации о b-деревьях см. Knuth, &lt;u&gt;Искусство компьютерного программирования&lt;/u&gt; , том 3 &amp;laquo;Сортировка и поиск&amp;raquo;, страницы 471-479. SQLite использует два вида b-деревьев. Алгоритм, который Кнут называет &amp;laquo;B * -Tree&amp;raquo;, хранит все данные в листьях дерева. SQLite называет эту разновидность b-дерева &amp;laquo;табличным b-деревом&amp;raquo;. Алгоритм, который Кнут называет просто &amp;laquo;B-Tree&amp;raquo;, хранит ключ и данные вместе как на листьях, так и на внутренних страницах. В реализации SQLite исходный алгоритм B-Tree хранит только ключи, полностью опуская данные, и называется &amp;laquo;индексным b-деревом&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d112311c7e2ccc4f400060b3e5337023ffd30dd4" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two variants of b-trees are used by SQLite. &quot;Table b-trees&quot; use a 64-bit signed integer key and store all data in the leaves. &quot;Index b-trees&quot; use arbitrary keys and store no data at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8fb65a49101b4953ed3553fa6d2836b2742f88" translate="yes" xml:space="preserve">
          <source>The b-tree page header is 8 bytes in size for leaf pages and 12 bytes for interior pages. All multibyte values in the page header are big-endian. The b-tree page header is composed of the following fields:</source>
          <target state="translated">Размер шапки b-дерева страницы составляет 8 байт для листовых страниц и 12 байт для внутренних страниц.Все многобайтовые значения в заголовке страницы имеют большой размер.Заголовок b-деревянной страницы состоит из следующих полей:</target>
        </trans-unit>
        <trans-unit id="b3cbe5b0fd4215124588bcf352c662cc2398e510" translate="yes" xml:space="preserve">
          <source>The backup API copies the content of one database into another. It is useful either for creating backups of databases or for copying in-memory databases to or from persistent files.</source>
          <target state="translated">API резервного копирования копирует содержимое одной базы данных в другую.Он полезен как для создания резервных копий баз данных,так и для копирования баз данных в памяти в постоянные файлы или из них.</target>
        </trans-unit>
        <trans-unit id="2cf1eb05a922a766ec8d7dd18ed7d6f4aa38bd5f" translate="yes" xml:space="preserve">
          <source>The backupDb() function uses the sqlite3_backup_remaining() and sqlite3_backup_pagecount() functions to report its progress via the user-supplied xProgress() callback. Function sqlite3_backup_remaining() returns the number of pages left to copy and sqlite3_backup_pagecount() returns the total number of pages in the source database (in this case the database opened by pDb). So the percentage completion of the process may be calculated as:</source>
          <target state="translated">Функция backupDb()использует функции sqlite3_backup_remaining()и sqlite3_backup_pagecount()для отчётности о своём прогрессе через пользовательский вызов xProgress().Функция sqlite3_backup_remaining()возвращает количество страниц,оставленных для копирования,а функция sqlite3_backup_pagecount()возвращает общее количество страниц в исходной базе данных (в данном случае в базе данных,открытой с помощью pDb).Таким образом,можно рассчитать процентное завершение процесса как:</target>
        </trans-unit>
        <trans-unit id="6b553d2761ee3fe64acd25548c40d0f8e4d42c23" translate="yes" xml:space="preserve">
          <source>The base window may not specify a frame specification. The frame specification can only be given in the new window specification.</source>
          <target state="translated">В базовом окне может не указываться спецификация рамы.Спецификация рамы может быть указана только в спецификации нового окна.</target>
        </trans-unit>
        <trans-unit id="5c2a91b9a2da4a8d6526f62c2bd849ce606c97d4" translate="yes" xml:space="preserve">
          <source>The basic algorithm for computing the content of the recursive table is as follows:</source>
          <target state="translated">Основной алгоритм вычисления содержания рекурсивной таблицы следующий:</target>
        </trans-unit>
        <trans-unit id="cc257445d9ceee252762e517b278c85329543c96" translate="yes" xml:space="preserve">
          <source>The basic principals described above apply to both ordinary rowid tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The only difference is that the rowid column that serves as the key for tables and that appears as the right-most term in indexes is replaced by the PRIMARY KEY.</source>
          <target state="translated">Основные принципы, описанные выше, применимы как к обычным таблицам &lt;a href=&quot;withoutrowid&quot;&gt;rowid, так и к&lt;/a&gt; таблицам БЕЗ ROWID . Единственное отличие состоит в том, что столбец rowid, который служит ключом для таблиц и который появляется как крайний правый термин в индексах, заменяется PRIMARY KEY.</target>
        </trans-unit>
        <trans-unit id="07bf749b7aaedba2ca3c53251a2ebc2903cbff5d" translate="yes" xml:space="preserve">
          <source>The basic procedure above may modified by the following additional rules:</source>
          <target state="translated">Приведенная выше базовая процедура может быть изменена следующими дополнительными правилами:</target>
        </trans-unit>
        <trans-unit id="5580fafc283a76d74ea47e0554226ba42ea5bc40" translate="yes" xml:space="preserve">
          <source>The behavior implemented by the AUTOINCREMENT keyword is subtly different from the default behavior. With AUTOINCREMENT, rows with automatically selected ROWIDs are guaranteed to have ROWIDs that have never been used before by the same table in the same database. And the automatically generated ROWIDs are guaranteed to be monotonically increasing. These are important properties in certain applications. But if your application does not need these properties, you should probably stay with the default behavior since the use of AUTOINCREMENT requires additional work to be done as each row is inserted and thus causes INSERTs to run a little slower.</source>
          <target state="translated">Поведение,реализованное ключевым словом AUTOINCREMENT,тонко отличается от поведения по умолчанию.С помощью AUTOINCREMENT в строках с автоматически выбранными ROWID гарантированно будут ROWID-идентификаторы,которые никогда раньше не использовались одной и той же таблицей в одной и той же базе данных.И автоматически сгенерированные ROWID гарантированно монотонно увеличиваются.Это важные свойства в некоторых приложениях.Но если ваше приложение не нуждается в этих свойствах,вы,вероятно,должны придерживаться поведения по умолчанию,так как использование АВТОИНКРЕМЕНТА требует дополнительной работы,так как каждая строка вставляется и таким образом заставляет INSERT'ы работать немного медленнее.</target>
        </trans-unit>
        <trans-unit id="53ddd9ac28fbcaf8f2c3233a5b531ac7ced77a80" translate="yes" xml:space="preserve">
          <source>The behavior of cache_size with a negative N was different prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16). In earlier versions, the number of pages in the cache was set to the absolute value of N.</source>
          <target state="translated">Поведение cache_size с отрицательным N отличалось до &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;версии 3.7.10&lt;/a&gt; (2012-01-16). В более ранних версиях для количества страниц в кэше было установлено абсолютное значение N.</target>
        </trans-unit>
        <trans-unit id="478ce327d17671071ecdc539934c95e63faeda7c" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">Поведение sqlite3changeset_apply_v2 () и его потокового эквивалента можно изменить, передав комбинацию &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;поддерживаемых флагов&lt;/a&gt; в качестве 9-го параметра.</target>
        </trans-unit>
        <trans-unit id="6e75893c7d343c6a289f5aa0da4c1e36a51499e7" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetapply_invert&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="translated">Поведение sqlite3changeset_apply_v2 () и его потокового эквивалента можно изменить, передав комбинацию &lt;a href=&quot;c_changesetapply_invert&quot;&gt;поддерживаемых флагов&lt;/a&gt; в качестве 9-го параметра.</target>
        </trans-unit>
        <trans-unit id="3b226ef505264d45ed6c9760d30054930a97eb46" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">Поведение sqlite3changeset_start_v2 () и его потокового эквивалента можно изменить, передав комбинацию &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;поддерживаемых флагов&lt;/a&gt; в качестве 4-го параметра.</target>
        </trans-unit>
        <trans-unit id="462fed9af71f32884c9943463dae76b5706b0104" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetstart_invert&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="translated">Поведение sqlite3changeset_start_v2 () и его потокового эквивалента можно изменить, передав комбинацию &lt;a href=&quot;c_changesetstart_invert&quot;&gt;поддерживаемых флагов&lt;/a&gt; в качестве 4-го параметра.</target>
        </trans-unit>
        <trans-unit id="0cd600a43e57a68ed3c7e61e8926b28cfcf03236" translate="yes" xml:space="preserve">
          <source>The behaviour described above may be modified slightly by using the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt; pragma to change the isolation level from serialized (the default), to read-uncommitted.</source>
          <target state="translated">Поведение, описанное выше, можно немного изменить, используя прагму &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted,&lt;/a&gt; чтобы изменить уровень изоляции с сериализованного (по умолчанию) на чтение-незафиксированный.</target>
        </trans-unit>
        <trans-unit id="d91219df791273fdd065b20fbe3a1ddef8cd79ad" translate="yes" xml:space="preserve">
          <source>The behaviour of queries when a column-filter is specified both as part of the FTS query and by using a column as the LHS of a MATCH operator is slightly different. For a table with columns &quot;a&quot; and &quot;b&quot; and a query similar to:</source>
          <target state="translated">Поведение запросов,когда колонка-фильтр указана как в запросе FTS,так и при использовании колонки в качестве LHS оператора MATCH,несколько отличается.Для таблицы со столбцами &quot;a&quot; и &quot;b&quot; и аналогичного запроса:</target>
        </trans-unit>
        <trans-unit id="1b74d0e5579c64699d464837588df4c3744c10fa" translate="yes" xml:space="preserve">
          <source>The best approach to make reliable backup copies of an SQLite database is to make use of the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; that is part of the SQLite library. Failing that, it is safe to make a copy of an SQLite database file as long as there are no transactions in progress by any process. If the previous transaction failed, then it is important that any rollback journal (the &lt;code&gt;*-journal&lt;/code&gt; file) or write-ahead log (the &lt;code&gt;*-wal&lt;/code&gt; file) be copied together with the database file itself.</source>
          <target state="translated">Лучший подход к созданию надежных резервных копий базы данных SQLite - использовать &lt;a href=&quot;backup&quot;&gt;API резервного копирования,&lt;/a&gt; который является частью библиотеки SQLite. В противном случае можно безопасно сделать копию файла базы данных SQLite, если ни один из процессов не выполняет транзакции. Если предыдущая транзакция &lt;code&gt;*-journal&lt;/code&gt; неудачно, важно, чтобы любой журнал отката ( файл * -journal ) или журнал упреждающей записи ( файл &lt;code&gt;*-wal&lt;/code&gt; ) копировались вместе с самим файлом базы данных.</target>
        </trans-unit>
        <trans-unit id="3e4c95bce459286798ea2a27bd9ecd8decb1253c" translate="yes" xml:space="preserve">
          <source>The best feature of SQL (in &lt;u&gt;all&lt;/u&gt; its implementations, not just SQLite) is that it is a</source>
          <target state="translated">Лучшая особенность SQL (во &lt;u&gt;всех&lt;/u&gt; его реализациях, а не только SQLite) заключается в том, что он</target>
        </trans-unit>
        <trans-unit id="dc958ef4fbaadd7154585494d4a1f0d8657cd355" translate="yes" xml:space="preserve">
          <source>The block above uses a shorthand form to create the foreign key constraint. Attaching a &quot;REFERENCES</source>
          <target state="translated">В приведенном выше блоке для создания ограничения по внешнему ключу используется сокращенная форма.Прикрепление &quot;Переопределения</target>
        </trans-unit>
        <trans-unit id="be5a6e82c647cd58e78eb343df366b2a12164999" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the leaf node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node.</source>
          <target state="translated">Блокада,соответствующая узлу листа с наибольшей блокой,принадлежащей этому сегменту b-дерева.Или ноль,если весь сегмент b-дерева укладывается в корневой узел.</target>
        </trans-unit>
        <trans-unit id="8114ba8fdc8ebfe0e7461c055a0e2fd44faa8a98" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the node with the smallest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always a leaf node.</source>
          <target state="translated">Блокада,соответствующая узлу с наименьшей блокой,принадлежащей этому сегменту b-дерева.Или ноль,если весь сегмент b-дерева укладывается в корневой узел.Если он существует,то этот узел всегда является узлом листа.</target>
        </trans-unit>
        <trans-unit id="f9a2b7b8a28aace68acd7dc6116c16ed08d188be" translate="yes" xml:space="preserve">
          <source>The boolean identifiers TRUE and FALSE are usually just aliases for the integer values 1 and 0, respectively. However, if TRUE or FALSE occur on the right-hand side of an IS operator, then they form new unary postfix operators &quot;IS TRUE&quot; and &quot;IS FALSE&quot; which test the boolean value of the operand on the left.</source>
          <target state="translated">Булевы идентификаторы TRUE и FALSE обычно являются просто псевдонимами для целочисленных значений 1 и 0 соответственно.Однако,если TRUE или FALSE встречаются справа от оператора IS,то они образуют новые унарные постфиксные операторы &quot;IS TRUE&quot; и &quot;IS FALSE&quot;,которые проверяют булевое значение операнда слева.</target>
        </trans-unit>
        <trans-unit id="cab234605422320bfe969b5533e06293770750e7" translate="yes" xml:space="preserve">
          <source>The boundary between a file format and an application format is fuzzy. This article calls JPEG a file format, but for an image editor, JPEG might be considered the application format. Much depends on context. For this article, let us say that a file format stores a single object and an application format stores many different objects and their relationships to one another.</source>
          <target state="translated">Граница между форматом файла и форматом приложения размыта.В этой статье JPEG называется форматом файла,но для редактора изображений JPEG можно считать форматом приложения.Многое зависит от контекста.Для этой статьи скажем,что формат файла хранит один объект,а формат приложения хранит множество различных объектов и их связи друг с другом.</target>
        </trans-unit>
        <trans-unit id="47707c3fbd653507bcb6765a57019dc2e9df3e77" translate="yes" xml:space="preserve">
          <source>The boundary description &quot;0 PRECEDING&quot; always means the same thing as &quot;CURRENT ROW&quot;.</source>
          <target state="translated">Описание границы &quot;0 ПОКАЗАТЕЛЬСТВА&quot; всегда означает то же самое,что и &quot;CURRENT ROW&quot;.</target>
        </trans-unit>
        <trans-unit id="65e8d52b8ac553953a11325088115a059c247d93" translate="yes" xml:space="preserve">
          <source>The build process makes extensive use of the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; scripting language. You will need to have a copy of TCL installed in order for the make targets above to work. Easy-to-use installers can be obtained from &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http://www.tcl-lang.org/&lt;/a&gt;. Many unix workstations have Tcl installed by default.</source>
          <target state="translated">В процессе сборки широко используется язык сценариев &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; . Вам потребуется установить копию TCL, чтобы указанные выше цели make работали. Простые в использовании установщики можно получить по &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;адресу http://www.tcl-lang.org/&lt;/a&gt; . На многих рабочих станциях unix по умолчанию установлен Tcl.</target>
        </trans-unit>
        <trans-unit id="7d4e60a19016fc83307d1ede2e1aa59927cbae39" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif(x,y,z) SQL function&lt;/a&gt; is logically equivalent to &quot;CASE WHEN x THEN y ELSE z END&quot;. The iif() function is found in SQL Server and is included in SQLite for compatibility. Some developers prefer the iif() function because it is more concise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9c97359a7945f825df70e8e7d3bf03b435fc83" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; have been enhanced so that they can be used in &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, and in the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, provided that they do not use the 'now', 'localtime', or 'utc' keywords. &lt;a href=&quot;deterministic#dtexception&quot;&gt;More information&lt;/a&gt;.</source>
          <target state="translated">Встроенные &lt;a href=&quot;lang_datefunc&quot;&gt;функции даты и времени&lt;/a&gt; были улучшены, так что их можно использовать в &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничениях CHECK&lt;/a&gt; , в &lt;a href=&quot;expridx&quot;&gt;индексах для выражений&lt;/a&gt; и в предложениях WHERE &lt;a href=&quot;partialindex&quot;&gt;частичных индексов&lt;/a&gt; , при условии, что они не используют 'now', 'localtime', или ключевые слова utc. &lt;a href=&quot;deterministic#dtexception&quot;&gt;Больше информации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a2f201a6d744f00508ed72b40ed46b5c83f60f1" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96663fb71968ae34b1131b3cb53ad7ba03319209" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allows.</source>
          <target state="translated">Особый случай - встроенные &lt;a href=&quot;lang_datefunc&quot;&gt;функции даты и времени&lt;/a&gt; SQLite. Эти функции обычно считаются детерминированными. Однако, если эти функции используют строку &amp;laquo;сейчас&amp;raquo; в качестве даты, или если они используют &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;модификатор localtime&lt;/a&gt; или &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;модификатор utc&lt;/a&gt; , то они считаются недетерминированными. Поскольку входные данные функции не обязательно известны до времени выполнения, функции даты / времени вызовут исключение, если они обнаружат любую из недетерминированных функций в контексте, где разрешены только детерминированные функции.</target>
        </trans-unit>
        <trans-unit id="adf744ca87e6c1a5f3b9a68b24961edea60809eb" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite understand date/times in all of the formats above, and can freely change between them. Which format you use, is entirely up to your application.</source>
          <target state="translated">Встроенные &lt;a href=&quot;lang_datefunc&quot;&gt;функции даты и времени&lt;/a&gt; SQLite понимают дату и время во всех форматах, указанных выше, и могут свободно переключаться между ними. Какой формат вы используете, полностью зависит от вашего приложения.</target>
        </trans-unit>
        <trans-unit id="8a5b38222ac4fb96f9a2b189215735dd804f8b2d" translate="yes" xml:space="preserve">
          <source>The built-in BINARY collation compares strings byte by byte using the memcmp() function from the standard C library.</source>
          <target state="translated">Встроенная функция BINARY сравнивает строки байт за байтом с помощью функции memcmp()из стандартной библиотеки Си.</target>
        </trans-unit>
        <trans-unit id="1b9d8615812e1b5dddaadf330db3704ed6104526" translate="yes" xml:space="preserve">
          <source>The built-in SQLite has compile-time options such as SQLITE_PRINTF_PRECISION_LIMIT that provide defense against denial-of-service attacks for application that expose the printf() functionality to untrusted users.</source>
          <target state="translated">Встроенный SQLite имеет опции времени компиляции,такие как SQLITE_PRINTF_PRECISION_LIMIT,которые обеспечивают защиту от атак типа &quot;отказ в обслуживании&quot; для приложений,которые подвергают функциональность printf()недоверенным пользователям.</target>
        </trans-unit>
        <trans-unit id="55ca16581ef8177476edac12f1cd562f40820547" translate="yes" xml:space="preserve">
          <source>The built-in Wagner edit-distance function with fixed weights can be replaced by the &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function with application-defined weights and support for unicode, by specifying the &quot;edit_cost_table=</source>
          <target state="translated">Встроенная функция расстояния редактирования Вагнера с фиксированными весами может быть заменена &lt;a href=&quot;spellfix1#editdist3&quot;&gt;функцией&lt;/a&gt; редактирования расстояния editdist3 () с весами, определяемыми приложением, и поддержкой юникода, указав &quot;edit_cost_table =</target>
        </trans-unit>
        <trans-unit id="919d1860b9bd16d4532d25388f1ffc8375baa209" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary function bm25() returns a real value indicating how well the current row matches the full-text query. The better the match, the numerically smaller the value returned. A query such as the following may be used to return matches in order from best to worst match:</source>
          <target state="translated">Встроенная вспомогательная функция bm25()возвращает реальное значение,указывающее на соответствие текущей строки полнотекстовому запросу.Чем лучше соответствие,тем меньше возвращаемое числовое значение.Для возврата совпадений по порядку от лучшего к худшему может быть использован такой запрос,как следующий:</target>
        </trans-unit>
        <trans-unit id="89afdc49975b5af95582dcbca838ad26684b8aa6" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary functions provided as part of FTS5 are described in the following section. Applications may also implement &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;custom auxiliary functions in C&lt;/a&gt;.</source>
          <target state="translated">Встроенные дополнительные функции, входящие в состав FTS5, описаны в следующем разделе. Приложения могут также реализовать &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;пользовательские вспомогательные функции в C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9249ce5cc7f5a31c9f40d1d2aedadc1d6c797929" translate="yes" xml:space="preserve">
          <source>The built-in functions used to implement LIKE and GLOB must not have been overloaded using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">Встроенные функции, используемые для реализации LIKE и GLOB, не должны быть перегружены с помощью API &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49a23aa1a5c2e20f2c3c4ac966e9783cdfed04b2" translate="yes" xml:space="preserve">
          <source>The built-in memory allocators in SQLite also provide the following additional interfaces:</source>
          <target state="translated">Встроенные аллокаторы памяти в SQLite также предоставляют следующие дополнительные интерфейсы:</target>
        </trans-unit>
        <trans-unit id="4fa083c0cbf6940d57170ea9aa2f51d37713e7a7" translate="yes" xml:space="preserve">
          <source>The built-in min() and max() functions now honor the difference between NUMERIC and TEXT datatypes. Formerly, min() and max() always assumed their arguments were of type NUMERIC.</source>
          <target state="translated">Встроенные функции min()и max()теперь учитывают разницу между типами данных NUMERIC и TEXT.Раньше функции min()и max()всегда предполагали,что их аргументы имеют тип NUMERIC.</target>
        </trans-unit>
        <trans-unit id="09829581870ec4ebe1c207006b15fd18f63554a5" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation does not handle posix positional referencing modifiers that allow the order of arguments to printf() to be different from the order of the %-substitutions. In the built-in printf(), the order of the arguments must exactly match the order of the %-substitutions.</source>
          <target state="translated">Встроенная реализация printf()не обрабатывает модификаторы позиционирования,которые позволяют порядок аргументов для printf()отличаться от порядка %-замещений.Во встроенной функции printf()порядок аргументов должен точно совпадать с порядком %-замещений.</target>
        </trans-unit>
        <trans-unit id="e86ab3d5db7f0615044de9985403c55275e95eaf" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation uses extra code space (about 7800 bytes on GCC 5.4 with -Os).</source>
          <target state="translated">Встроенная реализация printf()использует дополнительное кодовое пространство (около 7800 байт на GCC 5.4 с -O).</target>
        </trans-unit>
        <trans-unit id="68470e8ed26cf7ace0d2e09f00b9eab48903fc0b" translate="yes" xml:space="preserve">
          <source>The built-in tokenizers and auxiliary functions described in this document are all implemented using the publicly available API described below.</source>
          <target state="translated">Встроенные токенайзеры и вспомогательные функции,описанные в этом документе,реализованы с использованием общедоступного API,описанного ниже.</target>
        </trans-unit>
        <trans-unit id="9fc396222878f092f3ee1e16fde31353451d89d0" translate="yes" xml:space="preserve">
          <source>The busy callback should not take any actions which modify the database connection that invoked the busy handler. In other words, the busy handler is not reentrant. Any such actions result in undefined behavior.</source>
          <target state="translated">Обратный вызов &quot;занято&quot; не должен предпринимать никаких действий по изменению соединения с БД,вызвавшего обработчик &quot;занято&quot;.Другими словами,обработчик &quot;занят&quot; не является реентерабельным.Любые такие действия приводят к неопределенному поведению.</target>
        </trans-unit>
        <trans-unit id="f4f573b1a486bc41f01b46a6d80d9ecec47641b0" translate="yes" xml:space="preserve">
          <source>The byte offset of the matching term within the column.</source>
          <target state="translated">Смещение байта совпадающего термина внутри столбца.</target>
        </trans-unit>
        <trans-unit id="05f015bc1e7204efce9fc81ea976f5bbb81740a9" translate="yes" xml:space="preserve">
          <source>The byte-order of UTF16 input text is determined by the byte-order mark (BOM, U+FEFF) found in first character, which is removed, or in the absence of a BOM the byte order is the native byte order of the host machine for sqlite3_bind_text16() or the byte order specified in the 6th parameter for sqlite3_bind_text64(). If UTF16 input text contains invalid unicode characters, then SQLite might change those invalid characters into the unicode replacement character: U+FFFD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb76aa2fa15c5bd4f4468b266b4d77ab34c0a75" translate="yes" xml:space="preserve">
          <source>The bytecode engine begins execution on instruction number 0. Execution continues until a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction is seen, or until the program counter becomes greater than the address of last instruction, or until there is an error. When the bytecode engine halts, all memory that it allocated is released and all database cursors it may have had open are closed. If the execution stopped due to an error, any pending transactions are terminated and changes made to the database are rolled back.</source>
          <target state="translated">Механизм байт-кода начинает выполнение с инструкции номер 0. Выполнение продолжается до тех пор, пока не будет обнаружена инструкция &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; , или пока счетчик программы не станет больше адреса последней инструкции, или пока не возникнет ошибка. Когда механизм байт-кода останавливается, вся выделенная им память освобождается, и все курсоры базы данных, которые он мог открыть, закрываются. Если выполнение остановлено из-за ошибки, все ожидающие транзакции прекращаются, а изменения, внесенные в базу данных, откатываются.</target>
        </trans-unit>
        <trans-unit id="9a6398c9082248055b1fbc77ff5022201f3b1441" translate="yes" xml:space="preserve">
          <source>The bytecode engine has no stack on which to store the return address of a subroutine. Return addresses must be stored in registers. Hence, bytecode subroutines are not reentrant.</source>
          <target state="translated">В движке байткода нет стека,в котором хранился бы адрес возврата подпрограммы.Адреса возвратов должны храниться в регистрах.Следовательно,подпрограммы байткода не являются реентерабельными.</target>
        </trans-unit>
        <trans-unit id="28f086fcda9ebdf902655d03a38811e78fc96fb9" translate="yes" xml:space="preserve">
          <source>The bytecode engine is &lt;u&gt;not&lt;/u&gt; an API of SQLite. Details about the bytecode engine change from one release of SQLite to the next. Applications that use SQLite should not depend on any of the details found in this document.</source>
          <target state="translated">Механизм байт-кода &lt;u&gt;не&lt;/u&gt; является API SQLite. Подробная информация об изменении механизма байт-кода от одного выпуска SQLite к другому. Приложения, использующие SQLite, не должны зависеть от каких-либо деталей, содержащихся в этом документе.</target>
        </trans-unit>
        <trans-unit id="8f39ef66488b6211208c988daf5ffcab23760705" translate="yes" xml:space="preserve">
          <source>The bytecode virtual machine is the heart of SQLite. Programmers who want to understand how SQLite operates internally must be familiar with the bytecode engine.</source>
          <target state="translated">Виртуальная машина с байткодом является сердцем SQLite.Программисты,которые хотят понять,как SQLite работает внутри,должны быть знакомы с движком байткода.</target>
        </trans-unit>
        <trans-unit id="efeaf3fe17bdefca5b34d3df41725c68d1db2de0" translate="yes" xml:space="preserve">
          <source>The cFrom and cTo columns show edit transformation strings. Either or both columns may contain more than one character. Or either column (but not both) may hold an empty string. When cFrom is empty, that is the cost of inserting cTo. When cTo is empty, that is the cost of deleting cFrom.</source>
          <target state="translated">В колонках cFrom и cTo показаны строки редактирования трансформации.Любой из столбцов или оба столбца могут содержать более одного символа.Или любой столбец (но не оба)может содержать пустую строку.Когда cFrom пуст,это стоимость вставки cTo.Когда cTo пустая-это стоимость удаления cFrom.</target>
        </trans-unit>
        <trans-unit id="334e7f3d3c0f1d00666221b0f79b06086771f2a0" translate="yes" xml:space="preserve">
          <source>The cache must not perform any reference counting. A single call to xUnpin() unpins the page regardless of the number of prior calls to xFetch().</source>
          <target state="translated">Кэш не должен производить подсчет ссылок.Одиночный вызов xUnpin()распечатывает страницу независимо от количества предыдущих вызовов xFetch().</target>
        </trans-unit>
        <trans-unit id="ba91e47edf5c7de46f6d683125d4647799118c05" translate="yes" xml:space="preserve">
          <source>The cache query parameter determines if the new database is opened using &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; or with a private cache.</source>
          <target state="translated">Параметр запроса кеша определяет, будет ли открыта новая база данных в &lt;a href=&quot;sharedcache&quot;&gt;режиме общего кэша&lt;/a&gt; или в частном кэше.</target>
        </trans-unit>
        <trans-unit id="3b1d92f7c11891a9dfcf8a02bdb8e1d1b67e45d9" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c24d3d1b52233a8d1d33d1521f0d40a35115941" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">Режим совместного использования кеша, установленный этим интерфейсом, влияет на все последующие вызовы &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; . Существующие соединения с базой данных продолжают использовать режим общего доступа, который действовал на момент их открытия.</target>
        </trans-unit>
        <trans-unit id="84568a531cbb8fea84a45d0e913a15a98ad6bdd3" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue to use the sharing mode that was in effect at the time they were opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37b504a453065b9fe4d5c4bf29c4836a5d7646e" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="translated">Режим совместного использования кеша, установленный этим интерфейсом, влияет на все последующие вызовы &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; . Существующие соединения с базой данных продолжают использовать режим общего доступа, который действовал на момент их открытия.</target>
        </trans-unit>
        <trans-unit id="e474b4529162f0cc96b1a00a4049ab5a12dcf32d" translate="yes" xml:space="preserve">
          <source>The cache-flush method &lt;a href=&quot;c3ref/finalize&quot;&gt;finalizes&lt;/a&gt; all prepared statements currently in the cache.</source>
          <target state="translated">Метод cache-flush &lt;a href=&quot;c3ref/finalize&quot;&gt;завершает&lt;/a&gt; все подготовленные операторы, находящиеся в данный момент в кеше.</target>
        </trans-unit>
        <trans-unit id="9d8d3b22c77f42c07d50a96703e45047516a539f" translate="yes" xml:space="preserve">
          <source>The cache_spill pragma enables or disables the ability of the pager to spill dirty cache pages to the database file in the middle of a transaction. Cache_spill is enabled by default and most applications should leave it that way as cache spilling is usually advantageous. However, a cache spill has the side-effect of acquiring an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;EXCLUSIVE lock&lt;/a&gt; on the database file. Hence, some applications that have large long-running transactions may want to disable cache spilling in order to prevent the application from acquiring an exclusive lock on the database until the moment that the transaction &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;s.</source>
          <target state="translated">Прагма cache_spill включает или отключает возможность пейджера передавать грязные страницы кэша в файл базы данных в середине транзакции. Cache_spill включен по умолчанию, и большинство приложений должны оставить его таким образом, поскольку проливание кеша обычно является преимуществом. Однако утечка кэша имеет побочный эффект в виде &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;ИСКЛЮЧИТЕЛЬНОЙ блокировки&lt;/a&gt; файла базы данных. Следовательно, некоторые приложения, которые имеют большие длительные транзакции, могут захотеть отключить переполнение кеша, чтобы предотвратить получение приложением монопольной блокировки базы данных до момента, когда транзакция &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; s.</target>
        </trans-unit>
        <trans-unit id="9721a1202302bdb3675cb33fdaf401b47649ef3f" translate="yes" xml:space="preserve">
          <source>The callback function is used to receive the results of a query. A prototype for the callback function is as follows:</source>
          <target state="translated">Функция обратного вызова используется для получения результатов запроса.Прототипом функции обратного вызова является следующий:</target>
        </trans-unit>
        <trans-unit id="dce299de07269b78871b3c034bf37ba0c0271573" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">Функция обратного вызова, зарегистрированная sqlite3_profile (), вызывается после завершения каждого оператора SQL. Обратный вызов профиля содержит исходный текст оператора и приблизительное время выполнения этого оператора. Время обратного вызова профиля выражается в наносекундах, однако текущая реализация допускает только миллисекундное разрешение, поэтому шесть наименьших значащих цифр времени не имеют смысла. В будущих версиях SQLite может быть обеспечено большее разрешение обратного вызова профилировщика. Вызов &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; отменит обратный вызов профиля.</target>
        </trans-unit>
        <trans-unit id="a6f29aa702b9f0b66493dfb5e14c2df5fa8051eb" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="translated">Функция обратного вызова, зарегистрированная sqlite3_profile (), вызывается после завершения каждого оператора SQL. Обратный вызов профиля содержит исходный текст оператора и приблизительное время выполнения этого оператора. Время обратного вызова профиля выражается в наносекундах, однако текущая реализация допускает только миллисекундное разрешение, поэтому шесть наименьших значащих цифр времени не имеют смысла. В будущих версиях SQLite может быть обеспечено большее разрешение обратного вызова профилировщика. Вызов &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; или &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; отменит обратный вызов профиля.</target>
        </trans-unit>
        <trans-unit id="6cc8b0e0c1561082e8c35dc0acaf0338a474ad77" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">Функция обратного вызова, зарегистрированная sqlite3_trace (), вызывается в разное время, когда SQL-оператор выполняется &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Обратный вызов sqlite3_trace () вызывается с отрисовкой текста оператора SQL в кодировке UTF-8, когда оператор начинает выполняться первым. Дополнительные обратные вызовы sqlite3_trace () могут возникать при входе в каждую запущенную подпрограмму. Обратные вызовы для триггеров содержат комментарий SQL UTF-8, который идентифицирует триггер.</target>
        </trans-unit>
        <trans-unit id="ce29a09fb52c337eecabbd8bc599ef45377bf00d" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="translated">Функция обратного вызова, зарегистрированная sqlite3_trace (), вызывается в разное время, когда SQL-оператор выполняется &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Обратный вызов sqlite3_trace () вызывается с отрисовкой текста оператора SQL в кодировке UTF-8, когда оператор начинает выполняться первым. Дополнительные обратные вызовы sqlite3_trace () могут возникать при входе в каждую запущенную подпрограмму. Обратные вызовы для триггеров содержат комментарий SQL UTF-8, который идентифицирует триггер.</target>
        </trans-unit>
        <trans-unit id="b2f2fd31e08bf7a8ddd0b8f8f2559aa236b781e8" translate="yes" xml:space="preserve">
          <source>The callback function should normally return 0. If the callback function returns non-zero, the query is immediately aborted and &lt;b&gt;sqlite_exec&lt;/b&gt; will return SQLITE_ABORT.</source>
          <target state="translated">Функция обратного вызова обычно должна возвращать 0. Если функция обратного вызова возвращает ненулевое значение, запрос немедленно прерывается, и &lt;b&gt;sqlite_exec&lt;/b&gt; возвращает SQLITE_ABORT.</target>
        </trans-unit>
        <trans-unit id="2394e983e60bde9a89a8173fd3ab1cfc913e1dc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">Функция обратного вызова обычно должна возвращать &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; . Если возвращается код ошибки, эта ошибка будет распространяться обратно через базу кода SQLite, чтобы оператор, который спровоцировал обратный вызов, сообщил об ошибке, хотя фиксация все равно произойдет. Если обратный вызов возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; или &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; или возвращает значение, не соответствующее какому-либо допустимому коду ошибки SQLite, результаты не определены.</target>
        </trans-unit>
        <trans-unit id="e115553094195c6d671fc1803e4945ba335eedc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="translated">Функция обратного вызова обычно должна возвращать &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; . Если возвращается код ошибки, эта ошибка будет распространяться обратно через базу кода SQLite, чтобы оператор, который спровоцировал обратный вызов, сообщил об ошибке, хотя фиксация все равно произойдет. Если обратный вызов возвращает &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; или &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; или возвращает значение, не соответствующее какому-либо допустимому коду ошибки SQLite, результаты не определены.</target>
        </trans-unit>
        <trans-unit id="dd2c627a789615e3efe180bdedfefe32d9d62d76" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">Функция обратного вызова должна зарегистрировать желаемое сопоставление с помощью &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c17f517957de57a117a3b4627294584d44e59419" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="translated">Функция обратного вызова должна зарегистрировать желаемое сопоставление с помощью &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; , &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16 ()&lt;/a&gt; или &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fefabcb34707d427a36b9901ef209a203d46bf9f" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">Обратный вызов вызывается SQLite после совершения фиксации и снятия связанной блокировки записи в базе данных, поэтому реализация может читать, записывать или &lt;a href=&quot;../wal#ckpt&quot;&gt;проверять&lt;/a&gt; базу данных по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="f6c4a8d646e0cbd66ca6c45574aae0dd0351286a" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="translated">Обратный вызов вызывается SQLite после совершения фиксации и снятия связанной блокировки записи в базе данных, поэтому реализация может читать, записывать или &lt;a href=&quot;wal#ckpt&quot;&gt;проверять&lt;/a&gt; базу данных по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="facad5f03164aa5e049b3e0fcdccc7d1ce7b086d" translate="yes" xml:space="preserve">
          <source>The callback is invoked every N virtual machine operations, where N is supplied as the second argument to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt;. The third and fourth arguments to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; are a pointer to the routine to be invoked and a void pointer to be passed as the first argument to it.</source>
          <target state="translated">Обратный вызов вызывается каждые N операций виртуальной машины, где N предоставляется в качестве второго аргумента функции &lt;b&gt;sqlite_progress_handler ()&lt;/b&gt; . Третий и четвертый аргументы &lt;b&gt;sqlite_progress_handler ()&lt;/b&gt; - это указатель на вызываемую процедуру и указатель void, который должен быть передан ей в качестве первого аргумента.</target>
        </trans-unit>
        <trans-unit id="70ae791199d0c0d2e25d25668478f3c97d6fcbcf" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">Обратный вызов, зарегистрированный этой функцией, заменяет любой существующий обратный вызов, зарегистрированный с помощью &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; . Точно так же регистрация обратного вызова с помощью &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; отключает механизм автоматической контрольной точки, настроенный этой функцией.</target>
        </trans-unit>
        <trans-unit id="95427739ef742c846008bdf4e9ade466f5ff0b68" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="translated">Обратный вызов, зарегистрированный этой функцией, заменяет любой существующий обратный вызов, зарегистрированный с помощью &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; . Точно так же регистрация обратного вызова с помощью &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; отключает механизм автоматической контрольной точки, настроенный этой функцией.</target>
        </trans-unit>
        <trans-unit id="af79ec8f0bec910d80bc717aab639238d9ea73fe" translate="yes" xml:space="preserve">
          <source>The caller could distinguish between this special &quot;DROP TABLE|INDEX&quot; case and other cases by using &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. When it is appropriate to call &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt;, the extended error code is SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the &quot;DROP TABLE|INDEX&quot; case, it is just plain SQLITE_LOCKED. Another solution might be to limit the number of times that any single query could be reattempted (to say 100). Although this might be less efficient than one might wish, the situation in question is not likely to occur often.</source>
          <target state="translated">Вызывающий может отличить этот специальный случай &amp;laquo;DROP TABLE | INDEX&amp;raquo; от других случаев, используя &lt;a href=&quot;rescode#extrc&quot;&gt;расширенные коды ошибок&lt;/a&gt; . Когда уместно вызвать &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; , расширенный код ошибки - SQLITE_LOCKED_SHAREDCACHE. В противном случае в случае &quot;DROP TABLE | INDEX&quot; это просто SQLITE_LOCKED. Другим решением может быть ограничение количества повторных попыток выполнения любого отдельного запроса (скажем, 100). Хотя это может быть менее эффективным, чем можно было бы ожидать, рассматриваемая ситуация вряд ли будет возникать часто.</target>
        </trans-unit>
        <trans-unit id="b3f82dd9e0519120922fe3d796ee7df0852a43b3" translate="yes" xml:space="preserve">
          <source>The canonical FTS5 source code consists of a series of *.c and other files in the &quot;ext/fts5&quot; directory of the SQLite source tree. A build process reduces this to just two files - &quot;fts5.c&quot; and &quot;fts5.h&quot; - which may be used to build an SQLite loadable extension.</source>
          <target state="translated">Канонический исходный код FTS5 состоит из серии *.c и других файлов в директории &quot;ext/fts5&quot; исходного дерева SQLite.Процесс сборки сводится к двум файлам-&quot;fts5.c&quot; и &quot;fts5.h&quot;.-которые могут быть использованы для сборки загружаемого расширения SQLite.</target>
        </trans-unit>
        <trans-unit id="821b27603ed5a2bcfa634bb0e0d6241eee07c748" translate="yes" xml:space="preserve">
          <source>The carray() function can be used in the FROM clause of a query. For example, to query two entries from the OBJ table using rowids taken from a C-language array at address $PTR.</source>
          <target state="translated">Функция carray()может быть использована в выражении FROM запроса.Например,для запроса двух записей из OBJ-таблицы можно использовать rowids,взятые из массива на языке C по адресу $PTR.</target>
        </trans-unit>
        <trans-unit id="44fb31ec0ece772e4bff94846b749fc144432db5" translate="yes" xml:space="preserve">
          <source>The carray() function is not compiled into SQLite by default. It is available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext/misc/carray.c&lt;/a&gt; source file.</source>
          <target state="translated">По умолчанию функция carray () не компилируется в SQLite. Он доступен как &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение&lt;/a&gt; в исходном файле &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext / misc / carray.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="435764c5d08e172eacd91d4b4315996e3f48003b" translate="yes" xml:space="preserve">
          <source>The carray() function takes two or three arguments. The first argument is a pointer to an array. Since pointer values cannot be specified directly in SQL, the first argument must be a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a pointer value using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface using a pointer-type of &quot;carray&quot;. The second argument is the number of elements in the array. The optional third argument is a string that determines the datatype of the elements in the C-language array. Allowed values for the third argument are:</source>
          <target state="translated">Функция carray () принимает два или три аргумента. Первый аргумент - это указатель на массив. Поскольку значения указателя не могут быть указаны непосредственно в SQL, первый аргумент должен быть &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; который привязан к значению указателя с помощью интерфейса &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; с использованием типа указателя &quot;carray&quot;. Второй аргумент - это количество элементов в массиве. Необязательный третий аргумент - это строка, которая определяет тип данных элементов в массиве языка Си. Допустимые значения для третьего аргумента:</target>
        </trans-unit>
        <trans-unit id="41b5d7c612b8b2127750760016443da99495e2ab" translate="yes" xml:space="preserve">
          <source>The casual reader is not expected to understand or remember any part of the list above. The point of this list is to demonstrate that the decision of whether or not to flatten a query is complex.</source>
          <target state="translated">От случайного читателя не ожидается,что он поймет или запомнит какую-либо часть вышеприведенного списка.Смысл этого списка состоит в том,чтобы продемонстрировать,что решение о том,сгладить запрос или нет,является сложным.</target>
        </trans-unit>
        <trans-unit id="bcf344511369b084d726030fdafcea463d5dc468" translate="yes" xml:space="preserve">
          <source>The cell content area</source>
          <target state="translated">Область содержимого ячейки</target>
        </trans-unit>
        <trans-unit id="4e5d403004805e89c7f707b8add474e39df5ebd7" translate="yes" xml:space="preserve">
          <source>The cell pointer array</source>
          <target state="translated">Массив указателей ячеек</target>
        </trans-unit>
        <trans-unit id="e6c56d9636275558f42c1d09a95b01d119d13bcb" translate="yes" xml:space="preserve">
          <source>The cell pointer array of a b-tree page immediately follows the b-tree page header. Let K be the number of cells on the btree. The cell pointer array consists of K 2-byte integer offsets to the cell contents. The cell pointers are arranged in key order with left-most cell (the cell with the smallest key) first and the right-most cell (the cell with the largest key) last.</source>
          <target state="translated">Массив указателей ячеек b-деревянной страницы сразу же следует за заголовком b-деревянной страницы.Пусть K будет числом ячеек в btree.Массив указателей ячеек состоит из K 2-байтовых целочисленных смещений к содержимому ячейки.Указатели на ячейки располагаются в порядке следования ключей,самая левая (ячейка с наименьшим ключом)-первая,самая правая (ячейка с наибольшим ключом)-последняя.</target>
        </trans-unit>
        <trans-unit id="1302721086a59f9c1c80a0439335aec4ebc89654" translate="yes" xml:space="preserve">
          <source>The cell_size_check pragma enables or disables additional sanity checking on database b-tree pages as they are initially read from disk. With cell size checking enabled, database corruption is detected earlier and is less likely to &quot;spread&quot;. However, there is a small performance hit for doing the extra checks and so cell size checking is turned off by default.</source>
          <target state="translated">Прагма cells_size_check включает или отключает дополнительную проверку вменяемости на страницах b-дерева базы данных по мере того,как они изначально считываются с диска.При включенной проверке размера ячеек повреждение базы данных обнаруживается раньше и с меньшей вероятностью &quot;распространится&quot;.Однако,для выполнения дополнительных проверок есть небольшое снижение производительности,поэтому проверка размера ячеек по умолчанию отключена.</target>
        </trans-unit>
        <trans-unit id="68b13b4df554f0eca9f783dc081206c3c433b689" translate="yes" xml:space="preserve">
          <source>The cg_anno.tcl script removes extraneous details from the default cachegrind annotation output so that before-and-after reports can be compared using a side-by-side diff to view specific details of how a micro-optimization attempt affected performance.</source>
          <target state="translated">Скрипт cg_anno.tcl удаляет посторонние детали из вывода аннотаций по умолчанию cachegrind,так что до и после отчетов можно сравнить,используя бок о бок,чтобы посмотреть конкретные детали того,как попытка микро-оптимизации повлияла на производительность.</target>
        </trans-unit>
        <trans-unit id="fdc2d39d7bf4988a1e3259d80bd003ba0f7f2a24" translate="yes" xml:space="preserve">
          <source>The change is made by an SQL trigger or foreign key action instead of directly as a result of a users SQL statement.</source>
          <target state="translated">Изменение производится с помощью SQL триггера или действия постороннего ключа,а не непосредственно в результате пользовательского SQL-оператора.</target>
        </trans-unit>
        <trans-unit id="55b6de28efb13f598ab97e8c9b2ad359898d3863" translate="yes" xml:space="preserve">
          <source>The changes must consist of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations only. CREATE and DROP operations are not supported.</source>
          <target state="translated">Изменения должны состоять только из операций &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; . Операции CREATE и DROP не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="204b32b2b5c56879d06b01e160a1a35686edf225" translate="yes" xml:space="preserve">
          <source>The changes to locking and concurrency control in SQLite version 3 also introduce some subtle changes in the way transactions work at the SQL language level. By default, SQLite version 3 operates in &lt;em&gt;autocommit&lt;/em&gt; mode. In autocommit mode, all changes to the database are committed as soon as all operations associated with the current database connection complete.</source>
          <target state="translated">Изменения в блокировке и управлении параллелизмом в SQLite версии 3 также вносят некоторые тонкие изменения в способ работы транзакций на уровне языка SQL. По умолчанию SQLite версии 3 работает в режиме &lt;em&gt;автоматической фиксации&lt;/em&gt; . В режиме автоматической фиксации все изменения в базе данных фиксируются, как только завершаются все операции, связанные с текущим подключением к базе данных.</target>
        </trans-unit>
        <trans-unit id="9ec4059d42e348f2d46482a218570373eadf5d72" translate="yes" xml:space="preserve">
          <source>The changes() function returns the number of database rows that were changed or inserted or deleted by the most recently completed INSERT, DELETE, or UPDATE statement, exclusive of statements in lower-level triggers. The changes() SQL function is a wrapper around the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; C/C++ function and hence follows the same rules for counting changes.</source>
          <target state="translated">Функция changes () возвращает количество строк базы данных, которые были изменены, вставлены или удалены последним завершенным оператором INSERT, DELETE или UPDATE, за исключением операторов в триггерах нижнего уровня. Функция SQL changes () является оболочкой для &lt;a href=&quot;c3ref/changes&quot;&gt;функции sqlite3_changes ()&lt;/a&gt; C / C ++ и, следовательно, следует тем же правилам для подсчета изменений.</target>
        </trans-unit>
        <trans-unit id="a67c4e9392e6b6f9ae02f045b5dfeb70fe9c0330" translate="yes" xml:space="preserve">
          <source>The char(X1,X2,...,XN) function returns a string composed of characters having the unicode code point values of integers X1 through XN, respectively.</source>
          <target state="translated">Функция char(X1,X2,...,XN)возвращает строку,состоящую из символов,имеющих значения точек юникода для целых чисел от X1 до XN,соответственно.</target>
        </trans-unit>
        <trans-unit id="37f1486781d28feebc971db6315e3ab886799387" translate="yes" xml:space="preserve">
          <source>The chart below shows average time to read a blob directly from the filesystem versus the time needed to read the same blob from the SQLite database. The actual timings vary considerably from one system to another (the Ubuntu desktop is much faster than the Galaxy S3 phone, for example). This chart shows the ratio of the times needed to read blobs from a file divided by the time needed to from the database. The left-most column in the chart is the normalized time to read from the database, for reference.</source>
          <target state="translated">На графике ниже показано среднее время чтения блока непосредственно из файловой системы по сравнению со временем,необходимым для чтения того же блока из базы данных SQLite.Фактические тайминги значительно варьируются в зависимости от системы (например,рабочий стол Ubuntu намного быстрее,чем телефон Galaxy S3).Этот график показывает соотношение времени,необходимого для чтения блоков из файла,деленное на время,необходимое для чтения из базы данных.Самый левый столбец диаграммы-это нормализованное время для чтения из базы данных,для справки.</target>
        </trans-unit>
        <trans-unit id="f11b1918c906d3777fe0d3b93cddb4875a03b224" translate="yes" xml:space="preserve">
          <source>The chart below shows data collected using &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; on five different systems:</source>
          <target state="translated">На диаграмме ниже показаны данные, собранные с помощью &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; в пяти различных системах:</target>
        </trans-unit>
        <trans-unit id="7328593ed0585c2ca2a1685910b260ca61685e5b" translate="yes" xml:space="preserve">
          <source>The chart below shows the relative size and performance for SQLite as of 2017-10-08 for various compilers and optimization settings as tested on Ubuntu 16.04.3 on x86_64. General observations:</source>
          <target state="translated">На графике ниже показан относительный размер и производительность SQLite по состоянию на 2017-10-08 годы для различных компиляторов и настройки оптимизации,протестированные на Ubuntu 16.04.3 на x86_64.Общие замечания:</target>
        </trans-unit>
        <trans-unit id="3c6947bf2e572c7854301cde9f7c5737935d4086" translate="yes" xml:space="preserve">
          <source>The chart shows that on Windows10, content can be read from the SQLite database about 5 times faster than it can be read directly from disk. On Android, SQLite is only about 35% faster than reading from disk.</source>
          <target state="translated">На графике видно,что в Windows10 контент можно читать из базы данных SQLite примерно в 5 раз быстрее,чем непосредственно с диска.На Android,SQLite всего лишь примерно на 35% быстрее,чем чтение с диска.</target>
        </trans-unit>
        <trans-unit id="4b79be443470ce0f3ea4b17f53ee3e0a63d67172" translate="yes" xml:space="preserve">
          <source>The check-in has a &quot;trunk&quot; tag.</source>
          <target state="translated">На регистрации есть метка &quot;багажник&quot;.</target>
        </trans-unit>
        <trans-unit id="83b47a927090544c586621a60b2916e19fae4550" translate="yes" xml:space="preserve">
          <source>The check-in has a child that has a &quot;trunk&quot; tag.</source>
          <target state="translated">У зарегистрированного ребенка есть метка &quot;багажник&quot;.</target>
        </trans-unit>
        <trans-unit id="62c61bcc8ce340ae3a9c5cbdd0d35b553d2386d8" translate="yes" xml:space="preserve">
          <source>The check-in has a parent that has a &quot;trunk&quot; tag.</source>
          <target state="translated">У регистрации есть родитель,у которого есть тэг &quot;багажник&quot;.</target>
        </trans-unit>
        <trans-unit id="b751a07c985fa86fe7c3c40b3bf6704b7852bcb1" translate="yes" xml:space="preserve">
          <source>The checksum algorithm only works for content which is a multiple of 8 bytes in length. In other words, if the inputs are x(0) through x(N) then N must be odd. The checksum algorithm is as follows:</source>
          <target state="translated">Алгоритм контрольной суммы работает только для контента,кратного 8 байтам в длину.Другими словами,если входы x(0)-x(N),то N должно быть нечетным.Алгоритм контрольной суммы следующий:</target>
        </trans-unit>
        <trans-unit id="9654e9833d2bad18eac61dc57f147c1ed15a761f" translate="yes" xml:space="preserve">
          <source>The checksum is an unsigned 32-bit integer computed as follows:</source>
          <target state="translated">Контрольная сумма представляет собой беззнаковое 32-битное целое число,вычисленное следующим образом:</target>
        </trans-unit>
        <trans-unit id="270f933e45ef3250cf9dcd69e18f5fd196bd90a0" translate="yes" xml:space="preserve">
          <source>The checksum is computed by interpreting the input as an even number of unsigned 32-bit integers: x(0) through x(N). The 32-bit integers are big-endian if the magic number in the first 4 bytes of the WAL header is 0x377f0683 and the integers are little-endian if the magic number is 0x377f0682. The checksum values are always stored in the frame header in a big-endian format regardless of which byte order is used to compute the checksum.</source>
          <target state="translated">Контрольная сумма вычисляется путем интерпретации входа как четное число беззнаковых 32-битных целых:x(0)-x(N).32-битные целые числа являются big-endian,если магическое число в первых 4 байтах заголовка WAL равно 0x377f0683,и целые числа являются little-endian,если магическое число равно 0x377f0682.Значения контрольных сумм всегда хранятся в заголовке кадра в big-endian формате,независимо от того,какой порядок байт используется для вычисления контрольной суммы.</target>
        </trans-unit>
        <trans-unit id="cc24b6f9af8e44f6ff2e41a4a1721f4bd21f35c7" translate="yes" xml:space="preserve">
          <source>The checksum value is used to guard against incomplete writes of a journal page record following a power failure. A different random nonce is used each time a transaction is started in order to minimize the risk that unwritten sectors might by chance contain data from the same page that was a part of prior journals. By changing the nonce for each transaction, stale data on disk will still generate an incorrect checksum and be detected with high probability. The checksum only uses a sparse sample of 32-bit words from the data record for performance reasons - design studies during the planning phases of SQLite 3.0.0 showed a significant performance hit in checksumming the entire page.</source>
          <target state="translated">Значение контрольной суммы используется для защиты от неполной записи записи страницы журнала после отключения питания.Каждый раз при запуске транзакции используется другой случайный нон-кум,чтобы минимизировать риск того,что неписаные секторы могут случайно содержать данные с той же самой страницы,которая была частью предыдущих журналов.При изменении нонсе для каждой транзакции залежавшиеся на диске данные все равно будут генерировать некорректную контрольную сумму и с высокой вероятностью будут обнаружены.Контрольная сумма использует только разреженную выборку из 32-битных слов из записи данных из соображений производительности-проектные исследования на этапе планирования SQLite 3.0.0 показали значительное падение производительности при контрольной сумме всей страницы.</target>
        </trans-unit>
        <trans-unit id="3990c0ed7263ce684acb68c345cf784357432dbe" translate="yes" xml:space="preserve">
          <source>The checksum value written to the</source>
          <target state="translated">Значение контрольной суммы,записанной на</target>
        </trans-unit>
        <trans-unit id="77ac1ab95620d7ae472b49582dcc0e306b38c020" translate="yes" xml:space="preserve">
          <source>The checksum values in the final 8 bytes of the frame-header exactly match the checksum computed consecutively on the first 24 bytes of the WAL header and the first 8 bytes and the content of all frames up to and including the current frame.</source>
          <target state="translated">Значения контрольных сумм в последних 8 байтах заголовка кадра точно совпадают с контрольной суммой,вычисленной последовательно на первых 24 байтах заголовка WAL и первых 8 байтах,а также с содержанием всех кадров вплоть до текущего кадра включительно.</target>
        </trans-unit>
        <trans-unit id="6c5140842eec97f2402faa79d3b18bc3769b3084" translate="yes" xml:space="preserve">
          <source>The child table references the primary key of the parent without specifying the primary key columns and the number of primary key columns in the parent do not match the number of child key columns.</source>
          <target state="translated">Дочерняя таблица ссылается на первичный ключ родительского без указания столбцов первичного ключа,а количество столбцов первичного ключа в родительской не совпадает с количеством столбцов дочернего ключа.</target>
        </trans-unit>
        <trans-unit id="cb680522ff952474c4763f726c9755f62f14ba34" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the heap limits may changes in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da194c4576594e7457a28ceeefa6139ab020edb1" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the soft heap limit may changes in future releases of SQLite.</source>
          <target state="translated">Обстоятельства,при которых SQLite будет обеспечивать соблюдение лимита мягкой кучи,могут измениться в будущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="eed6f77a1a12342f6f0e71580e9b4032c3ba5e49" translate="yes" xml:space="preserve">
          <source>The claim of the previous paragraph is extensively checked in the SQLite regression test suite using a special test harness that simulates the effects on a database file of operating system crashes and power failures.</source>
          <target state="translated">Утверждение,содержащееся в предыдущем пункте,подробно проверяется в наборе регрессионных тестов SQLite с использованием специального тестового жгута,который моделирует воздействие на файл базы данных сбоев операционной системы и перебоев в электропитании.</target>
        </trans-unit>
        <trans-unit id="ce6585a17c4368c809080175136a8937ad00861b" translate="yes" xml:space="preserve">
          <source>The coalesce() function returns a copy of its first non-NULL argument, or NULL if all arguments are NULL. Coalesce() must have at least 2 arguments.</source>
          <target state="translated">Функция Coalesce()возвращает копию своего первого не NULL аргумента,или NULL,если все аргументы NULL.Функция Coalesce()должна иметь как минимум 2 аргумента.</target>
        </trans-unit>
        <trans-unit id="f7c2331fa2d3327c8c4beede4ed0b6e31a651048" translate="yes" xml:space="preserve">
          <source>The code above is for the general case. For the special case of an SQLite Archive that only stores uncompressed or uncompressible content (this might come up, for example, in an SQLite Archive that stores only JPEG, GIF, and/or PNG images) then the content can be inserted into and extracted from the database without using the sqlar_compress() and sqlar_uncompress() functions, and the sqlar.c extension is not required.</source>
          <target state="translated">Код выше для общего случая.Для специального случая SQLite Archive,в котором хранится только несжатое или несжимаемое содержимое (это может появиться,например,в SQLite Archive,в котором хранятся только изображения в формате JPEG,GIF и/или PNG),содержимое может быть вставлено и извлечено из базы данных без использования функций sqlar_compress()и sqlar_uncompress(),при этом расширение sqlar.c не является обязательным.</target>
        </trans-unit>
        <trans-unit id="4eb7b1d4fed609f9eafac0ed3cfa712e4a84c44c" translate="yes" xml:space="preserve">
          <source>The code appears stable so we are now calling it &quot;beta&quot;.</source>
          <target state="translated">Код выглядит стабильным,поэтому сейчас мы называем его &quot;бета&quot;.</target>
        </trans-unit>
        <trans-unit id="4dcec88beb123f0b5fcd5b586036ea0a356cf753" translate="yes" xml:space="preserve">
          <source>The code audits used to ensure that memory allocation size computations do not overflow in SQLite are repeated prior to every SQLite release.</source>
          <target state="translated">Аудиты кода,используемые для того,чтобы убедиться,что вычисления объема выделения памяти не переполняются в SQLite,повторяются перед каждым выпуском SQLite.</target>
        </trans-unit>
        <trans-unit id="b0a804ee343680af0bae1b47adaea7bd27c01026" translate="yes" xml:space="preserve">
          <source>The code for the swarmvtab virtual table is found in the ext/misc/unionvtab.c file of the main SQLite source tree. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">Код виртуальной таблицы swarmvtab находится в файле ext / misc / unionvtab.c основного дерева исходных текстов SQLite. Его можно скомпилировать в &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение&lt;/a&gt; SQLite с помощью такой команды:</target>
        </trans-unit>
        <trans-unit id="429be1d142052bd4928f94110562bdb201e97a74" translate="yes" xml:space="preserve">
          <source>The code for the zipfile module is found in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext/misc/zipfile.c&lt;/a&gt; file of the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;main SQLite source tree&lt;/a&gt;. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="translated">Код для модуля zipfile находится в файле &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext / misc / zipfile.c &lt;/a&gt;&lt;a href=&quot;https://sqlite.org/src&quot;&gt;основного дерева исходных &lt;/a&gt;текстов SQLite . Его можно скомпилировать в &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение&lt;/a&gt; SQLite с помощью такой команды:</target>
        </trans-unit>
        <trans-unit id="e9f5bceb13445c13d968dff10e26983b65675c68" translate="yes" xml:space="preserve">
          <source>The code generated in this last example is the same as the previous except for the addition of two conditional jumps used to implement the extra WHERE and HAVING clauses. The WHERE clause is implemented by instructions 9 through 11 in the query loop. The HAVING clause is implemented by instruction 28 through 30 in the output loop.</source>
          <target state="translated">Код,сгенерированный в этом последнем примере,тот же самый,что и в предыдущем,за исключением добавления двух условных переходов,используемых для реализации дополнительных пунктов WHERE и HAVING.В цикле запросов выражение WHERE реализовано командами с 9 по 11.В выходном цикле выражение HAVING реализуется командами с 28 по 30.</target>
        </trans-unit>
        <trans-unit id="ecc7e2ea5797377ee55e53ff370e71d0a0432eb1" translate="yes" xml:space="preserve">
          <source>The code generated to implement this last query is as follows:</source>
          <target state="translated">Ниже приведен код,сгенерированный для реализации этого последнего запроса:</target>
        </trans-unit>
        <trans-unit id="26011ad1079cb8255e24204fff9114945ad7804b" translate="yes" xml:space="preserve">
          <source>The code generator in SQLite processes compound SELECT statements using a recursive algorithm. In order to limit the size of the stack, we therefore limit the number of terms in a compound SELECT. The maximum number of terms is SQLITE_MAX_COMPOUND_SELECT which defaults to 500. We think this is a generous allotment since in practice we almost never see the number of terms in a compound select exceed single digits.</source>
          <target state="translated">Генератор кода в SQLite обрабатывает сложные операторы SELECT,используя рекурсивный алгоритм.Для того,чтобы ограничить размер стека,мы ограничиваем количество терминов в составном SELECT.Максимальное количество терминов-SQLITE_MAX_COMPOUND_SELECT,которое по умолчанию равно 500.Мы считаем это щедрым распределением,так как на практике мы почти никогда не видим,чтобы количество членов в составном отборе превышало одиночные цифры.</target>
        </trans-unit>
        <trans-unit id="0a5ca134725357f1db49cf5e9aed85ae431b52f8" translate="yes" xml:space="preserve">
          <source>The code generator, and especially the logic in &lt;b&gt;where*.c&lt;/b&gt; and in &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, is sometimes called the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;. For any particular SQL statement, there might be hundreds, thousands, or millions of different algorithms to compute the answer. The query planner is an AI that strives to select the best algorithm from these millions of choices.</source>
          <target state="translated">Генератор кода, и особенно логику в &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;файлах &lt;/a&gt;&lt;b&gt;where * .c&lt;/b&gt; и select.c , иногда называют &lt;a href=&quot;optoverview&quot;&gt;планировщиком запросов&lt;/a&gt; . Для любого конкретного оператора SQL могут быть сотни, тысячи или миллионы различных алгоритмов вычисления ответа. Планировщик запросов - это ИИ, который стремится выбрать лучший алгоритм из этого миллиона вариантов.</target>
        </trans-unit>
        <trans-unit id="25e3614fe3c2a2058c86f93c8b850392e16eae8c" translate="yes" xml:space="preserve">
          <source>The code in &quot;fts5.c&quot; may then be compiled into a loadable extension or statically linked into an application as described in &lt;a href=&quot;loadext#build&quot;&gt;Compiling Loadable Extensions&lt;/a&gt;. There are two entry points defined, both of which do the same thing:</source>
          <target state="translated">Код в &quot;fts5.c&quot; затем может быть скомпилирован в загружаемое расширение или статически связан с приложением, как описано в &lt;a href=&quot;loadext#build&quot;&gt;разделе &quot;Компиляция загружаемых расширений&quot;&lt;/a&gt; . Определены две точки входа, каждая из которых выполняет одно и то же:</target>
        </trans-unit>
        <trans-unit id="c15d2613b82ac42eff7d51f6a4257bfde77f5feb" translate="yes" xml:space="preserve">
          <source>The code in this article could be improved in at least two ways:</source>
          <target state="translated">Код в этой статье можно было бы улучшить как минимум двумя способами:</target>
        </trans-unit>
        <trans-unit id="81d14a407fed1c180dec58abfdf7e1bfd2ff10aa" translate="yes" xml:space="preserve">
          <source>The code space used by the SQLite library depends on the target platform, the compiler, and optimization settings. These variables also affect performance.</source>
          <target state="translated">Пространство кода,используемое библиотекой SQLite,зависит от целевой платформы,компилятора и настроек оптимизации.Эти переменные также влияют на производительность.</target>
        </trans-unit>
        <trans-unit id="5c4a1121bef63849753648d7ec67f82ac551ebbe" translate="yes" xml:space="preserve">
          <source>The colUsed field indicates which columns of the virtual table may be required by the current scan. Virtual table columns are numbered from zero in the order in which they appear within the CREATE TABLE statement passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62), the corresponding bit is set within the colUsed mask if the column may be required by SQLite. If the table has at least 64 columns and any column to the right of the first 63 is required, then bit 63 of colUsed is also set. In other words, column iCol may be required if the expression (colUsed &amp;amp; ((sqlite3_uint64)1 &amp;lt;&amp;lt; (iCol&amp;gt;=63 ? 63 : iCol))) evaluates to non-zero.</source>
          <target state="translated">Поле colUsed указывает, какие столбцы виртуальной таблицы могут потребоваться для текущего сканирования. Столбцы виртуальной таблицы нумеруются с нуля в том порядке, в котором они появляются в операторе CREATE TABLE, переданном в sqlite3_declare_vtab (). Для первых 63 столбцов (столбцы 0-62) соответствующий бит устанавливается в маске colUsed, если столбец может потребоваться SQLite. Если таблица имеет не менее 64 столбцов и требуется любой столбец справа от первых 63, то также устанавливается бит 63 столбца colUsed. Другими словами, столбец iCol может потребоваться, если выражение (colUsed &amp;amp; ((sqlite3_uint64) 1 &amp;lt;&amp;lt; (iCol&amp;gt; = 63? 63: iCol))) оценивается как ненулевое.</target>
        </trans-unit>
        <trans-unit id="cd6add92b1a269fd1ee22788d7c2c68cbcfa3387" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="translated">Обратный вызов коллекционной функции вызывается с копией указателя на данные приложения pArg и двумя строками в кодировке,заданной аргументом eTextRep.Функция collating должна возвращать целое число,которое является отрицательным,нулевым или положительным,если первая строка меньше,равна или больше второй соответственно.Коллатирующая функция должна всегда возвращать один и тот же ответ при одних и тех же входах.Если две или более функций объединения зарегистрированы под одним и тем же именем (с использованием разных значений eTextRep),то при вызове с эквивалентными строками все они должны дать эквивалентный ответ.Функция сопоставления должна подчиняться следующим свойствам для всех строк A,B и C:</target>
        </trans-unit>
        <trans-unit id="0a8a7f3b3c83ac2e3d1763414e674a2e2ca29ee7" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The two integer parameters to the collating function callback are the length of the two strings, in bytes. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d2bfaa5988de22a32b291f24dfa00da4fc2f70" translate="yes" xml:space="preserve">
          <source>The column is identified by the second, third and fourth parameters to this function. The second parameter is either the name of the database (i.e. &quot;main&quot;, &quot;temp&quot;, or an attached database) containing the specified table or NULL. If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.</source>
          <target state="translated">Колонка идентифицируется по второму,третьему и четвертому параметрам этой функции.Вторым параметром является либо название БД (т.е.&quot;основная&quot;,&quot;временная&quot; или прикрепленная БД),содержащая указанную таблицу,либо NULL.Если это NULL,то все подключенные БД ищут таблицу по тому же алгоритму,который используется движком БД для разрешения неквалифицированных ссылок на таблицы.</target>
        </trans-unit>
        <trans-unit id="7829593889659cca230ab3239645af748546a7d0" translate="yes" xml:space="preserve">
          <source>The column labels that appear on the first two lines of output can be turned on and off using the &quot;.header&quot; dot command. In the examples above, the column labels are on. To turn them off you could do this:</source>
          <target state="translated">Метки столбцов,которые появляются в первых двух строках вывода,могут быть включены и выключены командой &quot;.header&quot; dot.В приведенных выше примерах метки столбцов включены.Для их выключения можно сделать это:</target>
        </trans-unit>
        <trans-unit id="9b37c354a4343966405cb0363479fdc771c7551d" translate="yes" xml:space="preserve">
          <source>The column may not be &lt;a href=&quot;gencol&quot;&gt;GENERATED ALWAYS ... STORED&lt;/a&gt;, though VIRTUAL columns are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d2d7e1bd431710201b6152bbbf86fa85eac1e5" translate="yes" xml:space="preserve">
          <source>The column may not have a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="translated">Столбец может не иметь ограничения PRIMARY KEY или UNIQUE.</target>
        </trans-unit>
        <trans-unit id="99d848b798067eee9317efc709f08dee3a25b0a8" translate="yes" xml:space="preserve">
          <source>The column may not have a default value of CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP, or an expression in parentheses.</source>
          <target state="translated">Столбец может не иметь значения по умолчанию CURRENT_TIME,CURRENT_DATE,CURRENT_TIMESTAMP или выражения в круглых скобках.</target>
        </trans-unit>
        <trans-unit id="adb879e73b7d88dc161320c793668864d27ae4e6" translate="yes" xml:space="preserve">
          <source>The column names and definitions for</source>
          <target state="translated">Названия колонок и определения для</target>
        </trans-unit>
        <trans-unit id="b16cccd51ed940f2dd9c18cb3d4d9b130c9ecd9e" translate="yes" xml:space="preserve">
          <source>The column names for the result sets of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements have been tweaked in some cases to work more like other SQL database engines.</source>
          <target state="translated">Имена столбцов для наборов результатов &lt;a href=&quot;lang_select&quot;&gt;операторов SELECT&lt;/a&gt; в некоторых случаях были изменены, чтобы они работали как другие механизмы баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="239fe7786e783e697b78c9df7c06b9daecb4d9f7" translate="yes" xml:space="preserve">
          <source>The column names of the virtual table are determined primarily by the &lt;b&gt;schema=&lt;/b&gt; argument. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted, but &lt;b&gt;header&lt;/b&gt; is true, then the values found in the first line of the CSV file become the column names. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted and &lt;b&gt;header&lt;/b&gt; is false, then the columns are named &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, and so forth.</source>
          <target state="translated">Имена столбцов виртуальной таблицы определяются главным образом аргументом &lt;b&gt;schema =&lt;/b&gt; . Если аргумент &lt;b&gt;schema =&lt;/b&gt; опущен, но &lt;b&gt;заголовок&lt;/b&gt; верен, тогда значения, найденные в первой строке файла CSV, становятся именами столбцов. Если аргумент &lt;b&gt;schema =&lt;/b&gt; опущен и &lt;b&gt;заголовок&lt;/b&gt; имеет значение false, тогда столбцам будут присвоены имена &amp;laquo;c0&amp;raquo;, &amp;laquo;c1&amp;raquo;, &amp;laquo;c2&amp;raquo; и т. Д.</target>
        </trans-unit>
        <trans-unit id="27cc219896194f2cbf6cb1853331dc30b6f1a32f" translate="yes" xml:space="preserve">
          <source>The column names reported by join subqueries have been modified slightly in order to work more like other database engines. Consider the following query:</source>
          <target state="translated">Имена столбцов,сообщаемые в подзапросах на присоединение,были слегка изменены,чтобы работать как другие движки базы данных.Рассмотрим следующий запрос:</target>
        </trans-unit>
        <trans-unit id="cf988c97f1d408bf1402feb7e21744609abdb492" translate="yes" xml:space="preserve">
          <source>The column number (1 for the second leftmost column, etc.). This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">Номер столбца (1 для второго левого столбца и т.д.).Данное поле опускается для любого списка смещений сроков,связанных со столбцом 0.</target>
        </trans-unit>
        <trans-unit id="0d64ee03e40c54227cba3f5e9c70df99b5d87845" translate="yes" xml:space="preserve">
          <source>The column number that the term instance occurs in (0 for the leftmost column of the FTS table, 1 for the next leftmost, etc.).</source>
          <target state="translated">Номер столбца,в котором встречается экземпляр термина (0 для самого левого столбца таблицы FTS,1 для следующего самого левого и т.д.).</target>
        </trans-unit>
        <trans-unit id="0e0d4c37f8f415ca48f1578c5fbfec2c6eeee2e7" translate="yes" xml:space="preserve">
          <source>The column-name list syntax was added in SQLite versions 3.9.0 (2015-10-14).</source>
          <target state="translated">Синтаксис списка имен столбцов был добавлен в версии SQLite 3.9.0 (2015-10-14).</target>
        </trans-unit>
        <trans-unit id="74b05d9163657d39d9cb9b3d5f80884cae70cb2c" translate="yes" xml:space="preserve">
          <source>The columns are provided by the SQLITE_STMT virtual table are summarized by the hypothetical CREATE TABLE statement show here:</source>
          <target state="translated">Столбцы,предоставляемые виртуальной таблицей SQLITE_STMT,суммируются гипотетическим оператором CREATE TABLE,показанным здесь:</target>
        </trans-unit>
        <trans-unit id="99fc02c8d425b8c14b21527882dd349490360fd6" translate="yes" xml:space="preserve">
          <source>The columns referenced in the WHERE clause of a partial index can be any of the columns in the table, not just columns that happen to be indexed. However, it is very common for the WHERE clause expression of a partial index to be a simple expression on the column being indexed. The following is a typical example:</source>
          <target state="translated">Столбцы,на которые делается ссылка в пункте &quot;ГДЕ&quot; частичного индекса,могут быть любыми из столбцов таблицы,а не только столбцами,которые случайно индексируются.Однако очень часто выражение в пункте &quot;ГДЕ&quot; частичного индекса является простым выражением в индексируемом столбце.Ниже приведен типичный пример:</target>
        </trans-unit>
        <trans-unit id="c36ceb732928b62fa9f17cf0516fa8ff6f38d20c" translate="yes" xml:space="preserve">
          <source>The command above created the new branch. But your checkout is still on the trunk - a fact you can see by running the command:</source>
          <target state="translated">Команда,приведенная выше,создала новую ветку.Но ваша проверка всё ещё находится в стволе-факт,который вы можете увидеть,выполнив эту команду:</target>
        </trans-unit>
        <trans-unit id="39e91ef2d072dfac6ebe4c80889ed64220c2f4b1" translate="yes" xml:space="preserve">
          <source>The command above will make a copy of the complete development history of SQLite into the &quot;sqlite.fossil&quot; file on your computer. Making this copy takes about a minute and uses about 32 megabytes of transfer. After making the copy, &quot;open&quot; the repository by typing:</source>
          <target state="translated">Вышеуказанная команда сделает копию полной истории разработки SQLite в файл &quot;sqlite.fossil&quot; на вашем компьютере.Создание этой копии занимает около минуты и использует около 32 мегабайт передачи.После создания копии &quot;откройте&quot; хранилище,набрав соответствующую строку:</target>
        </trans-unit>
        <trans-unit id="4b3dc1d8af5139eaa56167ba29f9c2c18e9d510c" translate="yes" xml:space="preserve">
          <source>The command above writes the output of the query as CSV into a temporary file, invokes the default handler for CSV files (usually the preferred spreadsheet program such as Excel or LibreOffice), then deletes the temporary file. This is essentially a short-hand method of doing the sequence of &quot;.csv&quot;, &quot;.once&quot;, and &quot;.system&quot; commands described above.</source>
          <target state="translated">Команда выше записывает вывод запроса в виде CSV во временный файл,вызывает обработчик по умолчанию для CSV-файлов (обычно это предпочтительная программа для работы с таблицами,например,Excel или LibreOffice),затем удаляет временный файл.По сути,это краткосрочный метод выполнения последовательности команд &quot;.csv&quot;,&quot;.once&quot; и &quot;.system&quot;,описанный выше.</target>
        </trans-unit>
        <trans-unit id="b075c13635ba5e790ee4582ea35e32db5040da00" translate="yes" xml:space="preserve">
          <source>The command returns a new TCL channel for reading or writing to the BLOB. The channel is opened using the underlying &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; C-language interface. Close the channel using the &lt;b&gt;close&lt;/b&gt; command of TCL.</source>
          <target state="translated">Команда возвращает новый канал TCL для чтения или записи в BLOB. Канал открывается с помощью базового интерфейса &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open () на языке&lt;/a&gt; C. Закройте канал, используя команду &lt;b&gt;закрытия&lt;/b&gt; TCL.</target>
        </trans-unit>
        <trans-unit id="988274d0addcbb9018970d10733f7b4052f070a2" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a64c0d6110f60679f08571c4a254a77214045a1" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="translated">Оболочка командной строки добавляет две &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемые приложением функции SQL,&lt;/a&gt; которые облегчают чтение содержимого из файла в столбец таблицы и запись содержимого столбца в файл соответственно.</target>
        </trans-unit>
        <trans-unit id="5a15969d303479025517006f69c3c3e87572075f" translate="yes" xml:space="preserve">
          <source>The command-line shell uses the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; to access ZIP archives. You can see this by running the &quot;.schema&quot; command when a ZIP archive is open:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d792fd30ad98774099bd3871331d49c13f01ab7" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратные вызовы обработчиков фиксации и отката не реентерабельны. Реализация обратного вызова не должна делать ничего, что могло бы изменить соединение с базой данных, вызвавшее обратный вызов. Любые действия по изменению подключения к базе данных должны быть отложены до завершения вызова &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (),&lt;/a&gt; который в первую очередь инициировал фиксацию или откат. Обратите внимание, что выполнение любых других операторов SQL, включая операторы SELECT, или простой вызов &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; изменит соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="837a3144fbcca3d5f0e20f9cd17c26bc03114566" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">Обратные вызовы обработчиков фиксации и отката не реентерабельны. Реализация обратного вызова не должна делать ничего, что могло бы изменить соединение с базой данных, вызвавшее обратный вызов. Любые действия по изменению подключения к базе данных должны быть отложены до завершения вызова &lt;a href=&quot;step&quot;&gt;sqlite3_step (),&lt;/a&gt; который в первую очередь инициировал фиксацию или откат. Обратите внимание, что выполнение любых других операторов SQL, включая операторы SELECT, или простой вызов &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; и &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; изменит соединения с базой данных для значения слова &amp;laquo;изменить&amp;raquo; в этом абзаце.</target>
        </trans-unit>
        <trans-unit id="5854e2359472df03b69e7808b8ee34022d4a6816" translate="yes" xml:space="preserve">
          <source>The commit process shown in &lt;a href=&quot;#section_3_0&quot;&gt;section 3.0&lt;/a&gt; assumes that all database changes fit in memory until it is time to commit. This is the common case. But sometimes a larger change will overflow the user-space cache prior to transaction commit. In those cases, the cache must spill to the database before the transaction is complete.</source>
          <target state="translated">Процесс фиксации, показанный в &lt;a href=&quot;#section_3_0&quot;&gt;разделе 3.0,&lt;/a&gt; предполагает, что все изменения базы данных умещаются в памяти, пока не наступит время фиксации. Это обычный случай. Но иногда более крупное изменение приводит к переполнению кеша пользовательского пространства до фиксации транзакции. В таких случаях кэш должен попасть в базу данных до завершения транзакции.</target>
        </trans-unit>
        <trans-unit id="831de8c9305e21ddee6326436c38620139c51d57" translate="yes" xml:space="preserve">
          <source>The common table expression works without having to load an extension. On the other hand, the extension is easier to program and faster.</source>
          <target state="translated">Общее табличное выражение работает без необходимости загрузки расширения.С другой стороны,расширение проще и быстрее программируется.</target>
        </trans-unit>
        <trans-unit id="975322957294bcdde1991bc8533b4c3c42c34fe5" translate="yes" xml:space="preserve">
          <source>The comparison is a sort comparison, so NULLs compare equal, NULLs are less than numbers, numbers are less than strings, and strings are less than blobs.</source>
          <target state="translated">Сравнение представляет собой сортировочное сравнение,поэтому NULLs сравнивают равными,NULLs меньше чем числа,числа меньше чем строки,и строки меньше чем капли.</target>
        </trans-unit>
        <trans-unit id="77fdffaa220770108e157d8f6fdf86e8984310f3" translate="yes" xml:space="preserve">
          <source>The compilation step shown immediately above is merely representative. In a working installation, one would normally want to specify optimization parameters and compile-time switches on the compiler command line.</source>
          <target state="translated">Представленный выше этап компиляции является лишь репрезентативным.В рабочей установке обычно требуется указать параметры оптимизации и ключи времени компиляции в командной строке компилятора.</target>
        </trans-unit>
        <trans-unit id="06859965a5874b48e17ef99de2638103b952d1aa" translate="yes" xml:space="preserve">
          <source>The compile-time options for setting upper bounds are &lt;a href=&quot;limits&quot;&gt;documented separately&lt;/a&gt;. The following is a list of the available settings:</source>
          <target state="translated">Параметры времени компиляции для установки верхних границ &lt;a href=&quot;limits&quot;&gt;документируются отдельно&lt;/a&gt; . Ниже приводится список доступных настроек:</target>
        </trans-unit>
        <trans-unit id="d37610227543b6269c9a6c07ddb9c1381df5a58a" translate="yes" xml:space="preserve">
          <source>The complete state of an SQLite database is usually contained in a single file on disk called the &quot;main database file&quot;.</source>
          <target state="translated">Полное состояние базы данных SQLite обычно содержится в одном файле на диске,называемом &quot;основным файлом базы данных&quot;.</target>
        </trans-unit>
        <trans-unit id="96bf44cd55dc348e4e3f4d568f7843d225f7562d" translate="yes" xml:space="preserve">
          <source>The completion table is designed for interactive use. It will return answers at a speed appropriate for human typing. No effort is made to be unusually efficient, so long as the response time is nearly instantaneous in a user interface.</source>
          <target state="translated">Завершающая таблица предназначена для интерактивного использования.Она будет возвращать ответы со скоростью,подходящей для набора текста человеком.При этом не прилагается никаких усилий для того,чтобы быть необычайно эффективным,при условии,что время ответа практически мгновенно отображается в пользовательском интерфейсе.</target>
        </trans-unit>
        <trans-unit id="d59eec775be7e50d6274c344c801f729c91ab804" translate="yes" xml:space="preserve">
          <source>The completion table is used to implement tab-completion in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; in conjunction with either the readline or linenoise input line editing packages for unix. See the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; source file for example code. Search for &quot;FROM completion&quot; to find the relevant code sections.</source>
          <target state="translated">Таблица завершения используется для реализации автозавершения табуляции в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; в сочетании с пакетами редактирования строки ввода readline или Linenoise для unix. Смотрите &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; исходный файл для примера кода. Выполните поиск по запросу &amp;laquo;ОТ завершения&amp;raquo;, чтобы найти соответствующие разделы кода.</target>
        </trans-unit>
        <trans-unit id="e034c5722458a4ef5f557863bb00dfc415febe07" translate="yes" xml:space="preserve">
          <source>The completion table might return the same candidate more than once, and it will return candidates in an arbitrary order. The DISTINCT keyword and the ORDER BY in the sample query above are added to make the answers unique and in lexicographical order.</source>
          <target state="translated">Таблица завершения работы может возвращать одного и того же кандидата не один раз,и в ней кандидаты будут возвращаться в произвольном порядке.Ключевое слово &quot;DISTINCT&quot; и &quot;ORDER BY&quot; в приведенном выше примере запроса добавляются для того,чтобы сделать ответы уникальными и в лексикографическом порядке.</target>
        </trans-unit>
        <trans-unit id="7bf1657f4892b438bb6c981746dfe40cd870c0fa" translate="yes" xml:space="preserve">
          <source>The complexity of Git distracts attention from the software under development. A user of Git needs to keep all of the following in mind:</source>
          <target state="translated">Сложность Git'а отвлекает внимание от разрабатываемого программного обеспечения.Пользователь Git'а должен помнить обо всём следующем:</target>
        </trans-unit>
        <trans-unit id="15376f7aadf15df031fa31738229dcbaf3f18c9d" translate="yes" xml:space="preserve">
          <source>The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit comparisons between values. No affinity is applied to comparison operands for the implicit comparisons associated with UNION, INTERSECT, or EXCEPT - the values are compared as is.</source>
          <target state="translated">Комбинированные операторы SELECT UNION,INTERSECT и EXCEPT выполняют неявное сравнение значений.К операндам сравнения для неявных сравнений,связанных с UNION,INTERSECT или EXCEPT,не применяется никакого сродства-значения сравниваются как есть.</target>
        </trans-unit>
        <trans-unit id="dc11a925c84e89a2d79f62896a81bbc87b31205f" translate="yes" xml:space="preserve">
          <source>The compress and uncompress options allow FTS4 content to be stored in the database in a compressed form. Both options should be set to the name of an SQL scalar function registered using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; that accepts a single argument.</source>
          <target state="translated">Параметры сжатия и распаковки позволяют сохранять содержимое FTS4 в базе данных в сжатом виде. Обе опции должны быть установлены на имя скалярной функции SQL, зарегистрированной с помощью &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function (),&lt;/a&gt; которая принимает единственный аргумент.</target>
        </trans-unit>
        <trans-unit id="8f77d8f289ab8ab189cc2f583f00d06f6f32d94d" translate="yes" xml:space="preserve">
          <source>The compress function should return a compressed version of the value passed to it as an argument. Each time data is written to the FTS4 table, each column value is passed to the compress function and the result value stored in the database. The compress function may return any type of SQLite value (blob, text, real, integer or null).</source>
          <target state="translated">Функция компрессии должна возвращать сжатую версию значения,переданного ей в качестве аргумента.Каждый раз,когда данные записываются в таблицу FTS4,значение каждого столбца передается в функцию компрессии,а значение результата сохраняется в базе данных.Функция компрессии может возвращать любое значение SQLite (блочное,текстовое,вещественное,целое или нулевое).</target>
        </trans-unit>
        <trans-unit id="290b0a4fd26e950183bc56ef03571b78a9f077cd" translate="yes" xml:space="preserve">
          <source>The compress option is used to specify the compress function. It is an error to specify a compress function without also specifying an uncompress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">Параметр сжатия используется для указания функции сжатия. Ошибочно указывать функцию сжатия без указания функции распаковки. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;Подробнее см. Ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5836c13f879c56ed967a4394bb1d7a4816e02cd2" translate="yes" xml:space="preserve">
          <source>The compress=, uncompress= and languageid= options are not available. There is as of yet no equivalent for their functionality.</source>
          <target state="translated">Опции compress=,uncompress=и languageid=недоступны.Пока нет эквивалента их функциональности.</target>
        </trans-unit>
        <trans-unit id="2469db0ecb30ed655de4891189661dea5b883567" translate="yes" xml:space="preserve">
          <source>The compression method used to compress the data (an integer). The value 0 indicates that the data is stored in the zip archive without compression. 8 means the raw deflate algorithm.</source>
          <target state="translated">Метод сжатия,используемый для сжатия данных (целое число).Значение 0 означает,что данные хранятся в zip-архиве без сжатия.8 означает необработанный алгоритм сдувания.</target>
        </trans-unit>
        <trans-unit id="c682ba9f6178606617e01c8b48358fa9163f9c2c" translate="yes" xml:space="preserve">
          <source>The computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime_r() is used to assist in the calculation of local time. The localtime_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.</source>
          <target state="translated">Расчет местного времени в значительной степени зависит от прихоти политиков и поэтому его трудно скорректировать для всех местностей.В этой реализации для помощи в вычислении локального времени используется стандартная функция библиотеки языка Си localtime_r().Функция localtime_r()C обычно работает только в течение лет между 1970 и 2037 годами.Для дат вне этого диапазона SQLite пытается отобразить год в эквивалентный год в этом диапазоне,выполняет вычисление,а затем отображает год назад.</target>
        </trans-unit>
        <trans-unit id="a84ddecfbfcfd1c573cf704dea12a071acade093" translate="yes" xml:space="preserve">
          <source>The concept of fuzz testing has been around for decades, but fuzz testing was not an effective way to find bugs until 2014 when Michal Zalewski invented the first practical profile-guided fuzzer, &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot;. Unlike prior fuzzers that blindly generate random inputs, AFL instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c788bf48ee2358b78bb00bc56b593bb09c394d8" translate="yes" xml:space="preserve">
          <source>The configure script (on unix) automatically detects pread() and pwrite() and sets compile-time options to use those OS interfaces if they are available.</source>
          <target state="translated">Сценарий конфигурации (на unix)автоматически определяет pread()и pwrite()и устанавливает опции времени компиляции для использования этих интерфейсов ОС,если они доступны.</target>
        </trans-unit>
        <trans-unit id="b71509666058777b45e3ddaa4c2923ebc4c7fa2f" translate="yes" xml:space="preserve">
          <source>The configure-make works whether your are building from the canonical sources from the source tree, or from an amalgamated bundle. There are few dependencies. When building from canonical sources, a working &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; is required. If using an amalgamation bundle, all the preprocessing work normally done by tclsh will have already been carried out and only normal build tools are required.</source>
          <target state="translated">Configure-make работает независимо от того, собираете ли вы из канонических источников из дерева исходных текстов или из объединенного пакета. Есть несколько зависимостей. При сборке из канонических источников требуется рабочий &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; . При использовании пакета объединения вся работа по предварительной обработке, обычно выполняемая tclsh, уже будет выполнена, и требуются только обычные инструменты сборки.</target>
        </trans-unit>
        <trans-unit id="8ac9040eb64152e9af693ac6b3d6353d633a032f" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_DATA as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is present in the database, but one or more other (non primary-key) fields modified by the update do not contain the expected &quot;before&quot; values.</source>
          <target state="translated">Обработчик конфликтов вызывается со вторым аргументом CHANGESET_DATA при обработке изменения DELETE или UPDATE,если строка с требуемыми полями PRIMARY KEY присутствует в БД,но одно или несколько других (не праймерик)полей,модифицированных обновлением,не содержат ожидаемых значений &quot;до&quot;.</target>
        </trans-unit>
        <trans-unit id="23fc4d91796bed566e82459162cebcab0cf84b45" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_NOTFOUND as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is not present in the database.</source>
          <target state="translated">Обработчик конфликтов вызывается со вторым аргументом CHANGESET_NOTFOUND при обработке изменения DELETE или UPDATE,если строка с требуемыми полями PRIMARY KEY отсутствует в БД.</target>
        </trans-unit>
        <trans-unit id="c661dc346561d136d5859295a5527b2af74324a7" translate="yes" xml:space="preserve">
          <source>The conflicting row in this case is the database row with the matching primary key.</source>
          <target state="translated">Конфликтной строкой в данном случае является строка БД с соответствующим первичным ключом.</target>
        </trans-unit>
        <trans-unit id="4298401952abf69332c686d0b1f446ca8e2e6344" translate="yes" xml:space="preserve">
          <source>The conflicting row, in this case, is the database row with the matching primary key.</source>
          <target state="translated">Конфликтная строка в данном случае-это строка базы данных с соответствующим первичным ключом.</target>
        </trans-unit>
        <trans-unit id="ca62ceaf8e4848fb4512d05da76c6a9337ad0aa5" translate="yes" xml:space="preserve">
          <source>The connection checks if a</source>
          <target state="translated">Соединение проверяет</target>
        </trans-unit>
        <trans-unit id="72c42ad2c395427b5b34bc215df721de823e8688" translate="yes" xml:space="preserve">
          <source>The connection checks if the data in the</source>
          <target state="translated">Соединение проверяет данные в</target>
        </trans-unit>
        <trans-unit id="aed384d7e555153a17ceb13abbd6bca15763f13c" translate="yes" xml:space="preserve">
          <source>The content allows the text being indexed to be stored in a separate table distinct from the FTS4 table, or even outside of SQLite.</source>
          <target state="translated">Содержание позволяет хранить индексируемый текст в отдельной таблице,отличной от таблицы FTS4,или даже вне SQLite.</target>
        </trans-unit>
        <trans-unit id="d6e0eda1c9ea11f507c054ff491306a6eca1ff67" translate="yes" xml:space="preserve">
          <source>The content in the sqlite_stat4 table cannot be computed with anything less than a full scan. Hence, if a non-zero analysis limit is specified, the sqlite_stat4 table is not computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbe292e23fdc57896771b367c267746f39de5b7" translate="yes" xml:space="preserve">
          <source>The content of P3 registers starting at register P2 form an unpacked index key. This opcode removes that entry from the index opened by cursor P1.</source>
          <target state="translated">Содержимое регистров P3,начиная с регистра P2,образует распакованный индексный ключ.Этот опкод удаляет эту запись из индекса,открытого курсором P1.</target>
        </trans-unit>
        <trans-unit id="53039aadd3f75ae33d382081b8b5f0e6fd60f4d6" translate="yes" xml:space="preserve">
          <source>The content of an R*Tree index is actually stored in three ordinary SQLite tables with names derived from the name of the R*Tree. These three tables are called &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;. This is their schema:</source>
          <target state="translated">Содержимое индекса R * Tree фактически хранится в трех обычных таблицах SQLite с именами, производными от имени R * Tree. Эти три таблицы называются &amp;laquo; &lt;a href=&quot;vtab#xshadowname&quot;&gt;теневыми таблицами&lt;/a&gt; &amp;raquo;. Это их схема:</target>
        </trans-unit>
        <trans-unit id="dd5b1eb070f31c8697b621bf1847b35fb7a8adaf" translate="yes" xml:space="preserve">
          <source>The content of each SQL table row is stored in the database file by first combining the values in the various columns into a byte array in the record format, then storing that byte array as the payload in an entry in the table b-tree. The order of values in the record is the same as the order of columns in the SQL table definition. When an SQL table includes an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column (which aliases the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) then that column appears in the record as a NULL value. SQLite will always use the table b-tree key rather than the NULL value when referencing the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.</source>
          <target state="translated">Содержимое каждой строки таблицы SQL сохраняется в файле базы данных путем сначала объединения значений в различных столбцах в массив байтов в формате записи, а затем сохранения этого массива байтов в качестве полезной нагрузки в записи в b-дереве таблицы. Порядок значений в записи такой же, как порядок столбцов в определении таблицы SQL. Когда таблица SQL включает столбец &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; (который является псевдонимом &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; ), этот столбец отображается в записи как значение NULL. При обращении к столбцу &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; SQLite всегда будет использовать ключ b-дерева таблицы, а не значение NULL .</target>
        </trans-unit>
        <trans-unit id="71920b63c9e6445164e490bc0f251a06d6bb693f" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the master journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="translated">Содержимое каждого журнала отката прошивается на диск как до,так и после того,как в заголовок журнала отката записывается имя файла главного журнала.Важно сделать обе эти промывки.К счастью,вторая прошивка обычно недорогая,так как обычно меняется только одна страница файла журнала (первая страница).</target>
        </trans-unit>
        <trans-unit id="2c74d571015e1e1c51708cccb3ac9a7ab08632cc" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the super-journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b372f8730aa69db1fd10c964b137259496c534" translate="yes" xml:space="preserve">
          <source>The content of each slide could still be stored as compressed XML. But now each page is stored separately. So when opening a new document, the application could simply run:</source>
          <target state="translated">Содержимое каждого слайда может быть сохранено в виде сжатого XML.Но теперь каждая страница хранится отдельно.Так что при открытии нового документа приложение могло просто запускаться:</target>
        </trans-unit>
        <trans-unit id="ef2de54ba7f62420a379fc46c4ab7cf3080ae413" translate="yes" xml:space="preserve">
          <source>The content of the statistics tables can be queried using &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; and can be changed using the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands. The &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command works on statistics tables as of SQLite version 3.7.9. (2011-11-01) The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command does not work on statistics tables. Appropriate care should be used when changing the content of the statistics tables as invalid content can cause SQLite to select inefficient query plans. Generally speaking, one should not modify the content of the statistics tables by any mechanism other than invoking the ANALYZE command. See &quot;&lt;a href=&quot;optoverview#manctrl&quot;&gt;Manual Control Of Query Plans Using SQLITE_STAT Tables&lt;/a&gt;&quot; for further information.</source>
          <target state="translated">Содержимое таблиц статистики можно запросить с помощью &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; и изменить с помощью команд &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; и &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; . Команда &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; работает с таблицами статистики, начиная с версии SQLite 3.7.9. (2011-11-01) Команда &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; не работает с таблицами статистики. При изменении содержимого таблиц статистики следует проявлять соответствующую осторожность, поскольку недопустимое содержимое может привести к тому, что SQLite выберет неэффективные планы запросов. Вообще говоря, не следует изменять содержимое таблиц статистики с помощью какого-либо механизма, кроме вызова команды ANALYZE. См. &amp;laquo; &lt;a href=&quot;optoverview#manctrl&quot;&gt;Ручное управление планами запросов с использованием таблиц SQLITE_STAT&lt;/a&gt; &amp;raquo; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="cb0bc8e6cf7e707512464168a8333cd25f0f7228" translate="yes" xml:space="preserve">
          <source>The content option allows FTS4 to forego storing the text being indexed. The content option can be used in two ways:</source>
          <target state="translated">Опция контента позволяет FTS4 отказаться от хранения индексируемого текста.Опция контента может быть использована двумя способами:</target>
        </trans-unit>
        <trans-unit id="50fd4cd87f476ff7994844fe209f20e1e61a3e92" translate="yes" xml:space="preserve">
          <source>The content table may also be queried as follows:</source>
          <target state="translated">Содержание таблицы также может быть запрошено следующим образом:</target>
        </trans-unit>
        <trans-unit id="43da535bae3bfe186441cea4bad1d427988c63d1" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">Содержимое &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;набора&lt;/a&gt; изменений можно просмотреть с помощью итератора, созданного с помощью API sqlite3changeset_start () . Набор изменений можно применить к базе данных с совместимой схемой с помощью API &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1fc4719b451a2f189cbf09b3af719ceaa1455fd" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="translated">Содержимое &lt;a href=&quot;sqlite3changeset_start&quot;&gt;набора&lt;/a&gt; изменений можно просмотреть с помощью итератора, созданного с помощью API sqlite3changeset_start () . Набор изменений можно применить к базе данных с совместимой схемой с помощью API &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17197a14b8f9ff583e2fbe7ec6a33d12aff2f981" translate="yes" xml:space="preserve">
          <source>The contents of an SQLite database file are formatted as a set of fixed size pages. See</source>
          <target state="translated">Содержимое файла базы данных SQLite отформатировано в виде набора страниц фиксированного размера.См..</target>
        </trans-unit>
        <trans-unit id="6741b03ffce89c3a2ca3addb1cadccc791915ce5" translate="yes" xml:space="preserve">
          <source>The contents of columns qualified with the UNINDEXED column option are not added to the FTS index. This means that for the purposes of MATCH queries and &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt;, the column contains no matchable tokens.</source>
          <target state="translated">Содержимое столбцов, отмеченных параметром UNINDEXED column, не добавляется в индекс FTS. Это означает, что для целей запросов MATCH и &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;вспомогательных функций FTS5&lt;/a&gt; столбец не содержит подходящих токенов.</target>
        </trans-unit>
        <trans-unit id="f4381b2c97365bdc1448864c183789c2d75a4c76" translate="yes" xml:space="preserve">
          <source>The contents of the logical full-text index is found by merging the contents of all segment b-trees. If a term is present in more than one segment b-tree, then it maps to the union of each individual doclist. If, for a single term, the same docid occurs in more than one doclist, then only the doclist that is part of the most recently created segment b-tree is considered valid.</source>
          <target state="translated">Содержимое логического полнотекстового индекса находят путем слияния содержимого всех b-деревьев сегмента.Если термин присутствует более чем в одном сегменте b-дерева,то он сопоставляется с объединением каждого отдельного доклиста.Если в течение одного срока один и тот же доцит встречается более чем в одном докласте,то действительным считается только тот доцит,который входит в состав последнего созданного b-дерева сегмента.</target>
        </trans-unit>
        <trans-unit id="603ef17ea7e8b979fdc97587b739002125ee3a17" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">Содержимое структуры sqlite3_pcache_methods2 копируется во внутренний буфер SQLite при вызове &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; . Следовательно, приложение может отказаться от параметра после возврата из вызова &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d33c4566f4b0045dff066d31694e73d46d2bf6db" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="translated">Содержимое структуры sqlite3_pcache_methods2 копируется во внутренний буфер SQLite при вызове &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; . Следовательно, приложение может отказаться от параметра после возврата из вызова &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e184948fbfc41a2f2c0c14809d37c70c80c03a2" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">Контекст, в котором выполняется функция SQL, хранится в объекте sqlite3_context. Указатель на объект sqlite3_context всегда является первым параметром для &lt;a href=&quot;#sqlite3_create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; . Реализация определяемой приложением функции SQL передаст этот указатель в вызовы &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata ()&lt;/a&gt; и / или &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb189ce529b8d7d0045783021bb7d8fd77526437" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53fb8a37d043abdf36747b3ab57dd8a44c62d486" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c0cad9919ee775dcafe683809a8efa13aeacfd" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="translated">Контекст, в котором выполняется функция SQL, хранится в объекте sqlite3_context. Указатель на объект sqlite3_context всегда является первым параметром для &lt;a href=&quot;create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; . Реализация определяемой приложением функции SQL передаст этот указатель в вызовы &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result ()&lt;/a&gt; , &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context ()&lt;/a&gt; , &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; , &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; , &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata ()&lt;/a&gt; и / или &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc88bed6dbd7abe62664d54e6bdaf4f83cf04fb" translate="yes" xml:space="preserve">
          <source>The copy is edited to change the branch instruction into either a no-op or an unconditional jump.</source>
          <target state="translated">Копия редактируется,чтобы изменить инструкцию ветки либо на &quot;нет-нет-нет&quot;,либо на &quot;безусловный прыжок&quot;.</target>
        </trans-unit>
        <trans-unit id="cb1935e51d150180f58869cd5c4365f67de7c57a" translate="yes" xml:space="preserve">
          <source>The copy method implements similar functionality to the &lt;b&gt;.import&lt;/b&gt; SQLite shell command.</source>
          <target state="translated">Метод копирования реализует аналогичные функции с &lt;b&gt;командой&lt;/b&gt; оболочки &lt;b&gt;.import&lt;/b&gt; SQLite.</target>
        </trans-unit>
        <trans-unit id="7d3c9b74d67dc166ca8e07aaa910e143f4d6cf96" translate="yes" xml:space="preserve">
          <source>The copy of sqlite3.s is assembled into sqlite3.o then linked again th3.o to generate the &quot;th3&quot; executable.</source>
          <target state="translated">Копия sqlite3.s собирается в sqlite3.o и затем снова связывается th3.o для генерации &quot;th3&quot; исполняемого файла.</target>
        </trans-unit>
        <trans-unit id="b047a98a10f78ed2613ab80ee6fd529ee912f70f" translate="yes" xml:space="preserve">
          <source>The core functions shown below are available by default. &lt;a href=&quot;lang_datefunc&quot;&gt;Date &amp;amp; Time functions&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;, &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;window functions&lt;/a&gt;, and &lt;a href=&quot;json1&quot;&gt;JSON functions&lt;/a&gt; are documented separately. An application may define additional functions written in C and added to the database engine using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="translated">Показанные ниже основные функции доступны по умолчанию. &lt;a href=&quot;lang_datefunc&quot;&gt;Функции даты и времени&lt;/a&gt; , &lt;a href=&quot;lang_aggfunc&quot;&gt;агрегатные функции&lt;/a&gt; , &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;оконные функции&lt;/a&gt; и &lt;a href=&quot;json1&quot;&gt;функции JSON&lt;/a&gt; документируются отдельно. Приложение может определять дополнительные функции, написанные на C и добавленные в ядро ​​базы данных с помощью API &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7002ce76e139b64c91049472e1737291c84c664" translate="yes" xml:space="preserve">
          <source>The core idea is to create a special table (named &quot;UNDOLOG&quot; in the example) that holds information needed to undo/redo changes to the database. For each class (table) in the database that wants to participate in the undo/redo, triggers are created that cause entries to be made in the UNDOLOG table for each DELETE, INSERT, and UPDATE of the participating class. The UNDOLOG entries consist of ordinary SQL statements the can be played back to reverse the changes.</source>
          <target state="translated">Основная идея заключается в создании специальной таблицы (в примере названной &quot;UNDOLOG&quot;),содержащей информацию,необходимую для отмены/внесения изменений в базу данных.Для каждого класса (таблицы)в БД,который хочет участвовать в отмене/повторжении,создаются триггеры,которые вызывают записи в таблице UNDOLOG для каждого DELETE,INSERT и UPDATE участвующего класса.Записи UNDOLOG состоят из обычных SQL-операторов,которые могут быть воспроизведены для отмены изменений.</target>
        </trans-unit>
        <trans-unit id="b4619c14d9f61ffdd467d39188a12cbd3dab6b8b" translate="yes" xml:space="preserve">
          <source>The core of a SELECT statement is a &quot;simple SELECT&quot; shown by the &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; and &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; syntax diagrams below. In practice, most SELECT statements are simple SELECT statements.</source>
          <target state="translated">Ядром оператора SELECT является &amp;laquo;простой SELECT&amp;raquo;, показанный синтаксическими диаграммами &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; и &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; ниже. На практике большинство операторов SELECT являются простыми операторами SELECT.</target>
        </trans-unit>
        <trans-unit id="202f127cc642aea639fbf4c524ee9db3a310c986" translate="yes" xml:space="preserve">
          <source>The core query used to generate the branch timeline is shown below. (Readers are not expected to understand the details of this query. Commentary will follow.)</source>
          <target state="translated">Ниже показан основной запрос,использованный для генерации шкалы времени ветки.(Читатели не должны понимать детали этого запроса.Комментарий последует далее).</target>
        </trans-unit>
        <trans-unit id="ca59f51d09381d1b3447776404c915b9169882ab" translate="yes" xml:space="preserve">
          <source>The core string formatting routine is the sqlite3VXPrintf() function found in the &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; source file. All the various interfaces invoke (sometimes indirectly) this one core function. The sqlite3VXPrintf() function began as code written by the first author of SQLite (&lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt;) when he was a graduate student a Duke University in the late 1980s. Hipp kept this printf() implementation in his personal toolbox until he started working on SQLite in 2000. The code was incorporated into the SQLite source tree on &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;2000-10-08&lt;/a&gt; for SQLite version 1.0.9.</source>
          <target state="translated">Основная процедура форматирования строк - это функция sqlite3VXPrintf (), которая находится в исходном файле &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; . Все различные интерфейсы вызывают (иногда косвенно) эту одну базовую функцию. Функция sqlite3VXPrintf () началась с кода, написанного первым автором SQLite ( &lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt; ), когда он был аспирантом Университета Дьюка в конце 1980-х годов. Хипп хранил эту реализацию printf () в своем личном наборе инструментов до тех пор, пока не начал работать над SQLite в 2000 году. Код был включен в дерево исходных &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;текстов&lt;/a&gt; SQLite 2008-10-08 для SQLite версии 1.0.9.</target>
        </trans-unit>
        <trans-unit id="093b78a42e1ecfed114ac694aeda4be18d47e5e9" translate="yes" xml:space="preserve">
          <source>The cost table can be named anything you want - it does not have to be called &quot;editcost&quot;. And the table can contain additional columns. The only requirement is that the table must contain the four columns show above, with exactly the names shown.</source>
          <target state="translated">Таблицу стоимости можно назвать как угодно-ее не обязательно называть &quot;editcost&quot;.А таблица может содержать дополнительные колонки.Единственное требование-таблица должна содержать четыре столбца,показанные выше,с точно указанными именами.</target>
        </trans-unit>
        <trans-unit id="ab3b915916ad100c2de3d193cbc3d8e54968ac9c" translate="yes" xml:space="preserve">
          <source>The costs are comprised of multiple numbers, not a single number as shown in the graph. SQLite computes several different estimated costs for each loop that apply at different times. For example, there is a &quot;setup&quot; cost that is incurred just once when the query starts. The setup cost is the cost of computing an &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; for a table that does not already have an index. Then there is the cost of running each step of the loop. Finally, there is an estimate of the number rows generated by the loop, which is information needed in estimating the costs of inner loops. Sorting costs may come into play if the query has an ORDER BY clause.</source>
          <target state="translated">Стоимость состоит из нескольких чисел, а не из одного числа, как показано на графике. SQLite вычисляет несколько различных оценочных затрат для каждого цикла, которые применяются в разное время. Например, есть &amp;laquo;затраты на установку&amp;raquo;, которые понесены только один раз при запуске запроса. Стоимость установки - это стоимость вычисления &lt;a href=&quot;optoverview#autoindex&quot;&gt;автоматического индекса&lt;/a&gt; для таблицы, у которой еще нет индекса. Затем идет стоимость выполнения каждого шага цикла. Наконец, есть оценка количества строк, сгенерированных циклом, которая является информацией, необходимой для оценки стоимости внутренних циклов. Затраты на сортировку могут иметь значение, если в запросе есть предложение ORDER BY.</target>
        </trans-unit>
        <trans-unit id="19bc3b9522f26a7b0a814b17b06d2223be3c56f5" translate="yes" xml:space="preserve">
          <source>The count(X) function returns a count of the number of times that</source>
          <target state="translated">Функция count(X)возвращает количество раз,которое</target>
        </trans-unit>
        <trans-unit id="e3944d86225bf50f66350ca2264ab4a84abeb87d" translate="yes" xml:space="preserve">
          <source>The cov1 test set used to obtain 100% branch test coverage are only a subset of the tests currently implemented using TH3. New test modules are added on a regular basis.</source>
          <target state="translated">Набор тестов cov1,используемый для получения 100%-ного тестового покрытия ветвей,является лишь подмножеством тестов,реализованных в настоящее время с использованием TH3.Новые тестовые модули добавляются регулярно.</target>
        </trans-unit>
        <trans-unit id="d677c2d682d4dade2e8fc2faf6167d79dbe61f08" translate="yes" xml:space="preserve">
          <source>The crash tests in SQLite have discovered a number of very subtle bugs (now fixed) in the recovery mechanism. Some of these bugs were very obscure and unlikely to have been found using only code inspection and analysis techniques. From this experience, the developers of SQLite feel confident that any other database system that does not use a similar crash test system likely contains undetected bugs that will lead to database corruption following a system crash or power failure.</source>
          <target state="translated">Крэш-тесты в SQLite обнаружили ряд очень тонких ошибок (теперь исправлены)в механизме восстановления.Некоторые из этих ошибок были очень непонятны и вряд ли были найдены с использованием только методов осмотра и анализа кода.Исходя из этого опыта,разработчики SQLite уверены,что любая другая система базы данных,не использующая аналогичную систему краш-тестов,скорее всего,содержит необнаруженные ошибки,которые приведут к повреждению базы данных после сбоя системы или отключения электропитания.</target>
        </trans-unit>
        <trans-unit id="33ac0d26d4e9c7d412c89e095055cacaebdbb563" translate="yes" xml:space="preserve">
          <source>The cumulative distribution. Calculated as</source>
          <target state="translated">Совокупное распределение.Рассчитано как</target>
        </trans-unit>
        <trans-unit id="9f3f4c9ed1a83693cad288a8dbbe975dd262d497" translate="yes" xml:space="preserve">
          <source>The current implementation of SQLite uses only loop joins. That is to say, joins are implemented as nested loops.</source>
          <target state="translated">Текущая реализация SQLite использует только соединения циклов.То есть соединения реализованы как вложенные циклы.</target>
        </trans-unit>
        <trans-unit id="0595dd468ba4f2594b89c18514e0ce47ff0d0c46" translate="yes" xml:space="preserve">
          <source>The current implementation of this JSON library uses a recursive descent parser. In order to avoid using excess stack space, any JSON input that has more than 2000 levels of nesting is considered invalid. Limits on nesting depth are allowed for compatible implementations of JSON by &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159 section 9&lt;/a&gt;.</source>
          <target state="translated">Текущая реализация этой библиотеки JSON использует парсер рекурсивного спуска. Чтобы избежать использования лишнего пространства стека, любой ввод JSON с более чем 2000 уровнями вложенности считается недопустимым. Ограничения на глубину вложенности разрешены для совместимых реализаций JSON в &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;разделе 9 RFC-7159&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1859423b8976d8bfae8dfc344c1935671c660093" translate="yes" xml:space="preserve">
          <source>The current implementation will only support a string or BLOB length up to 2&lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt;-1 or 2147483647. And some built-in functions such as hex() might fail well before that point. In security-sensitive applications it is best not to try to increase the maximum string and blob length. In fact, you might do well to lower the maximum string and blob length to something more in the range of a few million if that is possible.</source>
          <target state="translated">Текущая реализация будет поддерживать только строку или большой двоичный объект длиной до 2 &lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt; -1 или 2147483647. И некоторые встроенные функции, такие как hex (), могут выйти из строя задолго до этого. В чувствительных к безопасности приложениях лучше не пытаться увеличить максимальную длину строки и большого двоичного объекта. Фактически, вы могли бы поступить правильно, снизив максимальную длину строки и blob до чего-то большего в диапазоне нескольких миллионов, если это возможно.</target>
        </trans-unit>
        <trans-unit id="ce671671108a214d3061700585cfbe08230e46de" translate="yes" xml:space="preserve">
          <source>The current row. For RANGE and GROUPS frame types, peers of the current row are also included in the frame, unless specifically excluded by the EXCLUDE clause. This is true regardless of whether CURRENT ROW is used as the starting or ending frame boundary.</source>
          <target state="translated">Текущий ряд.Для типов кадров RANGE и GROUPS коллеги текущей строки также включаются в кадр,если только это специально не исключено пунктом EXCLUDE.Это справедливо независимо от того,используется ли CURRENT ROW в качестве границы начального или конечного кадра.</target>
        </trans-unit>
        <trans-unit id="bd2930f3fd3f6f19fc9ada96c54055098b67532e" translate="yes" xml:space="preserve">
          <source>The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr. If the resetFlg is true, then the highest instantaneous value is reset back down to the current value.</source>
          <target state="translated">Текущее значение запрашиваемого параметра записывается в *pCur,а наибольшее мгновенное значение-в *pHiwtr.Если resetFlg верно,то самое большое мгновенное значение сбрасывается назад к текущему значению.</target>
        </trans-unit>
        <trans-unit id="b3c10a59b750c785e72b4dc21d7b05d270490210" translate="yes" xml:space="preserve">
          <source>The current working directory (&quot;.&quot;)</source>
          <target state="translated">Текущая рабочая директория (&quot;.&quot;)</target>
        </trans-unit>
        <trans-unit id="34c8be248703e890d36c7a3af0b628d68ce8275b" translate="yes" xml:space="preserve">
          <source>The current writer concludes its transaction, OR</source>
          <target state="translated">Текущий автор заключает свою сделку,ИЛИ</target>
        </trans-unit>
        <trans-unit id="d429ef679ef6041cdac168ab25fbc584b8f7c9d4" translate="yes" xml:space="preserve">
          <source>The cycle above can be repeated many times. The diagram shows a third SQLite release, 3.6.17 in circle (6). The private branch maintainer can do another merge in order to incorporate the changes moving from (4) to (6) into the private branch, resulting in version (7).</source>
          <target state="translated">Указанный выше цикл можно повторять много раз.На диаграмме показан третий релиз SQLite,3.6.17 в кружке (6).Мейнтейнер частной ветки может провести ещё одно слияние,чтобы включить изменения,переходящие от (4)к (6),в частную ветку,в результате чего получится версия (7).</target>
        </trans-unit>
        <trans-unit id="8810808ac8350e84a24599fba1a1c44e6d0fc9da" translate="yes" xml:space="preserve">
          <source>The cycle counts provided by cachegrind are a good proxy for actual performance, but they are not 100% accurate.</source>
          <target state="translated">Количество циклов,обеспечиваемое кэш-функцией,является хорошим прокси-сервером для фактической производительности,но они не на 100% точны.</target>
        </trans-unit>
        <trans-unit id="fac9319a6ade67af6ca8dc4d7c432433a5c8d584" translate="yes" xml:space="preserve">
          <source>The data and method columns may also be set as described for an INSERT above.</source>
          <target state="translated">Столбцы данных и метода также могут быть установлены,как описано выше для INSERT.</target>
        </trans-unit>
        <trans-unit id="062b3a0f8f6a4c6911f0379b0878b031acaf0a51" translate="yes" xml:space="preserve">
          <source>The data for a table b-tree leaf page and the key of an index b-tree page was characterized above as an arbitrary sequence of bytes. The prior discussion mentioned one key being less than another, but did not define what &quot;less than&quot; meant. The current section will address these omissions.</source>
          <target state="translated">Данные для страницы листа b-дерева таблицы и ключа индексной страницы b-дерева были охарактеризованы выше как произвольная последовательность байтов.В ходе предыдущего обсуждения было упомянуто,что один ключ меньше другого,но не было определено,что означает &quot;меньше&quot;.В настоящем разделе будут рассмотрены эти пропуски.</target>
        </trans-unit>
        <trans-unit id="b9c10539b9c59116b81ff7089713236e6e1327e8" translate="yes" xml:space="preserve">
          <source>The data for rowid tables is stored as a B-Tree structure containing one entry for each table row, using the rowid value as the key. This means that retrieving or sorting records by rowid is fast. Searching for a record with a specific rowid, or for all records with rowids within a specified range is around twice as fast as a similar search made by specifying any other PRIMARY KEY or indexed value.</source>
          <target state="translated">Данные для таблиц rowid хранятся в виде B-дерева структуры,содержащего по одной записи для каждой строки таблицы,используя в качестве ключа значение rowid.Это означает,что поиск или сортировка записей по рядкам происходит быстро.Поиск записи с определенным рядком или всех записей с рядками в указанном диапазоне примерно в два раза быстрее,чем аналогичный поиск,выполненный путем указания любого другого PRIMARY KEY или проиндексированного значения.</target>
        </trans-unit>
        <trans-unit id="8f8b09e33f29c0f7e2cdc53d761f0421d3f8a545" translate="yes" xml:space="preserve">
          <source>The data_% table must have all the same columns as the target table, plus one additional column named &quot;rbu_control&quot;. The data_% table should have no PRIMARY KEY or UNIQUE constraints, but each column should have the same type as the corresponding column in the target database. The rbu_control column should have no type at all. For example, if the target database contains:</source>
          <target state="translated">Таблица data_% должна иметь все те же столбцы,что и целевая таблица,плюс один дополнительный столбец с именем &quot;rbu_control&quot;.Таблица data_% не должна иметь ограничений PRIMARY KEY или UNIQUE,но каждый столбец должен иметь тот же тип,что и соответствующий столбец целевой базы данных.Столбец rbu_control вообще не должен иметь типа.Например,если целевая БД содержит:</target>
        </trans-unit>
        <trans-unit id="17bee7a4a210b94f9cd35ef19e344d890d514950" translate="yes" xml:space="preserve">
          <source>The data_% tables may be created as follows:</source>
          <target state="translated">Таблицы data_% могут быть созданы следующим образом:</target>
        </trans-unit>
        <trans-unit id="d8fc42980131b74512111cf667ced537b6faec1f" translate="yes" xml:space="preserve">
          <source>The data_% tables themselves should have no PRIMARY KEY declarations. However, RBU is more efficient if reading the rows in from each data_% table in &quot;rowid&quot; order is roughly the same as reading them sorted by the PRIMARY KEY of the corresponding target database table. In other words, rows should be sorted using the destination table PRIMARY KEY fields before they are inserted into the data_% tables.</source>
          <target state="translated">Сами таблицы data_% не должны иметь деклараций PRIMARY KEY.Однако RBU более эффективен,если чтение строк в каждой таблице data_% в &quot;рядном&quot; порядке примерно такое же,как и чтение их отсортированных по PRIMARY KEY соответствующей целевой таблицы БД.Другими словами,строки должны быть отсортированы с использованием полей целевой таблицы PRIMARY KEY,прежде чем они будут вставлены в таблицы data_%.</target>
        </trans-unit>
        <trans-unit id="0e861495335228dd9715b8957c822d148379befb" translate="yes" xml:space="preserve">
          <source>The data_ccc table may then be populated as normal with the updates intended for target database table ccc. The same updates will be read by RBU from the data0_ccc_fts view and applied to FTS table ccc_fts. Because &quot;data0_ccc_fts&quot; is smaller than &quot;data_ccc&quot;, the FTS table will be updated first, as required.</source>
          <target state="translated">В этом случае таблица data_ccc может быть заполнена,как обычно,обновлениями,предназначенными для целевой базы данных таблицы ccc.Эти же обновления будут считываться RBU из представления data0_ccc_fts и применяться к таблице FTS ccc_fts.Поскольку &quot;data0_ccc_fts&quot; меньше,чем &quot;data_ccc&quot;,то таблица FTS будет обновляться первой при необходимости.</target>
        </trans-unit>
        <trans-unit id="7a9df4aba808f0f7f287daab1202c053d1ad5c81" translate="yes" xml:space="preserve">
          <source>The database being vacuumed may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Очищаемая база данных может быть не в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f84e31daf7f78443fa69ada7a9a8e535388ab9" translate="yes" xml:space="preserve">
          <source>The database connection can be changed between full and incremental autovacuum mode at any time. However, changing from &quot;none&quot; to &quot;full&quot; or &quot;incremental&quot; can only occur when the database is new (no tables have yet been created) or by running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. To change auto-vacuum modes, first use the auto_vacuum pragma to set the new desired mode, then invoke the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to reorganize the entire database file. To change from &quot;full&quot; or &quot;incremental&quot; back to &quot;none&quot; always requires running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; even on an empty database.</source>
          <target state="translated">Соединение с базой данных можно в любой момент изменить между полным и инкрементным режимом автоочистки. Однако изменение с &amp;laquo;нет&amp;raquo; на &amp;laquo;полную&amp;raquo; или &amp;laquo;инкрементальную&amp;raquo; может происходить только в случае новой базы данных (таблицы еще не созданы) или при выполнении команды &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . Чтобы изменить режимы автоматического вакуумирования, сначала используйте прагму auto_vacuum, чтобы установить новый желаемый режим, затем вызовите команду &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; чтобы реорганизовать весь файл базы данных. Для изменения с &amp;laquo;полного&amp;raquo; или &amp;laquo;инкрементального&amp;raquo; обратно на &amp;laquo;нет&amp;raquo; всегда требуется запускать &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; даже в пустой базе данных.</target>
        </trans-unit>
        <trans-unit id="3e8669da1288d64c48a1d4da77efa2cfbe93e717" translate="yes" xml:space="preserve">
          <source>The database connection is opened using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">Соединение с базой данных открывается с использованием &lt;a href=&quot;uri#uriimmutable&quot;&gt;неизменяемого параметра запроса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17dc502f4a596e5beade9b059c41722a7380dd5f" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged for WAL mode. However, the WAL file and the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; are new concepts and so older versions of SQLite will not know how to recover a crashed SQLite database that was operating in WAL mode when the crash occurred. To prevent older versions of SQLite (prior to version 3.7.0, 2010-07-22) from trying to recover a WAL-mode database (and making matters worse) the database file format version numbers (bytes 18 and 19 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;) are increased from 1 to 2 in WAL mode. Thus, if an older version of SQLite attempts to connect to an SQLite database that is operating in WAL mode, it will report an error along the lines of &quot;file is encrypted or is not a database&quot;.</source>
          <target state="translated">Формат файла базы данных не изменился для режима WAL. Однако файл WAL и &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; являются новыми концепциями, и поэтому более старые версии SQLite не знают, как восстановить базу данных SQLite, после которой произошел сбой, которая работала в режиме WAL, когда произошел сбой. Чтобы старые версии SQLite (до версии 3.7.0, 2010-07-22) не пытались восстановить базу данных в режиме WAL (что еще хуже), номера версий формата файлов базы данных (байты 18 и 19 в &lt;a href=&quot;fileformat2#database_header&quot;&gt;заголовке базы данных)&lt;/a&gt; ) увеличиваются с 1 до 2 в режиме WAL. Таким образом, если более старая версия SQLite попытается подключиться к базе данных SQLite, которая работает в режиме WAL, она сообщит об ошибке в строке &amp;laquo;файл зашифрован или не является базой данных&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9c1329ad6c1d5d5a9b13da19601459b465ae67ba" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged.</source>
          <target state="translated">Формат файла базы данных не изменился.</target>
        </trans-unit>
        <trans-unit id="1d07edfc3d0d439a4f2d02bad68d889bf985841b" translate="yes" xml:space="preserve">
          <source>The database file header</source>
          <target state="translated">Заголовок файла базы данных</target>
        </trans-unit>
        <trans-unit id="042540519692f217502c3ae945ec1187e2e057d0" translate="yes" xml:space="preserve">
          <source>The database file is synced to ensure that all updates are stored safely on the persistent media.</source>
          <target state="translated">Файл базы данных синхронизируется для обеспечения безопасного хранения всех обновлений на постоянном носителе.</target>
        </trans-unit>
        <trans-unit id="e23d0cd874d4749bf56cbe1f6d077df68f5dc7f5" translate="yes" xml:space="preserve">
          <source>The database file is unlocked.</source>
          <target state="translated">Файл базы данных разблокирован.</target>
        </trans-unit>
        <trans-unit id="0b3f3d4ba2117afe864ef2e2e3855b3dd6cb1ace" translate="yes" xml:space="preserve">
          <source>The database filename is not allowed to be a symbolic link</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5b1b36f625c53227300ca5232e63d1f84ef897" translate="yes" xml:space="preserve">
          <source>The database for TEMP tables is not created until it is needed.</source>
          <target state="translated">База данных для таблиц TEMP не создается до тех пор,пока в ней нет необходимости.</target>
        </trans-unit>
        <trans-unit id="0bdbc9610964d617ffff9c05691c3e95d705203e" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">Дескриптор базы данных не должен находиться в &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;режиме автоматической фиксации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94abbac71c91061eed5db3642683f70b586a784a" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="translated">Дескриптор базы данных не должен находиться в &lt;a href=&quot;get_autocommit&quot;&gt;режиме автоматической фиксации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="915d44defd987e4d007442eec15de7482af138fa" translate="yes" xml:space="preserve">
          <source>The database in which the new table is created. Tables may be created in the main database, the temp database, or in any attached database.</source>
          <target state="translated">БД,в которой создается новая таблица.Таблицы могут создаваться в основной БД,временной БД или в любой присоединенной БД.</target>
        </trans-unit>
        <trans-unit id="f11c35a2d4a1cdd518b7cc45f596b046478c935a" translate="yes" xml:space="preserve">
          <source>The database is modified by the transaction</source>
          <target state="translated">База данных модифицируется транзакцией</target>
        </trans-unit>
        <trans-unit id="a60dcb2504ad2ca1f013e489bb243d5fba664847" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eaa608858923b8628e324d3b5e39f5d6ac0b6e8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;../sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="438e6e4f2464e93327c1c43679960b9033bba769" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; disabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2866aa5f974824c8ab6f079d70d8228fd2d735a8" translate="yes" xml:space="preserve">
          <source>The database is opened &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; enabled, overriding the default shared cache setting provided by &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca1bec50c05a4f92423e17a029876db2e2195fa" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.</source>
          <target state="translated">БД по возможности открывается на чтение и запись или на чтение только в том случае,если файл защищен операционной системой от записи.В любом случае банк данных должен уже существовать,в противном случае возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="9bd4a4b6de8565a3e1cf815b4bc5b9706070cf17" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing, and is created if it does not already exist. This is the behavior that is always used for sqlite3_open() and sqlite3_open16().</source>
          <target state="translated">База данных открыта для чтения и записи и создается,если ее еще нет.Именно такое поведение всегда используется для sqlite3_open()и sqlite3_open16().</target>
        </trans-unit>
        <trans-unit id="e33053c4558a1f3729067b3cae6e30d0b922d25b" translate="yes" xml:space="preserve">
          <source>The database is opened in read-only mode. If the database does not already exist, an error is returned.</source>
          <target state="translated">База данных открывается в режиме только для чтения.Если БД еще не существует,возвращается ошибка.</target>
        </trans-unit>
        <trans-unit id="c36f905350b3694fef2e907f7076bd6c0eb07bcf" translate="yes" xml:space="preserve">
          <source>The database may be read but not written. Any number of processes can hold SHARED locks at the same time, hence there can be many simultaneous readers. But no other thread or process is allowed to write to the database file while one or more SHARED locks are active.</source>
          <target state="translated">База данных может быть прочитана,но не записана.Любое количество процессов может содержать одновременно замки SHARED,следовательно,может быть много одновременных считывателей.Но никакому другому потоку или процессу не разрешается записывать в файл базы данных,пока один или несколько замков SHARED активны.</target>
        </trans-unit>
        <trans-unit id="2cc9e66b5c02e09e5ad16f7b64822b0c58495bb9" translate="yes" xml:space="preserve">
          <source>The database page size in bytes, or 1 if the page size is 65536.</source>
          <target state="translated">Размер страницы базы данных в байтах или 1,если размер страницы 65536.</target>
        </trans-unit>
        <trans-unit id="8a5fb001456adc96d15706d6924ffd2f301ed99f" translate="yes" xml:space="preserve">
          <source>The database page size in bytes. Must be a power of two between 512 and 32768 inclusive, or the value 1 representing a page size of 65536.</source>
          <target state="translated">Размер страницы базы данных в байтах.Должно быть два значения мощности между 512 и 32768 включительно,или значение 1,представляющее размер страницы 65536.</target>
        </trans-unit>
        <trans-unit id="960363c84d760f550ea9fae647b23fad91849f93" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="translated">Схема базы данных (в таблице &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; ) обычно не включается в хэш, но может быть добавлена ​​с помощью параметра &amp;laquo;--schema&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="14a6eadb07a326767237571a6c459f7de69f6f90" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8594a821095f6391744d60f5433b9311564cee65" translate="yes" xml:space="preserve">
          <source>The database text encoding. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be.</source>
          <target state="translated">Текстовая кодировка базы данных.Значение 1 означает UTF-8.Значение 2 означает UTF-16le.Значение 3 означает UTF-16be.</target>
        </trans-unit>
        <trans-unit id="e0c8f6d94e8860f110aff3d0dcf3dec439a12ec1" translate="yes" xml:space="preserve">
          <source>The database will be opened as an in-memory database. The database is named by the &quot;filename&quot; argument for the purposes of cache-sharing, if shared cache mode is enabled, but the &quot;filename&quot; is otherwise ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8474bd3b47622066afeb4b46c5b6be93034d3e7c" translate="yes" xml:space="preserve">
          <source>The datatype of columns now appear in the 4th argument to the callback.</source>
          <target state="translated">Типы данных столбцов теперь появляются в 4-м аргументе к обратному вызову.</target>
        </trans-unit>
        <trans-unit id="aa9bbe0be9ce7cff21329528d0726ee0baa77cf6" translate="yes" xml:space="preserve">
          <source>The date and time functions use a subset of &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns &quot;YYYY-MM-DD HH:MM:SS&quot;. The julianday() function returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; - the number of days since noon in Greenwich on November 24, 4714 B.C. (&lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Proleptic Gregorian calendar&lt;/a&gt;). The strftime() routine returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime() function&lt;/a&gt; from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions:</source>
          <target state="translated">Функции даты и времени используют подмножество &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;форматов&lt;/a&gt; даты и времени IS0-8601 . Функция date () возвращает дату в следующем формате: ГГГГ-ММ-ДД. Функция time () возвращает время в формате ЧЧ: ММ: СС. Функция datetime () возвращает &amp;laquo;ГГГГ-ММ-ДД ЧЧ: ММ: СС&amp;raquo;. Функция julianday () возвращает &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;юлианский день&lt;/a&gt; - количество дней с полудня по Гринвичу 24 ноября 4714 г. до н.э. ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;пролептический григорианский календарь&lt;/a&gt; ). Подпрограмма strftime () возвращает дату, отформатированную в соответствии со строкой формата, указанной в качестве первого аргумента. Строка формата поддерживает наиболее распространенные замены, найденные в функции &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime ()&lt;/a&gt; из стандартной библиотеки C, плюс две новые замены,% f и% J. Ниже приведен полный список допустимых замен strftime ():</target>
        </trans-unit>
        <trans-unit id="41f51b9af9bc71b6bb1cc99119d6849c39b622ad" translate="yes" xml:space="preserve">
          <source>The db parameter is a pointer to the SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is executing the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The pAux argument is the copy of the client data pointer that was the fourth argument to the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; call that registered the &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt;. The argv parameter is an array of argc pointers to null terminated strings. The first string, argv[0], is the name of the module being invoked. The module name is the name provided as the second argument to &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and as the argument to the USING clause of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement that is running. The second, argv[1], is the name of the database in which the new virtual table is being created. The database name is &quot;main&quot; for the primary database, or &quot;temp&quot; for TEMP database, or the name given at the end of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The third element of the array, argv[2], is the name of the new virtual table, as specified following the TABLE keyword in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If present, the fourth and subsequent strings in the argv[] array report the arguments to the module name in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">Параметр db - это указатель на соединение с &lt;a href=&quot;c3ref/sqlite3&quot;&gt;базой данных&lt;/a&gt; SQLite , которое выполняет оператор &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . Аргумент pAux - это копия указателя данных клиента, который был четвертым аргументом для вызова &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; или &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 (),&lt;/a&gt; который зарегистрировал &lt;a href=&quot;c3ref/module&quot;&gt;модуль виртуальной таблицы&lt;/a&gt; . Параметр argv - это массив указателей argc на строки с завершающим нулем. Первая строка argv [0] - это имя вызываемого модуля. Имя модуля - это имя, указанное в качестве второго аргумента &lt;a href=&quot;c3ref/create_module&quot;&gt;функции sqlite3_create_module ()&lt;/a&gt; и в качестве аргумента предложения USING в &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;заявление, которое выполняется. Второй, argv [1], - это имя базы данных, в которой создается новая виртуальная таблица. Имя базы данных - &amp;laquo;main&amp;raquo; для первичной базы данных или &amp;laquo;temp&amp;raquo; для базы данных TEMP, или имя, указанное в конце оператора &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; для присоединенных баз данных. Третий элемент массива, argv [2], - это имя новой виртуальной таблицы, как указано после ключевого слова &lt;a href=&quot;lang_createvtab&quot;&gt;TABLE в&lt;/a&gt; операторе CREATE VIRTUAL TABLE . Если присутствует, четвертая и последующие строки в массиве argv [] сообщают аргументы имени модуля в операторе &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f728f7217f7fc88bd0e8e8228a6a594400b21afc" translate="yes" xml:space="preserve">
          <source>The dbhash program is implemented by a single file of C-code called &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt;. To build the dbhash program manually, simply compile the dbhash.c source file and link it against the SQLite library.</source>
          <target state="translated">Программа dbhash реализуется одним файлом C-кода, который называется &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt; . Чтобы собрать программу dbhash вручную, просто скомпилируйте исходный файл dbhash.c и свяжите его с библиотекой SQLite.</target>
        </trans-unit>
        <trans-unit id="b16703d23a9ca6a2a8cb4ca235cc87a944a6dff5" translate="yes" xml:space="preserve">
          <source>The dbhash.exe Utility Program</source>
          <target state="translated">Полезная программа dbhash.exe.</target>
        </trans-unit>
        <trans-unit id="825612a3619e0d061fa775e13b4301fdfc5c4d06" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer has been so successful at hardening the SQLite code base against malicious attack that it is now considered one of the four primary test harnesses for SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce23c499eac5efbdaf2dbb036cb7b2ac9a155ffe" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file.</source>
          <target state="translated">Фаззер dbsqlfuzz изменяет одновременно входные данные SQL и файл базы данных. Dbsqlfuzz использует настраиваемый &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;мутатор&lt;/a&gt; с учетом структуры в специализированном входном файле, который определяет как входную базу данных, так и текст SQL, который будет запускаться в этой базе данных. Поскольку он изменяет и входную базу данных, и входной SQL одновременно, dbsqlfuzz смогла найти некоторые неясные ошибки в SQLite, которые были пропущены предыдущими фаззерами, которые мутировали только входные данные SQL или только файл базы данных.</target>
        </trans-unit>
        <trans-unit id="e0f01bd5981d7e05e25eea466d94ddbb29381d04" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file. The SQLite developers usually leave an instance or two of dbsqlfuzz running on the latest trunk code of SQLite whenever they are away from the office for an extended period, such as overnight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bae73cc22154360311af38fab160d5138d312f9" translate="yes" xml:space="preserve">
          <source>The dbstat virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="translated">Виртуальная таблица dbstat - это &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименная виртуальная таблица&lt;/a&gt; , что означает, что нет необходимости запускать &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; для создания экземпляра виртуальной таблицы dbstat перед ее использованием. Имя модуля &amp;laquo;dbstat&amp;raquo; можно использовать, как если бы это было имя таблицы, для непосредственного запроса виртуальной таблицы dbstat. Например:</target>
        </trans-unit>
        <trans-unit id="efcc1572318b12d880dcf6c5ba6e48d567425a65" translate="yes" xml:space="preserve">
          <source>The decision of whether to implement a FROM-clause subquery as a co-routine or using &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattening&lt;/a&gt; now considers whether the result set of the outer query is &quot;complex&quot; (if it contains functions or expression subqueries). A complex result set biases the decision toward the use of co-routines.</source>
          <target state="translated">Решение о том, реализовать ли подзапрос FROM-clause как сопрограмму или использовать &lt;a href=&quot;optoverview#flattening&quot;&gt;сглаживание запросов,&lt;/a&gt; теперь учитывает, является ли набор результатов внешнего запроса &amp;laquo;сложным&amp;raquo; (если он содержит функции или подзапросы выражений). Сложный набор результатов смещает решение в пользу использования совместных процедур.</target>
        </trans-unit>
        <trans-unit id="ab20325df0acc9b2aa5397a0a5067782536af164" translate="yes" xml:space="preserve">
          <source>The decision of which collating sequence to use is controlled by the COLLATE clause in SQL. A COLLATE clause can occur on a table definition, to define a default collating sequence to a table column, or on field of an index, or in the ORDER BY clause of a SELECT statement. Planned enhancements to SQLite are to include standard CAST() syntax to allow the collating sequence of an expression to be defined.</source>
          <target state="translated">Решение о том,какую коллекционную последовательность использовать,контролируется в SQL с помощью выражения COLLATE.Оговорка COLLATE может встречаться в определении таблицы,в определении коллизионной последовательности по умолчанию к столбцу таблицы,или к полю индекса,или в пункте ORDER BY оператора SELECT.Планируемые усовершенствования SQLite включают стандартный синтаксис CAST(),позволяющий определять коллекционную последовательность выражения.</target>
        </trans-unit>
        <trans-unit id="18e04830dfd2e28b2697cd44ccf76543eadbcceb" translate="yes" xml:space="preserve">
          <source>The declared type of each column in the table.</source>
          <target state="translated">Объявленный тип каждого столбца таблицы.</target>
        </trans-unit>
        <trans-unit id="68032822fa262cd72f80461a11d217079b712edb" translate="yes" xml:space="preserve">
          <source>The default 'crisismerge' value is 16. There is no maximum limit. Attempting to set the 'crisismerge' parameter to a value of 0 or 1 is equivalent to setting it to the default value (16). It is an error to attempt to set the 'crisismerge' option to a negative value.</source>
          <target state="translated">По умолчанию значение 'crisismerge' равно 16.Максимального предела нет.Попытка установить параметр 'crisismerge' на значение 0 или 1 эквивалентна установке его на значение по умолчанию (16).Ошибкой является попытка установить опцию 'crisismerge' в отрицательное значение.</target>
        </trans-unit>
        <trans-unit id="04fcbed48c760da194eb2fb040297255b4fffa15" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; is changed from 1 to 4. This means that, unless the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format=ON&lt;/a&gt; statement is run, newly created database files will be unreadable by version of SQLite prior to 3.3.0 (2006-01-10). It also means that the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; are enabled by default.</source>
          <target state="translated">Номер &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;формата схемы по&lt;/a&gt; умолчанию изменен с 1 на 4. Это означает, что, если не будет &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;запущен оператор PRAGMA legacy_file_format = ON&lt;/a&gt; , вновь созданные файлы базы данных будут нечитаемыми для версий SQLite до 3.3.0 (2006-01-10). Это также означает, что по умолчанию включены &lt;a href=&quot;lang_createindex#descidx&quot;&gt;нисходящие индексы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8d41b5a0a8527b81ce581d5cb059a7a0ef7283f" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; used by SQLite when creating new database files is set by this macro. The schema formats are all very similar. The difference between formats 1 and 4 is that format 4 understands &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; and has a tighter encoding for boolean values.</source>
          <target state="translated">Этот макрос устанавливает &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;номер формата схемы по&lt;/a&gt; умолчанию , используемый SQLite при создании новых файлов базы данных. Форматы схемы очень похожи. Разница между форматами 1 и 4 заключается в том, что формат 4 понимает &lt;a href=&quot;lang_createindex#descidx&quot;&gt;убывающие индексы&lt;/a&gt; и имеет более жесткую кодировку для логических значений.</target>
        </trans-unit>
        <trans-unit id="ca0921362c7fa29bf8c96529653cba6ff2aa4225" translate="yes" xml:space="preserve">
          <source>The default MASK is and always shall be 0xfffe. The 0xfffe mask means perform all of the optimizations listed above except Debug Mode. If new optimizations are added in the future that should be off by default, those new optimizations will be given a mask of 0x10000 or larger.</source>
          <target state="translated">МАСКА по умолчанию является и всегда должна быть 0xfffe.Маска 0xfffe означает выполнение всех оптимизаций,перечисленных выше,за исключением Debug Mode.Если в будущем будут добавлены новые оптимизации,которые должны быть выключены по умолчанию,то этим новым оптимизациям будет дана маска 0x10000 или больше.</target>
        </trans-unit>
        <trans-unit id="a903124a6abce3d6d4d4bbe7f6d1f8b599823062" translate="yes" xml:space="preserve">
          <source>The default VFS can be changed by registering or re-registering the VFS using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface with a second parameter of 1. Hence, if a (unix) process wants to always use the &quot;unix-nolock&quot; VFS in place of &quot;unix&quot;, the following code would work:</source>
          <target state="translated">VFS по умолчанию можно изменить путем регистрации или перерегистрации VFS с использованием интерфейса &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; со вторым параметром 1. Следовательно, если процесс (unix) хочет всегда использовать VFS &amp;laquo;unix-nolock&amp;raquo; вместо &amp;laquo; unix &quot;, будет работать следующий код:</target>
        </trans-unit>
        <trans-unit id="c5a51f22fb2e29520e6fcdc862dfe6400d4b2d95" translate="yes" xml:space="preserve">
          <source>The default behavior for a loadable extension is that it is unloaded from process memory when the database connection that originally invoked &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; closes. (In other words, the xDlUnload method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is called for all extensions when a database connection closes.) However, if the initialization procedure returns &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; instead of SQLITE_OK, then the extension will not be unloaded (xDlClose will not be invoked) and the extension will remain in process memory indefinitely. The SQLITE_OK_LOAD_PERMANENTLY return value is useful for extensions that want to register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">Поведение по умолчанию для загружаемого расширения заключается в том, что оно выгружается из памяти процесса при закрытии соединения с базой данных, которое изначально вызывало &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; . (Другими словами, метод xDlUnload объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; вызывается для всех расширений при закрытии соединения с базой данных.) Однако, если процедура инициализации возвращает &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; вместо SQLITE_OK, то расширение не будет выгружено (xDlClose не будет вызываться) и расширение останется в памяти процесса на неопределенный срок. Возвращаемое значение SQLITE_OK_LOAD_PERMANENTLY полезно для расширений, которые хотят зарегистрировать новые &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="35fa7584b655adc25cbf99cb25271bb088b3504f" translate="yes" xml:space="preserve">
          <source>The default behavior gives this results:</source>
          <target state="translated">Поведение по умолчанию дает такой результат:</target>
        </trans-unit>
        <trans-unit id="929789505d4e7daeec8d95f7bd37c902d7905d6b" translate="yes" xml:space="preserve">
          <source>The default behavior of assert(X) in standard C is that it is enabled for release builds. This is a reasonable default. However, the SQLite code base has many assert() statements in performance-sensitive areas of the code. Leaving assert(X) turned on causes SQLite to run about three times slower. Also, SQLite strives to provide 100% MC/DC in an as-delivered configuration, which is obviously impossible if assert(X) statements are enabled. For these reasons, assert(X) is a no-op for release builds in SQLite.</source>
          <target state="translated">Поведение по умолчанию assert(X)в стандартном C заключается в том,что он включен для сборки релизов.Это разумное значение по умолчанию.Тем не менее,в коде SQLite есть много операторов assert()в чувствительных к производительности областях кода.Если оставить assert(X)включенным,то SQLite будет работать примерно в три раза медленнее.Кроме того,SQLite стремится предоставлять 100% MC/DC в конфигурации как доставка,что очевидно невозможно,если операторы assert(X)включены.По этим причинам утверждение assert(X)не является опцией для сборки релизов в SQLite.</target>
        </trans-unit>
        <trans-unit id="d9b3b8cc178a304f2169b7fe7ac799ae14ab4502" translate="yes" xml:space="preserve">
          <source>The default behavior of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator is to ignore case for ASCII characters. Hence, by default &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is true. The case_sensitive_like pragma installs a new application-defined LIKE function that is either case sensitive or insensitive depending on the value of the case_sensitive_like pragma. When case_sensitive_like is disabled, the default LIKE behavior is expressed. When case_sensitive_like is enabled, case becomes significant. So, for example, &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is false but &lt;b&gt;'a' LIKE 'a'&lt;/b&gt; is still true.</source>
          <target state="translated">По умолчанию оператор &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; игнорирует регистр символов ASCII. Следовательно, по умолчанию &lt;b&gt;&amp;laquo;A&amp;raquo; LIKE &amp;laquo;A&amp;raquo;&lt;/b&gt; истинно. Прагма case_sensitive_like устанавливает новую определяемую приложением функцию LIKE, которая либо чувствительна к регистру, либо нечувствительна к регистру в зависимости от значения прагмы case_sensitive_like. Когда case_sensitive_like отключен, выражается поведение LIKE по умолчанию. Когда case_sensitive_like включен, регистр становится значимым. Так, например, &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; ложно, но &lt;b&gt;'a' LIKE 'a'&lt;/b&gt; по-прежнему верно.</target>
        </trans-unit>
        <trans-unit id="9edad614da3d9aaf086c0a5c5b068d92a4f96481" translate="yes" xml:space="preserve">
          <source>The default builds for SQLite on Unix, Windows, and OS/2 include a VFS appropriate for the target platform. SQLite builds for other operating systems do not contain a VFS by default, but the application can register one or more at run-time.</source>
          <target state="translated">Стандартные сборки для SQLite на Unix,Windows и OS/2 включают VFS,подходящую для целевой платформы.По умолчанию сборки SQLite для других операционных систем не содержат VFS,но приложение может зарегистрировать одну или более сборок во время выполнения.</target>
        </trans-unit>
        <trans-unit id="6a78f3c92a0ec476b159128dcf1aca02c9237966" translate="yes" xml:space="preserve">
          <source>The default busy callback is NULL.</source>
          <target state="translated">Обратный звонок по умолчанию занят NULL.</target>
        </trans-unit>
        <trans-unit id="a139fc5b0808f70ee2866da438ce9a4197bf896c" translate="yes" xml:space="preserve">
          <source>The default collating function for all strings is BINARY. Alternative collating functions for table columns can be specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement using the COLLATE clause on the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. When a column is indexed, the same collating function specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement is used for the column in the index, by default, though this can be overridden using a COLLATE clause in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="translated">Функция сортировки по умолчанию для всех строк - ДВОИЧНАЯ. Альтернативные функции сортировки для столбцов таблицы могут быть указаны в операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; с помощью предложения COLLATE в &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;определении столбца&lt;/a&gt; . Когда столбец индексируется, та же функция сортировки, которая указана в операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE,&lt;/a&gt; используется для столбца в индексе по умолчанию, хотя это можно переопределить с помощью предложения COLLATE в операторе &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4196a7b520d0708c2ca6c2f0dd09284b39f44638" translate="yes" xml:space="preserve">
          <source>The default configuration for SQLite works great for most applications. But sometimes developers want to tweak the setup to try to squeeze out a little more performance, or take advantage of some obscure feature.</source>
          <target state="translated">Конфигурация по умолчанию для SQLite отлично работает для большинства приложений.Но иногда разработчикам хочется настроить конфигурацию так,чтобы попытаться выжать немного больше производительности,или воспользоваться какой-нибудь непонятной особенностью.</target>
        </trans-unit>
        <trans-unit id="7f629fe0c846fce25506268b75e0f95dc1a4e2cd" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite assumes the underlying filesystem supports long filenames.</source>
          <target state="translated">Конфигурация SQLite по умолчанию предполагает,что базовая файловая система поддерживает длинные имена файлов.</target>
        </trans-unit>
        <trans-unit id="f9ca0f7d70101ac90e64f7de1b18481b2e2650e6" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite only supports case-insensitive comparisons of ASCII characters. The reason for this is that doing full Unicode case-insensitive comparisons and case conversions requires tables and logic that would nearly double the size of the SQLite library. The SQLite developers reason that any application that needs full Unicode case support probably already has the necessary tables and functions and so SQLite should not take up space to duplicate this ability.</source>
          <target state="translated">Конфигурация SQLite по умолчанию поддерживает только регистронезависимые сравнения ASCII-символов.Причина этого заключается в том,что для проведения полных юникодовых нечувствительных к регистру сравнений и регистро-преобразований требуются таблицы и логика,которая почти в два раза больше,чем у библиотеки SQLite.Разработчики SQLite объясняют это тем,что любое приложение,которое нуждается в полной поддержке Unicode case,вероятно,уже имеет необходимые таблицы и функции,и поэтому SQLite не должен занимать место для дублирования этой возможности.</target>
        </trans-unit>
        <trans-unit id="c23763d0cb18af4da83857106ae71fb287c36d2b" translate="yes" xml:space="preserve">
          <source>The default datatype is 'int32'.</source>
          <target state="translated">По умолчанию используется тип данных 'int32'.</target>
        </trans-unit>
        <trans-unit id="57ca93f20ecfcb67f54da8e6ff374c396f410f8d" translate="yes" xml:space="preserve">
          <source>The default deletion cost</source>
          <target state="translated">Стоимость удаления по умолчанию</target>
        </trans-unit>
        <trans-unit id="348ca4d833d68a6b457e44e2f51c5dde36928e20" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files depends on the OS. Some OS interfaces may choose to ignore this variable and place temporary files in some other directory different from the directory specified here. In that sense, this pragma is only advisory.</source>
          <target state="translated">Каталог временных файлов по умолчанию зависит от операционной системы.Некоторые интерфейсы ОС могут игнорировать эту переменную и помещать временные файлы в другую директорию,отличную от указанной здесь.В этом смысле данная прагма является только рекомендательной.</target>
        </trans-unit>
        <trans-unit id="09a19fe31cacf32f0a49986af2b636abaafd7a24" translate="yes" xml:space="preserve">
          <source>The default encoding will be UTF-8 for databases created using sqlite3_open() or sqlite3_open_v2(). The default encoding for databases created using sqlite3_open16() will be UTF-16 in the native byte order.</source>
          <target state="translated">Для баз данных,созданных с помощью sqlite3_open()или sqlite3_open_v2(),кодировкой по умолчанию будет UTF-8.Для баз данных,созданных с помощью sqlite3_open16(),кодировкой по умолчанию будет UTF-16 в родном порядке байт.</target>
        </trans-unit>
        <trans-unit id="93b91496e8c579b792f6528c1582f57d8e5307a9" translate="yes" xml:space="preserve">
          <source>The default file format is now 1.</source>
          <target state="translated">Формат файла по умолчанию теперь 1.</target>
        </trans-unit>
        <trans-unit id="07f52e2687ee82b720aa1390843c77644fb57108" translate="yes" xml:space="preserve">
          <source>The default file format is set by the &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; compile-time option.</source>
          <target state="translated">Формат файла по умолчанию устанавливается параметром &lt;a href=&quot;compile#default_file_format&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_FILE_FORMAT .</target>
        </trans-unit>
        <trans-unit id="cc414446f05fe3ef5190b22cd556bce2036d0102" translate="yes" xml:space="preserve">
          <source>The default frame-spec is:</source>
          <target state="translated">По умолчанию это фрейм-spec:</target>
        </trans-unit>
        <trans-unit id="c9df385f1bced3c35670bbdf7a0e4f5a1cfdb4ca" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option and without the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; but all recent versions of SQLite ignore the sqlite_stat2 table. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="translated">Реализация по умолчанию хранит всю статистику в одной таблице с именем &amp;laquo; &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; &amp;raquo;. Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; и без параметра &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; , то дополнительные данные гистограммы собираются и сохраняются в &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; . Если SQLite скомпилирован с опцией &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; , то дополнительные данные гистограммы собираются и сохраняются в &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; . Более старые версии SQLite использовали &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;бы&lt;/a&gt; таблицу sqlite_stat2 при компиляции с &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2,&lt;/a&gt; но все последние версии SQLite игнорируют таблицу sqlite_stat2. Будущие улучшения могут создать дополнительные &lt;a href=&quot;fileformat2#intschema&quot;&gt;внутренние таблицы&lt;/a&gt;с тем же шаблоном имени, за исключением последней цифры больше &quot;4&quot;. Все эти таблицы вместе называются &amp;laquo;таблицами статистики&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2000f471d1e2f9fad888fbe96454c85325906ea0" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table or &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt;, but all recent versions of SQLite ignore the sqlite_stat2 and sqlite_stat3 tables. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c0ee558e2a1a06a318ed232e40e1c0e6d83d45" translate="yes" xml:space="preserve">
          <source>The default insertion cost</source>
          <target state="translated">Стоимость вставки по умолчанию</target>
        </trans-unit>
        <trans-unit id="44b061817ffc2eb0f5dadec06f4e66f4f81231c2" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking, but there are other options. By selecting an alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface, an application can make use of other locking protocols that might be more appropriate to certain filesystems. For example, dot-file locking might be select for use in an application that has to run on an NFS filesystem that does not support POSIX advisory locking.</source>
          <target state="translated">Механизм блокировки по умолчанию, используемый SQLite на платформах unix, - это рекомендательная блокировка POSIX, но есть и другие варианты. Выбирая альтернативный &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; с помощью интерфейса &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , приложение может использовать другие протоколы блокировки, которые могут быть более подходящими для определенных файловых систем. Например, блокировку точечных файлов можно выбрать для использования в приложении, которое должно работать в файловой системе NFS, не поддерживающей рекомендательную блокировку POSIX.</target>
        </trans-unit>
        <trans-unit id="d9e0888f3707dfa1a041c24c2a5eb623fe8f593b" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking. Unfortunately, POSIX advisory locking has design quirks that make it prone to misuse and failure. In particular, any thread in the same process with a file descriptor that is holding a POSIX advisory lock can override that lock using a different file descriptor. One particularly pernicious problem is that the &lt;code&gt;close()&lt;/code&gt; system call will cancel all POSIX advisory locks on the same file for all threads and all file descriptors in the process.</source>
          <target state="translated">Механизм блокировки по умолчанию, используемый SQLite на платформах unix, - это рекомендательная блокировка POSIX. К сожалению, консультативная блокировка POSIX имеет конструктивные особенности, которые делают ее склонной к неправильному использованию и сбоям. В частности, любой поток в том же процессе с файловым дескриптором, который удерживает консультативную блокировку POSIX, может переопределить эту блокировку, используя другой файловый дескриптор. Одна особенно пагубная проблема заключается в том, что системный вызов &lt;code&gt;close()&lt;/code&gt; отменяет все рекомендательные блокировки POSIX для одного и того же файла для всех потоков и всех файловых дескрипторов в процессе.</target>
        </trans-unit>
        <trans-unit id="07275b3b33b4fa68f4e8147d7f962856df7d7bd0" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration has changed from 100 slots of 1200 bytes each (120KB) to be 40 slots of 1200 bytes each (48KB). This space ends up being allocated as 93 slots of 128 bytes each and 30 slots of 1200 bytes each. So more lookaside slots are available but much less heap space is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e313113e047c2f26bfe18f713c540368922a076" translate="yes" xml:space="preserve">
          <source>The default lookaside configuration, the size of the small-slots, and the details of how heap space is allocated between small-slots and big-slots, are all subject to change from one release to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf451db4759c12771bfb1206d604a686ee94bb6" translate="yes" xml:space="preserve">
          <source>The default mapping of the rank column for a table may be modified using the &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5 rank configuration option&lt;/a&gt;.</source>
          <target state="translated">Отображение по умолчанию столбца ранга для таблицы может быть изменено с помощью &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;опции конфигурации ранга FTS5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="676ab2fe4bf4ab903767c236b27e9b63051796ee" translate="yes" xml:space="preserve">
          <source>The default maximum trigger recursion depth is 1000.</source>
          <target state="translated">Максимальная глубина рекурсии триггера по умолчанию составляет 1000.</target>
        </trans-unit>
        <trans-unit id="fd5421bb6c7fc35d245339e5557eb27520f8453d" translate="yes" xml:space="preserve">
          <source>The default means that aggregate window functions read all rows from the beginning of the partition up to and including the current row and its peers. This implies that rows that have the same values for all ORDER BY expressions will also have the same value for the result of the window function (as the window frame is the same). For example:</source>
          <target state="translated">По умолчанию функции агрегированного окна считывают все строки от начала раздела до текущей строки и ее ровесников включительно.Это подразумевает,что строки,которые имеют одинаковые значения для всех выражений ORDER BY,будут иметь одинаковое значение и для результата оконной функции (так как рамка окна одна и та же).Например:</target>
        </trans-unit>
        <trans-unit id="2d78a92ed9db0e9db8d034d6998442b87734337c" translate="yes" xml:space="preserve">
          <source>The default mechanism by which SQLite accesses and updates database disk files is the xRead() and xWrite() methods of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFS object. These methods are typically implemented as &quot;read()&quot; and &quot;write()&quot; system calls which cause the operating system to copy disk content between the kernel buffer cache and user space.</source>
          <target state="translated">Механизм по умолчанию, с помощью которого SQLite получает доступ и обновляет файлы на диске базы данных, - это методы xRead () и xWrite () объекта VFS &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; . Эти методы обычно реализуются как системные вызовы &amp;laquo;read ()&amp;raquo; и &amp;laquo;write ()&amp;raquo;, которые заставляют операционную систему копировать содержимое диска между буферным кешем ядра и пользовательским пространством.</target>
        </trans-unit>
        <trans-unit id="af6b4fd5a17994d4af89bdbebf0e8f01053d45e7" translate="yes" xml:space="preserve">
          <source>The default memory allocation settings in SQLite are appropriate for most applications. However, applications with unusual or particularly strict requirements may want to adjust the configuration to more closely align SQLite to their needs. Both compile-time and start-time configuration options are available.</source>
          <target state="translated">Настройки выделения памяти по умолчанию в SQLite подходят для большинства приложений.Однако приложения с необычными или особо строгими требованиями могут захотеть настроить конфигурацию так,чтобы SQLite более точно соответствовал их потребностям.Доступны опции конфигурации как во время компиляции,так и во время запуска.</target>
        </trans-unit>
        <trans-unit id="62759f30ef7e2768a0dc269d58d4f224a639e96a" translate="yes" xml:space="preserve">
          <source>The default memory allocator is recommended for most applications. If you do not have a compelling need to use an alternative memory allocator, then use the default.</source>
          <target state="translated">Для большинства приложений рекомендуется использовать аллокатор памяти по умолчанию.Если у вас нет необходимости использовать альтернативный аллокатор памяти,то используйте аллокатор по умолчанию.</target>
        </trans-unit>
        <trans-unit id="dcfc21fe3a44b7df155912e662a52083d37f6130" translate="yes" xml:space="preserve">
          <source>The default method by which SQLite implements &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit and rollback&lt;/a&gt; is a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt;. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), a new &quot;Write-Ahead Log&quot; option (hereafter referred to as &quot;WAL&quot;) is available.</source>
          <target state="translated">Метод по умолчанию, с помощью которого SQLite реализует &lt;a href=&quot;atomiccommit&quot;&gt;атомарную фиксацию и откат,&lt;/a&gt; - это &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнал отката&lt;/a&gt; . Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии 3.7.0&lt;/a&gt; ( 21.07.2010 ), доступна новая опция &amp;laquo;Журнал упреждающей записи&amp;raquo; (далее &amp;laquo;WAL&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="03533018c376c706c7055694a5695128f6d5dba9" translate="yes" xml:space="preserve">
          <source>The default mode is serialized.</source>
          <target state="translated">Режим по умолчанию сериализован.</target>
        </trans-unit>
        <trans-unit id="c91c1c07eac44347101354cb661e73cefc49a14a" translate="yes" xml:space="preserve">
          <source>The default numeric file permissions for newly created database files under unix. If not specified, the default is 0644 which means that the files is globally readable but only writable by the creator.</source>
          <target state="translated">Разрешения на использование числовых файлов по умолчанию для вновь создаваемых файлов базы данных в unix.Если не указано,по умолчанию используется значение 0644,что означает,что файлы глобально читаются,но могут быть записаны только их создателем.</target>
        </trans-unit>
        <trans-unit id="b7b908d4b0d2fc05c9ddc3f95f430fcff134a8ed" translate="yes" xml:space="preserve">
          <source>The default operation of edit() is to invoke a text editor. But by using an alternative edit program in the second argument, you can also get it to edit images or other non-text resources. For example, if you want to modify a JPEG image that happens to be stored in a field of a table, you could run:</source>
          <target state="translated">Операция по умолчанию функции edit()заключается в вызове текстового редактора.Но,используя альтернативную программу редактирования во втором аргументе,вы также можете заставить ее редактировать изображения или другие нетекстовые ресурсы.Например,если вы хотите изменить JPEG-изображение,которое случайно хранится в поле таблицы,вы можете запустить его:</target>
        </trans-unit>
        <trans-unit id="e15d9f7898bd04fad7c8bec9316feb2b3c4d67cc" translate="yes" xml:space="preserve">
          <source>The default order of the nested loops in a join is for the left-most table in the FROM clause to form the outer loop and the right-most table to form the inner loop. However, SQLite will nest the loops in a different order if doing so will help it to select better indices.</source>
          <target state="translated">Порядок вложенных циклов в соединении по умолчанию следующий:самая левая таблица в пункте FROM-для формирования внешнего цикла,а самая правая таблица-для формирования внутреннего цикла.Тем не менее,SQLite будет вставлять циклы в другом порядке,если это поможет ему выбрать лучшие индексы.</target>
        </trans-unit>
        <trans-unit id="c60124ec3003cce0626fc7fdd9909bdc4316bd6f" translate="yes" xml:space="preserve">
          <source>The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="translated">Режим вывода по умолчанию-&quot;список&quot;.В режиме списка каждая строка результата запроса записывается в одну строку вывода,а каждый столбец внутри этой строки отделяется определенной строкой разделителя.Разделителем по умолчанию является символ трубы (&quot;|&quot;).Режим списка особенно полезен,когда вы собираетесь отправить результат запроса в другую программу (например,AWK)для дополнительной обработки.</target>
        </trans-unit>
        <trans-unit id="cae14327c7d6852834539912db17ff8fae315187" translate="yes" xml:space="preserve">
          <source>The default output shows the beginning and end of each configuration and test module combination. In the example above &quot;c1&quot; and &quot;64k&quot; are configurations and &quot;pager08&quot;, &quot;build33&quot;, &quot;orderby01&quot;, etc. are test modules. Compile-time and run-time options are available to increase or decrease the amount of output. The output can be increased by showing each test case within each test module. The output can be decreased by degrees: omitting test modules starts and stops, omitting configuration starts and stops, and finally by omitting all output.</source>
          <target state="translated">На выходе по умолчанию отображается начало и конец каждой конфигурации и комбинации тестовых модулей.В примере выше &quot;c1&quot; и &quot;64k&quot;-это конфигурации,а &quot;pager08&quot;,&quot;build33&quot;,&quot;orderby01&quot; и т.д.-тестовые модули.Для увеличения или уменьшения объема выводимых данных доступны опции компиляции и исполнения.Вывод может быть увеличен путем показа каждого тестового случая внутри каждого тестового модуля.Вывод может быть уменьшен на градусы:опускание тестовых модулей запускается и останавливается,опускание конфигурации запускается и останавливается,и,наконец,опускается весь вывод.</target>
        </trans-unit>
        <trans-unit id="81fe79158a35398aa7562b0fca6f1415aa39b894" translate="yes" xml:space="preserve">
          <source>The default page cache implemention does not allocate the full amount of cache memory all at once. Cache memory is allocated in smaller chunks on an as-needed basis. The page_cache setting is a (suggested) upper bound on the amount of memory that the cache can use, not the amount of memory it will use all of the time. This is the behavior of the default page cache implementation, but an &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application defined page cache&lt;/a&gt; is free to behave differently if it wants.</source>
          <target state="translated">Реализация кэша страниц по умолчанию не выделяет сразу весь объем кэш-памяти. Кэш-память выделяется меньшими частями по мере необходимости. Параметр page_cache - это (предлагаемая) верхняя граница объема памяти, которую может использовать кеш, а не объем памяти, который он будет использовать все время. Это поведение реализации кеша страниц по умолчанию, но кеш страниц, определенный &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;приложением,&lt;/a&gt; может вести себя по-другому, если захочет.</target>
        </trans-unit>
        <trans-unit id="fc5d7962d2b50c7baceb7ed65dad81e0058ad64b" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40256b332aa600059fdd4657f3e43acb14b4e3d" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="translated">Кэш страниц по умолчанию старается более тщательно избегать использования памяти сверх того, что выделено ему &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; . Или, если использование кеша страниц выделяется из кучи, он пытается избежать перехода через &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; , даже если &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; не установлен.</target>
        </trans-unit>
        <trans-unit id="619cdf9a91dcb3b5377126d1f738a21802c8e3aa" translate="yes" xml:space="preserve">
          <source>The default page size on windows is automatically adjusted to match the capabilities of the underlying filesystem.</source>
          <target state="translated">Размер страницы по умолчанию в окнах автоматически настраивается в соответствии с возможностями базовой файловой системы.</target>
        </trans-unit>
        <trans-unit id="df04859a275716c6652a67712d525008dc797ebb" translate="yes" xml:space="preserve">
          <source>The default setting for SQLITE_MAX_COLUMN is 2000. You can change it at compile time to values as large as 32767. On the other hand, many experienced database designers will argue that a well-normalized database will never need more than 100 columns in a table.</source>
          <target state="translated">По умолчанию для SQLITE_MAX_COLUMN установлено значение 2000.Вы можете изменить его во время компиляции на значения до 32767.С другой стороны,многие опытные проектировщики БД будут утверждать,что хорошо нормализованная БД никогда не будет нуждаться более чем в 100 столбцах в таблице.</target>
        </trans-unit>
        <trans-unit id="0506f7d82e65a6fef4e6e411dc34fd230ff22185" translate="yes" xml:space="preserve">
          <source>The default setting for auto-vacuum is 0 or &quot;none&quot;, unless the &lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt; compile-time option is used. The &quot;none&quot; setting means that auto-vacuum is disabled. When auto-vacuum is disabled and data is deleted data from a database, the database file remains the same size. Unused database file pages are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot; and reused for subsequent inserts. So no database file space is lost. However, the database file does not shrink. In this mode the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command can be used to rebuild the entire database file and thus reclaim unused disk space.</source>
          <target state="translated">Значение по умолчанию для автоматического вакуумирования - 0 или &amp;laquo;нет&amp;raquo;, если не используется &lt;a href=&quot;compile#default_autovacuum&quot;&gt;параметр времени&lt;/a&gt; компиляции SQLITE_DEFAULT_AUTOVACUUM . Параметр &amp;laquo;Нет&amp;raquo; означает, что автоматический вакуум отключен. Когда автоматический вакуум отключен и данные удаляются из базы данных, файл базы данных остается того же размера. Неиспользуемые страницы файлов базы данных добавляются в &amp;laquo; &lt;a href=&quot;fileformat2#freelist&quot;&gt;свободный&lt;/a&gt; список &amp;raquo; и повторно используются для последующих вставок. Таким образом, файловое пространство базы данных не теряется. Однако файл базы данных не сжимается. В этом режиме команду &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; можно использовать для восстановления всего файла базы данных и, таким образом, освобождения неиспользуемого дискового пространства.</target>
        </trans-unit>
        <trans-unit id="de25e032063f16295b8e77c37d21842694e060fe" translate="yes" xml:space="preserve">
          <source>The default setting for the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; is 0, which means to following the recommendation of &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">Значение по умолчанию для &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагмы temp_store&lt;/a&gt; - 0, что означает выполнение рекомендаций параметра времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d111baa1a5224d066ace9e922bc0723387d0391f" translate="yes" xml:space="preserve">
          <source>The default setting for this pragma is OFF, which means that all references to the table anywhere in the schema are converted to the new name.</source>
          <target state="translated">Параметр по умолчанию для этой прагмы-OFF,что означает,что все ссылки на таблицу в любом месте схемы преобразуются в новое имя.</target>
        </trans-unit>
        <trans-unit id="5060b84cc58c53853f2caf81d58480c0590b9ac5" translate="yes" xml:space="preserve">
          <source>The default setting is 1. Additional information can be found in &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt;.</source>
          <target state="translated">Значение по умолчанию - 1. Дополнительную информацию можно найти в &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e7fc079075b7fd84d6268869958a93f9d4d68c3" translate="yes" xml:space="preserve">
          <source>The default sorting procedure is to gather all information that will ultimately be output into a &quot;record&quot; and pass that complete record to the sorter. But in some cases, for example if some of the output columns consists of large BLOB values, the size of the each record can be large, which means that the sorter has to either use more memory, and/or write more content to temporary storage.</source>
          <target state="translated">Процедура сортировки по умолчанию заключается в сборе всей информации,которая в конечном итоге будет выведена в &quot;запись&quot; и передаче этой полной записи сортировщику.Но в некоторых случаях,например,если некоторые из выводимых столбцов состоят из больших BLOB-значений,размер каждой записи может быть большим,что означает,что сортировщик должен либо использовать больше памяти,либо записывать больше содержимого во временное хранилище.</target>
        </trans-unit>
        <trans-unit id="6f4517865a59fec2a530bec6db77e7cd99eb8490" translate="yes" xml:space="preserve">
          <source>The default strategy is to allow successive write transactions to grow the WAL until the WAL becomes about 1000 pages in size, then to run a checkpoint operation for each subsequent COMMIT until the WAL is reset to be smaller than 1000 pages. By default, the checkpoint will be run automatically by the same thread that does the COMMIT that pushes the WAL over its size limit. This has the effect of causing most COMMIT operations to be very fast but an occasional COMMIT (those that trigger a checkpoint) to be much slower. If that effect is undesirable, then the application can disable automatic checkpointing and run the periodic checkpoints in a separate thread, or separate process. (Links to commands and interfaces to accomplish this are &lt;a href=&quot;#how_to_checkpoint&quot;&gt;shown below&lt;/a&gt;.)</source>
          <target state="translated">Стратегия по умолчанию - разрешить последовательным транзакциям записи увеличивать WAL до тех пор, пока размер WAL не станет примерно 1000 страниц, а затем выполнять операцию контрольной точки для каждого последующего COMMIT, пока WAL не будет сброшен до менее 1000 страниц. По умолчанию контрольная точка будет запускаться автоматически тем же потоком, который выполняет COMMIT, подталкивающий WAL к пределу размера. Это приводит к тому, что большинство операций COMMIT выполняются очень быстро, а случайные COMMIT (те, которые запускают контрольную точку) намного медленнее. Если этот эффект нежелателен, приложение может отключить автоматическое установление контрольных точек и запускать периодические контрольные точки в отдельном потоке или отдельном процессе. (Ссылки на команды и интерфейсы для этого &lt;a href=&quot;#how_to_checkpoint&quot;&gt;показаны ниже&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="7aba3882e935c491d72d10d266cb950c10ccee5f" translate="yes" xml:space="preserve">
          <source>The default substitution cost</source>
          <target state="translated">Стоимость замещения по умолчанию</target>
        </trans-unit>
        <trans-unit id="6947c6a992789a324c997f5478292dca047e240d" translate="yes" xml:space="preserve">
          <source>The default synchronous setting is full so the above is what usually happens. However, if the synchronous setting is lowered to &quot;normal&quot;, SQLite only flushes the rollback journal once, after the page count has been written. This carries a risk of corruption because it might happen that the modified (non-zero) page count reaches the disk surface before all of the data does. The data will have been written first, but SQLite assumes that the underlying filesystem can reorder write requests and that the page count can be burned into oxide first even though its write request occurred last. So as a second line of defense, SQLite also uses a 32-bit checksum on every page of data in the rollback journal. This checksum is evaluated for each page during rollback while rolling back a journal as described in &lt;a href=&quot;#section_4_4&quot;&gt;section 4.4&lt;/a&gt;. If an incorrect checksum is seen, the rollback is abandoned. Note that the checksum does not guarantee that the page data is correct since there is a small but finite probability that the checksum might be right even if the data is corrupt. But the checksum does at least make such an error unlikely.</source>
          <target state="translated">По умолчанию синхронная настройка заполнена, поэтому обычно происходит то, что описано выше. Однако, если параметр синхронности понижен до &amp;laquo;нормального&amp;raquo;, SQLite очищает журнал отката только один раз, после того как счетчик страниц был записан. Это несет в себе риск повреждения, потому что может случиться так, что измененное (ненулевое) количество страниц достигнет поверхности диска раньше, чем все данные. Данные будут записаны первыми, но SQLite предполагает, что соответствующая файловая система может переупорядочивать запросы на запись и что счетчик страниц может быть записан в оксид в первую очередь, даже если ее запрос записи был выполнен последним. Таким образом, в качестве второй линии защиты SQLite также использует 32-битную контрольную сумму на каждой странице данных в журнале отката. Эта контрольная сумма оценивается для каждой страницы во время отката при откате журнала, как описано в &lt;a href=&quot;#section_4_4&quot;&gt;разделе 4.4.&lt;/a&gt;. Если обнаружена неверная контрольная сумма, откат прекращается. Обратите внимание, что контрольная сумма не гарантирует правильность данных страницы, поскольку существует небольшая, но конечная вероятность того, что контрольная сумма может быть правильной, даже если данные повреждены. Но контрольная сумма, по крайней мере, делает такую ​​ошибку маловероятной.</target>
        </trans-unit>
        <trans-unit id="095be1a2c22dcc1b72f1d8ee5a80821a8e3ba1f7" translate="yes" xml:space="preserve">
          <source>The default value for SQLITE_PRINTF_PRECISION_LIMIT is 2147483647 (0x7fffffff).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5887e5cef0e652ea249c383a61a9790399db5025" translate="yes" xml:space="preserve">
          <source>The default value for languageid is 0. If an alternative language is specified in WHERE clause constraints, then that alternative is used instead of 0. There can only be a single languageid per query. In other words, the WHERE clause cannot contain a range constraint or IN operator on the languageid.</source>
          <target state="translated">Значение по умолчанию для лингвида равно 0.Если альтернативный язык указан в ограничениях пункта WHERE,то вместо 0 используется этот альтернативный язык.На каждый запрос может быть только один лингвид.Другими словами,выражение WHERE не может содержать ограничение диапазона или оператор IN на языковике.</target>
        </trans-unit>
        <trans-unit id="3d6f85ef321cfdfaecfbd8525333d39487f3c884" translate="yes" xml:space="preserve">
          <source>The default value of a languageid column is 0. Any value inserted into a languageid column is converted to a 32-bit (not 64) signed integer.</source>
          <target state="translated">Значение столбца языка по умолчанию равно 0.Любое значение,вставленное в столбец языка,преобразуется в 32-битное (не 64)подписанное целое число.</target>
        </trans-unit>
        <trans-unit id="0bb45f8540234b96b45cb058d442c35d3ea03bfa" translate="yes" xml:space="preserve">
          <source>The default value of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is 1, which means to store temporary files on disk but provide the option of overriding the behavior using the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">Значение по умолчанию для параметра &lt;a href=&quot;compile#temp_store&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TEMP_STORE равно 1, что означает хранение временных файлов на диске, но с возможностью переопределения поведения с помощью &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагмы temp_store&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3aae70c9121f536fa334d3f452170e8968ea3458" translate="yes" xml:space="preserve">
          <source>The default value of the usermerge option is 4. The minimum allowed value is 2, and the maximum 16.</source>
          <target state="translated">Значение по умолчанию для опции usermerge-4,минимально допустимое значение-2,максимальное-16.</target>
        </trans-unit>
        <trans-unit id="6973079b710b23783ded0a80f07fc117f677c334" translate="yes" xml:space="preserve">
          <source>The default virtual table (&quot;rtree&quot;) normally stores coordinates as single-precision (4-byte) floating point numbers. If integer coordinates are desired, declare the table using &quot;rtree_i32&quot; instead:</source>
          <target state="translated">В виртуальной таблице по умолчанию (&quot;rtree&quot;)координаты обычно хранятся в виде одноточного (4-байтового)числа с плавающей точкой.Если нужны целые координаты,объявите таблицу,используя &quot;rtree_i32&quot;:</target>
        </trans-unit>
        <trans-unit id="f282a44d7dfb6c6134a7e29df48c07aa44737ff7" translate="yes" xml:space="preserve">
          <source>The demonstration code assumes that the SQLite database is opened used as a database object named &quot;db&quot;.</source>
          <target state="translated">Демонстрационный код предполагает,что БД SQLite открывается и используется как объект БД с именем &quot;db&quot;.</target>
        </trans-unit>
        <trans-unit id="8837968f443dfe5005184f2c6a7e1c74103e5e88" translate="yes" xml:space="preserve">
          <source>The demonstration code below includes a status_refresh method that grays-out or activates the Undo and Redo buttons and menu entries depending on whether or not there is anything to be undone or redone. You will need to redefine this method to control the Undo and Redo buttons in your application.</source>
          <target state="translated">Демонстрационный код ниже включает метод status_refresh,который выделяет серым цветом или активирует кнопки &quot;Отменить&quot; и &quot;Повторно&quot;,а также пункты меню в зависимости от того,есть ли что-то,что нужно отменить или повторить.Вам нужно будет переопределить этот метод,чтобы управлять кнопками Отменить и Повторно в вашем приложении.</target>
        </trans-unit>
        <trans-unit id="e759858c504e056da064aff365282dc111db1fea" translate="yes" xml:space="preserve">
          <source>The depth of recursion for triggers has a hard upper limit set by the &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; compile-time option and a run-time limit set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;,...).</source>
          <target state="translated">Глубина рекурсии для триггеров имеет жесткий верхний предел, установленный параметром &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_MAX_TRIGGER_DEPTH, и предел времени выполнения, установленный &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="40be115b96b882b5a59636c2c2b3cce3bdbb02d6" translate="yes" xml:space="preserve">
          <source>The descendants of OpenOffice tend to segfault more often than commercial competitors. Perhaps for this reason, the OpenOffice forks make periodic backups of their in-memory documents so that users do not lose all pending edits when the inevitable application crash does occur. This causes frustrating pauses in the application for the few seconds while each backup is being made. After restarting from a crash, the user is presented with a dialog box that walks them through the recovery process. Managing the crash recovery this way involves lots of extra application logic and is generally an annoyance to the user.</source>
          <target state="translated">Потомки OpenOffice чаще,чем коммерческие конкуренты,склонны к сегрегации.Возможно,по этой причине вилки OpenOffice периодически делают резервные копии документов в памяти,чтобы пользователи не теряли все отложенные правки при неизбежном падении приложения.Это приводит к разочаровывающим паузам в работе приложения на несколько секунд во время выполнения каждого резервного копирования.После перезапуска после сбоя у пользователя появляется диалоговое окно,в котором он проходит через процесс восстановления.Управление аварийным восстановлением таким образом включает в себя много дополнительной логики приложения и,как правило,раздражает пользователя.</target>
        </trans-unit>
        <trans-unit id="2a2b8799305e9ca9fdc0f3b11f07bd75b53378d6" translate="yes" xml:space="preserve">
          <source>The designed query interface is:</source>
          <target state="translated">Разработан интерфейс запроса:</target>
        </trans-unit>
        <trans-unit id="85d6b31a6dd13fa4a2b19e14c162e00851337050" translate="yes" xml:space="preserve">
          <source>The detail option may be set to &quot;full&quot; (the default value), &quot;column&quot; or &quot;none&quot;. For example:</source>
          <target state="translated">Опция детализации может быть установлена на &quot;полный&quot; (значение по умолчанию),&quot;столбец&quot; или &quot;нет&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="1de34563fa7a58730a8b8b8a025ab7bdcb0a2940" translate="yes" xml:space="preserve">
          <source>The details of optimizations performed by this pragma are expected to change and improve over time. Applications should anticipate that this pragma will perform new optimizations in future releases.</source>
          <target state="translated">Ожидается,что детали оптимизаций,выполняемых этой прагмой,со временем будут меняться и улучшаться.Приложения должны ожидать,что эта прагма будет выполнять новые оптимизации в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="2ec6e7a356da9ba89cc679a27100e250b07d2b68" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">Подробная информация о поведении интерфейса sqlite3_step () зависит от того, было ли подготовлено заявление с использованием более новых интерфейсы &amp;laquo;Vx&amp;raquo; &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или старше устаревшие интерфейсы &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; . Для новых приложений рекомендуется использовать новый интерфейс &amp;laquo;vX&amp;raquo;, но старый интерфейс будет по-прежнему поддерживаться.</target>
        </trans-unit>
        <trans-unit id="a66564cccde706fd2f76931336faa29d5380763d" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="translated">Подробная информация о поведении интерфейса sqlite3_step () зависит от того, было ли подготовлено заявление с использованием более новых интерфейсы &amp;laquo;Vx&amp;raquo; &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; или старше устаревшие интерфейсы &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; и &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; . Для новых приложений рекомендуется использовать новый интерфейс &amp;laquo;vX&amp;raquo;, но старый интерфейс будет по-прежнему поддерживаться.</target>
        </trans-unit>
        <trans-unit id="d328873bfc7a5d2f8f59abeab740350558a37fbf" translate="yes" xml:space="preserve">
          <source>The details of the effects of the analysis limit described in the previous paragraph are subject to change in future versions of SQLite. But the core idea will remain the same. An analysis limit of N will strive to limit the number of rows visited in each index to approximately N.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cfb6e87da2bbb4d38b35a83664b9fdcddd81cb" translate="yes" xml:space="preserve">
          <source>The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice. Unlike most of the SQLite API, this function is not guaranteed to operate consistently from one release to the next.</source>
          <target state="translated">Детали кодов операций,их значения,параметры,которые они принимают,и то,что они делают,могут быть изменены без предварительного уведомления.В отличие от большинства SQLite API,эта функция не гарантированно работает последовательно от одного релиза к другому.</target>
        </trans-unit>
        <trans-unit id="dd71fb5d39136060492d732375a6fec71ebfc8ad" translate="yes" xml:space="preserve">
          <source>The developers are also on the lookout for new ways to optimize the commit mechanism. The current VFS implementations for Unix (Linux and Mac OS X) and Windows make pessimistic assumptions about the behavior of those systems. After consultation with experts on how these systems work, we might be able to relax some of the assumptions on these systems and allow them to run faster. In particular, we suspect that most modern filesystems exhibit the safe append property and that many of them might support atomic sector writes. But until this is known for certain, SQLite will take the conservative approach and assume the worst.</source>
          <target state="translated">Разработчики также находятся в поиске новых способов оптимизации механизма коммитов.Текущие реализации VFS для Unix (Linux и Mac OS X)и Windows делают пессимистические предположения о поведении этих систем.После консультации с экспертами о том,как эти системы работают,мы могли бы ослабить некоторые предположения об этих системах и позволить им работать быстрее.В частности,мы подозреваем,что большинство современных файловых систем обладают свойством безопасного приложения,и что многие из них могут поддерживать атомные записи.Но пока это не станет известно наверняка,SQLite будет придерживаться консервативного подхода и предполагать худшее.</target>
        </trans-unit>
        <trans-unit id="cba4f98976654b480368200cf64e4d7ca1caf336" translate="yes" xml:space="preserve">
          <source>The developers of SQLite are confident that it is robust in the face of power failures and system crashes because the automatic test procedures do extensive checks on the ability of SQLite to recover from simulated power loss. We call these the &quot;crash tests&quot;.</source>
          <target state="translated">Разработчики SQLite уверены,что он устойчив к перебоям в электропитании и сбоям системы,потому что процедуры автоматического тестирования делают обширные проверки способности SQLite восстанавливаться после смоделированных потерь электроэнергии.Мы называем это &quot;краш-тестами&quot;.</target>
        </trans-unit>
        <trans-unit id="57e3f42d8aa639c2f77c64f6029c9126e99e122e" translate="yes" xml:space="preserve">
          <source>The developers of SQLite have found that full coverage testing is an extremely effective method for locating and preventing bugs. Because every single branch instruction in SQLite core code is covered by test cases, the developers can be confident that changes made in one part of the code do not have unintended consequences in other parts of the code. The many new features and performance improvements that have been added to SQLite in recent years would not have been possible without the availability full-coverage testing.</source>
          <target state="translated">Разработчики SQLite обнаружили,что тестирование полного покрытия является чрезвычайно эффективным методом локализации и предотвращения ошибок.Поскольку каждая инструкция в основной части кода SQLite покрывается тестовыми случаями,разработчики могут быть уверены,что изменения,внесенные в одну часть кода,не повлекут за собой непредвиденных последствий в других частях кода.Множество новых возможностей и улучшений производительности,которые были добавлены в SQLite в последние годы,были бы невозможны без полноценного тестирования.</target>
        </trans-unit>
        <trans-unit id="c6e54cb667da50110192519bd611d69d7d2d59cd" translate="yes" xml:space="preserve">
          <source>The developers of SQLite intend to support the product through the year 2050. To this end, the source code is carefully documented to promote long-term maintainability. We prefer mature and stable over trendy and cutting-edge.</source>
          <target state="translated">Разработчики SQLite намерены поддерживать продукт до 2050 года.Для этого исходный код тщательно документируется,чтобы обеспечить долгосрочную поддержку.Мы предпочитаем зрелый и стабильный,а не модный и современный.</target>
        </trans-unit>
        <trans-unit id="aa1c82e2078fb346e28f27499859e5261dd7cb0d" translate="yes" xml:space="preserve">
          <source>The diagram above implies that SQLite computes all of the rowids first and then combines them with a union operation before starting to do rowid lookups on the original table. In reality, the rowid lookups are interspersed with rowid computations. SQLite uses one index at a time to find rowids while remembering which rowids it has seen before so as to avoid duplicates. That is just an implementation detail, though. The diagram, while not 100% accurate, provides a good overview of what is happening.</source>
          <target state="translated">Приведенная выше диаграмма подразумевает,что SQLite сначала вычисляет все rowid'ы,а затем комбинирует их с объединенной операцией,прежде чем начать выполнять поиск rowid'ов в исходной таблице.В действительности,поиск рядков чередуется с вычислениями рядков.SQLite использует по одному индексу за раз,чтобы найти рядки,вспоминая,какие рядки он видел раньше,чтобы избежать дубликатов.Однако это всего лишь деталь реализации.Диаграмма,хотя и не на 100% точна,но дает хороший обзор происходящего.</target>
        </trans-unit>
        <trans-unit id="cc06f8d8201603f348e84ed00b97e2bebb250253" translate="yes" xml:space="preserve">
          <source>The diagram at the right illustrates the concept. One begins with a standard SQLite release. For the sake of example, suppose that one intends to create a private branch off of SQLite version 3.6.15. In the diagram this is version (1). The maintainer makes an exact copy of the baseline SQLite into the branch space, shown as version (2). Note that (1) and (2) are exactly the same. Then the maintainer applies the private changes to version (2) resulting in version (3). In other words, version (3) is SQLite version 3.6.15 plus edits.</source>
          <target state="translated">Диаграмма справа иллюстрирует концепцию.Начинается со стандартного релиза SQLite.Для примера предположим,что планируется создать частную ветку от SQLite версии 3.6.15.На диаграмме это версия (1).Сопровождающий делает точную копию базовой ветки SQLite в пространство ветки,показанное как версия (2).Обратите внимание,что (1)и (2)точно совпадают.Затем мейнтейнер применяет частные изменения к версии (2),в результате чего получается версия (3).Другими словами,версия (3)-это версия SQLite 3.6.15 плюс изменения.</target>
        </trans-unit>
        <trans-unit id="7b170d383461e4dd7d9f55e0934f811bdf7d240b" translate="yes" xml:space="preserve">
          <source>The difference between reading from the rank column and using the bm25() function directly within the query is only significant when sorting by the returned value. In this case, using &quot;rank&quot; is faster than using bm25().</source>
          <target state="translated">Разница между чтением из столбца ранга и использованием функции bm25()непосредственно внутри запроса значима только при сортировке по возвращаемому значению.В этом случае использование &quot;rank&quot; происходит быстрее,чем использование bm25().</target>
        </trans-unit>
        <trans-unit id="9a6b573084b906296ca61d103b50efb82fd91899" translate="yes" xml:space="preserve">
          <source>The difference between this option and the 'automerge' option is that when the 'automerge' limit is reached FTS5 only begins to merge the b-trees together. Most of the work is performed as part of subsequent INSERT, UPDATE or DELETE operations. Whereas when the 'crisismerge' limit is reached, the offending b-trees are all merged immediately. This means that an INSERT, UPDATE or DELETE that triggers a crisis-merge may take a long time to complete.</source>
          <target state="translated">Разница между этой опцией и опцией 'automerge' заключается в том,что при достижении лимита 'automerge' FTS5 начинает только слияние b-деревьев.Большая часть работы выполняется в рамках последующих операций INSERT,UPDATE или DELETE.В то время как при достижении лимита &quot;кризисного погружения&quot;,нарушившие лимит b-деревья немедленно сливаются.Это означает,что выполнение операций INSERT,UPDATE или DELETE,вызывающих кризисное погружение,может занять много времени.</target>
        </trans-unit>
        <trans-unit id="6b73e10a6ce3d527b6333ec3f4b76095553830b9" translate="yes" xml:space="preserve">
          <source>The difference is that xConnect is called to establish a new connection to an existing virtual table whereas xCreate is called to create a new virtual table from scratch.</source>
          <target state="translated">Разница заключается в том,что xConnect вызывается для создания нового соединения с существующей виртуальной таблицей,в то время как xCreate вызывается для создания новой виртуальной таблицы с нуля.</target>
        </trans-unit>
        <trans-unit id="2f41e80a4cb41a6cee44f4eaec98226e9c29f84f" translate="yes" xml:space="preserve">
          <source>The differences between a patchset and a changeset are that:</source>
          <target state="translated">Различия между патчсетами и пейджетами заключаются в следующем:</target>
        </trans-unit>
        <trans-unit id="4fa2acc79952a3a20f72fc7c3e0f092b1e96e820" translate="yes" xml:space="preserve">
          <source>The differences between an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; database and an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; database is this: The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; is used for explicitly declared and named TEMP tables (using the CREATE TEMP TABLE syntax) or for named tables in a temporary database that is created by opening a database with a filename that is an empty string. An &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; holds a database table that SQLite creates automatically in order to evaluate a subquery or ORDER BY or GROUP BY clause. Both TEMP_DB and TRANSIENT_DB databases are private and are deleted automatically. TEMP_DB databases last for the duration of the database connection. TRANSIENT_DB databases last only for the duration of a single SQL statement.</source>
          <target state="translated">Различия между &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;базой&lt;/a&gt; данных SQLITE_OPEN_TEMP_DB и &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;базой&lt;/a&gt; данных SQLITE_OPEN_TRANSIENT_DB заключаются в следующем: &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; используется для явно объявленных и именованных таблиц TEMP (с использованием синтаксиса CREATE TEMP TABLE) или для именованных таблиц во временной базе данных, которая создается путем открытия базы данных с именем файла это пустая строка. &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; держит таблицу базы данных, SQLite автоматически создает для того , чтобы оценить подзапрос или ORDER BY или GROUP BY предложения. Обе базы данных TEMP_DB и TRANSIENT_DB являются частными и удаляются автоматически. Базы данных TEMP_DB существуют на время соединения с базой данных. Базы данных TRANSIENT_DB существуют только в течение одного оператора SQL.</target>
        </trans-unit>
        <trans-unit id="ea188c1a8a3d9f0d3afac3d8adfd72df27cd7aa2" translate="yes" xml:space="preserve">
          <source>The direct-to-disk writes are accomplished using fopen()/fwrite()/fclose(). By default, and in all the results shown below, the OS filesystem buffers are never flushed to persistent storage using fsync() or FlushFileBuffers(). In other words, there is no attempt to make the direct-to-disk writes transactional or power-safe. We found that invoking fsync() or FlushFileBuffers() on each file written causes direct-to-disk storage to be about 10 times or more slower than writes to SQLite.</source>
          <target state="translated">Прямая запись на диск выполняется с помощью функции fopen()/fwrite()/fclose().По умолчанию,и во всех результатах,показанных ниже,буферы файловой системы никогда не смываются в постоянное хранилище с помощью fsync()или FlushFileBuffers().Другими словами,нет никаких попыток сделать прямую запись на диск транзакционной или энергобезопасной.Мы обнаружили,что обращение к функциям fsync()или FlushFileBuffers()для каждого записываемого файла приводит к тому,что запись на диск происходит примерно в 10 и более раз медленнее,чем запись на SQLite.</target>
        </trans-unit>
        <trans-unit id="480bdad0842ce92215a602c8e8a2e2ba5036d89a" translate="yes" xml:space="preserve">
          <source>The directory or folder in which temporary files are created is determined by the OS-specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Каталог или папка, в которых создаются временные файлы, определяется &lt;a href=&quot;vfs&quot;&gt;VFS для&lt;/a&gt; конкретной ОС .</target>
        </trans-unit>
        <trans-unit id="58c1fd9cf0b8fae2622f0a1831b48a0d95eaabc6" translate="yes" xml:space="preserve">
          <source>The directory set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">Каталог, установленный &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; или глобальной переменной &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e347995ace178c5b68534f7a6dde94c35392830" translate="yes" xml:space="preserve">
          <source>The directory used to hold temporary files on unix can now be set using the SQLITE_TMPDIR environment variable, which takes precedence over the TMPDIR environment variable. The &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable still has higher precedence than both environment variables, however.</source>
          <target state="translated">Каталог, используемый для хранения временных файлов в unix, теперь может быть установлен с помощью переменной среды SQLITE_TMPDIR, которая имеет приоритет над переменной среды TMPDIR. Однако глобальная переменная &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory по-&lt;/a&gt; прежнему имеет более высокий приоритет, чем обе переменные среды.</target>
        </trans-unit>
        <trans-unit id="081d4a11583041f4e8625a8cc56c88ce7150faa6" translate="yes" xml:space="preserve">
          <source>The docid value. The first entry in a doclist contains the literal docid value. The first field of each subsequent doclist entry contains the difference between the new docid and the previous one (always a positive number).</source>
          <target state="translated">Докидное значение.Первая запись в доклисте содержит буквальное значение докида.Первое поле каждой последующей записи в доклисте содержит разницу между новым и предыдущим докидом (всегда положительное число).</target>
        </trans-unit>
        <trans-unit id="49e2bf067b92acf951896b04368654ffcd3a3f99" translate="yes" xml:space="preserve">
          <source>The document only describes locking for the older rollback-mode transaction mechanism. Locking for the newer &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is described separately.</source>
          <target state="translated">В документе описывается блокировка только для более старого механизма транзакций в режиме отката. Блокировка для нового &lt;a href=&quot;wal&quot;&gt;журнала упреждающей записи&lt;/a&gt; или &lt;a href=&quot;wal&quot;&gt;режима WAL&lt;/a&gt; описывается отдельно.</target>
        </trans-unit>
        <trans-unit id="1297878fc527d5d7c17142be2f4f043e484d8aa6" translate="yes" xml:space="preserve">
          <source>The documentation is maintained in separate source repositories on those same servers:</source>
          <target state="translated">Документация хранится в отдельных репозиториях на тех же серверах:</target>
        </trans-unit>
        <trans-unit id="d0017ab9193a6ed1029ad59fab58ce3ec88e592f" translate="yes" xml:space="preserve">
          <source>The documentation sources include documentation text and images with the scripts and makefile needed to construct the SQLite website documentation. This document is contained within the documentation sources. The document sources are kept in a separate repository distinct from the source code. The documentation sources repository is publicly readable.</source>
          <target state="translated">Источниками документации являются текст документации и изображения со скриптами и makefile,необходимые для создания документации сайта SQLite.Этот документ содержится в источниках документации.Исходные тексты документов хранятся в отдельном репозитории,отличном от исходного кода.Репозиторий источников документации является общедоступным для чтения.</target>
        </trans-unit>
        <trans-unit id="278f1b137f0865ba684c7cde1fa14cf1c768e813" translate="yes" xml:space="preserve">
          <source>The documentation system automatically maintains a &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; of past releases, as well as a &lt;a href=&quot;changes&quot;&gt;complete list of SQLite releases&lt;/a&gt; with change summaries.</source>
          <target state="translated">Система документации автоматически ведет &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;хронологию&lt;/a&gt; прошлых выпусков, а также &lt;a href=&quot;changes&quot;&gt;полный список выпусков SQLite&lt;/a&gt; с описанием изменений.</target>
        </trans-unit>
        <trans-unit id="65988e654b808af94ee6da6f09345ac1241a1ac8" translate="yes" xml:space="preserve">
          <source>The dot-command must be entirely contained on a single input line.</source>
          <target state="translated">Точка-команда должна полностью содержаться в одной строке ввода.</target>
        </trans-unit>
        <trans-unit id="6fcffd0a57b5ba6715e1715a67438a136bebf610" translate="yes" xml:space="preserve">
          <source>The dot-commands are interpreted by the sqlite3.exe command-line program, not by SQLite itself. So none of the dot-commands will work as an argument to SQLite interfaces like &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;.</source>
          <target state="translated">Точечные команды интерпретируются программой командной строки sqlite3.exe, а не самим SQLite. Таким образом, ни одна из точечных команд не будет работать в качестве аргумента для интерфейсов SQLite, таких как &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73b101a4a2aed2c88c1089ef5e27eb7bd916289f" translate="yes" xml:space="preserve">
          <source>The downside of automatic incremental merging is that it makes every INSERT, UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra time must be used to do the incremental merge. For maximum performance, it is recommended that applications disable automatic incremental merge and instead use the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&quot;merge&quot; command&lt;/a&gt; in an idle process to keep the inverted indices well merged. But if the structure of an application does not easily allow for idle processes, the use of automatic incremental merge is a very reasonable fallback solution.</source>
          <target state="translated">Обратной стороной автоматического добавочного слияния является то, что при нем каждая операция INSERT, UPDATE и DELETE в таблице FTS3 / 4 выполняется немного медленнее, поскольку для выполнения добавочного слияния требуется дополнительное время. Для максимальной производительности рекомендуется, чтобы приложения отключили автоматическое добавочное слияние и вместо этого использовали команду &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&amp;laquo;слияние&amp;raquo;&lt;/a&gt; в процессе ожидания, чтобы обеспечить хорошее слияние инвертированных индексов. Но если структура приложения не позволяет легко простаивать процессы, использование автоматического добавочного слияния является очень разумным резервным решением.</target>
        </trans-unit>
        <trans-unit id="c77ebced48dfa7e23a77c44a167057f7558d4f17" translate="yes" xml:space="preserve">
          <source>The downside of storing schema a text is that it can make the schema tricky to modify. And for that reason, the ALTER TABLE support in SQLite has traditionally lagged behind other SQL database engines that store their schemas as parsed system tables that are easier to modify.</source>
          <target state="translated">Недостатком хранения схемы в тексте является то,что это может сделать схему хитрой для изменения.И по этой причине поддержка ALTER TABLE в SQLite традиционно отстает от других движков БД SQL,которые хранят свои схемы в виде разобранных системных таблиц,которые легче модифицировать.</target>
        </trans-unit>
        <trans-unit id="1bd6a18e90f1a8ee8256e02fe4825c2a58f166f7" translate="yes" xml:space="preserve">
          <source>The dynamic webpages on the SQLite website are mostly generated by the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. A typical dynamic page would be a timeline such as &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt;. A log of all SQL used by the timeline is shown below.</source>
          <target state="translated">Динамические веб-страницы на веб-сайте SQLite в основном создаются &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;системой контроля версий Fossil&lt;/a&gt; . Типичная динамическая страница - это временная шкала, например &lt;a href=&quot;https://www.sqlite.org/src/timeline&quot;&gt;https://www.sqlite.org/src/timeline&lt;/a&gt; . Журнал всего SQL, используемого временной шкалой, показан ниже.</target>
        </trans-unit>
        <trans-unit id="f53c608dfb99715244babeb0f18e6bedb4ce61c6" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">Аргумент eTextRep определяет кодировку строк, передаваемых в функцию обратного вызова функции сортировки, xCallback. Значения &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; и &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; для eTextRep заставляют строки быть UTF16 с собственным порядком байтов. Значение &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; для eTextRep заставляет строки начинаться с четного байтового адреса.</target>
        </trans-unit>
        <trans-unit id="1f8a73896c29d2961fd12e3fd13060416db06dbd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCallback. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="translated">Аргумент eTextRep определяет кодировку строк, передаваемых в функцию обратного вызова функции сортировки, xCallback. Значения &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; и &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; для eTextRep заставляют строки быть UTF16 с собственным порядком байтов. Значение &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; для eTextRep заставляет строки начинаться с четного байтового адреса.</target>
        </trans-unit>
        <trans-unit id="4013154ef9b1afc10a2efd1408a9638085e650fc" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7222f354f082d59aa96eba0376b7b091cc4ec0bd" translate="yes" xml:space="preserve">
          <source>The eTextRep argument determines the encoding of strings passed to the collating function callback, xCompare. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; and &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; values for eTextRep force strings to be UTF16 with native byte order. The &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16_ALIGNED&lt;/a&gt; value for eTextRep forces strings to begin on an even byte address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af71ae840c72707272be3031b3c3ee6f45c5d71f" translate="yes" xml:space="preserve">
          <source>The edit distance coefficients are normally read from the APPCOST table once and there after stored in memory. Hence, run-time changes to the APPCOST table will not normally affect the edit distance results. However, inserting the special string 'reset' into the &quot;command&quot; column of the virtual table causes the edit distance coefficients to be reread the APPCOST table. Hence, applications should run a SQL statement similar to the following when changes to the APPCOST table occur:</source>
          <target state="translated">Коэффициенты расстояния редактирования обычно считываются из таблицы APPCOST один раз и туда после сохранения в памяти.Следовательно,изменения во времени выполнения APPCOST таблицы обычно не влияют на результаты расстояния редактирования.Однако,вставка специальной строки &quot;сброс&quot; в столбец &quot;команда&quot; виртуальной таблицы приводит к тому,что коэффициенты расстояния редактирования будут перечитываться из таблицы APPCOST.Следовательно,при изменении таблицы APPCOST приложения должны запускать SQL-оператор,аналогичный приведённому ниже:</target>
        </trans-unit>
        <trans-unit id="49994af0743488763f79d75d2c9c86ebfda2dfb6" translate="yes" xml:space="preserve">
          <source>The edit program can also be used as a viewer, by simply ignoring the return value. For example, to merely look at the image above, you might run:</source>
          <target state="translated">Программа редактирования также может быть использована в качестве программы просмотра,просто игнорируя возвращаемое значение.Например,чтобы просто посмотреть на изображение выше,можно запустить программу:</target>
        </trans-unit>
        <trans-unit id="47a4a763ba31495e47240c644f7558e9498bae30" translate="yes" xml:space="preserve">
          <source>The edit() function can be used to make changes to large text values. For example:</source>
          <target state="translated">Функция edit()может быть использована для внесения изменений в большие текстовые значения.Например:</target>
        </trans-unit>
        <trans-unit id="fd34f0d751c4ddc69b221f64ffd45f8927b66781" translate="yes" xml:space="preserve">
          <source>The editdist3 algorithm is a function that computes the minimum edit distance (a.k.a. the Levenshtein distance) between two input strings. The editdist3 algorithm is a configurable alternative to the default edit distance function of spellfix1. Features of editdist3 include:</source>
          <target state="translated">Алгоритм editdist3-это функция,которая вычисляет минимальное расстояние редактирования (также известное как расстояние Левенштейна)между двумя входными строками.Алгоритм editdist3 является настраиваемой альтернативой стандартной функции расстояния редактирования орфографической ошибки1.К особенностям editdist3 относятся:</target>
        </trans-unit>
        <trans-unit id="870b1bf5bd7c0178ecc9a04d5313cc57bc40b4f1" translate="yes" xml:space="preserve">
          <source>The effects of a &lt;b&gt;truncate file&lt;/b&gt; operation are not assumed to be made persistent until after the corresponding file has been</source>
          <target state="translated">Предполагается, что эффекты операции с &lt;b&gt;файлом усечения&lt;/b&gt; не будут сохраняться до тех пор, пока не будет выполнен соответствующий файл.</target>
        </trans-unit>
        <trans-unit id="393d1077fa976da06b2c81028e0e667751bfce07" translate="yes" xml:space="preserve">
          <source>The empty-result-callbacks flag affects the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API only. Normally, when the empty-result-callbacks flag is cleared, the callback function supplied to the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is not invoked for commands that return zero rows of data. When empty-result-callbacks is set in this situation, the callback function is invoked exactly once, with the third parameter set to 0 (NULL). This is to enable programs that use the &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; API to retrieve column-names even when a query returns no data.</source>
          <target state="translated">Флаг empty-result-callbacks влияет только на API &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; . Обычно, когда флаг empty-result-callbacks сброшен, функция обратного вызова, предоставленная &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , не вызывается для команд, возвращающих нулевые строки данных. Когда в этой ситуации заданы обратные вызовы с пустым результатом, функция обратного вызова вызывается ровно один раз, с третьим параметром, установленным в 0 (NULL). Это позволяет программам, использующим API &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec (),&lt;/a&gt; получать имена столбцов, даже если запрос не возвращает данных.</target>
        </trans-unit>
        <trans-unit id="f1a25180fc453bfc9b7157e5b028aa8235fc10f5" translate="yes" xml:space="preserve">
          <source>The end-user executes DML or DDL SQL statements that require the structure of the database file of the database file to be modified. These modifications may be any combination of operations to</source>
          <target state="translated">Конечный пользователь выполняет операторы DML или DDL SQL,которые требуют изменения структуры файла базы данных.Эти изменения могут быть любой комбинацией операций</target>
        </trans-unit>
        <trans-unit id="5b923462226ca9a3f1ea2da34aa276431384d659" translate="yes" xml:space="preserve">
          <source>The ending frame boundary can be omitted (if the BETWEEN and AND keywords that surround the starting frame boundary are also omitted), in which case the ending frame boundary defaults to CURRENT ROW.</source>
          <target state="translated">Граница конечного кадра может быть опущена (если опущены также ключевые слова BETWEEN и AND,окружающие границу начального кадра),в этом случае граница конечного кадра по умолчанию устанавливается в CURRENT ROW.</target>
        </trans-unit>
        <trans-unit id="b26c1d5670afb707a661dd133bd85c139805e555" translate="yes" xml:space="preserve">
          <source>The ending frame boundary may not take a form that appears higher in the above list than the starting frame boundary.</source>
          <target state="translated">Граница заканчивающейся рамки не может иметь форму,которая появляется выше в списке выше,чем граница стартовой рамки.</target>
        </trans-unit>
        <trans-unit id="1133a1a20cf9f9901ca7376082c18ed0b6c4a36d" translate="yes" xml:space="preserve">
          <source>The engine no longer consults the main table if it can get all the information it needs from an index.</source>
          <target state="translated">Двигатель больше не консультируется с основной таблицей,если он может получить всю необходимую информацию из индекса.</target>
        </trans-unit>
        <trans-unit id="b873e4983f185f34587580faeee301ccc43a5a88" translate="yes" xml:space="preserve">
          <source>The enhanced query syntax supports the AND, OR and NOT binary set operators. Each of the two operands to an operator may be a basic FTS query, or the result of another AND, OR or NOT set operation. Operators must be entered using capital letters. Otherwise, they are interpreted as basic term queries instead of set operators.</source>
          <target state="translated">Расширенный синтаксис запросов поддерживает операторы AND,OR и NOT двоичного множества.Каждый из двух операндов к оператору может быть основным запросом FTS или результатом другой операции задания AND,OR или NOT.Операторы должны вводиться с использованием заглавных букв.В противном случае они интерпретируются как основные запросы терминов,а не как заданные операторы.</target>
        </trans-unit>
        <trans-unit id="ec0a2d5aa63b2e3b719340bb237dcfc9aebe4443" translate="yes" xml:space="preserve">
          <source>The entries above might represent (for example) a bounding box around the main office for SQLite.org and bounding box around the 12th Congressional District of North Carolina (prior to the 2011 redistricting) in which SQLite.org was located.</source>
          <target state="translated">Приведенные выше записи могут представлять собой (например)граничное поле вокруг главного офиса для SQLite.org и граничное поле вокруг 12-го округа Конгресса Северной Каролины (до перекрёстка 2011 года),в котором находился SQLite.org.</target>
        </trans-unit>
        <trans-unit id="df23c9e0d03ef84c1b3ecc39ad637f8b14bf70ea" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Точка входа - zProc. zProc может иметь значение 0, и в этом случае SQLite попытается самостоятельно указать имя точки входа. Сначала он пробует sqlite3_extension_init. Если это не сработает, создается имя &amp;laquo;sqlite3_X_init&amp;raquo;, где X состоит из строчных эквивалентов всех буквенных символов ASCII в имени файла от последнего &amp;laquo;/&amp;raquo; до первого следующего &amp;laquo;&amp;raquo;. и опуская любую начальную &quot;lib&quot;. Интерфейс sqlite3_load_extension () возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если что-то пойдет не так. Если возникает ошибка и pzErrMsg не равно 0, то интерфейс &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; должен попытаться заполнить * pzErrMsg текстом сообщения об ошибке, хранящимся в памяти, полученным из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt;. Вызывающая функция должна освободить эту память, вызвав &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2e7b718e4064a2f8cc8acbe7a051458f014ce0" translate="yes" xml:space="preserve">
          <source>The entry point is zProc. zProc may be 0, in which case SQLite will try to come up with an entry point name on its own. It first tries &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a name &quot;sqlite3_X_init&quot; where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last &quot;/&quot; to the first following &quot;.&quot; and omitting any initial &quot;lib&quot;. The sqlite3_load_extension() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if something goes wrong. If an error occurs and pzErrMsg is not 0, then the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The calling function should free this memory by calling &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">Точка входа - zProc. zProc может иметь значение 0, и в этом случае SQLite попытается самостоятельно указать имя точки входа. Сначала он пробует sqlite3_extension_init. Если это не сработает, создается имя &amp;laquo;sqlite3_X_init&amp;raquo;, где X состоит из строчных эквивалентов всех буквенных символов ASCII в имени файла от последнего &amp;laquo;/&amp;raquo; до первого следующего &amp;laquo;&amp;raquo;. и опуская любую начальную &quot;lib&quot;. Интерфейс sqlite3_load_extension () возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха и &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если что-то пойдет не так. Если возникает ошибка и pzErrMsg не равно 0, то интерфейс &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; должен попытаться заполнить * pzErrMsg текстом сообщения об ошибке, хранящимся в памяти, полученным из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt;. Вызывающая функция должна освободить эту память, вызвав &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40007c6bf4af7619580a2e5c3ec81a4fee4ad813" translate="yes" xml:space="preserve">
          <source>The error code is changed to &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;) when an attempt is made to &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; while one or more queries are still pending.</source>
          <target state="translated">Код ошибки изменяется на &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; (вместо &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; ), когда делается попытка &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK,&lt;/a&gt; когда один или несколько запросов все еще ожидают обработки.</target>
        </trans-unit>
        <trans-unit id="2e60aa60ea376ea9ca807c8cc7d0b0b91ec054e5" translate="yes" xml:space="preserve">
          <source>The error codes for SQLite version 3 are unchanged from version 2. They are as follows:</source>
          <target state="translated">Коды ошибок для SQLite версии 3 не изменились по сравнению с версией 2.Они выглядят следующим образом:</target>
        </trans-unit>
        <trans-unit id="2ccece93e5a00d5f5d9d7a6919183b3a66f82129" translate="yes" xml:space="preserve">
          <source>The error logger callback function might look something like this:</source>
          <target state="translated">Функция обратного вызова регистратора ошибок может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="8ad007677ae545b2ad036dc3fbfd526afb2a9647" translate="yes" xml:space="preserve">
          <source>The error logger callback should be treated like a signal handler. The application should save off or otherwise process the error, then return as soon as possible. No other SQLite APIs should be invoked, directly or indirectly, from the error logger. SQLite is &lt;u&gt;not&lt;/u&gt; reentrant through the error logger callback. In particular, the error logger callback is invoked when a memory allocation fails, so it is generally a bad idea to try to allocate memory inside the error logger. Do not even think about trying to store the error message in another SQLite database.</source>
          <target state="translated">Обратный вызов регистратора ошибок следует рассматривать как обработчик сигнала. Приложение должно сохранить или иным образом обработать ошибку, а затем вернуться как можно скорее. Никакие другие API SQLite не должны вызываться прямо или косвенно из регистратора ошибок. SQLite &lt;u&gt;не&lt;/u&gt; поддерживает повторный вход через обратный вызов регистратора ошибок. В частности, обратный вызов регистратора ошибок вызывается при сбое выделения памяти, поэтому, как правило, попытки выделить память внутри регистратора ошибок - плохая идея. Даже не думайте о попытке сохранить сообщение об ошибке в другой базе данных SQLite.</target>
        </trans-unit>
        <trans-unit id="931b7a49e1d266b8f7af8c59c48646cf4fc9a825" translate="yes" xml:space="preserve">
          <source>The error messages that might be sent to the error logger and their exact format is subject to changes from one release to the next. So applications should not depend on any particular error message text formats or error codes. Things do not change capriciously, but they do sometimes changes.</source>
          <target state="translated">Сообщения об ошибках,которые могут быть отправлены в регистратор ошибок,и их точный формат могут изменяться от одного выпуска к другому.Поэтому приложения не должны зависеть от конкретных форматов текстовых сообщений об ошибках или кодов ошибок.Вещи не меняются капризно,но иногда меняются.</target>
        </trans-unit>
        <trans-unit id="6f0f73d0eed4daf2fa7ce504b606f01da04260dc" translate="yes" xml:space="preserve">
          <source>The estimatedCost field should be set to the estimated number of disk access operations required to execute this query against the virtual table. The SQLite core will often call xBestIndex multiple times with different constraints, obtain multiple cost estimates, then choose the query plan that gives the lowest estimate. The SQLite core initializes estimatedCost to a very large value prior to invoking xBestIndex, so if xBestIndex determines that the current combination of parameters is undesirable, it can leave the estimatedCost field unchanged to discourage its use.</source>
          <target state="translated">Поле estimatedCost должно быть установлено в соответствие с предполагаемым количеством операций доступа к диску,необходимых для выполнения этого запроса к виртуальной таблице.Ядро SQLite часто вызывает xBestIndex несколько раз с различными ограничениями,получает несколько оценок стоимости,затем выбирает план запроса,который дает самую низкую оценку.Ядро SQLite инициализирует estimatedCost до очень большого значения перед вызовом xBestIndex,поэтому,если xBestIndex определит,что текущая комбинация параметров является нежелательной,он может оставить поле estimatedCost без изменений,чтобы предотвратить его использование.</target>
        </trans-unit>
        <trans-unit id="9110d26065cfada658af48dd22a731f2e42c4634" translate="yes" xml:space="preserve">
          <source>The estimatedCost value is an estimate of the cost of a particular strategy. A cost of N indicates that the cost of the strategy is similar to a linear scan of an SQLite table with N rows. A cost of log(N) indicates that the expense of the operation is similar to that of a binary search on a unique indexed field of an SQLite table with N rows.</source>
          <target state="translated">Оценочная стоимость представляет собой оценку стоимости конкретной стратегии.Стоимость N указывает на то,что стоимость стратегии аналогична линейному сканированию таблицы SQLite с N строками.Стоимость журнала(N)указывает на то,что стоимость операции аналогична стоимости двоичного поиска по уникальному индексированному полю таблицы SQLite с N строками.</target>
        </trans-unit>
        <trans-unit id="a1d11ebb28b1bb46c038273ece9416f81d29642b" translate="yes" xml:space="preserve">
          <source>The estimatedRows value is an estimate of the number of rows that will be returned by the strategy.</source>
          <target state="translated">Значение estimateRows является оценкой количества строк,которые будут возвращены стратегией.</target>
        </trans-unit>
        <trans-unit id="6e98b869e8e492045895b07f0da4a451a3b65571" translate="yes" xml:space="preserve">
          <source>The exact logic used to determine if a</source>
          <target state="translated">Точная логика,используемая для определения</target>
        </trans-unit>
        <trans-unit id="c7341ca7ddb26c5a501b148a51edcbd920ab7841" translate="yes" xml:space="preserve">
          <source>The exact same source code can be used for both a run-time loadable shared library or DLL and as a module that is statically linked with your application. This provides flexibility and allows you to reuse the same code in different ways.</source>
          <target state="translated">Точно такой же исходный код может быть использован как для загружаемой во время выполнения разделяемой библиотеки или DLL,так и в качестве модуля,статически связанного с вашим приложением.Это обеспечивает гибкость и позволяет повторно использовать один и тот же код различными способами.</target>
        </trans-unit>
        <trans-unit id="51d3ce62c3eb93876d401465d70f8ba808604db2" translate="yes" xml:space="preserve">
          <source>The example above causes the database file named &quot;ex1.db&quot; to be opened and used. The &quot;ex1.db&quot; file is created if it does not previously exist. You might want to use a full pathname to ensure that the file is in the directory that you think it is in. Use forward-slashes as the directory separator character. In other words use &quot;c:/work/ex1.db&quot;, not &quot;c:\work\ex1.db&quot;.</source>
          <target state="translated">В приведенном выше примере открывается и используется файл БД с именем &quot;ex1.db&quot;.Файл &quot;ex1.db&quot; создается,если он ранее не существовал.Возможно,вы захотите использовать полное имя,чтобы убедиться,что файл находится в каталоге,в котором,как вы думаете,он находится.Используйте прямые косые черты в качестве символа разделителя каталогов.Другими словами,используйте &quot;c:/work/ex1.db&quot;,а не &quot;c:\work\ex1.db&quot;.</target>
        </trans-unit>
        <trans-unit id="97b14b6298ce84315e618c11d7722d98fb92421a" translate="yes" xml:space="preserve">
          <source>The example above contains two &quot;SCALAR&quot; subqueries. The subqueries are SCALAR in the sense that they return a single value - a one-row, one-column table. If the actual query returns more than that, then only the first column of the first row is used.</source>
          <target state="translated">Пример выше содержит два подзапроса &quot;SCALAR&quot;.Подзапросы являются SCALAR-ами в том смысле,что они возвращают одно значение-однострочную таблицу с одной колонкой.Если фактический запрос возвращает больше,то используется только первый столбец первой строки.</target>
        </trans-unit>
        <trans-unit id="d7a7c3999051bd06566a95bdd9bc9de8e3e4adaa" translate="yes" xml:space="preserve">
          <source>The example above illustrates the signature of the error logger callback. However, in an embedded application, one usually does not print messages on stderr. Instead, one might store the messages in a preallocated circular buffer where they can be accessed when diagnostic information is needed during debugging. Or perhaps the messages can be sent to &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;Syslog&lt;/a&gt;. Somehow, the messages need to be stored where they are accessible to developers, not displayed to end users.</source>
          <target state="translated">В приведенном выше примере показана подпись обратного вызова регистратора ошибок. Однако во встроенном приложении сообщения на stderr обычно не выводятся. Вместо этого можно сохранить сообщения в заранее выделенном кольцевом буфере, где к ним можно будет получить доступ, когда во время отладки потребуется диагностическая информация. Или, возможно, сообщения можно отправлять в &lt;a href=&quot;http://en.wikipedia.org/wiki/Syslog&quot;&gt;системный журнал&lt;/a&gt; . Каким-то образом сообщения необходимо хранить там, где они доступны разработчикам, а не показывать конечным пользователям.</target>
        </trans-unit>
        <trans-unit id="d307547a7cd9c2e8e0dc86cacf98f3de8afb55c2" translate="yes" xml:space="preserve">
          <source>The example above showed a single &lt;b&gt;filename='thefile.csv'&lt;/b&gt; argument for the CSV virtual table. But other arguments are also possible.</source>
          <target state="translated">В приведенном выше примере показан единственный аргумент &lt;b&gt;filename = 'thefile.csv'&lt;/b&gt; для виртуальной таблицы CSV. Но возможны и другие аргументы.</target>
        </trans-unit>
        <trans-unit id="11a05b76af4570008579a529531a96eb802e047d" translate="yes" xml:space="preserve">
          <source>The example above shows SQLite picking full-table scan will visit all rows in the table. If the query were able to use an index, then the SCAN/SEARCH record would include the name of the index and, for a SEARCH record, an indication of how the subset of rows visited is identified. For example:</source>
          <target state="translated">Приведенный выше пример показывает,что при выборе SQLite полноэкранного сканирования будут посещены все строки таблицы.Если бы запрос мог использовать индекс,то SCAN/SEARCH-запись включала бы имя индекса,а для SEARCH-записи-указание на то,как идентифицируется подмножество посещенных строк.Например:</target>
        </trans-unit>
        <trans-unit id="abd381887f2ea42f76bfd9ebc8b17425d16e2957" translate="yes" xml:space="preserve">
          <source>The example below uses ntile() to divide the six rows into two groups (the ntile(2) call) and into four groups (the ntile(4) call). For ntile(2), there are three rows assigned to each group. For ntile(4), there are two groups of two and two groups of one. The larger groups of two appear first.</source>
          <target state="translated">В приведенном ниже примере используется функция ntile()для разделения шести строк на две группы (вызов ntile(2))и четыре группы (вызов ntile(4)).Для ntile(2)каждой группе назначено по три строки.Для петли(4)имеется две группы по две и две группы по одной.Сначала появляются две большие группы.</target>
        </trans-unit>
        <trans-unit id="c8ad72613a1253e10b2aeefbfa091cedb3448e07" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the steps involved in capturing a changeset while executing SQL commands. In summary:</source>
          <target state="translated">Приведенный ниже пример кода демонстрирует шаги,связанные с захватом changeset при выполнении SQL-команд.Подводя итог:</target>
        </trans-unit>
        <trans-unit id="cfda7c494f05312b3bf7826ec92aff6df2e44b46" translate="yes" xml:space="preserve">
          <source>The example code below demonstrates the techniques used to iterate through and extract the data related to all changes in a changeset. To summarize:</source>
          <target state="translated">Приведенный ниже пример кода демонстрирует методы,используемые для итерации и извлечения данных,связанных со всеми изменениями в changeset.Подводя итог:</target>
        </trans-unit>
        <trans-unit id="5dde8802fcba008ca09e765d610fcb4f5bf326ca" translate="yes" xml:space="preserve">
          <source>The example code below uses the second of the methods enumerated above - it monitors for changes on all database tables.</source>
          <target state="translated">Приведенный ниже пример кода использует второй из перечисленных выше методов-он отслеживает изменения на всех таблицах БД.</target>
        </trans-unit>
        <trans-unit id="3f036ecd22d9629ed467ac2dbb67b517f12166ad" translate="yes" xml:space="preserve">
          <source>The examples above all use basic full-text term queries as both operands of the set operations demonstrated. Phrase and NEAR queries may also be used, as may the results of other set operations. When more than one set operation is present in an FTS query, the precedence of operators is as follows:</source>
          <target state="translated">В приведенных выше примерах в качестве обоих продемонстрированных операндов множества операций используются базовые полнотекстовые запросы терминов.Могут также использоваться фразовые и NEAR-запросы,а также результаты других операций множества.Когда в запросе ПВТ присутствует несколько множественных операций,приоритет операторов следующий:</target>
        </trans-unit>
        <trans-unit id="1921013ee1678e9933f635ab4c9457e39025bfc3" translate="yes" xml:space="preserve">
          <source>The examples below identify the collating sequences that would be used to determine the results of text comparisons that may be performed by various SQL statements. Note that a text comparison may not be required, and no collating sequence used, in the case of numeric, blob or NULL values.</source>
          <target state="translated">В приведенных ниже примерах определены последовательности сопоставления,которые будут использоваться для определения результатов сопоставления текста,которые могут быть выполнены различными SQL-операторами.Обратите внимание,что текстовое сравнение может не потребоваться,а в случае числовых,блочных или NULL-значений коллекционная последовательность не используется.</target>
        </trans-unit>
        <trans-unit id="367a92feb39a9287f4306f6946c319f7064a8b02" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume that the database is populated as follows:</source>
          <target state="translated">Все примеры в этом разделе предполагают,что БД заполнена следующим образом:</target>
        </trans-unit>
        <trans-unit id="c2bd8a896b6e33422d64448169403c1bc373cf0d" translate="yes" xml:space="preserve">
          <source>The examples in this section all assume the following data:</source>
          <target state="translated">Все примеры в этом разделе предполагают следующие данные:</target>
        </trans-unit>
        <trans-unit id="4d8c3a17bac2c4be1cb9b2d64248454f5513cff9" translate="yes" xml:space="preserve">
          <source>The exception mentioned above is that if the declaration of a column with declared type &quot;INTEGER&quot; includes an &quot;PRIMARY KEY DESC&quot; clause, it does not become an alias for the rowid and is not classified as an integer primary key. This quirk is not by design. It is due to a bug in early versions of SQLite. But fixing the bug could result in backwards incompatibilities. Hence, the original behavior has been retained (and documented) because odd behavior in a corner case is far better than a compatibility break. This means that the following three table declarations all cause the column &quot;x&quot; to be an alias for the rowid (an integer primary key):</source>
          <target state="translated">Исключение,упомянутое выше,состоит в том,что если объявление столбца с объявленным типом &quot;INTEGER&quot; включает в себя выражение &quot;PRIMARY KEY DESC&quot;,то оно не становится псевдонимом для rowid и не классифицируется как целочисленный первичный ключ.Эта причуда не является преднамеренной.Она вызвана ошибкой в ранних версиях SQLite.Но исправление ошибки может привести к обратной несовместимости.Следовательно,первоначальное поведение было сохранено (и задокументировано),потому что странное поведение в угловом случае намного лучше,чем разрыв совместимости.Это означает,что все три нижеследующие декларации таблицы приводят к тому,что столбец &quot;x&quot; является псевдонимом для rowid (целочисленного первичного ключа):</target>
        </trans-unit>
        <trans-unit id="f41b51d024f674a1f6149c31aede1e868d7d56cf" translate="yes" xml:space="preserve">
          <source>The existence of a transaction depends on whether or not the rollback journal file exists and the deletion of a file appears to be an atomic operation from the point of view of a user-space process. Therefore, a transaction appears to be an atomic operation.</source>
          <target state="translated">Существование транзакции зависит от того,существует ли файл журнала отката,а удаление файла представляется с точки зрения пользовательского пространства атомарной операцией.Следовательно,транзакция выглядит как атомарная операция.</target>
        </trans-unit>
        <trans-unit id="6021cb5e88d7481ca7795a9ddd0c04e6033fc0e0" translate="yes" xml:space="preserve">
          <source>The existing INSERT is removed from the changegroup. The DELETE is not added.</source>
          <target state="translated">Существующий INSERT удаляется из группы изменений.УДАЛЕНИЕ не добавляется.</target>
        </trans-unit>
        <trans-unit id="4a2b5a6b7a6bdb1833a8cf1e839e065d174385dc" translate="yes" xml:space="preserve">
          <source>The existing UPDATE is replaced by the new DELETE within the changegroup.</source>
          <target state="translated">Существующая UPDATE заменяется новой DELETE в группе изменений.</target>
        </trans-unit>
        <trans-unit id="5c1e2e9de2a17cfdc315c14e1e74a36e45b9c92f" translate="yes" xml:space="preserve">
          <source>The existing UPDATE remains within the changegroup. It is amended so that the accompanying values are as if the row was updated once by the existing change and then again by the new change.</source>
          <target state="translated">Существующая дата UPDATE остается в группе изменений.Она изменяется таким образом,что сопроводительные значения как если бы строка была обновлена один раз существующим изменением,а затем снова новым изменением.</target>
        </trans-unit>
        <trans-unit id="fca9185c8e0eb9e3e49b7068e021cf8a710c066e" translate="yes" xml:space="preserve">
          <source>The explicit COMMIT command runs immediately, even if there are pending &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. However, if there are pending write operations, the COMMIT command will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">Явная команда COMMIT выполняется немедленно, даже если есть ожидающие &lt;a href=&quot;lang_select&quot;&gt;выполнения&lt;/a&gt; инструкции SELECT . Однако, если есть ожидающие операции записи, команда COMMIT завершится ошибкой с кодом &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2d16a733bb795b8f24e0161c9bf1e3201567a34" translate="yes" xml:space="preserve">
          <source>The expression &quot;+column&quot; is now considered the same as &quot;column&quot; when computing the collating sequence to use on the expression.</source>
          <target state="translated">Выражение &quot;+столбец&quot; теперь считается таким же,как и &quot;столбец&quot; при вычислении коллатирующей последовательности для использования в выражении.</target>
        </trans-unit>
        <trans-unit id="fee373e0e83d3368c40362493777ab8e984bd97b" translate="yes" xml:space="preserve">
          <source>The expression &quot;a BETWEEN b AND c&quot; is treated as two separate binary comparisons &quot;a &amp;gt;= b AND a &amp;lt;= c&quot;, even if that means different affinities are applied to 'a' in each of the comparisons. Datatype conversions in comparisons of the form &quot;x IN (SELECT y ...)&quot; are handled is if the comparison were really &quot;x=y&quot;. The expression &quot;a IN (x, y, z, ...)&quot; is equivalent to &quot;a = +x OR a = +y OR a = +z OR ...&quot;. In other words, the values to the right of the IN operator (the &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; values in this example) are considered to have no affinity, even if they happen to be column values or CAST expressions.</source>
          <target state="translated">Выражение &amp;laquo;a BETWEEN b AND c&amp;raquo; обрабатывается как два отдельных двоичных сравнения &amp;laquo;a&amp;gt; = b AND a &amp;lt;= c&amp;raquo;, даже если это означает, что к &amp;laquo;a&amp;raquo; в каждом из сравнений применяются разные аффинности. Преобразования типов данных при сравнении формы &amp;laquo;x IN (SELECT y ...)&amp;raquo; обрабатываются, если сравнение действительно было &amp;laquo;x = y&amp;raquo;. Выражение &amp;laquo;a IN (x, y, z, ...)&amp;raquo; эквивалентно &amp;laquo;a = + x OR a = + y OR a = + z OR ...&amp;raquo;. Другими словами, значения справа от оператора IN (значения &amp;laquo;x&amp;raquo;, &amp;laquo;y&amp;raquo; и &amp;laquo;z&amp;raquo; в этом примере) считаются не имеющими сродства, даже если они являются значениями столбцов или выражениями CAST. .</target>
        </trans-unit>
        <trans-unit id="15a424b3e7e4f20cd419dc00af0824f2446f3f50" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x.</source>
          <target state="translated">Выражение &amp;laquo;x BETWEEN y and z&amp;raquo; логически эквивалентно двум сравнениям &amp;laquo;x&amp;gt; = y AND x &amp;lt;= z&amp;raquo; и работает в отношении функций сопоставления, как если бы это были два отдельных сравнения. Выражение &amp;laquo;x IN (SELECT y ...)&amp;raquo; обрабатывается таким же образом, как и выражение &amp;laquo;x = y&amp;raquo; для определения последовательности сортировки. Последовательность упорядочения, используемая для выражений вида &amp;laquo;x IN (y, z, ...)&amp;raquo;, является последовательностью упорядочения x.</target>
        </trans-unit>
        <trans-unit id="70c0ccea32ba2d8b128981db932845adc7b90c4c" translate="yes" xml:space="preserve">
          <source>The expression &quot;x BETWEEN y and z&quot; is logically equivalent to two comparisons &quot;x &amp;gt;= y AND x &amp;lt;= z&quot; and works with respect to collating functions as if it were two separate comparisons. The expression &quot;x IN (SELECT y ...)&quot; is handled in the same way as the expression &quot;x = y&quot; for the purposes of determining the collating sequence. The collating sequence used for expressions of the form &quot;x IN (y, z, ...)&quot; is the collating sequence of x. If an explicit collating sequence is required on an IN operator it should be applied to the left operand, like this: &quot;x COLLATE nocase IN (y,z, ...)&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6d1934b411c6401d1051c4d7453826ea7a9843" translate="yes" xml:space="preserve">
          <source>The expression attached to the optional OFFSET clause that may follow a LIMIT clause must also evaluate to an integer, or a value that can be losslessly converted to an integer. If an expression has an OFFSET clause, then the first M rows are omitted from the result set returned by the SELECT statement and the next N rows are returned, where M and N are the values that the OFFSET and LIMIT clauses evaluate to, respectively. Or, if the SELECT would return less than M+N rows if it did not have a LIMIT clause, then the first M rows are skipped and the remaining rows (if any) are returned. If the OFFSET clause evaluates to a negative value, the results are the same as if it had evaluated to zero.</source>
          <target state="translated">Выражение,приложенное к необязательному пункту OFFSET,которое может следовать за пунктом LIMIT,должно также вычисляться в целое число или в значение,которое может быть без потерь преобразовано в целое число.Если выражение имеет условие OFFSET,то первые M строк опускаются из набора результатов,возвращаемого оператором SELECT,а следующие N строк возвращаются,где M и N-это значения,которые клаузулы OFFSET и LIMIT оценивают соответственно.Или,если SELECT возвращает меньше M+N строк,если в нем нет пункта LIMIT,то пропускаются первые M строк и возвращаются оставшиеся строки (если таковые имеются).Если условие OFFSET оценивает отрицательное значение,результаты будут такими же,как если бы оно оценивалось до нуля.</target>
        </trans-unit>
        <trans-unit id="1cd8c2a06181abbb52fb772c5e4393bf493adec9" translate="yes" xml:space="preserve">
          <source>The expression following the WHERE clause may contain operators, literal values, and names of columns in the table being indexed. The WHERE clause may &lt;em&gt;not&lt;/em&gt; contain subqueries, references to other tables, &lt;a href=&quot;deterministic&quot;&gt;non-deterministic functions&lt;/a&gt;, or &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">Выражение, следующее за предложением WHERE, может содержать операторы, буквальные значения и имена столбцов в индексируемой таблице. Предложение WHERE &lt;em&gt;не&lt;/em&gt; может содержать подзапросы, ссылки на другие таблицы, &lt;a href=&quot;deterministic&quot;&gt;недетерминированные функции&lt;/a&gt; или &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанные параметры&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa57007d3af78002775463ea997fdbb172a0c191" translate="yes" xml:space="preserve">
          <source>The extension loading mechanism of SQLite (accessed using the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function) is turned off by default. This is a security precaution. If an application wants to make use of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; function it must first turn the capability on using this method.</source>
          <target state="translated">Механизм загрузки расширений SQLite (доступ к которому осуществляется с помощью функции SQL &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; ) по умолчанию отключен. Это мера безопасности. Если приложение хочет использовать &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;функцию load_extension (),&lt;/a&gt; оно должно сначала включить эту возможность с помощью этого метода.</target>
        </trans-unit>
        <trans-unit id="bbd9a40496de97ba5cfcabba824166980ee9d8c1" translate="yes" xml:space="preserve">
          <source>The extra write overhead prompted a reexamination of assumptions about powersafe overwrite. With modern disk drives, the capacity has become so large and the data density so great that a single sector is very small and writing a single sector takes very little time. We know that disk drives can detect an impending power loss and continue to operate for some small amount of time on residual energy because those drives are able to park their heads before spinning down. And so if an impending power loss is detectable by the disk controller, it seems reasonable that the controller will finish writing whatever sector it is current working on when the imminent power loss is first detected, prior to parking the heads, as long as doing so does not take too long, which it should not with small and dense sectors. Hence it seems reasonable to assume powersafe overwrite for modern disks. Indeed, BerkeleyDB has made this assumption for decades, we are told. Caution is advised though. As Roger Binns noted on the SQLite developers mailing list: &quot;'poorly written' should be the main assumption about drive firmware.&quot;</source>
          <target state="translated">Дополнительные накладные расходы на запись заставили пересмотреть предположения о перезаписи в режиме энергосбережения.С современными дисковыми накопителями емкость стала настолько велика,а плотность данных настолько велика,что один сектор очень мал,а запись одного сектора занимает очень мало времени.Мы знаем,что дисковые накопители могут обнаружить надвигающуюся потерю энергии и продолжать работать в течение некоторого небольшого количества времени на остаточной энергии,потому что эти накопители способны парковать свои головы перед вращением вниз.И поэтому,если предстоящая потеря мощности обнаруживается контроллером диска,кажется разумным,что контроллер закончит запись любого сектора,над которым он работает в данный момент,при первом обнаружении неминуемой потери мощности,до парковки головок,при условии,что это не займет слишком много времени,что не должно происходить при работе с малыми и плотными секторами.Поэтому представляется разумным предположить безопасную для питания перезапись для современных дисков.Действительно,BerkeleyDB делает это предположение на протяжении десятилетий,как нам говорят.Тем не менее,следует быть осторожным.Как отметил Роджер Биннс в списке рассылки разработчиков SQLite:&quot;плохо написанное&quot; должно быть основным предположением о прошивке диска&quot;.</target>
        </trans-unit>
        <trans-unit id="f31765748ec404a72a387c3ce457db0e7fddb3f0" translate="yes" xml:space="preserve">
          <source>The fact that NULLs are distinct for UNIQUE columns but are indistinct for SELECT DISTINCT and UNION continues to be puzzling. It seems that NULLs should be either distinct everywhere or nowhere. And the SQL standards documents suggest that NULLs should be distinct everywhere. Yet as of this writing, no SQL engine tested treats NULLs as distinct in a SELECT DISTINCT statement or in a UNION.</source>
          <target state="translated">Тот факт,что NULLs различаются для столбцов UNIQUE,но неразличимы для SELECT DISTINCT и UNION,продолжает вызывать недоумение.Похоже,что NULLs должны быть либо везде,либо нигде.А в документах по стандартам SQL говорится,что NULL должны быть разными везде.Тем не менее,на момент написания этой статьи ни один SQL-движок,протестированный,не рассматривает NULL как различные в заявлении SELECT DISTINCT или в UNION.</target>
        </trans-unit>
        <trans-unit id="36716fd190ed79338836da067e34479b294afa61" translate="yes" xml:space="preserve">
          <source>The fact that SQLite is embedded and &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt; instead of being client/server is a feature, not a bug.</source>
          <target state="translated">Тот факт, что SQLite является встроенным и &lt;a href=&quot;serverless&quot;&gt;бессерверным,&lt;/a&gt; а не клиент-серверным, является функцией, а не ошибкой.</target>
        </trans-unit>
        <trans-unit id="893ade2ecf018b089d7d0c2f18f2d37a93397ea0" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">Пятый аргумент интерфейсов привязки BLOB и строки - это деструктор, используемый для удаления BLOB или строки после того, как SQLite завершит работу с ними. Деструктор вызывается для удаления BLOB или строки, даже если вызов API привязки завершается неудачно, за исключением того, что деструктор не вызывается, если третий параметр является указателем NULL или четвертый параметр имеет отрицательное значение. Если пятым аргументом является специальное значение &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_STATIC&lt;/a&gt; , тогда SQLite предполагает, что информация находится в статическом неуправляемом пространстве и не требует освобождения. Если пятый аргумент имеет значение &lt;a href=&quot;#SQLITE_STATIC&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt; , то SQLite создает свою собственную частную копию данных немедленно, до возврата из процедуры sqlite3_bind _ * ().</target>
        </trans-unit>
        <trans-unit id="e68c8434fb7585b2fc0da0f853455aed19727f06" translate="yes" xml:space="preserve">
          <source>The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it. The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if the third parameter is a NULL pointer or the fourth parameter is negative. If the fifth argument is the special value &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt;, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed. If the fifth argument has the value &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt;, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*() routine returns.</source>
          <target state="translated">Пятый аргумент интерфейсов привязки BLOB и строки - это деструктор, используемый для удаления BLOB или строки после того, как SQLite завершит работу с ними. Деструктор вызывается для удаления BLOB или строки, даже если вызов API привязки завершается неудачно, за исключением того, что деструктор не вызывается, если третий параметр является указателем NULL или четвертый параметр имеет отрицательное значение. Если пятым аргументом является специальное значение &lt;a href=&quot;c_static&quot;&gt;SQLITE_STATIC&lt;/a&gt; , тогда SQLite предполагает, что информация находится в статическом неуправляемом пространстве и не требует освобождения. Если пятый аргумент имеет значение &lt;a href=&quot;c_static&quot;&gt;SQLITE_TRANSIENT&lt;/a&gt; , то SQLite создает свою собственную частную копию данных немедленно, до возврата из процедуры sqlite3_bind _ * ().</target>
        </trans-unit>
        <trans-unit id="901b5e438fd14b98c5489ac30117b7e4f79582ec" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCallback, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCallback argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="translated">Пятый аргумент,xCallback,это указатель на функцию сравнения.Несколько функций коллатинга могут быть зарегистрированы под одним и тем же именем,но с разными параметрами eTextRep,и SQLite будет использовать ту функцию,которая требует наименьшего объема трансформации данных.Если аргумент xCallback равен NULL,то функция коллатинга удаляется.Когда все функции-компиляторы с одинаковыми именами удаляются,эта компиляция больше не может быть использована.</target>
        </trans-unit>
        <trans-unit id="9b66d05a972406caa6b8e66ca673681eea81f8a6" translate="yes" xml:space="preserve">
          <source>The fifth argument, xCompare, is a pointer to the collating function. Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation. If the xCompare argument is NULL then the collating function is deleted. When all collating functions having the same name are deleted, that collation is no longer usable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3d71778e0851af7f19eb98c05ebd04280b893c" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">Пятый параметр - произвольный указатель. Реализация функции может получить доступ к этому указателю с помощью &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8991c375d182bf0ed874e01ceb3c3fba4c90a4d1" translate="yes" xml:space="preserve">
          <source>The fifth parameter is an arbitrary pointer. The implementation of the function can gain access to this pointer using &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;.</source>
          <target state="translated">Пятый параметр - произвольный указатель. Реализация функции может получить доступ к этому указателю с помощью &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b5fa94425e25711d656d2caafbaef27474f2b42" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to change the way it deals with files. For example, an application that does not care about crash recovery or rollback might make the open of a journal file a no-op. Writes to this journal would also be no-ops, and any attempt to read the journal would return SQLITE_IOERR. Or the implementation might recognize that a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly.</source>
          <target state="translated">Реализация файлового ввода/вывода может использовать флаги типа объекта для изменения способа работы с файлами.Например,приложение,которое не заботится о восстановлении после сбоя или откате,может сделать открытие файла журнала нерабочим.Запись в этот журнал также была бы no-ops,и любая попытка чтения журнала возвращала бы SQLITE_IOERR.Или же реализация может распознать,что файл базы данных будет выполнять чтение и запись выровненных по страницам секторов в случайном порядке и соответствующим образом настроить свою подсистему ввода/вывода.</target>
        </trans-unit>
        <trans-unit id="2ace627b4eb1891a06a62ee2e61523c0922ec242" translate="yes" xml:space="preserve">
          <source>The file I/O implementation can use the object type flags to changes the way it deals with files. For example, an application that does not care about crash recovery or rollback, might make the open of a journal file a no-op. Writes to this journal are also a no-op. Any attempt to read the journal returns &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;. Or the implementation might recognize the a database file will be doing page-aligned sector reads and writes in a random order and set up its I/O subsystem accordingly. SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">Реализация файлового ввода-вывода может использовать флаги типа объекта, чтобы изменить способ работы с файлами. Например, приложение, которое не заботится о восстановлении после сбоя или откате, может заблокировать открытие файла журнала. Записи в этот журнал также запрещены. Любая попытка прочитать журнал возвращает &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; . Или реализация может распознать, что файл базы данных будет выполнять чтение и запись с выравниванием по страницам в произвольном порядке, и соответствующим образом настроить свою подсистему ввода-вывода. SQLite может также добавить один из следующих флагов к методу xOpen:</target>
        </trans-unit>
        <trans-unit id="339116ded6000b1bbd01c16fbc4b426fdbec3ebf" translate="yes" xml:space="preserve">
          <source>The file change counter is a 4-byte big-endian integer at offset 24 that is incremented whenever the database file is unlocked after having been modified. When two or more processes are reading the same database file, each process can detect database changes from other processes by monitoring the change counter. A process will normally want to flush its database page cache when another process modified the database, since the cache has become stale. The file change counter facilitates this.</source>
          <target state="translated">Счетчик изменений файлов представляет собой 4-байтовое биг-ендианное целое число со смещением 24,которое инкрементируется всякий раз,когда файл базы данных разблокирован после его изменения.Когда два или более процесса считывают один и тот же файл базы данных,каждый процесс может обнаружить изменения в базе данных от других процессов,отслеживая счетчик изменений.Обычно процесс хочет очистить кэш страниц базы данных,когда другой процесс изменил базу данных,так как кэш стал черствым.Счетчик изменений файлов облегчает это.</target>
        </trans-unit>
        <trans-unit id="3144a807afc9a81e0cce3e084ad085692d9830bb" translate="yes" xml:space="preserve">
          <source>The file format can be extended in future releases simply by adding new tables and/or column, preserving backwards compatibility.</source>
          <target state="translated">Формат файла может быть расширен в будущих релизах простым добавлением новых таблиц и/или столбцов,сохраняя обратную совместимость.</target>
        </trans-unit>
        <trans-unit id="e6aaed4a8d57b71607b8967869bcc7f23189ec3d" translate="yes" xml:space="preserve">
          <source>The file format for indices was changed slightly in order to work around an inefficiency that can sometimes come up with GDBM when there are large indices having many entries with the same key. ** Incompatible Change **</source>
          <target state="translated">Формат файлов для индексов был несколько изменен,чтобы работать вокруг неэффективности,которая иногда может прийти в голову GDBM,когда есть большие индексы,имеющие много записей с одним и тем же ключом.**Несовместимое изменение</target>
        </trans-unit>
        <trans-unit id="227aafe2527e84f2018568e74a1b6b84889b7a1b" translate="yes" xml:space="preserve">
          <source>The file format write version and file format read version at offsets 18 and 19 are intended to allow for enhancements of the file format in future versions of SQLite. In current versions of SQLite, both of these values are 1 for rollback journalling modes and 2 for &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; journalling mode. If a version of SQLite coded to the current file format specification encounters a database file where the read version is 1 or 2 but the write version is greater than 2, then the database file must be treated as read-only. If a database file with a read version greater than 2 is encountered, then that database cannot be read or written.</source>
          <target state="translated">Версия для записи формата файла и версия для чтения в формате файла на смещениях 18 и 19 предназначены для улучшения формата файла в будущих версиях SQLite. В текущих версиях SQLite оба эти значения: 1 для режимов журналирования отката и 2 для режима журналирования &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; . Если версия SQLite, закодированная в соответствии с текущей спецификацией формата файла, встречает файл базы данных, где версия для чтения равна 1 или 2, но версия для записи больше 2, то файл базы данных должен рассматриваться как доступный только для чтения. Если обнаружен файл базы данных с версией чтения больше 2, то эта база данных не может быть прочитана или записана.</target>
        </trans-unit>
        <trans-unit id="57007ced430f8a0cf3127ebbd04af2dceb5d897b" translate="yes" xml:space="preserve">
          <source>The file-handle open on the</source>
          <target state="translated">Ручка-файл открыта на</target>
        </trans-unit>
        <trans-unit id="b75893e55d63ac0a30441dba63c6c7335b33555b" translate="yes" xml:space="preserve">
          <source>The file-system</source>
          <target state="translated">Файловая система</target>
        </trans-unit>
        <trans-unit id="e3cc87e79b2a7545d431775230c50e5146077116" translate="yes" xml:space="preserve">
          <source>The filename can be interpreted as a URI if this flag is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f230eea69094b4593dd99813cb077b78f99716" translate="yes" xml:space="preserve">
          <source>The filename for the database to be attached is the value of the expression that occurs before the AS keyword. The filename of the database follows the same semantics as the filename argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;; the special name &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; results in an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and an empty string results in a new temporary database. The filename argument can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filename processing is enable on the database connection. The default behavior is for URI filenames to be disabled, however that might change in a future release of SQLite, so application developers are advised to plan accordingly.</source>
          <target state="translated">Имя файла для присоединяемой базы данных - это значение выражения, которое стоит перед ключевым словом AS. Имя файла базы данных следует той же семантике, что и аргумент имени файла для &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; и &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; ; специальное имя &quot; &lt;a href=&quot;inmemorydb&quot;&gt;: memory:&lt;/a&gt; &quot; приводит к &lt;a href=&quot;inmemorydb&quot;&gt;базе данных в памяти,&lt;/a&gt; а пустая строка приводит к новой временной базе данных. Аргументом имени файла может быть &lt;a href=&quot;uri&quot;&gt;имя файла URI,&lt;/a&gt; если обработка имени файла URI включена для соединения с базой данных. По умолчанию имена файлов URI отключены, однако это может измениться в будущих версиях SQLite, поэтому разработчикам приложений рекомендуется планировать соответствующие действия.</target>
        </trans-unit>
        <trans-unit id="f17e1c0d84ff3c2fe25d0856ea88c3fbd19c5fb1" translate="yes" xml:space="preserve">
          <source>The filename in the INTO clause can be an arbitrary SQL expression that evaluates to a string. The file named by the INTO clause must not previously exist, or else it must be an empty file, or the VACUUM INTO command will fail with an error.</source>
          <target state="translated">Имя файла в выражении INTO может быть произвольным SQL выражением,которое вычисляется в строку.Файл,названный с помощью выражения INTO,не должен существовать ранее,иначе он должен быть пустым файлом,иначе команда VACUUM INTO выйдет из строя с ошибкой.</target>
        </trans-unit>
        <trans-unit id="d4df05c7fc29b7702e9fa3ab7eeeb629cbcad3f5" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">Имя файла, возвращаемое этой функцией, является выводом метода xFullPathname &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; . Другими словами, имя файла будет абсолютным путем, даже если имя файла, используемое для открытия базы данных, изначально было URI или относительным путем.</target>
        </trans-unit>
        <trans-unit id="9485b160522d31184c8916615322f5219f0612b8" translate="yes" xml:space="preserve">
          <source>The filename returned by this function is the output of the xFullPathname method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.</source>
          <target state="translated">Имя файла, возвращаемое этой функцией, является выводом метода xFullPathname &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Другими словами, имя файла будет абсолютным путем, даже если имя файла, используемое для открытия базы данных, изначально было URI или относительным путем.</target>
        </trans-unit>
        <trans-unit id="fc318f399f5ecbc4db919258057f39b26883fdf3" translate="yes" xml:space="preserve">
          <source>The final answer is found by looking for a string with ind==0. If the original sudoku problem did not have a unique solution, then the query will return all possible solutions. If the original problem was unsolvable, then no rows will be returned. In this case, the unique answer is:</source>
          <target state="translated">Окончательный ответ найден путем поиска строки с ind==0.Если оригинальная задача sudoku не имела уникального решения,то запрос вернет все возможные решения.Если оригинальная задача была неразрешимой,то строки возвращаться не будут.В этом случае уникальным ответом будет:</target>
        </trans-unit>
        <trans-unit id="0fa7031611bf07c03077958f2b8ed29a77590306" translate="yes" xml:space="preserve">
          <source>The final argument is an output variable. If successful, (*ppOut) should be set to point to the new tokenizer handle and SQLITE_OK returned. If an error occurs, some value other than SQLITE_OK should be returned. In this case, fts5 assumes that the final value of *ppOut is undefined.</source>
          <target state="translated">Последним аргументом является выходная переменная.В случае успеха (*ppOut)необходимо указать на новый хэндл токенайзера и вернуть SQLITE_OK.В случае ошибки должно быть возвращено некоторое значение,отличное от SQLITE_OK.В этом случае fts5 предполагает,что конечное значение *ppOut не определено.</target>
        </trans-unit>
        <trans-unit id="3adcbd65298a5982e7a64803692e07245861c301" translate="yes" xml:space="preserve">
          <source>The final byte of an encoded FTS varint has its most significant bit cleared. All preceding bytes have the most significant bit set. Data is stored in the remaining seven least significant bits of each byte. The first byte of the encoded representation contains the least significant seven bits of the encoded integer value. The second byte of the encoded representation, if it is present, contains the seven next least significant bits of the integer value, and so on. The following table contains examples of encoded integer values:</source>
          <target state="translated">Последний байт закодированного варинта FTS очищен от наиболее значимого бита.Все предыдущие байты имеют наиболее значащий набор битов.Данные хранятся в оставшихся семи младших битах каждого байта.Первый байт кодированного представления содержит семь младших значащих битов кодированного целого значения.Второй байт кодированного представления,если он присутствует,содержит семь следующих младших значащих битов целого значения и так далее.В следующей таблице приведены примеры кодированных целочисленных значений:</target>
        </trans-unit>
        <trans-unit id="c65b7966b6f5867eece6741b751cabc0c349ca6a" translate="yes" xml:space="preserve">
          <source>The final line of the example (the &quot;.system c:/work/dataout.csv&quot;) has the same effect as double-clicking on the c:/work/dataout.csv file in windows. This will typically bring up a spreadsheet program to display the CSV file.</source>
          <target state="translated">Последняя строка примера (&quot;.system c:/work/dataout.csv&quot;)имеет тот же эффект,что и двойной щелчок на файле c:/work/dataout.csv в окнах.Обычно это вызовет программу электронной таблицы для отображения CSV-файла.</target>
        </trans-unit>
        <trans-unit id="312ab3f0c70e0337ccdf666710177cbb51a2f6d3" translate="yes" xml:space="preserve">
          <source>The final query in the block above may not work as expected. Because the &quot;*&quot; character is inside the double-quotes, it will be passed to the tokenizer, which will likely discard it (or perhaps, depending on the specific tokenizer in use, include it as part of the final token) instead of recognizing it as a special FTS character.</source>
          <target state="translated">Последний запрос в вышеуказанном блоке может работать не так,как ожидалось.Поскольку символ &quot;*&quot; находится внутри двойных кавычек,он будет передан токенайзеру,который,скорее всего,отбросит его (или,возможно,в зависимости от используемого токенайзера,включит его в состав конечной токена),вместо того,чтобы распознавать его как специальный символ FTS.</target>
        </trans-unit>
        <trans-unit id="a564ec7adef18f2e787e1258b9aed3803202963e" translate="yes" xml:space="preserve">
          <source>The final recovery step is to reduce the exclusive lock back to a shared lock. Once this happens, the database is back in the state that it would have been if the aborted transaction had never started. Since all of this recovery activity happens completely automatically and transparently, it appears to the program using SQLite as if the aborted transaction had never begun.</source>
          <target state="translated">Последний шаг восстановления-уменьшение эксклюзивного замка до общего.Как только это происходит,база данных возвращается в то состояние,в котором она была бы,если бы прерванная транзакция никогда не начиналась.Поскольку вся эта деятельность по восстановлению происходит полностью автоматически и прозрачно,программе,использующей SQLite,кажется,что прерванная транзакция никогда не начиналась.</target>
        </trans-unit>
        <trans-unit id="434e32f7c5be2c22a40571665c3031a75ce803d2" translate="yes" xml:space="preserve">
          <source>The final source of large memory allocations is the space to hold the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that result from compiling complex SQL operations. Ongoing work by the SQLite developers is reducing the amount of space required here. But large and complex queries might still require &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that are several kilobytes in size. The only workaround at the moment is for the application to break complex SQL operations up into two or more smaller and simpler operations contained in separate &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">Последним источником выделения больших объемов памяти является пространство для хранения &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленных операторов&lt;/a&gt; , являющихся результатом компиляции сложных операций SQL. Продолжающаяся работа разработчиков SQLite сокращает объем требуемого здесь места. Но для больших и сложных запросов все же могут потребоваться &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленные операторы&lt;/a&gt; размером в несколько килобайт. Единственный обходной путь на данный момент заключается в том, что приложение разбивает сложные операции SQL на две или более более мелких и простых операций, содержащихся в отдельных &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленных операторах&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e5be990568c2b06d13617fdb20a3f4473d59b9c" translate="yes" xml:space="preserve">
          <source>The final step in a multi-file commit is to delete the individual rollback journals and drop the exclusive locks on the database files so that other processes can see the changes. This corresponds to &lt;a href=&quot;#section_3_12&quot;&gt;step 3.12&lt;/a&gt; in the single-file commit sequence.</source>
          <target state="translated">Последним шагом в многофайловой фиксации является удаление отдельных журналов отката и снятие монопольных блокировок с файлов базы данных, чтобы другие процессы могли видеть изменения. Это соответствует &lt;a href=&quot;#section_3_12&quot;&gt;шагу 3.12&lt;/a&gt; в последовательности фиксации одного файла.</target>
        </trans-unit>
        <trans-unit id="570119a07afaf61a9f20cf9abd68b217ebf33834" translate="yes" xml:space="preserve">
          <source>The final three arguments passed to the auxiliary function callback are similar to the three arguments passed to the implementation of a scalar SQL function. All arguments except the first passed to the auxiliary function are available to the implementation in the apVal[] array. The implementation should return a result or error via the content handle pCtx.</source>
          <target state="translated">Последние три аргумента,переданные во вспомогательную функцию обратного вызова,аналогичны трем аргументам,переданным в реализацию скалярной SQL-функции.Все аргументы,кроме первого,переданного вспомогательной функции,доступны для реализации в массиве apVal[].Реализация должна возвращать результат или ошибку через хэндл содержимого pCtx.</target>
        </trans-unit>
        <trans-unit id="72acf6716754df5bf7660108439b7caacc7e6afa" translate="yes" xml:space="preserve">
          <source>The first 100 bytes of the database file comprise the database file header. The database file header is divided into fields as shown by the table below. All multibyte fields in the database file header are stored with the most significant byte first (big-endian).</source>
          <target state="translated">Первые 100 байт файла БД составляют заголовок файла БД.Заголовок файла БД разделен на поля,как показано в таблице ниже.Все многобайтовые поля в заголовке файла БД хранятся с самым старшим байтом (big-endian).</target>
        </trans-unit>
        <trans-unit id="7ad8baeb9b6a7d25df8e53c7bba57a3b07d6a12e" translate="yes" xml:space="preserve">
          <source>The first 136 bytes of the shm file are a header. The shm header has three main divisions as follows:</source>
          <target state="translated">Первые 136 байт файла shm-это заголовок.Заголовок шма имеет три основных разделения следующим образом:</target>
        </trans-unit>
        <trans-unit id="32a4d848523b5982a35dd9ccae2a5e300c48ac95" translate="yes" xml:space="preserve">
          <source>The first 8 bytes of the</source>
          <target state="translated">Первые 8 байт</target>
        </trans-unit>
        <trans-unit id="31e639e14579d85dee4c60a5aeaa903eaa1984f2" translate="yes" xml:space="preserve">
          <source>The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex() method. The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex. This function returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.</source>
          <target state="translated">Первым аргументом должен быть объект sqlite3_index_info,который является первым параметром метода xBestIndex().Вторым аргументом должен быть индекс в массиве aConstraint[],принадлежащем структуре sqlite3_index_info,переданный xBestIndex.Эта функция возвращает указатель на буфер,содержащий имя последовательности сравнения для соответствующего ограничения.</target>
        </trans-unit>
        <trans-unit id="756a3aef230a7b2fc01840e9c05f1d8a68c861b7" translate="yes" xml:space="preserve">
          <source>The first argument passed should be the database handle to register the extension with. The second and third arguments should both be passed 0.</source>
          <target state="translated">Первым аргументом должен быть хэндл БД для регистрации расширения.Второй и третий аргументы должны быть переданы 0.</target>
        </trans-unit>
        <trans-unit id="7fa580625e479f237836af3af275aa2f6a47351d" translate="yes" xml:space="preserve">
          <source>The first argument passed to an auxiliary function callback is a pointer to a structure containing methods that may be invoked in order to obtain information regarding the current query or row. The second argument is an opaque handle that should be passed as the first argument to any such method invocation. For example, the following auxiliary function definition returns the total number of tokens in all columns of the current row:</source>
          <target state="translated">Первый аргумент,передаваемый на обратный вызов вспомогательной функции-это указатель на структуру,содержащую методы,которые могут быть вызваны для получения информации о текущем запросе или строке.Второй аргумент-непрозрачный хэндл,который должен передаваться в качестве первого аргумента при вызове любого такого метода.Например,следующее определение вспомогательной функции возвращает общее количество лексем во всех столбцах текущей строки:</target>
        </trans-unit>
        <trans-unit id="d4428415829da9afdeca7abddd54df2e62906cce" translate="yes" xml:space="preserve">
          <source>The first argument passed to this function is a copy of the (void*) pointer provided by the application when the fts5_tokenizer object was registered with FTS5 (the third argument to xCreateTokenizer()). The second and third arguments are an array of nul-terminated strings containing the tokenizer arguments, if any, specified following the tokenizer name as part of the CREATE VIRTUAL TABLE statement used to create the FTS5 table.</source>
          <target state="translated">Первый аргумент,передаваемый в эту функцию,является копией указателя (void*),предоставленного приложением при регистрации объекта fts5_tokenizer в FTS5 (третий аргумент в xCreateTokenizer()).Второй и третий аргументы представляют собой массив нуль-терминированных строк,содержащих аргументы токенайзера,если таковые имеются,заданные после имени токенайзера в составе оператора CREATE VIRTUAL TABLE,используемого для создания таблицы FTS5.</target>
        </trans-unit>
        <trans-unit id="3ddc48958f41facca8a1ecdc60ac948a59cb2349" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must be the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer as the first parameter to this method. The second argument to &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; must a zero-terminated UTF-8 string that contains a well-formed &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that defines the columns in the virtual table and their data types. The name of the table in this CREATE TABLE statement is ignored, as are all constraints. Only the column names and datatypes matter. The CREATE TABLE statement string need not to be held in persistent memory. The string can be deallocated and/or reused as soon as the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; routine returns.</source>
          <target state="translated">Первый аргумент &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; должен быть тем же указателем &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных,&lt;/a&gt; что и первый параметр этого метода. Второй аргумент &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; должен содержать строку UTF-8 с нулевым символом в конце, которая содержит правильно сформированный оператор &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , определяющий столбцы в виртуальной таблице и их типы данных. Имя таблицы в этом операторе CREATE TABLE игнорируется, как и все ограничения. Имеют значение только имена столбцов и типы данных. Строку оператора CREATE TABLE не обязательно хранить в постоянной памяти. Строку можно освободить и / или использовать повторно, как только процедура &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; вернется.</target>
        </trans-unit>
        <trans-unit id="1aed5522193a69fc6ff8aa89cff3e41266a3f600" translate="yes" xml:space="preserve">
          <source>The first argument to all three special SQL scalar functions must be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table that the function is applied to. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically-generated column found on all FTS tables that has the same name as the FTS table itself. For example, given an FTS table named &quot;mail&quot;:</source>
          <target state="translated">Первым аргументом всех трех специальных скалярных функций SQL должен быть &lt;a href=&quot;fts3#hiddencol&quot;&gt;скрытый столбец&lt;/a&gt; FTS таблицы FTS, к которой применяется функция. &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS скрытый столбец&lt;/a&gt; является автоматически генерируемый столбец найдены на всех FTS таблиц, имеет такое же имя , как и сама таблица FTS. Например, для таблицы FTS с именем &amp;laquo;mail&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="952294bca557c59738bac0e545034c52a263067f" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">Первый аргумент sqlite3_config () - это целочисленный &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;параметр конфигурации,&lt;/a&gt; который определяет, какое свойство SQLite нужно настроить. Последующие аргументы меняются в зависимости от параметра &lt;a href=&quot;#SQLITE_CONFIG_COVERING_INDEX_SCAN&quot;&gt;конфигурации&lt;/a&gt; в первом аргументе.</target>
        </trans-unit>
        <trans-unit id="f875f5d7c01e9a29524328575e142babf2bae3ae" translate="yes" xml:space="preserve">
          <source>The first argument to sqlite3_config() is an integer &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; that determines what property of SQLite is to be configured. Subsequent arguments vary depending on the &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;configuration option&lt;/a&gt; in the first argument.</source>
          <target state="translated">Первый аргумент sqlite3_config () - это целочисленный &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;параметр конфигурации,&lt;/a&gt; который определяет, какое свойство SQLite нужно настроить. Последующие аргументы меняются в зависимости от параметра &lt;a href=&quot;c_config_covering_index_scan&quot;&gt;конфигурации&lt;/a&gt; в первом аргументе.</target>
        </trans-unit>
        <trans-unit id="3f0ed77e9965fa2c39bb9cbb993108ef55b7d05b" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">Первый аргумент обработчика занятости - это копия указателя void *, который является третьим аргументом sqlite3_busy_handler (). Второй аргумент обратного вызова обработчика занятости - это количество раз, когда обработчик занятости был вызван ранее для того же события блокировки. Если обратный вызов занятости возвращает 0, то дополнительных попыток доступа к базе данных не &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;делается,&lt;/a&gt; и приложению возвращается SQLITE_BUSY . Если обратный вызов возвращает ненулевое значение, делается еще одна попытка доступа к базе данных, и цикл повторяется.</target>
        </trans-unit>
        <trans-unit id="73aa47dd980f8a887b15a2decc4e912f8fd4e328" translate="yes" xml:space="preserve">
          <source>The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler(). The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event. If the busy callback returns 0, then no additional attempts are made to access the database and &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the application. If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.</source>
          <target state="translated">Первый аргумент обработчика занятости - это копия указателя void *, который является третьим аргументом sqlite3_busy_handler (). Второй аргумент обратного вызова обработчика занятости - это количество раз, когда обработчик занятости был вызван ранее для того же события блокировки. Если обратный вызов занятости возвращает 0, то дополнительных попыток доступа к базе данных не &lt;a href=&quot;../rescode#busy&quot;&gt;делается,&lt;/a&gt; и приложению возвращается SQLITE_BUSY . Если обратный вызов возвращает ненулевое значение, делается еще одна попытка доступа к базе данных, и цикл повторяется.</target>
        </trans-unit>
        <trans-unit id="395ff21e8cf7b4d90e5bc3764e07164a7c24e72d" translate="yes" xml:space="preserve">
          <source>The first argument to the callback is just a copy of the fourth argument to &lt;b&gt;sqlite_exec&lt;/b&gt; This parameter can be used to pass arbitrary information through to the callback function from client code. The second argument is the number of columns in the query result. The third argument is an array of pointers to strings where each string is a single column of the result for that record. Note that the callback function reports a NULL value in the database as a NULL pointer, which is very different from an empty string. If the i-th parameter is an empty string, we will get:</source>
          <target state="translated">Первый аргумент обратного вызова - это всего лишь копия четвертого аргумента &lt;b&gt;sqlite_exec.&lt;/b&gt; Этот параметр может использоваться для передачи произвольной информации в функцию обратного вызова из клиентского кода. Второй аргумент - это количество столбцов в результате запроса. Третий аргумент - это массив указателей на строки, где каждая строка представляет собой отдельный столбец результата для этой записи. Обратите внимание, что функция обратного вызова сообщает значение NULL в базе данных как указатель NULL, который сильно отличается от пустой строки. Если i-й параметр - пустая строка, мы получим:</target>
        </trans-unit>
        <trans-unit id="19ed31ae74a9a14120db33894759ec36b8a3df0f" translate="yes" xml:space="preserve">
          <source>The first argument to the snippet function must always be the &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; of the FTS table being queried and from which the snippet is to be taken. The &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; is an automatically generated column with the same name as the FTS table itself.</source>
          <target state="translated">Первым аргументом функции фрагмента всегда должен быть &lt;a href=&quot;fts3#hiddencol&quot;&gt;скрытый столбец&lt;/a&gt; FTS запрашиваемой таблицы FTS, из которого должен быть взят фрагмент. &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS скрыт столбец&lt;/a&gt; является автоматически генерируемый столбец с тем же именем, что и сама таблица FTS.</target>
        </trans-unit>
        <trans-unit id="a3c117d3156af5d9687ce63c9ca2baca71f1029c" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">Первый аргумент подпрограмм sqlite3_bind _ * () всегда является указателем на объект &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt,&lt;/a&gt; возвращаемый &lt;a href=&quot;#sqlite3_prepare&quot;&gt;функцией sqlite3_prepare_v2 ()&lt;/a&gt; или ее вариантами.</target>
        </trans-unit>
        <trans-unit id="e62bb2c9601439134c1919cc9d703235a3e8dcf1" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3_bind_*() routines is always a pointer to the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its variants.</source>
          <target state="translated">Первый аргумент подпрограмм sqlite3_bind _ * () всегда является указателем на объект &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt,&lt;/a&gt; возвращаемый &lt;a href=&quot;prepare&quot;&gt;функцией sqlite3_prepare_v2 ()&lt;/a&gt; или ее вариантами.</target>
        </trans-unit>
        <trans-unit id="4376fc02622bfe056753a887d840cb5de850cf76" translate="yes" xml:space="preserve">
          <source>The first argument to the sqlite3session_config() function must be one of the SQLITE_SESSION_CONFIG_XXX constants defined below. The interpretation of the (void*) value passed as the second parameter and the effect of calling this function depends on the value of the first parameter.</source>
          <target state="translated">Первый аргумент функции sqlite3session_config()должен быть одной из констант SQLITE_SESSION_CONFIG_XXX,определенных ниже.Интерпретация значения (void*),переданного в качестве второго параметра,и эффект вызова этой функции зависят от значения первого параметра.</target>
        </trans-unit>
        <trans-unit id="46628205e32bedcd53350a6840ee825a63d42391" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">Первым аргументом для этих интерфейсов является &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Эти функции возвращают информацию о N-м столбце результата, возвращенном оператором, где N - второй аргумент функции. Самый левый столбец - это столбец 0 для этих подпрограмм.</target>
        </trans-unit>
        <trans-unit id="0f76a71e763d5bd4fbae26e4a6f14b3c938ceb32" translate="yes" xml:space="preserve">
          <source>The first argument to these interfaces is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. These functions return information about the Nth result column returned by the statement, where N is the second function argument. The left-most column is column 0 for these routines.</source>
          <target state="translated">Первым аргументом для этих интерфейсов является &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Эти функции возвращают информацию о N-м столбце результата, возвращенном оператором, где N - второй аргумент функции. Самый левый столбец - это столбец 0 для этих подпрограмм.</target>
        </trans-unit>
        <trans-unit id="a5ff723764d00dd9ac3f381e3bed0a1f08296ed5" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">Первый аргумент, &amp;laquo;db&amp;raquo;, - это &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, полученное в результате предыдущего успешного вызова &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; . Соединение с базой данных не должно быть закрыто.</target>
        </trans-unit>
        <trans-unit id="691e78895187de6910913a151c966bb350230789" translate="yes" xml:space="preserve">
          <source>The first argument, &quot;db&quot;, is a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; obtained from a prior successful call to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. The database connection must not have been closed.</source>
          <target state="translated">Первый аргумент, &amp;laquo;db&amp;raquo;, - это &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, полученное в результате предыдущего успешного вызова &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; или &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; . Соединение с базой данных не должно быть закрыто.</target>
        </trans-unit>
        <trans-unit id="5da926bf27ba88ce6fa226bb8489971c4b0badd1" translate="yes" xml:space="preserve">
          <source>The first attempt at closing security gaps in pointer passing was to prevent pointer values from being forged. This was accomplished by having the sender attach a subtype to each pointer using &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; and having the receiver verify that subtype using &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and reject pointers that had an incorrect subtype. Since there is no way to attach a subtype to a result using pure SQL, this prevents pointers from being forged using SQL. The only way to send a pointer is to use C code. If an attacker can set a subtype, then he is also able to forge a pointer without the help of SQLite.</source>
          <target state="translated">Первой попыткой закрыть бреши в безопасности при передаче указателя было предотвращение подделки значений указателя. Для этого отправитель прикреплял подтип к каждому указателю с помощью &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype (),&lt;/a&gt; а получатель проверял этот подтип с помощью &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype ()&lt;/a&gt; и отклонял указатели с неправильным подтипом. Поскольку нет способа присоединить подтип к результату с использованием чистого SQL, это предотвращает подделку указателей с помощью SQL. Единственный способ отправить указатель - использовать код C. Если злоумышленник может установить подтип, он также может подделать указатель без помощи SQLite.</target>
        </trans-unit>
        <trans-unit id="b3f912cc569c0361b5c2cd2202f03f7409e6b0b1" translate="yes" xml:space="preserve">
          <source>The first beta release for SQLite 3.0.</source>
          <target state="translated">Первый бета-релиз для SQLite 3.0.</target>
        </trans-unit>
        <trans-unit id="85577f9e39e1e56bdcef30a17afd1e7fd9d77720" translate="yes" xml:space="preserve">
          <source>The first byte of the header is a flag byte. The least significant bit of the flag byte determines whether the coordinate pairs that follow the header are stored big-endian or little-endian. A value of 0 for the least significant bit means big-endian and a value of 1 means little endian. Other bits of the first byte in the header are reserved for future expansion.</source>
          <target state="translated">Первый байт заголовка-флаг-байт.Наименьший байт флага определяет,хранятся ли пары координат,следующие за заголовком,в big-endian или little-endian.Значение 0 для наименьшего значащего бита означает big-endian,а значение 1 означает little-endian.Остальные биты первого байта в заголовке зарезервированы для будущего расширения.</target>
        </trans-unit>
        <trans-unit id="f63d26f2f4bc609cd955a5edef912da4a0a9006c" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; on the iterator moves it to point to the first change in the changeset (or to EOF, if the changeset is completely empty). sqlite3changeset_next() returns SQLITE_ROW if it moves the iterator to point to a valid entry, SQLITE_DONE if it moves the iterator to EOF, or an SQLite error code if an error occurs.</source>
          <target state="translated">Первый вызов &lt;a href=&quot;session/sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; на итераторе перемещает его так, чтобы он указывал на первое изменение в наборе изменений (или на EOF, если набор изменений полностью пуст). sqlite3changeset_next () возвращает SQLITE_ROW, если он перемещает итератор, чтобы указать на действительную запись, SQLITE_DONE, если он перемещает итератор в EOF, или код ошибки SQLite, если возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="261c910c7fa661af930e1c363bad2fff3671bdea" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">Первый вызов sqlite3_backup_step () обеспечивает монопольную блокировку целевого файла. Эксклюзивная блокировка не снимается до тех пор, пока не будет вызвана sqlite3_backup_finish () или пока не будет завершена операция резервного копирования и sqlite3_backup_step () не вернет &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; . Каждый вызов sqlite3_backup_step () получает &lt;a href=&quot;lockingv3#shared_lock&quot;&gt;общую блокировку&lt;/a&gt;в исходной базе данных, которая действует на время вызова sqlite3_backup_step (). Поскольку исходная база данных не заблокирована между вызовами sqlite3_backup_step (), исходная база данных может быть изменена в середине процесса резервного копирования. Если исходная база данных изменена внешним процессом или через соединение с базой данных, отличное от того, которое используется операцией резервного копирования, то резервное копирование будет автоматически перезапущено при следующем вызове sqlite3_backup_step (). Если исходная база данных изменяется с использованием того же соединения с базой данных, которое используется при операции резервного копирования, то база данных резервного копирования автоматически обновляется одновременно.</target>
        </trans-unit>
        <trans-unit id="57eb736cb2a536a07c53b0e0f817765662d0da0a" translate="yes" xml:space="preserve">
          <source>The first call to sqlite3_backup_step() obtains an exclusive lock on the destination file. The exclusive lock is not released until either sqlite3_backup_finish() is called or the backup operation is complete and sqlite3_backup_step() returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. Every call to sqlite3_backup_step() obtains a &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;shared lock&lt;/a&gt; on the source database that lasts for the duration of the sqlite3_backup_step() call. Because the source database is not locked between calls to sqlite3_backup_step(), the source database may be modified mid-way through the backup process. If the source database is modified by an external process or via a database connection other than the one being used by the backup operation, then the backup will be automatically restarted by the next call to sqlite3_backup_step(). If the source database is modified by the using the same database connection as is used by the backup operation, then the backup database is automatically updated at the same time.</source>
          <target state="translated">Первый вызов sqlite3_backup_step () обеспечивает монопольную блокировку целевого файла. Эксклюзивная блокировка не снимается до тех пор, пока не будет вызвана sqlite3_backup_finish () или пока не будет завершена операция резервного копирования и sqlite3_backup_step () не вернет &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; . Каждый вызов sqlite3_backup_step () получает &lt;a href=&quot;../lockingv3#shared_lock&quot;&gt;общую блокировку&lt;/a&gt;в исходной базе данных, которая действует на время вызова sqlite3_backup_step (). Поскольку исходная база данных не заблокирована между вызовами sqlite3_backup_step (), исходная база данных может быть изменена в середине процесса резервного копирования. Если исходная база данных изменена внешним процессом или через соединение с базой данных, отличное от того, которое используется операцией резервного копирования, то резервное копирование будет автоматически перезапущено при следующем вызове sqlite3_backup_step (). Если исходная база данных изменяется с использованием того же соединения с базой данных, которое используется при операции резервного копирования, то база данных резервного копирования автоматически обновляется одновременно.</target>
        </trans-unit>
        <trans-unit id="878621de1d1518fe649327da44b122a6dcc1e4c1" translate="yes" xml:space="preserve">
          <source>The first code for TH3 was laid down on 2008-09-25. An intense effort over the next 10 months resulted in TH3 achieving 100% MC/DC on 2009-07-25. The TH3 code continues to be improved and expanded.</source>
          <target state="translated">Первый код для TH3 был заложен в 2008-09-25 годах.Интенсивные усилия в течение следующих 10 месяцев привели к тому,что в 2009-07-25 годах TH3 достигла 100% MC/DC.Код TH3 продолжает совершенствоваться и расширяться.</target>
        </trans-unit>
        <trans-unit id="708a1cddc7d07a561f3445a868346de6a13841df" translate="yes" xml:space="preserve">
          <source>The first column is the schema name for the database that contains the tables. Examples: &quot;main&quot;, &quot;zone512&quot;.</source>
          <target state="translated">Первый столбец-это имя схемы БД,содержащей таблицы.Примеры:&quot;главная&quot;,&quot;зона512&quot;.</target>
        </trans-unit>
        <trans-unit id="9814feb56c887ece7381e15fd8887b6ec1a1d8c0" translate="yes" xml:space="preserve">
          <source>The first column of an SQLite R*Tree is similar to an integer primary key column of a normal SQLite table. It may only store a 64-bit signed integer value. Inserting a NULL value into this column causes SQLite to automatically generate a new unique primary key value. If an attempt is made to insert any other non-integer value into this column, the r-tree module silently converts it to an integer before writing it into the database.</source>
          <target state="translated">Первый столбец R*Tree SQLite аналогичен целому столбцу первичного ключа обычной таблицы SQLite.В нем может храниться только 64-битное целое значение,подписанное.Вставка в этот столбец NULL-значения приводит к тому,что SQLite автоматически генерирует новое уникальное значение первичного ключа.При попытке вставить в этот столбец любое другое неинтегрированное значение,модуль r-дерева бесшумно преобразует его в целое число перед записью в БД.</target>
        </trans-unit>
        <trans-unit id="840bd12d54aba66c9e7cdaff39f91dd2e3886bf1" translate="yes" xml:space="preserve">
          <source>The first condition causes all of the trunk check-ins to be displayed and the second and third cause check-ins that merge into or fork from the trunk to also be included. The three conditions are implemented by the three OR-connected EXISTS statements in the WHERE clause of the query. The slowdown that occurred with the NGQP was caused by the second and third conditions. The problem is the same in each, so we will examine just the second one. The subquery of the second condition can be rewritten (with minor and immaterial simplifications) as follows:</source>
          <target state="translated">Первое условие приводит к тому,что отображаются все проверки в стволе,а второе и третье-к тому,что также включаются проверки,которые сливаются в ствол или вилки из него.Эти три условия выполняются тремя операторами &quot;ИЛИ-связанные ВЫХОДЫ&quot; в пункте &quot;ГДЕ&quot; запроса.Замедление,произошедшее с NGQP,вызвано вторым и третьим условиями.Проблема в каждом из них одна и та же,поэтому рассмотрим только второе.Подзапрос второго условия можно переписать (с незначительными и несущественными упрощениями)следующим образом:</target>
        </trans-unit>
        <trans-unit id="1d90855e6a48f657d5fb1f13585eab05ee2b6665" translate="yes" xml:space="preserve">
          <source>The first example above is the preferred definition of the table, of course. All of the examples create a WITHOUT ROWID table with two PRIMARY KEY columns, &quot;a&quot; and &quot;c&quot;, in that order, followed by two data columns &quot;b&quot; and &quot;d&quot;, also in that order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d78f5e7f65436952c61eefc9d02af59c750bcb9f" translate="yes" xml:space="preserve">
          <source>The first five fields of the sqlite3_rtree_query_info structure are identical to the sqlite3_rtree_geometry structure, and have exactly the same meaning. The sqlite3_rtree_query_info structure also contains nCoord and aCoord fields which have the same meaning as the parameter of the same name in the xGeom callback.</source>
          <target state="translated">Первые пять полей структуры sqlite3_rtree_query_info идентичны структуре sqlite3_rtree_geometry и имеют точно такое же значение.Структура sqlite3_rtree_query_info также содержит поля nCoord и aCoord,которые имеют то же значение,что и одноименный параметр в обратном вызове xGeom.</target>
        </trans-unit>
        <trans-unit id="8e073e98c04e5afd81b1a912e72c323c17ce2eb5" translate="yes" xml:space="preserve">
          <source>The first form (with the &quot;VALUES&quot; keyword) creates one or more new rows in an existing table. If the column-name list after table-name is omitted then the number of values inserted into each row must be the same as the number of columns in the table. In this case the result of evaluating the left-most expression from each term of the VALUES list is inserted into the left-most column of each new row, and so forth for each subsequent expression. If a column-name list is specified, then the number of values in each term of the VALUE list must match the number of specified columns. Each of the named columns of the new row is populated with the results of evaluating the corresponding VALUES expression. Table columns that do not appear in the column list are populated with the &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default column value&lt;/a&gt; (specified as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement), or with NULL if no &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt; is specified.</source>
          <target state="translated">Первая форма (с ключевым словом &amp;laquo;VALUES&amp;raquo;) создает одну или несколько новых строк в существующей таблице. Если список имен столбцов после имени таблицы опущен, то количество значений, вставляемых в каждую строку, должно быть таким же, как количество столбцов в таблице. В этом случае результат вычисления самого левого выражения из каждого члена списка VALUES вставляется в крайний левый столбец каждой новой строки и так далее для каждого последующего выражения. Если указан список имен столбцов, то количество значений в каждом термине списка VALUE должно соответствовать количеству указанных столбцов. Каждый из названных столбцов новой строки заполняется результатами вычисления соответствующего выражения VALUES. Столбцы таблицы, которые не отображаются в списке столбцов, заполняются &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;значением столбца&lt;/a&gt; по умолчанию.(указывается как часть оператора &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; ) или с NULL, если &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;значение по умолчанию&lt;/a&gt; не указано.</target>
        </trans-unit>
        <trans-unit id="2570c22a55e27cbe9ad6c1dce2c1cff1bff0c5c4" translate="yes" xml:space="preserve">
          <source>The first form loads the edit distance coefficients from a table called 'TABLENAME'. Any prior coefficients are discarded. So when experimenting with weights and the weight table changes, simply rerun the single-argument form of editdist3() to reload revised coefficients. Note that the edit distance weights used by the editdist3() SQL function are independent from the weights used by the spellfix1 virtual table.</source>
          <target state="translated">Первая форма загружает коэффициенты расстояния редактирования из таблицы под названием 'TABLENAME'.Любые предыдущие коэффициенты отбрасываются.Поэтому,экспериментируя с весами и изменением таблицы весов,просто перезагрузите единственную форму editdist3(),чтобы перезагрузить пересмотренные коэффициенты.Обратите внимание,что веса расстояния редактирования,используемые SQL-функцией editdist3(),не зависят от весов,используемых виртуальной таблицей spellfix1.</target>
        </trans-unit>
        <trans-unit id="7597ee6d3f1982d757a998bf7dd70b5fa125869a" translate="yes" xml:space="preserve">
          <source>The first form of the lag() function returns the result of evaluating expression</source>
          <target state="translated">Первая форма функции lag()возвращает результат вычисления выражения</target>
        </trans-unit>
        <trans-unit id="99435f14d6ece88179aba89152e1459d1e98bf65" translate="yes" xml:space="preserve">
          <source>The first form of the lead() function returns the result of evaluating expression</source>
          <target state="translated">Первая форма функции lead()возвращает результат вычисления выражения</target>
        </trans-unit>
        <trans-unit id="0e38dddff1d9fcb9023e44603abe1408f559a08e" translate="yes" xml:space="preserve">
          <source>The first form of this pragma queries the current journaling mode for</source>
          <target state="translated">Первая форма этой прагмы запрашивает текущий режим протоколирования для</target>
        </trans-unit>
        <trans-unit id="b8118a5225d858802697d63c772d9f2007991455" translate="yes" xml:space="preserve">
          <source>The first four columns a, b, c, and d of the index would be usable since those four columns form a prefix of the index and are all bound by equality constraints.</source>
          <target state="translated">Первые четыре столбца a,b,c и d индекса можно было бы использовать,поскольку эти четыре столбца образуют префикс индекса и все они связаны ограничениями равенства.</target>
        </trans-unit>
        <trans-unit id="4ead6c16538264b763b7c6adde08cc0b22f7c9e0" translate="yes" xml:space="preserve">
          <source>The first group of queries in the log are extracting display options from the &quot;config&quot; and &quot;global_config&quot; tables of the Fossil database. Then there is a single complex query that extracts a list of all elements to be displayed on the timeline. This &quot;timeline&quot; query demonstrates that SQLite can easily process complex relational database queries involving multiple tables, subqueries, and complex WHERE clause constraints, and it can make effective use of indexes to solve the queries with minimal disk I/O.</source>
          <target state="translated">Первая группа запросов в журнале-извлечение опций отображения из таблиц &quot;config&quot; и &quot;global_config&quot; Ископаемой базы данных.Затем идет один сложный запрос,который извлекает список всех элементов для отображения на временной шкале.Этот запрос &quot;timeline&quot; демонстрирует,что SQLite может легко обрабатывать сложные реляционные запросы к БД,включающие в себя несколько таблиц,подзапросов и сложные ограничения по пунктам WHERE,и может эффективно использовать индексы для решения запросов с минимальным количеством дисковых операций ввода-вывода.</target>
        </trans-unit>
        <trans-unit id="4e52fafda10d32765550d3edce2eeda11c3b4ffd" translate="yes" xml:space="preserve">
          <source>The first host parameter has an index of 1, not 0.</source>
          <target state="translated">Первый параметр хоста имеет индекс 1,а не 0.</target>
        </trans-unit>
        <trans-unit id="178a49643c52d6ff462985df8e6c238cfb8ec5cd" translate="yes" xml:space="preserve">
          <source>The first instruction of interest is the &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. The AggReset instruction initializes the set of buckets to be the empty set and specifies the number of memory slots available in each bucket as P2. In this example, each bucket will hold 3 memory slots. It is not obvious, but if you look closely at the rest of the program you can figure out what each of these slots is intended for.</source>
          <target state="translated">Первая интересующая нас инструкция - это &lt;a href=&quot;opcode#AggReset&quot;&gt;AggReset&lt;/a&gt; at 2. Инструкция AggReset инициализирует набор сегментов как пустой набор и указывает количество слотов памяти, доступных в каждом сегменте, как P2. В этом примере каждая корзина будет содержать 3 слота памяти. Это не очевидно, но если вы внимательно посмотрите на остальную часть программы, вы сможете понять, для чего предназначен каждый из этих слотов.</target>
        </trans-unit>
        <trans-unit id="11dcba86733ec3f9c57f212488f98cc390a1b479" translate="yes" xml:space="preserve">
          <source>The first integer in the P4 integer array is the length of the array and does not become part of the permutation.</source>
          <target state="translated">Первое целое число в P4-целом массиве является длиной массива и не становится частью перестановки.</target>
        </trans-unit>
        <trans-unit id="388856185e941f1980f4fd92691075a08784c68c" translate="yes" xml:space="preserve">
          <source>The first line of the script above causes the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to read and activate the run-time loadable extension for CSV. For an application, the equivalent C-language API is &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt;. Observe that the filename extension (ex: &quot;.dll&quot; or &quot;.so&quot; or &quot;.dylib&quot;) is omitted from the extension filename. Omitting the filename extension is not required, but it helps in making the script cross-platform. SQLite will automatically append the appropriate extension.</source>
          <target state="translated">Первая строка приведенного выше сценария заставляет &lt;a href=&quot;cli&quot;&gt;оболочку командной строки&lt;/a&gt; читать и активировать загружаемое расширение времени выполнения для CSV. Для приложения эквивалентным API языка C является &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; . Обратите внимание, что расширение имени файла (например, &amp;laquo;.dll&amp;raquo;, &amp;laquo;.so&amp;raquo; или &amp;laquo;.dylib&amp;raquo;) опущено в имени файла расширения. Пропускать расширение имени файла не обязательно, но это помогает сделать скрипт кроссплатформенным. SQLite автоматически добавит соответствующее расширение.</target>
        </trans-unit>
        <trans-unit id="75252c48c68a826da51013f5fcc062daddeb6d8f" translate="yes" xml:space="preserve">
          <source>The first of the above that is found to exist and have the write and execute bits set is used. The final &quot;.&quot; fallback is important for some applications that use SQLite inside of chroot jails that do not have the standard temporary file locations available.</source>
          <target state="translated">Используется первый из вышеперечисленных,который существует и имеет набор битов для записи и выполнения.Окончательный &quot;...&quot; откат важен для некоторых приложений,использующих SQLite внутри chroot jails,которые не имеют стандартного расположения временных файлов.</target>
        </trans-unit>
        <trans-unit id="1f9a60bfbed88db253a25c41a987f86e19f4d6aa" translate="yes" xml:space="preserve">
          <source>The first page of a cell payload overflow chain. The page number is the b-tree page that contains the cell whose content has overflowed.</source>
          <target state="translated">Первая страница цепи переполнения ячеек.Номер страницы-это страница b-дерева,содержащая ячейку,содержимое которой переполнилось.</target>
        </trans-unit>
        <trans-unit id="571e717de8bab6f472a3daa4d0e34a129cf9485d" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">Первый параметр - это &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Если этот оператор является &lt;a href=&quot;lang_select&quot;&gt;оператором SELECT,&lt;/a&gt; а N-й столбец возвращенного набора результатов этого &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; является столбцом таблицы (не выражением или подзапросом), то возвращается объявленный тип столбца таблицы. Если N-й столбец набора результатов является выражением или подзапросом, возвращается NULL-указатель. Возвращаемая строка всегда имеет кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="2d95d478fea3b8287d0a6628b14c6c99e2b30bf0" translate="yes" xml:space="preserve">
          <source>The first parameter is a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If this statement is a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement and the Nth column of the returned result set of that &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; is a table column (not an expression or subquery) then the declared type of the table column is returned. If the Nth column of the result set is an expression or subquery, then a NULL pointer is returned. The returned string is always UTF-8 encoded.</source>
          <target state="translated">Первый параметр - это &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; . Если этот оператор является &lt;a href=&quot;../lang_select&quot;&gt;оператором SELECT,&lt;/a&gt; а N-й столбец возвращенного набора результатов этого &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; является столбцом таблицы (не выражением или подзапросом), то возвращается объявленный тип столбца таблицы. Если N-й столбец набора результатов является выражением или подзапросом, возвращается NULL-указатель. Возвращаемая строка всегда имеет кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="c8355444303911368f3db824744273405e752637" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">Первый параметр - это &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, к которому должна быть добавлена ​​функция SQL. Если приложение использует более одного соединения с базой данных, тогда определяемые приложением функции SQL должны быть добавлены к каждому соединению с базой данных отдельно.</target>
        </trans-unit>
        <trans-unit id="2034bce444668b7bc337245a2c547e0aff9b9fd1" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to which the SQL function is to be added. If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.</source>
          <target state="translated">Первый параметр - это &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, к которому должна быть добавлена ​​функция SQL. Если приложение использует более одного соединения с базой данных, тогда определяемые приложением функции SQL должны быть добавлены к каждому соединению с базой данных отдельно.</target>
        </trans-unit>
        <trans-unit id="02bbb4f6b68ff55742031c8b1808d80607aaa103" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;#sqlite3_context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">Первый параметр должен быть копией &lt;a href=&quot;#sqlite3_context&quot;&gt;контекста функции SQL,&lt;/a&gt; который является первым параметром процедуры обратного вызова xStep или xFinal, которая реализует агрегатную функцию.</target>
        </trans-unit>
        <trans-unit id="303b1214ac90198e86e2d6fded39de6f12728048" translate="yes" xml:space="preserve">
          <source>The first parameter must be a copy of the &lt;a href=&quot;context&quot;&gt;SQL function context&lt;/a&gt; that is the first parameter to the xStep or xFinal callback routine that implements the aggregate function.</source>
          <target state="translated">Первый параметр должен быть копией &lt;a href=&quot;context&quot;&gt;контекста функции SQL,&lt;/a&gt; который является первым параметром процедуры обратного вызова xStep или xFinal, которая реализует агрегатную функцию.</target>
        </trans-unit>
        <trans-unit id="51bc3b9167a1367dcb303b210930c2e99a40f80a" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">Первый параметр, переданный в функцию обратного вызова при ее вызове, является копией третьего параметра, переданного в sqlite3_wal_hook () при регистрации обратного вызова. Второй - это копия дескриптора базы данных. Третий параметр - это имя базы данных, в которую была произведена запись - либо &amp;laquo;main&amp;raquo;, либо имя базы данных с &lt;a href=&quot;../lang_attach&quot;&gt;функцией ATTACH&lt;/a&gt; . Четвертый параметр - это количество страниц в файле журнала упреждающей записи, включая те, которые были только что зафиксированы.</target>
        </trans-unit>
        <trans-unit id="8448fcb45b7f072723f93590a80d37aef6a727c3" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook() when registering the callback. The second is a copy of the database handle. The third parameter is the name of the database that was written to - either &quot;main&quot; or the name of an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database. The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.</source>
          <target state="translated">Первый параметр, переданный в функцию обратного вызова при ее вызове, является копией третьего параметра, переданного в sqlite3_wal_hook () при регистрации обратного вызова. Второй - это копия дескриптора базы данных. Третий параметр - это имя базы данных, в которую была произведена запись - либо &amp;laquo;main&amp;raquo;, либо имя базы данных с &lt;a href=&quot;lang_attach&quot;&gt;функцией ATTACH&lt;/a&gt; . Четвертый параметр - это количество страниц в файле журнала упреждающей записи, включая те, которые были только что зафиксированы.</target>
        </trans-unit>
        <trans-unit id="114b67e4b3a89669211882b27d3030f929c0b812" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">Первый параметр обратного вызова авторизатора - это копия третьего параметра интерфейса sqlite3_set_authorizer (). Второй параметр обратного вызова - это целочисленный &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;код действия,&lt;/a&gt; который указывает конкретное действие, которое необходимо разрешить. Параметры с третьего по шестой для обратного вызова являются либо указателями NULL, либо строками с нулевым завершением, которые содержат дополнительные сведения о действии, которое необходимо разрешить. Приложения всегда должны быть готовы встретить нулевой указатель в любом из третьего-шестого параметров обратного вызова авторизации.</target>
        </trans-unit>
        <trans-unit id="031900d436ad256c6483a02e204c32e4df2ca84e" translate="yes" xml:space="preserve">
          <source>The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer() interface. The second parameter to the callback is an integer &lt;a href=&quot;c_alter_table&quot;&gt;action code&lt;/a&gt; that specifies the particular action to be authorized. The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized. Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.</source>
          <target state="translated">Первый параметр обратного вызова авторизатора - это копия третьего параметра интерфейса sqlite3_set_authorizer (). Второй параметр обратного вызова - это целочисленный &lt;a href=&quot;c_alter_table&quot;&gt;код действия,&lt;/a&gt; который указывает конкретное действие, которое необходимо разрешить. Параметры с третьего по шестой для обратного вызова являются либо указателями NULL, либо строками с нулевым завершением, которые содержат дополнительные сведения о действии, которое необходимо разрешить. Приложения всегда должны быть готовы встретить нулевой указатель в любом из третьего-шестого параметров обратного вызова авторизации.</target>
        </trans-unit>
        <trans-unit id="1622094cd4d4c27ce242fb95c194e4ab11274192" translate="yes" xml:space="preserve">
          <source>The first parameter to these interfaces (hereafter referred to as F) must be one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c4884990e25d1601d544fb2189fcbf8e2210be" translate="yes" xml:space="preserve">
          <source>The first section introduces the concept of an SQL foreign key by example and defines the terminology used for the remainder of the document. Section 2 describes the steps an application must take in order to enable foreign key constraints in SQLite (it is disabled by default). The next section, section 3, describes the indexes that the user must create in order to use foreign key constraints, and those that should be created in order for foreign key constraints to function efficiently. Section 4 describes the advanced foreign key related features supported by SQLite and section 5 describes the way the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands are enhanced to support foreign key constraints. Finally, section 6 enumerates the missing features and limits of the current implementation.</source>
          <target state="translated">Первый раздел представляет концепцию внешнего ключа SQL на примере и определяет терминологию, используемую в оставшейся части документа. В разделе 2 описаны шаги, которые должно предпринять приложение, чтобы включить ограничения внешнего ключа в SQLite (по умолчанию он отключен). В следующем разделе, разделе 3, описаны индексы, которые пользователь должен создать, чтобы использовать ограничения внешнего ключа, и индексы, которые должны быть созданы для эффективного функционирования ограничений внешнего ключа. В разделе 4 описаны расширенные функции, связанные с внешним ключом, поддерживаемые SQLite, а в разделе 5 описывается способ улучшения команд &lt;a href=&quot;lang_altertable&quot;&gt;ALTER&lt;/a&gt; и &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; для поддержки ограничений внешнего ключа. Наконец, в разделе 6 перечислены недостающие функции и ограничения текущей реализации.</target>
        </trans-unit>
        <trans-unit id="6abe8a139c8044b273ba74ec6b9c2e3f141ecabe" translate="yes" xml:space="preserve">
          <source>The first set of three values corresponds to the left-most column of the table (column 0) and the left-most matchable phrase in the query (phrase 0). If the table has more than one column, the second set of three values in the output array correspond to phrase 0 and column 1. Followed by phrase 0, column 2 and so on for all columns of the table. And so on for phrase 1, column 0, then phrase 1, column 1 etc. In other words, the data for occurrences of phrase</source>
          <target state="translated">Первый набор из трех значений соответствует самому левому столбцу таблицы (столбец 0)и самому левому совпадению фраз в запросе (фраза 0).Если таблица имеет более одного столбца,то второй набор из трех значений в выходном массиве соответствует фразе 0 и столбцу 1.Далее следует фраза 0,столбец 2 и т.д.для всех столбцов таблицы.И так далее для фразы 1,столбца 0,затем фразы 1,столбца 1 и так далее.Другими словами,данные для вхождения фразы</target>
        </trans-unit>
        <trans-unit id="b88b9c17da99b9d9285ae75db888dfa7bebfc06c" translate="yes" xml:space="preserve">
          <source>The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format. If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text() interface is used to extract the value) then an automatic type conversion is performed.</source>
          <target state="translated">Первые шесть интерфейсов (_blob,_double,_int,_int64,_text и _text16)каждый возвращает значение столбца результата в определенном формате данных.Если столбец результата изначально находится не в запрашиваемом формате (например,если запрос возвращает целое число,но для извлечения значения используется интерфейс sqlite3_column_text()),то выполняется автоматическое приведение типа.</target>
        </trans-unit>
        <trans-unit id="67231aa738e6314e6f80285f8fe72b39964cf222" translate="yes" xml:space="preserve">
          <source>The first six modifiers (1 through 6) simply add the specified amount of time to the date and time specified by the preceding timestring and modifiers. The 's' character at the end of the modifier names is optional. Note that &quot;&amp;plusmn;NNN months&quot; works by rendering the original date into the YYYY-MM-DD format, adding the &amp;plusmn;NNN to the MM month value, then normalizing the result. Thus, for example, the data 2001-03-31 modified by '+1 month' initially yields 2001-04-31, but April only has 30 days so the date is normalized to 2001-05-01. A similar effect occurs when the original date is February 29 of a leapyear and the modifier is &amp;plusmn;N years where N is not a multiple of four.</source>
          <target state="translated">Первые шесть модификаторов (с 1 по 6) просто добавляют указанное количество времени к дате и времени, указанным предыдущей временной строкой и модификаторами. Символ 's' в конце имен модификаторов необязателен. Обратите внимание, что &amp;laquo;&amp;plusmn; NNN месяцев&amp;raquo; работает путем преобразования исходной даты в формат ГГГГ-ММ-ДД, добавления &amp;plusmn; NNN к значению месяца ММ и последующей нормализации результата. Так, например, данные 2001-03-31, измененные на &amp;laquo;+1 месяц&amp;raquo;, первоначально дают 2001-04-31, но в апреле есть только 30 дней, поэтому дата нормализуется до 2001-05-01. Аналогичный эффект возникает, когда исходная дата - 29 февраля високосного года, а модификатор - &amp;plusmn; N лет, где N не кратно четырем.</target>
        </trans-unit>
        <trans-unit id="de80fd15e7d30919dde63ea2e434aa9d73b98e29" translate="yes" xml:space="preserve">
          <source>The first step toward dealing with a hot journal is to obtain an exclusive lock on the database file. This prevents two or more processes from trying to rollback the same hot journal at the same time.</source>
          <target state="translated">Первый шаг к работе с горячим журналом-получение эксклюзивной блокировки на файле базы данных.Это не позволяет двум или более процессам пытаться откатить один и тот же &quot;горячий&quot; журнал одновременно.</target>
        </trans-unit>
        <trans-unit id="6d5dce142e8b6c56f2485efc4da630bd41e2b246" translate="yes" xml:space="preserve">
          <source>The first step toward reading from the database file is obtaining a shared lock on the database file. A &quot;shared&quot; lock allows two or more database connections to read from the database file at the same time. But a shared lock prevents another database connection from writing to the database file while we are reading it. This is necessary because if another database connection were writing to the database file at the same time we are reading from the database file, we might read some data before the change and other data after the change. This would make it appear as if the change made by the other process is not atomic.</source>
          <target state="translated">Первый шаг к чтению из файла базы данных-получение общей блокировки на файле базы данных.Общий&quot; замок позволяет одновременно считывать из файла базы данных два или более соединения с БД.Но общий замок не позволяет другому соединению с БД записать в файл БД,пока мы его читаем.Это необходимо,потому что если бы другое подключение к БД записывалось в файл БД в то же самое время,когда мы читаем из файла БД,мы могли бы прочитать некоторые данные до изменения и другие данные после изменения.При этом будет выглядеть так,как будто изменение,сделанное другим процессом,не является атомарным.</target>
        </trans-unit>
        <trans-unit id="728a2c812c40e366db04b46879d8327a7463b66e" translate="yes" xml:space="preserve">
          <source>The first string or bareword in a column declaration is the column name. It is an error to attempt to name an fts5 table column &quot;rowid&quot; or &quot;rank&quot;, or to assign the same name to a column as is used by the table itself. This is not supported.</source>
          <target state="translated">Первая строка или пустое слово в декларации столбца-это имя столбца.Ошибкой является попытка назвать столбец fts5 таблицы &quot;rowid&quot; или &quot;rank&quot;,или присвоить столбцу то же имя,что используется самой таблицей.Это не поддерживается.</target>
        </trans-unit>
        <trans-unit id="15aebb5889bf7eacd8a14d41dd89f37206fa7a06" translate="yes" xml:space="preserve">
          <source>The first subquery above is constant with respect to the outer query. The value for the first subquery can be computed once and then reused for each row of the outer SELECT. The second subquery, however, is &quot;CORRELATED&quot;. The value of the second subquery changes depending on values in the current row of the outer query. Hence, the second subquery must be run once for each output row in the outer SELECT.</source>
          <target state="translated">Первый подзапрос,приведенный выше,является постоянным по отношению к внешнему запросу.Значение для первого подзапроса может быть вычислено один раз,а затем повторно использовано для каждой строки внешнего SELECT.Второй подзапрос,однако,является &quot;ИСПРАВЛЕННЫМ&quot;.Значение второго подзапроса изменяется в зависимости от значений в текущей строке внешнего запроса.Следовательно,второй подзапрос должен быть выполнен один раз для каждой выходной строки внешнего SELECT.</target>
        </trans-unit>
        <trans-unit id="c31bdf542d6f05cfa5241d61c80e5148ec82df02" translate="yes" xml:space="preserve">
          <source>The first term stored on each node (&quot;Term 1&quot; in the figure above) is stored verbatim. Each subsequent term is prefix-compressed with respect to its predecessor. Terms are stored within a page in sorted (memcmp) order.</source>
          <target state="translated">Первый термин,сохраненный в каждом узле (&quot;Термин 1&quot; на рисунке выше),сохраняется дословно.Каждый последующий термин сжимается префиксом по отношению к своему предшественнику.Термины хранятся внутри страницы в отсортированном (в формате memcmp)порядке.</target>
        </trans-unit>
        <trans-unit id="7a099bb22daac790c8e16aa7a285108628e1197d" translate="yes" xml:space="preserve">
          <source>The first thing that happens is that we open the table being indexed for reading. In order to construct an index for a table, we have to know what is in that table. The index has already been opened for writing using cursor 0 by instructions 3 and 4.</source>
          <target state="translated">Первое,что произойдет,это то,что мы откроем таблицу,индексируемую для чтения.Чтобы построить индекс для таблицы,мы должны знать,что находится в этой таблице.Индекс уже открыт для записи курсором 0 по инструкциям 3 и 4.</target>
        </trans-unit>
        <trans-unit id="5eb1752f78007fa49f66b7f76488ea011879482b" translate="yes" xml:space="preserve">
          <source>The first time that any SQLite process attempts to access the database file, it obtains a shared lock as described in &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;section 3.2&lt;/a&gt; above. But then it notices that there is a rollback journal file present. SQLite then checks to see if the rollback journal is a &quot;hot journal&quot;. A hot journal is a rollback journal that needs to be played back in order to restore the database to a sane state. A hot journal only exists when an earlier process was in the middle of committing a transaction when it crashed or lost power.</source>
          <target state="translated">В первый раз, когда какой-либо процесс SQLite пытается получить доступ к файлу базы данных, он получает общую блокировку, как описано в &lt;a href=&quot;https://sqlite.org/section_3_2&quot;&gt;разделе 3.2&lt;/a&gt; выше. Но затем он замечает наличие файла журнала отката. Затем SQLite проверяет, является ли журнал отката &amp;laquo;горячим журналом&amp;raquo;. Горячий журнал - это журнал отката, который необходимо воспроизвести, чтобы восстановить базу данных до нормального состояния. Горячий журнал существует только в том случае, если более ранний процесс находился в процессе фиксации транзакции, когда он потерпел сбой или потерял питание.</target>
        </trans-unit>
        <trans-unit id="e68a1d44352d39217814d6bf160a385833864476" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N bytes of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a42cd86f3f8e7c9fddbcba13c3c1c638314931" translate="yes" xml:space="preserve">
          <source>The first time the sqlite3_aggregate_context(C,N) routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory. On second and subsequent calls to sqlite3_aggregate_context() for the same aggregate function instance, the same buffer is returned. Sqlite3_aggregate_context() is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked. When no rows match an aggregate query, the xStep() callback of the aggregate function implementation is never called and xFinal() is called exactly once. In those cases, sqlite3_aggregate_context() might be called for the first time from within xFinal().</source>
          <target state="translated">При первом вызове рутины sqlite3_aggregate_context(C,N)для конкретной агрегатной функции SQLite выделяет N памяти,обнуляет эту память и возвращает указатель на новую память.При втором и последующих вызовах sqlite3_aggregate_context()для того же экземпляра агрегатной функции возвращается тот же буфер.Обычно функция Sqlite3_aggregate_context()вызывается один раз при каждом вызове функции xStep,а затем последний раз при вызове функции xFinal.Когда ни одна строка не совпадает с агрегированным запросом,обратный вызов xStep()реализации агрегированной функции никогда не вызывается,а xFinal()вызывается ровно один раз.В этих случаях sqlite3_aggregate_context()может быть вызвана впервые из xFinal().</target>
        </trans-unit>
        <trans-unit id="33a73e33477151458e48dab8a4d76f2a383719c8" translate="yes" xml:space="preserve">
          <source>The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) cause sqlite3_mutex_alloc() to create a new mutex. The new mutex is recursive when SQLITE_MUTEX_RECURSIVE is used but not necessarily so when SQLITE_MUTEX_FAST is used. The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does not want to. SQLite will only request a recursive mutex in cases where it really needs one. If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST.</source>
          <target state="translated">Первые две константы (SQLITE_MUTEX_FAST и SQLITE_MUTEX_RECURSIVE)вызывают sqlite3_mutex_alloc()для создания нового мьютекса.Новый мьютекс является рекурсивным при использовании SQLITE_MUTEX_RECURSIVE,но не обязательно при использовании SQLITE_MUTEX_FAST.В реализации мьютекса нет необходимости делать различие между SQLITE_MUTEX_RECURSIVE и SQLITE_MUTEX_FAST,если он этого не хочет.SQLite будет запрашивать рекурсивный мьютекс только в тех случаях,когда он действительно нужен.Если на хостовой платформе доступна более быстрая не рекурсивная реализация мьютекса,то подсистема мьютекса может вернуть такой мьютекс в ответ на запрос SQLITE_MUTEX_FAST.</target>
        </trans-unit>
        <trans-unit id="3ad84c4124333660ac2ec2d4b3b96a74793fd127" translate="yes" xml:space="preserve">
          <source>The first two elements in the list above, the associated</source>
          <target state="translated">Первые два элемента списка выше,связанные с</target>
        </trans-unit>
        <trans-unit id="9de36623b06dcc8a12dabc9fe8d69bf46f2afdab" translate="yes" xml:space="preserve">
          <source>The first two instructions in the VDBE program for our query are concerned with setting up values for &lt;b&gt;azColumn&lt;/b&gt;. The &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; instructions tell the VDBE what values to fill in for each element of the &lt;b&gt;azColumnName[]&lt;/b&gt; array. Every query will begin with one ColumnName instruction for each column in the result, and there will be a matching Column instruction for each one later in the query.</source>
          <target state="translated">Первые две инструкции в программе VDBE для нашего запроса связаны с настройкой значений для &lt;b&gt;azColumn&lt;/b&gt; . В &lt;a href=&quot;opcode#ColumnName&quot;&gt;ColumnName&lt;/a&gt; инструкции сказать VDBE , какие значения для заполнения для каждого элемента &lt;b&gt;azColumnName []&lt;/b&gt; массива. Каждый запрос будет начинаться с одной инструкции ColumnName для каждого столбца в результате, и позже в запросе будет соответствующая инструкция ColumnName для каждого столбца.</target>
        </trans-unit>
        <trans-unit id="80f7eaccbd1b0c6d2fde7b56494766bcf2304eb6" translate="yes" xml:space="preserve">
          <source>The first two query examples illustrate a kind of template that every SELECT program will follow. Basically, we have:</source>
          <target state="translated">Первые два примера запросов иллюстрируют вид шаблона,которому будет следовать каждая программа SELECT.В принципе,есть:</target>
        </trans-unit>
        <trans-unit id="c636087069b26e9346b965d8bb5b5d8294795344" translate="yes" xml:space="preserve">
          <source>The first value in the array of integer values corresponds to the leftmost column of the table (column 0) and the first phrase in the query (phrase 0). The values corresponding to other column/phrase combinations may be located using the following formula:</source>
          <target state="translated">Первое значение в массиве целочисленных значений соответствует самому левому столбцу таблицы (столбец 0)и первой фразе запроса (фраза 0).Значения,соответствующие другим комбинациям столбец/фраза,могут быть расположены по следующей формуле:</target>
        </trans-unit>
        <trans-unit id="61029d8449643ad48e743f1026fb94f8a1ed1222" translate="yes" xml:space="preserve">
          <source>The first, or only, integer is the blockid that corresponds to the interior node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always an interior node.</source>
          <target state="translated">Первое или единственное целое число-это блокировка,соответствующая внутреннему узлу с наибольшей блокировкой,принадлежащей этому сегменту b-дерева.Или ноль,если весь сегмент b-дерева укладывается в корневой узел.Если он существует,то этот узел всегда является внутренним узлом.</target>
        </trans-unit>
        <trans-unit id="c0ebe13b31f8942f70d44d11a35f84a9529666cd" translate="yes" xml:space="preserve">
          <source>The fix in the 3.25.0 release for the endless-loop in the byte-code associated with the ORDER BY LIMIT optimization did not work for some queries involving window functions. An additional correction is required. Ticket &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</source>
          <target state="translated">Исправление в выпуске 3.25.0 для бесконечного цикла в байтовом коде, связанное с оптимизацией ORDER BY LIMIT, не работало для некоторых запросов, связанных с оконными функциями. Требуется дополнительная коррекция. Билет &lt;a href=&quot;https://sqlite.org/src/info/510cde277783b5fb&quot;&gt;510cde277783b5fb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2032be06ad1313d23c4aa0f2d29e1f73447dfd8" translate="yes" xml:space="preserve">
          <source>The fix to the previous bug uncovered a deadlock which was also fixed.</source>
          <target state="translated">Исправление предыдущей ошибки обнаружило тупик,который также был исправлен.</target>
        </trans-unit>
        <trans-unit id="8197368f601d93edb14a348de0bf212d3c1bcf51" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">Аргументом flags для xAccess () может быть &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; для проверки существования файла или &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; для проверки, доступен ли файл для чтения и записи, или &lt;a href=&quot;#SQLITE_ACCESS_EXISTS&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; для проверки, по крайней мере, доступен для чтения файл. Флаг SQLITE_ACCESS_READ фактически никогда не используется и не реализован во встроенных VFS SQLite. Файл называется вторым аргументом и может быть каталогом. Метод xAccess возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или ненулевого кода ошибки, если есть ошибка ввода-вывода или если имя файла, указанное во втором аргументе, является недопустимым. Если возвращается SQLITE_OK, то в * pResOut записывается ненулевое или нулевое значение, чтобы указать, доступен ли файл.</target>
        </trans-unit>
        <trans-unit id="ee0102cf2398a56ff989592f19a055847f5dc920" translate="yes" xml:space="preserve">
          <source>The flags argument to xAccess() may be &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to test for the existence of a file, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to test whether a file is readable and writable, or &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to test whether a file is at least readable. The SQLITE_ACCESS_READ flag is never actually used and is not implemented in the built-in VFSes of SQLite. The file is named by the second argument and can be a directory. The xAccess method returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or some non-zero error code if there is an I/O error or if the name of the file given in the second argument is illegal. If SQLITE_OK is returned, then non-zero or zero is written into *pResOut to indicate whether or not the file is accessible.</source>
          <target state="translated">Аргументом flags для xAccess () может быть &lt;a href=&quot;c_access_exists&quot; id=&quot;sqlite3vfsxaccess&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; для проверки существования файла или &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; для проверки, доступен ли файл для чтения и записи, или &lt;a href=&quot;c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; для проверки, по крайней мере, доступен для чтения файл. Флаг SQLITE_ACCESS_READ фактически никогда не используется и не реализован во встроенных VFS SQLite. Файл называется вторым аргументом и может быть каталогом. Метод xAccess возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или ненулевого кода ошибки, если есть ошибка ввода-вывода или если имя файла, указанное во втором аргументе, является недопустимым. Если возвращается SQLITE_OK, то в * pResOut записывается ненулевое или нулевое значение, чтобы указать, доступен ли файл.</target>
        </trans-unit>
        <trans-unit id="d9f0c284ad1c57f7e5da616991af768f686e341f" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">Аргумент flags для xOpen () включает все биты, установленные в аргументе flags для &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . Или, если используется &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , тогда flags включает как минимум &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . Если xOpen () открывает файл только для чтения, он устанавливает * pOutFlags для включения &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . Другие биты в * pOutFlags могут быть установлены.</target>
        </trans-unit>
        <trans-unit id="f5198d48ad55972f3bafe448a5f83115c01462b7" translate="yes" xml:space="preserve">
          <source>The flags argument to xOpen() includes all bits set in the flags argument to &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. Or if &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; is used, then flags includes at least &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set.</source>
          <target state="translated">Аргумент flags для xOpen () включает все биты, установленные в аргументе flags для &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; . Или, если используется &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; или &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , тогда flags включает как минимум &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . Если xOpen () открывает файл только для чтения, он устанавливает * pOutFlags для включения &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . Другие биты в * pOutFlags могут быть установлены.</target>
        </trans-unit>
        <trans-unit id="7bc004618637404d4a4bd35b24cc91bd411a3086" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">Аргумент flags для xSync может быть одним из &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; или &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; . Первый выбор - это обычная fsync (). Второй вариант - это полная синхронизация в стиле Mac OS X. &lt;a href=&quot;#SQLITE_SYNC_DATAONLY&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; флаг может быть ORed , чтобы указать , что только данные файла , а не его потребности индексных дескрипторов , которые будут синхронизироваться.</target>
        </trans-unit>
        <trans-unit id="99d3aea2b8c0b18767851d7c8d3921e4603f6ed1" translate="yes" xml:space="preserve">
          <source>The flags argument to xSync may be one of &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; or &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt;. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.</source>
          <target state="translated">Аргумент flags для xSync может быть одним из &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; или &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; . Первый выбор - это обычная fsync (). Второй вариант - это полная синхронизация в стиле Mac OS X. &lt;a href=&quot;c_sync_dataonly&quot;&gt;SQLITE_SYNC_DATAONLY&lt;/a&gt; флаг может быть ORed , чтобы указать , что только данные файла , а не его потребности индексных дескрипторов , которые будут синхронизироваться.</target>
        </trans-unit>
        <trans-unit id="c377d5a3884469a39150e12bd3af49c973f2fad1" translate="yes" xml:space="preserve">
          <source>The floating-point to text conversion subfunction for the built-in printf() is limited in precision to 16 significant digits or 26 significant digits if the &quot;!&quot; alternate-form-2 flag is used. Every IEEE-754 double can be represented exactly as a decimal floating-point value, but some doubles require more than 16 or 26 significant digits.</source>
          <target state="translated">Подфункция преобразования текста с плавающей точкой в текст для встроенной функции printf()ограничена по точности 16 значащими цифрами или 26 значащими цифрами,если используется флаг &quot;!&quot; переменной формы-2.Каждый двойник IEEE-754 может быть точно представлен в виде десятичной запятой с плавающей точкой,но некоторые двойники требуют более 16 или 26 значащих цифр.</target>
        </trans-unit>
        <trans-unit id="68fce5c170ab1896511f13fd3e82f411098f2695" translate="yes" xml:space="preserve">
          <source>The folder returned by the GetTempPath() system interface.</source>
          <target state="translated">Папка,возвращаемая системным интерфейсом GetTempPath().</target>
        </trans-unit>
        <trans-unit id="4f48bdf9b1dfd94aea260fd19b610d7cf9d72be5" translate="yes" xml:space="preserve">
          <source>The folder set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="translated">Папка, заданная &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; или глобальной переменной &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f393fa7f5f393cd220ff4a7a6a7ccbac66e5676" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; cartoon is an exaggeration, yet hits close to home:</source>
          <target state="translated">Следующий мультфильм &lt;a href=&quot;https://xkcd.com/1597/&quot;&gt;https://xkcd.com/1597/&lt;/a&gt; является преувеличением, но близок к нему:</target>
        </trans-unit>
        <trans-unit id="40de557d79eeab5be4528c0beef95dcb1a5f7ef4" translate="yes" xml:space="preserve">
          <source>The following RBU database schema may be used:</source>
          <target state="translated">Может использоваться следующая схема базы данных RBU:</target>
        </trans-unit>
        <trans-unit id="ae49ebf9365c52bbf37afc8c396e0cba8b2d31d3" translate="yes" xml:space="preserve">
          <source>The following SQL demonstrates how SQLite uses column affinity to do type conversions when values are inserted into a table.</source>
          <target state="translated">Следующий SQL демонстрирует,как SQLite использует сродство столбцов для приведения типов,когда значения вставляются в таблицу.</target>
        </trans-unit>
        <trans-unit id="b7479fafb0c600f993e6250d871980ae79cbdf35" translate="yes" xml:space="preserve">
          <source>The following SQLite command-line session illustrates the effect of the foreign key constraint added to the</source>
          <target state="translated">Следующая сессия командной строки SQLite иллюстрирует эффект ограничения по внешнему ключу,добавленному к</target>
        </trans-unit>
        <trans-unit id="1f8a8aec572c42d81f9a9d30dc36ba0c1a7ca331" translate="yes" xml:space="preserve">
          <source>The following additional compile-time options are recommended in order to provide a full-featured command-line shell:</source>
          <target state="translated">Для обеспечения полнофункциональной оболочки командной строки рекомендуются следующие дополнительные опции времени компиляции:</target>
        </trans-unit>
        <trans-unit id="e661fc6daecc53fc88e2038803ed3bcb13092e93" translate="yes" xml:space="preserve">
          <source>The following additional syntax restrictions apply to UPDATE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">Следующие дополнительные ограничения синтаксиса применяются к операторам UPDATE, которые встречаются в теле оператора &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a78308c3e0962720a3b6c6b2c92b551ac030e31" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">Ниже приведены допустимые значения для 6-го аргумента (аргумент &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;F)&lt;/a&gt; интерфейса sqlite3_deserialize (D, S, P, N, M, F) .</target>
        </trans-unit>
        <trans-unit id="b9076a86669fb7bce220c5cc2398686ebb071016" translate="yes" xml:space="preserve">
          <source>The following are allowed values for 6th argument (the F argument) to the &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,P,N,M,F)&lt;/a&gt; interface.</source>
          <target state="translated">Ниже приведены допустимые значения для 6-го аргумента (аргумент &lt;a href=&quot;deserialize&quot;&gt;F)&lt;/a&gt; интерфейса sqlite3_deserialize (D, S, P, N, M, F) .</target>
        </trans-unit>
        <trans-unit id="a59459d6632d0bbc1149f827b602fb3d835358c8" translate="yes" xml:space="preserve">
          <source>The following are examples of disabling the built-in protection mechanisms of SQLite:</source>
          <target state="translated">Ниже приведены примеры отключения встроенных механизмов защиты SQLite:</target>
        </trans-unit>
        <trans-unit id="80d00e742a47603d638009e13703b23c42a0d91f" translate="yes" xml:space="preserve">
          <source>The following are other VFS implementations available in the public SQLite source tree:</source>
          <target state="translated">Ниже приведены другие реализации VFS,доступные в публичном дереве исходных текстов SQLite:</target>
        </trans-unit>
        <trans-unit id="ec123026fdd8e1c2278a5f9715d6939ab0dbeb46" translate="yes" xml:space="preserve">
          <source>The following are the available OMIT options:</source>
          <target state="translated">Ниже приведены доступные опции OMIT:</target>
        </trans-unit>
        <trans-unit id="8fa3cecc90ff41687bc039d2f339ed203679e422" translate="yes" xml:space="preserve">
          <source>The following block contains a summary of the FTS query syntax in BNF form. A detailed explanation follows.</source>
          <target state="translated">Следующий блок содержит краткое изложение синтаксиса запроса FTS в форме BNF.Ниже приводится подробное объяснение.</target>
        </trans-unit>
        <trans-unit id="9eacb2386777a09c397574d603b9f7b4a178b7c8" translate="yes" xml:space="preserve">
          <source>The following block contains an example of calling the fts3_tokenizer() function from C code:</source>
          <target state="translated">В следующем блоке приведен пример вызова функции fts3_tokenizer()из кода на языке Си:</target>
        </trans-unit>
        <trans-unit id="8a513f3e74d7cb1dc9f72503b5eb2053d246b6ad" translate="yes" xml:space="preserve">
          <source>The following block contains examples that use the offsets function.</source>
          <target state="translated">В следующем блоке приведены примеры использования функции смещения.</target>
        </trans-unit>
        <trans-unit id="5c334635414a3c37311f7280f25331d2da05c0d0" translate="yes" xml:space="preserve">
          <source>The following chart shows the substitution types supported by SQLite:</source>
          <target state="translated">На следующем графике показаны типы замен,поддерживаемые SQLite:</target>
        </trans-unit>
        <trans-unit id="16f175b629dac9ff34c51ebace5610e8bb2a6ee9" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that do not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c06c8d896e801657db8f70d5a5bd2960e6843e64" translate="yes" xml:space="preserve">
          <source>The following compile-time options are recommended for applications that are able to use them, in order to minimized the number of CPU cycles and the bytes of memory used by SQLite. Not all of these compile-time options are usable by every application. For example, the SQLITE_THREADSAFE=0 option is only usable by applications that never access SQLite from more than one thread at a time. And the SQLITE_OMIT_PROGRESS_CALLBACK option is only usable by applications that doe not use the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface. And so forth.</source>
          <target state="translated">Следующие параметры времени компиляции рекомендуются для приложений, которые могут их использовать, чтобы минимизировать количество циклов процессора и байтов памяти, используемых SQLite. Не все эти параметры времени компиляции могут использоваться каждым приложением. Например, параметр SQLITE_THREADSAFE = 0 может использоваться только приложениями, которые никогда не обращаются к SQLite из более чем одного потока одновременно. А параметр SQLITE_OMIT_PROGRESS_CALLBACK может использоваться только приложениями, которые не используют интерфейс &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; . И так далее.</target>
        </trans-unit>
        <trans-unit id="1f053eef3c13d51d862b4f23cc04af6f84e75626" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">Следующие константы можно использовать для параметра &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;T&lt;/a&gt; интерфейса sqlite3_stmt_scanstatus (S, X, T, V) . Каждая константа обозначает разные метрики, которые должна возвращать sqlite3_stmt_scanstatus ().</target>
        </trans-unit>
        <trans-unit id="42e5a30e943fe484b45c04468e002affa80c1a88" translate="yes" xml:space="preserve">
          <source>The following constants can be used for the T parameter to the &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus(S,X,T,V)&lt;/a&gt; interface. Each constant designates a different metric for sqlite3_stmt_scanstatus() to return.</source>
          <target state="translated">Следующие константы можно использовать для параметра &lt;a href=&quot;stmt_scanstatus&quot;&gt;T&lt;/a&gt; интерфейса sqlite3_stmt_scanstatus (S, X, T, V) . Каждая константа обозначает разные метрики, которые должна возвращать sqlite3_stmt_scanstatus ().</target>
        </trans-unit>
        <trans-unit id="0dd0f222abc9f123e613d4dc8f011601915507ab" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree interior (non-leaf) node.</source>
          <target state="translated">На следующем рисунке показан формат сегмента b-дерева внутреннего (нелистового)узла.</target>
        </trans-unit>
        <trans-unit id="24519f5efb1b482cdcbf663c45ec684bda267ab2" translate="yes" xml:space="preserve">
          <source>The following diagram depicts the format of a segment b-tree leaf node.</source>
          <target state="translated">На следующей диаграмме представлен формат узла сегмента b-деревянного листа.</target>
        </trans-unit>
        <trans-unit id="d2d809dec5a64a655b9636ca71424601eda3c8d0" translate="yes" xml:space="preserve">
          <source>The following example code illustrates the techniques described above.</source>
          <target state="translated">Следующий пример кода иллюстрирует методы,описанные выше.</target>
        </trans-unit>
        <trans-unit id="54bdf2a30ded538a716ed8a4baee084a78f8a312" translate="yes" xml:space="preserve">
          <source>The following example creates a new SQL function named &quot;hex&quot; that converts its numeric argument in to a hexadecimal encoded string:</source>
          <target state="translated">В следующем примере создается новая SQL-функция под названием &quot;hex&quot;,которая преобразует свой числовой аргумент в шестнадцатеричную закодированную строку:</target>
        </trans-unit>
        <trans-unit id="9d4eb7545f22068db9db1145bb2583cae1439f33" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the effect of the various forms of the EXCLUDE clause:</source>
          <target state="translated">Следующий пример демонстрирует действие различных форм клаузулы EXCLUDE:</target>
        </trans-unit>
        <trans-unit id="3fb64142e08ab04e58bc3d16cc93b9564bb653f2" translate="yes" xml:space="preserve">
          <source>The following example illustrates precedence of operators using the standard query syntax:</source>
          <target state="translated">Следующий пример иллюстрирует приоритет операторов,использующих стандартный синтаксис запроса:</target>
        </trans-unit>
        <trans-unit id="33e08656a40dfd68bcb2d6194c63e1be80dcd4d4" translate="yes" xml:space="preserve">
          <source>The following example illustrates the above. The expressions &quot;docs&quot;, &quot;docs.docs&quot; and &quot;main.docs.docs&quot; all refer to column &quot;docs&quot;. However, the expression &quot;main.docs&quot; does not refer to any column. It could be used to refer to a table, but a table name is not allowed in the context in which it is used below.</source>
          <target state="translated">Следующий пример иллюстрирует вышеизложенное.Выражения &quot;docs&quot;,&quot;docs.docs&quot; и &quot;main.docs.docs&quot; относятся к колонке &quot;docs&quot;.Однако,выражение &quot;main.docs&quot; не относится ни к одной из колонок.Оно может быть использовано для ссылки на таблицу,но имя таблицы не разрешается в контексте,в котором оно используется ниже.</target>
        </trans-unit>
        <trans-unit id="6318f87943b573664a21e50213cf281e74663a27" translate="yes" xml:space="preserve">
          <source>The following example illustrates the behaviour of the five ranking functions - row_number(), rank(), dense_rank(), percent_rank() and cume_dist().</source>
          <target state="translated">Следующий пример иллюстрирует поведение пяти ранжирующих функций-row_number(),rank(),dense_rank(),percent_rank()и cume_dist().</target>
        </trans-unit>
        <trans-unit id="fd2f5de221e0f758d71eb8931f8c7e719ace6200" translate="yes" xml:space="preserve">
          <source>The following example illustrates the effect of using a deferred foreign key constraint.</source>
          <target state="translated">Следующий пример иллюстрирует эффект использования отложенного иностранного ключа.</target>
        </trans-unit>
        <trans-unit id="21740a6dff76788fbc521cbbbedbec453f6795d5" translate="yes" xml:space="preserve">
          <source>The following example uses the sumint() function implemented by the above C code. For each row, the window consists of the preceding row (if any), the current row and the following row (again, if any):</source>
          <target state="translated">В следующем примере используется функция sumint(),реализованная в приведенном выше коде на языке Си.Для каждой строки окно состоит из предыдущей (если таковая имеется),текущей и следующей строки (опять же,если таковая имеется):</target>
        </trans-unit>
        <trans-unit id="9b577d330901567bab085337ea84d2a43135e876" translate="yes" xml:space="preserve">
          <source>The following example will better illustrate the use of SQLITE_CONSTRAINT as a return value from xBestIndex:</source>
          <target state="translated">Следующий пример лучше проиллюстрирует использование SQLITE_CONSTRAINT в качестве возвращаемого значения из xBestIndex:</target>
        </trans-unit>
        <trans-unit id="3f5880fbaaf652f0861c35b2ed9bf834e8800e30" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">Следующие флаги могут быть переданы через 4-й параметр &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; и &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dcb818ec6ae695589b5e698d66cbb55415f5689e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 4th parameter to &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt;:</source>
          <target state="translated">Следующие флаги могут быть переданы через 4-й параметр &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2&lt;/a&gt; и &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_start_v2_strm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="eaf06e6487557d77e67f76618b64eb4b39aae85e" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">Следующие флаги могут передаваться через 9-й параметр в &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; и &lt;a href=&quot;#sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8acfd72cc7dc7df0be4ef94764fa15b5b7e0e403" translate="yes" xml:space="preserve">
          <source>The following flags may passed via the 9th parameter to &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; and &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt;:</source>
          <target state="translated">Следующие флаги могут передаваться через 9-й параметр в &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply_v2&lt;/a&gt; и &lt;a href=&quot;sqlite3changegroup_add_strm&quot;&gt;sqlite3changeset_apply_v2_strm&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="90a5abe74323cb727451a1fc89d79f6674e34a04" translate="yes" xml:space="preserve">
          <source>The following four configuration changes are recommended for maximum application security. Turning off the trust_schema setting prevents virtual tables and dodgy SQL functions from being used inside of triggers, views, CHECK constraints, generated columns, and expression indexes. Turning off the dqs_dml and dqs_ddl settings prevents the use of double-quoted strings. Turning on defensive prevents direct writes to shadow tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88559c5309089b2c53eff7ab551567dc8265aad" translate="yes" xml:space="preserve">
          <source>The following functions can be used to advance and query a changeset iterator created by this function:</source>
          <target state="translated">Следующие функции могут быть использованы для продвижения и запроса итератора изменений,созданного этой функцией:</target>
        </trans-unit>
        <trans-unit id="35f53ac017499b71e5f28f348a1b347ee5939139" translate="yes" xml:space="preserve">
          <source>The following is a log of all SQL used to generate one particular timeline (captured on 2016-09-16):</source>
          <target state="translated">Ниже приведен журнал всех SQL,использованных для создания одной конкретной временной шкалы (захваченный в 2016-09-16 гг.):</target>
        </trans-unit>
        <trans-unit id="8ca654574638bb42c5b323e2fbbcf528a1c97560" translate="yes" xml:space="preserve">
          <source>The following is a partial list of the kinds of messages that might appear in the error logger callback.</source>
          <target state="translated">Ниже приведен неполный список видов сообщений,которые могут появляться при обратном вызове регистратора ошибок.</target>
        </trans-unit>
        <trans-unit id="91f9f5074c39cae7458cb274b5e2472dd1f18791" translate="yes" xml:space="preserve">
          <source>The following is a random assortment of techniques used by the SQLite developers to trace, examine, and understand the behavior of the core SQLite library.</source>
          <target state="translated">Ниже приводится случайный набор методов,используемых разработчиками SQLite для отслеживания,изучения и понимания поведения ядра библиотеки SQLite.</target>
        </trans-unit>
        <trans-unit id="172b7cc8402676bd9591f1901c350fe56e3b1a3a" translate="yes" xml:space="preserve">
          <source>The following is sqlite3_analyzer output for an example places.sqlite database used by Firefox.</source>
          <target state="translated">Ниже приведен вывод анализатора sqlite3_analyzerer для примера базы данных places.sqlite,используемой Firefox.</target>
        </trans-unit>
        <trans-unit id="3b9bb38ec5e22c57b0f7c289494707329a29a947" translate="yes" xml:space="preserve">
          <source>The following limitations apply to RBU updates:</source>
          <target state="translated">Следующие ограничения распространяются на обновления RBU:</target>
        </trans-unit>
        <trans-unit id="fc2fda4c09167d54864b95b318f076cb56ce31c3" translate="yes" xml:space="preserve">
          <source>The following macros specify interface linkage for certain kinds of SQLite builds. The Makefiles will normally handle setting these macros automatically. Application developers should not need to worry with these macros. The following documentation about these macros is included completeness.</source>
          <target state="translated">Следующие макросы определяют связь интерфейса для определенных видов сборки SQLite.Обычно Makefiles автоматически обрабатывает настройку этих макросов.Разработчикам приложений не стоит беспокоиться об этих макросах.Следующая документация по этим макросам включает в себя полноту.</target>
        </trans-unit>
        <trans-unit id="e520cf121083171350ce54bdc25d9fb94f2ae9df" translate="yes" xml:space="preserve">
          <source>The following must be true for this function to succeed. If any of the following statements are false when sqlite3_snapshot_get() is called, SQLITE_ERROR is returned. The final value of *P is undefined in this case.</source>
          <target state="translated">Для успешного выполнения этой функции необходимо следующее.Если при вызове sqlite3_snapshot_get()какое-либо из следующих выражений будет ложным,то возвращается SQLITE_ERROR.Окончательное значение *P в этом случае не определено.</target>
        </trans-unit>
        <trans-unit id="13b4c313c53ce999997969a2a1da623479829206" translate="yes" xml:space="preserve">
          <source>The following options can be used to &lt;a href=&quot;footprint&quot;&gt;reduce the size of the compiled library&lt;/a&gt; by omitting unused features. This is probably only useful in embedded systems where space is especially tight, as even with all features included the SQLite library is relatively small. Don't forget to tell your compiler to optimize for binary size! (the -Os option if using GCC). Telling your compiler to optimize for size usually has a much larger impact on library footprint than employing any of these compile-time options. You should also verify that &lt;a href=&quot;#debugoptions&quot;&gt;debugging options&lt;/a&gt; are disabled.</source>
          <target state="translated">Следующие параметры можно использовать для &lt;a href=&quot;footprint&quot;&gt;уменьшения размера скомпилированной библиотеки за&lt;/a&gt; счет исключения неиспользуемых функций. Это, вероятно, полезно только во встроенных системах, где места особенно мало, поскольку даже со всеми включенными функциями библиотека SQLite относительно мала. Не забудьте указать компилятору оптимизировать двоичный размер! (параметр -Os при использовании GCC). Указание компилятору оптимизировать размер обычно оказывает гораздо большее влияние на размер библиотеки, чем использование любого из этих параметров времени компиляции. Вы также должны убедиться, что &lt;a href=&quot;#debugoptions&quot;&gt;параметры отладки&lt;/a&gt; отключены.</target>
        </trans-unit>
        <trans-unit id="aa7c844b688230c89a2857560379c0f551e0b077" translate="yes" xml:space="preserve">
          <source>The following query computes an approximation of the Mandelbrot Set and outputs the result as ASCII-art:</source>
          <target state="translated">Следующий запрос вычисляет аппроксимацию Mandelbrot Set и выводит результат в виде ASCII-art:</target>
        </trans-unit>
        <trans-unit id="165c7c17f77322908874e60dfb0fb76218a06202" translate="yes" xml:space="preserve">
          <source>The following query parameters are recognized by SQLite as of &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). New query parameters might be added in the future.</source>
          <target state="translated">Следующие параметры запроса распознаются SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;начиная с версии 3.15.0&lt;/a&gt; (2016-10-14). В будущем могут быть добавлены новые параметры запроса.</target>
        </trans-unit>
        <trans-unit id="482aaeeca1acb6ff828caa9e341d537cef50e256" translate="yes" xml:space="preserve">
          <source>The following query returns all integers between 1 and 1000000:</source>
          <target state="translated">Следующий запрос возвращает все целые числа от 1 до 1000000:</target>
        </trans-unit>
        <trans-unit id="df61dccd4718a46758145386ef91e3af7a125626" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 1 of the above procedure in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают этап 1 вышеописанной процедуры.</target>
        </trans-unit>
        <trans-unit id="c7e0a9c1d2e39a35866f813a7b58e616f8a0dfa1" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 2 of the above procedure in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают этап 2 вышеуказанной процедуры.</target>
        </trans-unit>
        <trans-unit id="ab60a1fc45053970e49cb2236072b7574ce682f2" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 3 of the above procedure in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают 3-й этап вышеуказанной процедуры.</target>
        </trans-unit>
        <trans-unit id="0f5ce0f453d6b71b276dab07b31a916fac2ad143" translate="yes" xml:space="preserve">
          <source>The following requirements describe step 4 of the above procedure in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают 4-й этап вышеуказанной процедуры.</target>
        </trans-unit>
        <trans-unit id="ff1604c4fd7473773943aa62c8883c18d8179ef1" translate="yes" xml:space="preserve">
          <source>The following requirements describe the steps enumerated above in more detail.</source>
          <target state="translated">Следующие требования более подробно описывают вышеперечисленные шаги.</target>
        </trans-unit>
        <trans-unit id="ca6589a3a75bae1a771049671e8297b9c43f424f" translate="yes" xml:space="preserve">
          <source>The following restrictions apply to DELETE statements that occur within the body of a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement:</source>
          <target state="translated">Следующие ограничения применяются к операторам DELETE, которые встречаются в теле оператора &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1404887613e3d3d478c15bfa20064138fe1f758d" translate="yes" xml:space="preserve">
          <source>The following routines are used to implement user-defined collating sequences:</source>
          <target state="translated">Следующие процедуры используются для реализации заданных пользователем коллизионных последовательностей:</target>
        </trans-unit>
        <trans-unit id="9d61d2cb84c2da7119bdaa99ad1c2d7a32c4afe9" translate="yes" xml:space="preserve">
          <source>The following rules and caveats apply to the values specified as part of each INSERT statement:</source>
          <target state="translated">Следующие правила и предостережения применяются к значениям,указанным в каждом утверждении INSERT:</target>
        </trans-unit>
        <trans-unit id="a26a29856749163d9eb4f80a667633bb87f813e9" translate="yes" xml:space="preserve">
          <source>The following rules show how each of the locks is used.</source>
          <target state="translated">Следующие правила показывают,как используется каждый из замков.</target>
        </trans-unit>
        <trans-unit id="737ea9fa3e70c97a0a7b4c9228ebcdc9127f52cb" translate="yes" xml:space="preserve">
          <source>The following scenario illustrates how an SQLITE_BUSY_SNAPSHOT error might arise:</source>
          <target state="translated">Следующий сценарий иллюстрирует,как может возникнуть ошибка SQLITE_BUSY_SNAPSHOT:</target>
        </trans-unit>
        <trans-unit id="4840312a4c02316c9bb1b228254597da9db65628" translate="yes" xml:space="preserve">
          <source>The following script was used to gather information for the table above.</source>
          <target state="translated">Для сбора информации для вышеприведенной таблицы был использован следующий скрипт.</target>
        </trans-unit>
        <trans-unit id="5f95a6062676138baa336da2cd5b1ec87382d19c" translate="yes" xml:space="preserve">
          <source>The following section describes the API offered to auxiliary function implementations in detail. Further examples may be found in the &quot;fts5_aux.c&quot; file of the source code.</source>
          <target state="translated">В следующем разделе подробно описывается API,предлагаемый для реализации вспомогательных функций.Дальнейшие примеры можно найти в файле исходного кода &quot;fts5_aux.c&quot;.</target>
        </trans-unit>
        <trans-unit id="c91d01efc0ba3649e7eacbf59f700342ec3a53a5" translate="yes" xml:space="preserve">
          <source>The following sections describe some low-level details of the R*Tree implementation, that might be useful for trouble-shooting or performance analysis.</source>
          <target state="translated">В следующих разделах описываются некоторые низкоуровневые детали реализации R*Tree,которые могут быть полезны для поиска неисправностей или анализа производительности.</target>
        </trans-unit>
        <trans-unit id="17e43452198f5289d975fb07abeb874782ed48a0" translate="yes" xml:space="preserve">
          <source>The following sections describe the supported parameters. Specifying an unrecognized parameter name is an error.</source>
          <target state="translated">В следующих разделах описаны поддерживаемые параметры.Указание имени нераспознанного параметра является ошибкой.</target>
        </trans-unit>
        <trans-unit id="009cc36fd7239429da331a5197a208b717cdb22a" translate="yes" xml:space="preserve">
          <source>The following sections provide additional detail on the operation of the various functions that are part of the json1 extension.</source>
          <target state="translated">В следующих разделах приводятся дополнительные сведения о работе различных функций,входящих в состав json1-расширения.</target>
        </trans-unit>
        <trans-unit id="0b996a91eae66dcc3a2860511963eb7fa7efc7eb" translate="yes" xml:space="preserve">
          <source>The following syntax documentation topics are available:</source>
          <target state="translated">Доступны следующие темы синтаксической документации:</target>
        </trans-unit>
        <trans-unit id="0e5fa08cf1724f31556de517effc85351bb377ec" translate="yes" xml:space="preserve">
          <source>The following table shows how many common datatype names from more traditional SQL implementations are converted into affinities by the five rules of the previous section. This table shows only a small subset of the datatype names that SQLite will accept. Note that numeric arguments in parentheses that following the type name (ex: &quot;VARCHAR(255)&quot;) are ignored by SQLite - SQLite does not impose any length restrictions (other than the large global &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit) on the length of strings, BLOBs or numeric values.</source>
          <target state="translated">В следующей таблице показано, сколько общих имен типов данных из более традиционных реализаций SQL преобразовано в аффинности по пяти правилам из предыдущего раздела. В этой таблице показано только небольшое подмножество имен типов данных, которые принимает SQLite. Обратите внимание, что числовые аргументы в круглых скобках, следующие за именем типа (например: &amp;laquo;VARCHAR (255)&amp;raquo;), игнорируются SQLite - SQLite не налагает никаких ограничений длины (кроме большого глобального ограничения &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; ) на длину строк, BLOB-объектов или числовые значения.</target>
        </trans-unit>
        <trans-unit id="54c0ab33937bb3d0205754132a184edc97ac8f8b" translate="yes" xml:space="preserve">
          <source>The following table shows the meanings of the (non-hidden) columns of DBSTAT in both normal and aggregated mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54feeefe0d9e52f7880c035de3af5b0398710d6a" translate="yes" xml:space="preserve">
          <source>The following table shows the results of the NULL handling experiments.</source>
          <target state="translated">В следующей таблице приведены результаты экспериментов по работе с NULL.</target>
        </trans-unit>
        <trans-unit id="12e0a00ef75b703780c84d1074e0287b2f403501" translate="yes" xml:space="preserve">
          <source>The following table summarizes the SQLite file format changes that have occurred since version 1.0.0:</source>
          <target state="translated">В следующей таблице представлены изменения формата файлов SQLite,произошедшие с версии 1.0.0:</target>
        </trans-unit>
        <trans-unit id="ea82e2bbe8fed4a7a8a0361c062cdbf2a7cb2e1f" translate="yes" xml:space="preserve">
          <source>The following two objects and eight methods comprise the essential elements of the SQLite interface:</source>
          <target state="translated">Следующие два объекта и восемь методов составляют основные элементы интерфейса SQLite:</target>
        </trans-unit>
        <trans-unit id="1b3057a8ce2692f0addf4973e487586ba5e334ab" translate="yes" xml:space="preserve">
          <source>The foregoing is all one really needs to know in order to use SQLite effectively. All the rest is optimization and detail.</source>
          <target state="translated">Все вышесказанное действительно необходимо знать,чтобы эффективно использовать SQLite.Все остальное-оптимизация и детализация.</target>
        </trans-unit>
        <trans-unit id="75a22928178fbb3c0cbb048a8ad2cc0d5b3170b7" translate="yes" xml:space="preserve">
          <source>The foregoing text describes low-level aspects of the SQLite file format. The b-tree mechanism provides a powerful and efficient means of accessing a large data set. This section will describe how the low-level b-tree layer is used to implement higher-level SQL capabilities.</source>
          <target state="translated">Приведенный выше текст описывает низкоуровневые аспекты формата файлов SQLite.Механизм b-дерева обеспечивает мощное и эффективное средство доступа к большому массиву данных.В данном разделе будет описано,как низкоуровневый b-деревовидный слой используется для реализации возможностей SQL более высокого уровня.</target>
        </trans-unit>
        <trans-unit id="12199f4a726aab3fb6304db80ece6cf69a955319" translate="yes" xml:space="preserve">
          <source>The foreign key constraint is satisfied if for each row in the child table either one or more of the child key columns are NULL, or there exists a row in the parent table for which each parent key column contains a value equal to the value in its associated child key column.</source>
          <target state="translated">Ограничение постороннего ключа удовлетворяется,если для каждой строки в дочерней таблице либо один или несколько столбцов дочернего ключа NULL,либо существует строка в родительской таблице,для которой каждый столбец родительского ключа содержит значение,равное значению в связанном с ним столбце дочернего ключа.</target>
        </trans-unit>
        <trans-unit id="7eb5b173b9130668a2a0b17e4f207640eaa017f0" translate="yes" xml:space="preserve">
          <source>The foreign key constraints created as part of tables</source>
          <target state="translated">Иностранные ключевые ограничения,созданные в рамках таблиц</target>
        </trans-unit>
        <trans-unit id="add6cc21a0d1ec9f3c982acde6cc5dc3f05465f0" translate="yes" xml:space="preserve">
          <source>The foreign_key_check pragma checks the database, or the table called &quot;</source>
          <target state="translated">Foreign_key_check прагма проверяет базу данных,или таблицу с именем &quot;</target>
        </trans-unit>
        <trans-unit id="9efc16f15cca4547a2a6b1e6f0aea092764cfc35" translate="yes" xml:space="preserve">
          <source>The formalized assumptions in this section refer to</source>
          <target state="translated">Формализованные допущения в этом разделе относятся к</target>
        </trans-unit>
        <trans-unit id="fe9496c466bbe179ee18ac47ed69a346233c9cbd" translate="yes" xml:space="preserve">
          <source>The format for sqlite_stat2 is recorded here for legacy reference. Recent versions of SQLite no longer support sqlite_stat2 and the sqlite_stat2 table, if is exists, is simply ignored.</source>
          <target state="translated">Формат sqlite_stat2 записан здесь для справки по наследству.Последние версии SQLite больше не поддерживают sqlite_stat2 и таблица sqlite_stat2,если она существует,просто игнорируется.</target>
        </trans-unit>
        <trans-unit id="d2a469c667d3464f2b4b57e3f59fb88c3da53ff2" translate="yes" xml:space="preserve">
          <source>The format of a cell depends on which kind of b-tree page the cell appears on. The following table shows the elements of a cell, in order of appearance, for the various b-tree page types.</source>
          <target state="translated">Формат ячейки зависит от того,на какой b-деревянной странице появляется ячейка.В следующей таблице приведены элементы ячейки в порядке их внешнего вида для различных типов b-деревянных страниц.</target>
        </trans-unit>
        <trans-unit id="8f6ebed1965bbd7f7af8c4c0949451b7c054d06f" translate="yes" xml:space="preserve">
          <source>The format of the arguments to the module is very general. Each module-argument may contain keywords, string literals, identifiers, numbers, and punctuation. Each module-argument is passed as written (as text) into the &lt;a href=&quot;vtab#xcreate&quot;&gt;constructor method&lt;/a&gt; of the virtual table implementation when the virtual table is created and that constructor is responsible for parsing and interpreting the arguments. The argument syntax is sufficiently general that a virtual table implementation can, if it wants to, interpret its arguments as &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definitions&lt;/a&gt; in an ordinary &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The implementation could also impose some other interpretation on the arguments.</source>
          <target state="translated">Формат аргументов модуля очень общий. Каждый аргумент модуля может содержать ключевые слова, строковые литералы, идентификаторы, числа и знаки препинания. Каждый аргумент модуля передается так, как написано (как текст), в &lt;a href=&quot;vtab#xcreate&quot;&gt;метод&lt;/a&gt; конструктора реализации виртуальной таблицы при создании виртуальной таблицы, и этот конструктор отвечает за синтаксический анализ и интерпретацию аргументов. Синтаксис аргументов достаточно общий, чтобы реализация виртуальной таблицы могла, если захочет, интерпретировать свои аргументы как &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;определения столбцов&lt;/a&gt; в обычном операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Реализация может также наложить другую интерпретацию аргументов.</target>
        </trans-unit>
        <trans-unit id="ce6813c51545b0e36cbda5b5ae9abe31c78f2212" translate="yes" xml:space="preserve">
          <source>The format of the main database file is as described in the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The &lt;a href=&quot;fileformat2#vnums&quot;&gt;file format version numbers&lt;/a&gt; at offsets 18 and 19 into the main database must both be 2 to indicate that the database is in WAL mode. The main database may have an arbitrary name allowed by the underlying filesystem. No special file suffixes are required, though &quot;.db&quot;, &quot;.sqlite&quot;, and &quot;.sqlite3&quot; seem to be popular choices.</source>
          <target state="translated">Формат основного файла базы данных описан в документе о &lt;a href=&quot;fileformat2&quot;&gt;формате файла&lt;/a&gt; . Номера &lt;a href=&quot;fileformat2#vnums&quot;&gt;версий формата файлов&lt;/a&gt; на смещениях 18 и 19 в основной базе данных должны быть равны 2, чтобы указать, что база данных находится в режиме WAL. Основная база данных может иметь произвольное имя, разрешенное базовой файловой системой. Никаких специальных файловых суффиксов не требуется, хотя &quot;.db&quot;, &quot;.sqlite&quot; и &quot;.sqlite3&quot; кажутся популярными.</target>
        </trans-unit>
        <trans-unit id="c748249cfa33fdfdfb8560eb0a7a2d06c6a7130e" translate="yes" xml:space="preserve">
          <source>The format string for printf() is a template for the generated string. Substitutions are made whenever a &quot;%&quot; character appears in the format string. The &quot;%&quot; is followed by one or more additional characters that describe the substitution. Each substitution has the following format:</source>
          <target state="translated">Строка формата для функции printf()является шаблоном для сгенерированной строки.Замены производятся всякий раз,когда в строке форматирования появляется символ &quot;%&quot;.За &quot;%&quot; следует один или несколько дополнительных символов,описывающих подстановку.Каждая замена имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="e5481902d614e43b8906fc140d4dc2a9c7914623" translate="yes" xml:space="preserve">
          <source>The format used by SQLite database files has been completely revised. The old version 2.1 format and the new 3.0 format are incompatible with one another. Version 2.8 of SQLite will not read a version 3.0 database files and version 3.0 of SQLite will not read a version 2.8 database file.</source>
          <target state="translated">Формат,используемый файлами базы данных SQLite,был полностью пересмотрен.Старая версия 2.1 и новый формат 3.0 несовместимы друг с другом.Версия 2.8 SQLite не будет читать файлы баз данных версии 3.0 и версия 3.0 SQLite не будет читать файл базы данных версии 2.8.</target>
        </trans-unit>
        <trans-unit id="a376c207dbbf638ec2db0cb626e4c46931a236b1" translate="yes" xml:space="preserve">
          <source>The fossil delta format may only be used to update BLOB values. Instead of storing the new BLOB within the data_% table, the fossil delta is stored instead. And instead of specifying an 'x' as part of the rbu_control string for the column to be updated, an 'f' character is stored. When processing an 'f' update, RBU loads the original BLOB data from disk, applies the fossil delta to it and stores the results back into the database file. The RBU databases generated by &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu&lt;/a&gt; make use of fossil deltas wherever doing so would save space in the RBU database.</source>
          <target state="translated">Формат ископаемой дельты можно использовать только для обновления значений BLOB. Вместо того, чтобы хранить новый BLOB в таблице data_%, вместо этого сохраняется ископаемая дельта. И вместо указания &amp;laquo;x&amp;raquo; как части строки rbu_control для обновляемого столбца сохраняется символ &amp;laquo;f&amp;raquo;. При обработке обновления &amp;laquo;f&amp;raquo; RBU загружает исходные данные BLOB с диска, применяет к ним ископаемую дельту и сохраняет результаты обратно в файл базы данных. Базы данных RBU, созданные с помощью &lt;a href=&quot;rbu#sqldiff&quot;&gt;sqldiff --rbu,&lt;/a&gt; используют дельты ископаемых везде, где это может сэкономить место в базе данных RBU.</target>
        </trans-unit>
        <trans-unit id="23a39933682f9054d9fbfd81554ffb9e23300f95" translate="yes" xml:space="preserve">
          <source>The founder of SQLite and all current developers have pledged to follow spirit of The Rule to the best of their ability. They view The Rule as their promise to all SQLite users of how the developers are expected to behave in community. This is a one-way promise, or covenant. In other words, the developers are saying: &quot;We will treat you this way regardless of how you treat us.&quot;</source>
          <target state="translated">Основатель SQLite и все нынешние разработчики пообещали следовать духу Правила в меру своих возможностей.Они рассматривают это правило как свое обещание всем пользователям SQLite о том,как разработчики должны вести себя в сообществе.Это одностороннее обещание,или соглашение.Другими словами,разработчики говорят:&quot;Мы будем относиться к вам так,независимо от того,как вы к нам относитесь&quot;.</target>
        </trans-unit>
        <trans-unit id="fac57078ba906f356fde5d5be039fc86e66f550e" translate="yes" xml:space="preserve">
          <source>The founder of SQLite, and all of the current developers at the time when this document was composed, have pledged to govern their interactions with each other, with their clients, and with the larger SQLite user community in accordance with the &quot;instruments of good works&quot; from chapter 4 of &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;The Rule of St. Benedict&lt;/a&gt; (hereafter: &quot;The Rule&quot;). This code of ethics has proven its mettle in thousands of diverse communities for over 1,500 years, and has served as a baseline for many civil law codes since the time of Charlemagne.</source>
          <target state="translated">Основатель SQLite и все текущие разработчики на момент написания этого документа пообещали управлять своим взаимодействием друг с другом, со своими клиентами и с большим сообществом пользователей SQLite в соответствии с &amp;laquo;инструментами добрых дел&amp;raquo;. &quot;из главы 4 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rule_of_Saint_Benedict&quot;&gt;Правил св. Бенедикта&lt;/a&gt; (далее:&quot; Правило &quot;). Этот этический кодекс доказал свою стойкость в тысячах различных сообществ на протяжении более 1500 лет и служил базой для многих кодексов гражданского права со времен Карла Великого.</target>
        </trans-unit>
        <trans-unit id="555d8586503882b041c2a8a309c2f9e999580160" translate="yes" xml:space="preserve">
          <source>The four utility functions</source>
          <target state="translated">Четыре функции полезности</target>
        </trans-unit>
        <trans-unit id="6cfb5a37e3c4d212e2442aae712218c04b105dd5" translate="yes" xml:space="preserve">
          <source>The four-byte page number at offset 8 is the right-most pointer. This value appears in the header of interior b-tree pages only and is omitted from all other pages.</source>
          <target state="translated">Четырехбайтовый номер страницы со смещением 8 является самым правым указателем.Это значение отображается только в заголовке внутренних страниц b-дерева и опускается со всех остальных страниц.</target>
        </trans-unit>
        <trans-unit id="76f618a5029c6002ebdae975ee6043d888618d19" translate="yes" xml:space="preserve">
          <source>The fourth argument (xFilter) passed to these functions is the &quot;filter callback&quot;. If it is not NULL, then for each table affected by at least one change in the changeset, the filter callback is invoked with the table name as the second argument, and a copy of the context pointer passed as the sixth argument as the first. If the &quot;filter callback&quot; returns zero, then no attempt is made to apply any changes to the table. Otherwise, if the return value is non-zero or the xFilter argument to is NULL, all changes related to the table are attempted.</source>
          <target state="translated">Четвертый аргумент (xFilter),переданный этим функциям-&quot;обратный вызов фильтра&quot;.Если он не NULL,то для каждой таблицы,на которую повлияло хотя бы одно изменение в changeset,вызывается фильтр обратного вызова с именем таблицы в качестве второго аргумента,а в качестве первого аргумента передается копия указателя контекста,переданного в качестве шестого аргумента.Если &quot;filter callback&quot; возвращает ноль,то никаких попыток применить изменения к таблице не предпринимается.В противном случае,если возвращаемое значение ненулевое или аргумент xFilter равен NULL,все изменения,связанные с таблицей,пытаться не будут.</target>
        </trans-unit>
        <trans-unit id="999f04c49ef94f8766fa9cb6bb9bbba18afe2ece" translate="yes" xml:space="preserve">
          <source>The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback.</source>
          <target state="translated">Четвертый аргумент,pArg,является указателем на данные приложения,который передается в качестве первого аргумента на обратный вызов коллабораторной функции.</target>
        </trans-unit>
        <trans-unit id="c6b1934196a189db01281779b0c51a4b66faf522" translate="yes" xml:space="preserve">
          <source>The fourth column is the maximum value of any rowid in the table.</source>
          <target state="translated">Четвертый столбец-это максимальное значение любой строки таблицы.</target>
        </trans-unit>
        <trans-unit id="69cc3b7ae5b0c474135cb2e440fa03951919eaf0" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">Четвертый параметр может также дополнительно включать флаг &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; , который, если он присутствует, предотвращает вызов функции из VIEW или TRIGGER. По соображениям безопасности флаг &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; рекомендуется для любой определяемой приложением функции SQL, имеющей побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="c1fbaaa3083276ec5194db2d1a793d5691751026" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52c4099bf56a2a098b10ec045515f7e30e89130" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs. For security reasons, the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag is recommended for any application-defined SQL function that has side-effects.</source>
          <target state="translated">Четвертый параметр может также дополнительно включать флаг &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; , который, если он присутствует, предотвращает вызов функции из VIEW или TRIGGER. По соображениям безопасности флаг &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; рекомендуется для любой определяемой приложением функции SQL, имеющей побочные эффекты.</target>
        </trans-unit>
        <trans-unit id="67ad2195f1817b78a8b4837501855037b255117b" translate="yes" xml:space="preserve">
          <source>The fourth parameter may also optionally include the &lt;a href=&quot;c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag, which if present prevents the function from being invoked from within VIEWs, TRIGGERs, CHECK constraints, generated column expressions, index expressions, or the WHERE clause of partial indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649add83c8043b4bf2ea6e4b6cf49a7fdf941dff" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">Четвертый параметр может при желании быть &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;объединен&lt;/a&gt; оператором ИЛИ с SQLITE_DETERMINISTIC, чтобы сигнализировать, что функция всегда будет возвращать один и тот же результат при одинаковых входных данных в одном операторе SQL. Большинство функций SQL детерминированы. Встроенная функция SQL &lt;a href=&quot;lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; является примером недетерминированной функции. Планировщик запросов SQLite может выполнять дополнительную оптимизацию детерминированных функций, поэтому по &lt;a href=&quot;#SQLITE_DETERMINISTIC&quot;&gt;возможности&lt;/a&gt; рекомендуется использовать флаг SQLITE_DETERMINISTIC .</target>
        </trans-unit>
        <trans-unit id="6481c8ccbbe2254925779028e6672b2de9b23312" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="658cc43bdf2652e8cf4b2cffdcf6459b264f185d" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="translated">Четвертый параметр может при желании быть &lt;a href=&quot;c_deterministic&quot;&gt;объединен&lt;/a&gt; оператором ИЛИ с SQLITE_DETERMINISTIC, чтобы сигнализировать, что функция всегда будет возвращать один и тот же результат при одинаковых входных данных в одном операторе SQL. Большинство функций SQL детерминированы. Встроенная функция SQL &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random ()&lt;/a&gt; является примером недетерминированной функции. Планировщик запросов SQLite может выполнять дополнительную оптимизацию детерминированных функций, поэтому по &lt;a href=&quot;c_deterministic&quot;&gt;возможности&lt;/a&gt; рекомендуется использовать флаг SQLITE_DETERMINISTIC .</target>
        </trans-unit>
        <trans-unit id="7980c4f3a8ec7ae6d00b95c7cb68067b43db4da9" translate="yes" xml:space="preserve">
          <source>The fourth parameter may optionally be ORed with &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; to signal that the function will always return the same result given the same inputs within a single SQL statement. Most SQL functions are deterministic. The built-in &lt;a href=&quot;../lang_corefunc#random&quot;&gt;random()&lt;/a&gt; SQL function is an example of a function that is not deterministic. The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the &lt;a href=&quot;c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is recommended where possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feefd1b9ff1b8c4a1a74b3c8f0c879ca3de261f9" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">Четвертый параметр sqlite3_open_v2 () - это имя объекта &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs,&lt;/a&gt; который определяет интерфейс операционной системы, который должно использовать новое соединение с базой данных. Если четвертым параметром является указатель NULL, тогда используется объект &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="b7bbbda582299a1f3186b36dde756d304b0fa7e6" translate="yes" xml:space="preserve">
          <source>The fourth parameter to sqlite3_open_v2() is the name of the &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that defines the operating system interface that the new database connection should use. If the fourth parameter is a NULL pointer then the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is used.</source>
          <target state="translated">Четвертый параметр sqlite3_open_v2 () - это имя объекта &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs,&lt;/a&gt; который определяет интерфейс операционной системы, который должно использовать новое соединение с базой данных. Если четвертым параметром является указатель NULL, тогда используется объект &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="d063d165e08786a1b7ee913cfa396d1655f4a730" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;#SQLITE_ANY&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">Четвертый параметр, eTextRep, указывает, какую &lt;a href=&quot;#SQLITE_ANY&quot;&gt;кодировку текста&lt;/a&gt; эта функция SQL предпочитает для своих параметров. Приложение должно установить для этого параметра значение &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE,&lt;/a&gt; если реализация функции вызывает &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16le ()&lt;/a&gt; на входе, или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE,&lt;/a&gt; если реализация вызывает &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16be ()&lt;/a&gt; на входе, или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16,&lt;/a&gt; если используется &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; , или &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_value_text16 &lt;/a&gt;() , или SQLITE_UTF16BEв противном случае. Одна и та же функция SQL может быть зарегистрирована несколько раз с использованием различных предпочтительных текстовых кодировок с разными реализациями для каждой кодировки. Когда доступно несколько реализаций одной и той же функции, SQLite выберет ту, которая включает наименьший объем преобразования данных.</target>
        </trans-unit>
        <trans-unit id="57c66b621bee32c598b5cb9d09e4c1e1ae3f09dc" translate="yes" xml:space="preserve">
          <source>The fourth parameter, eTextRep, specifies what &lt;a href=&quot;c_any&quot;&gt;text encoding&lt;/a&gt; this SQL function prefers for its parameters. The application should set this parameter to &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; if the function implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; if the implementation invokes &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be()&lt;/a&gt; on an input, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; if &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; is used, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; otherwise. The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding. When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.</source>
          <target state="translated">Четвертый параметр, eTextRep, указывает, какую &lt;a href=&quot;c_any&quot;&gt;кодировку текста&lt;/a&gt; эта функция SQL предпочитает для своих параметров. Приложение должно установить для этого параметра значение &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE,&lt;/a&gt; если реализация функции вызывает &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16le ()&lt;/a&gt; на входе, или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE,&lt;/a&gt; если реализация вызывает &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16be ()&lt;/a&gt; на входе, или &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16,&lt;/a&gt; если используется &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; , или &lt;a href=&quot;c_any&quot;&gt;SQLITE_value_text16 &lt;/a&gt;() , или SQLITE_UTF16BEв противном случае. Одна и та же функция SQL может быть зарегистрирована несколько раз с использованием различных предпочтительных текстовых кодировок с разными реализациями для каждой кодировки. Когда доступно несколько реализаций одной и той же функции, SQLite выберет ту, которая включает наименьший объем преобразования данных.</target>
        </trans-unit>
        <trans-unit id="cdeeaf74a0034cfafd692646911468eeef688545" translate="yes" xml:space="preserve">
          <source>The fragment is optional. If present, it is ignored.</source>
          <target state="translated">Фрагмент необязателен.Если присутствует,то он игнорируется.</target>
        </trans-unit>
        <trans-unit id="36f14f55d888327ce43d396d69903a3ff7fd8e07" translate="yes" xml:space="preserve">
          <source>The frame boundary is the first row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">Граница кадра - это первая строка в &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;разделе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a03f5ecd3e39afb46315f6d23c888ecf09dac7b" translate="yes" xml:space="preserve">
          <source>The frame boundary is the last row in the &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;partition&lt;/a&gt;.</source>
          <target state="translated">Граница рамки - это последняя строка в &lt;a href=&quot;windowfunctions#ptxn&quot;&gt;разделе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ad39ba6054748efcf881cf5f3cfd24dafacebd" translate="yes" xml:space="preserve">
          <source>The frame-spec determines which output rows are read by an aggregate window function. The frame-spec consists of four parts:</source>
          <target state="translated">Рамка-spec определяет,какие выходные строки считываются функцией агрегированного окна.Рамка-spec состоит из четырех частей:</target>
        </trans-unit>
        <trans-unit id="8eb0b0542bfd6ed405e2b53c332150eda864217a" translate="yes" xml:space="preserve">
          <source>The freelist is organized as a linked list of freelist trunk pages with each trunk page containing page numbers for zero or more freelist leaf pages.</source>
          <target state="translated">Фрилист организован в виде связанного списка страниц во фрилисте,в котором каждая страница во фрилисте содержит номера страниц для нулевых и более страниц во фрилисте.</target>
        </trans-unit>
        <trans-unit id="4faa37aa2595b1d3bc75280cd8996cd072597ac3" translate="yes" xml:space="preserve">
          <source>The fts3tokenize virtual table can be used on any tokenizer, regardless of whether or not there exists an FTS3 or FTS4 table that actually uses that tokenizer.</source>
          <target state="translated">Виртуальная таблица fts3tokenize может использоваться на любом токенайзере,независимо от того,существует ли таблица FTS3 или FTS4,которая на самом деле использует этот токенайзер.</target>
        </trans-unit>
        <trans-unit id="346445abda1b7582bb76e9ab2cc48bb753bf4d95" translate="yes" xml:space="preserve">
          <source>The fts5 unicode61 tokenizer is byte-for-byte compatible with the fts3/4 unicode61 tokenizer.</source>
          <target state="translated">Токенайзер fts5 unicode61 совместим с токенайзером fts3/4 unicode61 байт за байт.</target>
        </trans-unit>
        <trans-unit id="78675caf2de7d160a88a0d764272d7a44454db10" translate="yes" xml:space="preserve">
          <source>The fts5_api structure is defined as follows. It exposes three methods, one each for registering new auxiliary functions and tokenizers, and one for retrieving existing tokenizer. The latter is intended to facilitate the implementation of &quot;tokenizer wrappers&quot; similar to the built-in porter tokenizer.</source>
          <target state="translated">Структура fts5_api определяется следующим образом.Она раскрывает три метода,по одному для регистрации новых вспомогательных функций и токенайзеров,и по одному для извлечения существующих токенайзеров.Последний предназначен для облегчения реализации &quot;оберток токенайзера&quot; по аналогии со встроенным токенайзером портатора.</target>
        </trans-unit>
        <trans-unit id="162ffee085d8569c08bb1ab9fff2a388996d64c4" translate="yes" xml:space="preserve">
          <source>The fts5_api structure methods are described individually in the following sections.</source>
          <target state="translated">Методы структуры fts5_api описываются индивидуально в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="10c372ee6826e322ad4396357787688e82cce472" translate="yes" xml:space="preserve">
          <source>The fts5vocab virtual table module allows users to extract information from an FTS5 full-text index directly. The fts5vocab module is a part of FTS5 - it is available whenever FTS5 is.</source>
          <target state="translated">Модуль виртуальной таблицы fts5vocab позволяет пользователям извлекать информацию из полнотекстового индекса FTS5 напрямую.Модуль fts5vocab является частью FTS5-он доступен всегда,когда FTS5.</target>
        </trans-unit>
        <trans-unit id="7f3f12f1d0cab297fd4ff2f20d0ccb7ef0778aa5" translate="yes" xml:space="preserve">
          <source>The full pathname of the database file is now remembered even if a relative path is passed into sqlite_open(). This allows the library to continue operating correctly after a chdir().</source>
          <target state="translated">Полное имя файла базы данных теперь запоминается,даже если в sqlite_open()передан относительный путь.Это позволяет библиотеке продолжить корректную работу после chdir().</target>
        </trans-unit>
        <trans-unit id="3b9a46ef2b67e207b1134faeedabd205f3bd8481" translate="yes" xml:space="preserve">
          <source>The full syntax for specifying foreign key constraints is available as part of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; documentation. Replacing the phrase above with any of the following creates an immediate foreign key constraint.</source>
          <target state="translated">Полный синтаксис для указания ограничений внешнего ключа доступен как часть документации &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Замена приведенной выше фразы любым из следующего создает немедленное ограничение внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="976d387f058fd1530001e6bc24b270372cb7f6ff" translate="yes" xml:space="preserve">
          <source>The full-text index maintained by FTS5 is stored as a series of fixed-size blobs in a database table. It is not strictly necessary for all blobs that make up a full-text index to be the same size. The pgsz option determines the size of all blobs created by subsequent index writers. The default value is 1000.</source>
          <target state="translated">Полнотекстовый индекс,поддерживаемый FTS5,хранится в виде серии блоков фиксированного размера в таблице базы данных.Строго говоря,не обязательно,чтобы все блоки,составляющие полнотекстовый индекс,имели одинаковый размер.Опция pgsz определяет размер всех блоков,создаваемых последующими составителями индекса.Значение по умолчанию равно 1000.</target>
        </trans-unit>
        <trans-unit id="7d7917f6db9701130aeed21c2478cad3cdfc0903" translate="yes" xml:space="preserve">
          <source>The function name is specified in UTF-8. A separate sqlite3_create_function16() API works the same as sqlite_create_function() except that the function name is specified in UTF-16 host byte order.</source>
          <target state="translated">Имя функции указано в UTF-8.Отдельный API sqlite3_create_function16()работает так же,как sqlite_create_function(),за исключением того,что имя функции указывается в порядке байт на хосте UTF-16.</target>
        </trans-unit>
        <trans-unit id="026205ed147556f48d88752d5a21eccbd2a64b48" translate="yes" xml:space="preserve">
          <source>The function pointer returned by this routine must be valid for the lifetime of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object given in the first parameter.</source>
          <target state="translated">Указатель на функцию, возвращаемый этой подпрограммой, должен быть действителен в течение всего времени существования объекта &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab,&lt;/a&gt; указанного в первом параметре.</target>
        </trans-unit>
        <trans-unit id="d5578e17f6c531f672841ef155dfdacbfa341e5d" translate="yes" xml:space="preserve">
          <source>The function presented in the previous example copies the entire source database in one call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This requires holding a read-lock on the source database file for the duration of the operation, preventing any other database user from writing to the database. It also holds the mutex associated with database pInMemory throughout the copy, preventing any other thread from using it. The C function in this section, designed to be called by a background thread or process for creating a backup of an online database, avoids these problems using the following approach:</source>
          <target state="translated">Функция, представленная в предыдущем примере, копирует всю исходную базу данных за один вызов &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; . Для этого требуется удерживать блокировку чтения исходного файла базы данных на время операции, чтобы любой другой пользователь базы данных не мог писать в базу данных. Он также содержит мьютекс, связанный с базой данных pInMemory по всей копии, предотвращая его использование другими потоками. Функция C в этом разделе, предназначенная для вызова фоновым потоком или процессом для создания резервной копии онлайн-базы данных, позволяет избежать этих проблем, используя следующий подход:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
