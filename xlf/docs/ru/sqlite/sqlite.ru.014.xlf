<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="3c516f46aa712315eea6584868cd627c02de7056" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;, &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;.</source>
          <target state="translated">См. Также: &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; , &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f01472d4da0f8e936c195c67175f791d08d0adbf" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d54723288e675ac0abb24e0dd779375fca23df6b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bfa2363ed594f2b2eede2b270349dfc67d7ebc18" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html#syntax&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html # syntax.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a4951221a904acb6ba86986765efc2037a09378" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;printf&quot;&gt;встроенная &lt;/a&gt;&lt;a href=&quot;lang_corefunc#printf&quot;&gt;функция SQL &lt;/a&gt;printf () , printf ()</target>
        </trans-unit>
        <trans-unit id="99bd38c265a6fb23dc830f7fe8c080eded5d7a07" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98b434bc0d8b8d185283486c42d9be672854146f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;rescode#busy_recovery&quot;&gt;SQLITE_BUSY_RECOVERY&lt;/a&gt; and &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt;.</source>
          <target state="translated">См. Также: &lt;a href=&quot;rescode#busy_recovery&quot;&gt;SQLITE_BUSY_RECOVERY&lt;/a&gt; и &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7299f9082103db8b34938e68ec91bd133f202916" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension()&lt;/a&gt; and &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension()&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension ()&lt;/a&gt; и &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa3c9ecf5456096c4af70cc1a45db8215c53ecad" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">Смотрите также &lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; и &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81c9581d614ee93295a05913a13ce83a1c537800" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt;.</source>
          <target state="translated">См. Также: &lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; и &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51bddd2f47aedb88c82ed00196f1d5f18d63b931" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset()&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5f9c8eaf62fde3d86c43f634a7ab02bd2fa6122" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt;.</source>
          <target state="translated">См. Также &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0933bf0a406419507f269f3297ab20733c0130b5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt;.</source>
          <target state="translated">См. Также &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="673270029c9264ee605b8c3d4c2fd772ac5ed2ec" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7a6a573f1a49c137144c2c0c0b973878be6af5b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b9de33ebd0cee270413e31ceb4bf9982bf25845" translate="yes" xml:space="preserve">
          <source>See also: SQL functions &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; and the &lt;a href=&quot;../pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">См. Также: функции SQL &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used ()&lt;/a&gt; и &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get ()&lt;/a&gt; и &lt;a href=&quot;../pragma#pragma_compile_options&quot;&gt;прагму compile_options&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83dccf87582bc1362c408c238feac4693c82e492" translate="yes" xml:space="preserve">
          <source>See also: SQL functions &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">См. Также: функции SQL &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get ()&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;прагму compile_options&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61cca4e5d339d369ec47f24cb61df5080a8fe143" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">Смотрите в &lt;a href=&quot;../threadsafe&quot;&gt;режиме поточной&lt;/a&gt; документации для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="6f095aa19ffa800ceddf0ec91e83f4521ad7e3e5" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">Смотрите &lt;a href=&quot;../uri&quot;&gt;имя файла URI&lt;/a&gt; документации для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="14bd56e01493d3e179ad29ee876d123ae68f7d39" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;assert&quot;&gt;Use Of assert in SQLite&lt;/a&gt; document for additional information about how SQLite uses assert().</source>
          <target state="translated">См. &lt;a href=&quot;assert&quot;&gt;В&lt;/a&gt; документе Использование assert в SQLite дополнительную информацию о том, как SQLite использует assert ().</target>
        </trans-unit>
        <trans-unit id="b7c31bb847b7fb9dd4bac9cc5dd5dc1c96846800" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;autoinc&quot;&gt;SQLite AUTOINCREMENT documentation&lt;/a&gt; for detailed instructions on what AUTOINCREMENT does and does not do in SQLite.</source>
          <target state="translated">См. &lt;a href=&quot;autoinc&quot;&gt;Документацию SQLite AUTOINCREMENT&lt;/a&gt; для получения подробных инструкций о том, что AUTOINCREMENT делает и не делает в SQLite.</target>
        </trans-unit>
        <trans-unit id="53b783989abda8014ea3d71299fadcaac3ac76a4" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;datatype3&quot;&gt;Datatypes in SQLite Version 3&lt;/a&gt; document for a detailed discussion of the type system in SQLite.</source>
          <target state="translated">См. Документ &amp;laquo; &lt;a href=&quot;datatype3&quot;&gt;Типы данных в SQLite версии 3&amp;raquo;&lt;/a&gt; для подробного обсуждения системы типов в SQLite.</target>
        </trans-unit>
        <trans-unit id="b929f22f98901beb9b1139bf55e5ff321f37875f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; document for instructions and hints on how to compile the program shown above.</source>
          <target state="translated">См. Документ &amp;laquo;Как компилировать &lt;a href=&quot;howtocompile&quot;&gt;SQLite&amp;raquo;&lt;/a&gt; для получения инструкций и советов о том, как скомпилировать программу, показанную выше.</target>
        </trans-unit>
        <trans-unit id="d23d8904a4dd8b2f59b61ec1f1d5eb8f80e47737" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information on aspects of using SQLite in a multithreaded environment.</source>
          <target state="translated">Смотрите в &lt;a href=&quot;threadsafe&quot;&gt;режиме поточной&lt;/a&gt; документацию для получения дополнительной информации по различным аспектам использования SQLite в многопоточной среде.</target>
        </trans-unit>
        <trans-unit id="a87fd9fe2045f5442c46fbc8912602fdbac0e8ba" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">Смотрите в &lt;a href=&quot;threadsafe&quot;&gt;режиме поточной&lt;/a&gt; документации для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="30f1bf85315b67413bef1d018f3d407e1c5b8c20" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">Смотрите &lt;a href=&quot;uri&quot;&gt;имя файла URI&lt;/a&gt; документации для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="86902a781e00345ab7ead57f5c2f261448269986" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;vtablist&quot;&gt;list of virtual tables&lt;/a&gt; page for a longer list of actual virtual table implementations.</source>
          <target state="translated">См. Страницу со &lt;a href=&quot;vtablist&quot;&gt;списком виртуальных таблиц&lt;/a&gt; для более подробного списка фактических реализаций виртуальных таблиц.</target>
        </trans-unit>
        <trans-unit id="bd6efac597cb0708970fe4961b56a3edc46475fe" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;whentouse&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; document for additional information.</source>
          <target state="translated">Дополнительную информацию см. В документе &amp;laquo; &lt;a href=&quot;whentouse&quot;&gt;Соответствующее использование для SQLite&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07ba693c1bca5dde244a27275e6109ebcc9602e4" translate="yes" xml:space="preserve">
          <source>See the separate &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; documentation for the additional trailing syntax that can cause an INSERT to behave as an UPDATE if the INSERT would otherwise violate a uniqueness constraint. The &lt;a href=&quot;lang_upsert&quot;&gt;upsert clause&lt;/a&gt; is not allowed on an &quot;INSERT ... DEFAULT VALUES&quot;.</source>
          <target state="translated">Смотрите отдельную &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; документацию для дополнительного завершающим синтаксиса , который может привести к ВСТАВИТЬ вести себя как UPDATE , если INSERT иначе нарушают ограничение уникальности. Предложение &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt; недопустимо для &quot;INSERT ... DEFAULT VALUES&quot;.</target>
        </trans-unit>
        <trans-unit id="939683e9d52824a9f73508cf71bd83e60abff90a" translate="yes" xml:space="preserve">
          <source>See xPhraseFirst above.</source>
          <target state="translated">См.выше xPhraseFirst.</target>
        </trans-unit>
        <trans-unit id="4a932238dbfaf0b21024ff5809159c0de781840d" translate="yes" xml:space="preserve">
          <source>See xPhraseFirstColumn above.</source>
          <target state="translated">См.выше xPhraseFirstColumn.</target>
        </trans-unit>
        <trans-unit id="9f853fa8d7ff147b89090825d00dc78b2f44a321" translate="yes" xml:space="preserve">
          <source>SeekEnd</source>
          <target state="translated">SeekEnd</target>
        </trans-unit>
        <trans-unit id="9fadfc9b512132149df920b10f206da2333bd9fa" translate="yes" xml:space="preserve">
          <source>SeekGE</source>
          <target state="translated">SeekGE</target>
        </trans-unit>
        <trans-unit id="1087f36e7b18281af36dad7cdbb8cd08b7115d15" translate="yes" xml:space="preserve">
          <source>SeekGT</source>
          <target state="translated">SeekGT</target>
        </trans-unit>
        <trans-unit id="460ea4a32fd1274da2db98168e01568ac9ce63a6" translate="yes" xml:space="preserve">
          <source>SeekHit</source>
          <target state="translated">SeekHit</target>
        </trans-unit>
        <trans-unit id="0b4f0d008f842f314db6efb3fa8c1e4f9ad7e37b" translate="yes" xml:space="preserve">
          <source>SeekLE</source>
          <target state="translated">SeekLE</target>
        </trans-unit>
        <trans-unit id="5c9e6758b219b2706a95d7da88c60ef0eba6fe03" translate="yes" xml:space="preserve">
          <source>SeekLT</source>
          <target state="translated">SeekLT</target>
        </trans-unit>
        <trans-unit id="141e7ed653901b0f647fda720472fc6667150f0c" translate="yes" xml:space="preserve">
          <source>SeekRowid</source>
          <target state="translated">SeekRowid</target>
        </trans-unit>
        <trans-unit id="a6f10a001bc16f4e4dec6480df4d69d414ad8be5" translate="yes" xml:space="preserve">
          <source>SeekScan</source>
          <target state="translated">SeekScan</target>
        </trans-unit>
        <trans-unit id="c6ed6b18512dd3401d381c337b03a01488f90762" translate="yes" xml:space="preserve">
          <source>Segment B-Tree Interior Node Format</source>
          <target state="translated">Формат узла интерьера сегмента B-дерева</target>
        </trans-unit>
        <trans-unit id="cc806c94f6fb1d331e8fb663d9d4f7e22793356b" translate="yes" xml:space="preserve">
          <source>Segment B-Tree Leaf Node Format</source>
          <target state="translated">Формат узла листа сегмента B-дерева</target>
        </trans-unit>
        <trans-unit id="fe4aff672a9c860addca0cf569e240d57055e4c7" translate="yes" xml:space="preserve">
          <source>Segment b-trees are prefix-compressed b+-trees. There is one segment b-tree for each row in the %_segdir table (see above). The root node of the segment b-tree is stored as a blob in the &quot;root&quot; field of the corresponding row of the %_segdir table. All other nodes (if any exist) are stored in the &quot;blob&quot; column of the %_segments table. Nodes within the %_segments table are identified by the integer value in the blockid field of the corresponding row. The following table describes the fields of the %_segdir table:</source>
          <target state="translated">Сегмент b-деревья-это деревья с префиксом b+.В таблице %_segdir для каждой строки имеется по одному b-дереву сегмента (см.выше).Корневой узел b-дерева сегмента хранится в виде блока в поле &quot;корень&quot; соответствующей строки таблицы %_segdir.Все остальные узлы (если таковые имеются)хранятся в столбце &quot;blob&quot; таблицы %_segdir.Узлы в таблице %_segments идентифицируются по целому значению в блоковом поле соответствующей строки.Следующая таблица описывает поля таблицы %_segdir:</target>
        </trans-unit>
        <trans-unit id="982d848bdbaf7ffda27f7d8aca752c82359ccf6f" translate="yes" xml:space="preserve">
          <source>Segment btree</source>
          <target state="translated">дерево сегмента</target>
        </trans-unit>
        <trans-unit id="40bf8b12088788ad70716eb1793e4cf249c09782" translate="yes" xml:space="preserve">
          <source>Separate INTEGER and REAL affinity</source>
          <target state="translated">Раздельное сродство INTEGER и REAL</target>
        </trans-unit>
        <trans-unit id="ba899678ef1e0fdd6b5eb799ee7abdd42cf175bf" translate="yes" xml:space="preserve">
          <source>Separating a database from its journal</source>
          <target state="translated">Отделение базы данных от ее журнала</target>
        </trans-unit>
        <trans-unit id="5c8f4e0e1a2281faf562976c2410f76c3d8fbc95" translate="yes" xml:space="preserve">
          <source>Sequence</source>
          <target state="translated">Sequence</target>
        </trans-unit>
        <trans-unit id="841936f1610c7b00e43fa53fbf75fb9b11abf32f" translate="yes" xml:space="preserve">
          <source>SequenceTest</source>
          <target state="translated">SequenceTest</target>
        </trans-unit>
        <trans-unit id="e12fccff7a8e896ad7cfa282736ffc4187cd7eaa" translate="yes" xml:space="preserve">
          <source>Serial Type</source>
          <target state="translated">Последовательный тип</target>
        </trans-unit>
        <trans-unit id="307ffd15fed4aa8193a8701f2970a48ccbc74bb4" translate="yes" xml:space="preserve">
          <source>Serial Type Codes Of The Record Format</source>
          <target state="translated">Коды последовательного типа формата записи</target>
        </trans-unit>
        <trans-unit id="b61faef97a33774dc6199c619a4461fc18672af3" translate="yes" xml:space="preserve">
          <source>Serial type</source>
          <target state="translated">Последовательный тип</target>
        </trans-unit>
        <trans-unit id="44bc81d8890afcfb324491bf1c0f95cb6563d3cc" translate="yes" xml:space="preserve">
          <source>Serialize a database</source>
          <target state="translated">Сериализовать базу данных</target>
        </trans-unit>
        <trans-unit id="90c4f08f792523112df74bc852026385bd4f8127" translate="yes" xml:space="preserve">
          <source>Session Object Handle</source>
          <target state="translated">Объектная ручка сеанса</target>
        </trans-unit>
        <trans-unit id="67e2e54aa75dbe4ba2529dc4e44d334d5c33427e" translate="yes" xml:space="preserve">
          <source>Session objects created using this function should be deleted using the &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; function before the database handle that they are attached to is itself closed. If the database handle is closed before the session object is deleted, then the results of calling any session module function, including &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; on the session object are undefined.</source>
          <target state="translated">Объекты сеанса, созданные с помощью этой функции, должны быть удалены с помощью функции &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; до того, как дескриптор базы данных, к которой они прикреплены, будет закрыт сам. Если дескриптор базы данных закрыт до удаления объекта сеанса, то результаты вызова любой функции модуля сеанса, включая &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; для объекта сеанса, не определены.</target>
        </trans-unit>
        <trans-unit id="36d7089db75a5bb06f2dd690097a4896b0ce0449" translate="yes" xml:space="preserve">
          <source>Session objects created using this function should be deleted using the &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; function before the database handle that they are attached to is itself closed. If the database handle is closed before the session object is deleted, then the results of calling any session module function, including &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; on the session object are undefined.</source>
          <target state="translated">Объекты сеанса, созданные с помощью этой функции, должны быть удалены с помощью функции &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; до того, как дескриптор базы данных, к которой они прикреплены, будет закрыт сам. Если дескриптор базы данных закрыт до удаления объекта сеанса, то результаты вызова любой функции модуля сеанса, включая &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; для объекта сеанса, не определены.</target>
        </trans-unit>
        <trans-unit id="ea1b131b3c13e62fbcb2b7e1d8113240624fdfe2" translate="yes" xml:space="preserve">
          <source>Session objects must be deleted before the database handle to which they are attached is closed. Refer to the documentation for &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; for details.</source>
          <target state="translated">Объекты сеанса должны быть удалены до закрытия дескриптора базы данных, к которому они прикреплены. За подробностями обращайтесь к документации по &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0df1e5a24e2b0c00b060a82e0a73f3246a4f51" translate="yes" xml:space="preserve">
          <source>Session objects must be deleted before the database handle to which they are attached is closed. Refer to the documentation for &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; for details.</source>
          <target state="translated">Объекты сеанса должны быть удалены до закрытия дескриптора базы данных, к которому они прикреплены. За подробностями обращайтесь к документации по &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6adb93a894674d02e091209977b242c152440ac9" translate="yes" xml:space="preserve">
          <source>Set *pnInst to the total number of occurrences of all phrases within the query within the current row. Return SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">Установите *pnInst для общего числа вхождений всех фраз внутри запроса в текущей строке.Возвращает SQLITE_OK в случае успеха,или код ошибки (т.е.SQLITE_NOMEM)в случае возникновения ошибки.</target>
        </trans-unit>
        <trans-unit id="efdec671fc0ce8bcb4bdb00d3f437085821cf12c" translate="yes" xml:space="preserve">
          <source>Set A Busy Timeout</source>
          <target state="translated">Установить тайм-аут</target>
        </trans-unit>
        <trans-unit id="b1a0dded912756ecf2b97f232c897007421fbf5d" translate="yes" xml:space="preserve">
          <source>Set Or Clear the Indirect Change Flag</source>
          <target state="translated">Установите или снимите флаг косвенного изменения</target>
        </trans-unit>
        <trans-unit id="3a493136e0eeea58ea401cab071add271017a5ae" translate="yes" xml:space="preserve">
          <source>Set a table filter on a Session Object</source>
          <target state="translated">Установить табличный фильтр на объект сеанса</target>
        </trans-unit>
        <trans-unit id="732b690730c3e6587386dab945ec7951b556c520" translate="yes" xml:space="preserve">
          <source>Set a table filter on a Session Object.</source>
          <target state="translated">Установите табличный фильтр на объект сеанса.</target>
        </trans-unit>
        <trans-unit id="1ac264a53518ed313b058a0a099912f2a35d826a" translate="yes" xml:space="preserve">
          <source>Set an upper bound on the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,N) setting that determines the maximum number of auxiliary threads that a single &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; will use to aid with CPU-intensive computations (mostly sorting). See also the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; options.</source>
          <target state="translated">Установите верхнюю границу для параметра &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; , N), который определяет максимальное количество вспомогательных потоков, которые один &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор&lt;/a&gt; будет использовать для помощи в вычислениях, интенсивно использующих ЦП (в основном, сортировка). См. Также параметры &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92f46b19209e84ffdca742022b56dfdca2dfb583" translate="yes" xml:space="preserve">
          <source>Set register P1 to have the value NULL as seen by the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction, but do not free any string or blob memory associated with the register, so that if the value was a string or blob that was previously copied using &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;, the copies will continue to be valid.</source>
          <target state="translated">Задайте регистру P1 значение NULL, как видно из инструкции &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; , но не освобождает никакую строку или блоб-память, связанную с регистром, так что если значение было строкой или &lt;a href=&quot;opcode#SCopy&quot;&gt;большим двоичным объектом&lt;/a&gt; , который был ранее скопирован с помощью SCopy , копии будут продолжаться быть действительным.</target>
        </trans-unit>
        <trans-unit id="cd7e5b09719a46bb1ffbc4c18faade6d76d5478d" translate="yes" xml:space="preserve">
          <source>Set the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag. This prevents ordinary SQL statements from deliberately corrupting the database file. SQLite should be proof against attacks that involve both malicious SQL inputs and a maliciously corrupted database file at the same time. Nevertheless, denying a script-only attacker access to corrupt database inputs provides an extra layer of defense.</source>
          <target state="translated">Установите флаг &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; . Это предотвращает умышленное повреждение файла базы данных обычными операторами SQL. SQLite должен быть защищен от атак, в которых одновременно используются как вредоносные входные данные SQL, так и вредоносный файл базы данных. Тем не менее, запрет злоумышленнику, использующему только сценарий, в доступе к поврежденным входным данным базы данных, обеспечивает дополнительный уровень защиты.</target>
        </trans-unit>
        <trans-unit id="241b76cbed3f5655045e8aff832d7f03205ef4fe" translate="yes" xml:space="preserve">
          <source>Set the Last Insert Rowid value</source>
          <target state="translated">Установите значение Last Insert Rowid (Последняя вставка в строку)</target>
        </trans-unit>
        <trans-unit id="3a9eaa4fc5302f500031c0b5a5700811aa0eb0fe" translate="yes" xml:space="preserve">
          <source>Set the Last Insert Rowid value.</source>
          <target state="translated">Установите значение Last Insert Rowid (Последняя вставка строки).</target>
        </trans-unit>
        <trans-unit id="5a5c894fd85a90ba517e62438c5aff9b40ab8cb2" translate="yes" xml:space="preserve">
          <source>Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in order to reset a database back to an empty database with no schema and no content. The following process works even for a badly corrupted database file:</source>
          <target state="translated">Установите флаг SQLITE_DBCONFIG_RESET_DATABASE, а затем запустите &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; , чтобы сбросить базу данных обратно в пустую базу данных без схемы и содержимого. Следующий процесс работает даже для сильно поврежденного файла базы данных:</target>
        </trans-unit>
        <trans-unit id="5453fe3bee790f9b36f9a933f54e5899bdab502e" translate="yes" xml:space="preserve">
          <source>Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in order to reset a database back to an empty database with no schema and no content. The following process works even for a badly corrupted database file:</source>
          <target state="translated">Установите флаг SQLITE_DBCONFIG_RESET_DATABASE, а затем запустите &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; , чтобы сбросить базу данных обратно в пустую базу данных без схемы и содержимого. Следующий процесс работает даже для сильно поврежденного файла базы данных:</target>
        </trans-unit>
        <trans-unit id="61c4c40f9a1bb5c18ccdd11c74e4b4fffa0d66f4" translate="yes" xml:space="preserve">
          <source>Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll back any currently active btree transactions. If there are any active VMs (apart from this one), then a ROLLBACK fails. A COMMIT fails if there are active writing VMs or active VMs that use shared cache.</source>
          <target state="translated">Установите флаг автокоррекции базы данных в P1 (1 или 0).Если P2 равен true,откатите все активные в данный момент транзакции btree.Если есть активные ВМ (кроме этой),то ROLLBACK не работает.COMMIT дает сбой,если есть активные ВМ или активные ВМ,использующие общий кэш.</target>
        </trans-unit>
        <trans-unit id="d6cb86bbec6abe009ef2b13054a8bf71fb971e51" translate="yes" xml:space="preserve">
          <source>Set the default size limit (in bytes) for in-memory databases created using &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This is just the default. The limit can be changed at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;,N) or at run-time for individual databases using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt;. If no default is specified, 1073741824 is used.</source>
          <target state="translated">Установите ограничение размера по умолчанию (в байтах) для баз данных в памяти, созданных с помощью &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; . Это просто значение по умолчанию. Предел можно изменить во время запуска с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt; , N) или во время выполнения для отдельных баз данных с помощью &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;файлового элемента &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;управления &lt;/a&gt;SQLITE_FCNTL_SIZE_LIMIT . Если значение по умолчанию не указано, используется 1073741824.</target>
        </trans-unit>
        <trans-unit id="866d8eaf3728a827f036375926469bd93bf88bea" translate="yes" xml:space="preserve">
          <source>Set the permutation used by the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; operator in the next instruction. The permutation is stored in the P4 operand.</source>
          <target state="translated">Задайте перестановку, используемую оператором &lt;a href=&quot;opcode#Compare&quot;&gt;сравнения&lt;/a&gt; в следующей инструкции. Перестановка сохраняется в операнде P4.</target>
        </trans-unit>
        <trans-unit id="ffc497dd2e0254996f63fed1801e825a18a0d70e" translate="yes" xml:space="preserve">
          <source>Set the seekHit flag on cursor P1 to the value in P2. The seekHit flag is used by the &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt; opcode.</source>
          <target state="translated">Установите флаг seekHit на курсоре P1 на значение P2. Флаг seekHit используется &lt;a href=&quot;opcode#IfNoHope&quot;&gt;кодом&lt;/a&gt; операции IfNoHope .</target>
        </trans-unit>
        <trans-unit id="f917c903736a886e2bae7dda91eb93f9fc5b88f2" translate="yes" xml:space="preserve">
          <source>Set up a process-wide &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">Настройте &lt;a href=&quot;errlog&quot;&gt;журнал ошибок&lt;/a&gt; всего процесса .</target>
        </trans-unit>
        <trans-unit id="f899229bce65615b9a9aafe730afb3055fc1d664" translate="yes" xml:space="preserve">
          <source>Set up register P1 so that it will &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; to the coroutine located at address P3.</source>
          <target state="translated">Настройте регистр P1 так, чтобы он &lt;a href=&quot;opcode#Yield&quot;&gt;подчинялся&lt;/a&gt; сопрограмме, расположенной по адресу P3.</target>
        </trans-unit>
        <trans-unit id="c422fe10a5573aa6ba7e50d9c77e20ca08878af0" translate="yes" xml:space="preserve">
          <source>SetCookie</source>
          <target state="translated">SetCookie</target>
        </trans-unit>
        <trans-unit id="01b3682b02999bc0d6273ad2e8a1ce7b60079442" translate="yes" xml:space="preserve">
          <source>Sets the &quot;fired&quot; flag to true.</source>
          <target state="translated">Устанавливает флаг &quot;выстрел&quot; на правду.</target>
        </trans-unit>
        <trans-unit id="5f1906e535428a6ef107759522f33ae96d47ce23" translate="yes" xml:space="preserve">
          <source>Sets the default size of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; memory pool to N entries of SZ bytes each. This setting can be modified at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;) and/or as each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is opened using &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt;).</source>
          <target state="translated">Устанавливает размер пула &lt;a href=&quot;malloc#lookaside&quot;&gt;памяти внешнего распределителя&lt;/a&gt; памяти по умолчанию равным N записям по SZ байтов каждая. Этот параметр можно изменить во время запуска с помощью &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; ) и / или при открытии каждого &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; с помощью &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8f949c67297579c935535017d3f831289e19ac6" translate="yes" xml:space="preserve">
          <source>Setting &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; can cause the database to go corrupt if there is an operating-system crash or power failure, though this setting is safe from damage due to application crashes.</source>
          <target state="translated">Установка &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF&lt;/a&gt; может привести к повреждению базы данных в случае сбоя операционной системы или сбоя питания, хотя этот параметр безопасен от повреждения из-за сбоев приложения.</target>
        </trans-unit>
        <trans-unit id="aefdd1b85748c7d4a0d551399e2edc72cd30afa6" translate="yes" xml:space="preserve">
          <source>Setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; and then changing the database schema using DML statements can render the database completely unreadable, if not done carefully.</source>
          <target state="translated">Установка &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA Writable_schema = ON&lt;/a&gt; и последующее изменение схемы базы данных с помощью операторов DML может сделать базу данных полностью нечитаемой, если не сделать это осторожно.</target>
        </trans-unit>
        <trans-unit id="3fa000f3c0976d971f291c1208857c79532870ca" translate="yes" xml:space="preserve">
          <source>Setting The Result Of An SQL Function</source>
          <target state="translated">Установка результата функции SQL</target>
        </trans-unit>
        <trans-unit id="1d4603c6597b76da3d906d68cccdecf5180cbe08" translate="yes" xml:space="preserve">
          <source>Setting The Subtype Of An SQL Function</source>
          <target state="translated">Установка подтипа функции SQL</target>
        </trans-unit>
        <trans-unit id="16955fa7b436cf8874edb738f171a4d0ef509182" translate="yes" xml:space="preserve">
          <source>Setting fullfsync on a Mac will guarantee that data really does get pushed out to the disk platter on a flush. But the implementation of fullfsync involves resetting the disk controller. And so not only is it profoundly slow, it also slows down other unrelated disk I/O. So its use is not recommended.</source>
          <target state="translated">Установка fullfsync на Mac гарантирует,что данные действительно будут выталкиваться на дисковую тарелку с флеша.Но реализация fullfsync предполагает сброс контроллера диска.И поэтому он не только работает очень медленно,но и замедляет другие несвязанные дисковые входы/выходы.Поэтому его использование не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="3eaa36d1b6e824ce1fa2d9dd603bd95da85fa485" translate="yes" xml:space="preserve">
          <source>Setting the automerge parameter to a non-zero value enables automatic incremental merging. This causes SQLite to do a small amount of inverted index merging after every INSERT operation. The amount of merging performed is designed so that the FTS3/4 table never reaches a point where it has 16 segments at the same level and hence has to do a large merge in order to complete an insert. In other words, automatic incremental merging is designed to prevent spiky INSERT performance.</source>
          <target state="translated">Установка параметра автоматики на ненулевое значение позволяет осуществлять автоматическое инкрементальное слияние.Это приводит к тому,что SQLite после каждой операции INSERT выполняет небольшое слияние инвертированных индексов.Количество выполненных слияний рассчитано таким образом,что таблица FTS3/4 никогда не достигает точки,когда она имеет 16 сегментов на одном уровне,и поэтому для завершения вставки необходимо выполнить большое слияние.Другими словами,автоматическое инкрементальное слияние спроектировано таким образом,чтобы предотвратить резкое повышение производительности INSERT.</target>
        </trans-unit>
        <trans-unit id="56f5ba775f4860afdbeef1efdf08d68cd3228bad" translate="yes" xml:space="preserve">
          <source>Setting the heap limits to zero disables the heap limiter mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d964c814943dd4cc633ef0ee8d21d48eb3735ca0" translate="yes" xml:space="preserve">
          <source>Setting this compile-time option prevents SQLite from being fully testable. Branch test coverage drops from 100% down to about 95%.</source>
          <target state="translated">Установка этого параметра времени компиляции не позволяет SQLite быть полностью тестируемым.Покрытие тестовой ветви снижается со 100% до 95%.</target>
        </trans-unit>
        <trans-unit id="00f0e8d6420ed50a38c6973317964bc318233512" translate="yes" xml:space="preserve">
          <source>Several new C-level objects are used by the virtual table implementation:</source>
          <target state="translated">При реализации виртуальной таблицы используется несколько новых объектов C-уровня:</target>
        </trans-unit>
        <trans-unit id="1b7d1cf980e975f4a1d8be50f6af0bb46a6caa32" translate="yes" xml:space="preserve">
          <source>Several obscure, unrelated bugs were found and fixed while implemented the integer primary key change of the previous bullet.</source>
          <target state="translated">Было найдено несколько непонятных,несвязанных ошибок,которые были исправлены при реализации изменения целочисленного первичного ключа предыдущего пульта.</target>
        </trans-unit>
        <trans-unit id="659f95a669a94f909d4f9c9e95d9d907e1cbadfa" translate="yes" xml:space="preserve">
          <source>Shadow tables are read/write by default. Shadow tables only become read-only when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set using &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. Shadow tables need to be read/write by default in order to maintain backwards compatibility. For example, the SQL text generated by the &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; writes directly into shadow tables.</source>
          <target state="translated">По умолчанию теневые таблицы доступны для чтения и записи. Теневые таблицы становятся доступными только для чтения, только если &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;установлен&lt;/a&gt; флаг SQLITE_DBCONFIG_DEFENSIVE с помощью &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; . По умолчанию теневые таблицы должны быть доступны для чтения и записи, чтобы обеспечить обратную совместимость. Например, текст SQL, сгенерированный командой &lt;a href=&quot;cli#dump&quot;&gt;.dump интерфейса&lt;/a&gt; командной &lt;a href=&quot;cli&quot;&gt;строки,&lt;/a&gt; записывается непосредственно в теневые таблицы.</target>
        </trans-unit>
        <trans-unit id="19452421c69c545e0b50fcc00a18251f53c4e9f4" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. But this might change in future releases of SQLite. Applications that care about shared cache setting should set it explicitly.</source>
          <target state="translated">Общий кэш отключен по умолчанию.Но это может измениться в будущих релизах SQLite.Приложения,которые заботятся о настройке общего кэша,должны установить его явно.</target>
        </trans-unit>
        <trans-unit id="8e41d50ebd1af2b3254810c6333341257c85989e" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016f63b1afdc35c75766700d01c855e2a30457a4" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f477f800bdd5ba8c256608dea929d26bc988f65b" translate="yes" xml:space="preserve">
          <source>Shared libraries or DLLs can be used as &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; to SQLite.</source>
          <target state="translated">Общие библиотеки или DLL могут использоваться как &lt;a href=&quot;loadext&quot;&gt;загружаемые расширения&lt;/a&gt; для SQLite.</target>
        </trans-unit>
        <trans-unit id="b6f715dc89839324b877f33d62ebb39393f6ca50" translate="yes" xml:space="preserve">
          <source>Shared-cache locks are released when a database connection concludes its current transaction, either by committing it or rolling it back.</source>
          <target state="translated">Блокировки общего кэша освобождаются,когда подключение к базе данных завершает свою текущую транзакцию,либо фиксируя ее,либо откатывая.</target>
        </trans-unit>
        <trans-unit id="1a3aca3d24b83cc38a4313e0315e88bcb9c21c92" translate="yes" xml:space="preserve">
          <source>Shared-cache mode changes the semantics of the locking model in some cases. The details are described by this document. A basic understanding of the normal SQLite locking model (see &lt;a href=&quot;lockingv3&quot;&gt;File Locking And Concurrency In SQLite Version 3&lt;/a&gt; for details) is assumed.</source>
          <target state="translated">В некоторых случаях режим общего кэша изменяет семантику модели блокировки. Подробности описаны в этом документе. Предполагается базовое понимание нормальной модели блокировки SQLite (подробности см. В разделе &amp;laquo; &lt;a href=&quot;lockingv3&quot;&gt;Блокировка и параллелизм файлов в SQLite версии 3&amp;raquo;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0a3f80e6eca574b532dbb5d0c3d9a7766e7bf84a" translate="yes" xml:space="preserve">
          <source>Shared-cache mode is enabled on a per-process basis. Using the C interface, the following API can be used to globally enable or disable shared-cache mode:</source>
          <target state="translated">Режим общего кэширования включается для каждого процесса.Используя C-интерфейс,можно использовать следующий API для глобального включения или отключения режима общего кэширования:</target>
        </trans-unit>
        <trans-unit id="f42662308d376fb67628511d59d090985566d2ae" translate="yes" xml:space="preserve">
          <source>Shared-memory files</source>
          <target state="translated">Файлы общей памяти</target>
        </trans-unit>
        <trans-unit id="c7114e495e770e3a02bbb164bf55e1f96da4aecc" translate="yes" xml:space="preserve">
          <source>Shift the integer value in register P2 to the left by the number of bits specified by the integer in register P1. Store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">Сдвинуть целое значение в регистре P2 влево на количество бит,заданное целым числом в регистре P1.Хранить результат в регистре P3.Если любой из входных данных равен NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="1886429e3c21f6dfa5e69e0091250e86426fb4f9" translate="yes" xml:space="preserve">
          <source>Shift the integer value in register P2 to the right by the number of bits specified by the integer in register P1. Store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">Сдвинуть вправо целое значение в регистре P2 на количество бит,заданное целым числом в регистре P1.Хранить результат в регистре P3.Если любой из входных данных равен NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="62341f589b9d3a0d923d18a2b4e7f7f2edda894e" translate="yes" xml:space="preserve">
          <source>ShiftLeft</source>
          <target state="translated">ShiftLeft</target>
        </trans-unit>
        <trans-unit id="2310b475647d9a4e74a4f5d5a47bfb27340ee08b" translate="yes" xml:space="preserve">
          <source>ShiftRight</source>
          <target state="translated">ShiftRight</target>
        </trans-unit>
        <trans-unit id="c8723bf8dd0f924a9f0d00bc2ddb22a9562a76b1" translate="yes" xml:space="preserve">
          <source>Shifting a negative number.</source>
          <target state="translated">Смещение отрицательного числа.</target>
        </trans-unit>
        <trans-unit id="8f0ca083402d5eb462b696e15e581aaadbeb113a" translate="yes" xml:space="preserve">
          <source>Shifting an N-bit integer by more than N bits.</source>
          <target state="translated">Смещение N-битного целого более чем на N бит.</target>
        </trans-unit>
        <trans-unit id="37dcc04149816924636682bd712a1a49f1dcb38f" translate="yes" xml:space="preserve">
          <source>Shifting by a negative amount.</source>
          <target state="translated">Смещение на отрицательную величину.</target>
        </trans-unit>
        <trans-unit id="d224675e61816beeffff3a83b33b759da2cf9109" translate="yes" xml:space="preserve">
          <source>Short answer: A column declared &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; will autoincrement.</source>
          <target state="translated">Краткий ответ: столбец, объявленный &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY,&lt;/a&gt; будет автоматически увеличиваться.</target>
        </trans-unit>
        <trans-unit id="66f7bc664b9d82f0b84142732a02328bc0cdf8d0" translate="yes" xml:space="preserve">
          <source>Show ASCII-art abstract syntax tree diagrams using the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; when compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;, SQLITE_ENABLE_SELECTTRACE, and SQLITE_ENABLE_WHERETRACE. Also provide the sqlite3TreeViewExpr() and sqlite3TreeViewSelect() entry points that can be invoked from with the debugger to show the parse tree when stopped at a breakpoint.</source>
          <target state="translated">Показать диаграммы абстрактного синтаксического дерева в стиле ASCII с помощью команд &amp;laquo;.selecttrace&amp;raquo; и &amp;laquo;.wheretrace&amp;raquo; в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; при компиляции с &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , SQLITE_ENABLE_SELECTTRACE и SQLITE_ENABLE_WHERETRACE. Также укажите точки входа sqlite3TreeViewExpr () и sqlite3TreeViewSelect (), которые можно вызывать с помощью отладчика для отображения дерева синтаксического анализа при остановке в точке останова.</target>
        </trans-unit>
        <trans-unit id="29bd1b65a367359ac801580f0f164ea797beea79" translate="yes" xml:space="preserve">
          <source>Show how many rows have changed on each table, but do not show the actual changes</source>
          <target state="translated">Показывать,сколько строк изменилось в каждой таблице,но не показывать фактических изменений.</target>
        </trans-unit>
        <trans-unit id="45c704a81c82ee8bb0729ae9984ab0b0befba88f" translate="yes" xml:space="preserve">
          <source>Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowcharts; they'll be obvious.</source>
          <target state="translated">Покажите мне свои блок-схемы и спрячьте свои таблицы,и я буду продолжать мистифицироваться.Покажите мне ваши таблицы,и мне обычно не понадобятся ваши блок-схемы,они будут очевидны.</target>
        </trans-unit>
        <trans-unit id="eadcf1db0ff39fb6bc0246ade4beb9b3e9027520" translate="yes" xml:space="preserve">
          <source>Show only differences in the schema not the table content</source>
          <target state="translated">Показывать только различия в схеме,а не в содержании таблицы.</target>
        </trans-unit>
        <trans-unit id="584527d924d04a23c5c08d9fd085c97f73f6da07" translate="yes" xml:space="preserve">
          <source>Show only the differences in content for TABLE, not for the entire database</source>
          <target state="translated">Показывать только различия в контенте для TABLE,а не для всей базы данных.</target>
        </trans-unit>
        <trans-unit id="c2688d3833edc37bfcee14b5515c2bff49005d0c" translate="yes" xml:space="preserve">
          <source>Show the SQL that would be run to carry out the archive operation, but do not actually change anything.</source>
          <target state="translated">Покажите SQL,который будет запущен для выполнения операции архивации,но на самом деле ничего не меняйте.</target>
        </trans-unit>
        <trans-unit id="f2d6599ba5b081fd8b2869046769b3cd08250edc" translate="yes" xml:space="preserve">
          <source>Shun arrogance.</source>
          <target state="translated">Шунь заносчивость.</target>
        </trans-unit>
        <trans-unit id="df3f4b6cc3b45148ff40b29aba7af47fbd10c1fd" translate="yes" xml:space="preserve">
          <source>Signed integer overflow. (Signed integer overflow does &lt;u&gt;not&lt;/u&gt; necessarily wrap around, as most people expect.)</source>
          <target state="translated">Знаковое целочисленное переполнение. (Знаковое целочисленное переполнение &lt;u&gt;не&lt;/u&gt; обязательно повторяется, как ожидает большинство людей.)</target>
        </trans-unit>
        <trans-unit id="2e226f8ddc66c1a463dcf0a7c345c529980f966b" translate="yes" xml:space="preserve">
          <source>Silent &quot;d&quot; in words beginning with &quot;dj&quot;: djinn, Djikarta</source>
          <target state="translated">Молчаливое &quot;d&quot; в словах,начинающихся с &quot;dj&quot;:djinn,Djikarta</target>
        </trans-unit>
        <trans-unit id="aada0dd0ffeee0e21804c55732d58986c7fd3694" translate="yes" xml:space="preserve">
          <source>Silent &quot;g&quot; in words beginning with &quot;gn&quot;: gnarly, gnome, gnat</source>
          <target state="translated">Молчаливое &quot;г&quot; в словах,начинающихся с &quot;гн&quot;:гнарли,гном,мошка.</target>
        </trans-unit>
        <trans-unit id="fbaa2ec88597d6e84d9f667ee669d561de7dec36" translate="yes" xml:space="preserve">
          <source>Silent &quot;k&quot; in words beginning with &quot;kn&quot;: knight, Knuthson</source>
          <target state="translated">Молчаливое &quot;к&quot; в словах,начинающихся с &quot;к&quot;:рыцарь,Кнутсон.</target>
        </trans-unit>
        <trans-unit id="0f8ddc119a87ce25d1a07a2270fa7ab759fe3699" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;pn&quot;: pneumonia, pneumatic</source>
          <target state="translated">Молчаливое &quot;p&quot; в словах,начинающихся с &quot;pn&quot;:пневмония,пневматические</target>
        </trans-unit>
        <trans-unit id="9fea8d13746b11fa947fbc609fcc6f58d06a7902" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;ps&quot;: psalm, psyche</source>
          <target state="translated">Молчаливое &quot;п&quot; в словах,начинающихся с &quot;пс&quot;:псалом,психика</target>
        </trans-unit>
        <trans-unit id="f17200036eeba29904ebeaabba7f7630872e60fd" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;pt&quot;: pterodactyl, ptolemaic</source>
          <target state="translated">Молчаливое &quot;p&quot; в словах,начинающихся с &quot;pt&quot;:птеродактиль,птолемейка</target>
        </trans-unit>
        <trans-unit id="9d3bc03d8343d400c82a4a71a8abb03ff87c2249" translate="yes" xml:space="preserve">
          <source>Similarly, SQLite allows you to store a 2000-character string into a column of type VARCHAR(50). Other SQL implementations would either throw an error or truncate the string. SQLite stores the entire 2000-character string with no loss of information and without complaint.</source>
          <target state="translated">Аналогично,SQLite позволяет хранить 2000-символьную строку в столбце типа VARCHAR(50).Другие реализации SQL будут либо бросать ошибку,либо усекать строку.SQLite хранит всю 2000-символьную строку без потерь информации и без жалоб.</target>
        </trans-unit>
        <trans-unit id="8b91c3fa499f0d4214317846c7c43d756cfd2b0a" translate="yes" xml:space="preserve">
          <source>Similarly, a</source>
          <target state="translated">Аналогично</target>
        </trans-unit>
        <trans-unit id="5bca9444f10a42e6ae3d406bbcd7ca872ce4cd02" translate="yes" xml:space="preserve">
          <source>Similarly, in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, the write-ahead log file is not truncated following a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. Instead, SQLite reuses the existing file for subsequent WAL entries since overwriting is faster than appending.</source>
          <target state="translated">Точно так же в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; файл журнала упреждающей записи не усекается после &lt;a href=&quot;wal#ckpt&quot;&gt;контрольной точки&lt;/a&gt; . Вместо этого SQLite повторно использует существующий файл для последующих записей WAL, поскольку перезапись выполняется быстрее, чем добавление.</target>
        </trans-unit>
        <trans-unit id="bac336a356dc6f108086c2da32cf914ab388438e" translate="yes" xml:space="preserve">
          <source>Similarly, streaming API functions that return changesets (or patchsets) return them in chunks by way of a callback function instead of via a pointer to a single large buffer. In this case, a pair of parameters such as:</source>
          <target state="translated">Аналогично,потоковые функции API,возвращающие наборы изменений (или патч-сеты),возвращают их в кусках с помощью функции обратного вызова,а не с помощью указателя на один большой буфер.В этом случае пару параметров,например:</target>
        </trans-unit>
        <trans-unit id="7d579b15000cacebe667c23c91900124e0021ffe" translate="yes" xml:space="preserve">
          <source>Similarly, the following expressions have historically evaluated to TRUE when in fact NULL is also the correct answer here:</source>
          <target state="translated">Аналогичным образом,следующие выражения исторически оценивались до TRUE,в то время как на самом деле NULL также является правильным ответом здесь:</target>
        </trans-unit>
        <trans-unit id="8de10619f1c2dbf3cc29b124beee52534207f387" translate="yes" xml:space="preserve">
          <source>Simple Queries</source>
          <target state="translated">Простые запросы</target>
        </trans-unit>
        <trans-unit id="c820f89b614c85cd10dd51d0186cb9a23cd537b4" translate="yes" xml:space="preserve">
          <source>Simple SELECT</source>
          <target state="translated">Простой выбор</target>
        </trans-unit>
        <trans-unit id="2b5e01ecfaf01cf9d6fed2afce17a1e2ec85faaa" translate="yes" xml:space="preserve">
          <source>Simple Select Processing</source>
          <target state="translated">Простой выбор Обработка</target>
        </trans-unit>
        <trans-unit id="25bc3effd8fab2177bf75bccfaba476dd31d7e03" translate="yes" xml:space="preserve">
          <source>Simple fts queries</source>
          <target state="translated">Простые запросы</target>
        </trans-unit>
        <trans-unit id="d21c97069116b510ca5fd5d37452e567c518b5ee" translate="yes" xml:space="preserve">
          <source>Simple, easy to use &lt;a href=&quot;cintro&quot;&gt;API&lt;/a&gt;.</source>
          <target state="translated">Простой и удобный &lt;a href=&quot;cintro&quot;&gt;API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20a696ed001fc7792dc03669a107ef6867be06cf" translate="yes" xml:space="preserve">
          <source>Simplified Application Development</source>
          <target state="translated">Упрощенная разработка приложений</target>
        </trans-unit>
        <trans-unit id="75e092657cf7286e756d1dede51480e5230b9edf" translate="yes" xml:space="preserve">
          <source>Simplify the design of the VDBE by restricting the number of sorters and lists to 1. In practice, no more than one sorter and one list was ever used anyhow.</source>
          <target state="translated">Упростите конструкцию VDBE,ограничив количество сортировщиков и списков до 1.На практике в любом случае использовалось не более одного сортировщика и одного списка.</target>
        </trans-unit>
        <trans-unit id="89151b192ec38384818e48383b1951487fe9cb56" translate="yes" xml:space="preserve">
          <source>Simply replace</source>
          <target state="translated">Просто замените</target>
        </trans-unit>
        <trans-unit id="de0928c2b632719ec80087729ff90db61c097100" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_13_0.html&quot;&gt;version 3.13.0&lt;/a&gt; (2016-05-18), the session extension has been included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source distribution. By default, the session extension is disabled. To enable it, build with the following compiler switches:</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_13_0.html&quot;&gt;версии 3.13.0&lt;/a&gt; ( 18.05.2016 ), расширение сеанса было включено в дистрибутив &lt;a href=&quot;amalgamation&quot;&gt;слияния&lt;/a&gt; источников SQLite . По умолчанию расширение сеанса отключено. Чтобы включить его, выполните сборку со следующими переключателями компилятора:</target>
        </trans-unit>
        <trans-unit id="eaa37de22579abc7084228906dd483ab965aacfb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), SQLite has supported an interface called the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; or &quot;VFS&quot;. This object is somewhat misnamed since it is really an interface to the whole underlying operating system, not just the filesystem.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;версии 3.5.0&lt;/a&gt; (2007-09-04), SQLite поддерживает интерфейс, называемый &lt;a href=&quot;c3ref/vfs&quot;&gt;виртуальной файловой системой&lt;/a&gt; или &amp;laquo;VFS&amp;raquo;. Этот объект несколько неверно назван, поскольку на самом деле он является интерфейсом для всей базовой операционной системы, а не только для файловой системы.</target>
        </trans-unit>
        <trans-unit id="c659e6cde59a26a5cc98604eaf1a60217b6d7297" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), SQLite source code has been stored in the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil configuration management system&lt;/a&gt;. The SQLITE_SOURCE_ID macro evaluates to a string which identifies a particular check-in of SQLite within its configuration management system. The SQLITE_SOURCE_ID string contains the date and time of the check-in (UTC) and a SHA1 or SHA3-256 hash of the entire source tree. If the source code has been edited in any way since it was last checked in, then the last four hexadecimal digits of the hash may be modified.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;версии 3.6.18&lt;/a&gt; (2009-09-11), исходный код SQLite хранится в системе &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;управления конфигурацией Fossil&lt;/a&gt; . Макрос SQLITE_SOURCE_ID оценивает строку, которая идентифицирует конкретную регистрацию SQLite в его системе управления конфигурацией. Строка SQLITE_SOURCE_ID содержит дату и время регистрации (UTC) и хэш SHA1 или SHA3-256 всего исходного дерева. Если исходный код был каким-либо образом отредактирован с момента последней регистрации, то могут быть изменены последние четыре шестнадцатеричные цифры хеш-кода.</target>
        </trans-unit>
        <trans-unit id="bde8c10aa2c3a82fb7235b00f685cbcc6334e9b8" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), SQLite source code has been stored in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil configuration management system&lt;/a&gt;. The SQLITE_SOURCE_ID macro evaluates to a string which identifies a particular check-in of SQLite within its configuration management system. The SQLITE_SOURCE_ID string contains the date and time of the check-in (UTC) and a SHA1 or SHA3-256 hash of the entire source tree. If the source code has been edited in any way since it was last checked in, then the last four hexadecimal digits of the hash may be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef82de3319be0d75e458ab4416694f2f8299790" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite also supports &quot;&lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;&quot;. In WAL mode, changes are not written to the original database file. Instead, changes go into a separate &quot;write-ahead log&quot; or &quot;WAL&quot; file. Later, after the transaction commits, those changes will be moved from the WAL file back into the original database in an operation called &quot;checkpoint&quot;. WAL mode is enabled by running &quot;&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt;&quot;.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии 3.7.0&lt;/a&gt; ( 21.07.2010 ), SQLite также поддерживает &amp;laquo; &lt;a href=&quot;wal&quot;&gt;режим WAL&lt;/a&gt; &amp;raquo;. В режиме WAL изменения не записываются в исходный файл базы данных. Вместо этого изменения заносятся в отдельный &amp;laquo;журнал упреждающей записи&amp;raquo; или &amp;laquo;WAL&amp;raquo; файл. Позже, после фиксации транзакции, эти изменения будут перемещены из файла WAL обратно в исходную базу данных в ходе операции, называемой &amp;laquo;контрольная точка&amp;raquo;. Режим WAL включается запуском &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="974a12d011bbc97d586f22e505d00eff41958058" translate="yes" xml:space="preserve">
          <source>Since SQLite always interprets any filename that does not begin with &quot;&lt;code&gt;file:&lt;/code&gt;&quot; as an ordinary filename regardless of the URI setting, and because it is very unusual to have an actual file begin with &quot;&lt;code&gt;file:&lt;/code&gt;&quot;, it is safe for most applications to enable URI processing even if URI filenames are not currently being used.</source>
          <target state="translated">Поскольку SQLite всегда интерпретирует любое имя файла, которое не начинается с &amp;laquo; &lt;code&gt;file:&lt;/code&gt; &amp;raquo;, как обычное имя файла независимо от настройки URI, и поскольку очень необычно иметь фактический файл, начинающийся с &amp;laquo; &lt;code&gt;file:&lt;/code&gt; &amp;raquo;, для большинства приложений безопасно включить обработку URI, даже если имена файлов URI в настоящее время не используются.</target>
        </trans-unit>
        <trans-unit id="6787bde414a9d9d049df11f55e9b93b41be95c03" translate="yes" xml:space="preserve">
          <source>Since SQLite databases are ordinary disk files, any malfunction in the filesystem can corrupt the database. Filesystems in modern operating systems are very reliable, but errors do still occur. For example, on 2013-10-01 the SQLite database that holds the &lt;a href=&quot;http://wiki.tcl-lang.org/&quot;&gt;Wiki for Tcl/Tk&lt;/a&gt; went corrupt a few days after the host computer was moved to a dodgy build of the (linux) kernel that had issues in the filesystem layer. In that event, the filesystem eventually became so badly corrupted that the machine was unusable, but the earliest symptom of trouble was the corrupted SQLite database.</source>
          <target state="translated">Поскольку базы данных SQLite являются обычными дисковыми файлами, любая неисправность в файловой системе может привести к повреждению базы данных. Файловые системы в современных операционных системах очень надежны, но ошибки все же возникают. Например, 01.10.2013 база данных SQLite, в которой хранится &lt;a href=&quot;http://wiki.tcl-lang.org/&quot;&gt;Wiki для Tcl / Tk,&lt;/a&gt; была повреждена через несколько дней после того, как главный компьютер был переведен на хитроумную сборку ядра (linux), которая имела проблемы на уровне файловой системы. В этом случае файловая система в конечном итоге была настолько сильно повреждена, что машина стала непригодной для использования, но самым ранним признаком проблемы была поврежденная база данных SQLite.</target>
        </trans-unit>
        <trans-unit id="c695a2f51c4b24da3c2784ee7cd9c9755809b7df" translate="yes" xml:space="preserve">
          <source>Since SQLite reads and writes an ordinary disk file, the only access permissions that can be applied are the normal file access permissions of the underlying operating system. The GRANT and REVOKE commands commonly found on client/server RDBMSes are not implemented because they would be meaningless for an embedded database engine.</source>
          <target state="translated">Поскольку SQLite читает и записывает обычный файл с диска,единственными разрешениями доступа,которые могут быть применены,являются обычные разрешения доступа к файлам базовой операционной системы.Команды GRANT и REVOKE,обычно встречающиеся на клиентских/серверных СУБД,не реализованы,так как они были бы бессмысленны для встроенного движка СУБД.</target>
        </trans-unit>
        <trans-unit id="59abdbce3144e8f85a07a8dfceb62a241d9b0167" translate="yes" xml:space="preserve">
          <source>Since an SQLite database is a more general format (it is designed to do much more than simply store a bunch of files) it is not as compact as either the ZIP Archive or Tarball formats. An SQLite Archive is usually about 1% larger than the equivalent ZIP Archive. Tarballs are compressed as a single unit rather than compressing each file separately as is done by both SQLite and ZIP Archives. For these reason, Tarballs tend to be smaller than either ZIP or SQLite Archives.</source>
          <target state="translated">Поскольку база данных SQLite является более общим форматом (она предназначена для выполнения гораздо большего,чем просто хранение кучи файлов),она не так компактна,как формат ZIP Archive или Tarball.SQLite Archive обычно на 1% больше,чем эквивалентный ZIP Archive.Tarballs сжимается как единое целое,а не как каждый файл в отдельности,как это делается в SQLite и ZIP архивах.По этой причине Tarballs обычно меньше,чем ZIP или SQLite архивы.</target>
        </trans-unit>
        <trans-unit id="4194b98c5f98c8eb76bc03b04a9e6fbf66db418a" translate="yes" xml:space="preserve">
          <source>Since database zFilename is a file on disk, then it may be accessed externally by another process. This means that when the call to sqlite3_backup_step() attempts to read from or write data to it, it may fail to obtain the required file lock. If this happens, this implementation will fail, returning SQLITE_BUSY immediately. The solution would be to register a busy-handler callback or timeout with &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pFile using &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; or &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; as soon as it is opened. If it fails to obtain a required lock immediately, &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; uses any registered busy-handler callback or timeout in the same way as &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; does.</source>
          <target state="translated">Поскольку база данных zFilename представляет собой файл на диске, к ней может получить доступ извне другой процесс. Это означает, что когда вызов sqlite3_backup_step () пытается читать или записывать в него данные, он может не получить требуемую блокировку файла. Если это произойдет, эта реализация завершится ошибкой, немедленно вернув SQLITE_BUSY. Решением было бы зарегистрировать обратный вызов обработчика занятости или тайм-аут с &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключением к базе данных&lt;/a&gt; pFile с использованием &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; или &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; сразу после его открытия. Если не удается получить требуемую блокировку немедленно, &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; использует любой зарегистрированный обратный вызов обработчика занятости или тайм-аут так же, как &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; или &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="689371fa0cc7aa87af9ab6ee0314efa8f5ddaa1a" translate="yes" xml:space="preserve">
          <source>Since its inception on 2000-05-29, SQLite has been implemented in generic C. C was and continues to be the best language for implementing a software library like SQLite. There are no plans to recode SQLite in any other programming language at this time.</source>
          <target state="translated">С момента своего создания в 2000-05-29 годах SQLite был и остается лучшим языком для реализации такой программной библиотеки,как SQLite.В настоящее время не планируется перекодировать SQLite ни на какой другой язык программирования.</target>
        </trans-unit>
        <trans-unit id="e237e23641bdbe1625752d920a811e88f9bea9fa" translate="yes" xml:space="preserve">
          <source>Since the &quot;t2&quot; imposter table is a form of database corruption, the manual approach to creating imposter tables is not recommended. Actually, any use of imposter tables is discouraged for all but expert developers, but manually created imposter tables are especially discouraged because they are permanent.</source>
          <target state="translated">Поскольку imposter-таблица &quot;t2&quot; является формой повреждения БД,ручной подход к созданию imposter-таблиц не рекомендуется.На самом деле,любое использование imposter-таблиц не приветствуется всеми,кроме экспертов-разработчиков,но ручное создание imposter-таблиц особенно не приветствуется,так как они являются постоянными.</target>
        </trans-unit>
        <trans-unit id="0cc48f0c85bdbc88acc6ded1a2b33b3cefbcc949" translate="yes" xml:space="preserve">
          <source>Since the SQLite database file format was designed (in 2003) the default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page size&lt;/a&gt; for new databases has been 1024 bytes. This was a reasonable choice in 2003. But on modern hardware, a 4096 byte page is a faster and better choice. So, beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; (2016-03-29)) the default page size for new database files has been increased to 4096 bytes.</source>
          <target state="translated">Поскольку формат файлов базы данных SQLite был разработан (в 2003 году), &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;размер страницы&lt;/a&gt; по умолчанию для новых баз данных составлял 1024 байта. В 2003 году это был разумный выбор. Но на современном оборудовании страница размером 4096 байт является более быстрым и лучшим выбором. Итак, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.12.0 (2016-03-29) размер страницы по умолчанию для новых файлов базы данных был увеличен до 4096 байт.</target>
        </trans-unit>
        <trans-unit id="054ac08de64845448b2fb9281541e1391100a214" translate="yes" xml:space="preserve">
          <source>Since the actions of &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; are determined to some extent by prior queries that have been evaluated on the same database connection, it is recommended that &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; be deferred until the database connection is closing and has thus had an opportunity to accumulate as much usage information as possible. It is also reasonable to set a timer to run &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; every few hours, or every few days, for database connections that stay open for a long time.</source>
          <target state="translated">Поскольку действия &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; в некоторой степени определяются предыдущими запросами, которые были оценены в том же соединении с базой данных, рекомендуется &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;отложить PRAGMA optimize&lt;/a&gt; до тех пор, пока соединение с базой данных не закрывается и, таким образом, у него была возможность накопить как можно больше информации об использовании. насколько возможно. Также разумно установить таймер для запуска &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; каждые несколько часов или каждые несколько дней для соединений с базой данных, которые остаются открытыми в течение длительного времени.</target>
        </trans-unit>
        <trans-unit id="a35c2dbd798622212a3da41545074117af9096bd" translate="yes" xml:space="preserve">
          <source>Since the index is used to look up values in the table, it is important that the index and table be kept consistent. Now that there is an index on the examp table, we will have to update that index whenever data is inserted, deleted, or changed in the examp table. Remember the first example above where we were able to insert a new row into the &quot;examp&quot; table using 12 VDBE instructions. Now that this table is indexed, 19 instructions are required. The SQL statement is this:</source>
          <target state="translated">Поскольку индекс используется для поиска значений в таблице,важно,чтобы индекс и таблица были одинаковыми.Теперь,когда в таблице экзамена есть индекс,нам придется обновлять этот индекс всякий раз,когда данные вставляются,удаляются или изменяются в таблице экзамена.Вспомните первый пример выше,когда мы смогли вставить новую строку в таблицу &quot;экзамен&quot;,используя 12 инструкций VDBE.Теперь,когда эта таблица проиндексирована,требуется 19 инструкций.SQL-оператор таков:</target>
        </trans-unit>
        <trans-unit id="792d86f988c7b4533a9df91cbaad2f47d8254db5" translate="yes" xml:space="preserve">
          <source>Since the information is stored in the table in rowid order, SQLite can find the correct row using a binary search. If the table contains N element, the time required to look up the desired row is proportional to logN rather than being proportional to N as in a full table scan. If the table contains 10 million elements, that means the query will be on the order of N/logN or about 1 million times faster.</source>
          <target state="translated">Так как информация хранится в таблице в рядном порядке,SQLite может найти нужную строку с помощью бинарного поиска.Если таблица содержит N элементов,то время,необходимое для поиска нужной строки,пропорционально logN,а не пропорционально N,как при полном сканировании таблицы.Если таблица содержит 10 миллионов элементов,то это означает,что запрос будет по порядку N/logN или примерно в 1 миллион раз быстрее.</target>
        </trans-unit>
        <trans-unit id="f5b0a5f9338e5d6f0eb6749a38c57ac37eadf9c5" translate="yes" xml:space="preserve">
          <source>Since the information is stored in the table in rowid order, SQLite can find the correct row using a binary search. If the table contains N elements, the time required to look up the desired row is proportional to logN rather than being proportional to N as in a full table scan. If the table contains 10 million elements, that means the query will be on the order of N/logN or about 1 million times faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ff8f1fdae75cff7dbf44bfb613a96fb3fe71f5" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the canonical SQLite source code has been moved from the venerable CVS system into a Fossil repository at &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt;. This means that if you are working with canonical SQLite source code (as opposed to the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code files, sqlite3.c and sqlite3.h) then you can create a private repository simply by cloning the official repository:</source>
          <target state="translated">С тех пор как этот документ был впервые написан, канонический исходный код SQLite был перемещен из почтенной системы CVS в репозиторий Fossil по адресу &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt; . Это означает, что если вы работаете с каноническим исходным кодом SQLite (в отличие от файлов исходного кода &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; , sqlite3.c и sqlite3.h), вы можете создать частный репозиторий, просто клонировав официальный репозиторий:</target>
        </trans-unit>
        <trans-unit id="b099e40d5135d32fbddb7b54b1e0fec56c9ea4c7" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the canonical SQLite source code has been moved from the venerable CVS system into a Fossil repository at &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt;. This means that if you are working with canonical SQLite source code (as opposed to the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code files, sqlite3.c and sqlite3.h) then you can create a private repository simply by cloning the official repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7c178a22b32f8642c754bb0ef6c8c8f9f96539" translate="yes" xml:space="preserve">
          <source>Since this document was originally written some of the database engines tested have been updated and users have been kind enough to send in corrections to the chart below. The original data showed a wide variety of behaviors, but over time the range of behaviors has converged toward the PostgreSQL/Oracle model. The only significant difference is that Informix and MS-SQL both treat NULLs as indistinct in a UNIQUE column.</source>
          <target state="translated">С момента написания этого документа некоторые из протестированных движков базы данных были обновлены,и пользователи были любезны прислать исправления к таблице ниже.Первоначальные данные показали широкий диапазон поведения,но со временем этот диапазон сместился в сторону модели PostgreSQL/Oracle.Единственное существенное различие заключается в том,что и Informix,и MS-SQL рассматривают NULL как нечеткие в колонке UNIQUE.</target>
        </trans-unit>
        <trans-unit id="a988ba929d7a7d98790e14aa91b1b4ee801c28ea" translate="yes" xml:space="preserve">
          <source>Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Поскольку ожидается, что этот интерфейс будет использоваться редко, он доступен только в том случае, если SQLite скомпилирован с использованием параметра &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_STMT_SCANSTATUS .</target>
        </trans-unit>
        <trans-unit id="fc8856dbc189b149adcf35c14f2c019d6ca39cd2" translate="yes" xml:space="preserve">
          <source>Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Поскольку ожидается, что этот интерфейс будет использоваться редко, он доступен только в том случае, если SQLite скомпилирован с использованием параметра &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_STMT_SCANSTATUS .</target>
        </trans-unit>
        <trans-unit id="69653584b18a40e580d58b62294b4d01dca91c5b" translate="yes" xml:space="preserve">
          <source>Since undefined and implementation-defined behavior is non-portable and can easily lead to incorrect answers, SQLite works very hard to avoid it. For example, when adding two integer column values together as part of an SQL statement, SQLite does not simply add them together using the C-language &quot;+&quot; operator. Instead, it first checks to make sure the addition will not overflow, and if it will, it does the addition using floating point instead.</source>
          <target state="translated">Так как неопределенное и реализованно-определенное поведение не переносится и может легко привести к неправильным ответам,SQLite очень усердно работает над тем,чтобы избежать этого.Например,при добавлении двух целочисленных значений столбцов вместе как части SQL-оператора,SQLite не просто складывает их вместе,используя оператор &quot;+&quot; на языке C.Вместо этого он сначала проверяет,не переполнится ли сложение,а если переполнится,то делает сложение с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="9a1c7258f48d87f5562218d2ba5ba3886293704d" translate="yes" xml:space="preserve">
          <source>Single-File Documents</source>
          <target state="translated">Документы в одном файле</target>
        </trans-unit>
        <trans-unit id="7fd14cfbad52780046ab174d1c92328e62738415" translate="yes" xml:space="preserve">
          <source>Single-file Cross-platform Database</source>
          <target state="translated">Однофайловая кроссплатформенная база данных</target>
        </trans-unit>
        <trans-unit id="71d9f86ea2562e67aa07344919bbe26526606087" translate="yes" xml:space="preserve">
          <source>Situations Where A Client/Server RDBMS May Work Better</source>
          <target state="translated">Ситуации,когда СУБД &quot;Клиент/сервер&quot; может работать лучше.</target>
        </trans-unit>
        <trans-unit id="7606f77965da29221827e7ce60dd2a6316522a70" translate="yes" xml:space="preserve">
          <source>Situations Where SQLite Works Well</source>
          <target state="translated">Ситуации,в которых SQLite работает хорошо</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="23dd62e305cc04b400ea8b167918d45e391e1599" translate="yes" xml:space="preserve">
          <source>Size Of The SQLite Library</source>
          <target state="translated">Размер библиотеки SQLite</target>
        </trans-unit>
        <trans-unit id="23aa6e811d60088ebfe23efb308861aa99dcc44c" translate="yes" xml:space="preserve">
          <source>Size in bytes</source>
          <target state="translated">Размер в байтах</target>
        </trans-unit>
        <trans-unit id="866e161f09886804ed95702c5f38517afa748243" translate="yes" xml:space="preserve">
          <source>Size of a disk sector assumed by the process that wrote this journal.</source>
          <target state="translated">Размер сектора диска,принятый в процессе записи этого журнала.</target>
        </trans-unit>
        <trans-unit id="d67d90ae080b2ba6443535a1ba1538cce623c7a0" translate="yes" xml:space="preserve">
          <source>Size of associated data in bytes after it has been uncompressed (an integer).</source>
          <target state="translated">Размер связанных данных в байтах после их распаковки (целое число).</target>
        </trans-unit>
        <trans-unit id="af19d643ee98cb7aaa5189e1e80bb15629e35fe6" translate="yes" xml:space="preserve">
          <source>Size of pages in this journal.</source>
          <target state="translated">Размер страниц в этом журнале.</target>
        </trans-unit>
        <trans-unit id="594a08e2bfa114e1b1b2dd2a2473b57fc253e650" translate="yes" xml:space="preserve">
          <source>Size of the database file in pages.</source>
          <target state="translated">Размер файла базы данных в страницах.</target>
        </trans-unit>
        <trans-unit id="57e816514d2bd056545721fc5901b1263c953939" translate="yes" xml:space="preserve">
          <source>Size of the database file in pages. The &quot;in-header database size&quot;.</source>
          <target state="translated">Размер файла базы данных в страницах.Размер заголовочной базы данных.</target>
        </trans-unit>
        <trans-unit id="80dfcf68ced67397f8e69446b796772d4e573bd1" translate="yes" xml:space="preserve">
          <source>Skip NULL entries on range queries in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview/4baa46491212947&quot;&gt;4baa46491212947&lt;/a&gt;.</source>
          <target state="translated">Пропускать записи NULL в запросах диапазона в &lt;a href=&quot;expridx&quot;&gt;индексах по выражениям&lt;/a&gt; . Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/tktview/4baa46491212947&quot;&gt;4baa46491212947&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8597bf03434e274cab90656bf57bce61497b541d" translate="yes" xml:space="preserve">
          <source>Skip over leading spaces in text to numeric conversions.</source>
          <target state="translated">Пропустить лидирующие пробелы в преобразовании текста в цифры.</target>
        </trans-unit>
        <trans-unit id="44c1dff190859dd795700849185006cec261ef11" translate="yes" xml:space="preserve">
          <source>Small code &lt;a href=&quot;footprint&quot;&gt;footprint&lt;/a&gt;: less than 600KiB fully configured or much less with optional features omitted.</source>
          <target state="translated">Небольшой &lt;a href=&quot;footprint&quot;&gt;размер&lt;/a&gt; кода : менее 600 КБ при полной настройке или гораздо меньше без дополнительных функций.</target>
        </trans-unit>
        <trans-unit id="2d43535873c35c636399ec243f6c8a56398f45fc" translate="yes" xml:space="preserve">
          <source>Small edits only overwrite the parts of the file that change, reducing write time and wear on SSD drives.</source>
          <target state="translated">Маленькие правки перезаписывают только те части файла,которые изменяются,что сокращает время записи и износ SSD-накопителей.</target>
        </trans-unit>
        <trans-unit id="15cb3011196ef5ecfa387e72a64b6b9858775898" translate="yes" xml:space="preserve">
          <source>Smaller documents</source>
          <target state="translated">Более мелкие документы</target>
        </trans-unit>
        <trans-unit id="6085ef2b0d377636644056b25b8388fdb9315be1" translate="yes" xml:space="preserve">
          <source>Snapshots of official releases of SQLite source code can often be obtained directly from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; of the SQLite website. Even if the specific version desired is not listed on the download page, the naming conventions are fairly clear and so programmers can often guess the name of an historical release and download it that way.</source>
          <target state="translated">Снимки официальных выпусков исходного кода SQLite часто можно получить прямо со &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;страницы загрузки&lt;/a&gt; веб-сайта SQLite. Даже если конкретная желаемая версия не указана на странице загрузки, соглашения об именах довольно ясны, и поэтому программисты часто могут угадать название исторической версии и загрузить ее таким образом.</target>
        </trans-unit>
        <trans-unit id="7745ac392b119ee893e25a699e3cdf853f08cced" translate="yes" xml:space="preserve">
          <source>So as not to open security holes in older applications that are unprepared to deal with &lt;a href=&quot;../loadext&quot;&gt;extension loading&lt;/a&gt;, and as a means of disabling &lt;a href=&quot;../loadext&quot;&gt;extension loading&lt;/a&gt; while evaluating user-entered SQL, the following API is provided to turn the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; mechanism on and off.</source>
          <target state="translated">Чтобы не открывать дыры в безопасности в старых приложениях, которые не подготовлены к &lt;a href=&quot;../loadext&quot;&gt;загрузке расширений&lt;/a&gt; , а также как средство отключения &lt;a href=&quot;../loadext&quot;&gt;загрузки расширений&lt;/a&gt; при оценке введенного пользователем SQL, предоставляется следующий API для включения и выключения механизма &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="38b1dd3b3f9a942c8b562e364d61d2076822b07d" translate="yes" xml:space="preserve">
          <source>So as not to open security holes in older applications that are unprepared to deal with &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt;, and as a means of disabling &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt; while evaluating user-entered SQL, the following API is provided to turn the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; mechanism on and off.</source>
          <target state="translated">Чтобы не открывать дыры в безопасности в старых приложениях, которые не подготовлены к &lt;a href=&quot;loadext&quot;&gt;загрузке расширений&lt;/a&gt; , а также как средство отключения &lt;a href=&quot;loadext&quot;&gt;загрузки расширений&lt;/a&gt; при оценке введенного пользователем SQL, предоставляется следующий API для включения и выключения механизма &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="16d0e08c9c27f821bc14542d2dfda5e1d13ecd69" translate="yes" xml:space="preserve">
          <source>So in the vast majority of cases, applications need not worry about the WAL file at all. SQLite will automatically take care of it. But it is possible to get SQLite into a state where the WAL file will grow without bound, causing excess disk space usage and slow queries speeds. The following bullets enumerate some of the ways that this can happen and how to avoid them.</source>
          <target state="translated">Поэтому в подавляющем большинстве случаев приложениям вообще не нужно беспокоиться о файле WAL.SQLite автоматически позаботится о нем.Но можно довести SQLite до такого состояния,когда файл WAL вырастет без ограничений,что приведет к избыточному использованию дискового пространства и замедлению скорости запросов.Следующие пункты перечисляют некоторые из способов,которыми это может произойти,и как их избежать.</target>
        </trans-unit>
        <trans-unit id="e294517ccb0b92866adadbcc46dbbe368da638fb" translate="yes" xml:space="preserve">
          <source>So instead of going by the standards documents, various popular SQL engines were tested to see how they handle NULLs. The idea was to make SQLite work like all the other engines. An SQL test script was developed and run by volunteers on various SQL RDBMSes and the results of those tests were used to deduce how each engine processed NULL values. The original tests were run in May of 2002. A copy of the test script is found at the end of this document.</source>
          <target state="translated">Поэтому вместо того,чтобы идти по документам стандартов,были протестированы различные популярные SQL-движки,чтобы посмотреть,как они справляются с NULL.Идея заключалась в том,чтобы заставить SQLite работать как все остальные движки.Скрипт для тестирования SQL был разработан и запущен добровольцами на различных СУБД SQL,и результаты этих тестов были использованы для того,чтобы определить,как каждый движок обрабатывает NULL-значения.Оригинальные тесты были запущены в мае 2002 года.Копия тестового скрипта находится в конце этого документа.</target>
        </trans-unit>
        <trans-unit id="cb3fd38b2086ae5409a50744fd4fc4e629f9ceb9" translate="yes" xml:space="preserve">
          <source>So let your take-away be this: read/write latency for SQLite is competitive with read/write latency of individual files on disk. Often SQLite is faster. Sometimes SQLite is almost as fast. Either way, this article disproves the common assumption that a relational database must be slower than direct filesystem I/O.</source>
          <target state="translated">Так что пусть ваша очередь будет такой:задержка чтения/записи для SQLite конкурирует с задержкой чтения/записи отдельных файлов на диске.Часто SQLite работает быстрее.Иногда SQLite почти так же быстр.В любом случае,эта статья опровергает распространенное предположение,что реляционная база данных должна быть медленнее,чем прямой ввод/вывод файловой системы.</target>
        </trans-unit>
        <trans-unit id="4e14f136c4639ca69349a007ce6b5be7651832a1" translate="yes" xml:space="preserve">
          <source>So that</source>
          <target state="translated">чтобы</target>
        </trans-unit>
        <trans-unit id="ed811e71ef3d05d3652d347ba0eec5bc9cfd6daf" translate="yes" xml:space="preserve">
          <source>So the implementation of DELETE is really in two loops. The first loop (instructions 5 through 11) locates the records that are to be deleted and saves their keys onto a temporary list, and the second loop (instructions 16 through 19) uses the key list to delete the records one by one.</source>
          <target state="translated">Так что реализация DELETE на самом деле находится в двух циклах.Первый цикл (команды 5-11)находит удаляемые записи и сохраняет их ключи во временный список,а второй цикл (команды 16-19)использует список ключей для удаления записей по одному.</target>
        </trans-unit>
        <trans-unit id="c4f70ed30e8ca5ddd05ca39e32d9f73108273525" translate="yes" xml:space="preserve">
          <source>So then, instead of storing all content for all slides in a single oversized XML file (&quot;content.xml&quot;), suppose there was a separate table for storing the content of each slide separately. The table schema might look something like this:</source>
          <target state="translated">Тогда,вместо того,чтобы хранить все содержимое для всех слайдов в одном большом XML-файле (&quot;content.xml&quot;),предположим,что существовала отдельная таблица для хранения содержимого каждого слайда в отдельности.Схема таблицы может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="21a527776b915968f528d88d96579bf0b2cfc459" translate="yes" xml:space="preserve">
          <source>So which query plan is better? It turns out that the answer depends on what kind of data is found in the node and edge tables.</source>
          <target state="translated">Так какой план запросов лучше? Получается,что ответ зависит от того,какие данные найдены в узловых и краевых таблицах.</target>
        </trans-unit>
        <trans-unit id="15a7d8b50c8c0de15e18cf6f21d9c00564463215" translate="yes" xml:space="preserve">
          <source>So with this simple change, the ODP file now stores not just the most recent edit to the presentation, but a history of all historic edits. The user would normally want to see just the most recent edition of the presentation, but if desired, the user can now go backwards in time to see historical versions of the same presentation.</source>
          <target state="translated">Таким образом,с этим простым изменением ODP-файл теперь хранит не только самые последние правки презентации,но и историю всех исторических правок.Обычно пользователь хочет увидеть только самую последнюю версию презентации,но при желании он может теперь вернуться назад во времени,чтобы увидеть исторические версии той же самой презентации.</target>
        </trans-unit>
        <trans-unit id="1b3d75a6fea634203c91a87ee6d0199704a76d2e" translate="yes" xml:space="preserve">
          <source>So you can see that depending on how the data is structured in the table, either query plan 1 or query plan 2 might be better. Which plan does SQLite choose by default? As of version 3.6.18, without running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;, SQLite will choose option 2. But if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is run in order to gather statistics, a different choice might be made if the statistics indicate that the alternative is likely to run faster.</source>
          <target state="translated">Итак, вы можете видеть, что в зависимости от того, как данные структурированы в таблице, может быть лучше план запроса 1 или план запроса 2. Какой тарифный план выбирает SQLite по умолчанию? Начиная с версии 3.6.18, без запуска &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; , SQLite выберет опцию 2. Но если команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; запускается для сбора статистики, может быть сделан другой выбор, если статистика показывает, что альтернатива, вероятно, будет работать быстрее.</target>
        </trans-unit>
        <trans-unit id="a928bb1185074b6024b0f391bb34b87d559742b4" translate="yes" xml:space="preserve">
          <source>So you can see that depending on how the data is structured in the table, either query plan 1 or query plan 2 might be better. Which plan does SQLite choose by default? As of version 3.6.18, without running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;, SQLite will choose option 2. If the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is run in order to gather statistics, a different choice might be made if the statistics indicate that the alternative is likely to run faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae83e266982fd9b4e55366971516ab44ce25fd32" translate="yes" xml:space="preserve">
          <source>So, SQLite is able to do one or two large and complex queries, or it can do many smaller and simpler queries. Both are efficient. An application can use either or both techniques, depending on what works best for the situation at hand.</source>
          <target state="translated">Таким образом,SQLite способен выполнять один или два больших и сложных запроса,или же он может выполнять много более мелких и простых запросов.Оба они эффективны.Приложение может использовать как одну,так и обе техники,в зависимости от того,что лучше всего работает в данной ситуации.</target>
        </trans-unit>
        <trans-unit id="bac7c0c462d374d0c622ef9a876ba7c2814954d0" translate="yes" xml:space="preserve">
          <source>So, for example, Android applications written in Java are able to invoke SQLite (through an adaptor). Maybe it would have been more convenient for Android if SQLite had been coded in Java as that would make the interface simpler. However, on iPhone applications are coded in Objective-C or Swift, neither of which have the ability to call libraries written in Java. Thus, SQLite would be unusable on iPhones had it been written in Java.</source>
          <target state="translated">Так,например,приложения для Android,написанные на Java,могут вызывать SQLite (через адаптер).Может быть,для Android было бы удобнее,если бы SQLite был закодирован на Java,так как это сделало бы интерфейс проще.Однако,на iPhone приложения кодируются в Objective-C или Swift,ни одно из которых не имеет возможности вызывать библиотеки,написанные на Java.Таким образом,SQLite был бы непригоден для использования на iPhone,если бы он был написан на Java.</target>
        </trans-unit>
        <trans-unit id="74dbcba5ce1ee9e465ff4640af1328df3383d188" translate="yes" xml:space="preserve">
          <source>So, for example, if you read on Wikipedia that the encoding for the minimum positive binary64 value is 0x0000000000000001, then you can find the corresponding floating point value like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a08fae7d5439605099534f2303acb989c7de8df" translate="yes" xml:space="preserve">
          <source>So, for example, if you wanted to see the compression efficiency (expressed as the size of the compressed content relative to the original uncompressed file size) for all files in the ZIP archive, sorted from most compressed to least compressed, you could run a query like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181a0af408b7a72e62f37951390087a73f4bc42a" translate="yes" xml:space="preserve">
          <source>So, for example, suppose a multi-thread process has two or more threads with separate SQLite database connections to the same database file. Then a third thread comes along and wants to read something out of that same database file on its own, without using the SQLite library. The third thread does an &lt;code&gt;open()&lt;/code&gt;, a &lt;code&gt;read()&lt;/code&gt; and then a &lt;code&gt;close()&lt;/code&gt;. One would think this would be harmless. But the &lt;code&gt;close()&lt;/code&gt; system call caused the locks held on the database by all the other threads to be dropped. Those other threads have no way of knowing that their locks have just been trashed (POSIX does not provide any mechanism to determine this) and so they keep on running under the assumption that their locks are still valid. This can lead to two or more threads or processes trying to write to the database at the same time, resulting in database corruption.</source>
          <target state="translated">Так, например, предположим, что многопоточный процесс имеет два или более потоков с отдельными подключениями базы данных SQLite к одному и тому же файлу базы данных. Затем появляется третий поток, который хочет прочитать что-то из того же файла базы данных самостоятельно, без использования библиотеки SQLite. Третий поток выполняет &lt;code&gt;open()&lt;/code&gt; , &lt;code&gt;read()&lt;/code&gt; а затем &lt;code&gt;close()&lt;/code&gt; . Казалось бы, это безвредно. Но &lt;code&gt;close()&lt;/code&gt; Системный вызов привел к снятию блокировок, удерживаемых в базе данных всеми другими потоками. Эти другие потоки не имеют возможности узнать, что их блокировки только что были сброшены (POSIX не предоставляет никакого механизма для определения этого), и поэтому они продолжают работать в предположении, что их блокировки все еще действительны. Это может привести к тому, что два или более потоков или процессов будут пытаться записать в базу данных одновременно, что приведет к повреждению базы данных.</target>
        </trans-unit>
        <trans-unit id="e67704da7c1255179aaf24e0803cc78b548dbe91" translate="yes" xml:space="preserve">
          <source>So, for example, suppose an application runs one query against an R-Tree like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7734444a7a6faac12d5a5f4324148513ca147ad7" translate="yes" xml:space="preserve">
          <source>So, for example, to move a polygon by some amount DX, DY without changing its shape, use:</source>
          <target state="translated">Так,например,чтобы переместить полигон на некоторое количество DX,DY без изменения его формы,используйте:</target>
        </trans-unit>
        <trans-unit id="e378604952476e70a532691c0957173825ab1905" translate="yes" xml:space="preserve">
          <source>So, in most real systems, an index should be created on the child key columns of each foreign key constraint. The child key index does not have to be (and usually will not be) a UNIQUE index. Returning again to the example in section 1, the complete database schema for efficient implementation of the foreign key constraint might be:</source>
          <target state="translated">Таким образом,в большинстве реальных систем индекс должен быть создан на дочерних столбцах каждого внешнего ключа-ограничения.Индекс дочернего ключа не обязательно должен быть (и,как правило,не будет)индексом UNIQUE.Возвращаясь к примеру в разделе 1,можно получить полную схему базы данных для эффективной реализации ограничения постороннего ключа:</target>
        </trans-unit>
        <trans-unit id="ae3d493e7575fd35c2f366541da3ece2a1661c2d" translate="yes" xml:space="preserve">
          <source>So-called &quot;REAL&quot; or floating point values are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Binary-64&lt;/a&gt; format. This gives a range of positive values between approximately 1.7976931348623157e+308 and 4.9406564584124654e-324 with an equivalent range of negative values. A binary64 can also be 0.0 (and -0.0), positive and negative infinity and &quot;NaN&quot; or &quot;Not-a-Number&quot;. Floating point values are approximate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3db788b7daff3a78000d452682744db386479ec" translate="yes" xml:space="preserve">
          <source>SoftNull</source>
          <target state="translated">SoftNull</target>
        </trans-unit>
        <trans-unit id="36455d32e1724499e8736ccea81ccd08b26881c3" translate="yes" xml:space="preserve">
          <source>Solve Sudoku puzzles</source>
          <target state="translated">Решать головоломки Судоку</target>
        </trans-unit>
        <trans-unit id="ea9361715e601f0c6bb314bde2f85f47f8bc5402" translate="yes" xml:space="preserve">
          <source>Some &quot;safe&quot; languages (ex: Go) dislike the use of assert(). But the use of assert() is a vital part of keeping SQLite maintainable. The lack of assert() in Go is a show-stopper as far as the developers of SQLite are concerned. See the &lt;a href=&quot;assert&quot;&gt;The Use Of assert() In SQLite&lt;/a&gt; article for additional information.</source>
          <target state="translated">Некоторые &amp;laquo;безопасные&amp;raquo; языки (например, Go) не любят использование assert (). Но использование assert () - жизненно важная часть поддержки SQLite. Отсутствие assert () в Go является препятствием для разработчиков SQLite. См. Дополнительную информацию в статье &lt;a href=&quot;assert&quot;&gt;Использование assert () в SQLite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82877b639e06578b26b7b6487eda6b76c0a0e3c6" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements do their work during sqlite3_prepare() rather than during sqlite3_step(). Those PRAGMA statements are unaffected by EXPLAIN. They operate the same with or without the EXPLAIN prefix. The set of PRAGMA statements that are unaffected by EXPLAIN can vary from one release to the next. Some PRAGMA statements operate during sqlite3_prepare() depending on their arguments. For consistent results, avoid using EXPLAIN on PRAGMA statements.</source>
          <target state="translated">Некоторые операторы &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; выполняют свою работу во время sqlite3_prepare (), а не во время sqlite3_step (). EXPLAIN не влияет на эти утверждения PRAGMA. Они работают одинаково с префиксом EXPLAIN или без него. Набор операторов PRAGMA, на которые не влияет EXPLAIN, может варьироваться от одного выпуска к другому. Некоторые операторы PRAGMA работают во время sqlite3_prepare () в зависимости от их аргументов. Для получения стабильных результатов избегайте использования EXPLAIN в операторах PRAGMA.</target>
        </trans-unit>
        <trans-unit id="5732042dba5cf74de37a47838012719f36ee8111" translate="yes" xml:space="preserve">
          <source>Some Example Triggers</source>
          <target state="translated">Некоторые примеры триггеров</target>
        </trans-unit>
        <trans-unit id="e2da6518510111d1ca6bc33d2d1e98dff9548bb8" translate="yes" xml:space="preserve">
          <source>Some SQL database engines provide non-standard &quot;hint&quot; mechanisms which can be used to give the query optimizer clues about what indices it should use for a particular statement. The INDEX BY clause of SQLite is &lt;em&gt;not&lt;/em&gt; a hinting mechanism and it should not be used as such. The INDEXED BY clause does not give the optimizer hints about which index to use; it gives the optimizer a requirement of which index to use. If the query optimizer is unable to use the index specified by the INDEX BY clause, then the query will fail with an error.</source>
          <target state="translated">Некоторые механизмы баз данных SQL предоставляют нестандартные механизмы &amp;laquo;подсказок&amp;raquo;, которые можно использовать, чтобы дать оптимизатору запросов подсказки о том, какие индексы он должен использовать для определенного оператора. Предложение INDEX BY SQLite &lt;em&gt;не&lt;/em&gt; является механизмом подсказок и не должно использоваться как таковое. Предложение INDEXED BY не дает оптимизатору подсказок о том, какой индекс использовать; он дает оптимизатору требование о том, какой индекс использовать. Если оптимизатор запросов не может использовать индекс, указанный в предложении INDEX BY, запрос завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="fbf443b96f0d9f6eac4bc80a9c5c544e6d64bd31" translate="yes" xml:space="preserve">
          <source>Some commentators say that SQLite is &quot;weakly typed&quot; and that other SQL databases are &quot;strongly typed&quot;. We consider these terms to be inaccurate and pejorative. We prefer to say that SQLite is &quot;flexibly typed&quot; and that other SQL databases are &quot;rigidly typed&quot;.</source>
          <target state="translated">Некоторые комментаторы говорят,что SQLite &quot;слабо набран&quot;,а другие базы данных SQL &quot;сильно набраны&quot;.Мы считаем эти термины неточными и уничижительными.Мы предпочитаем говорить,что SQLite &quot;гибко набран&quot;,а другие базы данных SQL &quot;жестко набраны&quot;.</target>
        </trans-unit>
        <trans-unit id="ffa0bb5b46a56bce712735328de2ecfd7898dd9a" translate="yes" xml:space="preserve">
          <source>Some devices are compelled to use an older filesystem with 8+3 filename restrictions for backwards compatibility, or due to other non-technical factors. In such situations, SQLite can be coerced into using auxiliary files that fit the 8+3 pattern as follows:</source>
          <target state="translated">Некоторые устройства вынуждены использовать старую файловую систему с ограничениями по имени файла 8+3 для обратной совместимости или из-за других нетехнических факторов.В таких ситуациях SQLite может быть вынужден использовать вспомогательные файлы,соответствующие шаблону 8+3,следующим образом:</target>
        </trans-unit>
        <trans-unit id="a1a4bdb9a86e43ef62782dbb2803e2ef7fef0a7a" translate="yes" xml:space="preserve">
          <source>Some example, cost table entries:</source>
          <target state="translated">Например,записи в таблице расходов:</target>
        </trans-unit>
        <trans-unit id="9234854e8f0cb7e3b23fa0273a95bcc8f4a8eaf9" translate="yes" xml:space="preserve">
          <source>Some examples will help illustrate the difference:</source>
          <target state="translated">Некоторые примеры помогут проиллюстрировать разницу:</target>
        </trans-unit>
        <trans-unit id="31941b285d3264077d66c50c29fee18d7a8c1f66" translate="yes" xml:space="preserve">
          <source>Some freelist pages contain critical data; specifically the locations of other freelist pages. But most freelist pages contain nothing useful. These latter freelist pages are called &quot;leaf&quot; pages. We are free to modify the content of a leaf freelist page in the database without changing the meaning of the database in any way.</source>
          <target state="translated">Некоторые страницы фрилиста содержат критические данные,в частности,расположение других страниц фрилиста.Но большинство страниц фрилиста не содержат ничего полезного.Эти последние страницы фрилиста называются &quot;страницами листа&quot;.Мы вольны изменять содержимое страницы фрилиста в базе данных,не изменяя значения базы данных ни в коем случае.</target>
        </trans-unit>
        <trans-unit id="6d4f98671a50a0a922d51c622597741cdfcd893a" translate="yes" xml:space="preserve">
          <source>Some future versions of SQLite may change to enable this feature by default.</source>
          <target state="translated">Некоторые будущие версии SQLite могут быть изменены для включения этой функции по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2f4d80fea07d79c2b9292b009b4bc9dc70c5c271" translate="yes" xml:space="preserve">
          <source>Some heightened security settings (&lt;a href=&quot;#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt;) disable the use of SQL functions inside views and triggers and in schema structures such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt; unless the function is tagged with SQLITE_INNOCUOUS. Most built-in functions are innocuous. Developers are advised to avoid using the SQLITE_INNOCUOUS flag for application-defined functions unless the function has been carefully audited and found to be free of potentially security-adverse side-effects and information-leaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94760af1d8102735e05f237c89411fff0859308d" translate="yes" xml:space="preserve">
          <source>Some heightened security settings (&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt;) disable the use of SQL functions inside views and triggers and in schema structures such as &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;../expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt; unless the function is tagged with SQLITE_INNOCUOUS. Most built-in functions are innocuous. Developers are advised to avoid using the SQLITE_INNOCUOUS flag for application-defined functions unless the function has been carefully audited and found to be free of potentially security-adverse side-effects and information-leaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc7150370b1275da7b22e0b3c0daa34955ce5a3" translate="yes" xml:space="preserve">
          <source>Some limits can be changed at run-time on a per-connection basis using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface with one of the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;limit categories&lt;/a&gt; defined for that interface. Run-time limits are designed for applications that have multiple databases, some of which are for internal use only and others which can be influenced or controlled by potentially hostile external agents. For example, a web browser application might use an internal database to track historical page views but have one or more separate databases that are created and controlled by javascript applications that are downloaded from the internet. The &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface allows internal databases managed by trusted code to be unconstrained while simultaneously placing tight limitations on databases created or controlled by untrusted external code in order to help prevent a denial of service attack.</source>
          <target state="translated">Некоторые ограничения могут быть изменены во время выполнения для каждого соединения с помощью интерфейса &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; с одной из &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;категорий ограничений,&lt;/a&gt; определенных для этого интерфейса. Ограничения времени выполнения предназначены для приложений с несколькими базами данных, некоторые из которых предназначены только для внутреннего использования, а другие могут контролироваться или контролироваться потенциально враждебными внешними агентами. Например, приложение веб-браузера может использовать внутреннюю базу данных для отслеживания исторических просмотров страниц, но иметь одну или несколько отдельных баз данных, которые создаются и контролируются приложениями javascript, загружаемыми из Интернета. &lt;a href=&quot;c3ref/limit&quot;&gt;Sqlite3_limit ()&lt;/a&gt;Интерфейс позволяет не ограничивать внутренние базы данных, управляемые доверенным кодом, одновременно накладывая жесткие ограничения на базы данных, созданные или контролируемые ненадежным внешним кодом, чтобы помочь предотвратить атаку отказа в обслуживании.</target>
        </trans-unit>
        <trans-unit id="27f0f8e3878344df85d2a4246c11bee1e47d7640" translate="yes" xml:space="preserve">
          <source>Some older versions of Linux used the LinuxThreads library for thread support. LinuxThreads is similar to Pthreads, but is subtly different with respect to handling of POSIX advisory locks. SQLite versions 2.2.3 through 3.6.23 recognized that LinuxThreads were being used at runtime and took appropriate action to work around the non-standard behavior of LinuxThreads. But most modern Linux implementations make use of the newer, and correct, NPTL implementation of Pthreads. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), the use of NPTL is assumed. No checks are made. Hence, recent versions of SQLite will subtly malfunction and may corrupt database files if used in multi-threaded application that run on older linux systems that make use of LinuxThreads.</source>
          <target state="translated">Некоторые старые версии Linux использовали библиотеку LinuxThreads для поддержки потоков. LinuxThreads похож на Pthreads, но немного отличается в отношении обработки рекомендательных блокировок POSIX. SQLite версий с 2.2.3 по 3.6.23 распознал, что LinuxThreads использовался во время выполнения, и предпринял соответствующие действия, чтобы обойти нестандартное поведение LinuxThreads. Но большинство современных реализаций Linux используют более новую и правильную реализацию NPTL для потоков Pthreads. Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.0 ( 21.07.2010 ) предполагается использование NPTL. Никаких проверок не производится. Следовательно, последние версии SQLite будут работать с небольшими сбоями и могут повредить файлы базы данных, если они используются в многопоточном приложении, которое работает в старых системах Linux, использующих LinuxThreads.</target>
        </trans-unit>
        <trans-unit id="0bef87b7bc572b2934b8ea6d4c58c70ed7dd3633" translate="yes" xml:space="preserve">
          <source>Some older versions of SQLite (prior to version 2.4.0) would show decreasing performance after a sequence of DELETEs followed by new INSERTs. As this test shows, the problem has now been resolved.</source>
          <target state="translated">Некоторые старые версии SQLite (до версии 2.4.0)показали бы снижение производительности после последовательности DELETE,за которой следовали бы новые INSERT.Как показывает этот тест,теперь проблема решена.</target>
        </trans-unit>
        <trans-unit id="4b536a604954c308bdf6df6ee3bb8ed7c841aa8c" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode in every bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52125a8361f282383783887e4dc2c4cfed4a215d" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode run a bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="translated">Некоторые коды операций изменяются автоматически. Например, код операции &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; (который всегда является первым кодом операции запуска программы с байт-кодом) увеличивает свой операнд P1. Последующий &lt;a href=&quot;opcode#Once&quot;&gt;После&lt;/a&gt; опкодов сравнение их P1 операндов к значению P1 для &lt;a href=&quot;opcode#Init&quot;&gt;инициализации&lt;/a&gt; опкода для того , чтобы определить , является ли один-временным код инициализации , который следует следует пропустить. Другой пример - код операции &lt;a href=&quot;opcode#String8&quot;&gt;String8,&lt;/a&gt; который преобразует свой операнд P4 из UTF-8 в правильную кодировку строки базы данных, а затем преобразует себя в код операции &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="426e64b4a66f4f7807aa6667039b81573979fe2a" translate="yes" xml:space="preserve">
          <source>Some opcodes use all five operands. Some opcodes use one or two. Some opcodes use none of the operands.</source>
          <target state="translated">Некоторые опкоды используют все пять операндов.Некоторые опкоды используют один или два.Некоторые опкоды не используют ни одного из операндов.</target>
        </trans-unit>
        <trans-unit id="18b335ac36fb2d38cd00024b326c89df9316f364" translate="yes" xml:space="preserve">
          <source>Some or all of these restrictions may be removed in the future.</source>
          <target state="translated">Некоторые или все эти ограничения могут быть сняты в будущем.</target>
        </trans-unit>
        <trans-unit id="b476a9e69a79b5371957fc7b1a40c95e375aeff4" translate="yes" xml:space="preserve">
          <source>Some other SQL database engines advise developers to store blobs in separate files and then store the filename in the database. In that case, where the database must first be consulted to find the filename before opening and reading the file, simply storing the entire blob in the database gives much faster read and write performance with SQLite. See the &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article for more information.</source>
          <target state="translated">Некоторые другие движки баз данных SQL рекомендуют разработчикам хранить большие двоичные объекты в отдельных файлах, а затем сохранять имя файла в базе данных. В том случае, когда необходимо сначала проконсультироваться с базой данных, чтобы найти имя файла перед открытием и чтением файла, простое сохранение всего большого двоичного объекта в базе данных дает гораздо более высокую производительность чтения и записи с помощью SQLite. См. Статью о &lt;a href=&quot;intern-v-extern-blob&quot;&gt;внутренних и внешних больших двоичных объектах&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="e94448e3ce0b80c02ec3cf58a3a89e81bfc4e794" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the new row is inserted.</source>
          <target state="translated">Некоторые другие ограничения БД,например,UNIQUE или CHECK,могут быть нарушены при вставке новой строки.</target>
        </trans-unit>
        <trans-unit id="d87a22bd6e23f0cc806f999949a67d71c38a0517" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the row is updated.</source>
          <target state="translated">Некоторые другие ограничения БД,например UNIQUE или CHECK,могут быть нарушены при обновлении строки.</target>
        </trans-unit>
        <trans-unit id="a803eb726af2b55f4a3a45a5ec6b4038451fda8a" translate="yes" xml:space="preserve">
          <source>Some other ways in which FTS5 differs from FTS3/4 are:</source>
          <target state="translated">Есть и другие отличия FTS5 от FTS3/4:</target>
        </trans-unit>
        <trans-unit id="e2d6bed42aa0aeee6bb3a36da7e69907ed2fed99" translate="yes" xml:space="preserve">
          <source>Some people say that we should eliminate all warnings because benign warnings mask real warnings that might arise in future changes. This is true enough. But in reply, the developers observe that all warnings have already been fixed in the builds used for SQLite development (various versions of GCC, MSVC, and clang). Compiler warnings usually only arise from compilers or compile-time options that the SQLite developers do not use themselves.</source>
          <target state="translated">Некоторые люди говорят,что мы должны устранить все предупреждения,потому что доброкачественные предупреждения маскируют реальные предупреждения,которые могут возникнуть при будущих изменениях.Это достаточно верно.Но в ответ разработчики отмечают,что все предупреждения уже исправлены в сборках,используемых для разработки SQLite (различные версии GCC,MSVC,clang).Предупреждения компилятора,как правило,выдаются только компиляторами или опциями времени компиляции,которые сами разработчики SQLite не используют.</target>
        </trans-unit>
        <trans-unit id="8711937cd8478cc6ecffffaffa9bef747431485f" translate="yes" xml:space="preserve">
          <source>Some people view RELEASE as the equivalent of COMMIT for a SAVEPOINT. This is an acceptable point of view as long as one remembers that the changes committed by an inner transaction might later be undone by a rollback in an outer transaction.</source>
          <target state="translated">Некоторые люди рассматривают RELEASE как эквивалент COMMIT для SAVEPOINT.Это приемлемая точка зрения,если помнить,что изменения,совершенные внутренней транзакцией,могут быть впоследствии отменены откатом во внешней транзакции.</target>
        </trans-unit>
        <trans-unit id="0c7ab5e876e4a01802f6862f91dcb4e0c53f5563" translate="yes" xml:space="preserve">
          <source>Some pragmas take effect during the SQL compilation stage, not the execution stage. This means if using the C-language &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; API (or similar in a wrapper interface), the pragma may run during the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; call, not during the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call as normal SQL statements do. Or the pragma might run during sqlite3_step() just like normal SQL statements. Whether or not the pragma runs during sqlite3_prepare() or sqlite3_step() depends on the pragma and on the specific release of SQLite.</source>
          <target state="translated">Некоторые прагмы вступают в силу на этапе компиляции SQL, а не на этапе выполнения. Это означает, что при использовании API &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; , &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; , &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; на языке C (или аналогичного в интерфейсе оболочки) прагма может выполняться во время вызова &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; , а не во время вызова &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; как обычный SQL заявления делаю. Или прагма может выполняться во время sqlite3_step (), как обычные операторы SQL. Будет ли прагма выполняться во время sqlite3_prepare () или sqlite3_step (), зависит от прагмы и от конкретной версии SQLite.</target>
        </trans-unit>
        <trans-unit id="16b35f88ff5fdb19b220d3f1fb964fe543a7595b" translate="yes" xml:space="preserve">
          <source>Some programmers cannot imagine developing a complex system like SQLite in a language that is not &quot;object oriented&quot;. So why is SQLite not coded in C++ or Java?</source>
          <target state="translated">Некоторые программисты не могут представить себе разработку такой сложной системы,как SQLite,на языке,который не является &quot;объектно-ориентированным&quot;.Так почему же SQLite не закодирован на C++или Java?</target>
        </trans-unit>
        <trans-unit id="b34c6a5bd79eb90989f1ccbc7f5ec2a47398a0d5" translate="yes" xml:space="preserve">
          <source>Some query parameters are interpreted by the SQLite core and used to modify the characteristics of the new connection. All query parameters are always passed through into the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; even if they are previously read and interpreted by the SQLite core.</source>
          <target state="translated">Некоторые параметры запроса интерпретируются ядром SQLite и используются для изменения характеристик нового соединения. Все параметры запроса всегда передаются в метод xOpen &lt;a href=&quot;vfs&quot;&gt;VFS,&lt;/a&gt; даже если они ранее считывались и интерпретировались ядром SQLite.</target>
        </trans-unit>
        <trans-unit id="dfe466f14dd2cc6407106f618ec85911c7fcc3f4" translate="yes" xml:space="preserve">
          <source>Some readers might be reluctant to consider SQLite as an application file format because they have been inculcated with the idea that all SQL database schemas must be factored into third normal form and store only small primitive data types such as strings and integers. Certainly relational theory is important and designers should strive to understand it. But, as demonstrated above, it is often quite acceptable to store complex information as XML or JSON in text fields of a database. Do what works, not what your database professor said you ought to do.</source>
          <target state="translated">Некоторые читатели могут неохотно рассматривать SQLite в качестве формата файла приложения,поскольку им пришла в голову идея,что все схемы баз данных SQL должны быть переведены в третью нормальную форму и хранить только небольшие примитивные типы данных,такие как строки и целые числа.Безусловно,реляционная теория важна,и проектировщики должны стремиться ее понять.Но,как было показано выше,часто вполне допустимо хранить сложную информацию в виде XML или JSON в текстовых полях базы данных.Делайте то,что работает,а не то,что сказал профессор БД.</target>
        </trans-unit>
        <trans-unit id="da24c123adee2fd8a84517f276f1059ec16db37d" translate="yes" xml:space="preserve">
          <source>Some readers might resist using SQLite as an application file format due to prior exposure to enterprise SQL databases and the caveats and limitations of those other systems. For example, many enterprise database engines advise against storing large strings or BLOBs in the database and instead suggest that large strings and BLOBs be stored as separate files and the filename stored in the database. But SQLite is not like that. Any column of an SQLite database can hold a string or BLOB up to about a gigabyte in size. And for strings and BLOBs of 100 kilobytes or less, &lt;a href=&quot;intern-v-extern-blob&quot;&gt;I/O performance is better&lt;/a&gt; than using separate files.</source>
          <target state="translated">Некоторые читатели могут сопротивляться использованию SQLite в качестве формата файла приложения из-за предшествующего знакомства с корпоративными базами данных SQL, а также предостережений и ограничений этих других систем. Например, многие механизмы корпоративных баз данных не рекомендуют хранить в базе данных большие строки или большие двоичные объекты и вместо этого предлагают хранить большие строки и большие двоичные объекты как отдельные файлы, а имя файла - в базе данных. Но SQLite не такой. Любой столбец базы данных SQLite может содержать строку или большой двоичный объект размером до гигабайта. А для строк и больших двоичных объектов размером 100 килобайт или меньше производительность &lt;a href=&quot;intern-v-extern-blob&quot;&gt;ввода-вывода лучше,&lt;/a&gt; чем при использовании отдельных файлов.</target>
        </trans-unit>
        <trans-unit id="4623126273e781b93958cb9c59802c9b42b20a62" translate="yes" xml:space="preserve">
          <source>Some sanity checking code was removed from the inner loop of vdbe.c to help the library to run a little faster. The code is only removed if you compile with -DNDEBUG.</source>
          <target state="translated">Некоторое количество кода проверки вменяемости было удалено из внутреннего цикла vdbe.c,чтобы помочь библиотеке работать немного быстрее.Код удаляется только в том случае,если вы скомпилируете его с помощью -DNDEBUG.</target>
        </trans-unit>
        <trans-unit id="fdb2b13b24f119a63e7d35aeab7a0a13260e1127" translate="yes" xml:space="preserve">
          <source>Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try(). On those systems, sqlite3_mutex_try() will always return SQLITE_BUSY. The SQLite core only ever uses sqlite3_mutex_try() as an optimization so this is acceptable behavior.</source>
          <target state="translated">Некоторые системы (например,Windows 95)не поддерживают операцию,реализованную функцией sqlite3_mutex_try().На этих системах функция sqlite3_mutex_try()всегда возвращает SQLITE_BUSY.Ядро SQLite всегда использует sqlite3_mutex_try()только для оптимизации,поэтому такое поведение является приемлемым.</target>
        </trans-unit>
        <trans-unit id="3594c70c212410200cff937ed0dc1d8804fee77c" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations (ex: &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;) make use of real (non-virtual) database tables to store content. For example, when content is inserted into the FTS3 virtual table, the data is ultimately stored in real tables named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot; where &quot;%&quot; is the name of the original virtual table. This auxiliary real tables that store content for a virtual table are called &quot;shadow tables&quot;. See (&lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt;), (&lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt;), and (&lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt;) for additional information.</source>
          <target state="translated">Некоторые реализации виртуальных таблиц (например, &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; и &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; ) используют реальные (не виртуальные) таблицы базы данных для хранения содержимого. Например, когда содержимое вставляется в виртуальную таблицу FTS3, данные в конечном итоге сохраняются в реальных таблицах с именами &amp;laquo;% _content&amp;raquo;, &amp;laquo;% _segdir&amp;raquo;, &amp;laquo;% _segments&amp;raquo;, &amp;laquo;% _stat&amp;raquo; и &amp;laquo;% _docsize&amp;raquo;, где &amp;laquo;% &quot;- это имя исходной виртуальной таблицы. Эти вспомогательные реальные таблицы, в которых хранится содержимое виртуальной таблицы, называются &amp;laquo;теневыми таблицами&amp;raquo;. См. ( &lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt; ), ( &lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt; ) и ( &lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt; ) для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ac3c1999dd15ec935e4c05fd2cbb35a8f0236c55" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="translated">Некоторые реализации виртуальных таблиц могут ВСТАВЛЯТЬ строки в таблицы rowid как часть фиксации транзакции (например, для сброса данных, накопленных в памяти, на диск). В этом случае последующие вызовы этой функции возвращают идентификатор строки, связанный с этими внутренними операциями INSERT, что приводит к неинтуитивным результатам. Реализации виртуальных таблиц, которые делают запись в таблицы rowid таким образом, могут избежать этой проблемы, восстанавливая исходное значение &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;rowid&lt;/a&gt; с помощью sqlite3_set_last_insert_rowid () перед возвратом управления пользователю.</target>
        </trans-unit>
        <trans-unit id="bf0309e04b01e09dca18924e050475fbb9284235" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="translated">Некоторые реализации виртуальных таблиц могут ВСТАВЛЯТЬ строки в таблицы rowid как часть фиксации транзакции (например, для сброса данных, накопленных в памяти, на диск). В этом случае последующие вызовы этой функции возвращают идентификатор строки, связанный с этими внутренними операциями INSERT, что приводит к неинтуитивным результатам. Реализации виртуальных таблиц, которые делают запись в таблицы rowid таким образом, могут избежать этой проблемы, восстанавливая исходное значение &lt;a href=&quot;set_last_insert_rowid&quot;&gt;rowid&lt;/a&gt; с помощью sqlite3_set_last_insert_rowid () перед возвратом управления пользователю.</target>
        </trans-unit>
        <trans-unit id="37863aa03861c512ad1c77afb4b6689cfad7493b" translate="yes" xml:space="preserve">
          <source>Some virtual tables exist automatically in the &quot;main&quot; schema of every database connection in which their module is registered, even without a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. Such virtual tables are called &quot;eponymous virtual tables&quot;. To use an eponymous virtual table, simply use the module name as if it were a table. Eponymous virtual tables exist in the &quot;main&quot; schema only, so they will not work if prefixed with a different schema name.</source>
          <target state="translated">Некоторые виртуальные таблицы автоматически существуют в &amp;laquo;основной&amp;raquo; схеме каждого соединения с базой данных, в котором зарегистрирован их модуль, даже без оператора &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; . Такие виртуальные таблицы называются &amp;laquo;одноименными виртуальными таблицами&amp;raquo;. Чтобы использовать одноименную виртуальную таблицу, просто используйте имя модуля, как если бы это была таблица. Одноименные виртуальные таблицы существуют только в &amp;laquo;основной&amp;raquo; схеме, поэтому они не будут работать, если им присвоено другое имя схемы.</target>
        </trans-unit>
        <trans-unit id="0235dde661a1106f01332ba53a569381817a7286" translate="yes" xml:space="preserve">
          <source>Someone (or some process) might rename the database file but fail to also rename its associated journal.</source>
          <target state="translated">Кто-то (или какой-то процесс)может переименовать файл базы данных,но не сможет переименовать и связанный с ним журнал.</target>
        </trans-unit>
        <trans-unit id="4532d3d7be4feca574a6f6430b43e863945ec230" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;b&gt;sqlite_exec()&lt;/b&gt; would return SQLITE_PROTOCOL when it should have returned SQLITE_BUSY.</source>
          <target state="translated">Иногда &lt;b&gt;sqlite_exec ()&lt;/b&gt; возвращал SQLITE_PROTOCOL, хотя должен был возвращать SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="dc0c06ae51aa05a33354304329c9c25f09e5959c" translate="yes" xml:space="preserve">
          <source>Sometimes SQLite uses compile-time evaluatable assert() statements. Consider the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&lt;/a&gt;. Four assert() statements verify the values for compile-time constants so that the reader can quickly check the validity of the if-statement that follows, without having to look up the constant values in a separate header file.</source>
          <target state="translated">Иногда SQLite использует вычисляемые операторы assert () во время компиляции. Рассмотрим код на &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&lt;/a&gt; . Четыре оператора assert () проверяют значения констант времени компиляции, чтобы читатель мог быстро проверить правильность следующего оператора if без необходимости искать значения констант в отдельном файле заголовка.</target>
        </trans-unit>
        <trans-unit id="e72dc8159e740969eabd99a1be0aa498a87e7c0f" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be completely omitted from a query without changing the result. This can happen if all of the following are true:</source>
          <target state="translated">Иногда LEFT JOIN может быть полностью опущен из запроса без изменения результата.Это может произойти,если все нижеследующее верно:</target>
        </trans-unit>
        <trans-unit id="3f8fa5c7b1abe4111bb41632dd1fff37e6c00e99" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be converted into an ordinary JOIN, if there are terms in the WHERE clause that guarantee that the two joins will give identical results. In particular, if any column in the right-hand table of the LEFT JOIN must be non-NULL in order for the WHERE clause to be true, then the LEFT JOIN is demoted to an ordinary JOIN.</source>
          <target state="translated">Иногда LEFT JOIN может быть конвертирован в обычное JOIN,если в пункте WHERE есть условия,гарантирующие,что два соединения дадут одинаковый результат.В частности,если любой столбец в правой таблице ЛЕВОГО СОГЛАШЕНИЯ должен быть НЕРНЫМ,чтобы условие WHERE было верным,тогда ЛЕВОЕ СОГЛАШЕНИЕ понижается до обычного СОГЛАШЕНИЯ.</target>
        </trans-unit>
        <trans-unit id="f090235439a288798f47de0b5a65b1ea028dc3f6" translate="yes" xml:space="preserve">
          <source>Sometimes a power failure will cause a filesystem to be corrupted such that recently changed filenames are forgotten and the file is moved into a &quot;/lost+found&quot; directory. When that happens, the hot journal will not be found and recovery will not occur. SQLite tries to prevent this by opening and syncing the directory containing the rollback journal at the same time it syncs the journal file itself. However, the movement of files into /lost+found can be caused by unrelated processes creating unrelated files in the same directory as the main database file. And since this is out from under the control of SQLite, there is nothing that SQLite can do to prevent it. If you are running on a system that is vulnerable to this kind of filesystem namespace corruption (most modern journalling filesystems are immune, we believe) then you might want to consider putting each SQLite database file in its own private subdirectory.</source>
          <target state="translated">Иногда сбой электропитания приводит к повреждению файловой системы,так что недавно измененные имена файлов забываются,и файл перемещается в каталог &quot;/lost+found&quot;.В этом случае горячий журнал не будет найден и восстановление не произойдет.SQLite пытается предотвратить это,открывая и синхронизируя каталог,содержащий журнал отката,одновременно синхронизируя сам файл журнала.Однако,перемещение файлов в /lost+found может быть вызвано несвязанными процессами создания несвязанных файлов в той же директории,что и основной файл БД.А так как это находится вне контроля SQLite,то нет ничего,что SQLite может сделать,чтобы предотвратить это.Если вы работаете на системе,которая уязвима к такого рода повреждениям пространства имен файловой системы (мы полагаем,что большинство современных файловых систем журналов защищены от них),то,возможно,вам стоит подумать о том,чтобы поместить каждый файл базы данных SQLite в свою собственную закрытую поддиректорию.</target>
        </trans-unit>
        <trans-unit id="3f9f858786d7c98364aee861ef2804edc03f7313" translate="yes" xml:space="preserve">
          <source>Sometimes applications encounter this error even though there is an abundance of primary disk space because the error occurs when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt; on a system where temporary files are stored on a separate partition with much less space that the primary disk.</source>
          <target state="translated">Иногда приложения сталкиваются с этой ошибкой, даже если первичного дискового пространства много, потому что ошибка возникает при записи во &lt;a href=&quot;tempfiles&quot;&gt;временные файлы&lt;/a&gt; на диске в системе, где временные файлы хранятся в отдельном разделе с гораздо меньшим пространством, чем на основном диске.</target>
        </trans-unit>
        <trans-unit id="fff8b7e3376a922064133232ffd6552acd46f238" translate="yes" xml:space="preserve">
          <source>Sometimes compile-time assert() statements are used to verify that SQLite has been correctly compiled. For example, the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&lt;/a&gt; verifies that the SQLITE_PTRSIZE preprocessor macro is set correctly for the target architecture.</source>
          <target state="translated">Иногда операторы assert () во время компиляции используются для проверки правильности компиляции SQLite. Например, код на &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&lt;/a&gt; проверяет правильность установки макроса препроцессора SQLITE_PTRSIZE для целевой архитектуры.</target>
        </trans-unit>
        <trans-unit id="d7e0873ee1e2576915056da7a06e2b494b2dd17f" translate="yes" xml:space="preserve">
          <source>Sometimes only part of an ORDER BY clause can be satisfied using indexes. Consider, for example, the following query:</source>
          <target state="translated">Иногда с помощью индексов может быть удовлетворена только часть пункта ЗАКАЗАТЬ ПО ЗАКАЗЧИКУ.Рассмотрим,например,следующий запрос:</target>
        </trans-unit>
        <trans-unit id="08e9765fc44bda2fdb0012e4541cc28a30458938" translate="yes" xml:space="preserve">
          <source>Sometimes operating systems will exhibit non-standard behavior which can lead to problems. Sometimes this non-standard behavior is deliberate, and sometimes it is a mistake in the implementation. But in any event, if the operating performs differently from they way SQLite expects it to perform, the possibility of database corruption exists.</source>
          <target state="translated">Иногда операционные системы проявляют нестандартное поведение,которое может привести к проблемам.Иногда такое нестандартное поведение является преднамеренным,а иногда и ошибкой в реализации.Но в любом случае,если операция работает не так,как ожидает SQLite,существует вероятность повреждения базы данных.</target>
        </trans-unit>
        <trans-unit id="60f1e4ae24175645a79034bd7c885a1e7d0f09d3" translate="yes" xml:space="preserve">
          <source>Sometimes the use of row values just makes the SQL easier to read and write. Consider the following two UPDATE statements:</source>
          <target state="translated">Иногда использование значений строк просто делает SQL более удобным для чтения и записи.Рассмотрим два следующих оператора UPDATE:</target>
        </trans-unit>
        <trans-unit id="24e2bab9e04a22b3a6d58f84b00743d3fb69e859" translate="yes" xml:space="preserve">
          <source>Sometimes when this error code is encountered, the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; routine will convert the error into &lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY&lt;/a&gt; and try again to prepare the SQL statement using a different query plan that does not require the use of the unknown collating sequence.</source>
          <target state="translated">Иногда, когда встречается этот код ошибки, процедура &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; преобразует ошибку в &lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY&lt;/a&gt; и снова пытается подготовить оператор SQL, используя другой план запроса, который не требует использования неизвестной последовательности сортировки.</target>
        </trans-unit>
        <trans-unit id="adc4e96a478be02a8147b100bd68113f38b89f80" translate="yes" xml:space="preserve">
          <source>Sort</source>
          <target state="translated">Sort</target>
        </trans-unit>
        <trans-unit id="5601af90fba7fe38466b58c08c018711849b8855" translate="yes" xml:space="preserve">
          <source>Sort order</source>
          <target state="translated">Сортировочный заказ</target>
        </trans-unit>
        <trans-unit id="74ab25d1e3d8ae1cb528685baf2d71b92460809e" translate="yes" xml:space="preserve">
          <source>SorterCompare</source>
          <target state="translated">SorterCompare</target>
        </trans-unit>
        <trans-unit id="e274ec5d63c6eab4a322b40fa92da953e269dcf5" translate="yes" xml:space="preserve">
          <source>SorterData</source>
          <target state="translated">SorterData</target>
        </trans-unit>
        <trans-unit id="84dc5b8de2832faa332b637acd50721fb4db3efe" translate="yes" xml:space="preserve">
          <source>SorterInsert</source>
          <target state="translated">SorterInsert</target>
        </trans-unit>
        <trans-unit id="2737748d72de05dcf6eba2817820522a4badd0ec" translate="yes" xml:space="preserve">
          <source>SorterNext</source>
          <target state="translated">SorterNext</target>
        </trans-unit>
        <trans-unit id="efe2a2f235ed328025a0db49a289c00d154bb3ba" translate="yes" xml:space="preserve">
          <source>SorterOpen</source>
          <target state="translated">SorterOpen</target>
        </trans-unit>
        <trans-unit id="58a2d7ee050bba205b0d21e366ed8ecfcceedf59" translate="yes" xml:space="preserve">
          <source>SorterSort</source>
          <target state="translated">SorterSort</target>
        </trans-unit>
        <trans-unit id="7dadfa55de2cffb43bdf1a8f139a4a743a9af71b" translate="yes" xml:space="preserve">
          <source>Sorting is accomplished by writing records into a sorting index, then rewinding that index and playing it back from beginning to end. We use the &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; opcode instead of &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; to do the rewinding so that the global variable will be incremented and regression tests can determine whether or not the optimizer is correctly optimizing out sorts.</source>
          <target state="translated">Сортировка выполняется путем записи записей в индекс сортировки, затем перемотки этого индекса и воспроизведения его от начала до конца. Мы используем код операции &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; вместо &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind,&lt;/a&gt; чтобы выполнить перемотку, чтобы глобальная переменная была увеличена, а регрессионные тесты могли определить, правильно ли оптимизатор оптимизирует сортировку.</target>
        </trans-unit>
        <trans-unit id="94c08b606385251adc6f9a4723f760124243a4d3" translate="yes" xml:space="preserve">
          <source>Sorting subsets of the result</source>
          <target state="translated">Сортировка подмножеств результата</target>
        </trans-unit>
        <trans-unit id="516e89309d994acf5d94c4a4907b3ff4a8e53a80" translate="yes" xml:space="preserve">
          <source>Source Of Data In A Query Result</source>
          <target state="translated">Источник данных в результате запроса</target>
        </trans-unit>
        <trans-unit id="cfbc658da4e64bd6eef7ec70eab5adab3d14a41a" translate="yes" xml:space="preserve">
          <source>Source code for several useful extensions can be found in the &lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext/misc&lt;/a&gt; subdirectory of the SQLite source tree. You can use these extensions as-is, or as a basis for creating your own custom extensions to address your own particular needs.</source>
          <target state="translated">Исходный код для нескольких полезных расширений можно найти в подкаталоге &lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext / misc&lt;/a&gt; дерева исходных текстов SQLite. Вы можете использовать эти расширения как есть или в качестве основы для создания ваших собственных расширений для удовлетворения ваших конкретных потребностей.</target>
        </trans-unit>
        <trans-unit id="950fc9d085d8682e69cc0123aa548c93074cdbe7" translate="yes" xml:space="preserve">
          <source>Source code for several useful extensions can be found in the &lt;a href=&quot;https://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext/misc&lt;/a&gt; subdirectory of the SQLite source tree. You can use these extensions as-is, or as a basis for creating your own custom extensions to address your own particular needs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64243b8fe27d8786b74ebe9ad360b0c831315629" translate="yes" xml:space="preserve">
          <source>Sources are in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. Use for any purpose.</source>
          <target state="translated">Источники находятся в &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;открытом доступе&lt;/a&gt; . Используйте для любых целей.</target>
        </trans-unit>
        <trans-unit id="bdb7e396773f80244c6756a8ac8a3ba107260e6f" translate="yes" xml:space="preserve">
          <source>Spatial indices using &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;</source>
          <target state="translated">Пространственные индексы с использованием &lt;a href=&quot;rtree&quot;&gt;R-деревьев&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f329318e826b6123bdadb48df921310c8b500b7" translate="yes" xml:space="preserve">
          <source>Speak no useless words or words that move to laughter.</source>
          <target state="translated">Не говори бесполезных слов или слов,которые движутся к смеху.</target>
        </trans-unit>
        <trans-unit id="9cda32c171792b8ebd4697561ad451beebb8dd76" translate="yes" xml:space="preserve">
          <source>Special INSERT operates can be used to issue commands to FTS3 and FTS4 tables. Every FTS3 and FTS4 has a hidden, read-only column which is the same name as the table itself. INSERTs into this hidden column are interpreted as commands to the FTS3/4 table. For a table with the name &quot;xyz&quot; the following commands are supported:</source>
          <target state="translated">Для выдачи команд к таблицам FTS3 и FTS4 можно использовать специальные операции INSERT.Каждый FTS3 и FTS4 имеет скрытый,доступный только для чтения столбец,который имеет то же имя,что и сама таблица.INSERT в этот скрытый столбец интерпретируется как команды к таблице FTS3/4.Для таблицы с именем &quot;xyz&quot; поддерживаются следующие команды:</target>
        </trans-unit>
        <trans-unit id="5c62a06b3206449dc4ac80333e6db0c204db7ba5" translate="yes" xml:space="preserve">
          <source>Special processing occurs when the aggregate function is either &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt;. Example:</source>
          <target state="translated">Специальная обработка происходит, когда агрегатной функцией является &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min ()&lt;/a&gt; или &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max ()&lt;/a&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="6937900c4a39aa0fb125a152dfd5d62be4f8822d" translate="yes" xml:space="preserve">
          <source>Special sqlite_stat1 Handling</source>
          <target state="translated">Специальная обработка sqlite_stat1</target>
        </trans-unit>
        <trans-unit id="1e4c6816e6235fac1910f655a4449098f3bab054" translate="yes" xml:space="preserve">
          <source>Special versions of the SQLite amalgamation that do work with a predetermined set of SQLITE_OMIT_* options can be generated. To do so, make a copy of the Makefile.linux-gcc makefile template in the canonical source code distribution. Change the name of your copy to simply &quot;Makefile&quot;. Then edit &quot;Makefile&quot; to set up appropriate compile-time options. Then type:</source>
          <target state="translated">Могут быть сгенерированы специальные версии слияния SQLite,которые работают с предопределенным набором опций SQLITE_OMIT_*.Для этого сделайте копию makefile шаблона Makefile.linux-gcc в каноническом дистрибутиве исходных текстов.Измените имя своей копии на просто &quot;Makefile&quot;.Затем отредактируйте &quot;Makefile&quot;,чтобы установить соответствующие опции времени компиляции.Затем введите:</target>
        </trans-unit>
        <trans-unit id="348842ed415067bf469c3c07cbca8231199b183f" translate="yes" xml:space="preserve">
          <source>Specialized applications for which the default implementation of shared memory is unacceptable can devise alternative methods via a custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. For example, if it is known that a particular database will only be accessed by threads within a single process, the wal-index can be implemented using heap memory instead of true shared memory.</source>
          <target state="translated">Специализированные приложения, для которых реализация разделяемой памяти по умолчанию неприемлема, могут разработать альтернативные методы с помощью специальной &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; . Например, если известно, что к конкретной базе данных будут обращаться только потоки в рамках одного процесса, то wal-index может быть реализован с использованием памяти кучи вместо истинной разделяемой памяти.</target>
        </trans-unit>
        <trans-unit id="a647b0621c3756491eb85db442ab54ae4811cd09" translate="yes" xml:space="preserve">
          <source>Specific pragma statements may be removed and others added in future releases of SQLite. There is no guarantee of backwards compatibility.</source>
          <target state="translated">Конкретные прагматические выражения могут быть удалены,а другие добавлены в будущие релизы SQLite.Гарантия обратной совместимости отсутствует.</target>
        </trans-unit>
        <trans-unit id="32a894085a5589da14805f40b5e5ec42d34bdb30" translate="yes" xml:space="preserve">
          <source>Specify an alternative malloc implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object.</source>
          <target state="translated">Укажите альтернативную реализацию malloc, используя команду &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; с объектом &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7969816e7b05b7f6c6da58d9c3d55a797859dc5f" translate="yes" xml:space="preserve">
          <source>Specify an alternative mutex implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="translated">Укажите альтернативную реализацию мьютекса, используя команду &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; с объектом &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7d9e8c303af8fa2eba928e74e37e3e2d5b8ccc2" translate="yes" xml:space="preserve">
          <source>Specify an application-defined page cache.</source>
          <target state="translated">Укажите кэш страниц,определяемый приложением.</target>
        </trans-unit>
        <trans-unit id="675036f344331d67d2ac3929e1284013b1817b31" translate="yes" xml:space="preserve">
          <source>Specifying a new page size does not change the page size immediately. Instead, the new page size is remembered and is used to set the page size when the database is first created, if it does not already exist when the page_size pragma is issued, or at the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command that is run on the same database connection while not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">Указание нового размера страницы не приводит к немедленному изменению размера страницы. Вместо этого новый размер страницы запоминается и используется для установки размера страницы при первом создании базы данных, если он еще не существует, когда выдается прагма page_size, или при следующей команде &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM,&lt;/a&gt; которая запускается в том же соединении с базой данных. пока не в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dfdc7dcd44b7642ef54261a530f0a8d271e92800" translate="yes" xml:space="preserve">
          <source>Specifying an explicit value for the rowid field as part of an INSERT statement is not supported. Any value supplied is ignored.</source>
          <target state="translated">Указание явного значения для строкового поля как части оператора INSERT не поддерживается.Любое заданное значение игнорируется.</target>
        </trans-unit>
        <trans-unit id="ff83e10cd15a3b1a3684d12025d600161e1e03fe" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;../uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">Указание неизвестного параметра в компоненте запроса URI не является ошибкой. В будущих версиях SQLite могут быть понятны дополнительные параметры запроса. См. &amp;laquo; &lt;a href=&quot;../uri#coreqp&quot;&gt;Параметры запроса со специальным значением для SQLite&lt;/a&gt; &amp;raquo; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ca08c5f93bc177c41e9e1cbac8bb1b05f691f402" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">Указание неизвестного параметра в компоненте запроса URI не является ошибкой. В будущих версиях SQLite могут быть понятны дополнительные параметры запроса. См. &amp;laquo; &lt;a href=&quot;uri#coreqp&quot;&gt;Параметры запроса со специальным значением для SQLite&lt;/a&gt; &amp;raquo; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b5466deac546a32beeffc729c74a6e5fd300f895" translate="yes" xml:space="preserve">
          <source>Specifying three arguments when creating an fts5vocab table in any database other than &quot;temp&quot; results in an error.</source>
          <target state="translated">Указание трех аргументов при создании таблицы fts5vocab в любой базе данных,отличной от &quot;temp&quot;,приводит к ошибке.</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">Улучшение скорости</target>
        </trans-unit>
        <trans-unit id="65d5a13bd4511e6816f18d10b6fcf53288c30d62" translate="yes" xml:space="preserve">
          <source>Speed improvements and library footprint reductions.</source>
          <target state="translated">Улучшение скорости и уменьшение площади библиотеки.</target>
        </trans-unit>
        <trans-unit id="886fdbf5bb356c1170f6be819f95ecf4cc1461e3" translate="yes" xml:space="preserve">
          <source>Speed improvements in the VDBE.</source>
          <target state="translated">Улучшение скорости в VDBE.</target>
        </trans-unit>
        <trans-unit id="67d42db811b80e228f8d1a0a01dc2cacac3b1009" translate="yes" xml:space="preserve">
          <source>Speed improvements in the btree and pager layers.</source>
          <target state="translated">Улучшение скорости в слоях btree и pager.</target>
        </trans-unit>
        <trans-unit id="0da1385bd95c04e2cef432911cc39014873cc087" translate="yes" xml:space="preserve">
          <source>Speed improvements: Do not do synchronous updates on TEMP tables.</source>
          <target state="translated">Улучшение скорости:Не делайте синхронных обновлений таблиц TEMP.</target>
        </trans-unit>
        <trans-unit id="77d342a78b198923e433b8a1315c81a6ffbf9833" translate="yes" xml:space="preserve">
          <source>Split amalgamation</source>
          <target state="translated">Слияние в одно целое</target>
        </trans-unit>
        <trans-unit id="1dac9d1634f1fa754c9cb08212550ad68bf6b1f7" translate="yes" xml:space="preserve">
          <source>Split the pager subsystem into separate pager and pcache subsystems.</source>
          <target state="translated">Разделить подсистему пейджера на отдельные подсистемы пейджера и кэша.</target>
        </trans-unit>
        <trans-unit id="1bb46447f9362d79f903651b48710b55ec51dd8a" translate="yes" xml:space="preserve">
          <source>Splitting content into smaller pieces also helps File/Save operations to go faster. Instead of having to write back the content of all pages when doing a File/Save, the application only has to write back those pages that have actually changed.</source>
          <target state="translated">Разделение содержимого на более мелкие части также помогает быстрее выполнять операции &quot;Файл/Сохранить&quot;.Вместо того,чтобы при выполнении операции Файл/Сохранение записывать обратно содержимое всех страниц,приложение должно записывать обратно только те страницы,которые действительно изменились.</target>
        </trans-unit>
        <trans-unit id="f0b1c55ba41f5df4c296b1603dd8662a874ad05f" translate="yes" xml:space="preserve">
          <source>SqlExec</source>
          <target state="translated">SqlExec</target>
        </trans-unit>
        <trans-unit id="21ba7365f757b4f24cbf08b5870a91de5cd965d8" translate="yes" xml:space="preserve">
          <source>Sqldiff --rbu</source>
          <target state="translated">Склдифф...</target>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="d96e5b2dd07c1733b2b013bd82922c22baade37d" translate="yes" xml:space="preserve">
          <source>Stable</source>
          <target state="translated">Stable</target>
        </trans-unit>
        <trans-unit id="ed9cb8071fd38e38b556df67e342f21ef7bd62db" translate="yes" xml:space="preserve">
          <source>Stable interfaces will be maintained indefinitely in a backwards compatible way. An application that uses only stable interfaces should always be able to relink against a newer version of SQLite without any changes.</source>
          <target state="translated">Стабильные интерфейсы будут поддерживаться бесконечно в обратно совместимом виде.Приложение,использующее только стабильные интерфейсы,всегда должно быть в состоянии безо всяких изменений перейти на новую версию SQLite.</target>
        </trans-unit>
        <trans-unit id="9d69ca23f60003536eb90ef7c1a45510967cd2a5" translate="yes" xml:space="preserve">
          <source>Stale file descriptor</source>
          <target state="translated">Дескриптор устаревших файлов</target>
        </trans-unit>
        <trans-unit id="aaf4ee63c814f2ac7a90ca00e168f99ba47070e5" translate="yes" xml:space="preserve">
          <source>Standard File Control Opcodes</source>
          <target state="translated">Стандартные опкоды управления файлами</target>
        </trans-unit>
        <trans-unit id="0271f691eaa2014cfdc1f8a7ed1187c67c1f03ee" translate="yes" xml:space="preserve">
          <source>Standard Query Syntax Precedence</source>
          <target state="translated">Преобладание синтаксиса стандартных запросов</target>
        </trans-unit>
        <trans-unit id="62af2c2f7d7a242deb88ffff88441215850f0cf0" translate="yes" xml:space="preserve">
          <source>Standard builds include the default &quot;unix&quot; or &quot;win32&quot; VFSes. But if you use the -DOS_OTHER=1 compile-time option, then SQLite is built without a default VFS. In that case, the application must register at least one VFS prior to calling &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;. This is the approach that embedded applications should use. Rather than modifying the SQLite source to insert an alternative OS layer as was done in prior releases of SQLite, instead compile an unmodified SQLite source file (preferably the amalgamation) with the -DOS_OTHER=1 option, then invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to define the interface to the underlying filesystem prior to creating any database connections.</source>
          <target state="translated">Стандартные сборки включают VFS по умолчанию &quot;unix&quot; или &quot;win32&quot;. Но если вы используете параметр времени компиляции -DOS_OTHER = 1, то SQLite будет построен без VFS по умолчанию. В этом случае приложение должно зарегистрировать хотя бы одну VFS перед вызовом &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; . Это подход, который должны использовать встроенные приложения. Вместо того, чтобы изменять исходный код SQLite для вставки альтернативного уровня ОС, как это делалось в предыдущих выпусках SQLite, вместо этого скомпилируйте неизмененный исходный файл SQLite (желательно объединение) с параметром -DOS_OTHER = 1, затем вызовите &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; для определения интерфейса к базовой файловой системе перед созданием любых подключений к базе данных.</target>
        </trans-unit>
        <trans-unit id="f4bb77fea34e91bf036ddd54845284d1cf9ef7e7" translate="yes" xml:space="preserve">
          <source>Standard builds of SQLite for Unix or Windows come with a single VFS named &quot;unix&quot; or &quot;win32&quot;, as appropriate. This one VFS is also the default. So if you are using the legacy open functions, everything will continue to operate as it has before. The change is that an application now has the flexibility of adding new VFS modules to implement a customized OS layer. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; API can be used to tell SQLite about one or more application-defined VFS modules:</source>
          <target state="translated">Стандартные сборки SQLite для Unix или Windows поставляются с одной VFS с именем &amp;laquo;unix&amp;raquo; или &amp;laquo;win32&amp;raquo;, в зависимости от ситуации. Эта VFS также используется по умолчанию. Поэтому, если вы используете устаревшие открытые функции, все будет продолжать работать, как и раньше. Изменение заключается в том, что приложение теперь имеет возможность добавлять новые модули VFS для реализации настраиваемого уровня ОС. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;Sqlite3_vfs_register ()&lt;/a&gt; API может быть использован , чтобы сказать SQLite об одном или нескольких модулей VFS определенных приложением:</target>
        </trans-unit>
        <trans-unit id="d9cadaed061bc7503c3155b4851296844f6b19b6" translate="yes" xml:space="preserve">
          <source>Start a read transaction on an historical snapshot</source>
          <target state="translated">Начните чтение с исторического моментального снимка.</target>
        </trans-unit>
        <trans-unit id="789445bbe2e230b404b0877611cb047ff79a2a8a" translate="yes" xml:space="preserve">
          <source>Start a transaction.</source>
          <target state="translated">Начать сделку.</target>
        </trans-unit>
        <trans-unit id="5ad3ad0c5dcdfd16f6c5507085aa11afef993658" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database (or &lt;a href=&quot;#zipdb&quot;&gt;ZIP archive&lt;/a&gt;). If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b65d3b5410040822706753355b83a262ca2b3805" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database. If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="translated">Запустите программу &lt;b&gt;sqlite3&lt;/b&gt; , набрав &amp;laquo;sqlite3&amp;raquo; в командной строке, за которым, при желании, следует имя файла, содержащего базу данных SQLite. Если названный файл не существует, новый файл базы данных с данным именем будет создан автоматически. Если в командной строке не указан файл базы данных, создается временная база данных, которая удаляется при выходе из программы &amp;laquo;sqlite3&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9eb60319509fec567263f40a7e8bf18c02dfd219" translate="yes" xml:space="preserve">
          <source>Starting with &lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;version 3.3.0&lt;/a&gt; (2006-01-11), SQLite includes a special &quot;shared-cache&quot; mode (disabled by default) intended for use in embedded servers. If shared-cache mode is enabled and a thread establishes multiple connections to the same database, the connections share a single data and schema cache. This can significantly reduce the quantity of memory and IO required by the system.</source>
          <target state="translated">Начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;версии 3.3.0&lt;/a&gt; (11 января 2006 г.), SQLite включает специальный режим &amp;laquo;общего кэша&amp;raquo; (отключен по умолчанию), предназначенный для использования во встроенных серверах. Если включен режим общего кэша и поток устанавливает несколько соединений с одной и той же базой данных, соединения совместно используют один кеш данных и схемы. Это может значительно уменьшить объем памяти и операций ввода-вывода, необходимых для системы.</target>
        </trans-unit>
        <trans-unit id="023a31bfb8ddab03b504852064e49a20e7d9d830" translate="yes" xml:space="preserve">
          <source>Startup time is reduced by allowing the application to read in only the content shown for the initial screen. This largely eliminates the need to show a progress bar when opening a new document. The document just pops up immediately, further enhancing the user experience.</source>
          <target state="translated">Время запуска сокращается,позволяя приложению считывать только содержимое,отображаемое на начальном экране.Это в значительной степени устраняет необходимость показывать индикатор выполнения при открытии нового документа.Документ просто всплывает мгновенно,что еще больше повышает удобство работы с ним.</target>
        </trans-unit>
        <trans-unit id="ec7c6f024748b0b4ca685edf7c9c36a22ff2bd48" translate="yes" xml:space="preserve">
          <source>Statement Rollback</source>
          <target state="translated">Отмотка выписки</target>
        </trans-unit>
        <trans-unit id="b1c7b81be5c9efcc042ff8389d0cd187913125cb" translate="yes" xml:space="preserve">
          <source>Statement Transactions</source>
          <target state="translated">Отчетные операции</target>
        </trans-unit>
        <trans-unit id="a90f613a0e148cacdfc6a3c9d8b61b95e2acb93e" translate="yes" xml:space="preserve">
          <source>Statement journal</source>
          <target state="translated">Журнал отчётности</target>
        </trans-unit>
        <trans-unit id="eb1040e934c3b0c196798a9d1961f27355d86e45" translate="yes" xml:space="preserve">
          <source>Statement journals</source>
          <target state="translated">Отчетные журналы</target>
        </trans-unit>
        <trans-unit id="ff8ba443e0e2998259e771cf2ecb0604dd034de1" translate="yes" xml:space="preserve">
          <source>Static analysis has not been helpful in finding bugs in SQLite. Static analysis has found a few bugs in SQLite, but those are the exceptions. More bugs have been introduced into SQLite while trying to get it to compile without warnings than have been found by static analysis.</source>
          <target state="translated">Статический анализ не помог найти ошибки в SQLite.Статический анализ нашел несколько ошибок в SQLite,но это исключение.Больше ошибок было внесено в SQLite при попытке заставить его скомпилироваться без предупреждений,чем было найдено статическим анализом.</target>
        </trans-unit>
        <trans-unit id="680999abb1389f8c322acbd6c1aa5dbe84be6521" translate="yes" xml:space="preserve">
          <source>Static analysis means analyzing source code at compile-time to check for correctness. Static analysis includes compiler warning messages and more in-depth analysis engines such as the &lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;. SQLite compiles without warnings on GCC and Clang using the -Wall and -Wextra flags on Linux and Mac and on MSVC on Windows. No valid warnings are generated by the Clang Static Analyzer tool &quot;scan-build&quot; either (though recent versions of clang seem to generate many false-positives.) Nevertheless, some warnings might be generated by other static analyzers. Users are encouraged not to stress over these warnings and to instead take solace in the intense testing of SQLite described above.</source>
          <target state="translated">Статический анализ означает анализ исходного кода во время компиляции для проверки правильности. Статический анализ включает предупреждающие сообщения компилятора и механизмы более глубокого анализа, такие как &lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt; . SQLite компилируется без предупреждений в GCC и Clang с использованием флагов -Wall и -Wextra в Linux и Mac и MSVC в Windows. Инструмент &quot;сканирование-сборка&quot; Clang Static Analyzer также не генерирует никаких допустимых предупреждений (хотя последние версии clang, похоже, генерируют много ложных срабатываний). Тем не менее, некоторые предупреждения могут быть сгенерированы другими статическими анализаторами. Пользователям рекомендуется не беспокоиться из-за этих предупреждений и вместо этого найти утешение в интенсивном тестировании SQLite, описанном выше.</target>
        </trans-unit>
        <trans-unit id="a8a7d3c3c3020e91e0baa9412b077479decb0556" translate="yes" xml:space="preserve">
          <source>Static analysis means analyzing source code at compile-time to check for correctness. Static analysis includes compiler warning messages and more in-depth analysis engines such as the &lt;a href=&quot;https://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;. SQLite compiles without warnings on GCC and Clang using the -Wall and -Wextra flags on Linux and Mac and on MSVC on Windows. No valid warnings are generated by the Clang Static Analyzer tool &quot;scan-build&quot; either (though recent versions of clang seem to generate many false-positives.) Nevertheless, some warnings might be generated by other static analyzers. Users are encouraged not to stress over these warnings and to instead take solace in the intense testing of SQLite described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e49731cc0b88e4893c23ef28a83ddda3bfb212a" translate="yes" xml:space="preserve">
          <source>Statistics gathered by ANALYZE are not automatically updated as the content of the database changes. If the content of the database changes significantly, or if the database schema changes, then one should consider rerunning the ANALYZE command in order to update the statistics.</source>
          <target state="translated">Статистика,собранная ANALYZE,не обновляется автоматически по мере изменения содержимого базы данных.Если содержимое БД существенно изменяется,или если изменяется схема БД,то для обновления статистики следует подумать о повторном запуске команды ANALYZE.</target>
        </trans-unit>
        <trans-unit id="06d77b9bb2436857be2774ccf495a6735714ef3f" translate="yes" xml:space="preserve">
          <source>Statistics might not be available for all loops in all statements. In cases where there exist loops with no available statistics, this function behaves as if the loop did not exist - it returns non-zero and leave the variable that pOut points to unchanged.</source>
          <target state="translated">Статистика может быть доступна не для всех циклов во всех утверждениях.В тех случаях,когда существуют циклы без доступной статистики,эта функция ведет себя так,как будто цикла не было-она возвращает ненулевое значение и оставляет переменную,на которую указывает pOut,без изменений.</target>
        </trans-unit>
        <trans-unit id="bc97dbd639562aa95bfaa677d2f8dc3487a559db" translate="yes" xml:space="preserve">
          <source>Stats pragma</source>
          <target state="translated">статистическая прагматика</target>
        </trans-unit>
        <trans-unit id="df542e628beff2a0b73ed1e479f1091511d9cd6a" translate="yes" xml:space="preserve">
          <source>Status Of A Dynamic String</source>
          <target state="translated">Статус динамической струны</target>
        </trans-unit>
        <trans-unit id="6872312ea81433049bd70deac565b5d633fd6998" translate="yes" xml:space="preserve">
          <source>Status Parameters</source>
          <target state="translated">Параметры статуса</target>
        </trans-unit>
        <trans-unit id="2adc22e7dbafa333d0e47ced61c20bab368c7387" translate="yes" xml:space="preserve">
          <source>Status Parameters for database connections</source>
          <target state="translated">Статус Параметры для подключения к базе данных</target>
        </trans-unit>
        <trans-unit id="8499ef2845b7984472eeaa5eec92eef3c3ddc5e1" translate="yes" xml:space="preserve">
          <source>Status Parameters for prepared statements</source>
          <target state="translated">Статус Параметры подготовленных отчетов</target>
        </trans-unit>
        <trans-unit id="f04daddc4070fdc058ac9e443c8962cff2f5d578" translate="yes" xml:space="preserve">
          <source>Sticky &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; or &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; errors in the pager are reset when a new transaction is started.</source>
          <target state="translated">Sticky &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; или &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; ошибка в пейджере сбрасывается при запуске новой транзакции.</target>
        </trans-unit>
        <trans-unit id="dd4fde80455d82361972cd992928272cdd38d544" translate="yes" xml:space="preserve">
          <source>Storage class</source>
          <target state="translated">Класс хранения</target>
        </trans-unit>
        <trans-unit id="0adf951cb70d6bfcdd293ee933bb14acec2e8923" translate="yes" xml:space="preserve">
          <source>Storage space for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects.</source>
          <target state="translated">Место для хранения объектов &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключения&lt;/a&gt; к базе данных .</target>
        </trans-unit>
        <trans-unit id="fbf3f676fb55796ce1a966642440eafe303dfddd" translate="yes" xml:space="preserve">
          <source>Storage used for</source>
          <target state="translated">Хранение,используемое для</target>
        </trans-unit>
        <trans-unit id="7a5447c3e2de40c5c68aa31375241b98a076167c" translate="yes" xml:space="preserve">
          <source>Store an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt; in a database table so that Undo could go back into prior edit sessions.</source>
          <target state="translated">Сохраните &lt;a href=&quot;undoredo&quot;&gt;автоматизированный стек отмены / повтора&lt;/a&gt; в таблице базы данных, чтобы можно было вернуться к предыдущим сеансам редактирования.</target>
        </trans-unit>
        <trans-unit id="a49a369d4dc034b2ddab0ef35e3bc0a19be08a8f" translate="yes" xml:space="preserve">
          <source>Store in register P2 an integer which is the key of the table entry that P1 is currently point to.</source>
          <target state="translated">Храните в регистре P2 целое число,которое является ключом к записи таблицы,на которую в данный момент указывает P1.</target>
        </trans-unit>
        <trans-unit id="867b15696e9fa5010d6dcd54eb51b1ee5a1a7a9e" translate="yes" xml:space="preserve">
          <source>Store in register P3 the value of the P2-th column of the current row of the virtual-table of cursor P1.</source>
          <target state="translated">Хранить в регистре P3 значение P2-го столбца текущей строки виртуальной таблицы курсора P1.</target>
        </trans-unit>
        <trans-unit id="c36766981b9139e0da225001d40b99095efc88b9" translate="yes" xml:space="preserve">
          <source>Store in register r[P3] the byte offset into the database file that is the start of the payload for the record at which that cursor P1 is currently pointing.</source>
          <target state="translated">Храните в регистре r[P3]смещение байта в файле базы данных,который является началом полезной нагрузки для записи,на которую в данный момент наведен курсор P1.</target>
        </trans-unit>
        <trans-unit id="30c620766d52d9f14ee6085868bffd5fb7f16c25" translate="yes" xml:space="preserve">
          <source>Store new polygons in the table using ordinary INSERT statements:</source>
          <target state="translated">Храните новые полигоны в таблице,используя обычные утверждения INSERT:</target>
        </trans-unit>
        <trans-unit id="e312586c7080f660b8a13dd56528c07ac821e623" translate="yes" xml:space="preserve">
          <source>Store the maximum page count after the change in register P2.</source>
          <target state="translated">Сохраняйте максимальное количество страниц после изменения регистра P2.</target>
        </trans-unit>
        <trans-unit id="4a03a2e19022832dfb9661ede226d69d6b142a41" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2</source>
          <target state="translated">Хранить количество записей (целое значение)в таблице или индексе,открытом курсором P1 в регистре P2.</target>
        </trans-unit>
        <trans-unit id="8f97ad7b80660d239651ee854a82a3871ca04288" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640b00f8e936acd9d22458864812f703b6f037f6" translate="yes" xml:space="preserve">
          <source>Store the statement journal in the temporary file directory instead of collocated with the database file.</source>
          <target state="translated">Храните журнал операторов во временном каталоге вместо того,чтобы совмещать его с файлом базы данных.</target>
        </trans-unit>
        <trans-unit id="25a1d24f343a9c4193ce3147697d66befd80ac3b" translate="yes" xml:space="preserve">
          <source>Storing the schema a text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="translated">Сохранение схемы в тексте также упрощает определение, документирование и понимание &lt;a href=&quot;fileformat2&quot;&gt;формата файла базы данных SQLite&lt;/a&gt; . Это помогает сделать файлы базы данных SQLite &lt;a href=&quot;locrsf&quot;&gt;рекомендуемым форматом хранения&lt;/a&gt; для долгосрочного архивирования данных.</target>
        </trans-unit>
        <trans-unit id="6734d41851e3e8e6c6cbda317484954f124d2cf8" translate="yes" xml:space="preserve">
          <source>Storing the schema as text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9347ad87d0fbebdfc89e77280c0ab0e8462e84d1" translate="yes" xml:space="preserve">
          <source>Storing the schema as text rather than as parsed tables also give flexibility to the implementation. Since the internal parse of the schema is regenerated each time the database is opened, the internal representation of the schema can change from one release to the next. This is important, as sometimes new features require enhancements to the internal schema representation. Changing the internal schema representation would be much more difficult if the schema representation was exposed in the database file. So, in other words, storing the schema as text helps maintain backwards compatibility, and helps ensure that older database files can be read and written by newer versions of SQLite.</source>
          <target state="translated">Хранение схемы в виде текста,а не в виде разобранных таблиц,также придает гибкость реализации.Так как внутренний анализ схемы восстанавливается каждый раз при открытии БД,внутреннее представление схемы может меняться от одного выпуска к другому.Это важно,так как иногда новые функции требуют усовершенствования внутреннего представления схемы.Изменение внутреннего представления схемы было бы гораздо сложнее,если бы оно было открыто в файле базы данных.Другими словами,хранение схемы в виде текста помогает поддерживать обратную совместимость,а также обеспечивает возможность чтения и записи старых файлов БД более новыми версиями SQLite.</target>
        </trans-unit>
        <trans-unit id="275b8884950b47fafacc5239216411e5afbdc454" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions</source>
          <target state="translated">Потоковые версии функций API</target>
        </trans-unit>
        <trans-unit id="1cda8a5c429d321cd55319d79be9050795d95668" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions.</source>
          <target state="translated">Потоковые версии функций API.</target>
        </trans-unit>
        <trans-unit id="41b71513a74ee80684014356a0159868598a4ea7" translate="yes" xml:space="preserve">
          <source>Streaming function</source>
          <target state="translated">Потоковая функция</target>
        </trans-unit>
        <trans-unit id="c76c18624ee750ab230cd2529398af4c90203056" translate="yes" xml:space="preserve">
          <source>Strengthen defenses against deliberately corrupted database files.</source>
          <target state="translated">Усилить защиту от намеренно поврежденных файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="70d422bf6680eb42d320cae6dd4ad922e3705a6b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object is not required since the convenience wrapper interfaces, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt; or &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table&lt;/a&gt;, can be used and these convenience wrappers encapsulate and hide the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object. Nevertheless, an understanding of &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; is needed to make full use of SQLite.</source>
          <target state="translated">Строго говоря, &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный&lt;/a&gt; объект оператора не требуется, поскольку можно использовать удобные интерфейсы оболочки, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt; или &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table&lt;/a&gt; , и эти удобные оболочки инкапсулируют и скрывают &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный&lt;/a&gt; объект оператора . Тем не менее, для полноценного использования SQLite необходимо понимание &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленных операторов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="f631842398197770725f42465ce9be3bb217fe7f" translate="yes" xml:space="preserve">
          <source>String Comparison</source>
          <target state="translated">Сравнение струн</target>
        </trans-unit>
        <trans-unit id="bca91d4c03b6524119c1475d05b8b5503e052ba2" translate="yes" xml:space="preserve">
          <source>String Globbing</source>
          <target state="translated">Стержневой глобус</target>
        </trans-unit>
        <trans-unit id="d8c2dabd43b3a0fa081659375ff18075de8cb9f3" translate="yes" xml:space="preserve">
          <source>String LIKE Matching</source>
          <target state="translated">Спичка струны LIKE Matching</target>
        </trans-unit>
        <trans-unit id="dfab1bcbfa804d1a74a7282da9ab4ff5c5353c70" translate="yes" xml:space="preserve">
          <source>String8</source>
          <target state="translated">String8</target>
        </trans-unit>
        <trans-unit id="add2080ddbdcd32891495b46eb567565fc93baa2" translate="yes" xml:space="preserve">
          <source>Strings returned by sqlite3_column_text() and sqlite3_column_text16(), even empty strings, are always zero-terminated. The return value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.</source>
          <target state="translated">Строки,возвращаемые функциями sqlite3_column_text()и sqlite3_column_text16(),даже пустые строки,всегда заканчиваются нулями.Возвращаемое функцией sqlite3_column_blob()значение для BLOB нулевой длины является указателем NULL.</target>
        </trans-unit>
        <trans-unit id="109fcef442d10303df5f7d59d40936a03977dfcb" translate="yes" xml:space="preserve">
          <source>Strings that include any other characters must be quoted. Characters that are not currently allowed in barewords, are not quote characters and do not currently serve any special purpose in FTS5 query expressions may at some point in the future be allowed in barewords or used to implement new query functionality. This means that queries that are currently syntax errors because they include such a character outside of a quoted string may be interpreted differently by some future version of FTS5.</source>
          <target state="translated">Строки,содержащие любые другие символы,должны быть процитированы.Символы,которые в настоящее время не разрешены в пустых словах,не являются символами кавычек и не служат в настоящее время для специальных целей в выражениях запросов FTS5,могут в какой-то момент в будущем быть разрешены в пустых словах или использованы для реализации новых функциональных возможностей запроса.Это означает,что запросы,которые в настоящее время являются синтаксическими ошибками,поскольку включают такой символ вне кавычек,могут быть интерпретированы по-разному в некоторых будущих версиях FTS5.</target>
        </trans-unit>
        <trans-unit id="0b6945b8df636a6d934a512accf12a8b76fc6265" translate="yes" xml:space="preserve">
          <source>Studies show that many applications already use SQLite as a container object. For example, &lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Kennedy&lt;/a&gt; (no relation to the &lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;SQLite developer&lt;/a&gt;) reports that 14% of Android applications never write to their SQLite databases. It is believed that these applications are downloading entire databases from the cloud and then using the information locally as needed. In other words, the applications are using SQLite not so much as a database but as a queryable wire-transfer format.</source>
          <target state="translated">Исследования показывают, что многие приложения уже используют SQLite в качестве объекта-контейнера. Например, &lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Кеннеди&lt;/a&gt; (не имеющий отношения к &lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;разработчику SQLite&lt;/a&gt; ) сообщает, что 14% приложений Android никогда не записывают данные в свои базы данных SQLite. Считается, что эти приложения загружают целые базы данных из облака, а затем используют информацию локально по мере необходимости. Другими словами, приложения используют SQLite не столько как базу данных, сколько как запрашиваемый формат передачи данных.</target>
        </trans-unit>
        <trans-unit id="bbd17ca7716d1959474368eb0c63e1ad9ad957be" translate="yes" xml:space="preserve">
          <source>Subqueries</source>
          <target state="translated">Subqueries</target>
        </trans-unit>
        <trans-unit id="9a235eb288a64671965312f5d0ad9f1b72cd84b6" translate="yes" xml:space="preserve">
          <source>Subqueries might also need to be materialized when they appear in the FROM clause of a SELECT statement. For example:</source>
          <target state="translated">Подзапросы могут также потребовать выполнения,когда они появляются в пункте FROM заявления SELECT.Например:</target>
        </trans-unit>
        <trans-unit id="79095639cf2544d3073712b3f47816fbf8b20418" translate="yes" xml:space="preserve">
          <source>Subquery Expressions</source>
          <target state="translated">Выражения подзапросов</target>
        </trans-unit>
        <trans-unit id="14de4f03d3cdec3c98a5016002bc81eb0292385c" translate="yes" xml:space="preserve">
          <source>Subquery co-routines</source>
          <target state="translated">Подзапросы совместные маршруты</target>
        </trans-unit>
        <trans-unit id="1d0025e26a750eaf886e5b666d451246677ab333" translate="yes" xml:space="preserve">
          <source>Substitution Type</source>
          <target state="translated">Тип замещения</target>
        </trans-unit>
        <trans-unit id="8ef51098d2d0844a5ec23726b4f7a7d03aa49015" translate="yes" xml:space="preserve">
          <source>Substrings consisting of fewer than 3 unicode characters do not match any rows when used with a full-text query. If a LIKE or GLOB pattern does not contain at least one sequence of non-wildcard unicode characters, FTS5 falls back to a linear scan of the entire table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="b2b6c0ca0db2f38dd797d319d2f786a2af93e034" translate="yes" xml:space="preserve">
          <source>Subtract 200 from X.</source>
          <target state="translated">Вычитайте 200 из Икс.</target>
        </trans-unit>
        <trans-unit id="351c38b73ce6b309921bfd5c87f12ea777d4a4ac" translate="yes" xml:space="preserve">
          <source>Subtract the value in register P1 from the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">Вычтите значение в регистре P1 из значения в регистре P2 и сохраните результат в регистре P3.Если любой из входов имеет значение NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="b3ad01aa557050dded853fc788b3484598298d39" translate="yes" xml:space="preserve">
          <source>Such a line of C code might generate a dozen separate machine code instructions. If any one of those instructions is ever evaluated, then we say that the statement has been tested. So, for example, it might be the case that the conditional expression is always false and the &quot;d&quot; variable is never incremented. Even so, statement coverage counts this line of code as having been tested.</source>
          <target state="translated">Такая строка C-кода может генерировать дюжину отдельных машинных инструкций.Если какая-либо из этих инструкций когда-либо будет оценена,то мы говорим,что утверждение было протестировано.Так,например,может случиться,что условное выражение всегда ложно и переменная &quot;d&quot; никогда не увеличивается.Тем не менее,покрытие оператора считает эту строку кода тестируемой.</target>
        </trans-unit>
        <trans-unit id="a042ce9ca13e4d4ddb750a0fe77ea337b1cdceb1" translate="yes" xml:space="preserve">
          <source>Such a virtual table has the same columns as the table-valued function described in the previous section. It may be read from using a SELECT statement in the same way as the table-valued function can.</source>
          <target state="translated">Такая виртуальная таблица имеет те же столбцы,что и табличная функция,описанная в предыдущем разделе.Она может быть прочитана с помощью оператора SELECT таким же образом,как и табличная функция-значение.</target>
        </trans-unit>
        <trans-unit id="da045363c8fb916c7bdb60bedab8cb85e2f1f5a1" translate="yes" xml:space="preserve">
          <source>Such advanced searches are requested by providing a more complicated FTS5 query string as the text to the right of the MATCH operator (or = operator, or as the first argument to a table-valued function syntax). The full query syntax is &lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">Такой расширенный поиск запрашивается путем предоставления более сложной строки запроса FTS5 в виде текста справа от оператора MATCH (или оператора =, или в качестве первого аргумента синтаксиса функции с табличным значением). Полный синтаксис запроса &lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;описан здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c0936ee6227b30512f2222702e2254d11d72a242" translate="yes" xml:space="preserve">
          <source>Such criticism would be well-founded for a traditional client/server database engine, such as MySQL, PostgreSQL, or SQL Server. In a client/server database, each SQL statement requires a message round-trip from the application to the database server and back to the application. Doing over 200 round-trip messages, sequentially, can be a serious performance drag. This is sometimes called the &quot;N+1 Query Problem&quot; or the &quot;N+1 Select Problem&quot; and it is an anti-pattern.</source>
          <target state="translated">Такая критика была бы вполне обоснованной для традиционного движка базы данных клиент/сервер,такого как MySQL,PostgreSQL или SQL Server.В базе данных клиент/сервер каждый SQL-запрос требует сообщения от приложения к серверу базы данных и обратно в приложение.Выполнение более 200 сообщений в обе стороны,последовательно,может быть серьезным перетаскиванием производительности.Иногда это называется &quot;N+1 Query Problem&quot; или &quot;N+1 Select Problem&quot; и является анти-шаблоном.</target>
        </trans-unit>
        <trans-unit id="f834acdfa0c7dab757f2bc4e26b1966eff963a52" translate="yes" xml:space="preserve">
          <source>Suggested Uses For SQLite:</source>
          <target state="translated">Предлагаемое использование для SQLite:</target>
        </trans-unit>
        <trans-unit id="f08f43d3c61d6c426d33128ee0c38e51fb6aad20" translate="yes" xml:space="preserve">
          <source>Suggested compile-time options include:</source>
          <target state="translated">Предлагаемые опции времени компиляции включают в себя:</target>
        </trans-unit>
        <trans-unit id="3d1a384ea1042be63f3032ea726e70fc4a04f311" translate="yes" xml:space="preserve">
          <source>Suggests completions for partially-entered words during interactive SQL input. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to help implement tab-completion.</source>
          <target state="translated">Предлагает дополнения для частично введенных слов во время интерактивного ввода SQL. Используется &lt;a href=&quot;cli&quot;&gt;CLI,&lt;/a&gt; чтобы помочь реализовать завершение табуляции.</target>
        </trans-unit>
        <trans-unit id="adca4d21f8bf7900f73ede68196274afd881f1d7" translate="yes" xml:space="preserve">
          <source>Sum() will throw an &quot;integer overflow&quot; exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. Total() never throws an integer overflow.</source>
          <target state="translated">Функция Sum()бросит исключение &quot;целочисленное переполнение&quot;,если все входные данные являются целыми числами или NULL и в любой момент вычисления происходит целочисленное переполнение.Total()никогда не выбрасывает &quot;целочисленное переполнение&quot;.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="1a7bd9ebcad37a0dd711dfc793fa96bb5022047c" translate="yes" xml:space="preserve">
          <source>Summary of Technical Differences</source>
          <target state="translated">Резюме технических различий</target>
        </trans-unit>
        <trans-unit id="4c599c4f8f2ffb798c4263cf7f6e473784c4d396" translate="yes" xml:space="preserve">
          <source>Super-journals</source>
          <target state="translated">Super-journals</target>
        </trans-unit>
        <trans-unit id="ab2e3b9850b401306a39a3a804f43e7d4f55c01f" translate="yes" xml:space="preserve">
          <source>Support for &quot;:AAA&quot; style bind parameter names.</source>
          <target state="translated">Поддержка имен параметров привязки в стиле &quot;:AAA&quot;.</target>
        </trans-unit>
        <trans-unit id="8b45bd25a3b604a0eccba69e7087834ecb582853" translate="yes" xml:space="preserve">
          <source>Support for &lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt; following the PostgreSQL syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e333e85b28ab7b57a0a5c9131f54f806015a6221" translate="yes" xml:space="preserve">
          <source>Support for ALTER TABLE ... RENAME TABLE ... added</source>
          <target state="translated">Поддержка ALTER-таблицы ...RENAME-таблица ...добавлена</target>
        </trans-unit>
        <trans-unit id="3251d36ace39f64a5ddca9143a5668b65028289f" translate="yes" xml:space="preserve">
          <source>Support for TCL variable names embedded in SQL statements in the TCL bindings.</source>
          <target state="translated">Поддержка имен переменных TCL,встроенных в SQL-операторы в связках TCL.</target>
        </trans-unit>
        <trans-unit id="4c4e649b2faf6e7dd28f3f288044f754a9767c05" translate="yes" xml:space="preserve">
          <source>Support for UTF-16.</source>
          <target state="translated">Поддержка UTF-16.</target>
        </trans-unit>
        <trans-unit id="49ef276ba874be88caa55a5b3e4a37db519f9394" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and ISO8859 characters in column and table names.</source>
          <target state="translated">Поддержка UTF-8 и ISO8859 символов в названиях столбцов и таблиц.</target>
        </trans-unit>
        <trans-unit id="78dc81c2a8faafa4c84493782b19c441e17956a6" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and UTF-16</source>
          <target state="translated">Поддержка UTF-8 и UTF-16</target>
        </trans-unit>
        <trans-unit id="1e1164bc2160d30de5ee08ec06fc2a323f2028fc" translate="yes" xml:space="preserve">
          <source>Support for both UTF-8 and UTF-16 text.</source>
          <target state="translated">Поддержка как UTF-8,так и UTF-16 текста.</target>
        </trans-unit>
        <trans-unit id="bf37e2ec021b62a6c46ffa2eb125d86eb07ffbc5" translate="yes" xml:space="preserve">
          <source>Support for correlated subqueries added.</source>
          <target state="translated">Добавлена поддержка коррелированных подзапросов.</target>
        </trans-unit>
        <trans-unit id="ec9173b8e288c70be66cdbfa81d0ba7ad6705c9c" translate="yes" xml:space="preserve">
          <source>Support for full text search using the FTS1 module (beta)</source>
          <target state="translated">Поддержка полнотекстового поиска с помощью модуля FTS1 (бета-версия)</target>
        </trans-unit>
        <trans-unit id="09344ff56160150e5ec18eb5a71ba2f29a6312fc" translate="yes" xml:space="preserve">
          <source>Support for internationalization including UTF-8, UTF-16, and user defined collating sequences.</source>
          <target state="translated">Поддержка интернационализации,включая UTF-8,UTF-16 и определяемые пользователем коллекционные последовательности.</target>
        </trans-unit>
        <trans-unit id="091e86f3d19a27b9089ddce8c418dcc49fd9c304" translate="yes" xml:space="preserve">
          <source>Support for non-ASCII characters in win95 filenames</source>
          <target state="translated">Поддержка не-ASCII символов в именах файлов win95</target>
        </trans-unit>
        <trans-unit id="cfddf0106ec96c94ef54d4e7b75188870573ef30" translate="yes" xml:space="preserve">
          <source>Support for the EXISTS clause added.</source>
          <target state="translated">Добавлена поддержка пункта EXISTS.</target>
        </trans-unit>
        <trans-unit id="21d1badc676c125ad5e671e3ae8383a4753e9f6c" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="translated">Поддержка диагностических функций sqlite3_compileoption_used () и sqlite3_compileoption_get () может быть опущена путем указания параметра &lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; во время компиляции.</target>
        </trans-unit>
        <trans-unit id="ceaebbe4250e5e44fc85c0a7be72215c2fc6b3df" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="translated">Поддержка диагностических функций sqlite3_compileoption_used () и sqlite3_compileoption_get () может быть опущена путем указания параметра &lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; во время компиляции.</target>
        </trans-unit>
        <trans-unit id="e227243100baec383101a5e3e5550db71fb48de1" translate="yes" xml:space="preserve">
          <source>Support operators IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE.</source>
          <target state="translated">Операторы поддержки СПОСОБНЫЕ,СПОСОБНЫЕ,НЕ СПОСОБНЫЕ и НЕ СПОСОБНЫЕ.</target>
        </trans-unit>
        <trans-unit id="8b76c3512f29a884a102a942cd3b81fe8d384ace" translate="yes" xml:space="preserve">
          <source>Supported unary prefix operators are these:</source>
          <target state="translated">Поддерживаются одинарные префиксные операторы:</target>
        </trans-unit>
        <trans-unit id="14453b6f0216ab7b03129623da62580288e5db4c" translate="yes" xml:space="preserve">
          <source>Supports terabyte-sized databases and gigabyte-sized strings and blobs. (See &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt;.)</source>
          <target state="translated">Поддерживает базы данных размером в терабайт, а также строки и капли размером в гигабайт. (См. &lt;a href=&quot;limits&quot;&gt;Limits.html&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="f2a1709933364d69e93326e81a6775d317d15202" translate="yes" xml:space="preserve">
          <source>Suppose N=4. Then for the TPC-H Q8 graph, the first step finds the four shortest paths to visit any single node in the graph:</source>
          <target state="translated">Предположим,N=4.Затем для графика TPC-H Q8 на первом шаге найдем четыре кратчайших пути для посещения любого отдельного узла графика:</target>
        </trans-unit>
        <trans-unit id="61fbb5bff735b0969304e1938310f741780fb8bb" translate="yes" xml:space="preserve">
          <source>Suppose SQLite is used as the &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; for a particular design application. Two users, Alice and Bob, each start with a baseline design that is about a gigabyte in size. They work all day, in parallel, each making their own customizations and tweaks to the design. At the end of the day, they would like to merge their changes together into a single unified design.</source>
          <target state="translated">Предположим, что SQLite используется как &lt;a href=&quot;appfileformat&quot;&gt;формат файла приложения&lt;/a&gt; для конкретного проектного приложения. Два пользователя, Алиса и Боб, каждый начинают с базового проекта размером около гигабайта. Они работают весь день, параллельно, каждый вносит свои коррективы в дизайн. В конце концов, они хотели бы объединить свои изменения в единый унифицированный дизайн.</target>
        </trans-unit>
        <trans-unit id="ef94f961eb3bb04314c719aa5da9edd146e885d3" translate="yes" xml:space="preserve">
          <source>Suppose an application wants to display a list of contacts in alphabetical order by lastname, firstname, in a scrolling window that can only show 7 contacts at a time. Initialize the scrolling window to the first 7 entries is easy:</source>
          <target state="translated">Предположим,приложение хочет отображать список контактов в алфавитном порядке по фамилии,имени,в окне прокрутки,которое может показывать только 7 контактов за раз.Инициализировать окно прокрутки до первых 7 записей очень просто:</target>
        </trans-unit>
        <trans-unit id="56904d3ea47369b0068186e8a39203c8a5f870c3" translate="yes" xml:space="preserve">
          <source>Suppose each entry in the BIG table is a JSON object with a '$.id' field that is a unique identifier and a '$.partlist' field that can be a deeply nested object. You want to find the id of every entry that contains one or more references to uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '$.partlist'.</source>
          <target state="translated">Предположим,что каждая запись в таблице BIG-это JSON-объект с полем '$.id',который является уникальным идентификатором,и полем '$.partlist',который может быть глубоко вложенным объектом.Вы хотите найти id каждой записи,которая содержит одну или несколько ссылок на uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' в любом месте его '$.partlist'.</target>
        </trans-unit>
        <trans-unit id="01636cb9299568d887d10674105e44b34b08d5bf" translate="yes" xml:space="preserve">
          <source>Suppose that after a while (about a month, usually) a new version of SQLite is released: 3.6.16. You will want to incorporate this new public version of SQLite into your repository in the public branch (the trunk). To do this, first change your repository over to the trunk:</source>
          <target state="translated">Предположим,что через некоторое время (обычно около месяца)выходит новая версия SQLite:3.6.16.Вы захотите включить эту новую публичную версию SQLite в свой репозиторий в общедоступном ответвлении (стволе).Для этого сначала переместите ваш репозиторий в ствол:</target>
        </trans-unit>
        <trans-unit id="cede4c6f59f784278daddf56ee62d38bbe080c9a" translate="yes" xml:space="preserve">
          <source>Suppose that in addition to the index on &quot;fruit&quot; there was also an index on &quot;state&quot;.</source>
          <target state="translated">Предположим,что помимо индекса на &quot;фрукты&quot; существовал также индекс на &quot;государство&quot;.</target>
        </trans-unit>
        <trans-unit id="66f9ffa5f1e3c7efa56791a73580d03426c293ab" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; file format, and specifically the &quot;ODP&quot; OpenDocument Presentation format, were built around SQLite. Benefits would include:</source>
          <target state="translated">Предположим, что &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;формат&lt;/a&gt; файла OpenDocument и, в частности, формат презентации OpenDocument &amp;laquo;ODP&amp;raquo;, были построены на базе SQLite. Преимущества будут включать:</target>
        </trans-unit>
        <trans-unit id="3afce37c04a00289ab78d43ef00f88c83b7ff381" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;a href=&quot;https://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; file format, and specifically the &quot;ODP&quot; OpenDocument Presentation format, were built around SQLite. Benefits would include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a6796b2c9a16b027d38641aa802a501818a470f" translate="yes" xml:space="preserve">
          <source>Suppose the SQLite source tree is stored in a directory named &quot;sqlite&quot;. Plan to construct the amalgamation in a parallel directory named (for example) &quot;bld&quot;. First construct an appropriate Makefile by either running the configure script at the top of the SQLite source tree, or by making a copy of one of the template Makefiles at the top of the source tree. Then hand edit this Makefile to include the desired compile-time options. Finally run:</source>
          <target state="translated">Допустим,дерево исходников SQLite хранится в директории с именем &quot;sqlite&quot;.Планируем построить слияние в параллельной директории с именем (например)&quot;bld&quot;.Сначала построим соответствующий Makefile либо запустив конфигурационный скрипт в верхней части дерева исходных текстов SQLite,либо сделав копию одного из шаблонов Makefile в верхней части дерева исходных текстов.Затем вручную отредактируйте этот Makefile,чтобы включить в него нужные опции времени компиляции.Наконец,запустите:</target>
        </trans-unit>
        <trans-unit id="0b1da1daf13d7c26fba356306203b171fd80d646" translate="yes" xml:space="preserve">
          <source>Suppose the application normally does a query against table TAB1 when it starts up. If an attacker can gain access to the database file and modify the schema like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af5f7045e9a9cbdbcc9c95551ce4e94ea5602be" translate="yes" xml:space="preserve">
          <source>Suppose the demo_data.boundary field holds some proprietary data description of a complex two-dimensional boundary for an object and suppose that the application has used the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface to created application-defined functions &quot;contained_in&quot; and &quot;overlaps&quot; accepting two demo_data.boundary objects and return true or false. One may assume that &quot;contained_in&quot; and &quot;overlaps&quot; are relatively slow functions that we do not want to invoke too frequently. Then an efficient way to find the name of all objects located within the North Carolina 12th District, one may be to run a query like this:</source>
          <target state="translated">Предположим, что поле demo_data.boundary содержит описание некоторых проприетарных данных сложной двумерной границы для объекта, и предположим, что приложение использовало интерфейс &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; для создания определяемых приложением функций &amp;laquo;contain_in&amp;raquo; и &amp;laquo;перекрытия&amp;raquo;, принимающих два demo_data. граничные объекты и возвращают истину или ложь. Можно предположить, что &amp;laquo;contains_in&amp;raquo; и &amp;laquo;overlaps&amp;raquo; - это относительно медленные функции, которые мы не хотим вызывать слишком часто. Тогда эффективный способ найти названия всех объектов, расположенных в 12-м округе Северной Каролины, может заключаться в выполнении такого запроса:</target>
        </trans-unit>
        <trans-unit id="be9cbf4654b2bfbdcf1b2bf833bfb8cf7cccef29" translate="yes" xml:space="preserve">
          <source>Suppose the initial sequence of non-wildcard characters on the right-hand side of the LIKE or GLOB operator is</source>
          <target state="translated">Предположим,что начальная последовательность не диких символов в правой части оператора LIKE или GLOB-это</target>
        </trans-unit>
        <trans-unit id="15341cf73e257c233d78d57ae1e295622b133b68" translate="yes" xml:space="preserve">
          <source>Suppose the power loss occurred during &lt;a href=&quot;#section_3_10&quot;&gt;step 3.10&lt;/a&gt; above, while the database changes were being written to disk. After power is restored, the situation might be something like what is shown to the right. We were trying to change three pages of the database file but only one page was successfully written. Another page was partially written and a third page was not written at all.</source>
          <target state="translated">Предположим, что отключение питания произошло на &lt;a href=&quot;#section_3_10&quot;&gt;шаге 3.10&lt;/a&gt; выше, когда изменения базы данных записывались на диск. После восстановления питания ситуация может быть примерно такой, как показано справа. Мы пытались изменить три страницы файла базы данных, но была успешно записана только одна страница. Другая страница была написана частично, а третья страница не была написана вообще.</target>
        </trans-unit>
        <trans-unit id="502f7a3363de6f918e427baeeb23c0fbeb554eda" translate="yes" xml:space="preserve">
          <source>Suppose the table &quot;CREATE TABLE user(name,phone)&quot; stores zero or more phone numbers as a JSON array object in the user.phone field. To find all users who have any phone number with a 704 area code:</source>
          <target state="translated">Предположим,что в таблице &quot;CREATE TABLE user(name,phone)&quot; в поле user.phone в качестве объекта JSON-массива записывается ноль или несколько телефонных номеров.Найти всех пользователей,у которых есть любой телефонный номер с кодом 704:</target>
        </trans-unit>
        <trans-unit id="d5297ab1e192fe178acfe6ab94a19f582b117e15" translate="yes" xml:space="preserve">
          <source>Suppose the term that is being spell-corrected is X. To limit the search space, X is converted to a k2-like key using the equivalent of:</source>
          <target state="translated">Предположим,что корректируемый по орфографии термин-X.Чтобы ограничить пространство поиска,X преобразуется в k2-подобный ключ,используя эквивалент:</target>
        </trans-unit>
        <trans-unit id="b244116e469acf86fbb0e19b53f1d8598b689446" translate="yes" xml:space="preserve">
          <source>Suppose there is a site hosting a database in state S0. And that modifications are made that move that database to state S1 and a changeset recorded (the &quot;local&quot; changeset). Then, a changeset based on S0 is received from another site (the &quot;remote&quot; changeset) and applied to the database. The database is then in state (S1+&quot;remote&quot;), where the exact state depends on any conflict resolution decisions (OMIT or REPLACE) made while applying &quot;remote&quot;. Rebasing a changeset is to update it to take those conflict resolution decisions into account, so that the same conflicts do not have to be resolved elsewhere in the network.</source>
          <target state="translated">Предположим,что есть сайт,на котором размещена база данных в состоянии S0.И что вносятся изменения,которые переводят эту базу данных в состояние S1 и записывают измененный набор (&quot;локальный&quot; набор изменений).Затем changeset на основе S0 принимается с другого сайта (&quot;удаленный&quot; changeset)и применяется к базе данных.Затем база данных находится в состоянии (S1+&quot;удалённый&quot;),где точное состояние зависит от любых решений по разрешению конфликтов (OMIT или REPLACE),принятых при применении &quot;удалённого&quot;.Перезагрузка changeset заключается в его обновлении для учета этих решений по разрешению конфликтов,чтобы эти же конфликты не приходилось разрешать в других местах сети.</target>
        </trans-unit>
        <trans-unit id="7ead91310400eb3c0d2b88fd20fde2e0225bdf31" translate="yes" xml:space="preserve">
          <source>Suppose we have a table X1 defined as follows:</source>
          <target state="translated">Предположим,что у нас есть таблица X1,определенная следующим образом:</target>
        </trans-unit>
        <trans-unit id="538e32b0b37a9243b789f735088e6724ac330912" translate="yes" xml:space="preserve">
          <source>Suppose we want to find the prices of all kinds of oranges sorted in order of the state where they are grown. The query is this:</source>
          <target state="translated">Предположим,мы хотим найти цены на все виды апельсинов,отсортированных в порядке возрастания государства,в котором они выращиваются.Запрос такой:</target>
        </trans-unit>
        <trans-unit id="064cebf29367ccdae2597fb8c1cb7630379e90ac" translate="yes" xml:space="preserve">
          <source>Suppose we want to know the order number, product number, and quantity for any item in which the product number and quantity match the product number and quantity of any item in order number 365:</source>
          <target state="translated">Предположим,мы хотим знать номер заказа,номер продукта и количество для любого элемента,в котором номер продукта и количество соответствуют номер продукта и количество любого элемента в порядке номер 365:</target>
        </trans-unit>
        <trans-unit id="8ecaf2920105d29b9c57f7494b3c969303781606" translate="yes" xml:space="preserve">
          <source>Suppose you have an undirected graph where each node is identified by an integer and edges are defined by a table like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465043a8fd6b7a4a4148ce99421e90822984188c" translate="yes" xml:space="preserve">
          <source>Suppose you want to look up the price of peaches. The query would be as follows:</source>
          <target state="translated">Предположим,вы хотите посмотреть цены на персики.Запрос будет следующим:</target>
        </trans-unit>
        <trans-unit id="5cde9a11c3caa7425e0b0c2c0bc60b2a242f9c61" translate="yes" xml:space="preserve">
          <source>Surprisingly, using SQLite in place of ZIP makes the presentation file smaller. Really. One would think that a relational database file would be larger than a ZIP archive, but at least in the case of NeoOffice that is not so. The following is an actual screen-scrape showing the sizes of the same NeoOffice presentation, both in its original ZIP archive format as generated by NeoOffice (self2014.odp), and as repacked as an SQLite database using the &lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; utility:</source>
          <target state="translated">Удивительно, но использование SQLite вместо ZIP уменьшает размер файла презентации. В самом деле. Можно подумать, что файл реляционной базы данных будет больше, чем архив ZIP, но, по крайней мере, в случае NeoOffice это не так. Ниже приведен фактический снимок экрана, показывающий размеры той же презентации NeoOffice, как в исходном формате ZIP-архива, сгенерированном NeoOffice (self2014.odp), так и в перепакованном виде базы данных SQLite с &lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;помощью&lt;/a&gt; утилиты SQLAR :</target>
        </trans-unit>
        <trans-unit id="399595a78d6a05cc21ce3af04c57307d7598c91a" translate="yes" xml:space="preserve">
          <source>Surprisingly, using SQLite in place of ZIP makes the presentation file smaller. Really. One would think that a relational database file would be larger than a ZIP archive, but at least in the case of NeoOffice that is not so. The following is an actual screen-scrape showing the sizes of the same NeoOffice presentation, both in its original ZIP archive format as generated by NeoOffice (self2014.odp), and as repacked as an SQLite database using the &lt;a href=&quot;https://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; utility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055c319b3692b1bab785599b3ba80b0068542bb5" translate="yes" xml:space="preserve">
          <source>Suspend Execution For A Short Time</source>
          <target state="translated">Приостановить исполнение на короткое время.</target>
        </trans-unit>
        <trans-unit id="7bdfc376d6f876239b6de7abf665805218ef476e" translate="yes" xml:space="preserve">
          <source>Swap the program counter with the value in register P1. This has the effect of yielding to a coroutine.</source>
          <target state="translated">Поменяйте счетчик программы на значение в регистре P1.Это приводит к эффекту уступки корутину.</target>
        </trans-unit>
        <trans-unit id="6cb264ae88f7fbec3546350312b9af582b1fc481" translate="yes" xml:space="preserve">
          <source>Swapping journal files between two different databases.</source>
          <target state="translated">Обмен файлами журналов между двумя разными базами данных.</target>
        </trans-unit>
        <trans-unit id="e8485294b019aa85fdb1a929771cba23d5593c45" translate="yes" xml:space="preserve">
          <source>Swarmvtab Virtual Table</source>
          <target state="translated">Виртуальный стол Swarmvtab</target>
        </trans-unit>
        <trans-unit id="01d32f35e7401403e071bd64f5c3b26a4e4dc5be" translate="yes" xml:space="preserve">
          <source>Swarmvtab context</source>
          <target state="translated">контекст Свармвтаба</target>
        </trans-unit>
        <trans-unit id="875cb081d7d2e461450da0199489f1266311e3ff" translate="yes" xml:space="preserve">
          <source>Swarmvtab efficiently handles range and equality constraints on the rowid (or other INTEGER PRIMARY KEY) field only. If a query does not contain such a constraint, then swarmvtab finds the results by opening each database in turn and linearly scanning the component table. Which generates a correct result, but is often slow.</source>
          <target state="translated">Swarmvtab эффективно справляется с ограничениями по дальности и равноправию только в шумовом (или другом)поле INTEGER PRIMARY KEY.Если запрос не содержит такого ограничения,то Swarmvtab находит результаты,открывая по очереди каждую БД и линейно сканируя таблицу компонентов.Что приводит к получению корректного результата,но часто является медленным.</target>
        </trans-unit>
        <trans-unit id="85aa4db2e47035bd4c2140f56e8799ea09c7ae90" translate="yes" xml:space="preserve">
          <source>Swarmvtab virtual tables must be created in the temp schema. Attempting to create a swarmvtab in the main or an attached database is an error.</source>
          <target state="translated">Виртуальные таблицы Swarmvtab должны быть созданы в temp-схеме.Попытка создать swarmvtab в основной или присоединенной базе данных является ошибкой.</target>
        </trans-unit>
        <trans-unit id="d0d92527f493460a8c4ce6ccbbd585c5ead2d11f" translate="yes" xml:space="preserve">
          <source>Synchronization Type Flags</source>
          <target state="translated">Тип синхронизации Флаги</target>
        </trans-unit>
        <trans-unit id="a7e6b31b20f1d4434bcadd521f6861e2f3378f97" translate="yes" xml:space="preserve">
          <source>Synchronous pragma</source>
          <target state="translated">Синхронная прагма</target>
        </trans-unit>
        <trans-unit id="4ae6fa22bc9918cf39eb8d8cef197a88e78982e8" translate="yes" xml:space="preserve">
          <source>Syncing</source>
          <target state="translated">Syncing</target>
        </trans-unit>
        <trans-unit id="c66891a446af4f02e4055198cbfa371561a78fd4" translate="yes" xml:space="preserve">
          <source>Syncing the Journal File</source>
          <target state="translated">Синхронизация файла журнала</target>
        </trans-unit>
        <trans-unit id="009e70db897489dd37e3be6570164d0a836b9c76" translate="yes" xml:space="preserve">
          <source>Syntactically, generated columns are designated using a &quot;GENERATED ALWAYS&quot; &lt;a href=&quot;syntax/column-constraint&quot;&gt;column-constraint&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17aba038fa3266b07efa450a91b91b1e792d66c5" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams</source>
          <target state="translated">Диаграмма синтаксиса</target>
        </trans-unit>
        <trans-unit id="33bbfae733b0f97c3ea72475efb5dfbb61ebe1e1" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams For SQLite</source>
          <target state="translated">Диаграммы синтаксиса для SQLite</target>
        </trans-unit>
        <trans-unit id="70a8fcc6fa01af0d580c320ddb0e42484905e68e" translate="yes" xml:space="preserve">
          <source>Syntax Restrictions On UPDATE, DELETE, and INSERT Statements Within Triggers</source>
          <target state="translated">Синтаксические ограничения на UPDATE,DELETE и INSERT заявления внутри триггеров</target>
        </trans-unit>
        <trans-unit id="34b408d97f8998a54cd64e9461c53dd4d1067b38" translate="yes" xml:space="preserve">
          <source>System Failure Related Assumptions</source>
          <target state="translated">Предположения,связанные с системными сбоями</target>
        </trans-unit>
        <trans-unit id="ba2da263deb1258b36edfe6f11f1b761d86b8d6d" translate="yes" xml:space="preserve">
          <source>Systems designers report success using SQLite as a data store on server applications running in the datacenter, or in other words, using SQLite as the underlying storage engine for an application-specific database server.</source>
          <target state="translated">Проектировщики систем сообщают об успешном использовании SQLite в качестве хранилища данных в серверных приложениях,запущенных в центре обработки данных,или,другими словами,используют SQLite в качестве базового механизма хранения данных для сервера баз данных,предназначенного для конкретных приложений.</target>
        </trans-unit>
        <trans-unit id="7244bff04e9f7001cbde5e129092d3ed31f1946c" translate="yes" xml:space="preserve">
          <source>Systems that run automatic backups in the background might try to make a backup copy of an SQLite database file while it is in the middle of a transaction. The backup copy then might contain some old and some new content, and thus be corrupt.</source>
          <target state="translated">Системы,выполняющие автоматическое резервное копирование в фоновом режиме,могут попытаться сделать резервную копию файла базы данных SQLite,пока он находится в середине транзакции.Тогда резервная копия может содержать некоторое старое и новое содержимое и,таким образом,быть повреждена.</target>
        </trans-unit>
        <trans-unit id="a4394edb00669dc4429b903f672c10ae13c95e90" translate="yes" xml:space="preserve">
          <source>TABLE</source>
          <target state="translated">TABLE</target>
        </trans-unit>
        <trans-unit id="2ba83e39946a4ce4cedf8d25757aa5972284aa54" translate="yes" xml:space="preserve">
          <source>TABLENAME</source>
          <target state="translated">TABLENAME</target>
        </trans-unit>
        <trans-unit id="4ff4bacb6a130128f6603752138b57217ef9b6fa" translate="yes" xml:space="preserve">
          <source>TBD...</source>
          <target state="translated">TBD...</target>
        </trans-unit>
        <trans-unit id="e44916ac43724313d53ca25dbe2f20ee993ff6ec" translate="yes" xml:space="preserve">
          <source>TBD: More information about the header</source>
          <target state="translated">TBD:Дополнительная информация о заголовке</target>
        </trans-unit>
        <trans-unit id="cdd060df603a64a7bee550bbc1c098580b231ab0" translate="yes" xml:space="preserve">
          <source>TCL interface authorizer method</source>
          <target state="translated">метод авторизации TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="aa517168bae4e2e388a6074b5a96fe2e5afc293f" translate="yes" xml:space="preserve">
          <source>TCL interface backup method</source>
          <target state="translated">метод резервного копирования интерфейса TCL</target>
        </trans-unit>
        <trans-unit id="a29047291bb3d39d19d4b03699cb7f433f5736f2" translate="yes" xml:space="preserve">
          <source>TCL interface bind_fallback method</source>
          <target state="translated">TCL-интерфейс методом bind_fallback</target>
        </trans-unit>
        <trans-unit id="1c5ad56544d8041c9b02f88d11a25782f14e4c9f" translate="yes" xml:space="preserve">
          <source>TCL interface busy method</source>
          <target state="translated">метод занятости TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="6e4d989bf3b3b512cc61d500b0cb58cfc259ca59" translate="yes" xml:space="preserve">
          <source>TCL interface cache method</source>
          <target state="translated">метод кэширования TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="f25b192d00bf0645e7eae602ec160016f797e6ac" translate="yes" xml:space="preserve">
          <source>TCL interface changes method</source>
          <target state="translated">Метод изменения TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="33f884ed1b8425d04cb3811d2ea16b66af480340" translate="yes" xml:space="preserve">
          <source>TCL interface close method</source>
          <target state="translated">метод закрытия TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="96c5f46c7769b7e1d49b804ecba806907889a771" translate="yes" xml:space="preserve">
          <source>TCL interface collate method</source>
          <target state="translated">метод сопоставления интерфейсов TCL</target>
        </trans-unit>
        <trans-unit id="2332befec61c50669cde60f3b1533591736f6a66" translate="yes" xml:space="preserve">
          <source>TCL interface collation_needed method</source>
          <target state="translated">TCL-интерфейс collation_needed метод</target>
        </trans-unit>
        <trans-unit id="8cd4b4c1ed1732eb767f776cef0372d6c6cd1054" translate="yes" xml:space="preserve">
          <source>TCL interface commit_hook method</source>
          <target state="translated">метод коммит_крюка TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="0157c2d923f1a0bec3d0245febd3f5035181a5aa" translate="yes" xml:space="preserve">
          <source>TCL interface complete method</source>
          <target state="translated">полный метод TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="c09e584a42654f26d29ff74df19ed9ca909905e4" translate="yes" xml:space="preserve">
          <source>TCL interface config method</source>
          <target state="translated">метод настройки TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="b70df1b7dc237a292692ace288ac2eb93a3bcef2" translate="yes" xml:space="preserve">
          <source>TCL interface copy method</source>
          <target state="translated">метод копирования TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="347f513a80d88ab334df317b8f83092d3ee26571" translate="yes" xml:space="preserve">
          <source>TCL interface deserialize method</source>
          <target state="translated">метод десериализации TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="0aa7225f1cfbaa7982110594b19739c6dbdfb9ac" translate="yes" xml:space="preserve">
          <source>TCL interface enable_load_extension method</source>
          <target state="translated">TCL-интерфейс enable_load_extension method</target>
        </trans-unit>
        <trans-unit id="64987beca677d7a4b95b820f3bed800e413b8cde" translate="yes" xml:space="preserve">
          <source>TCL interface errorcode method</source>
          <target state="translated">метод кодирования ошибок TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="2189980d19fa911ed2ea4bb8d946cfdc55a53bc7" translate="yes" xml:space="preserve">
          <source>TCL interface eval method</source>
          <target state="translated">метод оценки TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="f1bf6449a26eb7b025248f0b61a91066e3c39b49" translate="yes" xml:space="preserve">
          <source>TCL interface exists method</source>
          <target state="translated">TCL-интерфейс существует метод</target>
        </trans-unit>
        <trans-unit id="648b3c74c3afc3cad32dadd0965691c51538573c" translate="yes" xml:space="preserve">
          <source>TCL interface function method</source>
          <target state="translated">метод функции TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="4d842678586502cd1c46097c8ca3621079c38b98" translate="yes" xml:space="preserve">
          <source>TCL interface incrblob method</source>
          <target state="translated">метод инкрблобального интерфейса TCL</target>
        </trans-unit>
        <trans-unit id="066821d02e0db49a10a7937ff6d8bc5c5b5055c7" translate="yes" xml:space="preserve">
          <source>TCL interface interrupt method</source>
          <target state="translated">метод прерывания интерфейса TCL</target>
        </trans-unit>
        <trans-unit id="f2e3158832088a3ccb54fc358c6461aace750451" translate="yes" xml:space="preserve">
          <source>TCL interface last_insert_rowid method</source>
          <target state="translated">TCL-интерфейс last_insert_rowid метод</target>
        </trans-unit>
        <trans-unit id="50f8a5afc729daeaa27f3e057a6884d99bd7f622" translate="yes" xml:space="preserve">
          <source>TCL interface nullvalue method</source>
          <target state="translated">метод нулевого значения TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="e0711044ae2edb8698df1518d744c5b6309e1ba0" translate="yes" xml:space="preserve">
          <source>TCL interface onecolumn method</source>
          <target state="translated">метод onecolumn TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="7eb062b4a3cda7b5c21d07e42888d6f537605587" translate="yes" xml:space="preserve">
          <source>TCL interface profile method</source>
          <target state="translated">метод профиля интерфейса TCL</target>
        </trans-unit>
        <trans-unit id="4bd65df2fc14e08847cf659f886e3675b02fd603" translate="yes" xml:space="preserve">
          <source>TCL interface progress method</source>
          <target state="translated">метод прогресса интерфейса TCL</target>
        </trans-unit>
        <trans-unit id="24560fa957755f945fd0a996100a7a50130fe691" translate="yes" xml:space="preserve">
          <source>TCL interface restore method</source>
          <target state="translated">метод восстановления TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="2c81f806023d5b1efa791fd568b8a71993cb3fc8" translate="yes" xml:space="preserve">
          <source>TCL interface rollback_hook method</source>
          <target state="translated">метод отката TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="5d16200e0392f874424c9d693d564e213809df7d" translate="yes" xml:space="preserve">
          <source>TCL interface serialize method</source>
          <target state="translated">метод сериализации TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="8ad2308cc6d8c87dd4d39e3a54c207bf26684239" translate="yes" xml:space="preserve">
          <source>TCL interface status method</source>
          <target state="translated">способ состояния TCL-интерфейса</target>
        </trans-unit>
        <trans-unit id="149cac088a8935337f35ceed17575a182fb384dd" translate="yes" xml:space="preserve">
          <source>TCL variable substitution</source>
          <target state="translated">замена переменной TCL</target>
        </trans-unit>
        <trans-unit id="def1cac8277b55b62d6889e51352a77e3186587b" translate="yes" xml:space="preserve">
          <source>TEMP</source>
          <target state="translated">TEMP</target>
        </trans-unit>
        <trans-unit id="c02f25e228aca3bb6f42e48160b40dd55194b2cc" translate="yes" xml:space="preserve">
          <source>TEMP Triggers on Non-TEMP Tables</source>
          <target state="translated">Триггеры TEMP на таблицах без TEMP</target>
        </trans-unit>
        <trans-unit id="8d43ca29f9403615d1a5c8f0da40adcdae819802" translate="yes" xml:space="preserve">
          <source>TEMP databases</source>
          <target state="translated">базы данных TEMP</target>
        </trans-unit>
        <trans-unit id="0c21d62a74809c85ca0475d94b6c298ee066de4e" translate="yes" xml:space="preserve">
          <source>TEMP tables and indices</source>
          <target state="translated">таблицы и индексы TEMP</target>
        </trans-unit>
        <trans-unit id="df7db63622b3659c5ca6d357417169e72078f0bc" translate="yes" xml:space="preserve">
          <source>TEMP triggers on non-TEMP tables</source>
          <target state="translated">Триггеры TEMP на не-TEMP таблицах</target>
        </trans-unit>
        <trans-unit id="2ec4186ff6dd054f66dc48342664cc916e7cee64" translate="yes" xml:space="preserve">
          <source>TEMPORARY</source>
          <target state="translated">TEMPORARY</target>
        </trans-unit>
        <trans-unit id="7d4e42ef9d04a046b5679f952cb0b6b5c498c73c" translate="yes" xml:space="preserve">
          <source>TEXT</source>
          <target state="translated">TEXT</target>
        </trans-unit>
        <trans-unit id="6e2d2a0b927ccbcb0059d0c7ba90d9609187d08f" translate="yes" xml:space="preserve">
          <source>TH3</source>
          <target state="translated">TH3</target>
        </trans-unit>
        <trans-unit id="f0b11e9a80109508da2e3cbd3b7a0a8827845799" translate="yes" xml:space="preserve">
          <source>TH3 achieves 100% branch test coverage (and 100% &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC/DC&lt;/a&gt;) over the SQLite core. (Test coverage of extensions such as FTS and RTREE is less than 100%).</source>
          <target state="translated">TH3 обеспечивает 100% тестовое покрытие ветвей (и 100% &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC / DC&lt;/a&gt; ) по ядру SQLite. (Тестовое покрытие таких расширений, как FTS и RTREE составляет менее 100%).</target>
        </trans-unit>
        <trans-unit id="b39ec8bc0fe82988bb1da1f05fc2de8eb41887fa" translate="yes" xml:space="preserve">
          <source>TH3 checks SQLite's response to out-of-memory errors, disk I/O errors, and power loss during transaction commit.</source>
          <target state="translated">TH3 проверяет реакцию SQLite на ошибки вне памяти,ошибки дискового ввода/вывода и потерю питания во время совершения транзакции.</target>
        </trans-unit>
        <trans-unit id="055f71da54f782f8f65239fd4fb6b9c021760b69" translate="yes" xml:space="preserve">
          <source>TH3 comes with additional TCL scripts that help automate the testing process on workstations. The &quot;th3make&quot; script automatically runs &quot;mkth3.tcl&quot; and &quot;gcc&quot; and then runs the resulting test program and checks the results. Arguments to th3make include all of the &quot;*.test&quot; test modules and &quot;*.cfg&quot; configurations that are to be included in the test. Additional options to th3make can cause the test program to be compiled using different compilers (GCC, Clang, MSVC), to use different output verbosity levels, to run the test program under valgrind, to check the output for coverage using gcov, and so forth. The th3make script also accepts &quot;*.rc&quot; filenames as arguments. These *.rc files are just collections of other arguments that are commonly used together for a single purpose. For example, the &quot;quick.rc&quot; file contains a set of eight arguments to th3make that run a fast (3-minute) full-coverage test. This allows the operator to type &quot;./th3make quick.rc&quot; as a short-cut to typing out all of the required command-line options. The following are a few of the more than 40 available *.rc files:</source>
          <target state="translated">TH3 поставляется с дополнительными TCL-скриптами,которые помогают автоматизировать процесс тестирования на рабочих станциях.Скрипт &quot;th3make&quot; автоматически запускает &quot;mkth3.tcl&quot; и &quot;gcc&quot;,а затем запускает результирующую тестовую программу и проверяет результаты.Аргументами к th3make являются все тестовые модули &quot;*.test&quot; и конфигурации &quot;*.cfg&quot;,которые должны быть включены в тест.Дополнительные опции для th3make могут привести к тому,что тестовая программа будет скомпилирована разными компиляторами (GCC,Clang,MSVC),использовать разные уровни глаголов на выходе,запускать тестовую программу под valgrind,проверять вывод на покрытие с помощью gcov и так далее.Скрипт th3make также принимает в качестве аргументов имена файлов &quot;*.rc&quot;.Эти *.rc файлы являются просто набором других аргументов,которые обычно используются вместе для одной цели.Например,файл &quot;quick.rc&quot; содержит набор из восьми аргументов th3make,которые запускают быстрый (3-минутный)тест на полное покрытие.Это позволяет оператору набрать &quot;./th3make quick.rc&quot; в качестве краткого набора всех необходимых опций командной строки.Ниже приведены несколько из более чем 40 доступных *.rc файлов:</target>
        </trans-unit>
        <trans-unit id="a2a05ad4acef3c330bf37c9357e657e9ed2af845" translate="yes" xml:space="preserve">
          <source>TH3 exercises SQLite in a variety of run-time configurations (UTF8 vs UTF16, different pages sizes, varying journal modes, etc.)</source>
          <target state="translated">TH3 упражняет SQLite в различных конфигурациях исполнения (UTF8 против UTF16,разные размеры страниц,разные журнальные режимы и т.д.).</target>
        </trans-unit>
        <trans-unit id="f8e21da8c02749a044b3aef819f8092fd00ef786" translate="yes" xml:space="preserve">
          <source>TH3 is a test program generator. The output of TH3 is a program implemented in C-code and intended to be linked against the SQLite library under test. The generated test program is compiled and run on the target platform in order to verify correct operation of SQLite on that platform.</source>
          <target state="translated">TH3-это генератор тестовой программы.Выход TH3-это программа,реализованная в C-коде и предназначенная для компоновки с тестируемой библиотекой SQLite.Генерируемая тестовая программа компилируется и запускается на целевой платформе для проверки корректной работы SQLite на этой платформе.</target>
        </trans-unit>
        <trans-unit id="35be3734cb33090a9156032bab76a3246a8875be" translate="yes" xml:space="preserve">
          <source>TH3 is able to run on embedded platforms that lack the support infrastructure of workstations.</source>
          <target state="translated">TH3 способен работать на встраиваемых платформах,не имеющих инфраструктуры поддержки рабочих станций.</target>
        </trans-unit>
        <trans-unit id="924274e45e00b2de29022bcd422e62f257c51552" translate="yes" xml:space="preserve">
          <source>TH3 originated from an effort to test SQLite on &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;. Prior to TH3, all SQLite tests were run using the &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; script language, but TCL would not (easily) compile on SymbianOS which made testing difficult. The first attempt to remedy this problem was the &quot;TH1&quot; (Test Harness #1) scripting language - a reimplementation of parts of the TCL language in a more portable form that would compile and run on SymbianOS, and that was sufficient to run the SQLite tests. TH1 did not survive as a standard testing tool for SQLite, but it did find continued service as a scripting language used to customize the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system. There was also a &quot;Test Harness #2&quot; which was an attempt to create a simple scripting language using operator prefix notation to drive tests. TH3 was the third attempt.</source>
          <target state="translated">TH3 возник в результате попытки протестировать SQLite на &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt; . До TH3 все тесты SQLite запускались с использованием языка сценариев &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; , но TCL не мог (легко) компилироваться на SymbianOS, что затрудняло тестирование. Первой попыткой исправить эту проблему был язык сценариев &quot;TH1&quot; (Test Harness # 1) - повторная реализация частей языка TCL в более переносимой форме, которая могла бы компилироваться и запускаться на SymbianOS, и этого было достаточно для запуска SQLite. тесты. TH1 не выжил в качестве стандартного инструмента тестирования для SQLite, но продолжал работать как язык сценариев, используемый для настройки &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil.&lt;/a&gt;система контроля версий. Также была &amp;laquo;Test Harness # 2&amp;raquo;, которая была попыткой создать простой язык сценариев, использующий нотацию префиксов операторов для проведения тестов. TH3 была третьей попыткой.</target>
        </trans-unit>
        <trans-unit id="4c264425d6a132c02585028ee4d147fc5a2051e5" translate="yes" xml:space="preserve">
          <source>TH3 originated from an effort to test SQLite on &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;. Prior to TH3, all SQLite tests were run using the &lt;a href=&quot;https://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; script language, but TCL would not (easily) compile on SymbianOS which made testing difficult. The first attempt to remedy this problem was the &quot;TH1&quot; (Test Harness #1) scripting language - a reimplementation of parts of the TCL language in a more portable form that would compile and run on SymbianOS, and that was sufficient to run the SQLite tests. TH1 did not survive as a standard testing tool for SQLite, but it did find continued service as a scripting language used to customize the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system. There was also a &quot;Test Harness #2&quot; which was an attempt to create a simple scripting language using operator prefix notation to drive tests. TH3 was the third attempt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2607d86f3f95561abb29b75d3920751195896dbd" translate="yes" xml:space="preserve">
          <source>TH3 tests SQLite in an as-deployed configuration using only published and documented interfaces. In other words, TH3 tests the compiled object code, not the source code, thus verifying that no problems were introduced by compiler bugs. &quot;Test what you fly and fly what you test.&quot;</source>
          <target state="translated">TH3 тестирует SQLite в развернутой конфигурации,используя только опубликованные и документированные интерфейсы.Другими словами,TH3 проверяет не исходный код,а скомпилированный объектный код,проверяя,что ошибки компилятора не привели к возникновению проблем.&quot;Тестировать то,что ты летаешь и летать то,что ты тестируешь&quot;.</target>
        </trans-unit>
        <trans-unit id="c87cfbcfb0ff68ef8b8fa0759657744ff88b88af" translate="yes" xml:space="preserve">
          <source>TH3 was originally written for validation testing only, but has subsequently been used for development testing and debugging as well, and has proven very helpful in those roles. A full-coverage test takes less than five minutes on a workstation and hence serves as a fast regression test during day-to-day maintenance of the SQLite code base.</source>
          <target state="translated">Изначально TH3 был написан только для валидационного тестирования,но впоследствии также использовался для тестирования разработки и отладки,и оказался очень полезным в этих ролях.Тест на полное покрытие занимает менее пяти минут на рабочей станции и,следовательно,служит в качестве быстрого регрессионного теста при ежедневном обслуживании кодовой базы SQLite.</target>
        </trans-unit>
        <trans-unit id="bd7f8a83e07337beedb291a476a0abdb89ed6b4f" translate="yes" xml:space="preserve">
          <source>THEN</source>
          <target state="translated">THEN</target>
        </trans-unit>
        <trans-unit id="2c1d90a10bc6577f471f3c2c8cd6836385b31b82" translate="yes" xml:space="preserve">
          <source>TIES</source>
          <target state="translated">TIES</target>
        </trans-unit>
        <trans-unit id="4fe5a3682f8029783789ec9b3abba10f67f03ffa" translate="yes" xml:space="preserve">
          <source>TINYINT</source>
          <target state="translated">TINYINT</target>
        </trans-unit>
        <trans-unit id="15f51444be75bc88e935c57ef2ee7477dc73a64e" translate="yes" xml:space="preserve">
          <source>TO</source>
          <target state="translated">TO</target>
        </trans-unit>
        <trans-unit id="cd4fd03fe967437fff9a9133b579cdd5421577a6" translate="yes" xml:space="preserve">
          <source>TODO:  Add something about checking the page-cache first etc.</source>
          <target state="translated">TODO:Добавьте что-нибудь о проверке сначала кэша страниц и т.д.</target>
        </trans-unit>
        <trans-unit id="7fb66aab7e490b4f8a5b13b306c51e116175236a" translate="yes" xml:space="preserve">
          <source>TODO:  After sections 4 and 5 are finished, come back here and see if we can add a list of state items associated with each database connection to make things easier to understand. i.e each database connection has a file handle, a set of entries in the page cache, an expected page size etc.</source>
          <target state="translated">TODO:После завершения разделов 4 и 5 вернитесь сюда и посмотрите,сможем ли мы добавить список элементов состояния,связанных с каждым подключением к базе данных,чтобы сделать вещи более понятными.Т.е.каждое подключение к базе данных имеет файловую оболочку,набор записей в кэше страниц,ожидаемый размер страницы и т.д.</target>
        </trans-unit>
        <trans-unit id="4dc847eb4b63db6446f6040c4f09bb7ba16604ab" translate="yes" xml:space="preserve">
          <source>TODO:  After this document is ready, make the vocabulary consistent and then add a glossary here.</source>
          <target state="translated">TODO:После того,как документ будет готов,сделайте словарь согласованным,а затем добавьте сюда глоссарий.</target>
        </trans-unit>
        <trans-unit id="f4e2201a943d83ad82ae3edd3d70f87d9d34b73f" translate="yes" xml:space="preserve">
          <source>TODO:  Describe the parameters set to configure the page cache limits.</source>
          <target state="translated">TODO:Опишите параметры,установленные для настройки ограничений кэша страниц.</target>
        </trans-unit>
        <trans-unit id="30bb6265750b23e36fff26fba218f095577396da" translate="yes" xml:space="preserve">
          <source>TODO:  Expand on and explain the above a bit.</source>
          <target state="translated">ТОДО:Расширьте и объясните немного вышеизложенное.</target>
        </trans-unit>
        <trans-unit id="55f19663a5c44b6305b426b72aadfc9a70eb894d" translate="yes" xml:space="preserve">
          <source>TODO:  Introduce the following sub-sections.</source>
          <target state="translated">TODO:Представьте следующие подразделы.</target>
        </trans-unit>
        <trans-unit id="593039ec1c1939952bb9949b2bcbe1140a495e60" translate="yes" xml:space="preserve">
          <source>TODO:  Is the shared lock held after committing a</source>
          <target state="translated">Общий замок удерживается после фиксации</target>
        </trans-unit>
        <trans-unit id="c4a151926d0634538ee91af79c910ea2132025f5" translate="yes" xml:space="preserve">
          <source>TODO:  Master journal file pointers?</source>
          <target state="translated">Главные указатели на файлы журнала?</target>
        </trans-unit>
        <trans-unit id="2c459077da83b75d52b821b2b77b9e73be290e1e" translate="yes" xml:space="preserve">
          <source>TODO:  Requirements describing the way in which the configuration parameters are used. About LRU etc.</source>
          <target state="translated">ТОДО:Требования,описывающие способ использования параметров конфигурации.О LRU и т.д.</target>
        </trans-unit>
        <trans-unit id="f7e945f52e85f69c533b2d7abf6ea281ed104013" translate="yes" xml:space="preserve">
          <source>TODO:  System requirement references for the above points.</source>
          <target state="translated">TODO:Ссылки на системные требования для вышеперечисленных пунктов.</target>
        </trans-unit>
        <trans-unit id="840394002935b6f4d9da99212e26895929cd86d7" translate="yes" xml:space="preserve">
          <source>TODO:  What happens if the exclusive lock cannot be obtained? It is not possible for the attempt to upgrade from a reserved to a pending lock to fail.</source>
          <target state="translated">Что произойдет,если эксклюзивный замок не удастся получить? Попытка перехода с зарезервированного на ожидающий блокировки блокировки невозможна.</target>
        </trans-unit>
        <trans-unit id="6714ad8471919f57bc47d379c3524d08542a02be" translate="yes" xml:space="preserve">
          <source>TODO:  Why a 16 byte block? Why not 4? (something to do with encrypted databases).</source>
          <target state="translated">Почему 16-байтовый блок? Почему не 4? (что-то связанное с зашифрованными базами данных).</target>
        </trans-unit>
        <trans-unit id="2e614c97a332a0295344a53ea5da2a36633b1954" translate="yes" xml:space="preserve">
          <source>TPC-H Q8 is an eight-way join. As observed above, the main task of the query planner is to figure out the best nesting order of the eight loops in order to minimize the work needed to complete the join. A simplified model of this problem for the case of TPC-H Q8 is shown by the following diagram:</source>
          <target state="translated">TPC-H Q8-это восьмистороннее соединение.Как было отмечено выше,основная задача планировщика запросов-вычислить наилучший порядок вложенности восьми циклов,чтобы свести к минимуму работу,необходимую для завершения соединения.Упрощенная модель этой задачи для случая TPC-H Q8 показана на следующей диаграмме:</target>
        </trans-unit>
        <trans-unit id="bac722ed74faff65da62171d3c4183479a271d1f" translate="yes" xml:space="preserve">
          <source>TRANSACTION</source>
          <target state="translated">TRANSACTION</target>
        </trans-unit>
        <trans-unit id="c162c076dc07a546449be9e07aa7a5c312ecbfe1" translate="yes" xml:space="preserve">
          <source>TRIGGER</source>
          <target state="translated">TRIGGER</target>
        </trans-unit>
        <trans-unit id="74303786eb95ccd75228db361d37b804576e18e6" translate="yes" xml:space="preserve">
          <source>TRUNCATE</source>
          <target state="translated">TRUNCATE</target>
        </trans-unit>
        <trans-unit id="dc45fdb7de43a003177f8df9ee10d01f58f57a58" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell (header 0x05):</source>
          <target state="translated">Внутренняя ячейка стола Б-дерева (заголовок 0x05):</target>
        </trans-unit>
        <trans-unit id="984abe18431413aca60298750d5de10b6d8716c4" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell:</source>
          <target state="translated">Ячейка интерьера стола Б-дерева:</target>
        </trans-unit>
        <trans-unit id="94d19a21f457eb5da8f03166c4dbc3a6ef641531" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell (header 0x0d):</source>
          <target state="translated">Листовая ячейка стола Б-дерево (заголовок 0x0d):</target>
        </trans-unit>
        <trans-unit id="31beedcdbc76a09dd63a101eacf4e15dc87e80c5" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell:</source>
          <target state="translated">Листовая ячейка стола Б-дерево:</target>
        </trans-unit>
        <trans-unit id="cdad59a82a2e26e2fc2225d0629f7733aef385c4" translate="yes" xml:space="preserve">
          <source>Table Column Names</source>
          <target state="translated">Наименования столбцов таблицы</target>
        </trans-unit>
        <trans-unit id="1225362d8c3c05de317acf9684ffe2e1a7649c08" translate="yes" xml:space="preserve">
          <source>Table Interior (0x05)</source>
          <target state="translated">Интерьер стола (0x05)</target>
        </trans-unit>
        <trans-unit id="de156b09866349ad52b0a535e8144a86d129a154" translate="yes" xml:space="preserve">
          <source>Table Leaf (0x0d)</source>
          <target state="translated">Лист таблицы (0x0d)</target>
        </trans-unit>
        <trans-unit id="c27c7c360e130231f97ba874c98e3448dd648d35" translate="yes" xml:space="preserve">
          <source>Table Name</source>
          <target state="translated">Название таблицы</target>
        </trans-unit>
        <trans-unit id="6a975d3ec2f404cfb761b1314fc6745ca72f942e" translate="yes" xml:space="preserve">
          <source>Table b-tree</source>
          <target state="translated">Таблица б-дерево</target>
        </trans-unit>
        <trans-unit id="92db13efcb630c92ecf1220fd763e9d0e237c97e" translate="yes" xml:space="preserve">
          <source>Table name</source>
          <target state="translated">Название таблицы</target>
        </trans-unit>
        <trans-unit id="8fce71f88d0ac569b970cf1bcd57a56acf400366" translate="yes" xml:space="preserve">
          <source>Table name quoting works correctly for the &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; dot-command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3467c6281e0ea2be2b55952d6893e3fbba049d" translate="yes" xml:space="preserve">
          <source>Table or index entries that are out of sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70aee3388a925e7cbb0852fe8dcdd4c402a95fd1" translate="yes" xml:space="preserve">
          <source>Table zTable does not exist within database zDb,</source>
          <target state="translated">Таблица zTable не существует в БД zDb,</target>
        </trans-unit>
        <trans-unit id="8886ec4df0da407409b6e2c6457e09d78592c0c0" translate="yes" xml:space="preserve">
          <source>Table zTable is a WITHOUT ROWID table,</source>
          <target state="translated">Таблица zTable-это таблица БЕЗ РОУДА,</target>
        </trans-unit>
        <trans-unit id="053f4c073c904977c9ac1e40ab060f8397a0907f" translate="yes" xml:space="preserve">
          <source>Table-name must already exists as a table. File-name must exist, and each row must contain the same number of columns as defined in the table. If a line in the file contains more or less than the number of columns defined, the copy method rollbacks any inserts, and returns an error.</source>
          <target state="translated">Название таблицы должно уже существовать в виде таблицы.Имя файла должно существовать,и каждая строка должна содержать такое же количество столбцов,как определено в таблице.Если строка в файле содержит больше или меньше определенного количества столбцов,метод копирования откатывает любые вставки и возвращает ошибку.</target>
        </trans-unit>
        <trans-unit id="aea731c8e5cbf2292cf08d50a7760fa0d709eb35" translate="yes" xml:space="preserve">
          <source>Table-valued Functions In The FROM Clause</source>
          <target state="translated">Функции с табличной стоимостью в пункте ОТКЛЮЧЕНИЯ</target>
        </trans-unit>
        <trans-unit id="fc3ba8bea68a8b6f73ff90024cfd6082eaf4a791" translate="yes" xml:space="preserve">
          <source>Table-valued functions</source>
          <target state="translated">Функции табличной оценки</target>
        </trans-unit>
        <trans-unit id="b503117e6dd30a0beff0cc1ab7fb7d005000dd03" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for PRAGMAs that return results and that have no side-effects.</source>
          <target state="translated">Функции табличной оценки существуют только для PRAGMA,которые возвращают результаты и не имеют побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="f155ed85208e2d25c37ff0660af9e88e0ce41331" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for built-in PRAGMAs, not for PRAGMAs defined using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control.</source>
          <target state="translated">Возвращающие табличное значение функции существуют только для встроенных PRAGMA, но не для PRAGMA, определенных с помощью &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;файлового элемента&lt;/a&gt; управления SQLITE_FCNTL_PRAGMA .</target>
        </trans-unit>
        <trans-unit id="81ea5c3f4a86eb9511e7fd13ab5c2a7a105f6e9f" translate="yes" xml:space="preserve">
          <source>TableLock</source>
          <target state="translated">TableLock</target>
        </trans-unit>
        <trans-unit id="c52e87aa9f54904a290a1ea1125feb8f0b12b884" translate="yes" xml:space="preserve">
          <source>Tables are removed using the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement.</source>
          <target state="translated">Таблицы удаляются с помощью оператора &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bee9f4ba2588a4abe8a5e77c961e698fb909d93" translate="yes" xml:space="preserve">
          <source>Tables created using CREATE TABLE AS are initially populated with the rows of data returned by the SELECT statement. Rows are assigned contiguously ascending &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; values, starting with 1, in the &lt;a href=&quot;lang_select#orderby&quot;&gt;order&lt;/a&gt; that they are returned by the SELECT statement.</source>
          <target state="translated">Таблицы, созданные с помощью CREATE TABLE AS, изначально заполняются строками данных, возвращаемыми оператором SELECT. Строкам присваиваются непрерывно возрастающие значения &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; , начиная с 1, в том &lt;a href=&quot;lang_select#orderby&quot;&gt;порядке, в&lt;/a&gt; котором они возвращаются оператором SELECT.</target>
        </trans-unit>
        <trans-unit id="0b08405f06556bfc4a2cd40880fee5d5df353fe5" translate="yes" xml:space="preserve">
          <source>Tables created using the &quot;CREATE TEMP TABLE&quot; syntax are only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in which the &quot;CREATE TEMP TABLE&quot; statement is originally evaluated. These TEMP tables, together with any associated indices, triggers, and views, are collectively stored in a separate temporary database file that is created as soon as the first &quot;CREATE TEMP TABLE&quot; statement is seen. This separate temporary database file also has an associated rollback journal. The temporary database file used to store TEMP tables is deleted automatically when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">Таблицы, созданные с использованием синтаксиса &amp;laquo;CREATE TEMP TABLE&amp;raquo;, видны только тому &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению&lt;/a&gt; с базой данных, в котором первоначально вычисляется оператор &amp;laquo;CREATE TEMP TABLE&amp;raquo;. Эти таблицы TEMP вместе со всеми связанными индексами, триггерами и представлениями совместно хранятся в отдельном временном файле базы данных, который создается, как только появляется первый оператор &amp;laquo;CREATE TEMP TABLE&amp;raquo;. С этим отдельным временным файлом базы данных также связан журнал отката. Временный файл базы данных, используемый для хранения таблиц TEMP, автоматически удаляется при закрытии &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных с помощью &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="398c675fc2fa417398cf9f153388d4a182136954" translate="yes" xml:space="preserve">
          <source>Tables in an attached database can be referred to using the syntax</source>
          <target state="translated">К таблицам в подключенной БД можно обратиться с помощью синтаксиса</target>
        </trans-unit>
        <trans-unit id="230baa2e574ece0e6ffe7c574dcbbb9cd18fff76" translate="yes" xml:space="preserve">
          <source>Tables with names of the form &quot;sqlite_statN&quot; where N is an integer. Such tables store database statistics gathered by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used by the query planner to help determine the best algorithm to use for each query.</source>
          <target state="translated">Таблицы с именами в форме &quot;sqlite_statN&quot;, где N - целое число. В таких таблицах хранится статистика базы данных, собранная командой &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; и используемая планировщиком запросов, чтобы помочь определить лучший алгоритм для каждого запроса.</target>
        </trans-unit>
        <trans-unit id="6dbeddaf590f294decd7c12cd9b3ac14168d3997" translate="yes" xml:space="preserve">
          <source>Take advantage of the atomic-write capabilities in the &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS filesystem&lt;/a&gt; when available, for greatly reduced transaction overhead. This currently requires the &lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/a&gt; compile-time option.</source>
          <target state="translated">Воспользуйтесь возможностями атомарной записи в &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;файловой системе F2FS,&lt;/a&gt; когда они доступны, для значительного сокращения накладных расходов на транзакции. В настоящее время для этого требуется параметр &lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_BATCH_ATOMIC_WRITE .</target>
        </trans-unit>
        <trans-unit id="acf997da6bf4365bf440bc3ad9c07d7d7925e743" translate="yes" xml:space="preserve">
          <source>Take into account the fact WHERE clause terms that cannot be used with indices still probably reduce the number of output rows.</source>
          <target state="translated">Учитывать тот факт,что условия пункта WHERE,которые не могут быть использованы с индексами,все же,вероятно,уменьшают количество выходных строк.</target>
        </trans-unit>
        <trans-unit id="c2975a6466c6b11f1519a6c8652f37b3cef0c265" translate="yes" xml:space="preserve">
          <source>Take the bit-wise AND of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">Возьмите бит И значений в регистре P1 и P2 и сохраните результат в регистре P3.Если любой из входов имеет значение NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="23882df60c1b18a8b147b1926280887dfe7acb8a" translate="yes" xml:space="preserve">
          <source>Take the bit-wise OR of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">Возьмите битовое ИЛИ значений в регистре P1 и P2 и сохраните результат в регистре P3.Если любой из входов имеет значение NULL,то результат будет NULL.</target>
        </trans-unit>
        <trans-unit id="6a0b05dea29609663a6574c364045bd831c5b261" translate="yes" xml:space="preserve">
          <source>Take the logical AND of the values in registers P1 and P2 and write the result into register P3.</source>
          <target state="translated">Возьмите логический AND значений в регистрах P1 и P2 и запишите результат в регистр P3.</target>
        </trans-unit>
        <trans-unit id="9fe2090d6b7e599d38b33eca83b4b2c09d8a131d" translate="yes" xml:space="preserve">
          <source>Take the logical OR of the values in register P1 and P2 and store the answer in register P3.</source>
          <target state="translated">Возьмите логическое ИЛИ значений в регистрах P1 и P2 и сохраните ответ в регистре P3.</target>
        </trans-unit>
        <trans-unit id="86743ec77172a00f99a2bc089314b61779948598" translate="yes" xml:space="preserve">
          <source>Taking into consideration all of the above, the SQLite developers recommend compiling SQLite using GCC-7 with the -Os optimization setting.</source>
          <target state="translated">Учитывая все вышесказанное,разработчики SQLite рекомендуют компилировать SQLite с помощью GCC-7 с настройкой -O оптимизации.</target>
        </trans-unit>
        <trans-unit id="76c9ad6f3798c330d93462b6d6a9dc1c1bbb0620" translate="yes" xml:space="preserve">
          <source>Tarball</source>
          <target state="translated">Tarball</target>
        </trans-unit>
        <trans-unit id="81919e9867e82f4145f1c83ee343766917076a71" translate="yes" xml:space="preserve">
          <source>Tcl Interface</source>
          <target state="translated">Tcl Интерфейс</target>
        </trans-unit>
        <trans-unit id="5962096d8eee555590e081b0968ff7c28d5fa0d8" translate="yes" xml:space="preserve">
          <source>Tcl command. Here is an example of opening and then immediately closing a database:</source>
          <target state="translated">Команда Tcl.Приведем пример открытия,а затем немедленного закрытия БД:</target>
        </trans-unit>
        <trans-unit id="30d70929c5f61502f6c778af83fbc14057a6c36d" translate="yes" xml:space="preserve">
          <source>Tcl interface allows BLOB values to be transferred to user-defined functions</source>
          <target state="translated">Tcl-интерфейс позволяет передавать BLOB-значения в функции,определяемые пользователем.</target>
        </trans-unit>
        <trans-unit id="82fe9aa4119c1f18902f153a0d50a82f529e5cfb" translate="yes" xml:space="preserve">
          <source>Tcl variable names can appear in the SQL statement of the second argument in any position where it is legal to put a string or number literal. The value of the variable is substituted for the variable name. If the variable does not exist a NULL values is used. For example:</source>
          <target state="translated">Имена переменных Tcl могут появляться в SQL-операторе второго аргумента в любой позиции,где легально ставить строковый или числовой литерал.Значение переменной подставляется под имя переменной.Если переменная не существует,используется NULL-значение.Например:</target>
        </trans-unit>
        <trans-unit id="2087e1ec9a4eee3edea091cbf4ce24dad9709230" translate="yes" xml:space="preserve">
          <source>Technical and Design Documentation</source>
          <target state="translated">Техническая и проектная документация</target>
        </trans-unit>
        <trans-unit id="b6d6d722a0223fd3e9343b1f4796db6a665b091d" translate="yes" xml:space="preserve">
          <source>Temporary Databases</source>
          <target state="translated">Временные базы данных</target>
        </trans-unit>
        <trans-unit id="6035a1db7f899a29bfadee59c52d9c07fdd98c4f" translate="yes" xml:space="preserve">
          <source>Temporary Files Used By SQLite</source>
          <target state="translated">Временные файлы,используемые SQLite</target>
        </trans-unit>
        <trans-unit id="9fb2a1ec0fce944f3e17c8ab4b4f05b81d7ac8a9" translate="yes" xml:space="preserve">
          <source>Temporary directory search algorithm</source>
          <target state="translated">Алгоритм поиска временного каталога</target>
        </trans-unit>
        <trans-unit id="72f84f0ca9f1ad9f151e46cd589374308dcbfc81" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored in memory regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">Временные файлы всегда хранятся в памяти, независимо от настройки &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагмы temp_store&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92a5156680aa1ea2c11db1f65a26abbd9db39a63" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored on disk regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">Временные файлы всегда хранятся на диске независимо от настройки &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;прагмы temp_store&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7777ca8353568841ffb0454d79b2cf5d09f1f51b" translate="yes" xml:space="preserve">
          <source>Temporary files are now automatically deleted by the operating system when closed. There are no more dangling temporary files on a program crash. (If the OS crashes, fsck will delete the file after reboot under Unix. I do not know what happens under Windows.)</source>
          <target state="translated">Теперь временные файлы автоматически удаляются операционной системой при закрытии.Больше нет висячих временных файлов при падении программы.(При падении ОС fsck удалит файл после перезагрузки под Unix.Я не знаю,что происходит под Windows).</target>
        </trans-unit>
        <trans-unit id="96da9e1a1910e6d40a0e879229d60b3a31a1bf7a" translate="yes" xml:space="preserve">
          <source>Temporary files are stored in memory by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">По умолчанию временные файлы хранятся в памяти, но это можно &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;изменить&lt;/a&gt; с помощью прагмы temp_store .</target>
        </trans-unit>
        <trans-unit id="11e15117ca75e55537b6f5f3dded721aee297def" translate="yes" xml:space="preserve">
          <source>Temporary files are stored on disk by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">По умолчанию временные файлы хранятся на диске, но это можно &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;изменить&lt;/a&gt; с помощью прагмы temp_store .</target>
        </trans-unit>
        <trans-unit id="7500f7d38f84089cbb32d6695814260f35c022d2" translate="yes" xml:space="preserve">
          <source>Temporary journal files are created as part of transaction control, but those extra files are not part of the steady-state database.</source>
          <target state="translated">Файлы временных журналов создаются в рамках контроля транзакций,но эти дополнительные файлы не входят в стационарную базу данных.</target>
        </trans-unit>
        <trans-unit id="455a1e08ff236bc4fc37f10c45a4f1a9d962e921" translate="yes" xml:space="preserve">
          <source>Temporary tables</source>
          <target state="translated">Временные столы</target>
        </trans-unit>
        <trans-unit id="4dff3aa4061b74df07e184cd766c027d8d0851b5" translate="yes" xml:space="preserve">
          <source>Terminate the sqlite3 program by typing your system End-Of-File character (usually a Control-D). Use the interrupt character (usually a Control-C) to stop a long-running SQL statement.</source>
          <target state="translated">Завершите программу sqlite3,набрав в системе символ End-Of-File (обычно это Controll-D).Используйте символ прерывания (обычно Controll-C)для остановки долгосрочного SQL-оператора.</target>
        </trans-unit>
        <trans-unit id="f859f91a5306999f44ef0e2194daef49cbdeb611" translate="yes" xml:space="preserve">
          <source>Terminating a read-only transaction.</source>
          <target state="translated">Завершение сделки только для чтения.</target>
        </trans-unit>
        <trans-unit id="46428866c7ab286d2c6ac557b2373b6b72377ee3" translate="yes" xml:space="preserve">
          <source>Terms of the ORDER BY clause that is part of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement may be assigned a collating sequence using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, in which case the specified collating function is used for sorting. Otherwise, if the expression sorted by an ORDER BY clause is a column, then the collating sequence of the column is used to determine sort order. If the expression is not a column and has no COLLATE clause, then the BINARY collating sequence is used.</source>
          <target state="translated">Условиям предложения ORDER BY, которое является частью &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT,&lt;/a&gt; может быть назначена последовательность сортировки с помощью &lt;a href=&quot;lang_expr#collateop&quot;&gt;оператора COLLATE&lt;/a&gt; , и в этом случае указанная функция сортировки используется для сортировки. В противном случае, если выражение, отсортированное с помощью предложения ORDER BY, является столбцом, то последовательность сортировки столбца используется для определения порядка сортировки. Если выражение не является столбцом и не имеет предложения COLLATE, то используется последовательность сортировки BINARY.</target>
        </trans-unit>
        <trans-unit id="fcd7a264ae14d824015af364fb3c10f3c2a51f9d" translate="yes" xml:space="preserve">
          <source>Terms of the WHERE clause can be manually disqualified for use with indexes by prepending a unary &lt;b&gt;+&lt;/b&gt; operator to the column name. The unary &lt;b&gt;+&lt;/b&gt; is a no-op and will not generate any byte code in the prepared statement. However, the unary &lt;b&gt;+&lt;/b&gt; operator will prevent the term from constraining an index. So, in the example above, if the query were rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb252ee8cea482226d27c4a24f04af58befef27" translate="yes" xml:space="preserve">
          <source>Terms of the WHERE clause can be manually disqualified for use with indices by prepending a unary *+* operator to the column name. The unary *+* is a no-op and will not generate any byte code in the prepared statement. But the unary *+* operator will prevent the term from constraining an index. So, in the example above, if the query were rewritten as:</source>
          <target state="translated">Условия пункта WHERE можно вручную дисквалифицировать для использования с индексами,предваряя имя столбца унарным оператором *+*.Унарный *+*является нулевым и не будет генерировать байтовый код в подготовленном операторе.Однако,унарный оператор *+*не допустит,чтобы условие ограничивало индекс.Итак,в примере выше,если запрос был переписан как:</target>
        </trans-unit>
        <trans-unit id="db8a7aee242ffd686d07e20367e523410ddf047e" translate="yes" xml:space="preserve">
          <source>Test 10: 25000 text UPDATEs with an index</source>
          <target state="translated">Тест 10:25000 текстовых UPDATE с индексом</target>
        </trans-unit>
        <trans-unit id="aacbc05d861c7b90deae327687214123e261d5d7" translate="yes" xml:space="preserve">
          <source>Test 11: INSERTs from a SELECT</source>
          <target state="translated">Тест 11:ИНСЕРТЫ от ВЫБОРА</target>
        </trans-unit>
        <trans-unit id="aca64bdf90089bb1a7f070072ce5ba7eb929e0ca" translate="yes" xml:space="preserve">
          <source>Test 12: DELETE without an index</source>
          <target state="translated">Тест 12:УДАЛИТЬ без индекса</target>
        </trans-unit>
        <trans-unit id="24752c37e60c377f791b489053904e7999992109" translate="yes" xml:space="preserve">
          <source>Test 13: DELETE with an index</source>
          <target state="translated">Тест 13:УДАЛИТЬ с индексом</target>
        </trans-unit>
        <trans-unit id="00cb0edebe54a9c5c407d066d9fcba0da202194b" translate="yes" xml:space="preserve">
          <source>Test 14: A big INSERT after a big DELETE</source>
          <target state="translated">Тест 14:Большой проигрыватель после большого проигрыша.</target>
        </trans-unit>
        <trans-unit id="8033466c1d65a1a2a0c68dc77e0e42697e35f88b" translate="yes" xml:space="preserve">
          <source>Test 15: A big DELETE followed by many small INSERTs</source>
          <target state="translated">Тест 15:Большое УДАЛЕНИЕ,за которым следуют многие маленькие ИНСЕРТЫ.</target>
        </trans-unit>
        <trans-unit id="391b748d4bf30ad6ba35b1537b20fb9263b9be11" translate="yes" xml:space="preserve">
          <source>Test 16: DROP TABLE</source>
          <target state="translated">Тест 16:DROP TABLE</target>
        </trans-unit>
        <trans-unit id="700f1cfb18cec62b7bd8f4bd15b16b69774b094a" translate="yes" xml:space="preserve">
          <source>Test 1: 1000 INSERTs</source>
          <target state="translated">Тест 1:1000 ИНСЕРТОВ</target>
        </trans-unit>
        <trans-unit id="a74380705222d36f436d75c90099251831b68c6d" translate="yes" xml:space="preserve">
          <source>Test 2: 25000 INSERTs in a transaction</source>
          <target state="translated">Тест 2:25000 ИНСЕРТОВ в сделке</target>
        </trans-unit>
        <trans-unit id="d01c89b36c5ea1e456013c3cc10174d42005deaa" translate="yes" xml:space="preserve">
          <source>Test 3: 25000 INSERTs into an indexed table</source>
          <target state="translated">Тест 3:25000 ИНСЕРТов в проиндексированную таблицу</target>
        </trans-unit>
        <trans-unit id="5150380a9467a7720fe9216afc4866b3aea9f992" translate="yes" xml:space="preserve">
          <source>Test 4: 100 SELECTs without an index</source>
          <target state="translated">Тест 4:100 ВЫБРОСОВ без индекса</target>
        </trans-unit>
        <trans-unit id="2d07089542c5b6e56dea3631a868016dd2267c55" translate="yes" xml:space="preserve">
          <source>Test 5: 100 SELECTs on a string comparison</source>
          <target state="translated">Тест 5:100 ВЫБРОСОВ при сравнении строк</target>
        </trans-unit>
        <trans-unit id="1ee313e9981650c288efefb71dc3528b68b2a91a" translate="yes" xml:space="preserve">
          <source>Test 6: Creating an index</source>
          <target state="translated">Тест 6:Создание индекса</target>
        </trans-unit>
        <trans-unit id="e0797e7844f18b5e63c9d2f6207a7266e87d829e" translate="yes" xml:space="preserve">
          <source>Test 7: 5000 SELECTs with an index</source>
          <target state="translated">Тест 7:5000 SELECTs с индексом</target>
        </trans-unit>
        <trans-unit id="fccbfc70f55db2b38d057e5e2decb47d90df070e" translate="yes" xml:space="preserve">
          <source>Test 8: 1000 UPDATEs without an index</source>
          <target state="translated">Испытание 8:1000 UPDATE без индекса</target>
        </trans-unit>
        <trans-unit id="47ad12d810778d98e72de67605dc988105d4b09b" translate="yes" xml:space="preserve">
          <source>Test 9: 25000 UPDATEs with an index</source>
          <target state="translated">Тест 9:25000 UPDATE с индексом</target>
        </trans-unit>
        <trans-unit id="18a302ee283ea042f30ca2cb852a2846f97c9413" translate="yes" xml:space="preserve">
          <source>Test Code</source>
          <target state="translated">Тестовый код</target>
        </trans-unit>
        <trans-unit id="fbcf57d6160711801ae44b031c459127add7faaa" translate="yes" xml:space="preserve">
          <source>Test Environment</source>
          <target state="translated">Испытательная среда</target>
        </trans-unit>
        <trans-unit id="a76dd0a3dd495aa45fe2a39614c44782afcb01ca" translate="yes" xml:space="preserve">
          <source>Test For Auto-Commit Mode</source>
          <target state="translated">Тест для режима автоматической коммутации</target>
        </trans-unit>
        <trans-unit id="c05597ed0dba53dda21d6b294858039879f34b2b" translate="yes" xml:space="preserve">
          <source>Test To See If The Library Is Threadsafe</source>
          <target state="translated">Проверьте,является ли библиотека безопасной для чтения.</target>
        </trans-unit>
        <trans-unit id="02446da6bfd0c0c261b870c2d7a5bfb426f2969d" translate="yes" xml:space="preserve">
          <source>Test data unavailable.</source>
          <target state="translated">Тестовые данные недоступны.</target>
        </trans-unit>
        <trans-unit id="a364e52356a7ca07cff67161e3755ffa1a5b6b19" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes</source>
          <target state="translated">Проверить,записал ли набор изменений</target>
        </trans-unit>
        <trans-unit id="0687fd76855654ace6e8592132670b232e8466bb" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes.</source>
          <target state="translated">Проверьте,записал ли набор изменений.</target>
        </trans-unit>
        <trans-unit id="975278e4cf4ae85f07454f0bd57ddce6fc5bd9a5" translate="yes" xml:space="preserve">
          <source>Testcase macros are also used when two or more cases of a switch statement go to the same block of code, to make sure that the code was reached for all cases:</source>
          <target state="translated">Макросы Testcase также используются,когда два или более случая оператора-переключателя переходят в один и тот же блок кода,чтобы убедиться,что код был достигнут для всех случаев:</target>
        </trans-unit>
        <trans-unit id="c5d38ba7cbc400f9b209719e16e540214a64776c" translate="yes" xml:space="preserve">
          <source>Testing Interface</source>
          <target state="translated">Интерфейс тестирования</target>
        </trans-unit>
        <trans-unit id="8adc754de4730d9303e4e9dfdc04c11250d45d3c" translate="yes" xml:space="preserve">
          <source>Testing Interface Operation Codes</source>
          <target state="translated">Тестирование кодов управления интерфейсом</target>
        </trans-unit>
        <trans-unit id="61b27896db003bc4e45807f83422aff3b0ba8af9" translate="yes" xml:space="preserve">
          <source>Testing of both source code and object code</source>
          <target state="translated">Тестирование как исходного кода,так и объектного кода</target>
        </trans-unit>
        <trans-unit id="e1859263f675753d24029e449e12bbca3196f641" translate="yes" xml:space="preserve">
          <source>Testing on multiple platforms and with multiple compilers</source>
          <target state="translated">Тестирование на нескольких платформах и с помощью нескольких компиляторов</target>
        </trans-unit>
        <trans-unit id="c9efb9d787a1a844d9d75c706c96b2d104de210f" translate="yes" xml:space="preserve">
          <source>Text Encodings</source>
          <target state="translated">Текстовое кодирование</target>
        </trans-unit>
        <trans-unit id="104683d616e58eaef10d6dc4873ecdc3df7b2908" translate="yes" xml:space="preserve">
          <source>Text encoding</source>
          <target state="translated">Кодирование текста</target>
        </trans-unit>
        <trans-unit id="e12c4eeb80ad1f4c53769014c35b62416e040202" translate="yes" xml:space="preserve">
          <source>Text files read by the COPY command can now have line terminators of LF, CRLF, or CR.</source>
          <target state="translated">Текстовые файлы,читаемые командой COPY,теперь могут иметь терминаторы строк LF,CRLF или CR.</target>
        </trans-unit>
        <trans-unit id="cc9a8c0f2eca40d02a98349a624352ec809c4662" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="translated">Текст добавляется к объекту sqlite3_str с помощью различных методов, таких как &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f06b000ef5df2cf2524013049769bc8b85cadef" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="translated">Текст добавляется к объекту sqlite3_str с помощью различных методов, таких как &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65ebd99ce12ebe199710e41e33f5f3620f55ed7a" translate="yes" xml:space="preserve">
          <source>Text values (odd serial types 13 and larger) sort after numeric values in the order determined by the columns &lt;a href=&quot;datatype3#collation&quot;&gt;collating function&lt;/a&gt;.</source>
          <target state="translated">Текстовые значения (нечетные последовательные типы 13 и больше) сортируются после числовых значений в порядке, определяемом &lt;a href=&quot;datatype3#collation&quot;&gt;функцией сортировки&lt;/a&gt; столбцов .</target>
        </trans-unit>
        <trans-unit id="beca9771feb98f615524a1df72482f4458f93607" translate="yes" xml:space="preserve">
          <source>Text values come after numerics</source>
          <target state="translated">Текстовые значения идут после цифр</target>
        </trans-unit>
        <trans-unit id="938716cf9d2d773dc94de020d7864e49e44b2b9d" translate="yes" xml:space="preserve">
          <source>Th functionality described in this section may be integrated into other applications or tools using the &lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt; SQLite expert extension&lt;/a&gt; code.</source>
          <target state="translated">Функциональность, описанная в этом разделе, может быть интегрирована в другие приложения или инструменты с использованием кода &lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt;расширения эксперта SQLite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60ce50a49fab2debe76004dae03d373ca41cf229" translate="yes" xml:space="preserve">
          <source>Th functionality described in this section may be integrated into other applications or tools using the &lt;a href=&quot;https://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt; SQLite expert extension&lt;/a&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5401c7212b5c2e26aee89d6b33a167be2b97f64d" translate="yes" xml:space="preserve">
          <source>That command only works as written on Windows. The equivalent line on a Mac would be:</source>
          <target state="translated">Эта команда работает только так,как написано в Windows.Эквивалентная строка на Mac:</target>
        </trans-unit>
        <trans-unit id="5b3c3c06cd257877a1f47703881aa426e835ba23" translate="yes" xml:space="preserve">
          <source>That last command is the same &quot;ui&quot; command that we ran before. It starts a mini-webserver running and points your web browser at it. But this time we didn't have to specify the repository file because we are located inside a checkout and so fossil can figure out the repository for itself. If you want to type in the repository filename as the second argument, you can. But it is optional.</source>
          <target state="translated">Эта последняя команда-та же самая &quot;ui&quot; команда,которую мы выполняли раньше.Она запускает мини-сервер и направляет на него ваш веб-браузер.Но в этот раз нам не пришлось указывать файл репозитория,потому что мы находимся внутри извлекаемого файла и поэтому ископаемые могут сами разобраться в репозитории.Если вы хотите ввести имя файла репозитория в качестве второго аргумента,вы можете это сделать.Но это необязательно.</target>
        </trans-unit>
        <trans-unit id="a5f3f833bc87b1f8e923756ce16d0960d01c9cad" translate="yes" xml:space="preserve">
          <source>That number is very close to 47.49, but it is not exact. It is a little too big. If we reduce M by one to 6683623321994526 so that we have the next smaller possible binary64 value, we get:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec5cf39a76e0d09154e1a51128f437190f411ce" translate="yes" xml:space="preserve">
          <source>That said, there are a number of things that external programs or bugs in your hardware or OS can do to corrupt a database file. See &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt An SQLite Database File&lt;/a&gt; for further information.</source>
          <target state="translated">Тем не менее, есть ряд вещей, которые внешние программы или ошибки в вашем оборудовании или ОС могут сделать, чтобы повредить файл базы данных. См. &lt;a href=&quot;howtocorrupt&quot;&gt;Как испортить файл базы данных SQLite&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ac09579911e9129dbe219b67c0bf67a294beccfa" translate="yes" xml:space="preserve">
          <source>That statement is ambiguous, having at least two possible interpretations:</source>
          <target state="translated">Это утверждение неоднозначно,имеет,по крайней мере,две возможные интерпретации:</target>
        </trans-unit>
        <trans-unit id="c679c2a5140d95b7fe5e7a9c937890448e4790a5" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_parent table as there are non-leaf cells in the r-tree structure, and that there is a non-leaf cell that corresponds to each entry in the %_parent table.</source>
          <target state="translated">Чтобы в таблице %_parent было столько же записей,сколько и в структуре r-дерева,и чтобы была нелистовая ячейка,соответствующая каждой записи в таблице %_parent.</target>
        </trans-unit>
        <trans-unit id="9bc14fa3c4653db3dfe511c9da292c9e32677da7" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_rowid table as there are leaf cells in the r-tree structure, and that there is a leaf cell that corresponds to each entry in the %_rowid table.</source>
          <target state="translated">Чтобы в таблице %_rowid было столько же записей,сколько ячеек листа в структуре r-дерева,и чтобы была ячейка листа,соответствующая каждой записи в таблице %_rowid.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="c3fcc1dd87de9c9ad15a933b970c62ff1decbfcb" translate="yes" xml:space="preserve">
          <source>The &quot;%&quot; in the name of each shadow table is replaced by the name of the R*Tree virtual table. So, if the name of the R*Tree table is &quot;xyz&quot; then the three shadow tables would be &quot;xyz_node&quot;, &quot;xyz_parent&quot;, and &quot;xyz_rowid&quot;.</source>
          <target state="translated">В названии каждой теневой таблицы &quot;%&quot; заменяется на название виртуальной таблицы R*Tree.Таким образом,если бы имя таблицы R*Tree было &quot;xyz&quot;,то тремя теневыми таблицами были бы &quot;xyz_node&quot;,&quot;xyz_parent&quot; и &quot;xyz_rowid&quot;.</target>
        </trans-unit>
        <trans-unit id="c0ac1d4dc22d0f78dbeef0512926462de5ac6f42" translate="yes" xml:space="preserve">
          <source>The &quot;-1&quot; term at the start of the formula is not found in most implementations of the BM25 algorithm. Without it, a better match is assigned a numerically higher BM25 score. Since the default sorting order is &quot;ascending&quot;, this means that appending &quot;ORDER BY bm25(fts)&quot; to a query would cause results to be returned in order from worst to best. The &quot;DESC&quot; keyword would be required in order to return the best matches first. In order to avoid this pitfall, the FTS5 implementation of BM25 multiplies the result by -1 before returning it, ensuring that better matches are assigned numerically lower scores.</source>
          <target state="translated">Термин &quot;-1&quot; в начале формулы не встречается в большинстве реализаций алгоритма BM25.Без него лучшему соответствию присваивается численно более высокий балл BM25.Поскольку по умолчанию порядок сортировки &quot;восходящий&quot;,это означает,что добавление к запросу &quot;ORDER BY bm25(fts)&quot; приведет к тому,что результаты будут возвращаться в порядке от худшего к лучшему.Ключевое слово &quot;DESC&quot; будет необходимо для того,чтобы сначала вернуть лучшие совпадения.Чтобы избежать этого подводного камня,реализация FTS5 в BM25 умножает результат на -1 перед возвращением,гарантируя,что лучшим совпадениям присваивается численно меньшее количество баллов.</target>
        </trans-unit>
        <trans-unit id="e8a8a21328c61527fb3df55781ac56d188f8d80f" translate="yes" xml:space="preserve">
          <source>The &quot;.archive&quot; dot-command and the &quot;-A&quot; command-line option provide built-in support for the &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive format&lt;/a&gt;. The interface is similar to that of the &quot;tar&quot; command on unix systems. Each invocation of the &quot;.ar&quot; command must specify a single command option. The following commands are available for &quot;.archive&quot;:</source>
          <target state="translated">Точка-команда &quot;.archive&quot; и параметр командной строки &quot;-A&quot; обеспечивают встроенную поддержку &lt;a href=&quot;sqlar&quot;&gt;формата архива SQLite&lt;/a&gt; . Интерфейс аналогичен интерфейсу команды tar в системах unix. Каждый вызов команды &quot;.ar&quot; должен указывать единственный параметр команды. Для &quot;.archive&quot; доступны следующие команды:</target>
        </trans-unit>
        <trans-unit id="83487a27f6e8c5a3e4b3ee1c0c3210033e4ad993" translate="yes" xml:space="preserve">
          <source>The &quot;.breakpoint&quot; command in the CLI does nothing but invoke the procedure named &quot;test_breakpoint()&quot;, which is a no-op.</source>
          <target state="translated">Команда &quot;.breakpoint&quot; в CLI ничего не делает,кроме вызова процедуры с именем &quot;test_breakpoint()&quot;,которая является no-op.</target>
        </trans-unit>
        <trans-unit id="469a3442411a65b2a429f963b79791f612ed7d6e" translate="yes" xml:space="preserve">
          <source>The &quot;.databases&quot; command shows a list of all databases open in the current connection. There will always be at least 2. The first one is &quot;main&quot;, the original database opened. The second is &quot;temp&quot;, the database used for temporary tables. There may be additional databases listed for databases attached using the ATTACH statement. The first output column is the name the database is attached with, and the second column is the filename of the external file.</source>
          <target state="translated">Команда &quot;.БД&quot; показывает список всех БД,открытых в текущем подключении.Их всегда будет не менее 2.Первая-&quot;основная&quot;,оригинальная открытая БД.Вторая-&quot;временная&quot;,БД,используемая для временных таблиц.Для БД,подключенных с помощью оператора ATTACH,могут быть дополнительные БД.Первый столбец вывода-это имя,к которому подключена БД,а второй столбец-имя файла внешнего файла.</target>
        </trans-unit>
        <trans-unit id="d20a2da5a51f1af193930a68e8670b4b6926e994" translate="yes" xml:space="preserve">
          <source>The &quot;.databases&quot; command shows a list of all databases open in the current connection. There will always be at least 2. The first one is &quot;main&quot;, the original database opened. The second is &quot;temp&quot;, the database used for temporary tables. There may be additional databases listed for databases attached using the ATTACH statement. The first output column is the name the database is attached with, and the second result column is the filename of the external file. There may be a third result column which will be either &quot;'r/o'&quot; or &quot;'r/w'&quot; depending of if the database file is read-only or read-write. And there might be fourth result column showing the result of &lt;a href=&quot;c3ref/txn_state&quot;&gt;sqlite3_txn_state()&lt;/a&gt; for that database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee926b57bed300f9a7e5c92f6be433c508e9bcc7" translate="yes" xml:space="preserve">
          <source>The &quot;.dump&quot; output from the shell does not work if there are embedded newlines anywhere in the data. This is an old bug that was carried forward from version 1.0. To fix it, the &quot;.dump&quot; output no longer uses the COPY command. It instead generates INSERT statements.</source>
          <target state="translated">Вывод &quot;.dump&quot; из оболочки не работает,если в данные где-то встроены новые строки.Это старая ошибка,которая была перенесена с версии 1.0.Чтобы исправить ее,вывод &quot;.dump&quot; больше не использует команду COPY.Вместо этого он генерирует операторы INSERT.</target>
        </trans-unit>
        <trans-unit id="1b85291d31b07e89b01fbd9925959d88473c2a10" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is an alias for &quot;.once -x&quot;. It does exactly the same thing.</source>
          <target state="translated">Команда &quot;.excel&quot;-это псевдоним для &quot;.once -x&quot;.Она делает точно то же самое.</target>
        </trans-unit>
        <trans-unit id="9686c64857b56634cf1d980b549835b7a48ecb3c" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is really an alias for &quot;.once -x&quot;. The -x option to .once causes it to writes results as CSV into a temporary file that is named with a &quot;.csv&quot; suffix, then invoke the systems default handler for CSV files.</source>
          <target state="translated">Команда &quot;.excel&quot; на самом деле является псевдонимом для &quot;.once -x&quot;.Опция -x в .once приводит к записи результатов в виде CSV во временный файл,который называется суффиксом &quot;.csv&quot;,а затем вызывает системный обработчик по умолчанию для CSV-файлов.</target>
        </trans-unit>
        <trans-unit id="a0ea244938baaf074aedf53e702eadce70d483bf" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command accepts the following options:</source>
          <target state="translated">Команда &quot;.эксперт&quot; принимает следующие варианты:</target>
        </trans-unit>
        <trans-unit id="62869dd914f2d45ca628931082045505cc0aa98c" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command is issued first, followed by the SQL query on a separate line. For example, consider the following session:</source>
          <target state="translated">Сначала выдается команда &quot;.эксперт&quot;,а затем SQL-запрос в отдельной строке.Например,рассмотрим следующую сессию:</target>
        </trans-unit>
        <trans-unit id="bf73e6ae296e826f7923e0357132694890491637" translate="yes" xml:space="preserve">
          <source>The &quot;.fullschema&quot; dot-command works like the &quot;.schema&quot; command in that it displays the entire database schema. But &quot;.fullschema&quot; also includes dumps of the statistics tables &quot;sqlite_stat1&quot;, &quot;sqlite_stat3&quot;, and &quot;sqlite_stat4&quot;, if they exist. The &quot;.fullschema&quot; command normally provides all of the information needed to exactly recreate a query plan for a specific query. When reporting suspected problems with the SQLite query planner to the SQLite development team, developers are requested to provide the complete &quot;.fullschema&quot; output as part of the trouble report. Note that the sqlite_stat3 and sqlite_stat4 tables contain samples of index entries and so might contain sensitive data, so do not send the &quot;.fullschema&quot; output of a proprietary database over a public channel.</source>
          <target state="translated">Точка-команда &quot;.fulllschema&quot; работает как команда &quot;.schema&quot; в том,что она отображает всю схему БД.Но &quot;.fullschema&quot; включает также дамп таблицы статистики &quot;sqlite_stat1&quot;,&quot;sqlite_stat3&quot; и &quot;sqlite_stat4&quot;,если они существуют.Команда &quot;.fullschema&quot; обычно предоставляет всю информацию,необходимую для точного воссоздания плана запроса для конкретного запроса.При сообщении о подозрительных проблемах с планировщиком запросов SQLite команде разработчиков SQLite,разработчикам предлагается предоставить полный вывод &quot;.fulllschema&quot; как часть отчета о проблеме.Обратите внимание,что таблицы sqlite_stat3 и sqlite_stat4 содержат образцы индексных записей и поэтому могут содержать конфиденциальные данные,поэтому не посылайте вывод &quot;.fulllschema&quot; проприетарной базы данных по публичному каналу.</target>
        </trans-unit>
        <trans-unit id="8c41f773b4bec069e65cdeb1f84472339fd67927" translate="yes" xml:space="preserve">
          <source>The &quot;.genfkey&quot; operator has been removed from the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">Оператор &quot;.genfkey&quot; был удален из &lt;a href=&quot;cli&quot;&gt;интерфейса командной строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6da1e8e52719870c46e4714e803817bbb945c7a2" translate="yes" xml:space="preserve">
          <source>The &quot;.indexes&quot; command works in a similar way to list all of the indexes. If the &quot;.indexes&quot; command is given an argument which is the name of a table, then it shows just indexes on that table.</source>
          <target state="translated">Команда &quot;.индексы&quot; работает аналогичным образом,чтобы перечислить все индексы.Если команде &quot;.индексы&quot; задан аргумент,который является именем таблицы,то она показывает только индексы на этой таблице.</target>
        </trans-unit>
        <trans-unit id="332e81eb83bf30c51e9f2eb4830d160fd5e91b60" translate="yes" xml:space="preserve">
          <source>The &quot;.load&quot; command with one argument invokes sqlite3_load_extension() with the zProc parameter set to NULL, causing SQLite to first look for an entry point named &quot;sqlite3_extension_init&quot; and then &quot;sqlite3_X_init&quot; where &quot;X&quot; is derived from the filename. If your extension has an entry point with a different name, simply supply that name as the second argument. For example:</source>
          <target state="translated">Команда &quot;.load&quot; с одним аргументом вызывает sqlite3_load_extension()с параметром zProc,установленным в NULL,заставляя SQLite сначала искать точку входа с именем &quot;sqlite3_extension_init&quot;,а затем &quot;sqlite3_X_init&quot;,где &quot;X&quot; происходит от имени файла.Если ваше расширение имеет точку входа с другим именем,просто предоставьте это имя в качестве второго аргумента.Например:</target>
        </trans-unit>
        <trans-unit id="7e0f642688db88c440c3786a62b2e62ab2274b87" translate="yes" xml:space="preserve">
          <source>The &quot;.parameter&quot; command exists to simplify managing this table. The &quot;.parameter init&quot; command (often abbreviated as just &quot;.param init&quot;) creates the temp.sqlite_parameters table if it does not already exist. The &quot;.param list&quot; command shows all entries in the temp.sqlite_parameters table. The &quot;.param clear&quot; command drops the temp.sqlite_parameters table. The &quot;.param set KEY VALUE&quot; and &quot;.param unset KEY&quot; commands create or delete entries from the temp.sqlite_parameters table.</source>
          <target state="translated">Команда &quot;.параметр&quot; существует для упрощения управления этой таблицей.Команда &quot;.параметр init&quot; (часто сокращенно просто &quot;.параметр init&quot;)создает таблицу temp.sqlite_parameters,если она еще не существует.Команда &quot;.параметр init&quot; показывает все записи в таблице temp.sqlite_parameters.Команда &quot;.param clear&quot; выводит таблицу temp.sqlite_parameters.Команды &quot;.параметр set KEY VALUE&quot; и &quot;.параметр unset KEY&quot; создают или удаляют записи из таблицы temp.sqlite_parameters.</target>
        </trans-unit>
        <trans-unit id="37cba1b3643d5235ea4e515f4ee004481495d64b" translate="yes" xml:space="preserve">
          <source>The &quot;.read&quot; command takes a single argument which is (usually) the name of a file from which to read input text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b54f6bbb126d4f3d8cbe5461cc017452178177b" translate="yes" xml:space="preserve">
          <source>The &quot;.read&quot; command temporarily stops reading from the keyboard and instead takes its input from the file named. Upon reaching the end of the file, input reverts back to the keyboard. The script file may contain dot-commands, just like ordinary interactive input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789a156efc523de5bfce09730a51219cae2ec0c9" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command can be augmented with the &quot;--indent&quot; option, in which case it tries to reformat the various CREATE statements of the schema so that they are more easily readable by humans.</source>
          <target state="translated">Команда &quot;.schema&quot; может быть дополнена опцией &quot;--indent&quot;,в этом случае она пытается переформатировать различные CREATE утверждения схемы так,чтобы они были более легко читаемы людьми.</target>
        </trans-unit>
        <trans-unit id="754968254f462d66877df03c1c7cd51953693cab" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command is roughly the same as setting list mode, then entering the following query:</source>
          <target state="translated">Команда &quot;.schema&quot; приблизительно аналогична режиму задания списка,после чего вводится следующий запрос:</target>
        </trans-unit>
        <trans-unit id="7428559526f83a5c56d268af9889807faae2685e" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the complete schema for the database, or for a single table if an optional tablename argument is provided:</source>
          <target state="translated">Команда &quot;.schema&quot; показывает полную схему для БД или для одной таблицы,если указан необязательный аргумент &quot;tablename&quot;:</target>
        </trans-unit>
        <trans-unit id="52ace065300c40138c37799338bd3ec51aca18df" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the structure of virtual tables.</source>
          <target state="translated">Команда &quot;.schema&quot; показывает структуру виртуальных таблиц.</target>
        </trans-unit>
        <trans-unit id="73bcba8970e82dc921d7f4ec8db20bb33cbfb0a3" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest --init&quot; command creates the selftest table if it does not already exists, then appends entries that check the SHA3 hash of the content of all tables. Subsequent runs of &quot;.selftest&quot; will verify that the database has not been changed in any way. To generates tests to verify that a subset of the tables are unchanged, simply run &quot;.selftest --init&quot; then &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; the selftest rows that refer to tables that are not constant.</source>
          <target state="translated">Команда &quot;.selftest --init&quot; создает таблицу самотестирования, если она еще не существует, а затем добавляет записи, которые проверяют хэш SHA3 содержимого всех таблиц. Последующие запуски &quot;.selftest&quot; будут проверять, что база данных не была изменена каким-либо образом. Для генерирует тесты , чтобы убедиться , что подмножество таблиц неизменны, просто запустите &amp;laquo;.selftest --init&amp;raquo; , то &lt;a href=&quot;lang_delete&quot;&gt;УДАЛИТЬ&lt;/a&gt; самотестирования строки, относящиеся к таблицам, которые не являются постоянными.</target>
        </trans-unit>
        <trans-unit id="b23d6efbb796b87124747de656b1313433a59a58" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest&quot; command attempts to verify that a database is intact and is not corrupt. The .selftest command looks for a table in schema named &quot;selftest&quot; and defined as follows:</source>
          <target state="translated">Команда &quot;.selftest&quot; пытается проверить,что БД не повреждена и не повреждена.Команда &quot;.selftest&quot; ищет таблицу в схеме под названием &quot;selftest&quot; и определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="da3394cbf6e430093bb273dc53c5c24290fb42a2" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command is implemented with the help of the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;extension function &quot;sha3_query()&quot;&lt;/a&gt; that is included with the command-line shell.</source>
          <target state="translated">Команда &amp;laquo;.sha3sum&amp;raquo; реализована с помощью &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;функции расширения &amp;laquo;sha3_query ()&amp;raquo;,&lt;/a&gt; которая включена в оболочку командной строки.</target>
        </trans-unit>
        <trans-unit id="49607863a0b317eaa9e0bb0334b35c6b17a96a09" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command supports options &quot;--sha3-224&quot;, &quot;--sha3-256&quot;, &quot;--sha3-384&quot;, and &quot;--sha3-512&quot; to define which variety of SHA3 to use for the hash. The default is SHA3-256.</source>
          <target state="translated">Команда &quot;.sha3sum&quot; поддерживает опции &quot;--sha3-224&quot;,&quot;--sha3-256&quot;,&quot;--sha3-384&quot; и &quot;--sha3-512&quot; для определения,какой вариант SHA3 использовать для хэша.По умолчанию используется SHA3-256.</target>
        </trans-unit>
        <trans-unit id="e496b68fde3cba7a6d3e4d071d1b64676cd89817" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command takes a single optional argument which is a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern. If this option is present, only tables whose names match the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern will be hashed.</source>
          <target state="translated">Команда &quot;.sha3sum&quot; принимает единственный необязательный аргумент, который является шаблоном &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; . Если этот параметр присутствует, будут хешироваться только таблицы, имена которых соответствуют шаблону &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0e55e4c460c47133735d47238f402c87368287c" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; dot-command computes a &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3&lt;/a&gt; hash of the &lt;em&gt;content&lt;/em&gt; of the database. To be clear, the hash is computed over the database content, not its representation on disk. This means, for example, that a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or similar data-preserving transformation does not change the hash.</source>
          <target state="translated">Точка-команда &quot;.sha3sum&quot; вычисляет &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3-&lt;/a&gt; хэш &lt;em&gt;содержимого&lt;/em&gt; базы данных. Чтобы было ясно, хеш вычисляется по содержимому базы данных, а не по ее представлению на диске. Это означает, например, что &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; или подобное преобразование с сохранением данных не изменяет хэш.</target>
        </trans-unit>
        <trans-unit id="d2252b9e19709b03f7ab086b59b1a77291173bd1" translate="yes" xml:space="preserve">
          <source>The &quot;.tables&quot; command is similar to setting list mode then executing the following query:</source>
          <target state="translated">Команда &quot;.tables&quot; аналогична установке режима списка,после чего выполняется следующий запрос:</target>
        </trans-unit>
        <trans-unit id="9eda9619ee5cbc80757e21696103e58ade470ff1" translate="yes" xml:space="preserve">
          <source>The &quot;.width&quot; command in the example above sets the width of the first column to 12 and the width of the second column to 6. All other column widths were unaltered. You can give as many arguments to &quot;.width&quot; as necessary to specify the widths of as many columns as are in your query results.</source>
          <target state="translated">Команда &quot;.width&quot; в приведенном выше примере устанавливает ширину первого столбца равной 12,а ширину второго-6.Все остальные ширины столбцов были неизменны.Вы можете задать столько аргументов &quot;.width&quot;,сколько необходимо,чтобы задать ширину стольких столбцов,сколько указано в результатах запроса.</target>
        </trans-unit>
        <trans-unit id="8d28508cd52964017863df7d9bff1bae6f7b1b73" translate="yes" xml:space="preserve">
          <source>The &quot;1&quot; at the end of the name for the json1 extension is deliberate. The designers anticipate that there will be future incompatible JSON extensions building upon the lessons learned from json1. Once sufficient experience is gained, some kind of JSON extension might be folded into the SQLite core. For now, JSON support remains an extension.</source>
          <target state="translated">Символ &quot;1&quot; в конце имени для расширения json1 является преднамеренным.Разработчики предполагают,что в будущем будут существовать несовместимые расширения JSON на основе уроков,извлеченных из работы над расширением json1.Как только будет получен достаточный опыт,некоторое JSON расширение может быть сложено в ядро SQLite.Пока что поддержка JSON остается расширением.</target>
        </trans-unit>
        <trans-unit id="ec1a7b1bff513b8dc885dad8096593de50c679b9" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt;&quot; command ignores an initial UTF-8 BOM.</source>
          <target state="translated">Команда &quot; &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; &quot; игнорирует исходную спецификацию UTF-8.</target>
        </trans-unit>
        <trans-unit id="39a3b12173588647fa6bbe9bfdec68cffc6ff3a2" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; must be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt; where the right-most &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt; is either UNION or UNION ALL.</source>
          <target state="translated">&amp;laquo; &lt;a href=&quot;syntax/select-stmt&quot;&gt;Select-stmt&lt;/a&gt; &amp;raquo; должен быть &lt;a href=&quot;lang_select#compound&quot;&gt;составным выбором,&lt;/a&gt; где крайний правый &lt;a href=&quot;syntax/compound-operator&quot;&gt;составной оператор&lt;/a&gt; - либо UNION, либо UNION ALL.</target>
        </trans-unit>
        <trans-unit id="1b29ebb01e08ccb759bf391547ff1f9bffd4a349" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; must be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;. That is to say, the CTE body must be two or more individual SELECT statements separated by compound operators like UNION, UNION ALL, INTERSECT, or EXCEPT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1ee86a4eb35dd217941c49a4c1f826afe5d0c7" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; syntax diagram above attempts to show as much of the SELECT statement syntax as possible in a single diagram, because some readers find that helpful. The following &quot;&lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&quot; is an alternative syntax diagrams that expresses the same syntax but tries to break the syntax down into smaller chunks.</source>
          <target state="translated">Синтаксическая диаграмма &quot; &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; &quot; выше пытается показать как можно больше синтаксиса оператора SELECT на одной диаграмме, потому что некоторые читатели считают это полезным. Следующая &amp;laquo; &lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt; &amp;raquo; - это альтернативная синтаксическая диаграмма, которая выражает тот же синтаксис, но пытается разбить синтаксис на более мелкие части.</target>
        </trans-unit>
        <trans-unit id="9f631ef63bea49256ea8a2d7bafc4554c3faedfb" translate="yes" xml:space="preserve">
          <source>The &quot;Application ID&quot; set by &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;.</source>
          <target state="translated">&amp;laquo;Идентификатор приложения&amp;raquo;, установленный &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f5d1070df133cbc828d184fa205995550d45fd" translate="yes" xml:space="preserve">
          <source>The &quot;CREATE TABLE&quot; command is used to create a new table in an SQLite database. A CREATE TABLE command specifies the following attributes of the new table:</source>
          <target state="translated">Команда &quot;CREATE TABLE&quot; используется для создания новой таблицы в БД SQLite.Команда &quot;CREATE TABLE&quot; задает следующие атрибуты новой таблицы:</target>
        </trans-unit>
        <trans-unit id="07114418ccb01065c3be30aab50b4df2c4bf363e" translate="yes" xml:space="preserve">
          <source>The &quot;GENERATED ALWAYS&quot; keywords at the beginning of the constraint and the &quot;VIRTUAL&quot; or &quot;STORED&quot; keyword at the end are all optional. Only the &quot;AS&quot; keyword and the parenthesized expression are required. If the trailing &quot;VIRTUAL&quot; or &quot;STORED&quot; keyword is omitted, then VIRTUAL is the default. Hence, the example statement above could be simplified to just:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5736b1f20cbfd4541c75d144c2bb263b3a789707" translate="yes" xml:space="preserve">
          <source>The &quot;INDEXED BY index-name&quot; phrase specifies that the named index must be used in order to look up values on the preceding table. If index-name does not exist or cannot be used for the query, then the preparation of the SQL statement fails. The &quot;NOT INDEXED&quot; clause specifies that no index shall be used when accessing the preceding table, including implied indices create by UNIQUE and PRIMARY KEY constraints. However, the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; can still be used to look up entries even when &quot;NOT INDEXED&quot; is specified.</source>
          <target state="translated">Фраза &amp;laquo;INDEXED BY index-name&amp;raquo; указывает, что именованный индекс должен использоваться для поиска значений в предыдущей таблице. Если имя-индекса не существует или не может использоваться для запроса, подготовка оператора SQL завершается неудачей. Предложение &amp;laquo;NOT INDEXED&amp;raquo; указывает, что никакой индекс не должен использоваться при доступе к предыдущей таблице, включая подразумеваемые индексы, созданные ограничениями UNIQUE и PRIMARY KEY. Тем не менее, &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; все еще может использоваться для поиска записей, даже если указано &quot;NOT INDEXED&quot;.</target>
        </trans-unit>
        <trans-unit id="21fa27bc6e581b8fb060c98b51ebafd394898e71" translate="yes" xml:space="preserve">
          <source>The &quot;INSERT INTO</source>
          <target state="translated">&quot;INSERT INTO</target>
        </trans-unit>
        <trans-unit id="3c67e89c578626f4a5845690f5e802d46290edfe" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY 2&quot; (which means the same as &quot;ORDER BY under_alice.level+1&quot;) causes higher levels in the organization chart (with smaller &quot;level&quot; values) to be processed first, resulting in a breadth-first search. The output is:</source>
          <target state="translated">ЗАКАЗАНИЕ BY 2&quot; (что означает то же самое,что и &quot;ЗАКАЗАНИЕ BY under_alice.level+1&quot;)приводит к тому,что более высокие уровни на графике организации (с меньшими значениями &quot;уровня&quot;)обрабатываются в первую очередь,что приводит к первому поиску по широте.Результатом является:</target>
        </trans-unit>
        <trans-unit id="f957a1348139bb0e4f79cd1d2fbd5306c674fbde" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY checkin.mtime DESC&quot; term in the recursive-select makes the query run much faster by preventing it from following branches that merge checkins from long ago. The ORDER BY forces the recursive-select to focus on the most recent checkins, the ones we want. Without the ORDER BY on the recursive-select, one would be forced to compute the complete set of thousands of ancestors, sort them all by mtime, then take the top twenty. The ORDER BY essentially sets up a priority queue that forces the recursive query to look at the most recent ancestors first, allowing the use of a LIMIT clause to restrict the scope of the query to just the checkins of interest.</source>
          <target state="translated">Термин &quot;ORDER BY checkin.mtime DESC&quot; в рекурсивном выборе делает запрос намного быстрее,не позволяя ему следовать за ветвями,которые давно сливают проверки.ЗАКАЗАНИЕ BY заставляет рекурсивный выбор сфокусироваться на самых последних проверках,тех,которые нам нужны.Без &quot;ЗАКАЗАНИЯ BY&quot; на рекурсивном выборе можно было бы вычислить полный набор из тысяч предков,отсортировать их все по mtime,а затем взять верхнюю двадцатку.По сути,ORDER BY устанавливает очередь приоритетов,которая заставляет рекурсивный запрос сначала посмотреть на самые последние предки,позволяя использовать выражение LIMIT,чтобы ограничить область запроса только интересующими нас проверками.</target>
        </trans-unit>
        <trans-unit id="05aec33569483f3dc1a8463df38060dbf53e2c35" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA cache_spill=</source>
          <target state="translated">PRAGMA cache_spill=</target>
        </trans-unit>
        <trans-unit id="1a0a062742c0bea5342163f23635fff0e75751fe" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; command provides an indication that the database file has been modified. Interactive programs that hold database content in memory or that display database content on-screen can use the PRAGMA data_version command to determine if they need to flush and reload their memory or update the screen display.</source>
          <target state="translated">Команда &quot;PRAGMA data_version&quot; указывает на то,что файл БД был изменен.Интерактивные программы,хранящие содержимое БД в памяти или отображающие содержимое БД на экране,могут с помощью команды &quot;PRAGMA data_version&quot; определить,нужно ли им промыть и перезагрузить свою память или обновить отображение экрана.</target>
        </trans-unit>
        <trans-unit id="51c212d19062433a8ddb99b497e81dcefb5db939" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; value is a local property of each database connection and so values returned by two concurrent invocations of &quot;PRAGMA data_version&quot; on separate database connections are often different even though the underlying database is identical. It is only meaningful to compare the &quot;PRAGMA data_version&quot; values returned by the same database connection at two different points in time.</source>
          <target state="translated">Значение &quot;PRAGMA data_version&quot; является локальным свойством каждого соединения БД и поэтому значения,возвращаемые двумя одновременными вызовами &quot;PRAGMA data_version&quot; на отдельных соединениях БД,часто различаются,даже если базовая БД идентична.Сравнивать значения &quot;PRAGMA data_version&quot;,возвращаемые одним и тем же подключением к БД,имеет смысл только в два разных момента времени.</target>
        </trans-unit>
        <trans-unit id="03965d42503dca17ab62ff9cad1d8a5c3c8ffdbb" translate="yes" xml:space="preserve">
          <source>The &quot;Page Count&quot; - The number of pages in the next segment of the journal, or -1 to mean all content to the end of the file</source>
          <target state="translated">Количество страниц&quot;-количество страниц в следующем сегменте журнала,или -1 для обозначения всего содержимого до конца файла.</target>
        </trans-unit>
        <trans-unit id="48c6586de090c3bc2e13cc3b6a2a69ed36fa59fa" translate="yes" xml:space="preserve">
          <source>The &quot;USING TEMP B-TREE&quot; clause in the above output indicates that a temporary b-tree structure is used to implement the UNION of the results of the two sub-selects. An alternative method of computing a compound is to run each subquery as a co-routine, arrange for their outputs to appear in sorted order, and merge the results together. When the query planner chooses this latter approach, the EXPLAIN QUERY PLAN output looks like this:</source>
          <target state="translated">Пункт &quot;ИСПОЛЬЗОВАНИЕ ТЕМПЫ B-TREE&quot; в вышеуказанном выводе указывает на то,что временная структура b-дерева используется для реализации UNION результатов двух подвыборов.Альтернативный метод вычисления соединения состоит в том,чтобы выполнить каждый подзапрос как со-результат,расположить их выходы в отсортированном порядке и объединить результаты вместе.Когда планировщик запроса выбирает последний подход,выход EXPLAIN QUERY PLAN выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a9bff9645401cb328b5613b5233bf3e5ba1e2eb1" translate="yes" xml:space="preserve">
          <source>The &quot;alternate-form-2&quot; flag (&quot;!&quot;) on the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; implementation now causes string substitutions to measure the width and precision in characters instead of bytes.</source>
          <target state="translated">Флаг &amp;laquo;альтернативная форма-2&amp;raquo; (&amp;laquo;!&amp;raquo;) Во &lt;a href=&quot;printf&quot;&gt;встроенной&lt;/a&gt; реализации printf теперь вызывает подстановку строк для измерения ширины и точности в символах, а не в байтах.</target>
        </trans-unit>
        <trans-unit id="e4319cae606348ce23e782f966b47ff645421643" translate="yes" xml:space="preserve">
          <source>The &quot;atom&quot; column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The &quot;atom&quot; column is NULL for a JSON array or object. The &quot;value&quot; column is the same as the &quot;atom&quot; column for primitive JSON elements but takes on the text JSON value for arrays and objects.</source>
          <target state="translated">Столбец &quot;атом&quot;-это SQL-значение,соответствующее примитивным элементам-элементам,отличным от JSON-массивов и объектов.Столбец &quot;атом&quot;-NULL для JSON-массива или объекта.Столбец &quot;значение&quot; аналогичен столбцу &quot;атом&quot; для примитивных JSON-элементов,но принимает текстовое JSON-значение для массивов и объектов.</target>
        </trans-unit>
        <trans-unit id="cb8a5773e6c48280d7fe42741f8b4a093d392533" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method</source>
          <target state="translated">Метод &quot;авторизатора&quot;</target>
        </trans-unit>
        <trans-unit id="d2039edadf3792f44d9f55f1e52e41e045647126" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method provides access to the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C/C++ interface. The argument to authorizer is the name of a procedure that is called when SQL statements are being compiled in order to authorize certain operations. The callback procedure takes 5 arguments which describe the operation being coded. If the callback returns the text string &quot;SQLITE_OK&quot;, then the operation is allowed. If it returns &quot;SQLITE_IGNORE&quot;, then the operation is silently disabled. If the return is &quot;SQLITE_DENY&quot; then the compilation fails with an error.</source>
          <target state="translated">Метод &amp;laquo;authorizer&amp;raquo; обеспечивает доступ к интерфейсу &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C / C ++. Аргумент авторизатора - это имя процедуры, которая вызывается при компиляции операторов SQL для авторизации определенных операций. Процедура обратного вызова принимает 5 аргументов, которые описывают кодируемую операцию. Если обратный вызов возвращает текстовую строку &amp;laquo;SQLITE_OK&amp;raquo;, то операция разрешена. Если он возвращает &amp;laquo;SQLITE_IGNORE&amp;raquo;, то операция автоматически отключается. Если возвращается &quot;SQLITE_DENY&quot;, компиляция завершается ошибкой.</target>
        </trans-unit>
        <trans-unit id="d780e49acdf2e828a0e7b0580dfd96aff50cee2e" translate="yes" xml:space="preserve">
          <source>The &quot;automerge=N&quot; command (where N is an integer between 0 and 15, inclusive) is used to configure an FTS3/4 tables &quot;automerge&quot; parameter, which controls automatic incremental inverted index merging. The default automerge value for new tables is 0, meaning that automatic incremental merging is completely disabled. If the value of the automerge parameter is modified using the &quot;automerge=N&quot; command, the new parameter value is stored persistently in the database and is used by all subsequently established database connections.</source>
          <target state="translated">Команда &quot;automerge=N&quot; (где N-целое число между 0 и 15 включительно)используется для настройки параметра &quot;automerge&quot; таблиц FTS3/4,который управляет автоматическим слиянием инкрементных инвертированных индексов.Значение automerge по умолчанию для новых таблиц равно 0,что означает,что автоматическое инкрементальное слияние полностью отключено.Если значение параметра automerge изменяется командой &quot;automerge=N&quot;,то новое значение параметра постоянно сохраняется в БД и используется всеми последующими соединениями БД.</target>
        </trans-unit>
        <trans-unit id="35cc018cff76ce7093039d6d69782515b8dd9cbd" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method</source>
          <target state="translated">Метод &quot;резервного копирования&quot;</target>
        </trans-unit>
        <trans-unit id="c005edd2de62803b18a4eb1743378927a517fad5" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method makes a backup copy of a live database. The command syntax is like this:</source>
          <target state="translated">Метод &quot;резервного копирования&quot; делает резервную копию живой базы данных.Синтаксис команды такой:</target>
        </trans-unit>
        <trans-unit id="7652bc7646799c25c956b30319f71b75ca9a3e80" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method</source>
          <target state="translated">Метод &quot;bind_fallback&quot;.</target>
        </trans-unit>
        <trans-unit id="e31d9979cf6770ea07cdb2b87a23b0343179e30e" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method gives the application control over how to handle parameter binding when no TCL variable matches the parameter name.</source>
          <target state="translated">Метод &quot;bind_fallback&quot; дает программе контроль над тем,как работать с привязкой параметров,когда ни одна переменная TCL не совпадает с именем параметра.</target>
        </trans-unit>
        <trans-unit id="d6fd78a195f0dd5acebc1e5d408aa889656042c4" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method has a single optional argument. If the argument is an empty string, then the bind_fallback is cancelled and the default behavior is restored. If the argument is a non-empty string, then the argument is a TCL command (usually the name of a proc) to invoke whenever an SQL parameter is seen that does not match any TCL variable. If the &quot;bind_fallback&quot; method is given no arguments, then the current bind_fallback command is returned.</source>
          <target state="translated">Метод &quot;bind_fallback&quot; имеет один необязательный аргумент.Если аргумент является пустой строкой,то bind_fallback отменяется и поведение по умолчанию восстанавливается.Если аргумент-непустая строка,то это команда TCL (обычно имя proc)для вызова всякий раз,когда видим параметр SQL,который не соответствует ни одной переменной TCL.Если метод &quot;bind_fallback&quot; не имеет аргументов,то возвращается текущая команда bind_fallback.</target>
        </trans-unit>
        <trans-unit id="50a08084b4de7b3f67549ffe53d83ec728fa3cca" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method</source>
          <target state="translated">&quot;занятой&quot; метод</target>
        </trans-unit>
        <trans-unit id="94cabb870539d2659c509ca5d30b8de78ce6a143" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method, like &quot;timeout&quot;, only comes into play when the database is locked. But the &quot;busy&quot; method gives the programmer much more control over what action to take. The &quot;busy&quot; method specifies a callback Tcl procedure that is invoked whenever SQLite tries to open a locked database. A single integer argument is appended to the callback before it is invoke. The argument is the number of prior calls to the busy callback for the current locking event. It is intended that the callback will do some other useful work for a short while (such as service GUI events) then return so that the lock can be tried again. The callback procedure should return &quot;0&quot; if it wants SQLite to try again to open the database and should return &quot;1&quot; if it wants SQLite to abandon the current operation.</source>
          <target state="translated">Метод &quot;занят&quot;,как и &quot;тайм-аут&quot;,вступает в игру только тогда,когда база данных заблокирована.Но метод &quot;занято&quot; дает программисту гораздо больше контроля над тем,какие действия нужно предпринять.Метод &quot;занят&quot; определяет процедуру обратного вызова Tcl,которая вызывается всякий раз,когда SQLite пытается открыть заблокированную БД.Один целочисленный аргумент добавляется к обратному вызову перед его вызовом.Аргумент представляет собой количество предыдущих вызовов обратного вызова &quot;занято&quot; для текущего события блокировки.Он предназначен для того,чтобы обратный вызов выполнял некоторую другую полезную работу некоторое время (например,события GUI службы),а затем возвращался,чтобы блокировку можно было попробовать еще раз.Процедура обратного вызова должна возвращать &quot;0&quot;,если она хочет,чтобы SQLite попытался снова открыть базу данных,и должна возвращать &quot;1&quot;,если она хочет,чтобы SQLite отказался от текущей операции.</target>
        </trans-unit>
        <trans-unit id="806dbf019d18a933c45ea06755b6a277743f61ae" translate="yes" xml:space="preserve">
          <source>The &quot;cache&quot; method</source>
          <target state="translated">Метод &quot;кэширования&quot;</target>
        </trans-unit>
        <trans-unit id="6c5d5ba4e30c1f02fb732b5f9e013dee90e5777d" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method</source>
          <target state="translated">Метод &quot;изменений&quot;</target>
        </trans-unit>
        <trans-unit id="94441f79eee4930e4324a3b4a4acbce248260c58" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified by the most recent &quot;eval&quot; method.</source>
          <target state="translated">Метод &quot;изменений&quot; возвращает целое число,которое представляет собой количество строк в БД,которые были вставлены,удалены и/или изменены последним методом &quot;eval&quot;.</target>
        </trans-unit>
        <trans-unit id="b6c35aac78db7a1383140bebe49b233115675bec" translate="yes" xml:space="preserve">
          <source>The &quot;checksum_verification&quot; pragma will always respond with &quot;0&quot; if the database file does not have a &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of 8. The pragma will return no rows at all if the cksumvfs extension is not loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1066b4da2db6b6f62f1cb1a75e51624adbe905f6" translate="yes" xml:space="preserve">
          <source>The &quot;checksum_verification&quot; pragma will return &quot;1&quot; (true) or &quot;0&quot; (false) if checksum verification is enabled or disabled, respectively. &quot;Verification&quot; in this context means the feature that causes SQLITE_IOERR_DATA errors if a checksum mismatch is detected while reading. Checksums are always kept up-to-date as long as the &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of the database is 8, regardless of the setting of this pragma. Checksum verification can be disabled (for example) to do forensic analysis of a database that has previously reported a checksum error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3fc353d826f676e72487db0fd8f37052f9b16c1" translate="yes" xml:space="preserve">
          <source>The &quot;close&quot; method</source>
          <target state="translated">Метод &quot;закрыть&quot;</target>
        </trans-unit>
        <trans-unit id="b78db738260018e26bc56c431d7e164adb66bba3" translate="yes" xml:space="preserve">
          <source>The &quot;collate&quot; method</source>
          <target state="translated">Метод &quot;сопоставления&quot;</target>
        </trans-unit>
        <trans-unit id="3be1a86e589629a9a881a6da512b2ad6b5f62c78" translate="yes" xml:space="preserve">
          <source>The &quot;collation_needed&quot; method</source>
          <target state="translated">Метод &quot;collation_needed&quot;.</target>
        </trans-unit>
        <trans-unit id="b61e2a7799abe39106586491c34d057a3c163117" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; mode is a tabular output format. Other tabular output formats are &quot;box&quot;, &quot;markdown&quot;, and &quot;table&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c32eeacd0b85ddcdef7035930e1a8c64bfad10b" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; mode is a tabular output format. Other tabular output formats as &quot;box&quot;, &quot;markdown&quot;, and &quot;table&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1035634e0e0ea333e6f8d753c7fa7091a7d755db" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; output mode automatically expands columns to contain the longest output row and automatically turns &quot;.header&quot; on if it has not been previously set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f6089837a9332235ef1f677d9e2936edf51cae" translate="yes" xml:space="preserve">
          <source>The &quot;columns&quot; of a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery are really the expressions in the result set of the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements the VIEW or subquery. Thus, the affinity for columns of a VIEW or subquery are determined by the expression affinity rules above. Consider an example:</source>
          <target state="translated">&amp;laquo;Столбцы&amp;raquo; подзапроса &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; или FROM-clause на самом деле являются выражениями в результирующем наборе &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT&lt;/a&gt; , реализующего VIEW или подзапрос. Таким образом, сродство столбцов в представлении или подзапросе определяется правилами сродства выражений, приведенными выше. Рассмотрим пример:</target>
        </trans-unit>
        <trans-unit id="6efc033d7171b4cae5dcc026d731d1abc23f16f8" translate="yes" xml:space="preserve">
          <source>The &quot;commit_hook&quot; method</source>
          <target state="translated">Метод &quot;commit_hook&quot;</target>
        </trans-unit>
        <trans-unit id="075f9fcec0c51906d7830312bd2ffff7ac323743" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method</source>
          <target state="translated">&quot;Полный&quot; метод</target>
        </trans-unit>
        <trans-unit id="36202288005d888ee9c02c9332ba422aac36a5b3" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method is useful when building interactive applications in order to know when the user has finished entering a line of SQL code. This is really just an interface to the &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete()&lt;/b&gt;&lt;/a&gt; C function.</source>
          <target state="translated">Метод &amp;laquo;complete&amp;raquo; полезен при создании интерактивных приложений, чтобы узнать, когда пользователь закончил ввод строки кода SQL. На самом деле это просто интерфейс для &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;функции&lt;/b&gt;&lt;/a&gt; C. &lt;b&gt;sqlite3_complete ()&lt;/b&gt; C.</target>
        </trans-unit>
        <trans-unit id="cb6d6b519cc240799d0eae2497f1b956b7749126" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method takes a string of supposed SQL as its only argument. It returns TRUE if the string is a complete statement of SQL and FALSE if there is more to be entered.</source>
          <target state="translated">Полный&quot; метод принимает строку предполагаемого SQL в качестве единственного аргумента.Он возвращает TRUE,если строка является полным оператором SQL и FALSE,если нужно ввести больше.</target>
        </trans-unit>
        <trans-unit id="46bbc7a4eaf4d4f9fe40b357ef388a365c9285df" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method</source>
          <target state="translated">Метод &quot;config&quot;</target>
        </trans-unit>
        <trans-unit id="d8bb4ff8aef62d6cb6272264cef7cda239984bc9" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method queries or changes certain configuration settings for the database connection using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface. Run this method with no arguments to get a TCL list of available configuration settings and their current values:</source>
          <target state="translated">Метод &amp;laquo;config&amp;raquo; запрашивает или изменяет определенные параметры конфигурации для подключения к базе данных с помощью интерфейса &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; . Запустите этот метод без аргументов, чтобы получить список TCL доступных параметров конфигурации и их текущих значений:</target>
        </trans-unit>
        <trans-unit id="b266e6a044670a6e3a5e4102b0820031cb7ab393" translate="yes" xml:space="preserve">
          <source>The &quot;configure&quot; scripts should now automatically configure Unix systems for large file support. Improved error messages for when large files are encountered and large file support is disabled.</source>
          <target state="translated">Скрипты &quot;configure&quot; теперь должны автоматически настраивать Unix-системы для поддержки больших файлов.Улучшены сообщения об ошибках при работе с большими файлами и отключена поддержка больших файлов.</target>
        </trans-unit>
        <trans-unit id="577865d2c9835070772d4e94f47615cadfb2baec" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">Переменная &quot;const char *&quot;, на которую указывает параметр T, будет установлена ​​в строку UTF-8 с завершающим нулем, содержащую описание &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; для X-го цикла.</target>
        </trans-unit>
        <trans-unit id="2be51d012e0d49a380524a8121847e82af3226bf" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">Переменная &quot;const char *&quot;, на которую указывает параметр T, будет установлена ​​в строку UTF-8 с завершающим нулем, содержащую описание &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; для X-го цикла.</target>
        </trans-unit>
        <trans-unit id="bac7414b87b280f152adca2a25c602ba20600788" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">Переменная &quot;const char *&quot;,на которую указывает параметр T,будет установлена в нулевую строку UTF-8,содержащую имя индекса или таблицы,используемой в X-ом цикле.</target>
        </trans-unit>
        <trans-unit id="220e93adf7fc69205c340c5757886c63862916b5" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb2cfe6186a4a9c1039f7ec3e694a12e936a2d7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6993ddaa2434f289adeb086aed7ae04476a60ad7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aae3497dac443e109983b1c00a5960530139406" translate="yes" xml:space="preserve">
          <source>The &quot;content&quot; option, used to make the FTS5 table an &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;external content or contentless table&lt;/a&gt;.</source>
          <target state="translated">Параметр &amp;laquo;контент&amp;raquo;, используемый для превращения таблицы FTS5 в таблицу с &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;внешним контентом или без контента&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c79f409b23d48e87e77e61ee87998224597bc3" translate="yes" xml:space="preserve">
          <source>The &quot;content_rowid&quot; option, used to set the rowid field of an &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content table&lt;/a&gt;.</source>
          <target state="translated">Параметр content_rowid, используемый для установки поля rowid &lt;a href=&quot;fts5#external_content_tables&quot;&gt;внешней таблицы содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39cd9c81e20b57d6b78e1af2643005b4d6ac3fb3" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method</source>
          <target state="translated">Метод &quot;копирования&quot;</target>
        </trans-unit>
        <trans-unit id="983ea0fee26b9222536bfed9a0514ad997e9a0a2" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method copies data from a file into a table. It returns the number of rows processed successfully from the file. The syntax of the copy method looks like this:</source>
          <target state="translated">Метод &quot;копирования&quot; копирует данные из файла в таблицу.Он возвращает количество успешно обработанных строк из файла.Синтаксис метода копирования выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="dc3e7bd12c41305b3fc796bf145f478af20ae557" translate="yes" xml:space="preserve">
          <source>The &quot;cost&quot; here is logarithmic. With nested loops, the work is multiplied, not added. But it is customary to think of graphs with additive weights and so the graph shows the logarithm of the various costs. The graph shows a cost advantage of S being inside of L of about 6.87, but this translates into the query running about 963 times faster when S loop is inside of the L loop rather than being outside of it.</source>
          <target state="translated">Здесь &quot;стоимость&quot; логарифмическая.При вложенных циклах работа умножается,а не прибавляется.Но принято думать о графиках с аддитивными весами,поэтому график показывает логарифм различных затрат.На графике показано преимущество по стоимости того,что S находится внутри L примерно в 6.87,но это транслируется в запрос,выполняемый примерно в 963 раза быстрее,когда цикл S находится внутри цикла L,а не вне его.</target>
        </trans-unit>
        <trans-unit id="350bdd92630f61bca90b3168c90039a63f7ced5e" translate="yes" xml:space="preserve">
          <source>The &quot;csv&quot; mode option in the shell puts strings inside double-quotes.</source>
          <target state="translated">Опция режима &quot;csv&quot; в оболочке помещает строки внутри двойных кавычек.</target>
        </trans-unit>
        <trans-unit id="1f521a5c994d919d955260e93be15342970bdf26" translate="yes" xml:space="preserve">
          <source>The &quot;db&quot; parameter is a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The &quot;main&quot; argument is the name of the schema in which the imposter table is to be created. The &quot;1&quot; argument enables the imposter table mechanism. &quot;tnum&quot; is the root page of the index that the imposter table should mirror.</source>
          <target state="translated">Параметр &amp;laquo;db&amp;raquo; - это указатель на &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных . &amp;laquo;Главный&amp;raquo; аргумент - это имя схемы, в которой должна быть создана таблица самозванца. Аргумент &amp;laquo;1&amp;raquo; включает механизм таблицы самозванца. &amp;laquo;tnum&amp;raquo; - это корневая страница индекса, которую должна отражать таблица самозванца.</target>
        </trans-unit>
        <trans-unit id="1d7867d45fc6532563a6e0e1052f994086d7d4d3" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method</source>
          <target state="translated">Метод &quot;десериализации&quot;</target>
        </trans-unit>
        <trans-unit id="6f372f07e9e348fc01623f3016d82e06dd84212c" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method takes a TCL byte-array that contains an SQLite database file and adds it to the database connection. The syntax is:</source>
          <target state="translated">Метод &quot;десериализации&quot; берет байт-массив TCL,содержащий файл базы данных SQLite,и добавляет его в соединение с БД.Синтаксис таков:</target>
        </trans-unit>
        <trans-unit id="37b478850c0ef98b47e5a07304d319496a735ccd" translate="yes" xml:space="preserve">
          <source>The &quot;docid&quot; alias does not exist. Applications must use &quot;rowid&quot; instead.</source>
          <target state="translated">Псевдоним &quot;доцид&quot; не существует.Приложения должны использовать &quot;rowid&quot;.</target>
        </trans-unit>
        <trans-unit id="13cca21a87502057869d942479f833e57c886177" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the T parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">Двойная&quot; переменная,на которую указывает параметр T,будет установлена в оценку планировщика запросов для среднего количества строк,выводимых при каждой итерации X-го цикла.Если оценки планировщика запросов были точными,то это значение будет аппроксимировать коэффициент NVISIT/NLOOP,и произведением этого значения для всех предыдущих циклов с одинаковым SELECTID будет значение NLOOP для текущего цикла.</target>
        </trans-unit>
        <trans-unit id="ac86dc9fb240d8b577961e6fb339b312a7e8b6d2" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the V parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b47ab7441632c19a646d6f3d2e70bb71a8af6b" translate="yes" xml:space="preserve">
          <source>The &quot;ellipses&quot; text.</source>
          <target state="translated">Текст &quot;эллипсов&quot;.</target>
        </trans-unit>
        <trans-unit id="785dfb0eb14780fdc8609d7c7187bbcbf0dfe81b" translate="yes" xml:space="preserve">
          <source>The &quot;enable_load_extension&quot; method</source>
          <target state="translated">Метод &quot;enable_load_extension&quot;.</target>
        </trans-unit>
        <trans-unit id="24181470839fe75a380a1959898a8b67107aab1a" translate="yes" xml:space="preserve">
          <source>The &quot;end match&quot; text.</source>
          <target state="translated">Текст &quot;конечное совпадение&quot;.</target>
        </trans-unit>
        <trans-unit id="a4952b422a3c809d77afa1776609a2750c092857" translate="yes" xml:space="preserve">
          <source>The &quot;errorcode&quot; method</source>
          <target state="translated">Метод &quot;код ошибки&quot;</target>
        </trans-unit>
        <trans-unit id="79f7c0ddb2f3a3e97f9983c467d9c601808c789a" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method</source>
          <target state="translated">Метод &quot;оценки&quot;</target>
        </trans-unit>
        <trans-unit id="da370283ad69c2823d6201a69b7d1765374cb685" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method described &lt;a href=&quot;#eval&quot;&gt;above&lt;/a&gt; keeps a cache of &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared statements&lt;/a&gt; for recently evaluated SQL commands. The &quot;cache&quot; method is used to control this cache. The first form of this command is:</source>
          <target state="translated">Описанный &lt;a href=&quot;#eval&quot;&gt;выше&lt;/a&gt; метод eval сохраняет кэш &lt;a href=&quot;c3ref/prepare&quot;&gt;подготовленных операторов&lt;/a&gt; для недавно оцененных команд SQL. Для управления этим кешем используется метод &quot;cache&quot;. Первая форма этой команды:</target>
        </trans-unit>
        <trans-unit id="221bab33d21ea69f4dd52f3f0492767cb572de7f" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method</source>
          <target state="translated">Метод &quot;существует&quot;</target>
        </trans-unit>
        <trans-unit id="efdfc3e12d096d22035e667cf9f9a8fa50dec02d" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is often used to test for the existence of rows in a table. For example:</source>
          <target state="translated">Метод &quot;существует&quot; часто используется для проверки существования строк в таблице.Например:</target>
        </trans-unit>
        <trans-unit id="64883f01f5bafd4c69a4447377f37fc6c44868cb" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is similar to &quot;onecolumn&quot; and &quot;eval&quot; in that it executes SQL statements. The difference is that the &quot;exists&quot; method always returns a boolean value which is TRUE if a query in the SQL statement it executes returns one or more rows and FALSE if the SQL returns an empty set.</source>
          <target state="translated">Метод &quot;существует&quot; аналогичен методу &quot;onecolumn&quot; и &quot;eval&quot; в том,что он выполняет SQL-операторы.Разница заключается в том,что метод &quot;существует&quot; всегда возвращает булевое значение,которое равно TRUE,если запрос в SQL-операторе,который он выполняет,возвращает одну или несколько строк,и FALSE,если SQL возвращает пустой набор.</target>
        </trans-unit>
        <trans-unit id="2fa39980ca4c6c390fc0963b907ef032a2115a04" translate="yes" xml:space="preserve">
          <source>The &quot;family&quot; table is similar to the earlier &quot;org&quot; table except that now there are two parents to each member. We want to know all living ancestors of Alice, from oldest to youngest. An ordinary common table expression, &quot;parent_of&quot;, is defined first. That ordinary CTE is a view that can be used to find all parents of any individual. That ordinary CTE is then used in the &quot;ancestor_of_alice&quot; recursive CTE. The recursive CTE is then used in the final query:</source>
          <target state="translated">Таблица &quot;семьи&quot; похожа на предыдущую таблицу &quot;орг&quot;,за исключением того,что теперь у каждого члена семьи по два родителя.Мы хотим знать всех живых предков Алисы,от самых старших до самых младших.Сначала определяется обычное общее выражение таблицы-&quot;parent_of&quot;.Это обычное CTE-представление,которое может быть использовано для поиска всех родителей любого индивидуума.Этот обычный CTE затем используется в рекурсивном CTE &quot;ancestor_of_alice&quot;.Затем в финальном запросе используется рекурсивный CTE:</target>
        </trans-unit>
        <trans-unit id="e0decf38085a4ffc55fce2f25b175fd346628c61" translate="yes" xml:space="preserve">
          <source>The &quot;fast&quot; setting for secure_delete (added circa 2017-08-01) is an intermediate setting in between &quot;on&quot; and &quot;off&quot;. When secure_delete is set to &quot;fast&quot;, SQLite will overwrite deleted content with zeros only if doing so does not increase the amount of I/O. In other words, the &quot;fast&quot; setting uses more CPU cycles but does not use more I/O. This has the effect of purging all old content from &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree pages&lt;/a&gt;, but leaving forensic traces on &lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist pages&lt;/a&gt;.</source>
          <target state="translated">Настройка &amp;laquo;fast&amp;raquo; для secure_delete (добавлена ​​около 2017-08-01) является промежуточной настройкой между &amp;laquo;on&amp;raquo; и &amp;laquo;off&amp;raquo;. Когда для secure_delete установлено значение &amp;laquo;fast&amp;raquo;, SQLite перезапишет удаленный контент нулями только в том случае, если это не приведет к увеличению количества операций ввода-вывода. Другими словами, установка &amp;laquo;быстро&amp;raquo; использует больше циклов ЦП, но не использует больше операций ввода-вывода. Это приводит к удалению всего старого контента со &lt;a href=&quot;fileformat2#btree&quot;&gt;страниц b-tree&lt;/a&gt; , но оставляет следы судебной экспертизы на &lt;a href=&quot;fileformat2#freelist&quot;&gt;страницах freelist&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5e5534bc0599c1bf3dbead2d2f44bed70807ce6" translate="yes" xml:space="preserve">
          <source>The &quot;fsync()&quot; that occurs after the header is written in a WAL reset now uses the sync settings for checkpoints. This means it will use a &quot;fullfsync&quot; on macs if &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt; set on.</source>
          <target state="translated">Функция &amp;laquo;fsync ()&amp;raquo;, возникающая после записи заголовка при сбросе WAL, теперь использует настройки синхронизации для контрольных точек. Это означает, что он будет использовать &amp;laquo;fullfsync&amp;raquo; на &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;Mac,&lt;/a&gt; если PRAGMA checkpoint_fullfsync включен .</target>
        </trans-unit>
        <trans-unit id="80417a09b17dfee14228d5c4ecb3ba63e1360a53" translate="yes" xml:space="preserve">
          <source>The &quot;fts3tokenize&quot; virtual table can be used to directly access any tokenizer. The following SQL demonstrates how to create an instance of the fts3tokenize virtual table:</source>
          <target state="translated">Виртуальная таблица &quot;fts3tokenize&quot; может быть использована для прямого доступа к любому токенайзеру.Следующий SQL демонстрирует,как создать экземпляр виртуальной таблицы fts3tokenize:</target>
        </trans-unit>
        <trans-unit id="6cdf37fe2751376d1b848056d4ec78cc31cd8173" translate="yes" xml:space="preserve">
          <source>The &quot;fullkey&quot; column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the &quot;root&quot; argument.</source>
          <target state="translated">Столбец &quot;fullkey&quot;-это текстовый путь,который уникальным образом идентифицирует текущий элемент строки внутри исходной JSON-строки.Полный ключ к истинному элементу верхнего уровня возвращается,даже если альтернативная отправная точка задана аргументом &quot;root&quot;.</target>
        </trans-unit>
        <trans-unit id="81485590afed062476035ea78c2df833a07ce15c" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method</source>
          <target state="translated">Метод &quot;функции&quot;</target>
        </trans-unit>
        <trans-unit id="982021b0dd51770755c9c9e39c1c765e77fbdd84" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method accepts the following options:</source>
          <target state="translated">Метод &quot;функции&quot; принимает следующие варианты:</target>
        </trans-unit>
        <trans-unit id="e581fe2aa68e5275a553b3adbf390b762a9e4053" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method registers new SQL functions with the SQLite engine. The arguments are the name of the new SQL function and a TCL command that implements that function. Arguments to the function are appended to the TCL command before it is invoked.</source>
          <target state="translated">Метод &quot;функции&quot; регистрирует новые функции SQL в движке SQLite.Аргументами являются имя новой функции SQL и команда TCL,реализующая эту функцию.Аргументы функции добавляются к команде TCL перед ее вызовом.</target>
        </trans-unit>
        <trans-unit id="ff9f7422b3d2ef0edf475eeb60798d293ddec7bd" translate="yes" xml:space="preserve">
          <source>The &quot;fuzzershell.c&quot; program is used to run some &lt;a href=&quot;#fuzztesting&quot;&gt;fuzz tests&lt;/a&gt;.</source>
          <target state="translated">Программа fuzzershell.c используется для запуска некоторых &lt;a href=&quot;#fuzztesting&quot;&gt;тестов&lt;/a&gt; фаззинга .</target>
        </trans-unit>
        <trans-unit id="7c4947473658b4ae028d7e71df03314bb5d6e009" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">Параметр &amp;laquo;iScanStatusOp&amp;raquo; определяет, какую информацию о статусе нужно вернуть. &amp;laquo;IScanStatusOp&amp;raquo; должен быть одной из &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;опций scanstatus,&lt;/a&gt; иначе поведение этого интерфейса не определено. Запрошенное измерение записывается в переменную, на которую указывает параметр &amp;laquo;pOut&amp;raquo;. Параметр &amp;laquo;idx&amp;raquo; определяет конкретный цикл, для которого требуется получить статистику. Циклы нумеруются, начиная с нуля. Если idx выходит за пределы диапазона - меньше нуля или больше или равно общему количеству циклов, используемых для реализации оператора, - возвращается ненулевое значение, а переменная, на которую указывает pOut, не изменяется.</target>
        </trans-unit>
        <trans-unit id="82b3487c37966e4df98f8fc69e59c76eae09190d" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">Параметр &amp;laquo;iScanStatusOp&amp;raquo; определяет, какую информацию о статусе нужно вернуть. &amp;laquo;IScanStatusOp&amp;raquo; должен быть одной из &lt;a href=&quot;c_scanstat_est&quot;&gt;опций scanstatus,&lt;/a&gt; иначе поведение этого интерфейса не определено. Запрошенное измерение записывается в переменную, на которую указывает параметр &amp;laquo;pOut&amp;raquo;. Параметр &amp;laquo;idx&amp;raquo; определяет конкретный цикл, для которого требуется получить статистику. Циклы нумеруются, начиная с нуля. Если idx выходит за пределы диапазона - меньше нуля или больше или равно общему количеству циклов, используемых для реализации оператора, - возвращается ненулевое значение, а переменная, на которую указывает pOut, не изменяется.</target>
        </trans-unit>
        <trans-unit id="5abd56a3f33aa682cb5beed98f5ecb39cbd50edd" translate="yes" xml:space="preserve">
          <source>The &quot;id&quot; column is an integer that identifies a specific JSON element within the complete JSON string. The &quot;id&quot; integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the &quot;id&quot; column will be different for every row.</source>
          <target state="translated">Столбец &quot;id&quot;-это целое число,которое идентифицирует определенный JSON-элемент внутри полной JSON-строки.Целое &quot;id&quot; число-это внутреннее служебное число,вычисление которого может измениться в будущих релизах.Единственной гарантией является то,что столбец &quot;id&quot; будет отличаться для каждой строки.</target>
        </trans-unit>
        <trans-unit id="ca8669e4db9525865c9346904ab8bb3b3eb055a9" translate="yes" xml:space="preserve">
          <source>The &quot;incrblob&quot; method</source>
          <target state="translated">Метод &quot;инкрблоб&quot;</target>
        </trans-unit>
        <trans-unit id="8d184fd38641411539a264597b11e40c38841938" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; or staging area</source>
          <target state="translated">&quot;Индекс&quot; или инсценировочная площадка</target>
        </trans-unit>
        <trans-unit id="c6e7f631fc9ab8b7e2eecdc6301a632079a07cf7" translate="yes" xml:space="preserve">
          <source>The &quot;input&quot; CTE defines the input puzzle. The &quot;digits&quot; CTE defines a table that holds all digits between 1 and 9. The work of solving the puzzle is undertaken by the &quot;x&quot; CTE. An entry in x(s,ind) means that the 81-character string &quot;s&quot; is a valid sudoku puzzle (it has no conflicts) and that the first unknown character is at position &quot;ind&quot;, or ind==0 if all character positions are filled in. The goal, then, is to compute entries for &quot;x&quot; with an &quot;ind&quot; of 0.</source>
          <target state="translated">Входной&quot; CTE определяет входную головоломку.Цифры&quot; CTE определяют таблицу,содержащую все цифры от 1 до 9.Работа по решению головоломки выполняется по &quot;x&quot; CTE.Запись в x(s,ind)означает,что 81-символьная строка &quot;s&quot; является действительной судоку головоломкой (она не имеет конфликтов)и что первый неизвестный символ находится в позиции &quot;ind&quot;,или ind==0,если все позиции символов заполнены.Таким образом,цель состоит в том,чтобы вычислить записи для &quot;x&quot; со значением &quot;ind&quot;,равным 0.</target>
        </trans-unit>
        <trans-unit id="b6cb46f4a227f8313e332f23912dfe269a430a8c" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">Переменная &quot;int&quot;, на которую указывает параметр T, будет установлена ​​в &quot;select-id&quot; для X-го цикла. Select-id определяет, частью какого запроса или подзапроса является цикл. Основной запрос имеет нулевой идентификатор выбора. Select-id - это то же значение, которое выводится в первом столбце запроса &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd32578e68672fbb14bf7b3a04807a29e7c2c005" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">Переменная &quot;int&quot;, на которую указывает параметр T, будет установлена ​​в &quot;select-id&quot; для X-го цикла. Select-id определяет, частью какого запроса или подзапроса является цикл. Основной запрос имеет нулевой идентификатор выбора. Select-id - это то же значение, которое выводится в первом столбце запроса &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f1457987df7641bcada911e2bfe80eb91e9f5b" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b31808af87fb1ca4f0d10efd9a5ba2a54012dd" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47984da42c27787f28bd87d963296a6ecc85d38" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command causes SQLite to read and verify the accuracy of all inverted indices in an FTS3/4 table by comparing those inverted indices against the original content. The &quot;integrity-check&quot; command silently succeeds if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error if any problems are found.</source>
          <target state="translated">Команда &quot;проверка целостности&quot; заставляет SQLite считывать и проверять точность всех инвертированных индексов в таблице FTS3/4 путем сравнения этих инвертированных индексов с исходным содержимым.Команда &quot;Проверка целостности&quot; беззвучно завершает работу,если все инвертированные индексы в порядке,но при обнаружении проблем не будет работать с ошибкой SQLITE_CORRUPT.</target>
        </trans-unit>
        <trans-unit id="d1ee1009fc8d7ceb03381f3a07a84d688fe06706" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command is similar in concept to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;. In a working system, the &quot;integrity-command&quot; should always be successful. Possible causes of integrity-check failures include:</source>
          <target state="translated">Команда &amp;laquo;проверка целостности&amp;raquo; по своей концепции аналогична &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;команде PRAGMA integration_check&lt;/a&gt; . В работающей системе &amp;laquo;команда целостности&amp;raquo; всегда должна быть успешной. Возможные причины сбоев проверки целостности включают:</target>
        </trans-unit>
        <trans-unit id="9351b7e4831f50f0cddfc49da3ef44df26240c27" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method</source>
          <target state="translated">Метод &quot;прерывания&quot;</target>
        </trans-unit>
        <trans-unit id="1b5c7fcb603da939ee7df1123931389580f03242" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method invokes the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface, causing any pending queries to halt.</source>
          <target state="translated">Метод &amp;laquo;прерывание&amp;raquo; вызывает интерфейс &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; , вызывая остановку любых ожидающих запросов.</target>
        </trans-unit>
        <trans-unit id="33827ff37e59286ea63b18a3b491ccd55fa35d36" translate="yes" xml:space="preserve">
          <source>The &quot;isInit&quot; flag. 1 when the shm file has been initialized.</source>
          <target state="translated">Флаг &quot;isInit&quot;.1,когда файл shm был инициализирован.</target>
        </trans-unit>
        <trans-unit id="27d80d07107f3dd674071f8dcb5d66e927b93ae8" translate="yes" xml:space="preserve">
          <source>The &quot;isolation&quot; property of a database determines when changes made to the database by one operation become visible to other concurrent operations.</source>
          <target state="translated">Свойство &quot;изоляция&quot; БД определяет,когда изменения,внесенные в БД одной операцией,становятся видимыми для других параллельных операций.</target>
        </trans-unit>
        <trans-unit id="ca6207f3c60486460fc150891b4e2b2ff184348d" translate="yes" xml:space="preserve">
          <source>The &quot;key&quot; column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases.</source>
          <target state="translated">Столбец &quot;ключ&quot;-это целочисленный индекс массива для элементов JSON-массива и текстовая метка для элементов JSON-объекта.Столбец &quot;ключ&quot; во всех остальных случаях является NULL.</target>
        </trans-unit>
        <trans-unit id="f06bf7b5c9acc6e224eb6aebb494891b0b016a3d" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method</source>
          <target state="translated">Метод &quot;last_insert_rowid&quot;.</target>
        </trans-unit>
        <trans-unit id="b6bbfdca82da26696ded7dc7b5667ad95fba9734" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method returns an integer which is the ROWID of the most recently inserted database row.</source>
          <target state="translated">Метод &quot;last_insert_rowid&quot; возвращает целое число,которое является ROWID последней вставленной строки БД.</target>
        </trans-unit>
        <trans-unit id="7284b909bd501ff8419335375b9cbd82855b5cf7" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time string to its left is in Universal Coordinated Time (UTC) and adjusts the time string so that it displays localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the string to its left is in the local timezone and adjusts that string to be in UTC. If the prior string is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="translated">Модификатор &quot;локального времени&quot; (12)предполагает,что строка времени слева от него находится в Универсальном координированном времени (UTC),и подстраивает строку времени так,чтобы она отображала локальное время.Если &quot;локальное время&quot; следует за временем,которое не является UTC,то поведение не определено.Модификатор &quot;utc&quot; является противоположностью &quot;локального времени&quot;.&quot;utc&quot; предполагает,что строка слева от него находится в локальном часовом поясе,и подстраивает эту строку под UTC.Если предыдущая строка не находится в локальном времени,то результат &quot;utc&quot; неопределен.</target>
        </trans-unit>
        <trans-unit id="530c1a71b17edaa5c5193f0fc9e4ad1fed032d5d" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time value to its left is in Universal Coordinated Time (UTC) and adjusts that time value so that it is in localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the time value to its left is in the local timezone and adjusts that time value to be in UTC. If the time to the left is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b3080063f65f5e859c8cbf90675f21f18f1993" translate="yes" xml:space="preserve">
          <source>The &quot;lost_and_found&quot; table contains one row for each orphaned row recovered from the database. Additionally, there is one row for each recovered index entry that cannot be attributed to any SQL index. This is because, in an SQLite database, the same format is used to store SQL index entries and WITHOUT ROWID table entries.</source>
          <target state="translated">Таблица &quot;lost_and_found&quot; содержит по одной строке для каждой осиротевшей строки,восстановленной из БД.Кроме того,для каждой восстановленной записи индекса есть одна строка,которая не может быть отнесена ни к одному SQL-индексу.Это связано с тем,что в базе данных SQLite используется один и тот же формат для хранения записей индекса SQL и записей таблицы БЕЗ РОУИДА.</target>
        </trans-unit>
        <trans-unit id="9b9bb88fb1467415e1fd0ce3e886e98f2fabd9f8" translate="yes" xml:space="preserve">
          <source>The &quot;main&quot; argument to dbstat is default schema for which information is to be provided. The default is &quot;main&quot;, and so the use of &quot;main&quot; in the example above is redundant. For any particular query, the schema can be changed by specifying the alternative schema as a function argument to the virtual table name in the FROM clause of the query. (See further discussion of &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;table-valued functions in the FROM clause&lt;/a&gt; for more details.)</source>
          <target state="translated">&amp;laquo;Главный&amp;raquo; аргумент dbstat - это схема по умолчанию, для которой должна быть предоставлена ​​информация. По умолчанию используется &quot;main&quot;, поэтому использование &quot;main&quot; в приведенном выше примере является избыточным. Для любого конкретного запроса схему можно изменить, указав альтернативную схему в качестве аргумента функции для имени виртуальной таблицы в предложении FROM запроса. (Для получения дополнительных сведений см. Дальнейшее обсуждение возвращающих &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;табличное значение функций в предложении FROM&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="09862758c2c346b79031222c95f1cc2f0ca91ec9" translate="yes" xml:space="preserve">
          <source>The &quot;make&quot; utility, or optionally &quot;nmake&quot; on Windows.</source>
          <target state="translated">Утилита &quot;make&quot;,или опционально &quot;nmake&quot; на Windows.</target>
        </trans-unit>
        <trans-unit id="658c3f95d62bc63b68f3b7aa685ee8fbc83d8cde" translate="yes" xml:space="preserve">
          <source>The &quot;matchinfo=fts3&quot; option is not available. The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize=0&quot;&lt;/a&gt; option is equivalent.</source>
          <target state="translated">Параметр &quot;matchinfo = fts3&quot; недоступен. Параметр &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&amp;laquo;columnsize = 0&amp;raquo;&lt;/a&gt; эквивалентен.</target>
        </trans-unit>
        <trans-unit id="d99f30c2d0e908e2cc3022d7fdccaca904765bb1" translate="yes" xml:space="preserve">
          <source>The &quot;merge&quot; command attempts to apply all the changes between circles (1) and (4) to the files in the local checkout. Note that circle (5) has not been created yet. You will need to run the &quot;commit&quot; to create circle (5).</source>
          <target state="translated">Команда &quot;слияние&quot; пытается применить все изменения между кругами (1)и (4)к файлам в локальной кассе.Обратите внимание,что круг (5)еще не создан.Для создания окружности (5)нужно выполнить &quot;фиксацию&quot;.</target>
        </trans-unit>
        <trans-unit id="9e41a414a4991da0955ad788ff392c91737d8599" translate="yes" xml:space="preserve">
          <source>The &quot;merge=X,Y&quot; command (where X and Y are integers) causes SQLite to do a limited amount of work toward merging the various inverted index b-trees of an FTS3/4 table together into one large b-tree. The X value is the target number of &quot;blocks&quot; to be merged, and Y is the minimum number of b-tree segments on a level required before merging will be applied to that level. The value of Y should be between 2 and 16 with a recommended value of 8. The value of X can be any positive integer but values on the order of 100 to 300 are recommended.</source>
          <target state="translated">Команда &quot;merge=X,Y&quot; (где X и Y-целые числа)заставляет SQLite выполнить ограниченный объем работы по объединению различных перевернутых индексных b-деревьев таблицы FTS3/4 в одно большое b-дерево.Значение X-заданное количество &quot;блоков&quot;,подлежащих слиянию,а Y-минимальное количество сегментов b-дерева на уровне,требуемом для слияния,которое будет применено к этому уровню.Значение Y должно быть между 2 и 16 с рекомендуемым значением 8.Значение X может быть любым положительным целым числом,но рекомендуются значения порядка 100-300.</target>
        </trans-unit>
        <trans-unit id="7feb211cc64d1d7531c5d948598d752876b7262d" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3f77712e8ba4f79aa6578b325009e072dd171a" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">Параметр &amp;laquo;missing&amp;raquo; позволяет пользователю указать имя определяемой &lt;a href=&quot;c3ref/create_function&quot;&gt;приложением функции SQL,&lt;/a&gt; которая будет вызываться непосредственно перед тем, как swarmvtab откроет базу данных, если обнаружит, что требуемый файл базы данных отсутствует на диске. Это дает приложению возможность получить необходимую базу данных из удаленного источника, прежде чем swarmvtab попытается ее открыть. Единственный аргумент, передаваемый &quot;отсутствующей&quot; функции, - это имя или URI, который идентифицирует открытую базу данных. Предполагая:</target>
        </trans-unit>
        <trans-unit id="6f3a9546b734b773233219e3ac894021d9c4aea3" translate="yes" xml:space="preserve">
          <source>The &quot;mmap_size&quot; is the maximum number of bytes of the database file that SQLite will try to map into the process address space at one time. The mmap_size applies separately to each database file, so the total amount of process address space that could potentially be used is the mmap_size times the number of open database files.</source>
          <target state="translated">mmap_size&quot;-это максимальное количество байт файла базы данных,которое SQLite попытается отобразить в адресное пространство процесса за один раз.mmap_size применяется отдельно к каждому файлу базы данных,поэтому общее количество адресного пространства процесса,которое потенциально может быть использовано,умножается на mmap_size,умноженное на количество открытых файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="d05f6ca4b8375a55040cbbe82e13d67e18ad454c" translate="yes" xml:space="preserve">
          <source>The &quot;mptester.c&quot; program is a stress test for multiple processes concurrently reading and writing a single database.</source>
          <target state="translated">Программа &quot;mptester.c&quot; является стресс-тестом для нескольких процессов,одновременно читающих и записывающих одну базу данных.</target>
        </trans-unit>
        <trans-unit id="aceceab4037b5385ba92b29e0b20a81e94146ade" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method</source>
          <target state="translated">Метод &quot;нулевой стоимости&quot;</target>
        </trans-unit>
        <trans-unit id="e3321ce8b4cd40cd33c761004ca598eb073646da" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method changes the representation for NULL returned as result of the &quot;eval&quot; method.</source>
          <target state="translated">Метод &quot;nullvalue&quot; изменяет представление для NULL,возвращаемое в результате метода &quot;eval&quot;.</target>
        </trans-unit>
        <trans-unit id="afd7b6ac7a6da46e476f310a277a91923a4e7d04" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method is useful to differ between NULL and empty column values as Tcl lacks a NULL representation. The default representation for NULL values is an empty string.</source>
          <target state="translated">Метод &quot;nullvalue&quot; полезен для того,чтобы различать NULL и значения пустых столбцов,так как в Tcl отсутствует NULL представление.По умолчанию для NULL-значений используется пустая строка.</target>
        </trans-unit>
        <trans-unit id="0c64f6777879373881c2c98b6dbc2b30411e222a" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method</source>
          <target state="translated">Метод &quot;onecolumn&quot;</target>
        </trans-unit>
        <trans-unit id="3506b602f0b2580a68e5b060067cc065e54d9b3f" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method works like &quot;&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;&quot; in that it evaluates the SQL query statement given as its argument. The difference is that &quot;onecolumn&quot; returns a single element which is the first column of the first row of the query result.</source>
          <target state="translated">Метод &amp;laquo;onecolumn&amp;raquo; работает как &amp;laquo; &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; &amp;raquo; в том смысле, что он оценивает оператор запроса SQL, заданный в качестве его аргумента. Разница в том, что &amp;laquo;onecolumn&amp;raquo; возвращает единственный элемент, который является первым столбцом первой строки результата запроса.</target>
        </trans-unit>
        <trans-unit id="a0182d08456ee166091bc283f720fe1e714fcddc" translate="yes" xml:space="preserve">
          <source>The &quot;onoff&quot; parameter is true to enable the tracking of memory statistics and false to disable statistics tracking.</source>
          <target state="translated">Параметр &quot;onoff&quot; верен для включения отслеживания статистики в памяти и false для отключения отслеживания статистики.</target>
        </trans-unit>
        <trans-unit id="e1f82fa30a955dc30a2b143e423d5902467689c7" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c453be3bed80a3f6062f894d9c91b09f2a405f4" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">Параметр &amp;laquo;openclose&amp;raquo; позволяет пользователю указать имя определяемой &lt;a href=&quot;c3ref/create_function&quot;&gt;приложением функции SQL,&lt;/a&gt; которая будет вызываться непосредственно перед тем, как swarmvtab откроет базу данных, и снова сразу после ее закрытия. Первым аргументом, передаваемым функции open close, является имя файла или URI, идентифицирующий базу данных, которая должна быть открыта или только что закрыта (то же значение, возвращаемое в крайнем левом столбце оператора SQL, предоставленного команде CREATE VIRTUAL TABLE). Второй аргумент - это целочисленное значение 0, когда функция вызывается перед открытием базы данных, и 1, когда она вызывается после закрытия базы данных. Например, если:</target>
        </trans-unit>
        <trans-unit id="e12d49df2a6244cc1bdf5cf47d59be2df870804d" translate="yes" xml:space="preserve">
          <source>The &quot;optimize&quot; command causes FTS3/4 to merge together all of its inverted index b-trees into one large and complete b-tree. Doing an optimize will make subsequent queries run faster since there are fewer b-trees to search, and it may reduce disk usage by coalescing redundant entries. However, for a large FTS table, running optimize can be as expensive as running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;. The optimize command essentially has to read and write the entire FTS table, resulting in a large transaction.</source>
          <target state="translated">Команда optimize заставляет FTS3 / 4 объединить все свои инвертированные b-деревья индексов в одно большое и полное b-дерево. Выполнение оптимизации ускорит выполнение последующих запросов, поскольку для поиска требуется меньше b-деревьев, и может уменьшить использование диска за счет объединения избыточных записей. Однако для большой таблицы FTS запуск оптимизации может быть столь же дорогостоящим, как запуск &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . Команда optimize по существу должна читать и записывать всю таблицу FTS, что приводит к большой транзакции.</target>
        </trans-unit>
        <trans-unit id="8d4ccdc372ee3d695bbd6a513c0e6e7c13353814" translate="yes" xml:space="preserve">
          <source>The &quot;order&quot; option may be set to either &quot;DESC&quot; or &quot;ASC&quot; (in upper or lower case). If it is set to &quot;DESC&quot;, then FTS4 stores its data in such a way as to optimize returning results in descending order by docid. If it is set to &quot;ASC&quot; (the default), then the data structures are optimized for returning results in ascending order by docid. In other words, if many of the queries run against the FTS4 table use &quot;ORDER BY docid DESC&quot;, then it may improve performance to add the &quot;order=desc&quot; option to the CREATE VIRTUAL TABLE statement.</source>
          <target state="translated">Опция &quot;заказ&quot; может быть установлена либо в &quot;DESC&quot;,либо в &quot;ASC&quot; (в верхнем или нижнем регистре).Если она установлена в &quot;DESC&quot;,то FTS4 хранит свои данные таким образом,чтобы оптимизировать возвращаемые результаты в порядке убывания по документу.Если установлено значение &quot;ASC&quot; (по умолчанию),то структуры данных оптимизируются для возврата результатов в порядке возрастания по документу.Другими словами,если многие запросы,выполняемые против таблицы FTS4,используют &quot;ORDER BY docid DESC&quot;,то это может улучшить производительность,добавив опцию &quot;order=desc&quot; в оператор CREATE VIRTUAL TABLE.</target>
        </trans-unit>
        <trans-unit id="a820cd844c9df8619832ad41e29de304a643e275" translate="yes" xml:space="preserve">
          <source>The &quot;pBuf&quot; parameter is a pointer to memory space that will be used for the lookaside memory pool. If pBuf is NULL, then SQLite will obtain its own space for the memory pool using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The &quot;sz&quot; and &quot;cnt&quot; parameters are the size of each lookaside slot and the number of slots, respectively. If pBuf is not NULL, then it must point to at least sz*cnt bytes of memory.</source>
          <target state="translated">Параметр &amp;laquo;pBuf&amp;raquo; - это указатель на пространство памяти, которое будет использоваться для резервного пула памяти. Если pBuf равен NULL, то SQLite получит собственное пространство для пула памяти с помощью &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; . Параметры &amp;laquo;sz&amp;raquo; и &amp;laquo;cnt&amp;raquo; - это размер каждого дополнительного слота и количество слотов соответственно. Если pBuf не равен NULL, он должен указывать как минимум на sz * cnt байтов памяти.</target>
        </trans-unit>
        <trans-unit id="96f961210acaa75affae517c15c72d34812d54b4" translate="yes" xml:space="preserve">
          <source>The &quot;parent&quot; column is always NULL for json_each(). For json_tree(), the &quot;parent&quot; column is the &quot;id&quot; integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument.</source>
          <target state="translated">Родительский&quot; столбец всегда имеет значение NULL для функции json_each().Для json_tree()столбец &quot;parent&quot;-это &quot;id&quot; целое число для родителя текущего элемента,или NULL для JSON-элемента верхнего уровня,или элемент,идентифицируемый корневым путём во втором аргументе.</target>
        </trans-unit>
        <trans-unit id="f4a41ee583b00942417f0c8c5f788e416b5fcd33" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">В колонке &quot;путь&quot; описывается путь,взятый из корневого узла древовидной структуры к каждой странице.Путь&quot; самого корневого узла-'/'.Путь&quot; для самой левой дочерней страницы корневой структуры дерева-'/000/'.(В деревьях Btree содержимое упорядочивается слева направо,поэтому страницы слева имеют меньшие по размеру клавиши,чем страницы справа).Рядом с левой-самый младший по отношению к корневой странице-'/001',и так далее,каждая страница брата или сестры обозначается 3-значным шестнадцатеричным значением.Дочерние дети 451-го самого левого ребёнка имеют такие пути,как '/1c2/000/,'/1c2/001/' и т.д.Переполненные страницы задаются путем добавления символа '+' и шестизначного шестнадцатеричного значения к пути к ячейке,с которой они связаны.Например,три переполненные страницы в цепочке,связанной с самой левой ячейкой 450-го дочернего элемента корневой страницы,определяются путями:</target>
        </trans-unit>
        <trans-unit id="91195df7be82f506dcfbeb2cd0a2c8ea2909dc1a" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; is NULL when &quot;aggregate&quot; is TRUE. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2306ed00f4707f3494099d14093fb57dc4cef952" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column is the path to the array or object container the holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output.</source>
          <target state="translated">Столбец &quot;путь&quot;-это путь к массиву или контейнеру объектов,в котором хранится текущая строка,или путь к текущей строке в том случае,если итерация начинается с примитивного типа и,таким образом,обеспечивает только одну строку вывода.</target>
        </trans-unit>
        <trans-unit id="9d4d6b26f49abb4a72a1bbdb1337cbe3b3abe73d" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; in the last parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; is used to prevent pointers intended for one extension from being redirected to a different extension. For example, without the use of pointer types, an attacker could still get access to pointer information in a system that included both the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt; using SQL like this:</source>
          <target state="translated">&amp;laquo;Тип указателя&amp;raquo; в последнем параметре &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; используется для предотвращения перенаправления указателей, предназначенных для одного расширения, на другое расширение. Например, без использования типов указателей злоумышленник все еще может получить доступ к информации указателя в системе, которая включает как &lt;a href=&quot;fts3&quot;&gt;FTS3, так&lt;/a&gt; и &lt;a href=&quot;carray&quot;&gt;расширение CARRAY,&lt;/a&gt; используя SQL следующим образом:</target>
        </trans-unit>
        <trans-unit id="adee741afd091308ea52b91bf986798eb9c23f39" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; string which is the last parameter to each of the pointer-passing interfaces should be a distinct, application-specific string literal that appears directly in the API call. The pointer type should not be a parameter passed in from a higher-level function.</source>
          <target state="translated">Строка &quot;тип указателя&quot;,являющаяся последним параметром для каждого из интерфейсов обхода указателей,должна быть отдельным,специфичным для приложения строковым литералом,который появляется непосредственно при вызове API.Тип указателя не должен быть параметром,передаваемым из функции более высокого уровня.</target>
        </trans-unit>
        <trans-unit id="87d3095f178983c8a04814005e7e058687741b3d" translate="yes" xml:space="preserve">
          <source>The &quot;prefix&quot; option, used to add &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;prefix indexes&lt;/a&gt; to an FTS5 table.</source>
          <target state="translated">Параметр &amp;laquo;префикс&amp;raquo;, используемый для добавления &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;индексов префикса&lt;/a&gt; в таблицу FTS5.</target>
        </trans-unit>
        <trans-unit id="007337419b82fead3e9a4bb4ea6d17cd18d879d3" translate="yes" xml:space="preserve">
          <source>The &quot;price of California oranges&quot; query was made more efficient through the use of a two-column index. But SQLite can do even better with a three-column index that also includes the &quot;price&quot; column:</source>
          <target state="translated">Запрос &quot;цена калифорнийских апельсинов&quot; стал более эффективным благодаря использованию двухколоночного индекса.Но еще лучше SQLite может справиться с трехколонным индексом,который также включает в себя столбец &quot;цена&quot;:</target>
        </trans-unit>
        <trans-unit id="57afc82684ba8294d6cce9305c290f392e265962" translate="yes" xml:space="preserve">
          <source>The &quot;profile&quot; method</source>
          <target state="translated">Профильный&quot; метод</target>
        </trans-unit>
        <trans-unit id="a6a8d9f9ad6e3aababd749d5fdde2d82848ad996" translate="yes" xml:space="preserve">
          <source>The &quot;progress&quot; method</source>
          <target state="translated">Метод &quot;прогресса&quot;</target>
        </trans-unit>
        <trans-unit id="588545c2f185476e9dee998a1b045a9b0c16cc70" translate="yes" xml:space="preserve">
          <source>The &quot;quote&quot; output mode honors &quot;.separator&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98ea4147c812e538b99bc21f1f6a4e8e90abfe0" translate="yes" xml:space="preserve">
          <source>The &quot;rbu_control&quot; column may also be set to integer value 2 for an INSERT. In this case, the new row silently replaces any existing row that has the same primary key values. This is equivalent to a DELETE followed by an INSERT with the same primary key values. It is not the same as an SQL REPLACE command, as in that case the new row may replace any conflicting rows (i.e. those that conflict due to UNIQUE constraints or indexes), not just those with conflicting primary keys.</source>
          <target state="translated">Столбец &quot;rbu_control&quot; также может быть установлен в целое значение 2 для INSERT.В этом случае новая строка беззвучно заменяет любую существующую строку,которая имеет те же самые значения первичного ключа.Это эквивалентно DELETE,за которым следует INSERT со значениями тех же первичных ключей.Это не то же самое,что команда SQL REPLACE,так как в этом случае новая строка может заменить любые конфликтующие строки (т.е.те,которые конфликтуют из-за ограничений или индексов UNIQUE),а не только строки с конфликтующими первичными ключами.</target>
        </trans-unit>
        <trans-unit id="a26e076f35ba0ef194f00cabb02d8f0d110dbd9a" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command causes SQLite to discard the entire FTS3/4 table and then rebuild it again from original text. The concept is similar to &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, only that it applies to an FTS3/4 table instead of an ordinary index.</source>
          <target state="translated">Команда &amp;laquo;rebuild&amp;raquo; заставляет SQLite отбрасывать всю таблицу FTS3 / 4, а затем заново строить ее из исходного текста. Эта концепция похожа на &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; , только она применяется к таблице FTS3 / 4 вместо обычного индекса.</target>
        </trans-unit>
        <trans-unit id="9dfe3ef5f9d0e5aefda4d198135af7dfc82b7ad7" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command should be run whenever the implementation of a custom tokenizer changes, so that all content can be retokenized. The &quot;rebuild&quot; command is also useful when using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; after changes have been made to the original content table.</source>
          <target state="translated">Команду &amp;laquo;rebuild&amp;raquo; следует запускать всякий раз, когда изменяется реализация настраиваемого токенизатора, чтобы все содержимое можно было повторно токенизировать. Команда &amp;laquo;rebuild&amp;raquo; также полезна при использовании &lt;a href=&quot;fts3#*fts4content&quot;&gt;опции содержимого FTS4&lt;/a&gt; после того, как были внесены изменения в исходную таблицу содержимого.</target>
        </trans-unit>
        <trans-unit id="c9e0f27230c23e1210b0f85831927b9fb4ed65b1" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method</source>
          <target state="translated">Метод &quot;восстановления&quot;</target>
        </trans-unit>
        <trans-unit id="24c21c10984afe5581e89897013fce4a408ba45f" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method copies the content from a separate database file into the current database connection, overwriting any preexisting content. The command syntax is like this:</source>
          <target state="translated">Метод &quot;восстановления&quot; копирует содержимое из отдельного файла БД в текущее подключение к БД,перезаписывая любое существовавшее ранее содержимое.Синтаксис команды такой:</target>
        </trans-unit>
        <trans-unit id="9587ea916bf4a39318094206a7a32f2bcdfaa5ba" translate="yes" xml:space="preserve">
          <source>The &quot;rollback_hook&quot; method</source>
          <target state="translated">Метод &quot;rollback_hook&quot;</target>
        </trans-unit>
        <trans-unit id="e00d488bea46afaaecd75512057a1c66d8fe6370" translate="yes" xml:space="preserve">
          <source>The &quot;score&quot; for a comparison is the edit distance between the pattern and the word, adjusted down by the base-2 logarithm of the word rank. For example, a match with distance 100 but rank 1000 would have a score of 122 (= 100 - log2(1000) + 32) whereas a match with distance 100 with a rank of 1 would have a score of 131 (100 - log2(1) + 32). (NB: The constant 32 is added to each score to keep it from going negative in case the edit distance is zero.) In this way, frequently used words get a slightly lower cost which tends to move them toward the top of the list of alternative spellings.</source>
          <target state="translated">Оценка&quot; для сравнения-это редактируемое расстояние между деталью и словом,скорректированное вниз по логарифму слова &quot;ранг&quot; (базовый-2 логарифм).Например,при сравнении расстояния 100,но ранга 1000,оценка 122 (=100-log2(1000)+32),тогда как при сравнении расстояния 100,но ранга 1,оценка 131 (100-log2(1)+32).(NB:К каждой оценке добавляется константа 32,чтобы она не стала отрицательной в случае,если дистанция редактирования равна нулю).Таким образом,часто употребляемые слова получают немного меньшую стоимость,что имеет тенденцию перемещать их к вершине списка альтернативных заклинаний.</target>
        </trans-unit>
        <trans-unit id="5c73b0b5b1beb7568fc6d18b01b575dea3734b9a" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method</source>
          <target state="translated">Метод &quot;сериализации&quot;</target>
        </trans-unit>
        <trans-unit id="3d89d42c3828f01cc4451e3643a15ed26533dc51" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method creates a BLOB which is a complete copy of an underlying database. The syntax is like this:</source>
          <target state="translated">Метод &quot;сериализации&quot; создает BLOB,который является полной копией баз данных.Синтаксис такой:</target>
        </trans-unit>
        <trans-unit id="d8ecb1d818748f027a6df9d4ecf31fdb4abf6802" translate="yes" xml:space="preserve">
          <source>The &quot;size&quot; of a row value is the number of scalar values the row value contains. The size of a row value is always at least 2. A row value with a single column is just a scalar value. A row value with no columns is a syntax error.</source>
          <target state="translated">Размер&quot; значения строки-это количество скалярных значений,которое содержит значение строки.Размер значения строки всегда не менее 2,а значение строки с одним столбцом-всего лишь скалярное значение.Значение строки без столбцов является синтаксической ошибкой.</target>
        </trans-unit>
        <trans-unit id="5edd5de6e6f1cc913259bc478dccfe21c6a5d5fb" translate="yes" xml:space="preserve">
          <source>The &quot;speedtest1.c&quot; program estimates the performance of SQLite under a typical workload.</source>
          <target state="translated">Программа &quot;speedtest1.c&quot; оценивает производительность SQLite при типичной рабочей нагрузке.</target>
        </trans-unit>
        <trans-unit id="94d1e1fa50bdc62251cad63515806a616cb08e98" translate="yes" xml:space="preserve">
          <source>The &quot;spellfix1&quot; term is the name of the spellfix module and must be entered as shown. The &quot;demo&quot; term is the name of the virtual table you will be creating and can be altered to suit the needs of your application. The virtual table is initially empty. In order for the virtual table to be useful, you will need to populate it with your vocabulary. Suppose you have a list of words in a table named &quot;big_vocabulary&quot;. Then do this:</source>
          <target state="translated">Термин &quot;spellfix1&quot; является названием модуля правописания и должен вводиться в соответствии с указаниями.Демонстрационный&quot; термин-это название виртуальной таблицы,которую вы будете создавать,и может быть изменен в соответствии с потребностями вашего приложения.Виртуальная таблица изначально пуста.Для того чтобы виртуальный стол был полезен,необходимо заполнить его своим словарным запасом.Предположим,у Вас есть список слов в таблице под названием &quot;big_vocabulary&quot;.Тогда сделайте это:</target>
        </trans-unit>
        <trans-unit id="1f251add4c0609e09930cd5b2e1c244e554f6696" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; code file contains default implementations of a VFS and of the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; functions that are appropriate for Unix, Windows, and OS/2. To prevent one of these default components from being loaded when sqlite3.c is compiled, it is necessary to add the following compile-time option:</source>
          <target state="translated">Файл кода &quot;sqlite3.c&quot; содержит стандартные реализации VFS и функций &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; и &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; , которые подходят для Unix, Windows и OS / 2. Чтобы предотвратить загрузку одного из этих компонентов по умолчанию при компиляции sqlite3.c, необходимо добавить следующую опцию времени компиляции:</target>
        </trans-unit>
        <trans-unit id="d25afe467d47fff3cdb66b829147595e777d2e30" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; make target will automatically construct the regular &quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot; amalgamation source file, its header file &quot;&lt;b&gt;sqlite3.h&lt;/b&gt;&quot;, and the &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot; amalgamation source file that includes the TCL interface. Afterwards, the needed files can be copied into project directories and compiled according to the procedures outlined above.</source>
          <target state="translated">Цель make &quot;sqlite3.c&quot; автоматически &lt;b&gt;создаст обычный&lt;/b&gt; исходный файл объединения &quot; &lt;b&gt;sqlite3.c&lt;/b&gt; &quot;, его файл заголовка &quot; &lt;b&gt;sqlite3.h&lt;/b&gt; &quot; и исходный файл объединения &quot; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &quot;, который включает интерфейс TCL. После этого необходимые файлы можно скопировать в каталоги проекта и скомпилировать в соответствии с процедурами, описанными выше.</target>
        </trans-unit>
        <trans-unit id="66d4d7e86561a6b1d54c81eff00582173909b3a6" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="translated">Служебная программа sqlite3_analyzer.exe, доступная в виде исходного кода в дереве исходного кода SQLite или в виде предварительно скомпилированного двоичного файла на &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;странице загрузки SQLite&lt;/a&gt; , может использоваться для измерения средних размеров строк таблицы в существующей базе данных SQLite.</target>
        </trans-unit>
        <trans-unit id="a9d37ec09106220f475c04bb945df6d0783856ec" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;https://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff30531d333139aba53fa40d0cdd26055103901a" translate="yes" xml:space="preserve">
          <source>The &quot;start match&quot; text.</source>
          <target state="translated">Текст &quot;стартовое совпадение&quot;.</target>
        </trans-unit>
        <trans-unit id="b039029daf858be6adbac43c34475b31375cdd36" translate="yes" xml:space="preserve">
          <source>The &quot;start of&quot; modifiers (7 through 9) shift the date backwards to the beginning of the current month, year or day.</source>
          <target state="translated">Начало&quot; модификаторов (от 7 до 9)сдвигает дату назад к началу текущего месяца,года или дня.</target>
        </trans-unit>
        <trans-unit id="05b5d073f83b249218dde4220e351fdb9c81957d" translate="yes" xml:space="preserve">
          <source>The &quot;state&quot; index works just like the &quot;fruit&quot; index in that it is a new table with an extra column in front of the rowid and sorted by that extra column as the primary key. The only difference is that in Idx2, the first column is &quot;state&quot; instead of &quot;fruit&quot; as it is with Idx1. In our example data set, there is more redundancy in the &quot;state&quot; column and so they are more duplicate entries. The ties are still resolved using the rowid.</source>
          <target state="translated">Индекс &quot;состояния&quot; работает точно так же,как и индекс &quot;фруктов&quot;,в том смысле,что это новая таблица с дополнительным столбцом перед строкой,отсортированная по этому дополнительному столбцу в качестве первичного ключа.Единственное отличие состоит в том,что в индексе Idx2 первый столбец-это &quot;состояние&quot;,а не &quot;плод&quot;,как в индексе Idx1.В нашем примере набора данных,в столбце &quot;состояние&quot; больше избыточности,и поэтому они являются более дублирующимися записями.Связи все еще разрешаются с помощью rowid.</target>
        </trans-unit>
        <trans-unit id="cf055db4baca803941f56b418b3f79cd69d69f75" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; method</source>
          <target state="translated">Метод &quot;статуса&quot;</target>
        </trans-unit>
        <trans-unit id="4cb7bc19f02c001a06f5cf0e9a288feeb79d31b6" translate="yes" xml:space="preserve">
          <source>The &quot;swarmvtab&quot; virtual table allows the user to query a large number of tables (hereafter &quot;component&quot; tables) with similar schemas but distinct ranges of rowid values as if they were a single database table. The tables may be (and usually are) located in different databases. Swarmvtab tables are read-only.</source>
          <target state="translated">Виртуальная таблица &quot;swarmvtab&quot; позволяет пользователю опрашивать большое количество таблиц (далее-&quot;составные&quot; таблицы)со схожими схемами,но с различными диапазонами значений рядов,как если бы они были одной таблицей БД.Эти таблицы могут находиться (и,как правило,находятся)в разных БД.Таблицы Swarmvtab доступны только для чтения.</target>
        </trans-unit>
        <trans-unit id="dab19bcea20e3ab7d9ecf3510719cf0224e13f4a" translate="yes" xml:space="preserve">
          <source>The &quot;sz&quot; parameter is the size in bytes of each lookaside slot. The &quot;cnt&quot; parameter is the total number of lookaside memory slots per database connection. The total amount of lookaside memory allocated to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is sz*cnt bytes.</source>
          <target state="translated">Параметр &amp;laquo;sz&amp;raquo; - это размер в байтах каждого дополнительного слота. Параметр &amp;laquo;cnt&amp;raquo; - это общее количество дополнительных слотов памяти на одно соединение с базой данных. Общий объем дополнительной памяти, выделенной для каждого &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных,&lt;/a&gt; составляет sz * cnt байт.</target>
        </trans-unit>
        <trans-unit id="21cc2584b07fb547745b9d5684016c88291d98ce" translate="yes" xml:space="preserve">
          <source>The &quot;sz=NNN&quot; argument (where NNN represents a sequence of 1 or more digits) means that the average row size over all records of the table or index is NNN bytes per row. The SQLite query planner might use the estimated row size information provided by the &quot;sz=NNN&quot; token to help it choose smaller tables and indexes that require less disk I/O.</source>
          <target state="translated">Аргумент &quot;sz=NNN&quot; (где NNN представляет собой последовательность из 1 или более цифр)означает,что средний размер строки над всеми записями таблицы или индекса составляет NNN байт на строку.Планировщик запросов SQLite может использовать информацию об оценочном размере строки,предоставляемую маркером &quot;sz=NNN&quot;,чтобы помочь ему выбрать меньшие по размеру таблицы и индексы,требующие меньшего количества дисковых входов/выходов.</target>
        </trans-unit>
        <trans-unit id="1f5faa11cc0f3cca617edc23b678832f22fc7469" translate="yes" xml:space="preserve">
          <source>The &quot;temp&quot; database (in which TEMP tables and indices are stored) and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; always uses exclusive locking mode. The locking mode of temp and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; cannot be changed. All other databases use the normal locking mode by default and are affected by this pragma.</source>
          <target state="translated">База данных &amp;laquo;temp&amp;raquo; (в которой хранятся таблицы и индексы TEMP) и &lt;a href=&quot;inmemorydb&quot;&gt;базы данных в памяти&lt;/a&gt; всегда используют режим монопольной блокировки. Режим блокировки временных &lt;a href=&quot;inmemorydb&quot;&gt;баз данных и баз данных в памяти&lt;/a&gt; изменить нельзя. Все остальные базы данных по умолчанию используют нормальный режим блокировки, и на них влияет эта прагма.</target>
        </trans-unit>
        <trans-unit id="8cb92fbf85091b767df43e1863c69aa8515916b3" translate="yes" xml:space="preserve">
          <source>The &quot;test1.dir&quot; directory created above puts all the blobs into a single folder. It was conjectured that some operating systems would perform poorly when a single directory contains 100,000 objects. To test this, the kvtest program can also store the blobs in a hierarchy of folders with no more than 100 files and/or subdirectories per folder. The alternative on-disk representation of the blobs can be created using the --tree command-line option to the &quot;export&quot; command, like this:</source>
          <target state="translated">Созданный выше каталог &quot;test1.dir&quot; помещает все блобы в одну папку.Предполагалось,что некоторые операционные системы будут работать плохо,если в одной папке будет 100 000 объектов.Для проверки этого программа kvtest может также хранить капли в иерархии папок,содержащих не более 100 файлов и/или подкаталогов в каждой папке.Альтернативное представление блобов на диске может быть создано с помощью опции командной строки --tree для команды &quot;экспортировать&quot;:</target>
        </trans-unit>
        <trans-unit id="9e8c625e743111097d3b7602f25647d8fd5f0deb" translate="yes" xml:space="preserve">
          <source>The &quot;th3&quot; binary is run and the output checked for errors.</source>
          <target state="translated">Двоичный файл &quot;th3&quot; запускается,а выход проверяется на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="405706da87374261dc84d98a92672d2aa3e6824d" translate="yes" xml:space="preserve">
          <source>The &quot;threadtest3.c&quot; program is a stress test for multiple threads using SQLite simultaneously.</source>
          <target state="translated">Программа &quot;threadtest3.c&quot;-это стресс-тест для нескольких потоков,использующих SQLite одновременно.</target>
        </trans-unit>
        <trans-unit id="c2ea8ab5c5050c4a238a6302498853dd2f689e62" translate="yes" xml:space="preserve">
          <source>The &quot;three&quot; column -- the key to the bucket</source>
          <target state="translated">Колонка &quot;три&quot;-ключ к ведру.</target>
        </trans-unit>
        <trans-unit id="4fa8abbe4c1763e70302352dd8c5a5a17e072b27" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method</source>
          <target state="translated">Метод &quot;таймаута&quot;</target>
        </trans-unit>
        <trans-unit id="7d44f83daf7e28e3193a3ecca21e30ba205796c2" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method is used to control how long the SQLite library will wait for locks to clear before giving up on a database transaction. The default timeout is 0 millisecond. (In other words, the default behavior is not to wait at all.)</source>
          <target state="translated">Метод &quot;таймаута&quot; используется для контроля за тем,как долго библиотека SQLite будет ждать очистки замков,прежде чем отказаться от транзакции с БД.По умолчанию таймаут равен 0 миллисекундам.(Другими словами,поведение по умолчанию-вовсе не ждать).</target>
        </trans-unit>
        <trans-unit id="7ac730ff83376aab14adb2a2686e6b4272b35baf" translate="yes" xml:space="preserve">
          <source>The &quot;tokenize&quot; option, used to configure a &lt;a href=&quot;fts5#tokenizers&quot;&gt;custom tokenizer&lt;/a&gt;.</source>
          <target state="translated">Параметр &amp;laquo;tokenize&amp;raquo;, используемый для настройки &lt;a href=&quot;fts5#tokenizers&quot;&gt;настраиваемого токенизатора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5924f14d286c018a59c3ed95d3124a43c86bfc19" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method</source>
          <target state="translated">Метод &quot;total_changes&quot;</target>
        </trans-unit>
        <trans-unit id="67201b01d24a416fed46b29f515a9e7ed51080c3" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified since the current database connection was first opened.</source>
          <target state="translated">Метод &quot;total_changes&quot; возвращает целое число-количество строк в БД,которые были вставлены,удалены и/или изменены с момента первого открытия текущего соединения с БД.</target>
        </trans-unit>
        <trans-unit id="7e6156617165c2bee31d2c34a55e3df2f7ee7cbc" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method</source>
          <target state="translated">Метод &quot;следа&quot;</target>
        </trans-unit>
        <trans-unit id="b2906df9327952a977291763abf36d4cd7917ee1" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method registers a callback that is invoked as each SQL statement is compiled. The text of the SQL is appended as a single string to the command before it is invoked. This can be used (for example) to keep a log of all SQL operations that an application performs.</source>
          <target state="translated">Метод &quot;трассировки&quot; регистрирует обратный вызов,который вызывается по мере компиляции каждого SQL-оператора.Текст SQL-оператора добавляется к команде как единая строка перед ее вызовом.Это может быть использовано (например)для ведения журнала всех SQL-операций,выполняемых приложением.</target>
        </trans-unit>
        <trans-unit id="ce50004a13c3fcabcb6ebda341338c2b6ecfb280" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method</source>
          <target state="translated">Метод &quot;trace_v2&quot;</target>
        </trans-unit>
        <trans-unit id="2fe37d0c891dddf24c1d50f2d3327a7f07cf31d0" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method registers a callback that is invoked as each SQL statement is compiled. The syntax is as follows:</source>
          <target state="translated">Метод &quot;trace_v2&quot; регистрирует обратный вызов,который вызывается при компиляции каждого SQL-оператора.Синтаксис таков:</target>
        </trans-unit>
        <trans-unit id="e9e9294106d107e583dc783efd0d04b347f737f9" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method</source>
          <target state="translated">Метод &quot;сделки&quot;</target>
        </trans-unit>
        <trans-unit id="839415a25e55cb5e0ba1d1d3bedbc6f8468c1f73" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method is used to execute a TCL script inside an SQLite database transaction. The transaction is committed when the script completes, or it rolls back if the script fails. If the transaction occurs within another transaction (even one that is started manually using BEGIN) it is a no-op.</source>
          <target state="translated">Метод &quot;транзакции&quot; используется для выполнения TCL-скрипта внутри транзакции БД SQLite.Транзакция фиксируется,когда скрипт завершает работу,или откатывается,если скрипт дает сбой.Если транзакция происходит внутри другой транзакции (даже той,которая запускается вручную с помощью BEGIN),то она не работает.</target>
        </trans-unit>
        <trans-unit id="378f72a23dc895cffd3910e611b45425aeb46721" translate="yes" xml:space="preserve">
          <source>The &quot;type&quot; column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element.</source>
          <target state="translated">Столбец &quot;type&quot;-это SQL-текстовое значение,взятое из ('null','true','false','integer','real','text','array','object')в соответствии с типом текущего JSON-элемента.</target>
        </trans-unit>
        <trans-unit id="135f2f5e5d2c30f651d7adf36038240ab6497277" translate="yes" xml:space="preserve">
          <source>The &quot;typical&quot; workload is generated by the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; program in the canonical SQLite source tree. This program strives to exercise the SQLite library in a way that is typical of real-world applications. Of course, every application is different, and so no test program can exactly mirror the behavior of all applications.</source>
          <target state="translated">&amp;laquo;Типичная&amp;raquo; рабочая нагрузка создается программой &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; в каноническом дереве исходного кода SQLite. Эта программа стремится использовать библиотеку SQLite способом, типичным для реальных приложений. Конечно, каждое приложение индивидуально, поэтому ни одна тестовая программа не может точно отражать поведение всех приложений.</target>
        </trans-unit>
        <trans-unit id="27bfc78b4ec7e83cf7c09ae529723bb27ae007c2" translate="yes" xml:space="preserve">
          <source>The &quot;ui&quot; command will cause fossil to run a miniature built-in webserver and to launch your web-browser pointing at that webserver. You can use your web-browser to configure your project in various ways. See the instructions on the fossil website for additional information.</source>
          <target state="translated">Команда &quot;ui&quot; заставит ископаемого запустить миниатюрный встроенный веб-сервер и запустить веб-браузер,указывающий на этот веб-сервер.Вы можете использовать Ваш web-браузер для настройки Вашего проекта различными способами.Для получения дополнительной информации обратитесь к инструкциям на ископаемом веб-сайте.</target>
        </trans-unit>
        <trans-unit id="d78919ab60690742844f0ae8327639ff7f7b254a" translate="yes" xml:space="preserve">
          <source>The &quot;unicode61&quot; tokenizer is available beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11). Unicode61 works very much like &quot;simple&quot; except that it does simple unicode case folding according to rules in Unicode Version 6.1 and it recognizes unicode space and punctuation characters and uses those to separate tokens. The simple tokenizer only does case folding of ASCII characters and only recognizes ASCII space and punctuation characters as token separators.</source>
          <target state="translated">Токенизатор &amp;laquo;unicode61&amp;raquo; доступен, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.13 (2012-06-11). Unicode61 работает очень похоже на &amp;laquo;простой&amp;raquo;, за исключением того, что он выполняет простое сворачивание регистра Unicode в соответствии с правилами Unicode Version 6.1, распознает пробелы и знаки пунктуации Unicode и использует их для разделения токенов. Простой токенизатор выполняет сворачивание только регистра символов ASCII и распознает только символы пробела и пунктуации ASCII в качестве разделителей токенов.</target>
        </trans-unit>
        <trans-unit id="d6180590d39510270d29b1019046f6c7b0cbc137" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a time value in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a time value of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53568b33d00330dcebc8eb48a597c612134f3558" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a timestring in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a timestring of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="translated">Модификатор &amp;laquo;unixepoch&amp;raquo; (11) работает только в том случае, если он следует сразу за временной строкой в ​​формате DDDDDDDDDD. Этот модификатор заставляет DDDDDDDDDD интерпретироваться не как номер дня по юлианскому календарю, как это обычно бывает, а как &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;время Unix&lt;/a&gt; - количество секунд с 1970 года. Если модификатор &quot;unixepoch&quot; не следует за временной строкой в ​​форме DDDDDDDDDD, которая выражает количество секунд с 1970 года или если другие модификаторы отделяют модификатор unixepoch от предыдущего DDDDDDDDDD, то поведение не определено. Для версий SQLite до 3.16.0 (02.01.2017) модификатор &quot;unixepoch&quot; работает только для дат между 0000-01-01 00:00:00 и 5352-11-01 10:52:47 (время unix С -62167219200 по 106751991167).</target>
        </trans-unit>
        <trans-unit id="9a380264abb876efbc0e0abf2e6a2f4c233a20b1" translate="yes" xml:space="preserve">
          <source>The &quot;unlock_notify&quot; method</source>
          <target state="translated">Метод &quot;unlock_notify&quot;</target>
        </trans-unit>
        <trans-unit id="a59aa60915a8fc6bc6f97fdfa3c585be19ca1408" translate="yes" xml:space="preserve">
          <source>The &quot;update_hook&quot; method</source>
          <target state="translated">Метод &quot;update_hook&quot;</target>
        </trans-unit>
        <trans-unit id="ad1e96bd97056b4fb89ac4a9d66b380d5f0978cd" translate="yes" xml:space="preserve">
          <source>The &quot;usable size&quot; of a database page is the page size specified by the 2-byte integer at offset 16 in the header less the &quot;reserved&quot; space size recorded in the 1-byte integer at offset 20 in the header. The usable size of a page might be an odd number. However, the usable size is not allowed to be less than 480. In other words, if the page size is 512, then the reserved space size cannot exceed 32.</source>
          <target state="translated">Полезный размер&quot; страницы БД-это размер страницы,задаваемый 2-байтовым целым числом со смещением 16 в заголовке за вычетом &quot;зарезервированного&quot; размера пространства,записанного в 1-байтовом целом числе со смещением 20 в заголовке.Полезный размер страницы может быть нечетным числом.Однако,допустимый размер не может быть меньше 480.Другими словами,если размер страницы 512,то размер зарезервированного пространства не может превышать 32.</target>
        </trans-unit>
        <trans-unit id="0117a41a4edb11977b96c0bfbaf5ae135dd4dc28" translate="yes" xml:space="preserve">
          <source>The &quot;user version&quot; as read and set by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">&quot;Версия пользователя&quot;, прочитанная и установленная &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;прагмой user_version&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f1221e2090e85cfaa0707db328c83c8e04e4462" translate="yes" xml:space="preserve">
          <source>The &quot;verb&quot; argument determines what statistic is accessed. There are &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;various verbs&lt;/a&gt; defined. The list is expected to grow as the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface matures. The current value the selected parameter is written into integer &quot;current&quot; and the highest historical value is written into integer &quot;highwater&quot;. If resetflag is true, then the high-water mark is reset down to the current value after the call returns.</source>
          <target state="translated">Аргумент &amp;laquo;глагол&amp;raquo; определяет, к какой статистике осуществляется доступ. Есть &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;разные&lt;/a&gt; определения глаголов . Ожидается, что список будет расти по мере развития интерфейса &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; . Текущее значение выбранного параметра записывается в целое число &amp;laquo;current&amp;raquo;, а максимальное историческое значение записывается в целое &amp;laquo;highwater&amp;raquo;. Если resetflag имеет значение true, то отметка максимального уровня сбрасывается до текущего значения после возврата вызова.</target>
        </trans-unit>
        <trans-unit id="fa357090791a4202ebbb1affe438340a7edf58ef" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; method</source>
          <target state="translated">Метод &quot;версии&quot;</target>
        </trans-unit>
        <trans-unit id="cd6ed1a853164caf36a9ec472723c210aaf3324f" translate="yes" xml:space="preserve">
          <source>The &quot;wal_hook&quot; method</source>
          <target state="translated">Метод &quot;wal_hook&quot;</target>
        </trans-unit>
        <trans-unit id="13953b9d13af87a94ab5c5d6a6cf14aaf24d8b07" translate="yes" xml:space="preserve">
          <source>The &quot;weekday&quot; modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the &quot;weekday&quot; modifier leaves the date unchanged.</source>
          <target state="translated">Модификатор &quot;День недели&quot; переносит дату вперед,при необходимости,на следующую дату,где номер дня недели-N.Воскресенье-0,понедельник-1 и так далее.Если дата уже в нужный день недели,то модификатор &quot;День недели&quot; оставляет эту дату без изменений.</target>
        </trans-unit>
        <trans-unit id="fc5b825d3bb551c0ffab90d4aebeaa4b072d1ccb" translate="yes" xml:space="preserve">
          <source>The $nExtCode extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">Коды расширенных результатов $ nExtCode &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;определены в sqlite3.h&lt;/a&gt; и перечислены в алфавитном порядке ниже:</target>
        </trans-unit>
        <trans-unit id="d7c45544c374d408b5b737fa2b109d54d1a57530" translate="yes" xml:space="preserve">
          <source>The $nPrimCode result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">Коды результатов $ nPrimCode &lt;a href=&quot;c3ref/c_abort&quot;&gt;определены в sqlite3.h&lt;/a&gt; и перечислены в алфавитном порядке ниже:</target>
        </trans-unit>
        <trans-unit id="3ab512eff5b3fb377f299e58700487486d503855" translate="yes" xml:space="preserve">
          <source>The $prefix parameter may be NULL, in which case the prefix is deduced from $wholeline. Or, the $wholeline parameter may be NULL or omitted if context information is unavailable or if context-aware completion is not desired.</source>
          <target state="translated">Параметр $prefix может быть NULL,в этом случае префикс вычитается из $wholeline.Или параметр $wholeline может быть NULL или опущен,если контекстная информация недоступна или если не требуется контекстное завершение.</target>
        </trans-unit>
        <trans-unit id="02bbc5a1a7e84666a4d4dd0cec4c28449ae27a6f" translate="yes" xml:space="preserve">
          <source>The %_content table contains the unadulterated data inserted by the user into the FTS virtual table by the user. If the user does not explicitly supply a &quot;docid&quot; value when inserting records, one is selected automatically by the system.</source>
          <target state="translated">Таблица %_content содержит данные,вставленные пользователем в виртуальную таблицу FTS.Если при вставке записей пользователь явно не указывает значение &quot;docid&quot;,то оно выбирается системой автоматически.</target>
        </trans-unit>
        <trans-unit id="7ff27a5cb67628299a86678a48c0336fb247a12c" translate="yes" xml:space="preserve">
          <source>The %_stat and %_docsize tables are only created if the FTS table uses the FTS4 module, not FTS3. Furthermore, the %_docsize table is omitted if the FTS4 table is created with the &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; directive specified as part of the CREATE VIRTUAL TABLE statement. If they are created, the schema of the two tables is as follows:</source>
          <target state="translated">Таблицы% _stat и% _docsize создаются только в том случае, если таблица FTS использует модуль FTS4, а не FTS3. Кроме того, таблица% _docsize опускается, если таблица FTS4 создается с помощью директивы &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo = fts3,&lt;/a&gt; указанной как часть оператора CREATE VIRTUAL TABLE. Если они созданы, схема двух таблиц будет следующей:</target>
        </trans-unit>
        <trans-unit id="c824e78a5796a4ada97aea7265fbe991ac4b8766" translate="yes" xml:space="preserve">
          <source>The %q and %Q substitutions are SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">Подстановки %q и %Q являются усовершенствованиями SQLite,не встречающимися в большинстве других реализаций printf().</target>
        </trans-unit>
        <trans-unit id="38a9fc3133aa73e0b29b95de437699b671e4c4f6" translate="yes" xml:space="preserve">
          <source>The %s substitution is universal, but the %z substitution is an SQLite enhancement, not found in other printf() implementations.</source>
          <target state="translated">Подстановка %s является универсальной,но подстановка %z является усовершенствованием SQLite,не встречающимся в других реализациях printf().</target>
        </trans-unit>
        <trans-unit id="4b87f6c99821c5908fd04958d29e2e7c01fcfa39" translate="yes" xml:space="preserve">
          <source>The %w substitution is an SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">Замена %w является усовершенствованием SQLite,не встречающимся в большинстве других реализаций printf().</target>
        </trans-unit>
        <trans-unit id="05ed0c85ed4fa11e23eab78d700cba29a96e54ed" translate="yes" xml:space="preserve">
          <source>The '%' character is used in requirement H35300 to represent the modulo operator, just as it is in programming languages such as C, Java and Javascript.</source>
          <target state="translated">Символ &quot;%&quot; используется в требовании H35300 для представления оператора modulo,так же как и в языках программирования,таких как C,Java и Javascript.</target>
        </trans-unit>
        <trans-unit id="e9354cba92715c3a8151b0bdbb532432be7bdd61" translate="yes" xml:space="preserve">
          <source>The 'crisismerge' option is similar to 'automerge', in that it determines how and how often the component b-trees that make up the full-text index are merged together. Once there exist</source>
          <target state="translated">Опция &quot;crisismerge&quot; аналогична опции &quot;automerge&quot; в том,что она определяет,как и как часто соединяются составные b-дерева,составляющие полнотекстовый индекс.Как только они существуют</target>
        </trans-unit>
        <trans-unit id="139c169421eec1791495afdd3b65ecbf6f7f8622" translate="yes" xml:space="preserve">
          <source>The *+* operator on the *x* column will prevent that term from constraining an index. This would force the use of the ex2i2 index.</source>
          <target state="translated">Оператор *+*в столбце *x*предотвратит ограничение индекса этим термином.Это заставит использовать индекс ex2i2.</target>
        </trans-unit>
        <trans-unit id="fe65d357eb360ea29fe1d68436790805aab233d0" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">Параметр * pHighwater записывает самый глубокий стек синтаксического анализатора. Значение * pCurrent не определено. Значение * pHighwater имеет смысл только в том случае, если SQLite скомпилирован с &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1ea66787615c66d86376977b69791f61618b2a2" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">Параметр * pHighwater записывает самый глубокий стек синтаксического анализатора. Значение * pCurrent не определено. Значение * pHighwater имеет смысл только в том случае, если SQLite скомпилирован с &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0209d4ffca3af22d05eab8c450129e95986f2c" translate="yes" xml:space="preserve">
          <source>The --blob-api option on the database read test causes kvtest to use the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; feature of SQLite to load the content of the blobs, rather than running pure SQL statements. This helps SQLite to run a little faster on read tests. You can omit that option to compare the performance of SQLite running SQL statements. In that case, the SQLite still out-performs direct reads, though by not as much as when using &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;. The --blob-api option is ignored for tests that read from individual disk files.</source>
          <target state="translated">Параметр --blob-api в тесте чтения базы данных заставляет kvtest использовать функцию &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; SQLite для загрузки содержимого больших двоичных объектов, а не запускать чистые операторы SQL. Это помогает SQLite работать немного быстрее в тестах чтения. Вы можете опустить эту опцию, чтобы сравнить производительность SQLite, выполняющего операторы SQL. В этом случае SQLite по-прежнему превосходит прямые чтения, хотя и не так сильно, как при использовании &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; . Параметр --blob-api игнорируется для тестов, которые читают из отдельных файлов на диске.</target>
        </trans-unit>
        <trans-unit id="aeee09a9fb263d7d0932e1687159faa31b022fff" translate="yes" xml:space="preserve">
          <source>The --deserialize option associated with opening a new database cause the database file to be read into memory and accessed using the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; API. This simplifies running tests on a database without modifying the file on disk.</source>
          <target state="translated">Параметр --deserialize, связанный с открытием новой базы данных, вызывает чтение файла базы данных в память и доступ к нему с помощью API &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; . Это упрощает выполнение тестов в базе данных без изменения файла на диске.</target>
        </trans-unit>
        <trans-unit id="ce432c27aa93648ce455d1142365434d4a1eea96" translate="yes" xml:space="preserve">
          <source>The --init option reports an error if the file named as its argument cannot be opened. The --init option also now honors the --bail option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d3b8386b1e3ccb1cc08c05d6ada4438f0769ba" translate="yes" xml:space="preserve">
          <source>The --primarykey flag changes the pairing algorithm slightly so that the schema-declared &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; is always used for pairing, even on tables that have a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. This is often a better choice for finding differences, however it can lead to missed differences in the case of rows that have one or more PRIMARY KEY columns set to NULL.</source>
          <target state="translated">Флаг --primarykey слегка изменяет алгоритм связывания, так что &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY,&lt;/a&gt; объявленный схемой, всегда используется для связывания, даже в таблицах с &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; . Часто это лучший выбор для поиска различий, однако он может привести к пропущенным различиям в случае строк, в которых для одного или нескольких столбцов PRIMARY KEY установлено значение NULL.</target>
        </trans-unit>
        <trans-unit id="5cd46599c902c6e8fdb69c21ede0585852a486b3" translate="yes" xml:space="preserve">
          <source>The --update and --insert commands work like --create command, except that they do not delete the current archive before commencing. New versions of files silently replace existing files with the same names, but otherwise the initial contents of the archive (if any) remain intact.</source>
          <target state="translated">Команды --update и --insert работают как команда --creatate,за исключением того,что они не удаляют текущий архив перед началом работы.Новые версии файлов беззвучно заменяют существующие файлы на те же имена,но в противном случае исходное содержимое архива (если таковое имеется)остается нетронутым.</target>
        </trans-unit>
        <trans-unit id="92d15467647a321ed86c3b0d4ddfb73a9334e61d" translate="yes" xml:space="preserve">
          <source>The -ldl library is needed to support dynamic loading, the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface and the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;. If these features are not required, then they can be omitted using &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; compile-time option:</source>
          <target state="translated">Библиотека -ldl необходима для поддержки динамической загрузки, интерфейса &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;функции SQL load_extension ()&lt;/a&gt; . Если эти функции не требуются, их можно опустить с помощью &lt;a href=&quot;compile#omit_load_extension&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_OMIT_LOAD_EXTENSION :</target>
        </trans-unit>
        <trans-unit id="ff976c7e2e67ea0658ecbf1774cc0a53bba77580" translate="yes" xml:space="preserve">
          <source>The .selftest command reads the rows of the selftest table in selftest.tno order. For each 'memo' row, it writes the text in 'cmd' to the output. For each 'run' row, it runs the 'cmd' text as SQL and compares the result to the value in 'ans', and shows an error message if the results differ.</source>
          <target state="translated">Команда .selftest читает строки таблицы selftest в порядке selftest.tno.Для каждой строки 'memo' она записывает текст в 'cmd'.Для каждой строки 'run' она запускает текст 'cmd' в виде SQL и сравнивает результат со значением в 'ans',а также выводит сообщение об ошибке,если результаты отличаются.</target>
        </trans-unit>
        <trans-unit id="12dcfb8a7c514a22ec8efe2151085ef4fd8b43ec" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header (found on page 1 only)</source>
          <target state="translated">Заголовок 100-байтового файла базы данных (находится только на странице 1).</target>
        </trans-unit>
        <trans-unit id="a17caaa0027df54644d9d8d5e0706c4b71db11b0" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header is found only on page 1, which is always a table b-tree page. All other b-tree pages in the database file omit this 100-byte header.</source>
          <target state="translated">Заголовок 100-байтового файла базы данных находится только на странице 1,которая всегда представляет собой таблицу b-дерево.Все остальные страницы b-дерева в файле БД опускают этот 100-байтовый заголовок.</target>
        </trans-unit>
        <trans-unit id="3b6884cf3226327e79dce3b07ec790a620af6f29" translate="yes" xml:space="preserve">
          <source>The 12-step &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;generalized ALTER TABLE procedure&lt;/a&gt; above will work even if the schema change causes the information stored in the table to change. So the full 12-step procedure above is appropriate for dropping a column, changing the order of columns, adding or removing a UNIQUE constraint or PRIMARY KEY, adding CHECK or FOREIGN KEY or NOT NULL constraints, or changing the datatype for a column, for example. However, a simpler and faster procedure can optionally be used for some changes that do no affect the on-disk content in any way. The following simpler procedure is appropriate for removing CHECK or FOREIGN KEY or NOT NULL constraints, or adding, removing, or changing default values on a column.</source>
          <target state="translated">&lt;a href=&quot;lang_altertable#otheralter&quot;&gt;Обобщенная&lt;/a&gt; 12-шаговая процедура ALTER TABLE, описанная выше, будет работать, даже если изменение схемы приведет к изменению информации, хранящейся в таблице. Таким образом, описанная выше полная 12-шаговая процедура подходит для удаления столбца, изменения порядка столбцов, добавления или удаления ограничения UNIQUE или PRIMARY KEY, добавления ограничений CHECK, FOREIGN KEY или NOT NULL или изменения типа данных для столбца для пример. Однако для некоторых изменений, которые никоим образом не влияют на содержимое на диске, может быть использована более простая и быстрая процедура. Следующая более простая процедура подходит для удаления ограничений CHECK, FOREIGN KEY или NOT NULL, а также для добавления, удаления или изменения значений по умолчанию в столбце.</target>
        </trans-unit>
        <trans-unit id="2e3276be673e6a294c05cbdaa0d3884fdd5a279f" translate="yes" xml:space="preserve">
          <source>The 1st parameter, &lt;b&gt;context&lt;/b&gt;, is a pointer to an opaque object that describes the content from which the SQL function was invoked. This context point becomes the first parameter to many other routines that the function implement might to invoke, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e86ab7971614c6f24df9cffe9f9872849aa09c9" translate="yes" xml:space="preserve">
          <source>The 2nd and 3rd arguments to the scalar SQL function implemenetation, &lt;b&gt;argc&lt;/b&gt; and &lt;b&gt;argv&lt;/b&gt;, are the number of arguments to the SQL function itself and the values for each argument of the SQL function. Argument values can be of any datatype and are thus stored in instances of the &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object. Specific C-language values can be extracted from this object using the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value() family of interfaces&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3229fe36f5dbdb9bc16916270b8799663f2b4b3a" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">Второй аргумент функции обратного вызова sqlite3_exec () - это количество столбцов в результате. Третий аргумент обратного вызова sqlite3_exec () - это массив указателей на строки, полученных как будто из &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; , по одному для каждого столбца. Если элемент результирующей строки имеет значение NULL, то соответствующий указатель строки для обратного вызова sqlite3_exec () является указателем NULL. Четвертый аргумент обратного вызова sqlite3_exec () - это массив указателей на строки, где каждая запись представляет имя соответствующего столбца результата, полученное из &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8004ad0fbc670903554e47567c2e9bf84a736bf" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">Второй аргумент функции обратного вызова sqlite3_exec () - это количество столбцов в результате. Третий аргумент обратного вызова sqlite3_exec () - это массив указателей на строки, полученных как будто из &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; , по одному для каждого столбца. Если элемент результирующей строки имеет значение NULL, то соответствующий указатель строки для обратного вызова sqlite3_exec () является указателем NULL. Четвертый аргумент обратного вызова sqlite3_exec () - это массив указателей на строки, где каждая запись представляет имя соответствующего столбца результата, полученное из &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fbe9436fd9db92826bf0f5761a30ba124b84870" translate="yes" xml:space="preserve">
          <source>The 31 result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de71717ad00d5c6da7753059b7611f9841b1d459" translate="yes" xml:space="preserve">
          <source>The 32-bit integer value P1 is written into register P2.</source>
          <target state="translated">В регистр P2 записывается 32-битное целое значение P1.</target>
        </trans-unit>
        <trans-unit id="0fa6dc01b797fc02e2f48692d3a39f9204d77ab0" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 128 in the WAL-index header is called the &quot;nBackfill&quot;. this field holds the number of frames in the WAL file which have been copied back into the main database.</source>
          <target state="translated">32-битное беззнаковое целое число со смещением 128 в заголовке WAL-index называется &quot;nBackfill&quot;.В этом поле хранится количество кадров в файле WAL,которые были скопированы обратно в основную БД.</target>
        </trans-unit>
        <trans-unit id="e3de01c332227a39275dbc5888bb606fa2949671" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 16 (and repeated at offset 64) is the number of valid frames in the WAL. Because WAL frame are numbered starting with 1, mxFrame is also the index of the last valid commit frame in the WAL. A commit frame is a frame that has a non-zero &quot;size of database&quot; value in bytes 4 through 7 of the frame header, and that indicates the end of a transaction.</source>
          <target state="translated">32-битное беззнаковое целое число со смещением 16 (и повторяющееся со смещением 64)-это количество действительных кадров в WAL.Поскольку WAL-кадр нумеруется начиная с 1,mxFrame также является индексом последнего действительного кадра коммита в WAL.Фрейм фиксации-это кадр,имеющий ненулевое значение &quot;размера базы данных&quot; в байтах с 4 по 7 заголовка кадра,и указывающий на конец транзакции.</target>
        </trans-unit>
        <trans-unit id="ae0f85b04e7fa9cc6d6fac1b8bbc475f7f896833" translate="yes" xml:space="preserve">
          <source>The 35% figure is based on running tests on every machine that the author has easily at hand. Some reviewers of this article report that SQLite has higher latency than direct I/O on their systems. We do not yet understand the difference. We also see indications that SQLite does not perform as well as direct I/O when experiments are run using a cold filesystem cache.</source>
          <target state="translated">Цифра 35% основана на выполнении тестов на каждой машине,которая легко доступна автору.Некоторые рецензенты этой статьи сообщают,что SQLite имеет более высокую латентность,чем прямой ввод-вывод на своих системах.Мы пока не понимаем разницы.Мы также видим признаки того,что SQLite не работает так хорошо,как при прямом вводе/выводе,когда эксперименты выполняются с использованием холодного кэша файловой системы.</target>
        </trans-unit>
        <trans-unit id="99484295a38d44d61a5164088be45dfe447bd6fb" translate="yes" xml:space="preserve">
          <source>The 3rd parameter of the built-in SUBSTR() function is now optional.</source>
          <target state="translated">Третий параметр встроенной функции SUBSTR()теперь является необязательным.</target>
        </trans-unit>
        <trans-unit id="b03a25a4d8213505aa58b43a2a9ec61a89d8bd66" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 28 into the header stores the size of the database file in pages. If this in-header datasize size is not valid (see the next paragraph), then the database size is computed by looking at the actual size of the database file. Older versions of SQLite ignored the in-header database size and used the actual file size exclusively. Newer versions of SQLite use the in-header database size if it is available but fall back to the actual file size if the in-header database size is not valid.</source>
          <target state="translated">4-байтовое биг-ендианное целое число со смещением 28 в заголовок хранит размер файла БД в страницах.Если размер заголовочного файла данных недействителен (см.следующий параграф),то размер БД вычисляется по фактическому размеру файла БД.Более старые версии SQLite игнорировали размер заголовочной базы данных и использовали только фактический размер файла.Более новые версии SQLite используют размер заголовочной базы данных,если она доступна,но возвращаются к размеру действительного файла,если размер заголовочной базы данных недействителен.</target>
        </trans-unit>
        <trans-unit id="ef2a0b06932c2dcd259f9b038635b5911a22f5bb" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 56 determines the encoding used for all text strings stored in the database. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be. No other values are allowed. The sqlite3.h header file defines C-preprocessor macros SQLITE_UTF8 as 1, SQLITE_UTF16LE as 2, and SQLITE_UTF16BE as 3, to use in place of the numeric codes for the text encoding.</source>
          <target state="translated">4-байтовое биг-ендианное целое число со смещением 56 определяет кодировку,используемую для всех текстовых строк,хранящихся в БД.Значение 1 означает UTF-8.Значение 2 означает UTF-16le.Значение 3 означает UTF-16be.Другие значения не допускаются.Заголовочный файл sqlite3.h определяет макросы C-препроцессора SQLITE_UTF8 как 1,SQLITE_UTF16LE как 2 и SQLITE_UTF16BE как 3 для использования вместо числовых кодов для кодирования текста.</target>
        </trans-unit>
        <trans-unit id="59780a9139eaaa69dc8ff8373215df2d27399d4a" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 60 is the user version which is set and queried by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;. The user version is not used by SQLite.</source>
          <target state="translated">4-байтовое целое число с &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;прямым порядком&lt;/a&gt; байтов по смещению 60 - это версия пользователя, которая устанавливается и запрашивается прагмой user_version . Пользовательская версия не используется SQLite.</target>
        </trans-unit>
        <trans-unit id="b59b6e739385a58f0bfd59ff19b74ae1c97b3ca9" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">4-байтовое целое число с &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;прямым&lt;/a&gt; порядком байтов по смещению 68 является &amp;laquo;идентификатором приложения&amp;raquo;, который может быть установлен командой PRAGMA application_id для идентификации базы данных как принадлежащей или связанной с конкретным приложением. Идентификатор приложения предназначен для файлов базы данных, используемых в качестве &lt;a href=&quot;appfileformat&quot;&gt;файлового формата приложения&lt;/a&gt; . Идентификатор приложения может использоваться такими утилитами, как &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file (1),&lt;/a&gt; для определения конкретного типа файла, а не просто для создания отчетов &amp;laquo;База данных SQLite3&amp;raquo;. Список присвоенных идентификаторов приложений можно увидеть, &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;обратившись к&lt;/a&gt; файлу magic.txt в исходном репозитории SQLite.</target>
        </trans-unit>
        <trans-unit id="38784fbab26020d518650e3bc21dc48be395b9c0" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f0a53720eada7bca96ab5b1af017ecee35257f" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 96 stores the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; value for the SQLite library that most recently modified the database file. The 4-byte big-endian integer at offset 92 is the value of the &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; when the version number was stored. The integer at offset 92 indicates which transaction the version number is valid for and is sometimes called the &quot;version-valid-for number&quot;.</source>
          <target state="translated">4-байтовое целое число с &lt;a href=&quot;c3ref/c_source_id&quot;&gt;прямым порядком&lt;/a&gt; байтов по смещению 96 хранит значение SQLITE_VERSION_NUMBER для библиотеки SQLite, которая последней изменила файл базы данных. 4-байтовое целое число с прямым порядком байтов по смещению 92 - это значение &lt;a href=&quot;fileformat2#chngctr&quot;&gt;счетчика изменений,&lt;/a&gt; когда номер версии был сохранен. Целое число со смещением 92 указывает, для какой транзакции действителен номер версии, и иногда его называют &amp;laquo;номером версии, допустимой для&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b2d1137ce6ac9536674089958f7183c5cef074dd" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian signed integer at offset 48 is the suggested cache size in pages for the database file. The value is a suggestion only and SQLite is under no obligation to honor it. The absolute value of the integer is used as the suggested size. The suggested cache size can be set using the &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">4-байтовое целое число со знаком прямого порядка байтов по смещению 48 - это рекомендуемый размер кэша в страницах для файла базы данных. Значение является всего лишь предложением, и SQLite не обязана его соблюдать. Абсолютное значение целого числа используется в качестве предлагаемого размера. Предлагаемый размер кеша может быть установлен с помощью &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;прагмы default_cache_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53d2cb69bc07058d95cd55a2bf0ace6be99d3312" translate="yes" xml:space="preserve">
          <source>The 4th parameter as more recently be extended with additional flag bits to convey additional information about the function. The additional bits include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a28f7f4f27954a38f3fd9a37598b5ec1312b94e" translate="yes" xml:space="preserve">
          <source>The 61 extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297d64bcfea641daf22ef24136ed89bff8802a91" translate="yes" xml:space="preserve">
          <source>The 71 extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7632ae3463f74e8bc40ebd99c8e14ebcad0e1acf" translate="yes" xml:space="preserve">
          <source>The 8 or 12 byte b-tree page header</source>
          <target state="translated">8 или 12-байтовый b-деревянный заголовок страницы</target>
        </trans-unit>
        <trans-unit id="f5b2d0b06ac8eecacdf1f9fc8ceb4463be132806" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; флаг означает , что файл должен быть удален , если он закрыт. &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; будет установлен для TEMP баз данных и их журналов, переходных баз данных и subjournals.</target>
        </trans-unit>
        <trans-unit id="113a719d1e8937c17801bea84f7fbfbe80a9d62b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; флаг всегда используется в сочетании с &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; флагом, которые оба непосредственно аналогичны флагам O_EXCL и O_CREAT в POSIX открытых () API. Флаг SQLITE_OPEN_EXCLUSIVE в сочетании с SQLITE_OPEN_CREATE используется для обозначения того, что файл всегда должен создаваться и что это ошибка, если он уже существует. это</target>
        </trans-unit>
        <trans-unit id="81aa4d01093839a3328717a25027872953f919a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; препроцессор макросов в заголовке sqlite3.h принимает значение строкового литерала , который является версией SQLite в формате &amp;laquo;XYZ&amp;raquo; , где Х представляет собой основной номер версии (всегда 3 для SQLite3) и Y это номер версии и незначительные Z является номер выпуска. &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; С препроцессора макрос преобразуется в целое число со значением (X * + Y 1000000 * 1000 + Z) , где X, Y и Z имеют те же номера , используемые в &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; . SQLITE_VERSION_NUMBER для любого данного выпуска SQLite также будет больше, чем выпуск, из которого он получен. Либо Y будет оставаться постоянным, а Z будет увеличиваться, либо Y будет увеличиваться, а Z будет сброшено на ноль.</target>
        </trans-unit>
        <trans-unit id="f3c03446112462ee2b9d55caa1b76200b09c27b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt; engine is a proprietary fuzz tester. Other &lt;a href=&quot;testing#fuzztesting&quot;&gt;fuzzers for SQLite&lt;/a&gt; mutate either the SQL inputs or the database file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and is thus able to reach new error states. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM with a custom mutator. Starting from 236 seed files, the dbsqlfuzz fuzzer has examined many tens of millions of mutations, resulting in 63493 distinct test cases that form the basis of each new fuzzing session. Dbsqlfuzz helps ensure that SQLite is robust against attack via malicious SQL or database inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9c9b7b18b9277de9026053f84f4ad8b81cc8b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt; engine is a proprietary fuzz tester. Other &lt;a href=&quot;testing#fuzztesting&quot;&gt;fuzzers for SQLite&lt;/a&gt; mutate either the SQL inputs or the database file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and is thus able to reach new error states. Dbsqlfuzz is built using the &lt;a href=&quot;https://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM with a custom mutator. Starting from 236 seed files, the dbsqlfuzz fuzzer has examined many tens of millions of mutations, resulting in 63493 distinct test cases that form the basis of each new fuzzing session. Dbsqlfuzz helps ensure that SQLite is robust against attack via malicious SQL or database inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c75916c07cfb8eae73aa66b68a34bf29c22777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;Подключение к базе данных&lt;/a&gt; указателя D в вызове &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt (D, S)&lt;/a&gt; должен относиться к соединению с открытой базой данных и , в частности , не должны быть указателем NULL.</target>
        </trans-unit>
        <trans-unit id="5bf64bb75c15b60e54d733e7fb04737bfbdcc130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">Сам объект &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; частично потокобезопасен. Несколько потоков могут безопасно выполнять несколько одновременных вызовов sqlite3_backup_step (). Однако API sqlite3_backup_remaining () и sqlite3_backup_pagecount (), строго говоря, не являются потокобезопасными. Если они вызываются одновременно с вызовом sqlite3_backup_step () другого потока, возможно, они возвращают недопустимые значения.</target>
        </trans-unit>
        <trans-unit id="7b899c2433d199dbb7815bdf0ba2afb729910cf1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob (),&lt;/a&gt; а также встроенная &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;функция&lt;/a&gt; SQL zeroblob могут использоваться для создания блоба с нулевым заполнением для чтения или записи с использованием интерфейса инкрементального блоба.</target>
        </trans-unit>
        <trans-unit id="243b1f5a94daea2d7cb3ce8a6e46d2fc0337bddb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; отменяет регистрацию процедуры инициализации X, которая была зарегистрирована с использованием предыдущего вызова &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension (X)&lt;/a&gt; . В &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; подпрограмма возвращает 1 , если процедура инициализации X был успешно незарегистрированные и возвращает 0 , если X не был включен в список подпрограмм инициализации.</target>
        </trans-unit>
        <trans-unit id="4d9c76fa5b1b1ce93415a995c6d4d84ffeb6d357" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...) может зарегистрировать альтернативную реализацию кеширования страниц, передав экземпляр структуры sqlite3_pcache_methods2. Во многих приложениях большая часть памяти кучи, выделенной SQLite, используется для кеширования страниц. Реализуя настраиваемый кеш страницы с помощью этого API, приложение может лучше контролировать объем памяти, потребляемой SQLite, способ выделения и освобождения этой памяти, а также политики, используемые для точного определения того, какие части файла базы данных кэшируются и как долго.</target>
        </trans-unit>
        <trans-unit id="5d45a04d8212fde9c0874120a3960331ca779f2b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; выполняет прямой вызов метода xFileControl для объекта &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods,&lt;/a&gt; связанного с конкретной базой данных, указанной вторым аргументом. Имя базы данных - &amp;laquo;main&amp;raquo; для основной базы данных или &amp;laquo;temp&amp;raquo; для базы данных TEMP, или имя, которое появляется после ключевого слова AS для баз данных, добавленных с помощью команды &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL. Указатель NULL может использоваться вместо &amp;laquo;main&amp;raquo; для ссылки на основной файл базы данных. Третий и четвертый параметры этой подпрограммы передаются напрямую второму и третьему параметрам метода xFileControl. Возвращаемое значение метода xFileControl становится возвращаемым значением этой процедуры.</target>
        </trans-unit>
        <trans-unit id="1190e60391b896900656c0ed0c45b80a24b61942" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;Sqlite3_int64&lt;/a&gt; переменной , на которую указывает параметр T будет установлен на общее количество строк осмотрен всех итераций X-го цикла.</target>
        </trans-unit>
        <trans-unit id="68df0918aa353458edcd2a2adfa1d6ea97cffd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;Sqlite3_int64&lt;/a&gt; переменной , на которую указывает параметр Т будет установлен на общее число раз , что Х-го цикла, закончилась.</target>
        </trans-unit>
        <trans-unit id="a4d4c03ef6c7fed4df5e7b2b60cea13e3845bb99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950c7d09e714f7025b91b049ed110aaf3de8d496" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e18bfb46029f881a46fabedb7acfaf5c4cc5dda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; записывает сообщение в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок,&lt;/a&gt; созданный параметром &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; для &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; . Если ведение журнала включено, строка zFormat и последующие аргументы используются с &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; для генерации окончательной выходной строки.</target>
        </trans-unit>
        <trans-unit id="a8d3a9c5e86973d6925c26336eb4b86036d70cb6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">В &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; подпрограмма возвращает число байт памяти в настоящее время в обращении (malloced но не освобожденные). В &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; подпрограмма возвращает максимальное значение &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , так как знак высокой воды последнего сброс. Значения, возвращаемые &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater (),&lt;/a&gt; включают любые накладные расходы, добавленные SQLite в его реализацию &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , но не накладные расходы, добавленные любыми базовыми подпрограммами системной библиотеки, которые может вызывать &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc30f41b86e312b265eb4e71d4d9a6acf99b0d1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; принимает единственный аргумент, который является одной из этих целочисленных констант.</target>
        </trans-unit>
        <trans-unit id="895178f8a3d57626d41012b259bf092ebaa065ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count (D)&lt;/a&gt; возвращает количество столбцов в строке, которая вставляется, обновляется или удаляется.</target>
        </trans-unit>
        <trans-unit id="92f98e455bc2921056f5d6b0ffb541ab9df1ffaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth (D)&lt;/a&gt; возвращает 0, если обратный вызов перед обновлением был вызван в результате прямой операции вставки, обновления или удаления; или 1 для вставок, обновлений или удалений, вызываемых триггерами верхнего уровня; или 2 для изменений, вызванных триггерами, вызванными триггерами верхнего уровня; и так далее.</target>
        </trans-unit>
        <trans-unit id="e08d4a7c0ce7457f9dab2dfa8af96af8deafb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; регистрирует функцию обратного вызова, которая вызывается перед каждой операцией &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; в таблице базы данных. В лучшем случае один preupdate крючок может быть зарегистрирован в то время , на одном &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; ; каждый вызов &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; отменяет предыдущую настройку. Ловушка preupdate отключается путем вызова &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; с указателем NULL в качестве второго параметра. Третий параметр &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; передается в качестве первого параметра обратным вызовам.</target>
        </trans-unit>
        <trans-unit id="76ad44c525d8f71caf7bed2b7e946c3d8c4e4d51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new (D, N, P)&lt;/a&gt; записывает в P указатель на &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенное значение sqlite3_value,&lt;/a&gt; которое содержит значение N-го столбца строки таблицы после его обновления. Параметр N должен быть между 0 и на единицу меньше количества столбцов, иначе поведение будет неопределенным. Это должно использоваться только в обратных вызовах SQLITE_INSERT и SQLITE_UPDATE перед обновлением; если он используется обратным вызовом SQLITE_DELETE, то поведение не определено. Значение &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value, на&lt;/a&gt; которое указывает P, будет уничтожено при возврате обратного вызова preupdate.</target>
        </trans-unit>
        <trans-unit id="1c708fa87b4305f6c6c7b152f77487e32500d735" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth ()&lt;/a&gt; предоставляют дополнительную информацию о событии preupdate. Эти подпрограммы можно вызывать только из обратного вызова перед обновлением. Вызов любой из этих подпрограмм вне функции обратного вызова перед обновлением или с указателем &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, который отличается от указателя, предоставленного для обратного вызова перед обновлением, приводит к неопределенному и, вероятно, нежелательному поведению.</target>
        </trans-unit>
        <trans-unit id="62645acd92fc3d494d833d1a2acf99fc550b25a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old (D, N, P)&lt;/a&gt; записывает в P указатель на &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенное значение sqlite3_value,&lt;/a&gt; которое содержит значение N-го столбца строки таблицы до его обновления. Параметр N должен быть между 0 и на единицу меньше количества столбцов, иначе поведение будет неопределенным. Это должно использоваться только в обратных вызовах SQLITE_UPDATE и SQLITE_DELETE перед обновлением; если он используется обратным вызовом SQLITE_INSERT, то поведение не определено. Значение &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value, на&lt;/a&gt; которое указывает P, будет уничтожено при возврате обратного вызова preupdate.</target>
        </trans-unit>
        <trans-unit id="73b2a32ae166fcb0b54e0a6a66b0c37e428124e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; не изменяет значения каких-либо &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;привязок&lt;/a&gt; в &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленном операторе&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="24aaeaf525c4a02afa566b3b6fde01711f410b96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; сбрасывает &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; S обратно в начало своей программы.</target>
        </trans-unit>
        <trans-unit id="5ec7f66ae2478b5bf1fba7004c6f9eca0c47bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">Функция &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;обратного вызова авторизатора&lt;/a&gt; должна возвращать либо &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK,&lt;/a&gt; либо одну из этих двух констант, чтобы сигнализировать SQLite, разрешено действие или нет. Дополнительную информацию см. В &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;документации авторизатора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de889cb07b2c7dd83d04327e082d9b8afd75421b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; регистрирует функцию обратного вызова, которая вызывается для авторизации определенных действий оператора SQL. Второй параметр обратного вызова - это целочисленный код, указывающий, какое действие разрешается. Это целочисленные коды действий, которые может быть передан обратному вызову авторизатора.</target>
        </trans-unit>
        <trans-unit id="b20fbf1dd1eb586565d476c6ea4477e75271549a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">Объект &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; возвращенный в результате успешного вызова &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get (),&lt;/a&gt; должен быть освобожден с помощью &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free (),&lt;/a&gt; чтобы избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="775754ed627fe2a2cc8e3c07dc04d7c2771ef634" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="14be7fcf3129f0807a23ee14219023eee52d1a02" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free (P)&lt;/a&gt; уничтожает &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. В конечном итоге приложение должно освободить каждый объект &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; используя эту процедуру, чтобы избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="3c246e9ef7aa9d8e18a838b47761936cd8a2acc5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="2146a577e5e49a77b490e29aca2d82e371ec702c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; пытается создать новый объект &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; который записывает текущее состояние схемы S в соединении с базой данных D. В случае успеха интерфейс &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; записывает указатель на вновь созданный &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; в * P и возвращает SQLITE_OK. Если при вызове этой функции в схеме S еще не открыта транзакция чтения, она открывается автоматически.</target>
        </trans-unit>
        <trans-unit id="efd7fc3c3c9a64e738f23c02f6e6fbe25f03ae8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="b4e3c98131317b43afc18d358e2869af93b46671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; либо запускает новую транзакцию чтения, либо обновляет существующую для схемы S &lt;a href=&quot;#sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; D, так что транзакция чтения относится к историческому &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;снимку&lt;/a&gt; P, а не к самому последнему изменению в базе данных. Интерфейс &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; возвращает SQLITE_OK в случае успеха или соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки в&lt;/a&gt; случае неудачи.</target>
        </trans-unit>
        <trans-unit id="83d565fd5c1ee3cccc1b5c10ce8ef575521cca40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append (X, S, N)&lt;/a&gt; добавляет ровно N байтов из строки S в конец объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X. N должно быть неотрицательным. S должен содержать не менее N ненулевых байтов содержимого. Чтобы добавить строку с нулевым символом в конце, используйте вместо этого метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6917c29880e6eab55b32466b3048653ea9692486" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall (X, S)&lt;/a&gt; добавляет полное содержимое строки S с нулевым завершением в конец объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X.</target>
        </trans-unit>
        <trans-unit id="8658941f24fcaee032cb73b6958282aac488a0c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar (X, N, C)&lt;/a&gt; добавляет N копий однобайтового символа C в конец объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X. Этот метод можно использовать, например, для добавления отступов между пробелами.</target>
        </trans-unit>
        <trans-unit id="5cf4ff61e78e32620c83211a0d5e1e3795abc7df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf (X, F, ...)&lt;/a&gt; и &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf (X, F, V)&lt;/a&gt; используют &lt;a href=&quot;printf&quot;&gt;встроенные функции printf&lt;/a&gt; SQLite для добавления форматированного текста в конец объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X.</target>
        </trans-unit>
        <trans-unit id="efc22c6c47d48b515ed10c7b3b7ca6cc54142437" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset (X)&lt;/a&gt; сбрасывает строящуюся строку внутри объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X обратно до нулевой длины в байтах.</target>
        </trans-unit>
        <trans-unit id="7f1ec747ece71d77c655f9a07fae8cab37f0a797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; возвращает текущую длину в байтах динамической строки, строящейся в объекте &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X. Длина, возвращаемая &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; , не включает байт нулевого завершения.</target>
        </trans-unit>
        <trans-unit id="abad991ae0af361a9313d8cfba4c5223a9d4a389" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; возвращает указатель на текущее содержимое динамической строки, строящейся в X. Значение, возвращаемое &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; , управляется объектом sqlite3_str X и может быть освобождено или изменено любым последующим методом того же &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; объект. Приложения не должны использовать указатель, возвращаемый &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; после любого последующего вызова метода для того же объекта. Приложения могут изменять содержимое строки, возвращаемой &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X),&lt;/a&gt; при условии, что они не записывают ни в какие байты вне диапазона от 0 до &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; и не читают и не записывают ни одного байта после любого последующего вызова метода sqlite3_str.</target>
        </trans-unit>
        <trans-unit id="9ed76b8571c1160c10dee5527b0d46210f6deae9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; уничтожает объект sqlite3_str X и возвращает указатель на буфер памяти, полученный из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; который содержит построенную строку. Вызывающее приложение должно передать возвращаемое значение в &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free (),&lt;/a&gt; чтобы избежать утечки памяти. Интерфейс &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; может вернуть указатель NULL, если во время построения строки были обнаружены какие-либо ошибки. Интерфейс &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; также вернет указатель NULL, если длина строки в объекте &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X равна нулю байтов.</target>
        </trans-unit>
        <trans-unit id="1a8bb7e6f2617ebce878cf41863558873c56dd1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; выделяет и инициализирует новый объект &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; . Чтобы избежать утечки памяти, объект, возвращаемый &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (),&lt;/a&gt; должен быть освобожден последующим вызовом &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="283dcdc6097ac99a155d31e274b76b664e287d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; всегда возвращает указатель на действительный объект &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; , хотя в случае ошибки нехватки памяти возвращаемый объект может быть специальным синглтоном, который будет молча отклонять новый текст, всегда возвращать SQLITE_NOMEM из &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode ()&lt;/a&gt; , всегда возвращать 0 для &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length ()&lt;/a&gt; и всегда возвращать NULL из &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; . Всегда безопасно использовать значение, возвращаемое &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D),&lt;/a&gt; в качестве параметра sqlite3_str для любого другого метода &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47a765f2716bbd0a7165479eb04c6ad3833cfd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; возвращает ноль тогда и только тогда, когда строка X совпадает с &lt;a href=&quot;lang_expr#glob&quot;&gt;шаблоном GLOB&lt;/a&gt; P. Определение &lt;a href=&quot;lang_expr#glob&quot;&gt;сопоставления с&lt;/a&gt; шаблоном GLOB, используемое в &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X),&lt;/a&gt; такое же, как и для оператора &amp;laquo;X GLOB P&amp;raquo; в Диалект SQL, понятный SQLite. Функция &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; чувствительна к регистру.</target>
        </trans-unit>
        <trans-unit id="95615e5c78fed3ee43eff0e7b082843f593e6a31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;Sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; API - интерфейсы позволяют приложения и расширения для сравнения содержимого двух буферов , содержащих UTF - 8 строк в случае независимым способом, используя такое же определение &amp;laquo;случая независимости&amp;raquo; , что SQLite использует внутренне при сравнении идентификаторов.</target>
        </trans-unit>
        <trans-unit id="51d8a3ef92ef4d7b314975584d8072e9206e198e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">Функция &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; сопоставляет символы Unicode, но только символы ASCII складываются по регистру.</target>
        </trans-unit>
        <trans-unit id="485ac31bffb8ac065daf3ba2a8161fbdf5039efd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; возвращает ноль тогда и только тогда, когда строка X совпадает с &lt;a href=&quot;lang_expr#like&quot;&gt;шаблоном LIKE&lt;/a&gt; P с escape-символом E. Определение сопоставления с образцом &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE,&lt;/a&gt; используемое в &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E),&lt;/a&gt; такое же, как и для Оператор &amp;laquo;X LIKE P ESCAPE E&amp;raquo; в диалекте SQL, понятном SQLite. Для &amp;laquo;X LIKE P&amp;raquo; без предложения ESCAPE установите для параметра E &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; значение 0. Как и в случае с оператором LIKE, функция &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; нечувствительна к регистру - эквивалентно верхнему и Строчные символы ASCII соответствуют друг другу.</target>
        </trans-unit>
        <trans-unit id="67cdd83f23b0c9baf88d22cb2f2c082de3577118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes (D)&lt;/a&gt; сообщает только количество строк, которые изменились из-за выполнения оператора SQL для соединения с базой данных D. Любые изменения, сделанные другими соединениями с базой данных, игнорируются. Чтобы обнаружить изменения файла базы данных из других подключений к базе данных, используйте команду &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; или &lt;a href=&quot;#sqlite3_file_control&quot;&gt;файловый элемент управления &lt;/a&gt;&lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc4153435020e41ac99ab2b5b83d08f27b98c68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;Sqlite3_wal_autocheckpoint (D, N)&lt;/a&gt; является оберткой &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; , что приводит к любой базе данных на &lt;a href=&quot;#sqlite3&quot;&gt;базу данных соединения&lt;/a&gt; D автоматически &lt;a href=&quot;wal#ckpt&quot;&gt;контрольную точку&lt;/a&gt; после совершения сделки , если есть N или больше кадров в &lt;a href=&quot;wal&quot;&gt;записи вперед лог&lt;/a&gt; - файле. Передача нуля или отрицательного значения в качестве параметра nFrame полностью отключает автоматические контрольные точки.</target>
        </trans-unit>
        <trans-unit id="9142f5b65b53643523fc33889c4ba6acff8188e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">Функция &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; используется для регистрации обратного вызова, который вызывается каждый раз, когда данные фиксируются в базе данных в режиме wal.</target>
        </trans-unit>
        <trans-unit id="fdbc2004b6063417b2874cd07563f5073fb2461b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0804c63302651c02a306eb7ec9ff35797d83276d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; файлы управление может быть вызвано SQLite на файл базы данных ручки вскоре после того, как он открыт для того , чтобы предоставить пользовательские VFS с доступом к соединениям занят обработчик обратного вызова. Аргумент имеет тип (void **) - массив из двух (void *) значений. Первый (void *) фактически указывает на функцию типа (int (*) (void *)). Чтобы вызвать обработчик занятости соединений, эта функция должна быть вызвана со вторым (void *) в массиве в качестве единственного аргумента. Если возвращается ненулевое значение, то операцию следует повторить. Если он возвращает ноль, пользовательская VFS должна отказаться от текущей операции.</target>
        </trans-unit>
        <trans-unit id="e16ec9bd7cc655e1fcca3234a2d80781961dcf25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; используется для запроса того, чтобы VFS расширяла и усекала файл базы данных кусками размера, указанного пользователем. Четвертый аргумент &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; должен указывать на целое число (тип int), содержащее новый размер блока, который будет использоваться для указанной базы данных. Выделение файлового пространства базы данных большими фрагментами (скажем, по 1 МБ за раз) может уменьшить фрагментацию файловой системы и повысить производительность в некоторых системах.</target>
        </trans-unit>
        <trans-unit id="55799a140d15462e73ef05abf1db855a8aa627ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23adb4e434c478e58b40c24db57f497a0e6e59c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196a41f980c38337225c4ba413e0b1dc0b2b471a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; заставляет все операции записи с момента предыдущего успешного вызова &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; выполняться атомарно. Этот файловый элемент управления возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; тогда и только тогда, когда все записи были выполнены успешно и были зафиксированы в постоянном хранилище. Независимо от того, успешен он или нет, этот файловый элемент управления выводит файловый дескриптор из режима пакетной записи, так что все последующие операции записи независимы. SQLite никогда не вызовет SQLITE_FCNTL_COMMIT_ATOMIC_WRITE без предварительного успешного вызова &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed7c39458516ed31456486d668f266799517f0b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; генерируется внутри SQLite и отправляется в VFS сразу после того, как транзакция была зафиксирована, но до того, как база данных будет разблокирована. VFS, которым этот сигнал не нужен, должны игнорировать этот код операции. Приложения не должны вызывать &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; с этим кодом операции, так как это может нарушить работу специализированных VFS, которые в этом нуждаются.</target>
        </trans-unit>
        <trans-unit id="a6067fb898268faa568cf0d8b727509a1e63a822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; используется для обнаружения изменений в файле базы данных. Аргумент - указатель на 32-битовое целое число без знака. &amp;laquo;Версия данных&amp;raquo; для пейджера записывается в указатель. &amp;laquo;Версия данных&amp;raquo; изменяется всякий раз, когда происходит какое-либо изменение в соответствующем файле базы данных, либо с помощью операторов SQL в том же соединении с базой данных, либо посредством транзакций, совершенных отдельными соединениями с базой данных, возможно, в других процессах. Интерфейс &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; можно использовать, чтобы узнать, изменилась ли какая-либо база данных в соединении, но этот интерфейс реагирует на изменения как на TEMP, так и на MAIN, и не предоставляет механизма для обнаружения изменений только в MAIN. Кроме того, &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;интерфейс реагирует только на внутренние изменения и пропускает изменения, сделанные другими соединениями с базой данных. Команда &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; предоставляет механизм для обнаружения изменений в одной подключенной базе данных, которые происходят из-за других подключений к базе данных, но пропускает изменения, реализованные подключением к базе данных, на котором она вызывается. Этот файловый контроль - единственный механизм для обнаружения изменений, которые происходят внутри или снаружи и которые связаны с конкретной присоединенной базой данных.</target>
        </trans-unit>
        <trans-unit id="e9a73ef11b02c7c1ef7f3e1f806173140bf3d029" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a2fa29af05eafc8a58031e6a08762e72b9ebb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; используется для получения указателя на объект &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file,&lt;/a&gt; связанный с конкретным подключением к базе данных. См. Также &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32fc3ec6f9212eb93de60bbea8de22f4f5c0720b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; управления файлами интерпретирует свой аргумент как указатель на целое число и записывает логическое значение в этом целое число в зависимости от наличия или отсутствия файла был переименован, перемещен или удален , так как он был впервые открыт.</target>
        </trans-unit>
        <trans-unit id="961fafabf95f8005cd6aacb0ba427c7a66f5ca95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; опкод используется для получения указателя на &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; объект , связанный с файлом журнал (либо &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнал откат&lt;/a&gt; или &lt;a href=&quot;wal&quot;&gt;журнал запись вперед&lt;/a&gt; ) для конкретного соединения с базой данных. См. Также &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3359a645510d53c409e1e871158229645d3789b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; используется для отладки. Этот код операции заставляет метод xFileControl записывать текущее состояние блокировки (одно из &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; или &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; ) в целое число, на которое указывает аргумент pArg. Эта возможность используется во время тестирования и доступна только при использовании параметра времени компиляции SQLITE_TEST.</target>
        </trans-unit>
        <trans-unit id="413d8e1b0a9fd900669cb69e73b3dca110ff8c2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; заставляет попытки получить блокировку файла с помощью методов xLock или xShmLock VFS для ожидания до M миллисекунд перед неудачей, где M - единственный целочисленный параметр без знака.</target>
        </trans-unit>
        <trans-unit id="15909a890c9f03d44aa2dc2921d58c760b545e1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a69e4da16c0af72de938b51b675221a8706b54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; управления файлами используется для запроса или установить максимальное число байтов , которые будут использоваться для памяти отображенного ввода / вывода. Аргумент является указателем на значение типа sqlite3_int64, которое является рекомендуемым максимальным количеством байтов в файле для отображения памяти. Указатель заменяется старым значением. Предел не изменяется, если изначально указанное значение отрицательное, поэтому текущий предел можно запросить, передав указатель на отрицательное число. Этот файловый контроль используется внутри для реализации &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d526543f15c2ce77f0461ecf7fe44c9004bea17a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; вызывается SQLite после открытия транзакции записи, чтобы указать, что, если по какой-либо причине не будет выполнен откат, весь файл базы данных будет перезаписан текущей транзакцией. Это используется операциями ВАКУУМ.</target>
        </trans-unit>
        <trans-unit id="5ebd2a70a799339bb0872257764cf8c08eda9ecd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; используется для установки или запроса постоянной настройки &lt;a href=&quot;wal&quot;&gt;журнала&lt;/a&gt; предварительной записи . По умолчанию вспомогательный журнал упреждающей записи ( &lt;a href=&quot;wal#walfile&quot;&gt;файл WAL&lt;/a&gt; ) и файлы разделяемой памяти, используемые для управления транзакциями, автоматически удаляются при закрытии последнего подключения к базе данных. Установка постоянного режима WAL приводит к тому, что эти файлы сохраняются после закрытия. Сохранение файлов полезно, когда другие процессы, у которых нет разрешения на запись в каталог, содержащий файл базы данных, хотят прочитать файл базы данных, поскольку файлы WAL и разделяемой памяти должны существовать, чтобы база данных была доступна для чтения. Четвертый параметр &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt;для этого кода операции должен быть указатель на целое число. Это целое число равно 0 для отключения постоянного режима WAL или 1 для включения постоянного режима WAL. Если целое число равно -1, оно перезаписывается текущим параметром сохранения WAL.</target>
        </trans-unit>
        <trans-unit id="fdccf2fe8da7ee0d8c5941a2ea211306829a9588" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; используется для установки или запроса постоянной настройки &amp;laquo;PowerSafe-overwrite&amp;raquo; или &amp;laquo;PSOW&amp;raquo;. Параметр PSOW определяет &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; немного методов xDeviceCharacteristics. Четвертый параметр &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; для этого кода операции должен быть указателем на целое число. Это целое число равно 0, чтобы отключить режим нулевого урона, или 1, чтобы включить режим нулевого урона. Если целое число равно -1, то оно перезаписывается текущим значением режима нулевого повреждения.</target>
        </trans-unit>
        <trans-unit id="7f192c2e63c8633453fa1eae93e0c07df64cf07f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; реализуется специальной VFS, используемой только расширением RBU. Все остальные VFS должны возвращать SQLITE_NOTFOUND для этого кода операции.</target>
        </trans-unit>
        <trans-unit id="dbf9a50cfd48cde386829709800477dc50bcc565" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; вызывает откат всех операций записи с момента предыдущего успешного вызова &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; . Этот файловый элемент управления выводит файловый дескриптор из режима пакетной записи, так что все последующие операции записи независимы. SQLite никогда не будет вызывать SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE без предварительного успешного вызова &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3dd434f5b5d6086654ad44e0af5b3fa3e940b9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; используется SQLite, чтобы дать слою VFS подсказку о том, насколько большим будет файл базы данных во время текущей транзакции. Этот намек не гарантирует точность, но часто бывает близок. Базовая VFS может выбрать предварительное выделение файлового пространства базы данных на основе этой подсказки, чтобы ускорить запись в файл базы данных.</target>
        </trans-unit>
        <trans-unit id="97cd9ce5f443d3219025ca93221b345486932d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; используется VFS в памяти, которая реализует &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; для установки верхней границы размера базы данных в памяти. Аргумент - указатель на &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; . Если указанное целое число отрицательно, то оно заполняется текущим пределом. В противном случае устанавливается максимальное значение из указанного целого числа и текущего размера базы данных. Указанное целое число установлено на новый предел.</target>
        </trans-unit>
        <trans-unit id="3a6ee4f80c9cf2b24ebb8343bd1162955c7d2500" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; генерируется внутри SQLite и отправляется в VFS непосредственно перед вызовом метода xSync в дескрипторе файла базы данных. Или, если метод xSync не вызывается из-за того, что пользователь настроил SQLite с &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF,&lt;/a&gt; он вызывается вместо метода xSync. В большинстве случаев аргумент указателя, передаваемый с этим файловым элементом управления, имеет значение NULL. Однако, если файл базы данных синхронизируется как часть фиксации нескольких баз данных, аргумент указывает на строку с завершающим нулем, содержащую имя файла главного журнала транзакций. VFS, которым этот сигнал не нужен, должны игнорировать этот код операции. Приложения не должны вызывать &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; с этим кодом операции, так как это может нарушить работу специализированных VFS, которым он действительно нужен.</target>
        </trans-unit>
        <trans-unit id="5178975b67a8618a8b0176ac061e8db0d71f5de9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105a39338a53cf76076319343b91a58b713c591f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; управления файлами предоставляет консультационную информацию для VFS о том , что высшие слои SQLite стека делают. Этот файловый элемент управления используется некоторыми &lt;a href=&quot;vfs#shim&quot;&gt;прокладками&lt;/a&gt; отслеживания активности VFS . Аргумент - строка с нулевым символом в конце. Более высокие уровни в стеке SQLite могут генерировать экземпляры этого файлового &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;элемента&lt;/a&gt; управления, если включена опция времени компиляции SQLITE_USE_FCNTL_TRACE .</target>
        </trans-unit>
        <trans-unit id="10a39c75085aed62eed16a6bd93eb299fac8af13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; опкод может быть использован для получения имен всех &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; в стеке VFS. Имена всех прокладок VFS и последняя VFS нижнего уровня записываются в память, полученную из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; а результат сохраняется в переменной char *, на которую указывает четвертый параметр &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; . Вызывающий абонент отвечает за освобождение памяти по завершении. Как и в случае со всеми действиями по управлению файлами, нет никакой гарантии, что это действительно что-то сделает. Вызывающие должны инициализировать переменную char * указателем NULL в случае, если этот файловый контроль не реализован. Этот файл-контроль предназначен только для диагностического использования.</target>
        </trans-unit>
        <trans-unit id="a0de6e2585567c94a4d2150e4d89a4457d85ed27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; находит указатель на &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; верхнего уровня, которые используются в настоящее время. Аргумент X в sqlite3_file_control (db, SQLITE_FCNTL_VFS_POINTER, X) должен иметь тип &amp;laquo; &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&amp;raquo;. Эти коды операций устанавливают * X как указатель на VFS верхнего уровня. Если в стеке несколько прокладок VFS, этот код операции находит только самую верхнюю прокладку.</target>
        </trans-unit>
        <trans-unit id="6fb5c486ab423108118235eb419e942dcdffc3fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; является сигналом к слою VFS , что это может быть выгодно , чтобы блокировать на следующей блокировке WAL , если блокировка не доступна немедленно. Подсистема WAL выдает этот сигнал в редких случаях, чтобы устранить проблему с инверсией приоритета. Приложения &lt;em&gt;не&lt;/em&gt; должны использовать этот файловый контроль.</target>
        </trans-unit>
        <trans-unit id="2324c4dab632501938725b9d6af72b57f5294994" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; используется для настройки автоматического числа повторов и интервалов для определенных операций дискового ввода-вывода для Windows &lt;a href=&quot;vfs&quot;&gt;VFS.&lt;/a&gt;для обеспечения устойчивости при наличии антивирусных программ. По умолчанию Windows VFS будет повторять операции чтения, записи и удаления файлов до 10 раз с задержкой 25 миллисекунд перед первой попыткой и с увеличением задержки на дополнительные 25 миллисекунд при каждой последующей попытке. Этот код операции позволяет настроить эти два значения (10 попыток и 25 миллисекунд задержки). Значения изменяются для всех подключений к базе данных в рамках одного процесса. Аргумент - это указатель на массив из двух целых чисел, где первое целое число - это новый счетчик повторов, а второе целое число - это задержка. Если любое из целых чисел является отрицательным, то параметр не изменяется, а вместо этого предыдущее значение этого параметра записывается в запись массива, позволяя запросить текущие параметры повторной попытки.Параметр zDbName игнорируется.</target>
        </trans-unit>
        <trans-unit id="257792bb90d40cbd5be070de917b57c36a5f9cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; может использоваться для получения базового собственного дескриптора файла, связанного с дескриптором файла. Этот файловый элемент управления интерпретирует свой аргумент как указатель на собственный дескриптор файла и записывает туда полученное значение.</target>
        </trans-unit>
        <trans-unit id="774ea185734630483687c4bdf35dc5a0169545c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; используется для отладки. Этот код операции заставляет метод xFileControl заменять дескриптор файла на тот, на который указывает аргумент pArg. Эта возможность используется во время тестирования и должна поддерживаться только тогда, когда определен SQLITE_TEST.</target>
        </trans-unit>
        <trans-unit id="6d8e8025bf5df9df0de6e9fce45f3dc3f3a1832f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; реализуется только zipvfs. Все остальные VFS должны возвращать SQLITE_NOTFOUND для этого кода операции.</target>
        </trans-unit>
        <trans-unit id="2a84f41bb71a501decc458aa53d2eb6f639dc064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">Параметр &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TRACE_SIZE_LIMIT можно использовать для ограничения длины расширения &lt;a href=&quot;../lang_expr#varparam&quot;&gt;связанного параметра&lt;/a&gt; в выводе sqlite3_trace ().</target>
        </trans-unit>
        <trans-unit id="a6d12472a003010a0b08bc4775382d299187ba70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">Параметр &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TRACE_SIZE_LIMIT ограничивает размер расширений связанных параметров. Параметр &lt;a href=&quot;../compile#omit_trace&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_OMIT_TRACE заставляет sqlite3_expanded_sql () всегда возвращать NULL.</target>
        </trans-unit>
        <trans-unit id="7fbc9bba97b7220d8d7ecc905032c6bd233e87c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;Data_store_directory прагма&lt;/a&gt; может изменять эту переменную и вызвать его точку к памяти , полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; . Кроме того, &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;прагма data_store_directory&lt;/a&gt; всегда предполагает, что любая строка, на которую указывает эта переменная, хранится в памяти, полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc,&lt;/a&gt; и прагма может попытаться освободить эту память с помощью &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt; . Следовательно, если эта переменная изменяется напрямую, либо она должна быть сделана NULL, либо указывать на память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc,&lt;/a&gt; в &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;противном&lt;/a&gt; случае следует избегать использования прагмы data_store_directory .</target>
        </trans-unit>
        <trans-unit id="f9eb53bad0c35cc3dcade82b9f30796bebe98ba9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">Оператор &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4683a2e9a942c25fe816aae1882f9a79405f5686" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;Temp_store_directory прагма&lt;/a&gt; может изменять эту переменную и вызвать его точку к памяти , полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; . Кроме того, &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;прагма temp_store_directory&lt;/a&gt; всегда предполагает, что любая строка, на которую указывает эта переменная, хранится в памяти, полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc,&lt;/a&gt; и прагма может попытаться освободить эту память с помощью &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt; . Следовательно, если эта переменная изменяется напрямую, либо она должна быть сделана NULL или указывать на память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc,&lt;/a&gt; либо следует избегать использования &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;прагмы temp_store_directory&lt;/a&gt; . За исключением случаев, когда этого &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;требует прагма temp_store_directory&lt;/a&gt;, SQLite не освобождает память, на которую указывает sqlite3_temp_directory. Если приложение хочет освободить эту память, оно должно сделать это само, заботясь об этом только после того, как все объекты &lt;a href=&quot;sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; будут уничтожены.</target>
        </trans-unit>
        <trans-unit id="d082fe94995359849591e8be7fa905999e11458e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;Wal_autocheckpoint Прагма&lt;/a&gt; можно использовать для вызова этого интерфейса из SQL.</target>
        </trans-unit>
        <trans-unit id="2688b20853de688f9667ff56467cd11f77df2163" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;ПРАГМА wal_checkpoint&lt;/a&gt; команда может быть использована для вызова этого интерфейса из SQL.</target>
        </trans-unit>
        <trans-unit id="3d14328a2609f4c2f2e647906b7ed9c9b0a6470e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">Оператор &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA Writable_schema = ON&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c456ed19efa854514b7975cbb780401189b8da5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">Метод &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; должен заполнить aConstraintUsage [] информацией о том, какие параметры передать в xFilter. Если argvIndex&amp;gt; 0, тогда правая часть соответствующего aConstraint [] оценивается и становится записью argvIndex-й в argv. Если aConstraintUsage []. Omit истинно, то предполагается, что ограничение полностью обрабатывается виртуальной таблицей и не проверяется SQLite снова.</target>
        </trans-unit>
        <trans-unit id="589ad4da98fc55a8cd1077ee9df3a71f69ad38f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52eaec5cfbc452ed9aad230504ada3c60f5e208b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">В &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; и &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; методы в &lt;a href=&quot;module&quot;&gt;модуле виртуальной таблицы&lt;/a&gt; называют этот интерфейс , чтобы объявить формат (имена и типы данных столбцов) из виртуальных таблиц , которые они реализуют.</target>
        </trans-unit>
        <trans-unit id="bcf8720fcb25c1b9008caa098927de8f2ece3d5e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit&lt;/a&gt; document describes how SQLite implements transactions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabaf2d0ed146df6465d7c01128019f3ef60888d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;atomic update capabilities&lt;/a&gt; of SQLite allow small incremental changes to be safely written into the document. This reduces total disk I/O and improves File/Save performance, enhancing the user experience.</source>
          <target state="translated">Возможности &lt;a href=&quot;atomiccommit&quot;&gt;атомарного обновления&lt;/a&gt; SQLite позволяют безопасно записывать небольшие инкрементные изменения в документ. Это снижает общий объем дискового ввода-вывода и улучшает производительность файлов и сохранений, улучшая взаимодействие с пользователем.</target>
        </trans-unit>
        <trans-unit id="08525d9bc082ee31e91cdcebab98cc6662084121" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature in SQLite works differently than it does in MySQL. This often causes confusion for people who initially learned SQL on MySQL and then start using SQLite, and expect the two systems to work identically.</source>
          <target state="translated">Функция &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; в SQLite работает иначе, чем в MySQL. Это часто вызывает путаницу у людей, которые сначала изучили SQL на MySQL, а затем начали использовать SQLite и ожидают, что две системы будут работать одинаково.</target>
        </trans-unit>
        <trans-unit id="bc38744c25dba895f9fced962c1bfedae8b7cde9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">Сам объект &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; частично потокобезопасен. Несколько потоков могут безопасно выполнять несколько одновременных вызовов sqlite3_backup_step (). Однако API sqlite3_backup_remaining () и sqlite3_backup_pagecount (), строго говоря, не являются потокобезопасными. Если они вызываются одновременно с вызовом sqlite3_backup_step () другого потока, возможно, они возвращают недопустимые значения.</target>
        </trans-unit>
        <trans-unit id="218098ad11bde6e156b4a9f8e57ca75e25354cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; и &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob (),&lt;/a&gt; а также встроенная &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;функция&lt;/a&gt; SQL zeroblob могут использоваться для создания блоба с нулевым заполнением для чтения или записи с использованием интерфейса инкрементального блоба.</target>
        </trans-unit>
        <trans-unit id="c7e4db04e283ee079f91c197314578446dc39a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; routine is used only in the implementations of aggregate and window functions. Scalar functions may not use &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;. The &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; function is included in the interface list only for completeness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f66c39b1fdccfb02fbdb0dd7e08e6474fe1802" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface, which has been deprecated and undocumented for 8 years, is changed into a no-op.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; , который устарел и не документировался в течение 8 лет, заменен на запретный.</target>
        </trans-unit>
        <trans-unit id="3cbc1814be35648af44f26835e6f82841778c411" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm&lt;/a&gt; routine is used to register a callback on memory allocation events. This routine registers or clears a callback that fires when the amount of memory allocated exceeds iThreshold. Only a single callback can be registered at a time. Each call to &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; overwrites the previous callback. The callback is disabled by setting xCallback to a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;Sqlite3_memory_alarm&lt;/a&gt; процедура используется для регистрации обратного вызова на события выделения памяти. Эта процедура регистрирует или очищает обратный вызов, который запускается, когда объем выделенной памяти превышает iThreshold. Одновременно можно зарегистрировать только один обратный вызов. Каждый вызов &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; перезаписывает предыдущий обратный вызов. Обратный вызов отключается путем установки xCallback на NULL указатель.</target>
        </trans-unit>
        <trans-unit id="fc7e34038a904f7366dde6ee090a8282d84ade6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; interface has become a no-op.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup ()&lt;/a&gt; стал недоступным.</target>
        </trans-unit>
        <trans-unit id="ac435cb36a069024ddc4f4287c8ff0d76c80af5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; was created to address these concerns. The online backup API allows the contents of one database to be copied into another database, overwriting the original contents of the target database. The copy operation may be done incrementally, in which case the source database does not need to be locked for the duration of the copy, only for the brief periods of time when it is actually being read from. This allows other database users to continue uninterrupted while a backup of an online database is made.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; был создан для решения этих проблем. API онлайн-резервного копирования позволяет копировать содержимое одной базы данных в другую базу данных, перезаписывая исходное содержимое целевой базы данных. Операция копирования может выполняться постепенно, и в этом случае исходную базу данных не нужно блокировать на время копирования, только на короткие периоды времени, когда она фактически считывается. Это позволяет другим пользователям базы данных продолжать бесперебойную работу, пока создается резервная копия онлайн-базы данных.</target>
        </trans-unit>
        <trans-unit id="563d98f5bc61682f67da5d25a1062884fd2fdf5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; interface does &lt;u&gt;not&lt;/u&gt; work for a union-vtab. BLOB content must be read from the union-vtab using ordinary SQL statements.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_open&quot;&gt;Sqlite3_blob_open ()&lt;/a&gt; интерфейс делает &lt;u&gt;не&lt;/u&gt; работает для союзной-vtab. Содержимое BLOB должно быть прочитано из union-vtab с помощью обычных операторов SQL.</target>
        </trans-unit>
        <trans-unit id="b9d5c3998902d7d51338a9f7531152bceea38f9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked once with a column name that is an empty string for every table referenced in a query from which no columns are extracted.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ &lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;доверитель обратного вызова&lt;/a&gt; вызывается один раз с именем столбца, пустая строка для каждой таблицы , указанного в запросе , из которого не извлекаются ни один столбец.</target>
        </trans-unit>
        <trans-unit id="a68ee8ce42ad40a73650dbfe088fcf3e1c842ed0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; run-time option and the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option enable the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt;. See also ticket &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</source>
          <target state="translated">Параметр &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;времени&lt;/a&gt; выполнения SQLITE_DBCONFIG_ENABLE_QPSG и параметр &lt;a href=&quot;compile#enable_qpsg&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_QPSG обеспечивают &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;гарантию стабильности планировщика запросов&lt;/a&gt; . См. Также билет &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba2430856bd9775a861cef9dfde7c36d65a2cc4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bit means that all writes to this device are atomic in the sense that either the entire write occurs or none of it occurs. The other &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; values indicate that writes of aligned blocks of the indicated size are atomic. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; means that when extending a file with new data, the new data is written first and then the file size is updated. So if a power failure occurs, there is no chance that the file might have been extended with randomness. The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; bit means that all writes occur in the order that they are issued and are not reordered by the underlying file system.</source>
          <target state="translated">В &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; бит означает , что все записи в этом устройстве являются неделимыми в том смысле , что либо происходит все записи или ни один из них не происходит. Другие &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;значения &lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; SQLITE_IOCAP_ATOMIC указывают, что запись выровненных блоков указанного размера является атомарной. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; означает, что при расширении файла новыми данными сначала записываются новые данные, а затем обновляется размер файла. Поэтому, если произойдет сбой питания, нет никаких шансов, что файл мог быть расширен случайным образом. В &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; бит означает , что все записи происходят в порядке их выдача и не кондиционированные в основной файловой системе.</target>
        </trans-unit>
        <trans-unit id="9a653d67bd1da50ffe32f058a08a81d4f6edcd9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. This will always be set for TEMP databases and journals and for subjournals. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag means the file should be opened for exclusive access. This flag is set for all files except for the main database file. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen is allocated by the caller. xOpen just fills it in. The caller allocates a minimum of szOsFile bytes for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; флаг означает , что файл должен быть удален , если он закрыт. Это всегда будет установлено для баз данных и журналов TEMP, а также для субжурналов. &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; флаг означает , что файл должен быть открыт для монопольного доступа. Этот флаг установлен для всех файлов, кроме основного файла базы данных. Структура &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file,&lt;/a&gt; переданная в качестве третьего аргумента xOpen, выделяется вызывающей стороной. xOpen просто заполняет его. Вызывающий выделяет минимум szOsFile байтов для структуры &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="229110ee7251c5cf9b125b0ef0813a6c6ba215fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flags to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can also be used to adjust the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; of individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; at run-time.</source>
          <target state="translated">В &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; и &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; флаги в &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; могут также использоваться для настройки &lt;a href=&quot;threadsafe&quot;&gt;режима поточного&lt;/a&gt; отдельных &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="966cc2ea77fca46efeb8c4289b4a653605ed43e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; option was added to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;.</source>
          <target state="translated">В &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; добавлен параметр &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abc999536061a5d7a156494c35b1ed191a9effbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type()&lt;/a&gt; function returns the datatype for the value in the Nth column. The return value is one of these:</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type ()&lt;/a&gt; возвращает тип данных для значения в N-м столбце. Возвращаемое значение - одно из следующих:</target>
        </trans-unit>
        <trans-unit id="cffa274dabb801c01eb4f4986ad5f8726b7dca26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; function returns the number of columns in the results set. sqlite3_column_count() can be called at any time after &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; works similarly to &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; except that it only works following &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. If the previous call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returned SQLITE_DONE or an error code, then &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; will return 0 whereas &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; will continue to return the number of columns in the result set.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; возвращает количество столбцов в наборе результатов. sqlite3_column_count () можно вызвать в любое время после &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count ()&lt;/a&gt; работает аналогично &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; за исключением того, что работает только после &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Если предыдущий вызов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернул SQLITE_DONE или код ошибки, тогда &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count ()&lt;/a&gt; вернет 0, тогда как &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; продолжит возвращать количество столбцов в наборе результатов.</target>
        </trans-unit>
        <trans-unit id="df909dfd5bdc309e3368846cb0f8c21a5731a3d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface is used to make global, process-wide configuration changes for SQLite. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface must be called before any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; are created. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows the programmer to do things like:</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; используется для внесения глобальных изменений конфигурации всего процесса для SQLite. Интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; должен быть вызван до создания любых &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; позволяет программисту делать такие вещи, как:</target>
        </trans-unit>
        <trans-unit id="7eb7ccb56d39b4e4c7e512ab71314c715b6ea1d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) interfaces was invoked at start-time.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; , 1) были вызваны во время запуска.</target>
        </trans-unit>
        <trans-unit id="faa946b5075b7749c61a0c77f6eb5fe8e812f89c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; routine returns a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c837fffcba80492d406ed18ba293449ca9513c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface is used to create new &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; for sorting text. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface is used to register new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface creates new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; используется для создания новых &lt;a href=&quot;datatype3#collation&quot;&gt;последовательностей&lt;/a&gt; сортировки для сортировки текста. Интерфейс &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; используется для регистрации новых реализаций &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; создает новые &lt;a href=&quot;vfs&quot;&gt;виртуальные файловые системы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="965853485ed37d427cfb8a0c73c9695bbb338f24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces is used to create new custom SQL functions. Each member of this family is a wrapper around a common core. All family members accomplish the same thing; they merely have different calling signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c521e07609cbfdb8d566dab7163fc87d422895" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces now return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; when passed invalid parameter combinations.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;Sqlite3_create_function ()&lt;/a&gt; семейство интерфейсов теперь возвращает &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; вместо &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; при пропускании недопустимых комбинаций параметров.</target>
        </trans-unit>
        <trans-unit id="caf6561662b932f66438111d53034fa55d79a49d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface can be used to override the like() function and thereby change the operation of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator depending on whether or not an ESCAPE clause was specified.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; может использоваться для переопределения функции like () и тем самым изменения работы оператора &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; . При переопределении функции like () может быть важно переопределить версии с двумя и тремя аргументами функции like (). В противном случае может быть вызван другой код для реализации оператора &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE в&lt;/a&gt; зависимости от того, было ли указано предложение ESCAPE.</target>
        </trans-unit>
        <trans-unit id="a6b630ee12d42fc4528bfc71d36f585a36895111" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface creates new SQL functions - either scalar or aggregate. The new function implementation typically makes use of the following additional interfaces:</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; создает новые функции SQL - скалярные или агрегатные. Реализация новой функции обычно использует следующие дополнительные интерфейсы:</target>
        </trans-unit>
        <trans-unit id="99635893a7742a2b0a9430ca501d241e5f7023c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces return SQLITE_MISUSE on any attempt to overload or replace a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; module. The destructor is always called in this case, in accordance with historical and current documentation.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; и &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; возвращают SQLITE_MISUSE при любой попытке перегрузить или заменить модуль &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; . В этом случае всегда вызывается деструктор в соответствии с исторической и текущей документацией.</target>
        </trans-unit>
        <trans-unit id="0e7c498dc9b696b8a3e4e1f8ce0b76687320b809" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; routines associates a module name with an &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure and a separate client data that is specific to each module. The only difference between the two create_module methods is that the _v2 method includes an extra parameter that specifies a destructor for client data pointer. The module structure is what defines the behavior of a virtual table. The module structure looks like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;Sqlite3_create_module ()&lt;/a&gt; и &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; подпрограмм связывает имя модуля с &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; структурой и отдельный клиент данные, специфичные для каждого модуля. Единственное различие между двумя методами create_module состоит в том, что метод _v2 включает дополнительный параметр, определяющий деструктор для указателя данных клиента. Структура модуля определяет поведение виртуальной таблицы. Структура модуля выглядит так:</target>
        </trans-unit>
        <trans-unit id="ea2068b9a7520d6dd4dead5bbb83fc7b95e63987" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface can be used during a transaction to determine if there are deferred and unresolved foreign key constraints.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;Sqlite3_db_status&lt;/a&gt; (дб, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt; , ...) C-язык интерфейса можно использовать во время операции , чтобы определить, есть ли доходы будущих периодов и неразрешенные ограничения внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="5d823f649e66e357a40f8457ae11a89f890b8312" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; теперь применяется ко всем потокам внутри процесса, а не только к одному потоку, в котором он был запущен.</target>
        </trans-unit>
        <trans-unit id="dc8c7487a7241b1b53f75118a25cdfbd803a1bd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; function works much as it did in SQLite version 2. Zero or more SQL statements specified in the second parameter are compiled and executed. Query results are returned to a callback routine.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; работает так же, как и в SQLite версии 2. Компилируется и выполняется ноль или более операторов SQL, указанных во втором параметре. Результаты запроса возвращаются в процедуру обратного вызова.</target>
        </trans-unit>
        <trans-unit id="060e03cab55fa6e258498e740c2441a904ee6a9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; interface is a convenience wrapper that carries out all four of the above steps with a single function call. A callback function passed into &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is used to process each row of the result set. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; is another convenience wrapper that does all four of the above steps. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface differs from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; in that it stores the results of queries in heap memory rather than invoking a callback.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; - это удобная оболочка, которая выполняет все четыре вышеуказанных шага за один вызов функции. Функция обратного вызова, переданная в &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , используется для обработки каждой строки набора результатов. &lt;a href=&quot;c3ref/free_table&quot;&gt;Sqlite3_get_table ()&lt;/a&gt; является еще удобство оболочки , которая делает все четыре вышеупомянутых шагов. Интерфейс &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; отличается от &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; тем, что он сохраняет результаты запросов в динамической памяти, а не вызывает обратный вызов.</target>
        </trans-unit>
        <trans-unit id="c55eb24f412d567a8152cd959c8adf08902c2ff0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface works on any prepared statement created using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. It is no longer necessary to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; in order to use &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; работает с любым подготовленным оператором, созданным с помощью &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; . Больше нет необходимости использовать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; с &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; , чтобы использовать &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b367904a5b319d97004324430003a01cf6b1ae72" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file. The xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; constructs an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object when the file is opened. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; keeps track of the state of the file while it is opened.</source>
          <target state="translated">Объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; представляет открытый файл. Метод xOpen &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; создает объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; при открытии файла. &lt;a href=&quot;c3ref/file&quot;&gt;Sqlite3_file&lt;/a&gt; отслеживает состояние файла во время его открытия.</target>
        </trans-unit>
        <trans-unit id="64a6d4c58c9877ecd1b62378eb5e65c884bd0f45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30882c8710d7d3a10831e6a935d755bd7e25652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is used to pass information into and out of the xBestIndex method of the module that implements a virtual table.</source>
          <target state="translated">Структура &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; используется для передачи информации в метод xBestIndex модуля, реализующего виртуальную таблицу, и из него.</target>
        </trans-unit>
        <trans-unit id="c68c89f6fed7e1292abcc19abd161e51c2b5b49a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface can be called to explicitly initialize the SQLite subsystem. The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically when invoking certain interfaces so the use of &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; is not required, but it is recommended.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; может быть вызван для явной инициализации подсистемы SQLite. Интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; вызывается автоматически при вызове определенных интерфейсов, поэтому использование &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; не требуется, но рекомендуется.</target>
        </trans-unit>
        <trans-unit id="086866a1ce9981846c47e35c1af526651c7809af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface causes SQLite to release any system resources (memory allocations, mutexes, open file handles) that might have been allocated by &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; заставляет SQLite освобождать любые системные ресурсы (выделение памяти, мьютексы, дескрипторы открытых файлов), которые могли быть выделены &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18eeb48351b373543379c24e8aba67998ec2d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface frees all mutexes under windows.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; освобождает все мьютексы под окнами.</target>
        </trans-unit>
        <trans-unit id="f14f29a4830a0488c9f404caad392cc8f7efd81d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; routine can be called for a different thread</source>
          <target state="translated">&lt;a href=&quot;c3ref/interrupt&quot;&gt;Sqlite3_interrupt ()&lt;/a&gt; подпрограмма может быть вызвана для другого потока</target>
        </trans-unit>
        <trans-unit id="78920df495dd4dfe901c1e207965f56317d12fca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object holds the methods used to interact with an open file. Each &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains a pointer to an &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that is appropriate for the file it represents. The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object contains methods to do things such as read and write from the file, to truncate the file, to flush any changes to persistent storage, to find the size of the file, to lock and unlock the file, and to close file and destroy the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">Объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; содержит методы, используемые для взаимодействия с открытым файлом. Каждый &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; содержит указатель на объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; , соответствующий файлу, который он представляет. Объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; содержит методы для выполнения таких действий, как чтение и запись из файла, усечение файла, сброс любых изменений в постоянное хранилище, определение размера файла, блокировка и разблокировка файла, закрытие файла и уничтожить объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="899386dff25e21c6b737c3d54a2f1045b6441f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object is a structure that contains pointers to methods for reading, writing, and otherwise dealing with files. This object is defined as follows:</source>
          <target state="translated">Объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; - это структура, которая содержит указатели на методы для чтения, записи и других действий с файлами. Этот объект определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="1277e9425f23dd50c872910508a38720a4c40a0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; function tries to detect if the source code has been modified from what is checked into version control and if there are modifications, the last four characters of the version hash are shown as &quot;alt1&quot; or &quot;alt2&quot;. The objective is to detect accidental and/or careless edits. A forger can subvert this feature.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; пытается определить, был ли исходный код изменен по сравнению с тем, что проверено в системе контроля версий, и если есть изменения, последние четыре символа хэша версии отображаются как &amp;laquo;alt1&amp;raquo; или &amp;laquo;alt2&amp;raquo;. Цель состоит в том, чтобы обнаружить случайные и / или небрежные правки. Фальсификатор может подорвать эту особенность.</target>
        </trans-unit>
        <trans-unit id="e51a6d9f987aab5062f7ef525db57b1e02273eb7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface loads an &lt;a href=&quot;loadext&quot;&gt;extension&lt;/a&gt; into a single database connection. The default behavior is for that extension to be automatically unloaded when the database connection closes. However, if the extension entry point returns SQLITE_OK_LOAD_PERMANENTLY instead of SQLITE_OK, then the extension remains loaded into the process address space after the database connection closes. In other words, the xDlClose methods of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is not called for the extension when the database connection closes.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; загружает &lt;a href=&quot;loadext&quot;&gt;расширение&lt;/a&gt; в одно соединение с базой данных. По умолчанию это расширение автоматически выгружается при закрытии соединения с базой данных. Однако, если точка входа расширения возвращает SQLITE_OK_LOAD_PERMANENTLY вместо SQLITE_OK, тогда расширение остается загруженным в адресное пространство процесса после закрытия соединения с базой данных. Другими словами, методы xDlClose объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; не вызываются для расширения при закрытии соединения с базой данных.</target>
        </trans-unit>
        <trans-unit id="e180768903c106d7d176b62ab434360e88ec87ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces are deprecated. The equivalent functionality is now available through &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; устарели. Эквивалентная функциональность теперь доступна через &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46ea088bdd6bab93bd39ac4df39be5b9d52d9d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces, the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interface, and the &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; compile-time option are all non-functional when memory usage tracking is disabled.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater (),&lt;/a&gt; интерфейс &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; ) и параметр &lt;a href=&quot;compile#max_memory&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_MAX_MEMORY не работают, если отслеживание использования памяти отключено.</target>
        </trans-unit>
        <trans-unit id="8f1193a5998521b29a68d3af0690b60d457381cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure defines a module object used to implement a virtual table. Think of a module as a class from which one can construct multiple virtual tables having similar properties. For example, one might have a module that provides read-only access to comma-separated-value (CSV) files on disk. That one module can then be used to create several virtual tables where each virtual table refers to a different CSV file.</source>
          <target state="translated">Структура &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; определяет объект модуля, используемый для реализации виртуальной таблицы. Подумайте о модуле как о классе, из которого можно построить несколько виртуальных таблиц со схожими свойствами. Например, у кого-то может быть модуль, который обеспечивает доступ только для чтения к файлам с разделителями-запятыми (CSV) на диске. Затем этот один модуль можно использовать для создания нескольких виртуальных таблиц, где каждая виртуальная таблица ссылается на отдельный файл CSV.</target>
        </trans-unit>
        <trans-unit id="26e5c834aec9a24795809e8d9018891e41492180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter()&lt;/a&gt; attempts to enter the mutex and blocks if another threads is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try()&lt;/a&gt; attempts to enter and returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another thread is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; exits a mutex. The mutex is held until the number of exits matches the number of entrances. If &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; is called on a mutex that the thread is not currently holding, then the behavior is undefined. If any routine is called for a deallocated mutex, then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;Sqlite3_mutex_enter ()&lt;/a&gt; пытается ввести взаимную блокировку и блокирует если другая нить уже есть. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try ()&lt;/a&gt; пытается войти и возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; если другой поток уже существует. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave ()&lt;/a&gt; выходит из мьютекса. Мьютекс удерживается до тех пор, пока количество выходов не совпадет с количеством входов. Если &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave ()&lt;/a&gt; вызывается для мьютекса, который поток в настоящее время не удерживает, то поведение не определено. Если для освобожденного мьютекса вызывается какая-либо подпрограмма, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="6f27ad8fcfe5b9da304436aec019b4cf39a32876" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free()&lt;/a&gt; routine should be used to deallocate a non-static mutex. If a static mutex is passed to this routine then the behavior is undefined.</source>
          <target state="translated">Для освобождения нестатического мьютекса следует использовать процедуру &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free ()&lt;/a&gt; . Если в эту процедуру передается статический мьютекс, поведение не определено.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
