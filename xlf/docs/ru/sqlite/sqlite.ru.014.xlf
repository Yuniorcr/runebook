<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="3c67e89c578626f4a5845690f5e802d46290edfe" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY 2&quot; (which means the same as &quot;ORDER BY under_alice.level+1&quot;) causes higher levels in the organization chart (with smaller &quot;level&quot; values) to be processed first, resulting in a breadth-first search. The output is:</source>
          <target state="translated">ЗАКАЗАНИЕ BY 2&quot; (что означает то же самое,что и &quot;ЗАКАЗАНИЕ BY under_alice.level+1&quot;)приводит к тому,что более высокие уровни на графике организации (с меньшими значениями &quot;уровня&quot;)обрабатываются в первую очередь,что приводит к первому поиску по широте.Результатом является:</target>
        </trans-unit>
        <trans-unit id="f957a1348139bb0e4f79cd1d2fbd5306c674fbde" translate="yes" xml:space="preserve">
          <source>The &quot;ORDER BY checkin.mtime DESC&quot; term in the recursive-select makes the query run much faster by preventing it from following branches that merge checkins from long ago. The ORDER BY forces the recursive-select to focus on the most recent checkins, the ones we want. Without the ORDER BY on the recursive-select, one would be forced to compute the complete set of thousands of ancestors, sort them all by mtime, then take the top twenty. The ORDER BY essentially sets up a priority queue that forces the recursive query to look at the most recent ancestors first, allowing the use of a LIMIT clause to restrict the scope of the query to just the checkins of interest.</source>
          <target state="translated">Термин &quot;ORDER BY checkin.mtime DESC&quot; в рекурсивном выборе делает запрос намного быстрее,не позволяя ему следовать за ветвями,которые давно сливают проверки.ЗАКАЗАНИЕ BY заставляет рекурсивный выбор сфокусироваться на самых последних проверках,тех,которые нам нужны.Без &quot;ЗАКАЗАНИЯ BY&quot; на рекурсивном выборе можно было бы вычислить полный набор из тысяч предков,отсортировать их все по mtime,а затем взять верхнюю двадцатку.По сути,ORDER BY устанавливает очередь приоритетов,которая заставляет рекурсивный запрос сначала посмотреть на самые последние предки,позволяя использовать выражение LIMIT,чтобы ограничить область запроса только интересующими нас проверками.</target>
        </trans-unit>
        <trans-unit id="05aec33569483f3dc1a8463df38060dbf53e2c35" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA cache_spill=</source>
          <target state="translated">PRAGMA cache_spill=</target>
        </trans-unit>
        <trans-unit id="1a0a062742c0bea5342163f23635fff0e75751fe" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; command provides an indication that the database file has been modified. Interactive programs that hold database content in memory or that display database content on-screen can use the PRAGMA data_version command to determine if they need to flush and reload their memory or update the screen display.</source>
          <target state="translated">Команда &quot;PRAGMA data_version&quot; указывает на то,что файл БД был изменен.Интерактивные программы,хранящие содержимое БД в памяти или отображающие содержимое БД на экране,могут с помощью команды &quot;PRAGMA data_version&quot; определить,нужно ли им промыть и перезагрузить свою память или обновить отображение экрана.</target>
        </trans-unit>
        <trans-unit id="51c212d19062433a8ddb99b497e81dcefb5db939" translate="yes" xml:space="preserve">
          <source>The &quot;PRAGMA data_version&quot; value is a local property of each database connection and so values returned by two concurrent invocations of &quot;PRAGMA data_version&quot; on separate database connections are often different even though the underlying database is identical. It is only meaningful to compare the &quot;PRAGMA data_version&quot; values returned by the same database connection at two different points in time.</source>
          <target state="translated">Значение &quot;PRAGMA data_version&quot; является локальным свойством каждого соединения БД и поэтому значения,возвращаемые двумя одновременными вызовами &quot;PRAGMA data_version&quot; на отдельных соединениях БД,часто различаются,даже если базовая БД идентична.Сравнивать значения &quot;PRAGMA data_version&quot;,возвращаемые одним и тем же подключением к БД,имеет смысл только в два разных момента времени.</target>
        </trans-unit>
        <trans-unit id="03965d42503dca17ab62ff9cad1d8a5c3c8ffdbb" translate="yes" xml:space="preserve">
          <source>The &quot;Page Count&quot; - The number of pages in the next segment of the journal, or -1 to mean all content to the end of the file</source>
          <target state="translated">Количество страниц&quot;-количество страниц в следующем сегменте журнала,или -1 для обозначения всего содержимого до конца файла.</target>
        </trans-unit>
        <trans-unit id="48c6586de090c3bc2e13cc3b6a2a69ed36fa59fa" translate="yes" xml:space="preserve">
          <source>The &quot;USING TEMP B-TREE&quot; clause in the above output indicates that a temporary b-tree structure is used to implement the UNION of the results of the two sub-selects. An alternative method of computing a compound is to run each subquery as a co-routine, arrange for their outputs to appear in sorted order, and merge the results together. When the query planner chooses this latter approach, the EXPLAIN QUERY PLAN output looks like this:</source>
          <target state="translated">Пункт &quot;ИСПОЛЬЗОВАНИЕ ТЕМПЫ B-TREE&quot; в вышеуказанном выводе указывает на то,что временная структура b-дерева используется для реализации UNION результатов двух подвыборов.Альтернативный метод вычисления соединения состоит в том,чтобы выполнить каждый подзапрос как со-результат,расположить их выходы в отсортированном порядке и объединить результаты вместе.Когда планировщик запроса выбирает последний подход,выход EXPLAIN QUERY PLAN выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="a9bff9645401cb328b5613b5233bf3e5ba1e2eb1" translate="yes" xml:space="preserve">
          <source>The &quot;alternate-form-2&quot; flag (&quot;!&quot;) on the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; implementation now causes string substitutions to measure the width and precision in characters instead of bytes.</source>
          <target state="translated">Флаг &amp;laquo;альтернативная форма-2&amp;raquo; (&amp;laquo;!&amp;raquo;) Во &lt;a href=&quot;printf&quot;&gt;встроенной&lt;/a&gt; реализации printf теперь вызывает подстановку строк для измерения ширины и точности в символах, а не в байтах.</target>
        </trans-unit>
        <trans-unit id="e4319cae606348ce23e782f966b47ff645421643" translate="yes" xml:space="preserve">
          <source>The &quot;atom&quot; column is the SQL value corresponding to primitive elements - elements other than JSON arrays and objects. The &quot;atom&quot; column is NULL for a JSON array or object. The &quot;value&quot; column is the same as the &quot;atom&quot; column for primitive JSON elements but takes on the text JSON value for arrays and objects.</source>
          <target state="translated">Столбец &quot;атом&quot;-это SQL-значение,соответствующее примитивным элементам-элементам,отличным от JSON-массивов и объектов.Столбец &quot;атом&quot;-NULL для JSON-массива или объекта.Столбец &quot;значение&quot; аналогичен столбцу &quot;атом&quot; для примитивных JSON-элементов,но принимает текстовое JSON-значение для массивов и объектов.</target>
        </trans-unit>
        <trans-unit id="cb8a5773e6c48280d7fe42741f8b4a093d392533" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method</source>
          <target state="translated">Метод &quot;авторизатора&quot;</target>
        </trans-unit>
        <trans-unit id="d2039edadf3792f44d9f55f1e52e41e045647126" translate="yes" xml:space="preserve">
          <source>The &quot;authorizer&quot; method provides access to the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C/C++ interface. The argument to authorizer is the name of a procedure that is called when SQL statements are being compiled in order to authorize certain operations. The callback procedure takes 5 arguments which describe the operation being coded. If the callback returns the text string &quot;SQLITE_OK&quot;, then the operation is allowed. If it returns &quot;SQLITE_IGNORE&quot;, then the operation is silently disabled. If the return is &quot;SQLITE_DENY&quot; then the compilation fails with an error.</source>
          <target state="translated">Метод &amp;laquo;authorizer&amp;raquo; обеспечивает доступ к интерфейсу &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer&lt;/a&gt; C / C ++. Аргумент авторизатора - это имя процедуры, которая вызывается при компиляции операторов SQL для авторизации определенных операций. Процедура обратного вызова принимает 5 аргументов, которые описывают кодируемую операцию. Если обратный вызов возвращает текстовую строку &amp;laquo;SQLITE_OK&amp;raquo;, то операция разрешена. Если он возвращает &amp;laquo;SQLITE_IGNORE&amp;raquo;, то операция автоматически отключается. Если возвращается &quot;SQLITE_DENY&quot;, компиляция завершается ошибкой.</target>
        </trans-unit>
        <trans-unit id="d780e49acdf2e828a0e7b0580dfd96aff50cee2e" translate="yes" xml:space="preserve">
          <source>The &quot;automerge=N&quot; command (where N is an integer between 0 and 15, inclusive) is used to configure an FTS3/4 tables &quot;automerge&quot; parameter, which controls automatic incremental inverted index merging. The default automerge value for new tables is 0, meaning that automatic incremental merging is completely disabled. If the value of the automerge parameter is modified using the &quot;automerge=N&quot; command, the new parameter value is stored persistently in the database and is used by all subsequently established database connections.</source>
          <target state="translated">Команда &quot;automerge=N&quot; (где N-целое число между 0 и 15 включительно)используется для настройки параметра &quot;automerge&quot; таблиц FTS3/4,который управляет автоматическим слиянием инкрементных инвертированных индексов.Значение automerge по умолчанию для новых таблиц равно 0,что означает,что автоматическое инкрементальное слияние полностью отключено.Если значение параметра automerge изменяется командой &quot;automerge=N&quot;,то новое значение параметра постоянно сохраняется в БД и используется всеми последующими соединениями БД.</target>
        </trans-unit>
        <trans-unit id="35cc018cff76ce7093039d6d69782515b8dd9cbd" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method</source>
          <target state="translated">Метод &quot;резервного копирования&quot;</target>
        </trans-unit>
        <trans-unit id="c005edd2de62803b18a4eb1743378927a517fad5" translate="yes" xml:space="preserve">
          <source>The &quot;backup&quot; method makes a backup copy of a live database. The command syntax is like this:</source>
          <target state="translated">Метод &quot;резервного копирования&quot; делает резервную копию живой базы данных.Синтаксис команды такой:</target>
        </trans-unit>
        <trans-unit id="7652bc7646799c25c956b30319f71b75ca9a3e80" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method</source>
          <target state="translated">Метод &quot;bind_fallback&quot;.</target>
        </trans-unit>
        <trans-unit id="e31d9979cf6770ea07cdb2b87a23b0343179e30e" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method gives the application control over how to handle parameter binding when no TCL variable matches the parameter name.</source>
          <target state="translated">Метод &quot;bind_fallback&quot; дает программе контроль над тем,как работать с привязкой параметров,когда ни одна переменная TCL не совпадает с именем параметра.</target>
        </trans-unit>
        <trans-unit id="d6fd78a195f0dd5acebc1e5d408aa889656042c4" translate="yes" xml:space="preserve">
          <source>The &quot;bind_fallback&quot; method has a single optional argument. If the argument is an empty string, then the bind_fallback is cancelled and the default behavior is restored. If the argument is a non-empty string, then the argument is a TCL command (usually the name of a proc) to invoke whenever an SQL parameter is seen that does not match any TCL variable. If the &quot;bind_fallback&quot; method is given no arguments, then the current bind_fallback command is returned.</source>
          <target state="translated">Метод &quot;bind_fallback&quot; имеет один необязательный аргумент.Если аргумент является пустой строкой,то bind_fallback отменяется и поведение по умолчанию восстанавливается.Если аргумент-непустая строка,то это команда TCL (обычно имя proc)для вызова всякий раз,когда видим параметр SQL,который не соответствует ни одной переменной TCL.Если метод &quot;bind_fallback&quot; не имеет аргументов,то возвращается текущая команда bind_fallback.</target>
        </trans-unit>
        <trans-unit id="50a08084b4de7b3f67549ffe53d83ec728fa3cca" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method</source>
          <target state="translated">&quot;занятой&quot; метод</target>
        </trans-unit>
        <trans-unit id="94cabb870539d2659c509ca5d30b8de78ce6a143" translate="yes" xml:space="preserve">
          <source>The &quot;busy&quot; method, like &quot;timeout&quot;, only comes into play when the database is locked. But the &quot;busy&quot; method gives the programmer much more control over what action to take. The &quot;busy&quot; method specifies a callback Tcl procedure that is invoked whenever SQLite tries to open a locked database. A single integer argument is appended to the callback before it is invoke. The argument is the number of prior calls to the busy callback for the current locking event. It is intended that the callback will do some other useful work for a short while (such as service GUI events) then return so that the lock can be tried again. The callback procedure should return &quot;0&quot; if it wants SQLite to try again to open the database and should return &quot;1&quot; if it wants SQLite to abandon the current operation.</source>
          <target state="translated">Метод &quot;занят&quot;,как и &quot;тайм-аут&quot;,вступает в игру только тогда,когда база данных заблокирована.Но метод &quot;занято&quot; дает программисту гораздо больше контроля над тем,какие действия нужно предпринять.Метод &quot;занят&quot; определяет процедуру обратного вызова Tcl,которая вызывается всякий раз,когда SQLite пытается открыть заблокированную БД.Один целочисленный аргумент добавляется к обратному вызову перед его вызовом.Аргумент представляет собой количество предыдущих вызовов обратного вызова &quot;занято&quot; для текущего события блокировки.Он предназначен для того,чтобы обратный вызов выполнял некоторую другую полезную работу некоторое время (например,события GUI службы),а затем возвращался,чтобы блокировку можно было попробовать еще раз.Процедура обратного вызова должна возвращать &quot;0&quot;,если она хочет,чтобы SQLite попытался снова открыть базу данных,и должна возвращать &quot;1&quot;,если она хочет,чтобы SQLite отказался от текущей операции.</target>
        </trans-unit>
        <trans-unit id="806dbf019d18a933c45ea06755b6a277743f61ae" translate="yes" xml:space="preserve">
          <source>The &quot;cache&quot; method</source>
          <target state="translated">Метод &quot;кэширования&quot;</target>
        </trans-unit>
        <trans-unit id="6c5d5ba4e30c1f02fb732b5f9e013dee90e5777d" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method</source>
          <target state="translated">Метод &quot;изменений&quot;</target>
        </trans-unit>
        <trans-unit id="94441f79eee4930e4324a3b4a4acbce248260c58" translate="yes" xml:space="preserve">
          <source>The &quot;changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified by the most recent &quot;eval&quot; method.</source>
          <target state="translated">Метод &quot;изменений&quot; возвращает целое число,которое представляет собой количество строк в БД,которые были вставлены,удалены и/или изменены последним методом &quot;eval&quot;.</target>
        </trans-unit>
        <trans-unit id="a3fc353d826f676e72487db0fd8f37052f9b16c1" translate="yes" xml:space="preserve">
          <source>The &quot;close&quot; method</source>
          <target state="translated">Метод &quot;закрыть&quot;</target>
        </trans-unit>
        <trans-unit id="b78db738260018e26bc56c431d7e164adb66bba3" translate="yes" xml:space="preserve">
          <source>The &quot;collate&quot; method</source>
          <target state="translated">Метод &quot;сопоставления&quot;</target>
        </trans-unit>
        <trans-unit id="3be1a86e589629a9a881a6da512b2ad6b5f62c78" translate="yes" xml:space="preserve">
          <source>The &quot;collation_needed&quot; method</source>
          <target state="translated">Метод &quot;collation_needed&quot;.</target>
        </trans-unit>
        <trans-unit id="6c32eeacd0b85ddcdef7035930e1a8c64bfad10b" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; mode is a tabular output format. Other tabular output formats as &quot;box&quot;, &quot;markdown&quot;, and &quot;table&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1035634e0e0ea333e6f8d753c7fa7091a7d755db" translate="yes" xml:space="preserve">
          <source>The &quot;column&quot; output mode automatically expands columns to contain the longest output row and automatically turns &quot;.header&quot; on if it has not been previously set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30f6089837a9332235ef1f677d9e2936edf51cae" translate="yes" xml:space="preserve">
          <source>The &quot;columns&quot; of a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery are really the expressions in the result set of the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements the VIEW or subquery. Thus, the affinity for columns of a VIEW or subquery are determined by the expression affinity rules above. Consider an example:</source>
          <target state="translated">&amp;laquo;Столбцы&amp;raquo; подзапроса &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; или FROM-clause на самом деле являются выражениями в результирующем наборе &lt;a href=&quot;lang_select&quot;&gt;оператора SELECT&lt;/a&gt; , реализующего VIEW или подзапрос. Таким образом, сродство столбцов в представлении или подзапросе определяется правилами сродства выражений, приведенными выше. Рассмотрим пример:</target>
        </trans-unit>
        <trans-unit id="6efc033d7171b4cae5dcc026d731d1abc23f16f8" translate="yes" xml:space="preserve">
          <source>The &quot;commit_hook&quot; method</source>
          <target state="translated">Метод &quot;commit_hook&quot;</target>
        </trans-unit>
        <trans-unit id="075f9fcec0c51906d7830312bd2ffff7ac323743" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method</source>
          <target state="translated">&quot;Полный&quot; метод</target>
        </trans-unit>
        <trans-unit id="36202288005d888ee9c02c9332ba422aac36a5b3" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method is useful when building interactive applications in order to know when the user has finished entering a line of SQL code. This is really just an interface to the &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;sqlite3_complete()&lt;/b&gt;&lt;/a&gt; C function.</source>
          <target state="translated">Метод &amp;laquo;complete&amp;raquo; полезен при создании интерактивных приложений, чтобы узнать, когда пользователь закончил ввод строки кода SQL. На самом деле это просто интерфейс для &lt;a href=&quot;c3ref/complete&quot;&gt;&lt;b&gt;функции&lt;/b&gt;&lt;/a&gt; C. &lt;b&gt;sqlite3_complete ()&lt;/b&gt; C.</target>
        </trans-unit>
        <trans-unit id="cb6d6b519cc240799d0eae2497f1b956b7749126" translate="yes" xml:space="preserve">
          <source>The &quot;complete&quot; method takes a string of supposed SQL as its only argument. It returns TRUE if the string is a complete statement of SQL and FALSE if there is more to be entered.</source>
          <target state="translated">Полный&quot; метод принимает строку предполагаемого SQL в качестве единственного аргумента.Он возвращает TRUE,если строка является полным оператором SQL и FALSE,если нужно ввести больше.</target>
        </trans-unit>
        <trans-unit id="46bbc7a4eaf4d4f9fe40b357ef388a365c9285df" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method</source>
          <target state="translated">Метод &quot;config&quot;</target>
        </trans-unit>
        <trans-unit id="d8bb4ff8aef62d6cb6272264cef7cda239984bc9" translate="yes" xml:space="preserve">
          <source>The &quot;config&quot; method queries or changes certain configuration settings for the database connection using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface. Run this method with no arguments to get a TCL list of available configuration settings and their current values:</source>
          <target state="translated">Метод &amp;laquo;config&amp;raquo; запрашивает или изменяет определенные параметры конфигурации для подключения к базе данных с помощью интерфейса &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; . Запустите этот метод без аргументов, чтобы получить список TCL доступных параметров конфигурации и их текущих значений:</target>
        </trans-unit>
        <trans-unit id="b266e6a044670a6e3a5e4102b0820031cb7ab393" translate="yes" xml:space="preserve">
          <source>The &quot;configure&quot; scripts should now automatically configure Unix systems for large file support. Improved error messages for when large files are encountered and large file support is disabled.</source>
          <target state="translated">Скрипты &quot;configure&quot; теперь должны автоматически настраивать Unix-системы для поддержки больших файлов.Улучшены сообщения об ошибках при работе с большими файлами и отключена поддержка больших файлов.</target>
        </trans-unit>
        <trans-unit id="577865d2c9835070772d4e94f47615cadfb2baec" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">Переменная &quot;const char *&quot;, на которую указывает параметр T, будет установлена ​​в строку UTF-8 с завершающим нулем, содержащую описание &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; для X-го цикла.</target>
        </trans-unit>
        <trans-unit id="2be51d012e0d49a380524a8121847e82af3226bf" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="translated">Переменная &quot;const char *&quot;, на которую указывает параметр T, будет установлена ​​в строку UTF-8 с завершающим нулем, содержащую описание &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; для X-го цикла.</target>
        </trans-unit>
        <trans-unit id="bac7414b87b280f152adca2a25c602ba20600788" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the T parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="translated">Переменная &quot;const char *&quot;,на которую указывает параметр T,будет установлена в нулевую строку UTF-8,содержащую имя индекса или таблицы,используемой в X-ом цикле.</target>
        </trans-unit>
        <trans-unit id="220e93adf7fc69205c340c5757886c63862916b5" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb2cfe6186a4a9c1039f7ec3e694a12e936a2d7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; description for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6993ddaa2434f289adeb086aed7ae04476a60ad7" translate="yes" xml:space="preserve">
          <source>The &quot;const char *&quot; variable pointed to by the V parameter will be set to a zero-terminated UTF-8 string containing the name of the index or table used for the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aae3497dac443e109983b1c00a5960530139406" translate="yes" xml:space="preserve">
          <source>The &quot;content&quot; option, used to make the FTS5 table an &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;external content or contentless table&lt;/a&gt;.</source>
          <target state="translated">Параметр &amp;laquo;контент&amp;raquo;, используемый для превращения таблицы FTS5 в таблицу с &lt;a href=&quot;fts5#external_content_and_contentless_tables&quot;&gt;внешним контентом или без контента&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c79f409b23d48e87e77e61ee87998224597bc3" translate="yes" xml:space="preserve">
          <source>The &quot;content_rowid&quot; option, used to set the rowid field of an &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content table&lt;/a&gt;.</source>
          <target state="translated">Параметр content_rowid, используемый для установки поля rowid &lt;a href=&quot;fts5#external_content_tables&quot;&gt;внешней таблицы содержимого&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39cd9c81e20b57d6b78e1af2643005b4d6ac3fb3" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method</source>
          <target state="translated">Метод &quot;копирования&quot;</target>
        </trans-unit>
        <trans-unit id="983ea0fee26b9222536bfed9a0514ad997e9a0a2" translate="yes" xml:space="preserve">
          <source>The &quot;copy&quot; method copies data from a file into a table. It returns the number of rows processed successfully from the file. The syntax of the copy method looks like this:</source>
          <target state="translated">Метод &quot;копирования&quot; копирует данные из файла в таблицу.Он возвращает количество успешно обработанных строк из файла.Синтаксис метода копирования выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="dc3e7bd12c41305b3fc796bf145f478af20ae557" translate="yes" xml:space="preserve">
          <source>The &quot;cost&quot; here is logarithmic. With nested loops, the work is multiplied, not added. But it is customary to think of graphs with additive weights and so the graph shows the logarithm of the various costs. The graph shows a cost advantage of S being inside of L of about 6.87, but this translates into the query running about 963 times faster when S loop is inside of the L loop rather than being outside of it.</source>
          <target state="translated">Здесь &quot;стоимость&quot; логарифмическая.При вложенных циклах работа умножается,а не прибавляется.Но принято думать о графиках с аддитивными весами,поэтому график показывает логарифм различных затрат.На графике показано преимущество по стоимости того,что S находится внутри L примерно в 6.87,но это транслируется в запрос,выполняемый примерно в 963 раза быстрее,когда цикл S находится внутри цикла L,а не вне его.</target>
        </trans-unit>
        <trans-unit id="350bdd92630f61bca90b3168c90039a63f7ced5e" translate="yes" xml:space="preserve">
          <source>The &quot;csv&quot; mode option in the shell puts strings inside double-quotes.</source>
          <target state="translated">Опция режима &quot;csv&quot; в оболочке помещает строки внутри двойных кавычек.</target>
        </trans-unit>
        <trans-unit id="1f521a5c994d919d955260e93be15342970bdf26" translate="yes" xml:space="preserve">
          <source>The &quot;db&quot; parameter is a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. The &quot;main&quot; argument is the name of the schema in which the imposter table is to be created. The &quot;1&quot; argument enables the imposter table mechanism. &quot;tnum&quot; is the root page of the index that the imposter table should mirror.</source>
          <target state="translated">Параметр &amp;laquo;db&amp;raquo; - это указатель на &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных . &amp;laquo;Главный&amp;raquo; аргумент - это имя схемы, в которой должна быть создана таблица самозванца. Аргумент &amp;laquo;1&amp;raquo; включает механизм таблицы самозванца. &amp;laquo;tnum&amp;raquo; - это корневая страница индекса, которую должна отражать таблица самозванца.</target>
        </trans-unit>
        <trans-unit id="1d7867d45fc6532563a6e0e1052f994086d7d4d3" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method</source>
          <target state="translated">Метод &quot;десериализации&quot;</target>
        </trans-unit>
        <trans-unit id="6f372f07e9e348fc01623f3016d82e06dd84212c" translate="yes" xml:space="preserve">
          <source>The &quot;deserialize&quot; method takes a TCL byte-array that contains an SQLite database file and adds it to the database connection. The syntax is:</source>
          <target state="translated">Метод &quot;десериализации&quot; берет байт-массив TCL,содержащий файл базы данных SQLite,и добавляет его в соединение с БД.Синтаксис таков:</target>
        </trans-unit>
        <trans-unit id="37b478850c0ef98b47e5a07304d319496a735ccd" translate="yes" xml:space="preserve">
          <source>The &quot;docid&quot; alias does not exist. Applications must use &quot;rowid&quot; instead.</source>
          <target state="translated">Псевдоним &quot;доцид&quot; не существует.Приложения должны использовать &quot;rowid&quot;.</target>
        </trans-unit>
        <trans-unit id="13cca21a87502057869d942479f833e57c886177" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the T parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="translated">Двойная&quot; переменная,на которую указывает параметр T,будет установлена в оценку планировщика запросов для среднего количества строк,выводимых при каждой итерации X-го цикла.Если оценки планировщика запросов были точными,то это значение будет аппроксимировать коэффициент NVISIT/NLOOP,и произведением этого значения для всех предыдущих циклов с одинаковым SELECTID будет значение NLOOP для текущего цикла.</target>
        </trans-unit>
        <trans-unit id="ac86dc9fb240d8b577961e6fb339b312a7e8b6d2" translate="yes" xml:space="preserve">
          <source>The &quot;double&quot; variable pointed to by the V parameter will be set to the query planner's estimate for the average number of rows output from each iteration of the X-th loop. If the query planner's estimates was accurate, then this value will approximate the quotient NVISIT/NLOOP and the product of this value for all prior loops with the same SELECTID will be the NLOOP value for the current loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b47ab7441632c19a646d6f3d2e70bb71a8af6b" translate="yes" xml:space="preserve">
          <source>The &quot;ellipses&quot; text.</source>
          <target state="translated">Текст &quot;эллипсов&quot;.</target>
        </trans-unit>
        <trans-unit id="785dfb0eb14780fdc8609d7c7187bbcbf0dfe81b" translate="yes" xml:space="preserve">
          <source>The &quot;enable_load_extension&quot; method</source>
          <target state="translated">Метод &quot;enable_load_extension&quot;.</target>
        </trans-unit>
        <trans-unit id="24181470839fe75a380a1959898a8b67107aab1a" translate="yes" xml:space="preserve">
          <source>The &quot;end match&quot; text.</source>
          <target state="translated">Текст &quot;конечное совпадение&quot;.</target>
        </trans-unit>
        <trans-unit id="a4952b422a3c809d77afa1776609a2750c092857" translate="yes" xml:space="preserve">
          <source>The &quot;errorcode&quot; method</source>
          <target state="translated">Метод &quot;код ошибки&quot;</target>
        </trans-unit>
        <trans-unit id="79f7c0ddb2f3a3e97f9983c467d9c601808c789a" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method</source>
          <target state="translated">Метод &quot;оценки&quot;</target>
        </trans-unit>
        <trans-unit id="da370283ad69c2823d6201a69b7d1765374cb685" translate="yes" xml:space="preserve">
          <source>The &quot;eval&quot; method described &lt;a href=&quot;#eval&quot;&gt;above&lt;/a&gt; keeps a cache of &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared statements&lt;/a&gt; for recently evaluated SQL commands. The &quot;cache&quot; method is used to control this cache. The first form of this command is:</source>
          <target state="translated">Описанный &lt;a href=&quot;#eval&quot;&gt;выше&lt;/a&gt; метод eval сохраняет кэш &lt;a href=&quot;c3ref/prepare&quot;&gt;подготовленных операторов&lt;/a&gt; для недавно оцененных команд SQL. Для управления этим кешем используется метод &quot;cache&quot;. Первая форма этой команды:</target>
        </trans-unit>
        <trans-unit id="221bab33d21ea69f4dd52f3f0492767cb572de7f" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method</source>
          <target state="translated">Метод &quot;существует&quot;</target>
        </trans-unit>
        <trans-unit id="efdfc3e12d096d22035e667cf9f9a8fa50dec02d" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is often used to test for the existence of rows in a table. For example:</source>
          <target state="translated">Метод &quot;существует&quot; часто используется для проверки существования строк в таблице.Например:</target>
        </trans-unit>
        <trans-unit id="64883f01f5bafd4c69a4447377f37fc6c44868cb" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; method is similar to &quot;onecolumn&quot; and &quot;eval&quot; in that it executes SQL statements. The difference is that the &quot;exists&quot; method always returns a boolean value which is TRUE if a query in the SQL statement it executes returns one or more rows and FALSE if the SQL returns an empty set.</source>
          <target state="translated">Метод &quot;существует&quot; аналогичен методу &quot;onecolumn&quot; и &quot;eval&quot; в том,что он выполняет SQL-операторы.Разница заключается в том,что метод &quot;существует&quot; всегда возвращает булевое значение,которое равно TRUE,если запрос в SQL-операторе,который он выполняет,возвращает одну или несколько строк,и FALSE,если SQL возвращает пустой набор.</target>
        </trans-unit>
        <trans-unit id="2fa39980ca4c6c390fc0963b907ef032a2115a04" translate="yes" xml:space="preserve">
          <source>The &quot;family&quot; table is similar to the earlier &quot;org&quot; table except that now there are two parents to each member. We want to know all living ancestors of Alice, from oldest to youngest. An ordinary common table expression, &quot;parent_of&quot;, is defined first. That ordinary CTE is a view that can be used to find all parents of any individual. That ordinary CTE is then used in the &quot;ancestor_of_alice&quot; recursive CTE. The recursive CTE is then used in the final query:</source>
          <target state="translated">Таблица &quot;семьи&quot; похожа на предыдущую таблицу &quot;орг&quot;,за исключением того,что теперь у каждого члена семьи по два родителя.Мы хотим знать всех живых предков Алисы,от самых старших до самых младших.Сначала определяется обычное общее выражение таблицы-&quot;parent_of&quot;.Это обычное CTE-представление,которое может быть использовано для поиска всех родителей любого индивидуума.Этот обычный CTE затем используется в рекурсивном CTE &quot;ancestor_of_alice&quot;.Затем в финальном запросе используется рекурсивный CTE:</target>
        </trans-unit>
        <trans-unit id="e0decf38085a4ffc55fce2f25b175fd346628c61" translate="yes" xml:space="preserve">
          <source>The &quot;fast&quot; setting for secure_delete (added circa 2017-08-01) is an intermediate setting in between &quot;on&quot; and &quot;off&quot;. When secure_delete is set to &quot;fast&quot;, SQLite will overwrite deleted content with zeros only if doing so does not increase the amount of I/O. In other words, the &quot;fast&quot; setting uses more CPU cycles but does not use more I/O. This has the effect of purging all old content from &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree pages&lt;/a&gt;, but leaving forensic traces on &lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist pages&lt;/a&gt;.</source>
          <target state="translated">Настройка &amp;laquo;fast&amp;raquo; для secure_delete (добавлена ​​около 2017-08-01) является промежуточной настройкой между &amp;laquo;on&amp;raquo; и &amp;laquo;off&amp;raquo;. Когда для secure_delete установлено значение &amp;laquo;fast&amp;raquo;, SQLite перезапишет удаленный контент нулями только в том случае, если это не приведет к увеличению количества операций ввода-вывода. Другими словами, установка &amp;laquo;быстро&amp;raquo; использует больше циклов ЦП, но не использует больше операций ввода-вывода. Это приводит к удалению всего старого контента со &lt;a href=&quot;fileformat2#btree&quot;&gt;страниц b-tree&lt;/a&gt; , но оставляет следы судебной экспертизы на &lt;a href=&quot;fileformat2#freelist&quot;&gt;страницах freelist&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5e5534bc0599c1bf3dbead2d2f44bed70807ce6" translate="yes" xml:space="preserve">
          <source>The &quot;fsync()&quot; that occurs after the header is written in a WAL reset now uses the sync settings for checkpoints. This means it will use a &quot;fullfsync&quot; on macs if &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt; set on.</source>
          <target state="translated">Функция &amp;laquo;fsync ()&amp;raquo;, возникающая после записи заголовка при сбросе WAL, теперь использует настройки синхронизации для контрольных точек. Это означает, что он будет использовать &amp;laquo;fullfsync&amp;raquo; на &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;Mac,&lt;/a&gt; если PRAGMA checkpoint_fullfsync включен .</target>
        </trans-unit>
        <trans-unit id="80417a09b17dfee14228d5c4ecb3ba63e1360a53" translate="yes" xml:space="preserve">
          <source>The &quot;fts3tokenize&quot; virtual table can be used to directly access any tokenizer. The following SQL demonstrates how to create an instance of the fts3tokenize virtual table:</source>
          <target state="translated">Виртуальная таблица &quot;fts3tokenize&quot; может быть использована для прямого доступа к любому токенайзеру.Следующий SQL демонстрирует,как создать экземпляр виртуальной таблицы fts3tokenize:</target>
        </trans-unit>
        <trans-unit id="6cdf37fe2751376d1b848056d4ec78cc31cd8173" translate="yes" xml:space="preserve">
          <source>The &quot;fullkey&quot; column is a text path that uniquely identifies the current row element within the original JSON string. The complete key to the true top-level element is returned even if an alternative starting point is provided by the &quot;root&quot; argument.</source>
          <target state="translated">Столбец &quot;fullkey&quot;-это текстовый путь,который уникальным образом идентифицирует текущий элемент строки внутри исходной JSON-строки.Полный ключ к истинному элементу верхнего уровня возвращается,даже если альтернативная отправная точка задана аргументом &quot;root&quot;.</target>
        </trans-unit>
        <trans-unit id="81485590afed062476035ea78c2df833a07ce15c" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method</source>
          <target state="translated">Метод &quot;функции&quot;</target>
        </trans-unit>
        <trans-unit id="982021b0dd51770755c9c9e39c1c765e77fbdd84" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method accepts the following options:</source>
          <target state="translated">Метод &quot;функции&quot; принимает следующие варианты:</target>
        </trans-unit>
        <trans-unit id="e581fe2aa68e5275a553b3adbf390b762a9e4053" translate="yes" xml:space="preserve">
          <source>The &quot;function&quot; method registers new SQL functions with the SQLite engine. The arguments are the name of the new SQL function and a TCL command that implements that function. Arguments to the function are appended to the TCL command before it is invoked.</source>
          <target state="translated">Метод &quot;функции&quot; регистрирует новые функции SQL в движке SQLite.Аргументами являются имя новой функции SQL и команда TCL,реализующая эту функцию.Аргументы функции добавляются к команде TCL перед ее вызовом.</target>
        </trans-unit>
        <trans-unit id="ff9f7422b3d2ef0edf475eeb60798d293ddec7bd" translate="yes" xml:space="preserve">
          <source>The &quot;fuzzershell.c&quot; program is used to run some &lt;a href=&quot;#fuzztesting&quot;&gt;fuzz tests&lt;/a&gt;.</source>
          <target state="translated">Программа fuzzershell.c используется для запуска некоторых &lt;a href=&quot;#fuzztesting&quot;&gt;тестов&lt;/a&gt; фаззинга .</target>
        </trans-unit>
        <trans-unit id="7c4947473658b4ae028d7e71df03314bb5d6e009" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">Параметр &amp;laquo;iScanStatusOp&amp;raquo; определяет, какую информацию о статусе нужно вернуть. &amp;laquo;IScanStatusOp&amp;raquo; должен быть одной из &lt;a href=&quot;#SQLITE_SCANSTAT_EST&quot;&gt;опций scanstatus,&lt;/a&gt; иначе поведение этого интерфейса не определено. Запрошенное измерение записывается в переменную, на которую указывает параметр &amp;laquo;pOut&amp;raquo;. Параметр &amp;laquo;idx&amp;raquo; определяет конкретный цикл, для которого требуется получить статистику. Циклы нумеруются, начиная с нуля. Если idx выходит за пределы диапазона - меньше нуля или больше или равно общему количеству циклов, используемых для реализации оператора, - возвращается ненулевое значение, а переменная, на которую указывает pOut, не изменяется.</target>
        </trans-unit>
        <trans-unit id="82b3487c37966e4df98f8fc69e59c76eae09190d" translate="yes" xml:space="preserve">
          <source>The &quot;iScanStatusOp&quot; parameter determines which status information to return. The &quot;iScanStatusOp&quot; must be one of the &lt;a href=&quot;c_scanstat_est&quot;&gt;scanstatus options&lt;/a&gt; or the behavior of this interface is undefined. The requested measurement is written into a variable pointed to by the &quot;pOut&quot; parameter. Parameter &quot;idx&quot; identifies the specific loop to retrieve statistics for. Loops are numbered starting from zero. If idx is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value is returned and the variable that pOut points to is unchanged.</source>
          <target state="translated">Параметр &amp;laquo;iScanStatusOp&amp;raquo; определяет, какую информацию о статусе нужно вернуть. &amp;laquo;IScanStatusOp&amp;raquo; должен быть одной из &lt;a href=&quot;c_scanstat_est&quot;&gt;опций scanstatus,&lt;/a&gt; иначе поведение этого интерфейса не определено. Запрошенное измерение записывается в переменную, на которую указывает параметр &amp;laquo;pOut&amp;raquo;. Параметр &amp;laquo;idx&amp;raquo; определяет конкретный цикл, для которого требуется получить статистику. Циклы нумеруются, начиная с нуля. Если idx выходит за пределы диапазона - меньше нуля или больше или равно общему количеству циклов, используемых для реализации оператора, - возвращается ненулевое значение, а переменная, на которую указывает pOut, не изменяется.</target>
        </trans-unit>
        <trans-unit id="5abd56a3f33aa682cb5beed98f5ecb39cbd50edd" translate="yes" xml:space="preserve">
          <source>The &quot;id&quot; column is an integer that identifies a specific JSON element within the complete JSON string. The &quot;id&quot; integer is an internal housekeeping number, the computation of which might change in future releases. The only guarantee is that the &quot;id&quot; column will be different for every row.</source>
          <target state="translated">Столбец &quot;id&quot;-это целое число,которое идентифицирует определенный JSON-элемент внутри полной JSON-строки.Целое &quot;id&quot; число-это внутреннее служебное число,вычисление которого может измениться в будущих релизах.Единственной гарантией является то,что столбец &quot;id&quot; будет отличаться для каждой строки.</target>
        </trans-unit>
        <trans-unit id="ca8669e4db9525865c9346904ab8bb3b3eb055a9" translate="yes" xml:space="preserve">
          <source>The &quot;incrblob&quot; method</source>
          <target state="translated">Метод &quot;инкрблоб&quot;</target>
        </trans-unit>
        <trans-unit id="8d184fd38641411539a264597b11e40c38841938" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; or staging area</source>
          <target state="translated">&quot;Индекс&quot; или инсценировочная площадка</target>
        </trans-unit>
        <trans-unit id="c6e7f631fc9ab8b7e2eecdc6301a632079a07cf7" translate="yes" xml:space="preserve">
          <source>The &quot;input&quot; CTE defines the input puzzle. The &quot;digits&quot; CTE defines a table that holds all digits between 1 and 9. The work of solving the puzzle is undertaken by the &quot;x&quot; CTE. An entry in x(s,ind) means that the 81-character string &quot;s&quot; is a valid sudoku puzzle (it has no conflicts) and that the first unknown character is at position &quot;ind&quot;, or ind==0 if all character positions are filled in. The goal, then, is to compute entries for &quot;x&quot; with an &quot;ind&quot; of 0.</source>
          <target state="translated">Входной&quot; CTE определяет входную головоломку.Цифры&quot; CTE определяют таблицу,содержащую все цифры от 1 до 9.Работа по решению головоломки выполняется по &quot;x&quot; CTE.Запись в x(s,ind)означает,что 81-символьная строка &quot;s&quot; является действительной судоку головоломкой (она не имеет конфликтов)и что первый неизвестный символ находится в позиции &quot;ind&quot;,или ind==0,если все позиции символов заполнены.Таким образом,цель состоит в том,чтобы вычислить записи для &quot;x&quot; со значением &quot;ind&quot;,равным 0.</target>
        </trans-unit>
        <trans-unit id="b6cb46f4a227f8313e332f23912dfe269a430a8c" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">Переменная &quot;int&quot;, на которую указывает параметр T, будет установлена ​​в &quot;select-id&quot; для X-го цикла. Select-id определяет, частью какого запроса или подзапроса является цикл. Основной запрос имеет нулевой идентификатор выбора. Select-id - это то же значение, которое выводится в первом столбце запроса &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd32578e68672fbb14bf7b3a04807a29e7c2c005" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the T parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="translated">Переменная &quot;int&quot;, на которую указывает параметр T, будет установлена ​​в &quot;select-id&quot; для X-го цикла. Select-id определяет, частью какого запроса или подзапроса является цикл. Основной запрос имеет нулевой идентификатор выбора. Select-id - это то же значение, которое выводится в первом столбце запроса &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f1457987df7641bcada911e2bfe80eb91e9f5b" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;../eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b31808af87fb1ca4f0d10efd9a5ba2a54012dd" translate="yes" xml:space="preserve">
          <source>The &quot;int&quot; variable pointed to by the V parameter will be set to the &quot;select-id&quot; for the X-th loop. The select-id identifies which query or subquery the loop is part of. The main query has a select-id of zero. The select-id is the same value as is output in the first column of an &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47984da42c27787f28bd87d963296a6ecc85d38" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command causes SQLite to read and verify the accuracy of all inverted indices in an FTS3/4 table by comparing those inverted indices against the original content. The &quot;integrity-check&quot; command silently succeeds if the inverted indices are all ok, but will fail with an SQLITE_CORRUPT error if any problems are found.</source>
          <target state="translated">Команда &quot;проверка целостности&quot; заставляет SQLite считывать и проверять точность всех инвертированных индексов в таблице FTS3/4 путем сравнения этих инвертированных индексов с исходным содержимым.Команда &quot;Проверка целостности&quot; беззвучно завершает работу,если все инвертированные индексы в порядке,но при обнаружении проблем не будет работать с ошибкой SQLITE_CORRUPT.</target>
        </trans-unit>
        <trans-unit id="d1ee1009fc8d7ceb03381f3a07a84d688fe06706" translate="yes" xml:space="preserve">
          <source>The &quot;integrity-check&quot; command is similar in concept to &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;. In a working system, the &quot;integrity-command&quot; should always be successful. Possible causes of integrity-check failures include:</source>
          <target state="translated">Команда &amp;laquo;проверка целостности&amp;raquo; по своей концепции аналогична &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;команде PRAGMA integration_check&lt;/a&gt; . В работающей системе &amp;laquo;команда целостности&amp;raquo; всегда должна быть успешной. Возможные причины сбоев проверки целостности включают:</target>
        </trans-unit>
        <trans-unit id="9351b7e4831f50f0cddfc49da3ef44df26240c27" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method</source>
          <target state="translated">Метод &quot;прерывания&quot;</target>
        </trans-unit>
        <trans-unit id="1b5c7fcb603da939ee7df1123931389580f03242" translate="yes" xml:space="preserve">
          <source>The &quot;interrupt&quot; method invokes the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface, causing any pending queries to halt.</source>
          <target state="translated">Метод &amp;laquo;прерывание&amp;raquo; вызывает интерфейс &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; , вызывая остановку любых ожидающих запросов.</target>
        </trans-unit>
        <trans-unit id="33827ff37e59286ea63b18a3b491ccd55fa35d36" translate="yes" xml:space="preserve">
          <source>The &quot;isInit&quot; flag. 1 when the shm file has been initialized.</source>
          <target state="translated">Флаг &quot;isInit&quot;.1,когда файл shm был инициализирован.</target>
        </trans-unit>
        <trans-unit id="27d80d07107f3dd674071f8dcb5d66e927b93ae8" translate="yes" xml:space="preserve">
          <source>The &quot;isolation&quot; property of a database determines when changes made to the database by one operation become visible to other concurrent operations.</source>
          <target state="translated">Свойство &quot;изоляция&quot; БД определяет,когда изменения,внесенные в БД одной операцией,становятся видимыми для других параллельных операций.</target>
        </trans-unit>
        <trans-unit id="ca6207f3c60486460fc150891b4e2b2ff184348d" translate="yes" xml:space="preserve">
          <source>The &quot;key&quot; column is the integer array index for elements of a JSON array and the text label for elements of a JSON object. The key column is NULL in all other cases.</source>
          <target state="translated">Столбец &quot;ключ&quot;-это целочисленный индекс массива для элементов JSON-массива и текстовая метка для элементов JSON-объекта.Столбец &quot;ключ&quot; во всех остальных случаях является NULL.</target>
        </trans-unit>
        <trans-unit id="f06bf7b5c9acc6e224eb6aebb494891b0b016a3d" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method</source>
          <target state="translated">Метод &quot;last_insert_rowid&quot;.</target>
        </trans-unit>
        <trans-unit id="b6bbfdca82da26696ded7dc7b5667ad95fba9734" translate="yes" xml:space="preserve">
          <source>The &quot;last_insert_rowid&quot; method returns an integer which is the ROWID of the most recently inserted database row.</source>
          <target state="translated">Метод &quot;last_insert_rowid&quot; возвращает целое число,которое является ROWID последней вставленной строки БД.</target>
        </trans-unit>
        <trans-unit id="7284b909bd501ff8419335375b9cbd82855b5cf7" translate="yes" xml:space="preserve">
          <source>The &quot;localtime&quot; modifier (12) assumes the time string to its left is in Universal Coordinated Time (UTC) and adjusts the time string so that it displays localtime. If &quot;localtime&quot; follows a time that is not UTC, then the behavior is undefined. The &quot;utc&quot; modifier is the opposite of &quot;localtime&quot;. &quot;utc&quot; assumes that the string to its left is in the local timezone and adjusts that string to be in UTC. If the prior string is not in localtime, then the result of &quot;utc&quot; is undefined.</source>
          <target state="translated">Модификатор &quot;локального времени&quot; (12)предполагает,что строка времени слева от него находится в Универсальном координированном времени (UTC),и подстраивает строку времени так,чтобы она отображала локальное время.Если &quot;локальное время&quot; следует за временем,которое не является UTC,то поведение не определено.Модификатор &quot;utc&quot; является противоположностью &quot;локального времени&quot;.&quot;utc&quot; предполагает,что строка слева от него находится в локальном часовом поясе,и подстраивает эту строку под UTC.Если предыдущая строка не находится в локальном времени,то результат &quot;utc&quot; неопределен.</target>
        </trans-unit>
        <trans-unit id="15b3080063f65f5e859c8cbf90675f21f18f1993" translate="yes" xml:space="preserve">
          <source>The &quot;lost_and_found&quot; table contains one row for each orphaned row recovered from the database. Additionally, there is one row for each recovered index entry that cannot be attributed to any SQL index. This is because, in an SQLite database, the same format is used to store SQL index entries and WITHOUT ROWID table entries.</source>
          <target state="translated">Таблица &quot;lost_and_found&quot; содержит по одной строке для каждой осиротевшей строки,восстановленной из БД.Кроме того,для каждой восстановленной записи индекса есть одна строка,которая не может быть отнесена ни к одному SQL-индексу.Это связано с тем,что в базе данных SQLite используется один и тот же формат для хранения записей индекса SQL и записей таблицы БЕЗ РОУИДА.</target>
        </trans-unit>
        <trans-unit id="9b9bb88fb1467415e1fd0ce3e886e98f2fabd9f8" translate="yes" xml:space="preserve">
          <source>The &quot;main&quot; argument to dbstat is default schema for which information is to be provided. The default is &quot;main&quot;, and so the use of &quot;main&quot; in the example above is redundant. For any particular query, the schema can be changed by specifying the alternative schema as a function argument to the virtual table name in the FROM clause of the query. (See further discussion of &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;table-valued functions in the FROM clause&lt;/a&gt; for more details.)</source>
          <target state="translated">&amp;laquo;Главный&amp;raquo; аргумент dbstat - это схема по умолчанию, для которой должна быть предоставлена ​​информация. По умолчанию используется &quot;main&quot;, поэтому использование &quot;main&quot; в приведенном выше примере является избыточным. Для любого конкретного запроса схему можно изменить, указав альтернативную схему в качестве аргумента функции для имени виртуальной таблицы в предложении FROM запроса. (Для получения дополнительных сведений см. Дальнейшее обсуждение возвращающих &lt;a href=&quot;lang_select#tabfunc1&quot;&gt;табличное значение функций в предложении FROM&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="09862758c2c346b79031222c95f1cc2f0ca91ec9" translate="yes" xml:space="preserve">
          <source>The &quot;make&quot; utility, or optionally &quot;nmake&quot; on Windows.</source>
          <target state="translated">Утилита &quot;make&quot;,или опционально &quot;nmake&quot; на Windows.</target>
        </trans-unit>
        <trans-unit id="658c3f95d62bc63b68f3b7aa685ee8fbc83d8cde" translate="yes" xml:space="preserve">
          <source>The &quot;matchinfo=fts3&quot; option is not available. The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize=0&quot;&lt;/a&gt; option is equivalent.</source>
          <target state="translated">Параметр &quot;matchinfo = fts3&quot; недоступен. Параметр &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&amp;laquo;columnsize = 0&amp;raquo;&lt;/a&gt; эквивалентен.</target>
        </trans-unit>
        <trans-unit id="d99f30c2d0e908e2cc3022d7fdccaca904765bb1" translate="yes" xml:space="preserve">
          <source>The &quot;merge&quot; command attempts to apply all the changes between circles (1) and (4) to the files in the local checkout. Note that circle (5) has not been created yet. You will need to run the &quot;commit&quot; to create circle (5).</source>
          <target state="translated">Команда &quot;слияние&quot; пытается применить все изменения между кругами (1)и (4)к файлам в локальной кассе.Обратите внимание,что круг (5)еще не создан.Для создания окружности (5)нужно выполнить &quot;фиксацию&quot;.</target>
        </trans-unit>
        <trans-unit id="9e41a414a4991da0955ad788ff392c91737d8599" translate="yes" xml:space="preserve">
          <source>The &quot;merge=X,Y&quot; command (where X and Y are integers) causes SQLite to do a limited amount of work toward merging the various inverted index b-trees of an FTS3/4 table together into one large b-tree. The X value is the target number of &quot;blocks&quot; to be merged, and Y is the minimum number of b-tree segments on a level required before merging will be applied to that level. The value of Y should be between 2 and 16 with a recommended value of 8. The value of X can be any positive integer but values on the order of 100 to 300 are recommended.</source>
          <target state="translated">Команда &quot;merge=X,Y&quot; (где X и Y-целые числа)заставляет SQLite выполнить ограниченный объем работы по объединению различных перевернутых индексных b-деревьев таблицы FTS3/4 в одно большое b-дерево.Значение X-заданное количество &quot;блоков&quot;,подлежащих слиянию,а Y-минимальное количество сегментов b-дерева на уровне,требуемом для слияния,которое будет применено к этому уровню.Значение Y должно быть между 2 и 16 с рекомендуемым значением 8.Значение X может быть любым положительным целым числом,но рекомендуются значения порядка 100-300.</target>
        </trans-unit>
        <trans-unit id="7feb211cc64d1d7531c5d948598d752876b7262d" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3f77712e8ba4f79aa6578b325009e072dd171a" translate="yes" xml:space="preserve">
          <source>The &quot;missing&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database if it finds that the required database file is not present on disk. This provides the application with an opportunity to retrieve the required database from a remote source before swarmvtab attempts to open it. The only argument passed to the &quot;missing&quot; function is the name or URI that identifies the database being opened. Assuming:</source>
          <target state="translated">Параметр &amp;laquo;missing&amp;raquo; позволяет пользователю указать имя определяемой &lt;a href=&quot;c3ref/create_function&quot;&gt;приложением функции SQL,&lt;/a&gt; которая будет вызываться непосредственно перед тем, как swarmvtab откроет базу данных, если обнаружит, что требуемый файл базы данных отсутствует на диске. Это дает приложению возможность получить необходимую базу данных из удаленного источника, прежде чем swarmvtab попытается ее открыть. Единственный аргумент, передаваемый &quot;отсутствующей&quot; функции, - это имя или URI, который идентифицирует открытую базу данных. Предполагая:</target>
        </trans-unit>
        <trans-unit id="6f3a9546b734b773233219e3ac894021d9c4aea3" translate="yes" xml:space="preserve">
          <source>The &quot;mmap_size&quot; is the maximum number of bytes of the database file that SQLite will try to map into the process address space at one time. The mmap_size applies separately to each database file, so the total amount of process address space that could potentially be used is the mmap_size times the number of open database files.</source>
          <target state="translated">mmap_size&quot;-это максимальное количество байт файла базы данных,которое SQLite попытается отобразить в адресное пространство процесса за один раз.mmap_size применяется отдельно к каждому файлу базы данных,поэтому общее количество адресного пространства процесса,которое потенциально может быть использовано,умножается на mmap_size,умноженное на количество открытых файлов базы данных.</target>
        </trans-unit>
        <trans-unit id="d05f6ca4b8375a55040cbbe82e13d67e18ad454c" translate="yes" xml:space="preserve">
          <source>The &quot;mptester.c&quot; program is a stress test for multiple processes concurrently reading and writing a single database.</source>
          <target state="translated">Программа &quot;mptester.c&quot; является стресс-тестом для нескольких процессов,одновременно читающих и записывающих одну базу данных.</target>
        </trans-unit>
        <trans-unit id="aceceab4037b5385ba92b29e0b20a81e94146ade" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method</source>
          <target state="translated">Метод &quot;нулевой стоимости&quot;</target>
        </trans-unit>
        <trans-unit id="e3321ce8b4cd40cd33c761004ca598eb073646da" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method changes the representation for NULL returned as result of the &quot;eval&quot; method.</source>
          <target state="translated">Метод &quot;nullvalue&quot; изменяет представление для NULL,возвращаемое в результате метода &quot;eval&quot;.</target>
        </trans-unit>
        <trans-unit id="afd7b6ac7a6da46e476f310a277a91923a4e7d04" translate="yes" xml:space="preserve">
          <source>The &quot;nullvalue&quot; method is useful to differ between NULL and empty column values as Tcl lacks a NULL representation. The default representation for NULL values is an empty string.</source>
          <target state="translated">Метод &quot;nullvalue&quot; полезен для того,чтобы различать NULL и значения пустых столбцов,так как в Tcl отсутствует NULL представление.По умолчанию для NULL-значений используется пустая строка.</target>
        </trans-unit>
        <trans-unit id="0c64f6777879373881c2c98b6dbc2b30411e222a" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method</source>
          <target state="translated">Метод &quot;onecolumn&quot;</target>
        </trans-unit>
        <trans-unit id="3506b602f0b2580a68e5b060067cc065e54d9b3f" translate="yes" xml:space="preserve">
          <source>The &quot;onecolumn&quot; method works like &quot;&lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt;&quot; in that it evaluates the SQL query statement given as its argument. The difference is that &quot;onecolumn&quot; returns a single element which is the first column of the first row of the query result.</source>
          <target state="translated">Метод &amp;laquo;onecolumn&amp;raquo; работает как &amp;laquo; &lt;a href=&quot;#eval&quot;&gt;eval&lt;/a&gt; &amp;raquo; в том смысле, что он оценивает оператор запроса SQL, заданный в качестве его аргумента. Разница в том, что &amp;laquo;onecolumn&amp;raquo; возвращает единственный элемент, который является первым столбцом первой строки результата запроса.</target>
        </trans-unit>
        <trans-unit id="a0182d08456ee166091bc283f720fe1e714fcddc" translate="yes" xml:space="preserve">
          <source>The &quot;onoff&quot; parameter is true to enable the tracking of memory statistics and false to disable statistics tracking.</source>
          <target state="translated">Параметр &quot;onoff&quot; верен для включения отслеживания статистики в памяти и false для отключения отслеживания статистики.</target>
        </trans-unit>
        <trans-unit id="e1f82fa30a955dc30a2b143e423d5902467689c7" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c453be3bed80a3f6062f894d9c91b09f2a405f4" translate="yes" xml:space="preserve">
          <source>The &quot;openclose&quot; parameter allows the user to specify the name of a &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; that will be invoked just before swarmvtab opens a database, and again just after it closes one. The first argument passed to the open close function is the filename or URI identifying the database to be opened or just recently closed (the same value returned in the leftmost column of the SQL statement provided to the CREATE VIRTUAL TABLE command). The second argument is integer value 0 when the function is invoked before opening a database, and 1 when it is invoked after one is closed. For example, if:</source>
          <target state="translated">Параметр &amp;laquo;openclose&amp;raquo; позволяет пользователю указать имя определяемой &lt;a href=&quot;c3ref/create_function&quot;&gt;приложением функции SQL,&lt;/a&gt; которая будет вызываться непосредственно перед тем, как swarmvtab откроет базу данных, и снова сразу после ее закрытия. Первым аргументом, передаваемым функции open close, является имя файла или URI, идентифицирующий базу данных, которая должна быть открыта или только что закрыта (то же значение, возвращаемое в крайнем левом столбце оператора SQL, предоставленного команде CREATE VIRTUAL TABLE). Второй аргумент - это целочисленное значение 0, когда функция вызывается перед открытием базы данных, и 1, когда она вызывается после закрытия базы данных. Например, если:</target>
        </trans-unit>
        <trans-unit id="e12d49df2a6244cc1bdf5cf47d59be2df870804d" translate="yes" xml:space="preserve">
          <source>The &quot;optimize&quot; command causes FTS3/4 to merge together all of its inverted index b-trees into one large and complete b-tree. Doing an optimize will make subsequent queries run faster since there are fewer b-trees to search, and it may reduce disk usage by coalescing redundant entries. However, for a large FTS table, running optimize can be as expensive as running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;. The optimize command essentially has to read and write the entire FTS table, resulting in a large transaction.</source>
          <target state="translated">Команда optimize заставляет FTS3 / 4 объединить все свои инвертированные b-деревья индексов в одно большое и полное b-дерево. Выполнение оптимизации ускорит выполнение последующих запросов, поскольку для поиска требуется меньше b-деревьев, и может уменьшить использование диска за счет объединения избыточных записей. Однако для большой таблицы FTS запуск оптимизации может быть столь же дорогостоящим, как запуск &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; . Команда optimize по существу должна читать и записывать всю таблицу FTS, что приводит к большой транзакции.</target>
        </trans-unit>
        <trans-unit id="8d4ccdc372ee3d695bbd6a513c0e6e7c13353814" translate="yes" xml:space="preserve">
          <source>The &quot;order&quot; option may be set to either &quot;DESC&quot; or &quot;ASC&quot; (in upper or lower case). If it is set to &quot;DESC&quot;, then FTS4 stores its data in such a way as to optimize returning results in descending order by docid. If it is set to &quot;ASC&quot; (the default), then the data structures are optimized for returning results in ascending order by docid. In other words, if many of the queries run against the FTS4 table use &quot;ORDER BY docid DESC&quot;, then it may improve performance to add the &quot;order=desc&quot; option to the CREATE VIRTUAL TABLE statement.</source>
          <target state="translated">Опция &quot;заказ&quot; может быть установлена либо в &quot;DESC&quot;,либо в &quot;ASC&quot; (в верхнем или нижнем регистре).Если она установлена в &quot;DESC&quot;,то FTS4 хранит свои данные таким образом,чтобы оптимизировать возвращаемые результаты в порядке убывания по документу.Если установлено значение &quot;ASC&quot; (по умолчанию),то структуры данных оптимизируются для возврата результатов в порядке возрастания по документу.Другими словами,если многие запросы,выполняемые против таблицы FTS4,используют &quot;ORDER BY docid DESC&quot;,то это может улучшить производительность,добавив опцию &quot;order=desc&quot; в оператор CREATE VIRTUAL TABLE.</target>
        </trans-unit>
        <trans-unit id="a820cd844c9df8619832ad41e29de304a643e275" translate="yes" xml:space="preserve">
          <source>The &quot;pBuf&quot; parameter is a pointer to memory space that will be used for the lookaside memory pool. If pBuf is NULL, then SQLite will obtain its own space for the memory pool using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The &quot;sz&quot; and &quot;cnt&quot; parameters are the size of each lookaside slot and the number of slots, respectively. If pBuf is not NULL, then it must point to at least sz*cnt bytes of memory.</source>
          <target state="translated">Параметр &amp;laquo;pBuf&amp;raquo; - это указатель на пространство памяти, которое будет использоваться для резервного пула памяти. Если pBuf равен NULL, то SQLite получит собственное пространство для пула памяти с помощью &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; . Параметры &amp;laquo;sz&amp;raquo; и &amp;laquo;cnt&amp;raquo; - это размер каждого дополнительного слота и количество слотов соответственно. Если pBuf не равен NULL, он должен указывать как минимум на sz * cnt байтов памяти.</target>
        </trans-unit>
        <trans-unit id="96f961210acaa75affae517c15c72d34812d54b4" translate="yes" xml:space="preserve">
          <source>The &quot;parent&quot; column is always NULL for json_each(). For json_tree(), the &quot;parent&quot; column is the &quot;id&quot; integer for the parent of the current element, or NULL for the top-level JSON element or the element identified by the root path in the second argument.</source>
          <target state="translated">Родительский&quot; столбец всегда имеет значение NULL для функции json_each().Для json_tree()столбец &quot;parent&quot;-это &quot;id&quot; целое число для родителя текущего элемента,или NULL для JSON-элемента верхнего уровня,или элемент,идентифицируемый корневым путём во втором аргументе.</target>
        </trans-unit>
        <trans-unit id="f4a41ee583b00942417f0c8c5f788e416b5fcd33" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="translated">В колонке &quot;путь&quot; описывается путь,взятый из корневого узла древовидной структуры к каждой странице.Путь&quot; самого корневого узла-'/'.Путь&quot; для самой левой дочерней страницы корневой структуры дерева-'/000/'.(В деревьях Btree содержимое упорядочивается слева направо,поэтому страницы слева имеют меньшие по размеру клавиши,чем страницы справа).Рядом с левой-самый младший по отношению к корневой странице-'/001',и так далее,каждая страница брата или сестры обозначается 3-значным шестнадцатеричным значением.Дочерние дети 451-го самого левого ребёнка имеют такие пути,как '/1c2/000/,'/1c2/001/' и т.д.Переполненные страницы задаются путем добавления символа '+' и шестизначного шестнадцатеричного значения к пути к ячейке,с которой они связаны.Например,три переполненные страницы в цепочке,связанной с самой левой ячейкой 450-го дочернего элемента корневой страницы,определяются путями:</target>
        </trans-unit>
        <trans-unit id="91195df7be82f506dcfbeb2cd0a2c8ea2909dc1a" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column describes the path taken from the root node of the btree structure to each page. The &quot;path&quot; of the root node itself is '/'. The &quot;path&quot; is NULL when &quot;aggregate&quot; is TRUE. The &quot;path&quot; for the left-most child page of the root of a btree page is '/000/'. (Btrees store content ordered from left to right so the pages to the left have smaller keys than the pages to the right.) The next to left-most child of the root page is '/001', and so on, each sibling page identified by a 3-digit hex value. The children of the 451st left-most sibling have paths such as '/1c2/000/, '/1c2/001/' etc. Overflow pages are specified by appending a '+' character and a six-digit hexadecimal value to the path to the cell they are linked from. For example, the three overflow pages in a chain linked from the left-most cell of the 450th child of the root page are identified by the paths:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2306ed00f4707f3494099d14093fb57dc4cef952" translate="yes" xml:space="preserve">
          <source>The &quot;path&quot; column is the path to the array or object container the holds the current row, or the path to the current row in the case where the iteration starts on a primitive type and thus only provides a single row of output.</source>
          <target state="translated">Столбец &quot;путь&quot;-это путь к массиву или контейнеру объектов,в котором хранится текущая строка,или путь к текущей строке в том случае,если итерация начинается с примитивного типа и,таким образом,обеспечивает только одну строку вывода.</target>
        </trans-unit>
        <trans-unit id="9d4d6b26f49abb4a72a1bbdb1337cbe3b3abe73d" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; in the last parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; is used to prevent pointers intended for one extension from being redirected to a different extension. For example, without the use of pointer types, an attacker could still get access to pointer information in a system that included both the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and the &lt;a href=&quot;carray&quot;&gt;CARRAY extension&lt;/a&gt; using SQL like this:</source>
          <target state="translated">&amp;laquo;Тип указателя&amp;raquo; в последнем параметре &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; и &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; используется для предотвращения перенаправления указателей, предназначенных для одного расширения, на другое расширение. Например, без использования типов указателей злоумышленник все еще может получить доступ к информации указателя в системе, которая включает как &lt;a href=&quot;fts3&quot;&gt;FTS3, так&lt;/a&gt; и &lt;a href=&quot;carray&quot;&gt;расширение CARRAY,&lt;/a&gt; используя SQL следующим образом:</target>
        </trans-unit>
        <trans-unit id="adee741afd091308ea52b91bf986798eb9c23f39" translate="yes" xml:space="preserve">
          <source>The &quot;pointer type&quot; string which is the last parameter to each of the pointer-passing interfaces should be a distinct, application-specific string literal that appears directly in the API call. The pointer type should not be a parameter passed in from a higher-level function.</source>
          <target state="translated">Строка &quot;тип указателя&quot;,являющаяся последним параметром для каждого из интерфейсов обхода указателей,должна быть отдельным,специфичным для приложения строковым литералом,который появляется непосредственно при вызове API.Тип указателя не должен быть параметром,передаваемым из функции более высокого уровня.</target>
        </trans-unit>
        <trans-unit id="87d3095f178983c8a04814005e7e058687741b3d" translate="yes" xml:space="preserve">
          <source>The &quot;prefix&quot; option, used to add &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;prefix indexes&lt;/a&gt; to an FTS5 table.</source>
          <target state="translated">Параметр &amp;laquo;префикс&amp;raquo;, используемый для добавления &lt;a href=&quot;fts5#prefix_indexes&quot;&gt;индексов префикса&lt;/a&gt; в таблицу FTS5.</target>
        </trans-unit>
        <trans-unit id="007337419b82fead3e9a4bb4ea6d17cd18d879d3" translate="yes" xml:space="preserve">
          <source>The &quot;price of California oranges&quot; query was made more efficient through the use of a two-column index. But SQLite can do even better with a three-column index that also includes the &quot;price&quot; column:</source>
          <target state="translated">Запрос &quot;цена калифорнийских апельсинов&quot; стал более эффективным благодаря использованию двухколоночного индекса.Но еще лучше SQLite может справиться с трехколонным индексом,который также включает в себя столбец &quot;цена&quot;:</target>
        </trans-unit>
        <trans-unit id="57afc82684ba8294d6cce9305c290f392e265962" translate="yes" xml:space="preserve">
          <source>The &quot;profile&quot; method</source>
          <target state="translated">Профильный&quot; метод</target>
        </trans-unit>
        <trans-unit id="a6a8d9f9ad6e3aababd749d5fdde2d82848ad996" translate="yes" xml:space="preserve">
          <source>The &quot;progress&quot; method</source>
          <target state="translated">Метод &quot;прогресса&quot;</target>
        </trans-unit>
        <trans-unit id="588545c2f185476e9dee998a1b045a9b0c16cc70" translate="yes" xml:space="preserve">
          <source>The &quot;quote&quot; output mode honors &quot;.separator&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98ea4147c812e538b99bc21f1f6a4e8e90abfe0" translate="yes" xml:space="preserve">
          <source>The &quot;rbu_control&quot; column may also be set to integer value 2 for an INSERT. In this case, the new row silently replaces any existing row that has the same primary key values. This is equivalent to a DELETE followed by an INSERT with the same primary key values. It is not the same as an SQL REPLACE command, as in that case the new row may replace any conflicting rows (i.e. those that conflict due to UNIQUE constraints or indexes), not just those with conflicting primary keys.</source>
          <target state="translated">Столбец &quot;rbu_control&quot; также может быть установлен в целое значение 2 для INSERT.В этом случае новая строка беззвучно заменяет любую существующую строку,которая имеет те же самые значения первичного ключа.Это эквивалентно DELETE,за которым следует INSERT со значениями тех же первичных ключей.Это не то же самое,что команда SQL REPLACE,так как в этом случае новая строка может заменить любые конфликтующие строки (т.е.те,которые конфликтуют из-за ограничений или индексов UNIQUE),а не только строки с конфликтующими первичными ключами.</target>
        </trans-unit>
        <trans-unit id="a26e076f35ba0ef194f00cabb02d8f0d110dbd9a" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command causes SQLite to discard the entire FTS3/4 table and then rebuild it again from original text. The concept is similar to &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, only that it applies to an FTS3/4 table instead of an ordinary index.</source>
          <target state="translated">Команда &amp;laquo;rebuild&amp;raquo; заставляет SQLite отбрасывать всю таблицу FTS3 / 4, а затем заново строить ее из исходного текста. Эта концепция похожа на &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; , только она применяется к таблице FTS3 / 4 вместо обычного индекса.</target>
        </trans-unit>
        <trans-unit id="9dfe3ef5f9d0e5aefda4d198135af7dfc82b7ad7" translate="yes" xml:space="preserve">
          <source>The &quot;rebuild&quot; command should be run whenever the implementation of a custom tokenizer changes, so that all content can be retokenized. The &quot;rebuild&quot; command is also useful when using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; after changes have been made to the original content table.</source>
          <target state="translated">Команду &amp;laquo;rebuild&amp;raquo; следует запускать всякий раз, когда изменяется реализация настраиваемого токенизатора, чтобы все содержимое можно было повторно токенизировать. Команда &amp;laquo;rebuild&amp;raquo; также полезна при использовании &lt;a href=&quot;fts3#*fts4content&quot;&gt;опции содержимого FTS4&lt;/a&gt; после того, как были внесены изменения в исходную таблицу содержимого.</target>
        </trans-unit>
        <trans-unit id="c9e0f27230c23e1210b0f85831927b9fb4ed65b1" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method</source>
          <target state="translated">Метод &quot;восстановления&quot;</target>
        </trans-unit>
        <trans-unit id="24c21c10984afe5581e89897013fce4a408ba45f" translate="yes" xml:space="preserve">
          <source>The &quot;restore&quot; method copies the content from a separate database file into the current database connection, overwriting any preexisting content. The command syntax is like this:</source>
          <target state="translated">Метод &quot;восстановления&quot; копирует содержимое из отдельного файла БД в текущее подключение к БД,перезаписывая любое существовавшее ранее содержимое.Синтаксис команды такой:</target>
        </trans-unit>
        <trans-unit id="9587ea916bf4a39318094206a7a32f2bcdfaa5ba" translate="yes" xml:space="preserve">
          <source>The &quot;rollback_hook&quot; method</source>
          <target state="translated">Метод &quot;rollback_hook&quot;</target>
        </trans-unit>
        <trans-unit id="e00d488bea46afaaecd75512057a1c66d8fe6370" translate="yes" xml:space="preserve">
          <source>The &quot;score&quot; for a comparison is the edit distance between the pattern and the word, adjusted down by the base-2 logarithm of the word rank. For example, a match with distance 100 but rank 1000 would have a score of 122 (= 100 - log2(1000) + 32) whereas a match with distance 100 with a rank of 1 would have a score of 131 (100 - log2(1) + 32). (NB: The constant 32 is added to each score to keep it from going negative in case the edit distance is zero.) In this way, frequently used words get a slightly lower cost which tends to move them toward the top of the list of alternative spellings.</source>
          <target state="translated">Оценка&quot; для сравнения-это редактируемое расстояние между деталью и словом,скорректированное вниз по логарифму слова &quot;ранг&quot; (базовый-2 логарифм).Например,при сравнении расстояния 100,но ранга 1000,оценка 122 (=100-log2(1000)+32),тогда как при сравнении расстояния 100,но ранга 1,оценка 131 (100-log2(1)+32).(NB:К каждой оценке добавляется константа 32,чтобы она не стала отрицательной в случае,если дистанция редактирования равна нулю).Таким образом,часто употребляемые слова получают немного меньшую стоимость,что имеет тенденцию перемещать их к вершине списка альтернативных заклинаний.</target>
        </trans-unit>
        <trans-unit id="5c73b0b5b1beb7568fc6d18b01b575dea3734b9a" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method</source>
          <target state="translated">Метод &quot;сериализации&quot;</target>
        </trans-unit>
        <trans-unit id="3d89d42c3828f01cc4451e3643a15ed26533dc51" translate="yes" xml:space="preserve">
          <source>The &quot;serialize&quot; method creates a BLOB which is a complete copy of an underlying database. The syntax is like this:</source>
          <target state="translated">Метод &quot;сериализации&quot; создает BLOB,который является полной копией баз данных.Синтаксис такой:</target>
        </trans-unit>
        <trans-unit id="d8ecb1d818748f027a6df9d4ecf31fdb4abf6802" translate="yes" xml:space="preserve">
          <source>The &quot;size&quot; of a row value is the number of scalar values the row value contains. The size of a row value is always at least 2. A row value with a single column is just a scalar value. A row value with no columns is a syntax error.</source>
          <target state="translated">Размер&quot; значения строки-это количество скалярных значений,которое содержит значение строки.Размер значения строки всегда не менее 2,а значение строки с одним столбцом-всего лишь скалярное значение.Значение строки без столбцов является синтаксической ошибкой.</target>
        </trans-unit>
        <trans-unit id="5edd5de6e6f1cc913259bc478dccfe21c6a5d5fb" translate="yes" xml:space="preserve">
          <source>The &quot;speedtest1.c&quot; program estimates the performance of SQLite under a typical workload.</source>
          <target state="translated">Программа &quot;speedtest1.c&quot; оценивает производительность SQLite при типичной рабочей нагрузке.</target>
        </trans-unit>
        <trans-unit id="94d1e1fa50bdc62251cad63515806a616cb08e98" translate="yes" xml:space="preserve">
          <source>The &quot;spellfix1&quot; term is the name of the spellfix module and must be entered as shown. The &quot;demo&quot; term is the name of the virtual table you will be creating and can be altered to suit the needs of your application. The virtual table is initially empty. In order for the virtual table to be useful, you will need to populate it with your vocabulary. Suppose you have a list of words in a table named &quot;big_vocabulary&quot;. Then do this:</source>
          <target state="translated">Термин &quot;spellfix1&quot; является названием модуля правописания и должен вводиться в соответствии с указаниями.Демонстрационный&quot; термин-это название виртуальной таблицы,которую вы будете создавать,и может быть изменен в соответствии с потребностями вашего приложения.Виртуальная таблица изначально пуста.Для того чтобы виртуальный стол был полезен,необходимо заполнить его своим словарным запасом.Предположим,у Вас есть список слов в таблице под названием &quot;big_vocabulary&quot;.Тогда сделайте это:</target>
        </trans-unit>
        <trans-unit id="1f251add4c0609e09930cd5b2e1c244e554f6696" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; code file contains default implementations of a VFS and of the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; functions that are appropriate for Unix, Windows, and OS/2. To prevent one of these default components from being loaded when sqlite3.c is compiled, it is necessary to add the following compile-time option:</source>
          <target state="translated">Файл кода &quot;sqlite3.c&quot; содержит стандартные реализации VFS и функций &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; и &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; , которые подходят для Unix, Windows и OS / 2. Чтобы предотвратить загрузку одного из этих компонентов по умолчанию при компиляции sqlite3.c, необходимо добавить следующую опцию времени компиляции:</target>
        </trans-unit>
        <trans-unit id="d25afe467d47fff3cdb66b829147595e777d2e30" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3.c&quot; make target will automatically construct the regular &quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot; amalgamation source file, its header file &quot;&lt;b&gt;sqlite3.h&lt;/b&gt;&quot;, and the &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot; amalgamation source file that includes the TCL interface. Afterwards, the needed files can be copied into project directories and compiled according to the procedures outlined above.</source>
          <target state="translated">Цель make &quot;sqlite3.c&quot; автоматически &lt;b&gt;создаст обычный&lt;/b&gt; исходный файл объединения &quot; &lt;b&gt;sqlite3.c&lt;/b&gt; &quot;, его файл заголовка &quot; &lt;b&gt;sqlite3.h&lt;/b&gt; &quot; и исходный файл объединения &quot; &lt;b&gt;tclsqlite3.c&lt;/b&gt; &quot;, который включает интерфейс TCL. После этого необходимые файлы можно скопировать в каталоги проекта и скомпилировать в соответствии с процедурами, описанными выше.</target>
        </trans-unit>
        <trans-unit id="66d4d7e86561a6b1d54c81eff00582173909b3a6" translate="yes" xml:space="preserve">
          <source>The &quot;sqlite3_analyzer.exe&quot; utility program, available as source code in the SQLite source tree or as a precompiled binary on the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite Download page&lt;/a&gt;, can be used to measure the average sizes of table rows in an existing SQLite database.</source>
          <target state="translated">Служебная программа sqlite3_analyzer.exe, доступная в виде исходного кода в дереве исходного кода SQLite или в виде предварительно скомпилированного двоичного файла на &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;странице загрузки SQLite&lt;/a&gt; , может использоваться для измерения средних размеров строк таблицы в существующей базе данных SQLite.</target>
        </trans-unit>
        <trans-unit id="ff30531d333139aba53fa40d0cdd26055103901a" translate="yes" xml:space="preserve">
          <source>The &quot;start match&quot; text.</source>
          <target state="translated">Текст &quot;стартовое совпадение&quot;.</target>
        </trans-unit>
        <trans-unit id="b039029daf858be6adbac43c34475b31375cdd36" translate="yes" xml:space="preserve">
          <source>The &quot;start of&quot; modifiers (7 through 9) shift the date backwards to the beginning of the current month, year or day.</source>
          <target state="translated">Начало&quot; модификаторов (от 7 до 9)сдвигает дату назад к началу текущего месяца,года или дня.</target>
        </trans-unit>
        <trans-unit id="05b5d073f83b249218dde4220e351fdb9c81957d" translate="yes" xml:space="preserve">
          <source>The &quot;state&quot; index works just like the &quot;fruit&quot; index in that it is a new table with an extra column in front of the rowid and sorted by that extra column as the primary key. The only difference is that in Idx2, the first column is &quot;state&quot; instead of &quot;fruit&quot; as it is with Idx1. In our example data set, there is more redundancy in the &quot;state&quot; column and so they are more duplicate entries. The ties are still resolved using the rowid.</source>
          <target state="translated">Индекс &quot;состояния&quot; работает точно так же,как и индекс &quot;фруктов&quot;,в том смысле,что это новая таблица с дополнительным столбцом перед строкой,отсортированная по этому дополнительному столбцу в качестве первичного ключа.Единственное отличие состоит в том,что в индексе Idx2 первый столбец-это &quot;состояние&quot;,а не &quot;плод&quot;,как в индексе Idx1.В нашем примере набора данных,в столбце &quot;состояние&quot; больше избыточности,и поэтому они являются более дублирующимися записями.Связи все еще разрешаются с помощью rowid.</target>
        </trans-unit>
        <trans-unit id="cf055db4baca803941f56b418b3f79cd69d69f75" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; method</source>
          <target state="translated">Метод &quot;статуса&quot;</target>
        </trans-unit>
        <trans-unit id="4cb7bc19f02c001a06f5cf0e9a288feeb79d31b6" translate="yes" xml:space="preserve">
          <source>The &quot;swarmvtab&quot; virtual table allows the user to query a large number of tables (hereafter &quot;component&quot; tables) with similar schemas but distinct ranges of rowid values as if they were a single database table. The tables may be (and usually are) located in different databases. Swarmvtab tables are read-only.</source>
          <target state="translated">Виртуальная таблица &quot;swarmvtab&quot; позволяет пользователю опрашивать большое количество таблиц (далее-&quot;составные&quot; таблицы)со схожими схемами,но с различными диапазонами значений рядов,как если бы они были одной таблицей БД.Эти таблицы могут находиться (и,как правило,находятся)в разных БД.Таблицы Swarmvtab доступны только для чтения.</target>
        </trans-unit>
        <trans-unit id="dab19bcea20e3ab7d9ecf3510719cf0224e13f4a" translate="yes" xml:space="preserve">
          <source>The &quot;sz&quot; parameter is the size in bytes of each lookaside slot. The &quot;cnt&quot; parameter is the total number of lookaside memory slots per database connection. The total amount of lookaside memory allocated to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is sz*cnt bytes.</source>
          <target state="translated">Параметр &amp;laquo;sz&amp;raquo; - это размер в байтах каждого дополнительного слота. Параметр &amp;laquo;cnt&amp;raquo; - это общее количество дополнительных слотов памяти на одно соединение с базой данных. Общий объем дополнительной памяти, выделенной для каждого &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных,&lt;/a&gt; составляет sz * cnt байт.</target>
        </trans-unit>
        <trans-unit id="21cc2584b07fb547745b9d5684016c88291d98ce" translate="yes" xml:space="preserve">
          <source>The &quot;sz=NNN&quot; argument (where NNN represents a sequence of 1 or more digits) means that the average row size over all records of the table or index is NNN bytes per row. The SQLite query planner might use the estimated row size information provided by the &quot;sz=NNN&quot; token to help it choose smaller tables and indexes that require less disk I/O.</source>
          <target state="translated">Аргумент &quot;sz=NNN&quot; (где NNN представляет собой последовательность из 1 или более цифр)означает,что средний размер строки над всеми записями таблицы или индекса составляет NNN байт на строку.Планировщик запросов SQLite может использовать информацию об оценочном размере строки,предоставляемую маркером &quot;sz=NNN&quot;,чтобы помочь ему выбрать меньшие по размеру таблицы и индексы,требующие меньшего количества дисковых входов/выходов.</target>
        </trans-unit>
        <trans-unit id="1f5faa11cc0f3cca617edc23b678832f22fc7469" translate="yes" xml:space="preserve">
          <source>The &quot;temp&quot; database (in which TEMP tables and indices are stored) and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; always uses exclusive locking mode. The locking mode of temp and &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; cannot be changed. All other databases use the normal locking mode by default and are affected by this pragma.</source>
          <target state="translated">База данных &amp;laquo;temp&amp;raquo; (в которой хранятся таблицы и индексы TEMP) и &lt;a href=&quot;inmemorydb&quot;&gt;базы данных в памяти&lt;/a&gt; всегда используют режим монопольной блокировки. Режим блокировки временных &lt;a href=&quot;inmemorydb&quot;&gt;баз данных и баз данных в памяти&lt;/a&gt; изменить нельзя. Все остальные базы данных по умолчанию используют нормальный режим блокировки, и на них влияет эта прагма.</target>
        </trans-unit>
        <trans-unit id="8cb92fbf85091b767df43e1863c69aa8515916b3" translate="yes" xml:space="preserve">
          <source>The &quot;test1.dir&quot; directory created above puts all the blobs into a single folder. It was conjectured that some operating systems would perform poorly when a single directory contains 100,000 objects. To test this, the kvtest program can also store the blobs in a hierarchy of folders with no more than 100 files and/or subdirectories per folder. The alternative on-disk representation of the blobs can be created using the --tree command-line option to the &quot;export&quot; command, like this:</source>
          <target state="translated">Созданный выше каталог &quot;test1.dir&quot; помещает все блобы в одну папку.Предполагалось,что некоторые операционные системы будут работать плохо,если в одной папке будет 100 000 объектов.Для проверки этого программа kvtest может также хранить капли в иерархии папок,содержащих не более 100 файлов и/или подкаталогов в каждой папке.Альтернативное представление блобов на диске может быть создано с помощью опции командной строки --tree для команды &quot;экспортировать&quot;:</target>
        </trans-unit>
        <trans-unit id="9e8c625e743111097d3b7602f25647d8fd5f0deb" translate="yes" xml:space="preserve">
          <source>The &quot;th3&quot; binary is run and the output checked for errors.</source>
          <target state="translated">Двоичный файл &quot;th3&quot; запускается,а выход проверяется на наличие ошибок.</target>
        </trans-unit>
        <trans-unit id="405706da87374261dc84d98a92672d2aa3e6824d" translate="yes" xml:space="preserve">
          <source>The &quot;threadtest3.c&quot; program is a stress test for multiple threads using SQLite simultaneously.</source>
          <target state="translated">Программа &quot;threadtest3.c&quot;-это стресс-тест для нескольких потоков,использующих SQLite одновременно.</target>
        </trans-unit>
        <trans-unit id="c2ea8ab5c5050c4a238a6302498853dd2f689e62" translate="yes" xml:space="preserve">
          <source>The &quot;three&quot; column -- the key to the bucket</source>
          <target state="translated">Колонка &quot;три&quot;-ключ к ведру.</target>
        </trans-unit>
        <trans-unit id="4fa8abbe4c1763e70302352dd8c5a5a17e072b27" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method</source>
          <target state="translated">Метод &quot;таймаута&quot;</target>
        </trans-unit>
        <trans-unit id="7d44f83daf7e28e3193a3ecca21e30ba205796c2" translate="yes" xml:space="preserve">
          <source>The &quot;timeout&quot; method is used to control how long the SQLite library will wait for locks to clear before giving up on a database transaction. The default timeout is 0 millisecond. (In other words, the default behavior is not to wait at all.)</source>
          <target state="translated">Метод &quot;таймаута&quot; используется для контроля за тем,как долго библиотека SQLite будет ждать очистки замков,прежде чем отказаться от транзакции с БД.По умолчанию таймаут равен 0 миллисекундам.(Другими словами,поведение по умолчанию-вовсе не ждать).</target>
        </trans-unit>
        <trans-unit id="7ac730ff83376aab14adb2a2686e6b4272b35baf" translate="yes" xml:space="preserve">
          <source>The &quot;tokenize&quot; option, used to configure a &lt;a href=&quot;fts5#tokenizers&quot;&gt;custom tokenizer&lt;/a&gt;.</source>
          <target state="translated">Параметр &amp;laquo;tokenize&amp;raquo;, используемый для настройки &lt;a href=&quot;fts5#tokenizers&quot;&gt;настраиваемого токенизатора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5924f14d286c018a59c3ed95d3124a43c86bfc19" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method</source>
          <target state="translated">Метод &quot;total_changes&quot;</target>
        </trans-unit>
        <trans-unit id="67201b01d24a416fed46b29f515a9e7ed51080c3" translate="yes" xml:space="preserve">
          <source>The &quot;total_changes&quot; method returns an integer which is the number of rows in the database that were inserted, deleted, and/or modified since the current database connection was first opened.</source>
          <target state="translated">Метод &quot;total_changes&quot; возвращает целое число-количество строк в БД,которые были вставлены,удалены и/или изменены с момента первого открытия текущего соединения с БД.</target>
        </trans-unit>
        <trans-unit id="7e6156617165c2bee31d2c34a55e3df2f7ee7cbc" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method</source>
          <target state="translated">Метод &quot;следа&quot;</target>
        </trans-unit>
        <trans-unit id="b2906df9327952a977291763abf36d4cd7917ee1" translate="yes" xml:space="preserve">
          <source>The &quot;trace&quot; method registers a callback that is invoked as each SQL statement is compiled. The text of the SQL is appended as a single string to the command before it is invoked. This can be used (for example) to keep a log of all SQL operations that an application performs.</source>
          <target state="translated">Метод &quot;трассировки&quot; регистрирует обратный вызов,который вызывается по мере компиляции каждого SQL-оператора.Текст SQL-оператора добавляется к команде как единая строка перед ее вызовом.Это может быть использовано (например)для ведения журнала всех SQL-операций,выполняемых приложением.</target>
        </trans-unit>
        <trans-unit id="ce50004a13c3fcabcb6ebda341338c2b6ecfb280" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method</source>
          <target state="translated">Метод &quot;trace_v2&quot;</target>
        </trans-unit>
        <trans-unit id="2fe37d0c891dddf24c1d50f2d3327a7f07cf31d0" translate="yes" xml:space="preserve">
          <source>The &quot;trace_v2&quot; method registers a callback that is invoked as each SQL statement is compiled. The syntax is as follows:</source>
          <target state="translated">Метод &quot;trace_v2&quot; регистрирует обратный вызов,который вызывается при компиляции каждого SQL-оператора.Синтаксис таков:</target>
        </trans-unit>
        <trans-unit id="e9e9294106d107e583dc783efd0d04b347f737f9" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method</source>
          <target state="translated">Метод &quot;сделки&quot;</target>
        </trans-unit>
        <trans-unit id="839415a25e55cb5e0ba1d1d3bedbc6f8468c1f73" translate="yes" xml:space="preserve">
          <source>The &quot;transaction&quot; method is used to execute a TCL script inside an SQLite database transaction. The transaction is committed when the script completes, or it rolls back if the script fails. If the transaction occurs within another transaction (even one that is started manually using BEGIN) it is a no-op.</source>
          <target state="translated">Метод &quot;транзакции&quot; используется для выполнения TCL-скрипта внутри транзакции БД SQLite.Транзакция фиксируется,когда скрипт завершает работу,или откатывается,если скрипт дает сбой.Если транзакция происходит внутри другой транзакции (даже той,которая запускается вручную с помощью BEGIN),то она не работает.</target>
        </trans-unit>
        <trans-unit id="378f72a23dc895cffd3910e611b45425aeb46721" translate="yes" xml:space="preserve">
          <source>The &quot;type&quot; column is an SQL text value taken from ('null', 'true', 'false', 'integer', 'real', 'text', 'array', 'object') according to the type of the current JSON element.</source>
          <target state="translated">Столбец &quot;type&quot;-это SQL-текстовое значение,взятое из ('null','true','false','integer','real','text','array','object')в соответствии с типом текущего JSON-элемента.</target>
        </trans-unit>
        <trans-unit id="135f2f5e5d2c30f651d7adf36038240ab6497277" translate="yes" xml:space="preserve">
          <source>The &quot;typical&quot; workload is generated by the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; program in the canonical SQLite source tree. This program strives to exercise the SQLite library in a way that is typical of real-world applications. Of course, every application is different, and so no test program can exactly mirror the behavior of all applications.</source>
          <target state="translated">&amp;laquo;Типичная&amp;raquo; рабочая нагрузка создается программой &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; в каноническом дереве исходного кода SQLite. Эта программа стремится использовать библиотеку SQLite способом, типичным для реальных приложений. Конечно, каждое приложение индивидуально, поэтому ни одна тестовая программа не может точно отражать поведение всех приложений.</target>
        </trans-unit>
        <trans-unit id="27bfc78b4ec7e83cf7c09ae529723bb27ae007c2" translate="yes" xml:space="preserve">
          <source>The &quot;ui&quot; command will cause fossil to run a miniature built-in webserver and to launch your web-browser pointing at that webserver. You can use your web-browser to configure your project in various ways. See the instructions on the fossil website for additional information.</source>
          <target state="translated">Команда &quot;ui&quot; заставит ископаемого запустить миниатюрный встроенный веб-сервер и запустить веб-браузер,указывающий на этот веб-сервер.Вы можете использовать Ваш web-браузер для настройки Вашего проекта различными способами.Для получения дополнительной информации обратитесь к инструкциям на ископаемом веб-сайте.</target>
        </trans-unit>
        <trans-unit id="d78919ab60690742844f0ae8327639ff7f7b254a" translate="yes" xml:space="preserve">
          <source>The &quot;unicode61&quot; tokenizer is available beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11). Unicode61 works very much like &quot;simple&quot; except that it does simple unicode case folding according to rules in Unicode Version 6.1 and it recognizes unicode space and punctuation characters and uses those to separate tokens. The simple tokenizer only does case folding of ASCII characters and only recognizes ASCII space and punctuation characters as token separators.</source>
          <target state="translated">Токенизатор &amp;laquo;unicode61&amp;raquo; доступен, начиная с &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;версии&lt;/a&gt; SQLite 3.7.13 (2012-06-11). Unicode61 работает очень похоже на &amp;laquo;простой&amp;raquo;, за исключением того, что он выполняет простое сворачивание регистра Unicode в соответствии с правилами Unicode Version 6.1, распознает пробелы и знаки пунктуации Unicode и использует их для разделения токенов. Простой токенизатор выполняет сворачивание только регистра символов ASCII и распознает только символы пробела и пунктуации ASCII в качестве разделителей токенов.</target>
        </trans-unit>
        <trans-unit id="53568b33d00330dcebc8eb48a597c612134f3558" translate="yes" xml:space="preserve">
          <source>The &quot;unixepoch&quot; modifier (11) only works if it immediately follows a timestring in the DDDDDDDDDD format. This modifier causes the DDDDDDDDDD to be interpreted not as a Julian day number as it normally would be, but as &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix Time&lt;/a&gt; - the number of seconds since 1970. If the &quot;unixepoch&quot; modifier does not follow a timestring of the form DDDDDDDDDD which expresses the number of seconds since 1970 or if other modifiers separate the &quot;unixepoch&quot; modifier from prior DDDDDDDDDD then the behavior is undefined. For SQLite versions before 3.16.0 (2017-01-02), the &quot;unixepoch&quot; modifier only works for dates between 0000-01-01 00:00:00 and 5352-11-01 10:52:47 (unix times of -62167219200 through 106751991167).</source>
          <target state="translated">Модификатор &amp;laquo;unixepoch&amp;raquo; (11) работает только в том случае, если он следует сразу за временной строкой в ​​формате DDDDDDDDDD. Этот модификатор заставляет DDDDDDDDDD интерпретироваться не как номер дня по юлианскому календарю, как это обычно бывает, а как &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;время Unix&lt;/a&gt; - количество секунд с 1970 года. Если модификатор &quot;unixepoch&quot; не следует за временной строкой в ​​форме DDDDDDDDDD, которая выражает количество секунд с 1970 года или если другие модификаторы отделяют модификатор unixepoch от предыдущего DDDDDDDDDD, то поведение не определено. Для версий SQLite до 3.16.0 (02.01.2017) модификатор &quot;unixepoch&quot; работает только для дат между 0000-01-01 00:00:00 и 5352-11-01 10:52:47 (время unix С -62167219200 по 106751991167).</target>
        </trans-unit>
        <trans-unit id="9a380264abb876efbc0e0abf2e6a2f4c233a20b1" translate="yes" xml:space="preserve">
          <source>The &quot;unlock_notify&quot; method</source>
          <target state="translated">Метод &quot;unlock_notify&quot;</target>
        </trans-unit>
        <trans-unit id="a59aa60915a8fc6bc6f97fdfa3c585be19ca1408" translate="yes" xml:space="preserve">
          <source>The &quot;update_hook&quot; method</source>
          <target state="translated">Метод &quot;update_hook&quot;</target>
        </trans-unit>
        <trans-unit id="ad1e96bd97056b4fb89ac4a9d66b380d5f0978cd" translate="yes" xml:space="preserve">
          <source>The &quot;usable size&quot; of a database page is the page size specified by the 2-byte integer at offset 16 in the header less the &quot;reserved&quot; space size recorded in the 1-byte integer at offset 20 in the header. The usable size of a page might be an odd number. However, the usable size is not allowed to be less than 480. In other words, if the page size is 512, then the reserved space size cannot exceed 32.</source>
          <target state="translated">Полезный размер&quot; страницы БД-это размер страницы,задаваемый 2-байтовым целым числом со смещением 16 в заголовке за вычетом &quot;зарезервированного&quot; размера пространства,записанного в 1-байтовом целом числе со смещением 20 в заголовке.Полезный размер страницы может быть нечетным числом.Однако,допустимый размер не может быть меньше 480.Другими словами,если размер страницы 512,то размер зарезервированного пространства не может превышать 32.</target>
        </trans-unit>
        <trans-unit id="0117a41a4edb11977b96c0bfbaf5ae135dd4dc28" translate="yes" xml:space="preserve">
          <source>The &quot;user version&quot; as read and set by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">&quot;Версия пользователя&quot;, прочитанная и установленная &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;прагмой user_version&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f1221e2090e85cfaa0707db328c83c8e04e4462" translate="yes" xml:space="preserve">
          <source>The &quot;verb&quot; argument determines what statistic is accessed. There are &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;various verbs&lt;/a&gt; defined. The list is expected to grow as the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface matures. The current value the selected parameter is written into integer &quot;current&quot; and the highest historical value is written into integer &quot;highwater&quot;. If resetflag is true, then the high-water mark is reset down to the current value after the call returns.</source>
          <target state="translated">Аргумент &amp;laquo;глагол&amp;raquo; определяет, к какой статистике осуществляется доступ. Есть &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;разные&lt;/a&gt; определения глаголов . Ожидается, что список будет расти по мере развития интерфейса &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; . Текущее значение выбранного параметра записывается в целое число &amp;laquo;current&amp;raquo;, а максимальное историческое значение записывается в целое &amp;laquo;highwater&amp;raquo;. Если resetflag имеет значение true, то отметка максимального уровня сбрасывается до текущего значения после возврата вызова.</target>
        </trans-unit>
        <trans-unit id="fa357090791a4202ebbb1affe438340a7edf58ef" translate="yes" xml:space="preserve">
          <source>The &quot;version&quot; method</source>
          <target state="translated">Метод &quot;версии&quot;</target>
        </trans-unit>
        <trans-unit id="cd6ed1a853164caf36a9ec472723c210aaf3324f" translate="yes" xml:space="preserve">
          <source>The &quot;wal_hook&quot; method</source>
          <target state="translated">Метод &quot;wal_hook&quot;</target>
        </trans-unit>
        <trans-unit id="13953b9d13af87a94ab5c5d6a6cf14aaf24d8b07" translate="yes" xml:space="preserve">
          <source>The &quot;weekday&quot; modifier advances the date forward, if necessary, to the next date where the weekday number is N. Sunday is 0, Monday is 1, and so forth. If the date is already on the desired weekday, the &quot;weekday&quot; modifier leaves the date unchanged.</source>
          <target state="translated">Модификатор &quot;День недели&quot; переносит дату вперед,при необходимости,на следующую дату,где номер дня недели-N.Воскресенье-0,понедельник-1 и так далее.Если дата уже в нужный день недели,то модификатор &quot;День недели&quot; оставляет эту дату без изменений.</target>
        </trans-unit>
        <trans-unit id="fc5b825d3bb551c0ffab90d4aebeaa4b072d1ccb" translate="yes" xml:space="preserve">
          <source>The $nExtCode extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">Коды расширенных результатов $ nExtCode &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;определены в sqlite3.h&lt;/a&gt; и перечислены в алфавитном порядке ниже:</target>
        </trans-unit>
        <trans-unit id="d7c45544c374d408b5b737fa2b109d54d1a57530" translate="yes" xml:space="preserve">
          <source>The $nPrimCode result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="translated">Коды результатов $ nPrimCode &lt;a href=&quot;c3ref/c_abort&quot;&gt;определены в sqlite3.h&lt;/a&gt; и перечислены в алфавитном порядке ниже:</target>
        </trans-unit>
        <trans-unit id="3ab512eff5b3fb377f299e58700487486d503855" translate="yes" xml:space="preserve">
          <source>The $prefix parameter may be NULL, in which case the prefix is deduced from $wholeline. Or, the $wholeline parameter may be NULL or omitted if context information is unavailable or if context-aware completion is not desired.</source>
          <target state="translated">Параметр $prefix может быть NULL,в этом случае префикс вычитается из $wholeline.Или параметр $wholeline может быть NULL или опущен,если контекстная информация недоступна или если не требуется контекстное завершение.</target>
        </trans-unit>
        <trans-unit id="02bbc5a1a7e84666a4d4dd0cec4c28449ae27a6f" translate="yes" xml:space="preserve">
          <source>The %_content table contains the unadulterated data inserted by the user into the FTS virtual table by the user. If the user does not explicitly supply a &quot;docid&quot; value when inserting records, one is selected automatically by the system.</source>
          <target state="translated">Таблица %_content содержит данные,вставленные пользователем в виртуальную таблицу FTS.Если при вставке записей пользователь явно не указывает значение &quot;docid&quot;,то оно выбирается системой автоматически.</target>
        </trans-unit>
        <trans-unit id="7ff27a5cb67628299a86678a48c0336fb247a12c" translate="yes" xml:space="preserve">
          <source>The %_stat and %_docsize tables are only created if the FTS table uses the FTS4 module, not FTS3. Furthermore, the %_docsize table is omitted if the FTS4 table is created with the &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; directive specified as part of the CREATE VIRTUAL TABLE statement. If they are created, the schema of the two tables is as follows:</source>
          <target state="translated">Таблицы% _stat и% _docsize создаются только в том случае, если таблица FTS использует модуль FTS4, а не FTS3. Кроме того, таблица% _docsize опускается, если таблица FTS4 создается с помощью директивы &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo = fts3,&lt;/a&gt; указанной как часть оператора CREATE VIRTUAL TABLE. Если они созданы, схема двух таблиц будет следующей:</target>
        </trans-unit>
        <trans-unit id="c824e78a5796a4ada97aea7265fbe991ac4b8766" translate="yes" xml:space="preserve">
          <source>The %q and %Q substitutions are SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">Подстановки %q и %Q являются усовершенствованиями SQLite,не встречающимися в большинстве других реализаций printf().</target>
        </trans-unit>
        <trans-unit id="38a9fc3133aa73e0b29b95de437699b671e4c4f6" translate="yes" xml:space="preserve">
          <source>The %s substitution is universal, but the %z substitution is an SQLite enhancement, not found in other printf() implementations.</source>
          <target state="translated">Подстановка %s является универсальной,но подстановка %z является усовершенствованием SQLite,не встречающимся в других реализациях printf().</target>
        </trans-unit>
        <trans-unit id="4b87f6c99821c5908fd04958d29e2e7c01fcfa39" translate="yes" xml:space="preserve">
          <source>The %w substitution is an SQLite enhancements, not found in most other printf() implementations.</source>
          <target state="translated">Замена %w является усовершенствованием SQLite,не встречающимся в большинстве других реализаций printf().</target>
        </trans-unit>
        <trans-unit id="05ed0c85ed4fa11e23eab78d700cba29a96e54ed" translate="yes" xml:space="preserve">
          <source>The '%' character is used in requirement H35300 to represent the modulo operator, just as it is in programming languages such as C, Java and Javascript.</source>
          <target state="translated">Символ &quot;%&quot; используется в требовании H35300 для представления оператора modulo,так же как и в языках программирования,таких как C,Java и Javascript.</target>
        </trans-unit>
        <trans-unit id="e9354cba92715c3a8151b0bdbb532432be7bdd61" translate="yes" xml:space="preserve">
          <source>The 'crisismerge' option is similar to 'automerge', in that it determines how and how often the component b-trees that make up the full-text index are merged together. Once there exist</source>
          <target state="translated">Опция &quot;crisismerge&quot; аналогична опции &quot;automerge&quot; в том,что она определяет,как и как часто соединяются составные b-дерева,составляющие полнотекстовый индекс.Как только они существуют</target>
        </trans-unit>
        <trans-unit id="139c169421eec1791495afdd3b65ecbf6f7f8622" translate="yes" xml:space="preserve">
          <source>The *+* operator on the *x* column will prevent that term from constraining an index. This would force the use of the ex2i2 index.</source>
          <target state="translated">Оператор *+*в столбце *x*предотвратит ограничение индекса этим термином.Это заставит использовать индекс ex2i2.</target>
        </trans-unit>
        <trans-unit id="fe65d357eb360ea29fe1d68436790805aab233d0" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">Параметр * pHighwater записывает самый глубокий стек синтаксического анализатора. Значение * pCurrent не определено. Значение * pHighwater имеет смысл только в том случае, если SQLite скомпилирован с &lt;a href=&quot;../compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1ea66787615c66d86376977b69791f61618b2a2" translate="yes" xml:space="preserve">
          <source>The *pHighwater parameter records the deepest parser stack. The *pCurrent value is undefined. The *pHighwater value is only meaningful if SQLite is compiled with &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt;.</source>
          <target state="translated">Параметр * pHighwater записывает самый глубокий стек синтаксического анализатора. Значение * pCurrent не определено. Значение * pHighwater имеет смысл только в том случае, если SQLite скомпилирован с &lt;a href=&quot;compile#yytrackmaxstackdepth&quot;&gt;YYTRACKMAXSTACKDEPTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a0209d4ffca3af22d05eab8c450129e95986f2c" translate="yes" xml:space="preserve">
          <source>The --blob-api option on the database read test causes kvtest to use the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; feature of SQLite to load the content of the blobs, rather than running pure SQL statements. This helps SQLite to run a little faster on read tests. You can omit that option to compare the performance of SQLite running SQL statements. In that case, the SQLite still out-performs direct reads, though by not as much as when using &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;. The --blob-api option is ignored for tests that read from individual disk files.</source>
          <target state="translated">Параметр --blob-api в тесте чтения базы данных заставляет kvtest использовать функцию &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; SQLite для загрузки содержимого больших двоичных объектов, а не запускать чистые операторы SQL. Это помогает SQLite работать немного быстрее в тестах чтения. Вы можете опустить эту опцию, чтобы сравнить производительность SQLite, выполняющего операторы SQL. В этом случае SQLite по-прежнему превосходит прямые чтения, хотя и не так сильно, как при использовании &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; . Параметр --blob-api игнорируется для тестов, которые читают из отдельных файлов на диске.</target>
        </trans-unit>
        <trans-unit id="aeee09a9fb263d7d0932e1687159faa31b022fff" translate="yes" xml:space="preserve">
          <source>The --deserialize option associated with opening a new database cause the database file to be read into memory and accessed using the &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; API. This simplifies running tests on a database without modifying the file on disk.</source>
          <target state="translated">Параметр --deserialize, связанный с открытием новой базы данных, вызывает чтение файла базы данных в память и доступ к нему с помощью API &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; . Это упрощает выполнение тестов в базе данных без изменения файла на диске.</target>
        </trans-unit>
        <trans-unit id="11d3b8386b1e3ccb1cc08c05d6ada4438f0769ba" translate="yes" xml:space="preserve">
          <source>The --primarykey flag changes the pairing algorithm slightly so that the schema-declared &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; is always used for pairing, even on tables that have a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;. This is often a better choice for finding differences, however it can lead to missed differences in the case of rows that have one or more PRIMARY KEY columns set to NULL.</source>
          <target state="translated">Флаг --primarykey слегка изменяет алгоритм связывания, так что &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY,&lt;/a&gt; объявленный схемой, всегда используется для связывания, даже в таблицах с &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; . Часто это лучший выбор для поиска различий, однако он может привести к пропущенным различиям в случае строк, в которых для одного или нескольких столбцов PRIMARY KEY установлено значение NULL.</target>
        </trans-unit>
        <trans-unit id="5cd46599c902c6e8fdb69c21ede0585852a486b3" translate="yes" xml:space="preserve">
          <source>The --update and --insert commands work like --create command, except that they do not delete the current archive before commencing. New versions of files silently replace existing files with the same names, but otherwise the initial contents of the archive (if any) remain intact.</source>
          <target state="translated">Команды --update и --insert работают как команда --creatate,за исключением того,что они не удаляют текущий архив перед началом работы.Новые версии файлов беззвучно заменяют существующие файлы на те же имена,но в противном случае исходное содержимое архива (если таковое имеется)остается нетронутым.</target>
        </trans-unit>
        <trans-unit id="92d15467647a321ed86c3b0d4ddfb73a9334e61d" translate="yes" xml:space="preserve">
          <source>The -ldl library is needed to support dynamic loading, the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface and the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;. If these features are not required, then they can be omitted using &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; compile-time option:</source>
          <target state="translated">Библиотека -ldl необходима для поддержки динамической загрузки, интерфейса &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;функции SQL load_extension ()&lt;/a&gt; . Если эти функции не требуются, их можно опустить с помощью &lt;a href=&quot;compile#omit_load_extension&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_OMIT_LOAD_EXTENSION :</target>
        </trans-unit>
        <trans-unit id="ff976c7e2e67ea0658ecbf1774cc0a53bba77580" translate="yes" xml:space="preserve">
          <source>The .selftest command reads the rows of the selftest table in selftest.tno order. For each 'memo' row, it writes the text in 'cmd' to the output. For each 'run' row, it runs the 'cmd' text as SQL and compares the result to the value in 'ans', and shows an error message if the results differ.</source>
          <target state="translated">Команда .selftest читает строки таблицы selftest в порядке selftest.tno.Для каждой строки 'memo' она записывает текст в 'cmd'.Для каждой строки 'run' она запускает текст 'cmd' в виде SQL и сравнивает результат со значением в 'ans',а также выводит сообщение об ошибке,если результаты отличаются.</target>
        </trans-unit>
        <trans-unit id="12dcfb8a7c514a22ec8efe2151085ef4fd8b43ec" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header (found on page 1 only)</source>
          <target state="translated">Заголовок 100-байтового файла базы данных (находится только на странице 1).</target>
        </trans-unit>
        <trans-unit id="a17caaa0027df54644d9d8d5e0706c4b71db11b0" translate="yes" xml:space="preserve">
          <source>The 100-byte database file header is found only on page 1, which is always a table b-tree page. All other b-tree pages in the database file omit this 100-byte header.</source>
          <target state="translated">Заголовок 100-байтового файла базы данных находится только на странице 1,которая всегда представляет собой таблицу b-дерево.Все остальные страницы b-дерева в файле БД опускают этот 100-байтовый заголовок.</target>
        </trans-unit>
        <trans-unit id="3b6884cf3226327e79dce3b07ec790a620af6f29" translate="yes" xml:space="preserve">
          <source>The 12-step &lt;a href=&quot;lang_altertable#otheralter&quot;&gt;generalized ALTER TABLE procedure&lt;/a&gt; above will work even if the schema change causes the information stored in the table to change. So the full 12-step procedure above is appropriate for dropping a column, changing the order of columns, adding or removing a UNIQUE constraint or PRIMARY KEY, adding CHECK or FOREIGN KEY or NOT NULL constraints, or changing the datatype for a column, for example. However, a simpler and faster procedure can optionally be used for some changes that do no affect the on-disk content in any way. The following simpler procedure is appropriate for removing CHECK or FOREIGN KEY or NOT NULL constraints, or adding, removing, or changing default values on a column.</source>
          <target state="translated">&lt;a href=&quot;lang_altertable#otheralter&quot;&gt;Обобщенная&lt;/a&gt; 12-шаговая процедура ALTER TABLE, описанная выше, будет работать, даже если изменение схемы приведет к изменению информации, хранящейся в таблице. Таким образом, описанная выше полная 12-шаговая процедура подходит для удаления столбца, изменения порядка столбцов, добавления или удаления ограничения UNIQUE или PRIMARY KEY, добавления ограничений CHECK, FOREIGN KEY или NOT NULL или изменения типа данных для столбца для пример. Однако для некоторых изменений, которые никоим образом не влияют на содержимое на диске, может быть использована более простая и быстрая процедура. Следующая более простая процедура подходит для удаления ограничений CHECK, FOREIGN KEY или NOT NULL, а также для добавления, удаления или изменения значений по умолчанию в столбце.</target>
        </trans-unit>
        <trans-unit id="3229fe36f5dbdb9bc16916270b8799663f2b4b3a" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">Второй аргумент функции обратного вызова sqlite3_exec () - это количество столбцов в результате. Третий аргумент обратного вызова sqlite3_exec () - это массив указателей на строки, полученных как будто из &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; , по одному для каждого столбца. Если элемент результирующей строки имеет значение NULL, то соответствующий указатель строки для обратного вызова sqlite3_exec () является указателем NULL. Четвертый аргумент обратного вызова sqlite3_exec () - это массив указателей на строки, где каждая запись представляет имя соответствующего столбца результата, полученное из &lt;a href=&quot;#sqlite3_column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f8004ad0fbc670903554e47567c2e9bf84a736bf" translate="yes" xml:space="preserve">
          <source>The 2nd argument to the sqlite3_exec() callback function is the number of columns in the result. The 3rd argument to the sqlite3_exec() callback is an array of pointers to strings obtained as if from &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt;, one for each column. If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec() callback is a NULL pointer. The 4th argument to the sqlite3_exec() callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt;.</source>
          <target state="translated">Второй аргумент функции обратного вызова sqlite3_exec () - это количество столбцов в результате. Третий аргумент обратного вызова sqlite3_exec () - это массив указателей на строки, полученных как будто из &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_text ()&lt;/a&gt; , по одному для каждого столбца. Если элемент результирующей строки имеет значение NULL, то соответствующий указатель строки для обратного вызова sqlite3_exec () является указателем NULL. Четвертый аргумент обратного вызова sqlite3_exec () - это массив указателей на строки, где каждая запись представляет имя соответствующего столбца результата, полученное из &lt;a href=&quot;column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fbe9436fd9db92826bf0f5761a30ba124b84870" translate="yes" xml:space="preserve">
          <source>The 31 result codes are &lt;a href=&quot;c3ref/c_abort&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de71717ad00d5c6da7753059b7611f9841b1d459" translate="yes" xml:space="preserve">
          <source>The 32-bit integer value P1 is written into register P2.</source>
          <target state="translated">В регистр P2 записывается 32-битное целое значение P1.</target>
        </trans-unit>
        <trans-unit id="0fa6dc01b797fc02e2f48692d3a39f9204d77ab0" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 128 in the WAL-index header is called the &quot;nBackfill&quot;. this field holds the number of frames in the WAL file which have been copied back into the main database.</source>
          <target state="translated">32-битное беззнаковое целое число со смещением 128 в заголовке WAL-index называется &quot;nBackfill&quot;.В этом поле хранится количество кадров в файле WAL,которые были скопированы обратно в основную БД.</target>
        </trans-unit>
        <trans-unit id="e3de01c332227a39275dbc5888bb606fa2949671" translate="yes" xml:space="preserve">
          <source>The 32-bit unsigned integer at offset 16 (and repeated at offset 64) is the number of valid frames in the WAL. Because WAL frame are numbered starting with 1, mxFrame is also the index of the last valid commit frame in the WAL. A commit frame is a frame that has a non-zero &quot;size of database&quot; value in bytes 4 through 7 of the frame header, and that indicates the end of a transaction.</source>
          <target state="translated">32-битное беззнаковое целое число со смещением 16 (и повторяющееся со смещением 64)-это количество действительных кадров в WAL.Поскольку WAL-кадр нумеруется начиная с 1,mxFrame также является индексом последнего действительного кадра коммита в WAL.Фрейм фиксации-это кадр,имеющий ненулевое значение &quot;размера базы данных&quot; в байтах с 4 по 7 заголовка кадра,и указывающий на конец транзакции.</target>
        </trans-unit>
        <trans-unit id="ae0f85b04e7fa9cc6d6fac1b8bbc475f7f896833" translate="yes" xml:space="preserve">
          <source>The 35% figure is based on running tests on every machine that the author has easily at hand. Some reviewers of this article report that SQLite has higher latency than direct I/O on their systems. We do not yet understand the difference. We also see indications that SQLite does not perform as well as direct I/O when experiments are run using a cold filesystem cache.</source>
          <target state="translated">Цифра 35% основана на выполнении тестов на каждой машине,которая легко доступна автору.Некоторые рецензенты этой статьи сообщают,что SQLite имеет более высокую латентность,чем прямой ввод-вывод на своих системах.Мы пока не понимаем разницы.Мы также видим признаки того,что SQLite не работает так хорошо,как при прямом вводе/выводе,когда эксперименты выполняются с использованием холодного кэша файловой системы.</target>
        </trans-unit>
        <trans-unit id="99484295a38d44d61a5164088be45dfe447bd6fb" translate="yes" xml:space="preserve">
          <source>The 3rd parameter of the built-in SUBSTR() function is now optional.</source>
          <target state="translated">Третий параметр встроенной функции SUBSTR()теперь является необязательным.</target>
        </trans-unit>
        <trans-unit id="b03a25a4d8213505aa58b43a2a9ec61a89d8bd66" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 28 into the header stores the size of the database file in pages. If this in-header datasize size is not valid (see the next paragraph), then the database size is computed by looking at the actual size of the database file. Older versions of SQLite ignored the in-header database size and used the actual file size exclusively. Newer versions of SQLite use the in-header database size if it is available but fall back to the actual file size if the in-header database size is not valid.</source>
          <target state="translated">4-байтовое биг-ендианное целое число со смещением 28 в заголовок хранит размер файла БД в страницах.Если размер заголовочного файла данных недействителен (см.следующий параграф),то размер БД вычисляется по фактическому размеру файла БД.Более старые версии SQLite игнорировали размер заголовочной базы данных и использовали только фактический размер файла.Более новые версии SQLite используют размер заголовочной базы данных,если она доступна,но возвращаются к размеру действительного файла,если размер заголовочной базы данных недействителен.</target>
        </trans-unit>
        <trans-unit id="ef2a0b06932c2dcd259f9b038635b5911a22f5bb" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 56 determines the encoding used for all text strings stored in the database. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be. No other values are allowed. The sqlite3.h header file defines C-preprocessor macros SQLITE_UTF8 as 1, SQLITE_UTF16LE as 2, and SQLITE_UTF16BE as 3, to use in place of the numeric codes for the text encoding.</source>
          <target state="translated">4-байтовое биг-ендианное целое число со смещением 56 определяет кодировку,используемую для всех текстовых строк,хранящихся в БД.Значение 1 означает UTF-8.Значение 2 означает UTF-16le.Значение 3 означает UTF-16be.Другие значения не допускаются.Заголовочный файл sqlite3.h определяет макросы C-препроцессора SQLITE_UTF8 как 1,SQLITE_UTF16LE как 2 и SQLITE_UTF16BE как 3 для использования вместо числовых кодов для кодирования текста.</target>
        </trans-unit>
        <trans-unit id="59780a9139eaaa69dc8ff8373215df2d27399d4a" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 60 is the user version which is set and queried by the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;. The user version is not used by SQLite.</source>
          <target state="translated">4-байтовое целое число с &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;прямым порядком&lt;/a&gt; байтов по смещению 60 - это версия пользователя, которая устанавливается и запрашивается прагмой user_version . Пользовательская версия не используется SQLite.</target>
        </trans-unit>
        <trans-unit id="b59b6e739385a58f0bfd59ff19b74ae1c97b3ca9" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 68 is an &quot;Application ID&quot; that can be set by the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command in order to identify the database as belonging to or associated with a particular application. The application ID is intended for database files used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. The application ID can be used by utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; to determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="translated">4-байтовое целое число с &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;прямым&lt;/a&gt; порядком байтов по смещению 68 является &amp;laquo;идентификатором приложения&amp;raquo;, который может быть установлен командой PRAGMA application_id для идентификации базы данных как принадлежащей или связанной с конкретным приложением. Идентификатор приложения предназначен для файлов базы данных, используемых в качестве &lt;a href=&quot;appfileformat&quot;&gt;файлового формата приложения&lt;/a&gt; . Идентификатор приложения может использоваться такими утилитами, как &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file (1),&lt;/a&gt; для определения конкретного типа файла, а не просто для создания отчетов &amp;laquo;База данных SQLite3&amp;raquo;. Список присвоенных идентификаторов приложений можно увидеть, &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;обратившись к&lt;/a&gt; файлу magic.txt в исходном репозитории SQLite.</target>
        </trans-unit>
        <trans-unit id="07f0a53720eada7bca96ab5b1af017ecee35257f" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian integer at offset 96 stores the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; value for the SQLite library that most recently modified the database file. The 4-byte big-endian integer at offset 92 is the value of the &lt;a href=&quot;fileformat2#chngctr&quot;&gt;change counter&lt;/a&gt; when the version number was stored. The integer at offset 92 indicates which transaction the version number is valid for and is sometimes called the &quot;version-valid-for number&quot;.</source>
          <target state="translated">4-байтовое целое число с &lt;a href=&quot;c3ref/c_source_id&quot;&gt;прямым порядком&lt;/a&gt; байтов по смещению 96 хранит значение SQLITE_VERSION_NUMBER для библиотеки SQLite, которая последней изменила файл базы данных. 4-байтовое целое число с прямым порядком байтов по смещению 92 - это значение &lt;a href=&quot;fileformat2#chngctr&quot;&gt;счетчика изменений,&lt;/a&gt; когда номер версии был сохранен. Целое число со смещением 92 указывает, для какой транзакции действителен номер версии, и иногда его называют &amp;laquo;номером версии, допустимой для&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b2d1137ce6ac9536674089958f7183c5cef074dd" translate="yes" xml:space="preserve">
          <source>The 4-byte big-endian signed integer at offset 48 is the suggested cache size in pages for the database file. The value is a suggestion only and SQLite is under no obligation to honor it. The absolute value of the integer is used as the suggested size. The suggested cache size can be set using the &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;default_cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">4-байтовое целое число со знаком прямого порядка байтов по смещению 48 - это рекомендуемый размер кэша в страницах для файла базы данных. Значение является всего лишь предложением, и SQLite не обязана его соблюдать. Абсолютное значение целого числа используется в качестве предлагаемого размера. Предлагаемый размер кеша может быть установлен с помощью &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;прагмы default_cache_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a28f7f4f27954a38f3fd9a37598b5ec1312b94e" translate="yes" xml:space="preserve">
          <source>The 61 extended result codes are &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;defined in sqlite3.h&lt;/a&gt; and are listed in alphabetical order below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7632ae3463f74e8bc40ebd99c8e14ebcad0e1acf" translate="yes" xml:space="preserve">
          <source>The 8 or 12 byte b-tree page header</source>
          <target state="translated">8 или 12-байтовый b-деревянный заголовок страницы</target>
        </trans-unit>
        <trans-unit id="f5b2d0b06ac8eecacdf1f9fc8ceb4463be132806" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; флаг означает , что файл должен быть удален , если он закрыт. &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; будет установлен для TEMP баз данных и их журналов, переходных баз данных и subjournals.</target>
        </trans-unit>
        <trans-unit id="113a719d1e8937c17801bea84f7fbfbe80a9d62b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; флаг всегда используется в сочетании с &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; флагом, которые оба непосредственно аналогичны флагам O_EXCL и O_CREAT в POSIX открытых () API. Флаг SQLITE_OPEN_EXCLUSIVE в сочетании с SQLITE_OPEN_CREATE используется для обозначения того, что файл всегда должен создаваться и что это ошибка, если он уже существует. это</target>
        </trans-unit>
        <trans-unit id="81aa4d01093839a3328717a25027872953f919a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">&lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; препроцессор макросов в заголовке sqlite3.h принимает значение строкового литерала , который является версией SQLite в формате &amp;laquo;XYZ&amp;raquo; , где Х представляет собой основной номер версии (всегда 3 для SQLite3) и Y это номер версии и незначительные Z является номер выпуска. &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; С препроцессора макрос преобразуется в целое число со значением (X * + Y 1000000 * 1000 + Z) , где X, Y и Z имеют те же номера , используемые в &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; . SQLITE_VERSION_NUMBER для любого данного выпуска SQLite также будет больше, чем выпуск, из которого он получен. Либо Y будет оставаться постоянным, а Z будет увеличиваться, либо Y будет увеличиваться, а Z будет сброшено на ноль.</target>
        </trans-unit>
        <trans-unit id="f3c03446112462ee2b9d55caa1b76200b09c27b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dbsqlfuzz&quot;&gt;&lt;b&gt;dbsqlfuzz&lt;/b&gt;&lt;/a&gt; engine is a proprietary fuzz tester. Other &lt;a href=&quot;testing#fuzztesting&quot;&gt;fuzzers for SQLite&lt;/a&gt; mutate either the SQL inputs or the database file. Dbsqlfuzz mutates both the SQL and the database file at the same time, and is thus able to reach new error states. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM with a custom mutator. Starting from 236 seed files, the dbsqlfuzz fuzzer has examined many tens of millions of mutations, resulting in 63493 distinct test cases that form the basis of each new fuzzing session. Dbsqlfuzz helps ensure that SQLite is robust against attack via malicious SQL or database inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c75916c07cfb8eae73aa66b68a34bf29c22777" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;Подключение к базе данных&lt;/a&gt; указателя D в вызове &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt (D, S)&lt;/a&gt; должен относиться к соединению с открытой базой данных и , в частности , не должны быть указателем NULL.</target>
        </trans-unit>
        <trans-unit id="5bf64bb75c15b60e54d733e7fb04737bfbdcc130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">Сам объект &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; частично потокобезопасен. Несколько потоков могут безопасно выполнять несколько одновременных вызовов sqlite3_backup_step (). Однако API sqlite3_backup_remaining () и sqlite3_backup_pagecount (), строго говоря, не являются потокобезопасными. Если они вызываются одновременно с вызовом sqlite3_backup_step () другого потока, возможно, они возвращают недопустимые значения.</target>
        </trans-unit>
        <trans-unit id="7b899c2433d199dbb7815bdf0ba2afb729910cf1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_zeroblob (),&lt;/a&gt; а также встроенная &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;функция&lt;/a&gt; SQL zeroblob могут использоваться для создания блоба с нулевым заполнением для чтения или записи с использованием интерфейса инкрементального блоба.</target>
        </trans-unit>
        <trans-unit id="243b1f5a94daea2d7cb3ce8a6e46d2fc0337bddb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; отменяет регистрацию процедуры инициализации X, которая была зарегистрирована с использованием предыдущего вызова &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension (X)&lt;/a&gt; . В &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; подпрограмма возвращает 1 , если процедура инициализации X был успешно незарегистрированные и возвращает 0 , если X не был включен в список подпрограмм инициализации.</target>
        </trans-unit>
        <trans-unit id="4d9c76fa5b1b1ce93415a995c6d4d84ffeb6d357" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...) может зарегистрировать альтернативную реализацию кеширования страниц, передав экземпляр структуры sqlite3_pcache_methods2. Во многих приложениях большая часть памяти кучи, выделенной SQLite, используется для кеширования страниц. Реализуя настраиваемый кеш страницы с помощью этого API, приложение может лучше контролировать объем памяти, потребляемой SQLite, способ выделения и освобождения этой памяти, а также политики, используемые для точного определения того, какие части файла базы данных кэшируются и как долго.</target>
        </trans-unit>
        <trans-unit id="5d45a04d8212fde9c0874120a3960331ca779f2b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; выполняет прямой вызов метода xFileControl для объекта &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods,&lt;/a&gt; связанного с конкретной базой данных, указанной вторым аргументом. Имя базы данных - &amp;laquo;main&amp;raquo; для основной базы данных или &amp;laquo;temp&amp;raquo; для базы данных TEMP, или имя, которое появляется после ключевого слова AS для баз данных, добавленных с помощью команды &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL. Указатель NULL может использоваться вместо &amp;laquo;main&amp;raquo; для ссылки на основной файл базы данных. Третий и четвертый параметры этой подпрограммы передаются напрямую второму и третьему параметрам метода xFileControl. Возвращаемое значение метода xFileControl становится возвращаемым значением этой процедуры.</target>
        </trans-unit>
        <trans-unit id="1190e60391b896900656c0ed0c45b80a24b61942" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;Sqlite3_int64&lt;/a&gt; переменной , на которую указывает параметр T будет установлен на общее количество строк осмотрен всех итераций X-го цикла.</target>
        </trans-unit>
        <trans-unit id="68df0918aa353458edcd2a2adfa1d6ea97cffd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_int64&quot;&gt;Sqlite3_int64&lt;/a&gt; переменной , на которую указывает параметр Т будет установлен на общее число раз , что Х-го цикла, закончилась.</target>
        </trans-unit>
        <trans-unit id="a4d4c03ef6c7fed4df5e7b2b60cea13e3845bb99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950c7d09e714f7025b91b049ed110aaf3de8d496" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e18bfb46029f881a46fabedb7acfaf5c4cc5dda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; записывает сообщение в &lt;a href=&quot;errlog&quot;&gt;журнал ошибок,&lt;/a&gt; созданный параметром &lt;a href=&quot;#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; для &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; . Если ведение журнала включено, строка zFormat и последующие аргументы используются с &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; для генерации окончательной выходной строки.</target>
        </trans-unit>
        <trans-unit id="a8d3a9c5e86973d6925c26336eb4b86036d70cb6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">В &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; подпрограмма возвращает число байт памяти в настоящее время в обращении (malloced но не освобожденные). В &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; подпрограмма возвращает максимальное значение &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , так как знак высокой воды последнего сброс. Значения, возвращаемые &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_memory_highwater&quot;&gt;sqlite3_memory_highwater (),&lt;/a&gt; включают любые накладные расходы, добавленные SQLite в его реализацию &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , но не накладные расходы, добавленные любыми базовыми подпрограммами системной библиотеки, которые может вызывать &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc30f41b86e312b265eb4e71d4d9a6acf99b0d1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; принимает единственный аргумент, который является одной из этих целочисленных констант.</target>
        </trans-unit>
        <trans-unit id="895178f8a3d57626d41012b259bf092ebaa065ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count (D)&lt;/a&gt; возвращает количество столбцов в строке, которая вставляется, обновляется или удаляется.</target>
        </trans-unit>
        <trans-unit id="92f98e455bc2921056f5d6b0ffb541ab9df1ffaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth (D)&lt;/a&gt; возвращает 0, если обратный вызов перед обновлением был вызван в результате прямой операции вставки, обновления или удаления; или 1 для вставок, обновлений или удалений, вызываемых триггерами верхнего уровня; или 2 для изменений, вызванных триггерами, вызванными триггерами верхнего уровня; и так далее.</target>
        </trans-unit>
        <trans-unit id="e08d4a7c0ce7457f9dab2dfa8af96af8deafb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; регистрирует функцию обратного вызова, которая вызывается перед каждой операцией &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; в таблице базы данных. В лучшем случае один preupdate крючок может быть зарегистрирован в то время , на одном &lt;a href=&quot;#sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; ; каждый вызов &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; отменяет предыдущую настройку. Ловушка preupdate отключается путем вызова &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; с указателем NULL в качестве второго параметра. Третий параметр &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; передается в качестве первого параметра обратным вызовам.</target>
        </trans-unit>
        <trans-unit id="76ad44c525d8f71caf7bed2b7e946c3d8c4e4d51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new (D, N, P)&lt;/a&gt; записывает в P указатель на &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенное значение sqlite3_value,&lt;/a&gt; которое содержит значение N-го столбца строки таблицы после его обновления. Параметр N должен быть между 0 и на единицу меньше количества столбцов, иначе поведение будет неопределенным. Это должно использоваться только в обратных вызовах SQLITE_INSERT и SQLITE_UPDATE перед обновлением; если он используется обратным вызовом SQLITE_DELETE, то поведение не определено. Значение &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value, на&lt;/a&gt; которое указывает P, будет уничтожено при возврате обратного вызова preupdate.</target>
        </trans-unit>
        <trans-unit id="1c708fa87b4305f6c6c7b152f77487e32500d735" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_new ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_count ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_depth ()&lt;/a&gt; предоставляют дополнительную информацию о событии preupdate. Эти подпрограммы можно вызывать только из обратного вызова перед обновлением. Вызов любой из этих подпрограмм вне функции обратного вызова перед обновлением или с указателем &lt;a href=&quot;#sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, который отличается от указателя, предоставленного для обратного вызова перед обновлением, приводит к неопределенному и, вероятно, нежелательному поведению.</target>
        </trans-unit>
        <trans-unit id="62645acd92fc3d494d833d1a2acf99fc550b25a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_old (D, N, P)&lt;/a&gt; записывает в P указатель на &lt;a href=&quot;#sqlite3_value&quot;&gt;защищенное значение sqlite3_value,&lt;/a&gt; которое содержит значение N-го столбца строки таблицы до его обновления. Параметр N должен быть между 0 и на единицу меньше количества столбцов, иначе поведение будет неопределенным. Это должно использоваться только в обратных вызовах SQLITE_UPDATE и SQLITE_DELETE перед обновлением; если он используется обратным вызовом SQLITE_INSERT, то поведение не определено. Значение &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value, на&lt;/a&gt; которое указывает P, будет уничтожено при возврате обратного вызова preupdate.</target>
        </trans-unit>
        <trans-unit id="73b2a32ae166fcb0b54e0a6a66b0c37e428124e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; не изменяет значения каких-либо &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;привязок&lt;/a&gt; в &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленном операторе&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="24aaeaf525c4a02afa566b3b6fde01711f410b96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; сбрасывает &lt;a href=&quot;#sqlite3_stmt&quot;&gt;подготовленный оператор&lt;/a&gt; S обратно в начало своей программы.</target>
        </trans-unit>
        <trans-unit id="5ec7f66ae2478b5bf1fba7004c6f9eca0c47bbe3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">Функция &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;обратного вызова авторизатора&lt;/a&gt; должна возвращать либо &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK,&lt;/a&gt; либо одну из этих двух констант, чтобы сигнализировать SQLite, разрешено действие или нет. Дополнительную информацию см. В &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;документации авторизатора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de889cb07b2c7dd83d04327e082d9b8afd75421b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; регистрирует функцию обратного вызова, которая вызывается для авторизации определенных действий оператора SQL. Второй параметр обратного вызова - это целочисленный код, указывающий, какое действие разрешается. Это целочисленные коды действий, которые может быть передан обратному вызову авторизатора.</target>
        </trans-unit>
        <trans-unit id="b20fbf1dd1eb586565d476c6ea4477e75271549a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">Объект &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; возвращенный в результате успешного вызова &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get (),&lt;/a&gt; должен быть освобожден с помощью &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free (),&lt;/a&gt; чтобы избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="775754ed627fe2a2cc8e3c07dc04d7c2771ef634" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="14be7fcf3129f0807a23ee14219023eee52d1a02" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_free&quot;&gt;sqlite3_snapshot_free (P)&lt;/a&gt; уничтожает &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. В конечном итоге приложение должно освободить каждый объект &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; используя эту процедуру, чтобы избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="3c246e9ef7aa9d8e18a838b47761936cd8a2acc5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="2146a577e5e49a77b490e29aca2d82e371ec702c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; пытается создать новый объект &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; который записывает текущее состояние схемы S в соединении с базой данных D. В случае успеха интерфейс &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; записывает указатель на вновь созданный &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; в * P и возвращает SQLITE_OK. Если при вызове этой функции в схеме S еще не открыта транзакция чтения, она открывается автоматически.</target>
        </trans-unit>
        <trans-unit id="efd7fc3c3c9a64e738f23c02f6e6fbe25f03ae8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="b4e3c98131317b43afc18d358e2869af93b46671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; либо запускает новую транзакцию чтения, либо обновляет существующую для схемы S &lt;a href=&quot;#sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; D, так что транзакция чтения относится к историческому &lt;a href=&quot;#sqlite3_snapshot&quot;&gt;снимку&lt;/a&gt; P, а не к самому последнему изменению в базе данных. Интерфейс &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; возвращает SQLITE_OK в случае успеха или соответствующий &lt;a href=&quot;rescode&quot;&gt;код ошибки в&lt;/a&gt; случае неудачи.</target>
        </trans-unit>
        <trans-unit id="83d565fd5c1ee3cccc1b5c10ce8ef575521cca40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_append (X, S, N)&lt;/a&gt; добавляет ровно N байтов из строки S в конец объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X. N должно быть неотрицательным. S должен содержать не менее N ненулевых байтов содержимого. Чтобы добавить строку с нулевым символом в конце, используйте вместо этого метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6917c29880e6eab55b32466b3048653ea9692486" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendall (X, S)&lt;/a&gt; добавляет полное содержимое строки S с нулевым завершением в конец объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X.</target>
        </trans-unit>
        <trans-unit id="8658941f24fcaee032cb73b6958282aac488a0c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendchar (X, N, C)&lt;/a&gt; добавляет N копий однобайтового символа C в конец объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X. Этот метод можно использовать, например, для добавления отступов между пробелами.</target>
        </trans-unit>
        <trans-unit id="5cf4ff61e78e32620c83211a0d5e1e3795abc7df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf (X, F, ...)&lt;/a&gt; и &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_vappendf (X, F, V)&lt;/a&gt; используют &lt;a href=&quot;printf&quot;&gt;встроенные функции printf&lt;/a&gt; SQLite для добавления форматированного текста в конец объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X.</target>
        </trans-unit>
        <trans-unit id="efc22c6c47d48b515ed10c7b3b7ca6cc54142437" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_reset (X)&lt;/a&gt; сбрасывает строящуюся строку внутри объекта &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X обратно до нулевой длины в байтах.</target>
        </trans-unit>
        <trans-unit id="7f1ec747ece71d77c655f9a07fae8cab37f0a797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; возвращает текущую длину в байтах динамической строки, строящейся в объекте &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X. Длина, возвращаемая &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; , не включает байт нулевого завершения.</target>
        </trans-unit>
        <trans-unit id="abad991ae0af361a9313d8cfba4c5223a9d4a389" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">Метод &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; возвращает указатель на текущее содержимое динамической строки, строящейся в X. Значение, возвращаемое &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; , управляется объектом sqlite3_str X и может быть освобождено или изменено любым последующим методом того же &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; объект. Приложения не должны использовать указатель, возвращаемый &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; после любого последующего вызова метода для того же объекта. Приложения могут изменять содержимое строки, возвращаемой &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_value (X),&lt;/a&gt; при условии, что они не записывают ни в какие байты вне диапазона от 0 до &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; и не читают и не записывают ни одного байта после любого последующего вызова метода sqlite3_str.</target>
        </trans-unit>
        <trans-unit id="9ed76b8571c1160c10dee5527b0d46210f6deae9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; уничтожает объект sqlite3_str X и возвращает указатель на буфер памяти, полученный из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; который содержит построенную строку. Вызывающее приложение должно передать возвращаемое значение в &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free (),&lt;/a&gt; чтобы избежать утечки памяти. Интерфейс &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; может вернуть указатель NULL, если во время построения строки были обнаружены какие-либо ошибки. Интерфейс &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; также вернет указатель NULL, если длина строки в объекте &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; X равна нулю байтов.</target>
        </trans-unit>
        <trans-unit id="1a8bb7e6f2617ebce878cf41863558873c56dd1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; выделяет и инициализирует новый объект &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; . Чтобы избежать утечки памяти, объект, возвращаемый &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (),&lt;/a&gt; должен быть освобожден последующим вызовом &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="283dcdc6097ac99a155d31e274b76b664e287d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; всегда возвращает указатель на действительный объект &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; , хотя в случае ошибки нехватки памяти возвращаемый объект может быть специальным синглтоном, который будет молча отклонять новый текст, всегда возвращать SQLITE_NOMEM из &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode ()&lt;/a&gt; , всегда возвращать 0 для &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_length ()&lt;/a&gt; и всегда возвращать NULL из &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; . Всегда безопасно использовать значение, возвращаемое &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D),&lt;/a&gt; в качестве параметра sqlite3_str для любого другого метода &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47a765f2716bbd0a7165479eb04c6ad3833cfd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; возвращает ноль тогда и только тогда, когда строка X совпадает с &lt;a href=&quot;lang_expr#glob&quot;&gt;шаблоном GLOB&lt;/a&gt; P. Определение &lt;a href=&quot;lang_expr#glob&quot;&gt;сопоставления с&lt;/a&gt; шаблоном GLOB, используемое в &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X),&lt;/a&gt; такое же, как и для оператора &amp;laquo;X GLOB P&amp;raquo; в Диалект SQL, понятный SQLite. Функция &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; чувствительна к регистру.</target>
        </trans-unit>
        <trans-unit id="95615e5c78fed3ee43eff0e7b082843f593e6a31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stricmp&quot;&gt;Sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; API - интерфейсы позволяют приложения и расширения для сравнения содержимого двух буферов , содержащих UTF - 8 строк в случае независимым способом, используя такое же определение &amp;laquo;случая независимости&amp;raquo; , что SQLite использует внутренне при сравнении идентификаторов.</target>
        </trans-unit>
        <trans-unit id="51d8a3ef92ef4d7b314975584d8072e9206e198e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">Функция &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; сопоставляет символы Unicode, но только символы ASCII складываются по регистру.</target>
        </trans-unit>
        <trans-unit id="485ac31bffb8ac065daf3ba2a8161fbdf5039efd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; возвращает ноль тогда и только тогда, когда строка X совпадает с &lt;a href=&quot;lang_expr#like&quot;&gt;шаблоном LIKE&lt;/a&gt; P с escape-символом E. Определение сопоставления с образцом &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE,&lt;/a&gt; используемое в &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E),&lt;/a&gt; такое же, как и для Оператор &amp;laquo;X LIKE P ESCAPE E&amp;raquo; в диалекте SQL, понятном SQLite. Для &amp;laquo;X LIKE P&amp;raquo; без предложения ESCAPE установите для параметра E &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; значение 0. Как и в случае с оператором LIKE, функция &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; нечувствительна к регистру - эквивалентно верхнему и Строчные символы ASCII соответствуют друг другу.</target>
        </trans-unit>
        <trans-unit id="67cdd83f23b0c9baf88d22cb2f2c082de3577118" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes (D)&lt;/a&gt; сообщает только количество строк, которые изменились из-за выполнения оператора SQL для соединения с базой данных D. Любые изменения, сделанные другими соединениями с базой данных, игнорируются. Чтобы обнаружить изменения файла базы данных из других подключений к базе данных, используйте команду &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; или &lt;a href=&quot;#sqlite3_file_control&quot;&gt;файловый элемент управления &lt;/a&gt;&lt;a href=&quot;#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2dc4153435020e41ac99ab2b5b83d08f27b98c68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_wal_autocheckpoint&quot;&gt;Sqlite3_wal_autocheckpoint (D, N)&lt;/a&gt; является оберткой &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; , что приводит к любой базе данных на &lt;a href=&quot;#sqlite3&quot;&gt;базу данных соединения&lt;/a&gt; D автоматически &lt;a href=&quot;wal#ckpt&quot;&gt;контрольную точку&lt;/a&gt; после совершения сделки , если есть N или больше кадров в &lt;a href=&quot;wal&quot;&gt;записи вперед лог&lt;/a&gt; - файле. Передача нуля или отрицательного значения в качестве параметра nFrame полностью отключает автоматические контрольные точки.</target>
        </trans-unit>
        <trans-unit id="9142f5b65b53643523fc33889c4ba6acff8188e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">Функция &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; используется для регистрации обратного вызова, который вызывается каждый раз, когда данные фиксируются в базе данных в режиме wal.</target>
        </trans-unit>
        <trans-unit id="fdbc2004b6063417b2874cd07563f5073fb2461b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0804c63302651c02a306eb7ec9ff35797d83276d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; файлы управление может быть вызвано SQLite на файл базы данных ручки вскоре после того, как он открыт для того , чтобы предоставить пользовательские VFS с доступом к соединениям занят обработчик обратного вызова. Аргумент имеет тип (void **) - массив из двух (void *) значений. Первый (void *) фактически указывает на функцию типа (int (*) (void *)). Чтобы вызвать обработчик занятости соединений, эта функция должна быть вызвана со вторым (void *) в массиве в качестве единственного аргумента. Если возвращается ненулевое значение, то операцию следует повторить. Если он возвращает ноль, пользовательская VFS должна отказаться от текущей операции.</target>
        </trans-unit>
        <trans-unit id="e16ec9bd7cc655e1fcca3234a2d80781961dcf25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; используется для запроса того, чтобы VFS расширяла и усекала файл базы данных кусками размера, указанного пользователем. Четвертый аргумент &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; должен указывать на целое число (тип int), содержащее новый размер блока, который будет использоваться для указанной базы данных. Выделение файлового пространства базы данных большими фрагментами (скажем, по 1 МБ за раз) может уменьшить фрагментацию файловой системы и повысить производительность в некоторых системах.</target>
        </trans-unit>
        <trans-unit id="55799a140d15462e73ef05abf1db855a8aa627ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23adb4e434c478e58b40c24db57f497a0e6e59c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196a41f980c38337225c4ba413e0b1dc0b2b471a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; заставляет все операции записи с момента предыдущего успешного вызова &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; выполняться атомарно. Этот файловый элемент управления возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; тогда и только тогда, когда все записи были выполнены успешно и были зафиксированы в постоянном хранилище. Независимо от того, успешен он или нет, этот файловый элемент управления выводит файловый дескриптор из режима пакетной записи, так что все последующие операции записи независимы. SQLite никогда не вызовет SQLITE_FCNTL_COMMIT_ATOMIC_WRITE без предварительного успешного вызова &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed7c39458516ed31456486d668f266799517f0b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; генерируется внутри SQLite и отправляется в VFS сразу после того, как транзакция была зафиксирована, но до того, как база данных будет разблокирована. VFS, которым этот сигнал не нужен, должны игнорировать этот код операции. Приложения не должны вызывать &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; с этим кодом операции, так как это может нарушить работу специализированных VFS, которые в этом нуждаются.</target>
        </trans-unit>
        <trans-unit id="a6067fb898268faa568cf0d8b727509a1e63a822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; используется для обнаружения изменений в файле базы данных. Аргумент - указатель на 32-битовое целое число без знака. &amp;laquo;Версия данных&amp;raquo; для пейджера записывается в указатель. &amp;laquo;Версия данных&amp;raquo; изменяется всякий раз, когда происходит какое-либо изменение в соответствующем файле базы данных, либо с помощью операторов SQL в том же соединении с базой данных, либо посредством транзакций, совершенных отдельными соединениями с базой данных, возможно, в других процессах. Интерфейс &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; можно использовать, чтобы узнать, изменилась ли какая-либо база данных в соединении, но этот интерфейс реагирует на изменения как на TEMP, так и на MAIN, и не предоставляет механизма для обнаружения изменений только в MAIN. Кроме того, &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;интерфейс реагирует только на внутренние изменения и пропускает изменения, сделанные другими соединениями с базой данных. Команда &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; предоставляет механизм для обнаружения изменений в одной подключенной базе данных, которые происходят из-за других подключений к базе данных, но пропускает изменения, реализованные подключением к базе данных, на котором она вызывается. Этот файловый контроль - единственный механизм для обнаружения изменений, которые происходят внутри или снаружи и которые связаны с конкретной присоединенной базой данных.</target>
        </trans-unit>
        <trans-unit id="e9a73ef11b02c7c1ef7f3e1f806173140bf3d029" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45a2fa29af05eafc8a58031e6a08762e72b9ebb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; используется для получения указателя на объект &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file,&lt;/a&gt; связанный с конкретным подключением к базе данных. См. Также &lt;a href=&quot;#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32fc3ec6f9212eb93de60bbea8de22f4f5c0720b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; управления файлами интерпретирует свой аргумент как указатель на целое число и записывает логическое значение в этом целое число в зависимости от наличия или отсутствия файла был переименован, перемещен или удален , так как он был впервые открыт.</target>
        </trans-unit>
        <trans-unit id="961fafabf95f8005cd6aacb0ba427c7a66f5ca95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; опкод используется для получения указателя на &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; объект , связанный с файлом журнал (либо &lt;a href=&quot;lockingv3#rollback&quot;&gt;журнал откат&lt;/a&gt; или &lt;a href=&quot;wal&quot;&gt;журнал запись вперед&lt;/a&gt; ) для конкретного соединения с базой данных. См. Также &lt;a href=&quot;#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3359a645510d53c409e1e871158229645d3789b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; используется для отладки. Этот код операции заставляет метод xFileControl записывать текущее состояние блокировки (одно из &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; , &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; или &lt;a href=&quot;#SQLITE_LOCK_EXCLUSIVE&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; ) в целое число, на которое указывает аргумент pArg. Эта возможность используется во время тестирования и доступна только при использовании параметра времени компиляции SQLITE_TEST.</target>
        </trans-unit>
        <trans-unit id="413d8e1b0a9fd900669cb69e73b3dca110ff8c2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; заставляет попытки получить блокировку файла с помощью методов xLock или xShmLock VFS для ожидания до M миллисекунд перед неудачей, где M - единственный целочисленный параметр без знака.</target>
        </trans-unit>
        <trans-unit id="15909a890c9f03d44aa2dc2921d58c760b545e1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a69e4da16c0af72de938b51b675221a8706b54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; управления файлами используется для запроса или установить максимальное число байтов , которые будут использоваться для памяти отображенного ввода / вывода. Аргумент является указателем на значение типа sqlite3_int64, которое является рекомендуемым максимальным количеством байтов в файле для отображения памяти. Указатель заменяется старым значением. Предел не изменяется, если изначально указанное значение отрицательное, поэтому текущий предел можно запросить, передав указатель на отрицательное число. Этот файловый контроль используется внутри для реализации &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d526543f15c2ce77f0461ecf7fe44c9004bea17a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; вызывается SQLite после открытия транзакции записи, чтобы указать, что, если по какой-либо причине не будет выполнен откат, весь файл базы данных будет перезаписан текущей транзакцией. Это используется операциями ВАКУУМ.</target>
        </trans-unit>
        <trans-unit id="5ebd2a70a799339bb0872257764cf8c08eda9ecd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; используется для установки или запроса постоянной настройки &lt;a href=&quot;wal&quot;&gt;журнала&lt;/a&gt; предварительной записи . По умолчанию вспомогательный журнал упреждающей записи ( &lt;a href=&quot;wal#walfile&quot;&gt;файл WAL&lt;/a&gt; ) и файлы разделяемой памяти, используемые для управления транзакциями, автоматически удаляются при закрытии последнего подключения к базе данных. Установка постоянного режима WAL приводит к тому, что эти файлы сохраняются после закрытия. Сохранение файлов полезно, когда другие процессы, у которых нет разрешения на запись в каталог, содержащий файл базы данных, хотят прочитать файл базы данных, поскольку файлы WAL и разделяемой памяти должны существовать, чтобы база данных была доступна для чтения. Четвертый параметр &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt;для этого кода операции должен быть указатель на целое число. Это целое число равно 0 для отключения постоянного режима WAL или 1 для включения постоянного режима WAL. Если целое число равно -1, оно перезаписывается текущим параметром сохранения WAL.</target>
        </trans-unit>
        <trans-unit id="fdccf2fe8da7ee0d8c5941a2ea211306829a9588" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; используется для установки или запроса постоянной настройки &amp;laquo;PowerSafe-overwrite&amp;raquo; или &amp;laquo;PSOW&amp;raquo;. Параметр PSOW определяет &lt;a href=&quot;#SQLITE_IOCAP_ATOMIC&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; немного методов xDeviceCharacteristics. Четвертый параметр &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; для этого кода операции должен быть указателем на целое число. Это целое число равно 0, чтобы отключить режим нулевого урона, или 1, чтобы включить режим нулевого урона. Если целое число равно -1, то оно перезаписывается текущим значением режима нулевого повреждения.</target>
        </trans-unit>
        <trans-unit id="7f192c2e63c8633453fa1eae93e0c07df64cf07f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; реализуется специальной VFS, используемой только расширением RBU. Все остальные VFS должны возвращать SQLITE_NOTFOUND для этого кода операции.</target>
        </trans-unit>
        <trans-unit id="dbf9a50cfd48cde386829709800477dc50bcc565" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; вызывает откат всех операций записи с момента предыдущего успешного вызова &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; . Этот файловый элемент управления выводит файловый дескриптор из режима пакетной записи, так что все последующие операции записи независимы. SQLite никогда не будет вызывать SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE без предварительного успешного вызова &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3dd434f5b5d6086654ad44e0af5b3fa3e940b9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; используется SQLite, чтобы дать слою VFS подсказку о том, насколько большим будет файл базы данных во время текущей транзакции. Этот намек не гарантирует точность, но часто бывает близок. Базовая VFS может выбрать предварительное выделение файлового пространства базы данных на основе этой подсказки, чтобы ускорить запись в файл базы данных.</target>
        </trans-unit>
        <trans-unit id="97cd9ce5f443d3219025ca93221b345486932d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; используется VFS в памяти, которая реализует &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; для установки верхней границы размера базы данных в памяти. Аргумент - указатель на &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; . Если указанное целое число отрицательно, то оно заполняется текущим пределом. В противном случае устанавливается максимальное значение из указанного целого числа и текущего размера базы данных. Указанное целое число установлено на новый предел.</target>
        </trans-unit>
        <trans-unit id="3a6ee4f80c9cf2b24ebb8343bd1162955c7d2500" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; генерируется внутри SQLite и отправляется в VFS непосредственно перед вызовом метода xSync в дескрипторе файла базы данных. Или, если метод xSync не вызывается из-за того, что пользователь настроил SQLite с &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF,&lt;/a&gt; он вызывается вместо метода xSync. В большинстве случаев аргумент указателя, передаваемый с этим файловым элементом управления, имеет значение NULL. Однако, если файл базы данных синхронизируется как часть фиксации нескольких баз данных, аргумент указывает на строку с завершающим нулем, содержащую имя файла главного журнала транзакций. VFS, которым этот сигнал не нужен, должны игнорировать этот код операции. Приложения не должны вызывать &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; с этим кодом операции, так как это может нарушить работу специализированных VFS, которым он действительно нужен.</target>
        </trans-unit>
        <trans-unit id="5178975b67a8618a8b0176ac061e8db0d71f5de9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105a39338a53cf76076319343b91a58b713c591f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; управления файлами предоставляет консультационную информацию для VFS о том , что высшие слои SQLite стека делают. Этот файловый элемент управления используется некоторыми &lt;a href=&quot;vfs#shim&quot;&gt;прокладками&lt;/a&gt; отслеживания активности VFS . Аргумент - строка с нулевым символом в конце. Более высокие уровни в стеке SQLite могут генерировать экземпляры этого файлового &lt;a href=&quot;compile#use_fcntl_trace&quot;&gt;элемента&lt;/a&gt; управления, если включена опция времени компиляции SQLITE_USE_FCNTL_TRACE .</target>
        </trans-unit>
        <trans-unit id="10a39c75085aed62eed16a6bd93eb299fac8af13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; опкод может быть использован для получения имен всех &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; в стеке VFS. Имена всех прокладок VFS и последняя VFS нижнего уровня записываются в память, полученную из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; а результат сохраняется в переменной char *, на которую указывает четвертый параметр &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; . Вызывающий абонент отвечает за освобождение памяти по завершении. Как и в случае со всеми действиями по управлению файлами, нет никакой гарантии, что это действительно что-то сделает. Вызывающие должны инициализировать переменную char * указателем NULL в случае, если этот файловый контроль не реализован. Этот файл-контроль предназначен только для диагностического использования.</target>
        </trans-unit>
        <trans-unit id="a0de6e2585567c94a4d2150e4d89a4457d85ed27" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; находит указатель на &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; верхнего уровня, которые используются в настоящее время. Аргумент X в sqlite3_file_control (db, SQLITE_FCNTL_VFS_POINTER, X) должен иметь тип &amp;laquo; &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&amp;raquo;. Эти коды операций устанавливают * X как указатель на VFS верхнего уровня. Если в стеке несколько прокладок VFS, этот код операции находит только самую верхнюю прокладку.</target>
        </trans-unit>
        <trans-unit id="6fb5c486ab423108118235eb419e942dcdffc3fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; является сигналом к слою VFS , что это может быть выгодно , чтобы блокировать на следующей блокировке WAL , если блокировка не доступна немедленно. Подсистема WAL выдает этот сигнал в редких случаях, чтобы устранить проблему с инверсией приоритета. Приложения &lt;em&gt;не&lt;/em&gt; должны использовать этот файловый контроль.</target>
        </trans-unit>
        <trans-unit id="2324c4dab632501938725b9d6af72b57f5294994" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; используется для настройки автоматического числа повторов и интервалов для определенных операций дискового ввода-вывода для Windows &lt;a href=&quot;vfs&quot;&gt;VFS.&lt;/a&gt;для обеспечения устойчивости при наличии антивирусных программ. По умолчанию Windows VFS будет повторять операции чтения, записи и удаления файлов до 10 раз с задержкой 25 миллисекунд перед первой попыткой и с увеличением задержки на дополнительные 25 миллисекунд при каждой последующей попытке. Этот код операции позволяет настроить эти два значения (10 попыток и 25 миллисекунд задержки). Значения изменяются для всех подключений к базе данных в рамках одного процесса. Аргумент - это указатель на массив из двух целых чисел, где первое целое число - это новый счетчик повторов, а второе целое число - это задержка. Если любое из целых чисел является отрицательным, то параметр не изменяется, а вместо этого предыдущее значение этого параметра записывается в запись массива, позволяя запросить текущие параметры повторной попытки.Параметр zDbName игнорируется.</target>
        </trans-unit>
        <trans-unit id="257792bb90d40cbd5be070de917b57c36a5f9cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; может использоваться для получения базового собственного дескриптора файла, связанного с дескриптором файла. Этот файловый элемент управления интерпретирует свой аргумент как указатель на собственный дескриптор файла и записывает туда полученное значение.</target>
        </trans-unit>
        <trans-unit id="774ea185734630483687c4bdf35dc5a0169545c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; используется для отладки. Этот код операции заставляет метод xFileControl заменять дескриптор файла на тот, на который указывает аргумент pArg. Эта возможность используется во время тестирования и должна поддерживаться только тогда, когда определен SQLITE_TEST.</target>
        </trans-unit>
        <trans-unit id="6d8e8025bf5df9df0de6e9fce45f3dc3f3a1832f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">Код операции &lt;a href=&quot;#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; реализуется только zipvfs. Все остальные VFS должны возвращать SQLITE_NOTFOUND для этого кода операции.</target>
        </trans-unit>
        <trans-unit id="2a84f41bb71a501decc458aa53d2eb6f639dc064" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">Параметр &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TRACE_SIZE_LIMIT можно использовать для ограничения длины расширения &lt;a href=&quot;../lang_expr#varparam&quot;&gt;связанного параметра&lt;/a&gt; в выводе sqlite3_trace ().</target>
        </trans-unit>
        <trans-unit id="a6d12472a003010a0b08bc4775382d299187ba70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;../compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">Параметр &lt;a href=&quot;../compile#trace_size_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TRACE_SIZE_LIMIT ограничивает размер расширений связанных параметров. Параметр &lt;a href=&quot;../compile#omit_trace&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_OMIT_TRACE заставляет sqlite3_expanded_sql () всегда возвращать NULL.</target>
        </trans-unit>
        <trans-unit id="7fbc9bba97b7220d8d7ecc905032c6bd233e87c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;Data_store_directory прагма&lt;/a&gt; может изменять эту переменную и вызвать его точку к памяти , полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; . Кроме того, &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;прагма data_store_directory&lt;/a&gt; всегда предполагает, что любая строка, на которую указывает эта переменная, хранится в памяти, полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc,&lt;/a&gt; и прагма может попытаться освободить эту память с помощью &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt; . Следовательно, если эта переменная изменяется напрямую, либо она должна быть сделана NULL, либо указывать на память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc,&lt;/a&gt; в &lt;a href=&quot;../pragma#pragma_data_store_directory&quot;&gt;противном&lt;/a&gt; случае следует избегать использования прагмы data_store_directory .</target>
        </trans-unit>
        <trans-unit id="f9eb53bad0c35cc3dcade82b9f30796bebe98ba9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">Оператор &lt;a href=&quot;../pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4683a2e9a942c25fe816aae1882f9a79405f5686" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;Temp_store_directory прагма&lt;/a&gt; может изменять эту переменную и вызвать его точку к памяти , полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; . Кроме того, &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;прагма temp_store_directory&lt;/a&gt; всегда предполагает, что любая строка, на которую указывает эта переменная, хранится в памяти, полученной из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc,&lt;/a&gt; и прагма может попытаться освободить эту память с помощью &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt; . Следовательно, если эта переменная изменяется напрямую, либо она должна быть сделана NULL или указывать на память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc,&lt;/a&gt; либо следует избегать использования &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;прагмы temp_store_directory&lt;/a&gt; . За исключением случаев, когда этого &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;требует прагма temp_store_directory&lt;/a&gt;, SQLite не освобождает память, на которую указывает sqlite3_temp_directory. Если приложение хочет освободить эту память, оно должно сделать это само, заботясь об этом только после того, как все объекты &lt;a href=&quot;sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; будут уничтожены.</target>
        </trans-unit>
        <trans-unit id="d082fe94995359849591e8be7fa905999e11458e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_autocheckpoint&quot;&gt;Wal_autocheckpoint Прагма&lt;/a&gt; можно использовать для вызова этого интерфейса из SQL.</target>
        </trans-unit>
        <trans-unit id="2688b20853de688f9667ff56467cd11f77df2163" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_wal_checkpoint&quot;&gt;ПРАГМА wal_checkpoint&lt;/a&gt; команда может быть использована для вызова этого интерфейса из SQL.</target>
        </trans-unit>
        <trans-unit id="3d14328a2609f4c2f2e647906b7ed9c9b0a6470e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">Оператор &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA Writable_schema = ON&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c456ed19efa854514b7975cbb780401189b8da5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">Метод &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; должен заполнить aConstraintUsage [] информацией о том, какие параметры передать в xFilter. Если argvIndex&amp;gt; 0, тогда правая часть соответствующего aConstraint [] оценивается и становится записью argvIndex-й в argv. Если aConstraintUsage []. Omit истинно, то предполагается, что ограничение полностью обрабатывается виртуальной таблицей и не проверяется SQLite снова.</target>
        </trans-unit>
        <trans-unit id="589ad4da98fc55a8cd1077ee9df3a71f69ad38f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52eaec5cfbc452ed9aad230504ada3c60f5e208b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">В &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; и &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; методы в &lt;a href=&quot;module&quot;&gt;модуле виртуальной таблицы&lt;/a&gt; называют этот интерфейс , чтобы объявить формат (имена и типы данных столбцов) из виртуальных таблиц , которые они реализуют.</target>
        </trans-unit>
        <trans-unit id="eabaf2d0ed146df6465d7c01128019f3ef60888d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atomiccommit&quot;&gt;atomic update capabilities&lt;/a&gt; of SQLite allow small incremental changes to be safely written into the document. This reduces total disk I/O and improves File/Save performance, enhancing the user experience.</source>
          <target state="translated">Возможности &lt;a href=&quot;atomiccommit&quot;&gt;атомарного обновления&lt;/a&gt; SQLite позволяют безопасно записывать небольшие инкрементные изменения в документ. Это снижает общий объем дискового ввода-вывода и улучшает производительность файлов и сохранений, улучшая взаимодействие с пользователем.</target>
        </trans-unit>
        <trans-unit id="08525d9bc082ee31e91cdcebab98cc6662084121" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature in SQLite works differently than it does in MySQL. This often causes confusion for people who initially learned SQL on MySQL and then start using SQLite, and expect the two systems to work identically.</source>
          <target state="translated">Функция &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; в SQLite работает иначе, чем в MySQL. Это часто вызывает путаницу у людей, которые сначала изучили SQL на MySQL, а затем начали использовать SQLite и ожидают, что две системы будут работать одинаково.</target>
        </trans-unit>
        <trans-unit id="bc38744c25dba895f9fced962c1bfedae8b7cde9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object itself is partially threadsafe. Multiple threads may safely make multiple concurrent calls to sqlite3_backup_step(). However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs are not strictly speaking threadsafe. If they are invoked at the same time as another thread is invoking sqlite3_backup_step() it is possible that they return invalid values.</source>
          <target state="translated">Сам объект &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; частично потокобезопасен. Несколько потоков могут безопасно выполнять несколько одновременных вызовов sqlite3_backup_step (). Однако API sqlite3_backup_remaining () и sqlite3_backup_pagecount (), строго говоря, не являются потокобезопасными. Если они вызываются одновременно с вызовом sqlite3_backup_step () другого потока, возможно, они возвращают недопустимые значения.</target>
        </trans-unit>
        <trans-unit id="218098ad11bde6e156b4a9f8e57ca75e25354cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; and &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; interfaces and the built-in &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; и &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_zeroblob (),&lt;/a&gt; а также встроенная &lt;a href=&quot;../lang_corefunc#zeroblob&quot;&gt;функция&lt;/a&gt; SQL zeroblob могут использоваться для создания блоба с нулевым заполнением для чтения или записи с использованием интерфейса инкрементального блоба.</target>
        </trans-unit>
        <trans-unit id="54f66c39b1fdccfb02fbdb0dd7e08e6474fe1802" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface, which has been deprecated and undocumented for 8 years, is changed into a no-op.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; , который устарел и не документировался в течение 8 лет, заменен на запретный.</target>
        </trans-unit>
        <trans-unit id="3cbc1814be35648af44f26835e6f82841778c411" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm&lt;/a&gt; routine is used to register a callback on memory allocation events. This routine registers or clears a callback that fires when the amount of memory allocated exceeds iThreshold. Only a single callback can be registered at a time. Each call to &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; overwrites the previous callback. The callback is disabled by setting xCallback to a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;c3ref/aggregate_count&quot;&gt;Sqlite3_memory_alarm&lt;/a&gt; процедура используется для регистрации обратного вызова на события выделения памяти. Эта процедура регистрирует или очищает обратный вызов, который запускается, когда объем выделенной памяти превышает iThreshold. Одновременно можно зарегистрировать только один обратный вызов. Каждый вызов &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; перезаписывает предыдущий обратный вызов. Обратный вызов отключается путем установки xCallback на NULL указатель.</target>
        </trans-unit>
        <trans-unit id="fc7e34038a904f7366dde6ee090a8282d84ade6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; interface has become a no-op.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup ()&lt;/a&gt; стал недоступным.</target>
        </trans-unit>
        <trans-unit id="ac435cb36a069024ddc4f4287c8ff0d76c80af5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; was created to address these concerns. The online backup API allows the contents of one database to be copied into another database, overwriting the original contents of the target database. The copy operation may be done incrementally, in which case the source database does not need to be locked for the duration of the copy, only for the brief periods of time when it is actually being read from. This allows other database users to continue uninterrupted while a backup of an online database is made.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;Online Backup API&lt;/a&gt; был создан для решения этих проблем. API онлайн-резервного копирования позволяет копировать содержимое одной базы данных в другую базу данных, перезаписывая исходное содержимое целевой базы данных. Операция копирования может выполняться постепенно, и в этом случае исходную базу данных не нужно блокировать на время копирования, только на короткие периоды времени, когда она фактически считывается. Это позволяет другим пользователям базы данных продолжать бесперебойную работу, пока создается резервная копия онлайн-базы данных.</target>
        </trans-unit>
        <trans-unit id="563d98f5bc61682f67da5d25a1062884fd2fdf5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; interface does &lt;u&gt;not&lt;/u&gt; work for a union-vtab. BLOB content must be read from the union-vtab using ordinary SQL statements.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_open&quot;&gt;Sqlite3_blob_open ()&lt;/a&gt; интерфейс делает &lt;u&gt;не&lt;/u&gt; работает для союзной-vtab. Содержимое BLOB должно быть прочитано из union-vtab с помощью обычных операторов SQL.</target>
        </trans-unit>
        <trans-unit id="b9d5c3998902d7d51338a9f7531152bceea38f9d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked once with a column name that is an empty string for every table referenced in a query from which no columns are extracted.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_READ &lt;/a&gt;&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;доверитель обратного вызова&lt;/a&gt; вызывается один раз с именем столбца, пустая строка для каждой таблицы , указанного в запросе , из которого не извлекаются ни один столбец.</target>
        </trans-unit>
        <trans-unit id="a68ee8ce42ad40a73650dbfe088fcf3e1c842ed0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; run-time option and the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option enable the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt;. See also ticket &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</source>
          <target state="translated">Параметр &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;времени&lt;/a&gt; выполнения SQLITE_DBCONFIG_ENABLE_QPSG и параметр &lt;a href=&quot;compile#enable_qpsg&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_QPSG обеспечивают &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;гарантию стабильности планировщика запросов&lt;/a&gt; . См. Также билет &lt;a href=&quot;https://www.sqlite.org/src/info/892fc34f173e99d8&quot;&gt;892fc34f173e99d8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba2430856bd9775a861cef9dfde7c36d65a2cc4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bit means that all writes to this device are atomic in the sense that either the entire write occurs or none of it occurs. The other &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; values indicate that writes of aligned blocks of the indicated size are atomic. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; means that when extending a file with new data, the new data is written first and then the file size is updated. So if a power failure occurs, there is no chance that the file might have been extended with randomness. The &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; bit means that all writes occur in the order that they are issued and are not reordered by the underlying file system.</source>
          <target state="translated">В &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; бит означает , что все записи в этом устройстве являются неделимыми в том смысле , что либо происходит все записи или ни один из них не происходит. Другие &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;значения &lt;i&gt;nnn&lt;/i&gt;&lt;/a&gt; SQLITE_IOCAP_ATOMIC указывают, что запись выровненных блоков указанного размера является атомарной. &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SAFE_APPEND&lt;/a&gt; означает, что при расширении файла новыми данными сначала записываются новые данные, а затем обновляется размер файла. Поэтому, если произойдет сбой питания, нет никаких шансов, что файл мог быть расширен случайным образом. В &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_SEQUENTIAL&lt;/a&gt; бит означает , что все записи происходят в порядке их выдача и не кондиционированные в основной файловой системе.</target>
        </trans-unit>
        <trans-unit id="9a653d67bd1da50ffe32f058a08a81d4f6edcd9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. This will always be set for TEMP databases and journals and for subjournals. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag means the file should be opened for exclusive access. This flag is set for all files except for the main database file. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen is allocated by the caller. xOpen just fills it in. The caller allocates a minimum of szOsFile bytes for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; флаг означает , что файл должен быть удален , если он закрыт. Это всегда будет установлено для баз данных и журналов TEMP, а также для субжурналов. &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; флаг означает , что файл должен быть открыт для монопольного доступа. Этот флаг установлен для всех файлов, кроме основного файла базы данных. Структура &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file,&lt;/a&gt; переданная в качестве третьего аргумента xOpen, выделяется вызывающей стороной. xOpen просто заполняет его. Вызывающий выделяет минимум szOsFile байтов для структуры &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="229110ee7251c5cf9b125b0ef0813a6c6ba215fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flags to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can also be used to adjust the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; of individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; at run-time.</source>
          <target state="translated">В &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; и &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; флаги в &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; могут также использоваться для настройки &lt;a href=&quot;threadsafe&quot;&gt;режима поточного&lt;/a&gt; отдельных &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; во время выполнения.</target>
        </trans-unit>
        <trans-unit id="966cc2ea77fca46efeb8c4289b4a653605ed43e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; option was added to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;.</source>
          <target state="translated">В &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; добавлен параметр &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abc999536061a5d7a156494c35b1ed191a9effbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type()&lt;/a&gt; function returns the datatype for the value in the Nth column. The return value is one of these:</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_type ()&lt;/a&gt; возвращает тип данных для значения в N-м столбце. Возвращаемое значение - одно из следующих:</target>
        </trans-unit>
        <trans-unit id="cffa274dabb801c01eb4f4986ad5f8726b7dca26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; function returns the number of columns in the results set. sqlite3_column_count() can be called at any time after &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;. &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; works similarly to &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; except that it only works following &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. If the previous call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returned SQLITE_DONE or an error code, then &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt; will return 0 whereas &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; will continue to return the number of columns in the result set.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; возвращает количество столбцов в наборе результатов. sqlite3_column_count () можно вызвать в любое время после &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; . &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count ()&lt;/a&gt; работает аналогично &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; за исключением того, что работает только после &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Если предыдущий вызов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; вернул SQLITE_DONE или код ошибки, тогда &lt;a href=&quot;c3ref/data_count&quot;&gt;sqlite3_data_count ()&lt;/a&gt; вернет 0, тогда как &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; продолжит возвращать количество столбцов в наборе результатов.</target>
        </trans-unit>
        <trans-unit id="df909dfd5bdc309e3368846cb0f8c21a5731a3d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface is used to make global, process-wide configuration changes for SQLite. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface must be called before any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; are created. The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface allows the programmer to do things like:</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; используется для внесения глобальных изменений конфигурации всего процесса для SQLite. Интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; должен быть вызван до создания любых &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединений с базой данных&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; позволяет программисту делать такие вещи, как:</target>
        </trans-unit>
        <trans-unit id="7eb7ccb56d39b4e4c7e512ab71314c715b6ea1d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt;,1) interfaces was invoked at start-time.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; , 1) были вызваны во время запуска.</target>
        </trans-unit>
        <trans-unit id="00c837fffcba80492d406ed18ba293449ca9513c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface is used to create new &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; for sorting text. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface is used to register new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface creates new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; используется для создания новых &lt;a href=&quot;datatype3#collation&quot;&gt;последовательностей&lt;/a&gt; сортировки для сортировки текста. Интерфейс &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; используется для регистрации новых реализаций &lt;a href=&quot;vtab&quot;&gt;виртуальных таблиц&lt;/a&gt; . Интерфейс &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; создает новые &lt;a href=&quot;vfs&quot;&gt;виртуальные файловые системы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4c521e07609cbfdb8d566dab7163fc87d422895" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces now return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; when passed invalid parameter combinations.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;Sqlite3_create_function ()&lt;/a&gt; семейство интерфейсов теперь возвращает &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; вместо &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; при пропускании недопустимых комбинаций параметров.</target>
        </trans-unit>
        <trans-unit id="caf6561662b932f66438111d53034fa55d79a49d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface can be used to override the like() function and thereby change the operation of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. When overriding the like() function, it may be important to override both the two and three argument versions of the like() function. Otherwise, different code may be called to implement the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator depending on whether or not an ESCAPE clause was specified.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; может использоваться для переопределения функции like () и тем самым изменения работы оператора &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; . При переопределении функции like () может быть важно переопределить версии с двумя и тремя аргументами функции like (). В противном случае может быть вызван другой код для реализации оператора &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE в&lt;/a&gt; зависимости от того, было ли указано предложение ESCAPE.</target>
        </trans-unit>
        <trans-unit id="a6b630ee12d42fc4528bfc71d36f585a36895111" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface creates new SQL functions - either scalar or aggregate. The new function implementation typically makes use of the following additional interfaces:</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; создает новые функции SQL - скалярные или агрегатные. Реализация новой функции обычно использует следующие дополнительные интерфейсы:</target>
        </trans-unit>
        <trans-unit id="99635893a7742a2b0a9430ca501d241e5f7023c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces return SQLITE_MISUSE on any attempt to overload or replace a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; module. The destructor is always called in this case, in accordance with historical and current documentation.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; и &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; возвращают SQLITE_MISUSE при любой попытке перегрузить или заменить модуль &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; . В этом случае всегда вызывается деструктор в соответствии с исторической и текущей документацией.</target>
        </trans-unit>
        <trans-unit id="0e7c498dc9b696b8a3e4e1f8ce0b76687320b809" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; routines associates a module name with an &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure and a separate client data that is specific to each module. The only difference between the two create_module methods is that the _v2 method includes an extra parameter that specifies a destructor for client data pointer. The module structure is what defines the behavior of a virtual table. The module structure looks like this:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;Sqlite3_create_module ()&lt;/a&gt; и &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; подпрограмм связывает имя модуля с &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; структурой и отдельный клиент данные, специфичные для каждого модуля. Единственное различие между двумя методами create_module состоит в том, что метод _v2 включает дополнительный параметр, определяющий деструктор для указателя данных клиента. Структура модуля определяет поведение виртуальной таблицы. Структура модуля выглядит так:</target>
        </trans-unit>
        <trans-unit id="ea2068b9a7520d6dd4dead5bbb83fc7b95e63987" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface can be used during a transaction to determine if there are deferred and unresolved foreign key constraints.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;Sqlite3_db_status&lt;/a&gt; (дб, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt; , ...) C-язык интерфейса можно использовать во время операции , чтобы определить, есть ли доходы будущих периодов и неразрешенные ограничения внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="5d823f649e66e357a40f8457ae11a89f890b8312" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; теперь применяется ко всем потокам внутри процесса, а не только к одному потоку, в котором он был запущен.</target>
        </trans-unit>
        <trans-unit id="dc8c7487a7241b1b53f75118a25cdfbd803a1bd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; function works much as it did in SQLite version 2. Zero or more SQL statements specified in the second parameter are compiled and executed. Query results are returned to a callback routine.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; работает так же, как и в SQLite версии 2. Компилируется и выполняется ноль или более операторов SQL, указанных во втором параметре. Результаты запроса возвращаются в процедуру обратного вызова.</target>
        </trans-unit>
        <trans-unit id="060e03cab55fa6e258498e740c2441a904ee6a9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; interface is a convenience wrapper that carries out all four of the above steps with a single function call. A callback function passed into &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; is used to process each row of the result set. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; is another convenience wrapper that does all four of the above steps. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; interface differs from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; in that it stores the results of queries in heap memory rather than invoking a callback.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; - это удобная оболочка, которая выполняет все четыре вышеуказанных шага за один вызов функции. Функция обратного вызова, переданная в &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , используется для обработки каждой строки набора результатов. &lt;a href=&quot;c3ref/free_table&quot;&gt;Sqlite3_get_table ()&lt;/a&gt; является еще удобство оболочки , которая делает все четыре вышеупомянутых шагов. Интерфейс &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; отличается от &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; тем, что он сохраняет результаты запросов в динамической памяти, а не вызывает обратный вызов.</target>
        </trans-unit>
        <trans-unit id="c55eb24f412d567a8152cd959c8adf08902c2ff0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface works on any prepared statement created using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. It is no longer necessary to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; in order to use &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; работает с любым подготовленным оператором, созданным с помощью &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; . Больше нет необходимости использовать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; с &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenormalize&quot;&gt;SQLITE_PREPARE_NORMALIZE&lt;/a&gt; , чтобы использовать &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b367904a5b319d97004324430003a01cf6b1ae72" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file. The xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; constructs an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object when the file is opened. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; keeps track of the state of the file while it is opened.</source>
          <target state="translated">Объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; представляет открытый файл. Метод xOpen &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; создает объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; при открытии файла. &lt;a href=&quot;c3ref/file&quot;&gt;Sqlite3_file&lt;/a&gt; отслеживает состояние файла во время его открытия.</target>
        </trans-unit>
        <trans-unit id="64a6d4c58c9877ecd1b62378eb5e65c884bd0f45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30882c8710d7d3a10831e6a935d755bd7e25652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure is used to pass information into and out of the xBestIndex method of the module that implements a virtual table.</source>
          <target state="translated">Структура &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; используется для передачи информации в метод xBestIndex модуля, реализующего виртуальную таблицу, и из него.</target>
        </trans-unit>
        <trans-unit id="c68c89f6fed7e1292abcc19abd161e51c2b5b49a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface can be called to explicitly initialize the SQLite subsystem. The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; interface is called automatically when invoking certain interfaces so the use of &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; is not required, but it is recommended.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; может быть вызван для явной инициализации подсистемы SQLite. Интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; вызывается автоматически при вызове определенных интерфейсов, поэтому использование &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; не требуется, но рекомендуется.</target>
        </trans-unit>
        <trans-unit id="086866a1ce9981846c47e35c1af526651c7809af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface causes SQLite to release any system resources (memory allocations, mutexes, open file handles) that might have been allocated by &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; заставляет SQLite освобождать любые системные ресурсы (выделение памяти, мьютексы, дескрипторы открытых файлов), которые могли быть выделены &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18eeb48351b373543379c24e8aba67998ec2d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interface frees all mutexes under windows.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; освобождает все мьютексы под окнами.</target>
        </trans-unit>
        <trans-unit id="f14f29a4830a0488c9f404caad392cc8f7efd81d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; routine can be called for a different thread</source>
          <target state="translated">&lt;a href=&quot;c3ref/interrupt&quot;&gt;Sqlite3_interrupt ()&lt;/a&gt; подпрограмма может быть вызвана для другого потока</target>
        </trans-unit>
        <trans-unit id="78920df495dd4dfe901c1e207965f56317d12fca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object holds the methods used to interact with an open file. Each &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains a pointer to an &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that is appropriate for the file it represents. The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object contains methods to do things such as read and write from the file, to truncate the file, to flush any changes to persistent storage, to find the size of the file, to lock and unlock the file, and to close file and destroy the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object.</source>
          <target state="translated">Объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; содержит методы, используемые для взаимодействия с открытым файлом. Каждый &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; содержит указатель на объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; , соответствующий файлу, который он представляет. Объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; содержит методы для выполнения таких действий, как чтение и запись из файла, усечение файла, сброс любых изменений в постоянное хранилище, определение размера файла, блокировка и разблокировка файла, закрытие файла и уничтожить объект &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="899386dff25e21c6b737c3d54a2f1045b6441f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object is a structure that contains pointers to methods for reading, writing, and otherwise dealing with files. This object is defined as follows:</source>
          <target state="translated">Объект &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; - это структура, которая содержит указатели на методы для чтения, записи и других действий с файлами. Этот объект определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="1277e9425f23dd50c872910508a38720a4c40a0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; function tries to detect if the source code has been modified from what is checked into version control and if there are modifications, the last four characters of the version hash are shown as &quot;alt1&quot; or &quot;alt2&quot;. The objective is to detect accidental and/or careless edits. A forger can subvert this feature.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; пытается определить, был ли исходный код изменен по сравнению с тем, что проверено в системе контроля версий, и если есть изменения, последние четыре символа хэша версии отображаются как &amp;laquo;alt1&amp;raquo; или &amp;laquo;alt2&amp;raquo;. Цель состоит в том, чтобы обнаружить случайные и / или небрежные правки. Фальсификатор может подорвать эту особенность.</target>
        </trans-unit>
        <trans-unit id="e51a6d9f987aab5062f7ef525db57b1e02273eb7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface loads an &lt;a href=&quot;loadext&quot;&gt;extension&lt;/a&gt; into a single database connection. The default behavior is for that extension to be automatically unloaded when the database connection closes. However, if the extension entry point returns SQLITE_OK_LOAD_PERMANENTLY instead of SQLITE_OK, then the extension remains loaded into the process address space after the database connection closes. In other words, the xDlClose methods of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is not called for the extension when the database connection closes.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; загружает &lt;a href=&quot;loadext&quot;&gt;расширение&lt;/a&gt; в одно соединение с базой данных. По умолчанию это расширение автоматически выгружается при закрытии соединения с базой данных. Однако, если точка входа расширения возвращает SQLITE_OK_LOAD_PERMANENTLY вместо SQLITE_OK, тогда расширение остается загруженным в адресное пространство процесса после закрытия соединения с базой данных. Другими словами, методы xDlClose объекта &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; не вызываются для расширения при закрытии соединения с базой данных.</target>
        </trans-unit>
        <trans-unit id="e180768903c106d7d176b62ab434360e88ec87ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces are deprecated. The equivalent functionality is now available through &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; устарели. Эквивалентная функциональность теперь доступна через &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46ea088bdd6bab93bd39ac4df39be5b9d52d9d73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interfaces, the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interface, and the &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; compile-time option are all non-functional when memory usage tracking is disabled.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater (),&lt;/a&gt; интерфейс &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; ) и параметр &lt;a href=&quot;compile#max_memory&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_MAX_MEMORY не работают, если отслеживание использования памяти отключено.</target>
        </trans-unit>
        <trans-unit id="8f1193a5998521b29a68d3af0690b60d457381cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure defines a module object used to implement a virtual table. Think of a module as a class from which one can construct multiple virtual tables having similar properties. For example, one might have a module that provides read-only access to comma-separated-value (CSV) files on disk. That one module can then be used to create several virtual tables where each virtual table refers to a different CSV file.</source>
          <target state="translated">Структура &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; определяет объект модуля, используемый для реализации виртуальной таблицы. Подумайте о модуле как о классе, из которого можно построить несколько виртуальных таблиц со схожими свойствами. Например, у кого-то может быть модуль, который обеспечивает доступ только для чтения к файлам с разделителями-запятыми (CSV) на диске. Затем этот один модуль можно использовать для создания нескольких виртуальных таблиц, где каждая виртуальная таблица ссылается на отдельный файл CSV.</target>
        </trans-unit>
        <trans-unit id="26e5c834aec9a24795809e8d9018891e41492180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_enter()&lt;/a&gt; attempts to enter the mutex and blocks if another threads is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try()&lt;/a&gt; attempts to enter and returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another thread is already there. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; exits a mutex. The mutex is held until the number of exits matches the number of entrances. If &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave()&lt;/a&gt; is called on a mutex that the thread is not currently holding, then the behavior is undefined. If any routine is called for a deallocated mutex, then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;Sqlite3_mutex_enter ()&lt;/a&gt; пытается ввести взаимную блокировку и блокирует если другая нить уже есть. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_try ()&lt;/a&gt; пытается войти и возвращает &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; в случае успеха или &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; если другой поток уже существует. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave ()&lt;/a&gt; выходит из мьютекса. Мьютекс удерживается до тех пор, пока количество выходов не совпадет с количеством входов. Если &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_leave ()&lt;/a&gt; вызывается для мьютекса, который поток в настоящее время не удерживает, то поведение не определено. Если для освобожденного мьютекса вызывается какая-либо подпрограмма, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="6f27ad8fcfe5b9da304436aec019b4cf39a32876" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free()&lt;/a&gt; routine should be used to deallocate a non-static mutex. If a static mutex is passed to this routine then the behavior is undefined.</source>
          <target state="translated">Для освобождения нестатического мьютекса следует использовать процедуру &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_free ()&lt;/a&gt; . Если в эту процедуру передается статический мьютекс, поведение не определено.</target>
        </trans-unit>
        <trans-unit id="bee285158d4476d2f4cfb28e9d58a1b17557c72d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; interface allows an application to discover all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; позволяет приложению обнаруживать все &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленные операторы,&lt;/a&gt; связанные с &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключением&lt;/a&gt; к базе данных .</target>
        </trans-unit>
        <trans-unit id="ab075f99c29f68391431d9855c2d09e8ff55b4eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces act as a compiler for converting SQL text into bytecode. The &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object is a container for a single bytecode program using to implement a single SQL statement. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface passes a bytecode program into the virtual machine, and runs the program until it either completes, or forms a row of result to be returned, or hits a fatal error, or is &lt;a href=&quot;c3ref/interrupt&quot;&gt;interrupted&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;Sqlite3_prepare_v2 ()&lt;/a&gt; и связанные с ними интерфейсы действуют как компилятор для преобразования текста в SQL байт - кода. Объект &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; - это контейнер для программы с одним байт-кодом, которая используется для реализации одного оператора SQL. Интерфейс &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; передает программу байт-кода в виртуальную машину и запускает программу до тех пор, пока она не завершится, либо не сформирует строку результата, которая будет возвращена, или не обнаружит фатальную ошибку, или не будет &lt;a href=&quot;c3ref/interrupt&quot;&gt;прервана&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f760f8c540dcc654012aa0be1cef03e69842a01e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interface creates a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that will automatically recompile itself if the schema changes. The easiest way to deal with &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors is to always use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; создает &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор&lt;/a&gt; , который автоматически перекомпилирует себя при изменении схемы. Самый простой способ справиться с ошибками &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; - всегда использовать &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; вместо &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3cb166cb387770ce5ad92997ed9078bd0c5b5827" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback is invoked (by &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;) for statements that did not run to completion.</source>
          <target state="translated">&lt;a href=&quot;c3ref/profile&quot;&gt;Sqlite3_profile ()&lt;/a&gt; обратный вызов (по &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; или &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; ) для операторов , которые не работают до завершения.</target>
        </trans-unit>
        <trans-unit id="c86c0301bb7f9f1fb47baffd646cd224ccc8e2ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface will now attempt to reduce the memory usages across all database connections in all threads, not just connections in the thread where the interface is called.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; теперь будет пытаться уменьшить использование памяти для всех подключений к базе данных во всех потоках, а не только для подключений в потоке, в котором вызывается интерфейс.</target>
        </trans-unit>
        <trans-unit id="049881541bf38acf3045d3cb673c48aa92e47dd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;, &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt;, and &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; interfaces now work cross all threads in the process, not just the single thread in which they are invoked. *** Potentially incompatible change ***</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; , &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; и &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; теперь работают со всеми потоками в процессе, а не только с одним потоком, в котором они вызываются. *** Потенциально несовместимое изменение ***</target>
        </trans-unit>
        <trans-unit id="af837a86c1e38824ef1d301d32834ef9f9b670f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; is invoked regardless of the presence of EXPLAIN or EXPLAIN QUERY PLAN.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;Авторизатор обратного вызова&lt;/a&gt; вызывается независимо от наличия EXPLAIN или EXPLAIN план запроса.</target>
        </trans-unit>
        <trans-unit id="af9451c90d2dee9cf3e529bb13a675b0008b0a17" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface now applies to all threads within a process, not to just the one thread in which it was run.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; теперь применяется ко всем потокам внутри процесса, а не только к одному потоку, в котором он был запущен.</target>
        </trans-unit>
        <trans-unit id="527b7feeedc271730252349576ab47baa1d727e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; interface works by registering a memory alarm at the soft heap limit and invoking &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; in the alarm callback. Application programs should not attempt to use the &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interface because doing so will interfere with the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; module. This interface is exposed only so that applications can provide their own alternative implementation when the SQLite core is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; работает, регистрируя аварийный сигнал памяти на пределе программной кучи и вызывая &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; в обратном вызове аварийного сигнала. Прикладные программы не должны пытаться использовать интерфейс &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm (),&lt;/a&gt; потому что это будет мешать работе модуля &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; . Этот интерфейс предоставляется только для того, чтобы приложения могли предоставить свою собственную альтернативную реализацию, когда ядро ​​SQLite скомпилировано с &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1ed21e10553df3077d02ccee7e2ab02fc21afc9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface can be used to set an upper bound on the total amount of outstanding memory that the general-purpose memory allocator for SQLite will allow to be outstanding at one time. If attempts are made to allocate more memory than specified by the soft heap limit, then SQLite will first attempt to free cache memory before continuing with the allocation request. The soft heap limit mechanism only works if &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; are enabled and it works best if the SQLite library is compiled with the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; можно использовать для установки верхнего предела общего объема невыполненной памяти, которую универсальный распределитель памяти для SQLite позволит одновременно использовать. Если предпринимаются попытки выделить больше памяти, чем указано в ограничении мягкой кучи, то SQLite сначала попытается освободить кеш-память, прежде чем продолжить выполнение запроса на выделение. Механизм ограничения мягкой кучи работает, только если включена &lt;a href=&quot;malloc#memstatus&quot;&gt;статистика памяти&lt;/a&gt; , и лучше всего работает, если библиотека SQLite скомпилирована с параметром &lt;a href=&quot;compile#enable_memory_management&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_MEMORY_MANAGEMENT .</target>
        </trans-unit>
        <trans-unit id="1eb6a622a1771cf9ae256233e2fb0c463ea616f9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects are controlled by a small set of C/C++ interface routine listed below.</source>
          <target state="translated">Соединение с &lt;a href=&quot;c3ref/sqlite3&quot;&gt;базой данных&lt;/a&gt; и &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленные&lt;/a&gt; объекты операторов управляются небольшим набором процедур интерфейса C / C ++, перечисленных ниже.</target>
        </trans-unit>
        <trans-unit id="5466713b299a5e73e4a0863d52f92664bc3844c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object: sqlite3</source>
          <target state="translated">Объект &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; : sqlite3</target>
        </trans-unit>
        <trans-unit id="1c3b251682ed613e33db0de124845adce3edbb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is running the VACUUM INTO statement was originally opened using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag.</source>
          <target state="translated">Соединение с &lt;a href=&quot;c3ref/sqlite3&quot;&gt;базой данных, на&lt;/a&gt; котором выполняется оператор VACUUM INTO, было первоначально открыто с использованием флага &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79e9d37ccb6719391098f5d43ea1dcd316705462" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object: sqlite3_stmt</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt&quot;&gt;Подготовленный оператор&lt;/a&gt; объекта: sqlite3_stmt</target>
        </trans-unit>
        <trans-unit id="cbcb829701917628eb2fd7b1899f66a93be104f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C/C++ interface together with the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; and &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; verbs can be used to detect at run-time when an SQL statement is not making effective use of indices. Many applications may prefer to use the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface to detect index misuse rather than the INDEXED BY phrase described here.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; C / C ++ вместе с &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusfullscanstep&quot;&gt;командами SQLITE_STMTSTATUS_FULLSCAN_STEP&lt;/a&gt; и &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatussort&quot;&gt;SQLITE_STMTSTATUS_SORT&lt;/a&gt; можно использовать для обнаружения во время выполнения, когда оператор SQL не эффективно использует индексы. Многие приложения могут предпочесть использовать интерфейс &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; для обнаружения неправильного использования индекса, а не описанную здесь фразу INDEXED BY.</target>
        </trans-unit>
        <trans-unit id="d3e46371f36d9155345020a6a81ffaba033339b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata()&lt;/a&gt; is enhanced to work correctly on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables and to check for the existence of a a table if the column name parameter is NULL. The interface is now also included in the build by default, without requiring the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; compile-time option.</source>
          <target state="translated">Функция &lt;a href=&quot;c3ref/table_column_metadata&quot;&gt;sqlite3_table_column_metadata ()&lt;/a&gt; улучшена для правильной работы с таблицами &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ ROWID&lt;/a&gt; и для проверки существования таблицы, если параметр имени столбца имеет значение NULL. Интерфейс теперь также включен в сборку по умолчанию, не требуя параметра &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_COLUMN_METADATA .</target>
        </trans-unit>
        <trans-unit id="edc8c97e4cc1a5aa05b289505090d5b34bad9902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt;, ...) interface allows selected SQL statement optimizations to be disabled at run-time. SQLite should always generate exactly the same answer with optimizations enabled and with optimizations disabled; the answer simply arrives quicker with the optimizations turned on. So in a production environment, one always leaves the optimizations turned on (the default setting).</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_OPTIMIZATIONS&lt;/a&gt; , ...) позволяет отключать оптимизацию выбранных операторов SQL во время выполнения. SQLite всегда должен генерировать один и тот же ответ при включенной и выключенной оптимизации; просто ответ приходит быстрее при включенной оптимизации. Поэтому в производственной среде оптимизацию всегда оставляют включенной (настройка по умолчанию).</target>
        </trans-unit>
        <trans-unit id="43fd3a5c9f7460ba2ff5df434fcffaa34616785e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; output for nested SQL statements should always begin with a &quot;--&quot; comment marker.</source>
          <target state="translated">&lt;a href=&quot;c3ref/trace_v2&quot;&gt;Sqlite3_trace_v2 ()&lt;/a&gt; выход для вложенных инструкций SQL всегда должен начинаться с &amp;laquo;-&amp;raquo; комментарием маркерами.</target>
        </trans-unit>
        <trans-unit id="19462b9c93da59d00cf4ac09d7e75c3130b9c27d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API, which is only available if the library is compiled with the pre-processor symbol &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; defined, is &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;documented here&lt;/a&gt;. This article is not a substitute for reading the full API documentation!</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;Sqlite3_unlock_notify ()&lt;/a&gt; API, который доступен только если библиотека скомпилирована с символом предварительно процессора &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; определена, &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;здесь документально&lt;/a&gt; . Эта статья не заменяет чтение полной документации по API!</target>
        </trans-unit>
        <trans-unit id="3e8d6caa4b5453ea5545263fa9616b15bb0d4f1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface is designed for use in systems that have a separate thread assigned to each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. There is nothing in the implementation that prevents a single thread from running multiple database connections. However, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface only works on a single connection at a time, so the lock resolution logic presented here will only work for a single database connection per thread.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; разработан для использования в системах, в которых каждому &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; назначен отдельный поток . В реализации нет ничего, что мешало бы одному потоку запускать несколько соединений с базой данных. Однако интерфейс &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; работает только с одним подключением за раз, поэтому представленная здесь логика разрешения блокировки будет работать только для одного подключения к базе данных на поток.</target>
        </trans-unit>
        <trans-unit id="1d6fc659db0d56afaed258d4fdfa842c7a2494e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; is not invoked for rows that are deleted by the REPLACE conflict resolution strategy. Nor does REPLACE increment the &lt;a href=&quot;c3ref/changes&quot;&gt;change counter&lt;/a&gt;. The exceptional behaviors defined in this paragraph might change in a future release.</source>
          <target state="translated">Ловушка &lt;a href=&quot;c3ref/update_hook&quot;&gt;обновления&lt;/a&gt; не вызывается для строк, удаленных стратегией разрешения конфликтов REPLACE. REPLACE также не увеличивает &lt;a href=&quot;c3ref/changes&quot;&gt;счетчик изменений&lt;/a&gt; . Исключительное поведение, определенное в этом параграфе, может измениться в следующем выпуске.</target>
        </trans-unit>
        <trans-unit id="50634212838ce725193912da3e909e9a53b3f585" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; API is used to locate a particular VFS by name. Its prototype is as follows:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;Sqlite3_vfs_find ()&lt;/a&gt; API используется для поиска определенного VFS по имени. Его прототип выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="cd79207584e9ef224be15cf9411b2100d6ae0c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; API is used to remove an existing VFS from the system.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs_find&quot;&gt;Sqlite3_vfs_unregister ()&lt;/a&gt; API , используется для удаления существующего VFS из системы.</target>
        </trans-unit>
        <trans-unit id="ca7466f7f648f5cd0c7b32027691a4626bfd37a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure represents a pointer to a specific row of a virtual table. This is what an sqlite3_vtab_cursor looks like:</source>
          <target state="translated">Структура &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; представляет собой указатель на определенную строку виртуальной таблицы. Вот как выглядит sqlite3_vtab_cursor:</target>
        </trans-unit>
        <trans-unit id="7da2c1fa98bb7a679ac7ffc72d14de8a7e2722aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connection's busy-handler callback. The argument is of type (void**) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connection's busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405e780a5eda0077cf02e3ce6060be9576266571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file-control may be invoked by SQLite on the database file handle shortly after it is opened in order to provide a custom VFS with access to the connections busy-handler callback. The argument is of type (void **) - an array of two (void *) values. The first (void *) actually points to a function of type (int (*)(void *)). In order to invoke the connections busy-handler, this function should be invoked with the second (void *) in the array as the only argument. If it returns non-zero, then the operation should be retried. If it returns zero, the custom VFS should abandon the current operation.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot; id=&quot;sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; файлы управление может быть вызвано SQLite на файл базы данных ручки вскоре после того, как он открыт для того , чтобы предоставить пользовательские VFS с доступом к соединениям занят обработчик обратного вызова. Аргумент имеет тип (void **) - массив из двух (void *) значений. Первый (void *) фактически указывает на функцию типа (int (*) (void *)). Чтобы вызвать обработчик занятости соединений, эту функцию следует вызывать со вторым (void *) в массиве в качестве единственного аргумента. Если возвращается ненулевое значение, то операцию следует повторить. Если он возвращает ноль, пользовательская VFS должна отказаться от текущей операции.</target>
        </trans-unit>
        <trans-unit id="c09f9898013c2f2b9084c257d373e6d8fb8e1f1d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; opcode is used to request that the VFS extends and truncates the database file in chunks of a size specified by the user. The fourth argument to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; should point to an integer (type int) containing the new chunk-size to use for the nominated database. Allocating database file space in large chunks (say 1MB at a time), may reduce file-system fragmentation and improve performance on some systems.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot; id=&quot;sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; используется для запроса того, чтобы VFS расширяла и усекала файл базы данных кусками размера, указанного пользователем. Четвертый аргумент &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; должен указывать на целое число (тип int), содержащее новый размер блока, который будет использоваться для указанной базы данных. Выделение файлового пространства базы данных большими фрагментами (скажем, по 1 МБ за раз) может уменьшить фрагментацию файловой системы и повысить производительность в некоторых системах.</target>
        </trans-unit>
        <trans-unit id="2724ba1a9151f430bfc44ff351307f4c931e3d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptdone&quot; id=&quot;sqlitefcntlckptdone&quot;&gt;SQLITE_FCNTL_CKPT_DONE&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode after the client has finished copying pages from the wal file to the database file, but before the *-shm file is updated to record the fact that the pages have been checkpointed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b7ae020cfbad6284212ff443474df4c8cbc164" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlckptstart&quot; id=&quot;sqlitefcntlckptstart&quot;&gt;SQLITE_FCNTL_CKPT_START&lt;/a&gt; opcode is invoked from within a checkpoint in wal mode before the client starts to copy pages from the wal file to the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563228c7f58e18a697dff44f98d2797b60b51628" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be performed atomically. This file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if the writes were all performed successfully and have been committed to persistent storage. Regardless of whether or not it is successful, this file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot; id=&quot;sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; заставляет все операции записи с момента предыдущего успешного вызова &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; выполняться атомарно. Этот файловый элемент управления возвращает &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; тогда и только тогда, когда все записи были выполнены успешно и были зафиксированы в постоянном хранилище. Независимо от того, успешен он или нет, этот файловый элемент управления выводит файловый дескриптор из режима пакетной записи, так что все последующие операции записи независимы. SQLite никогда не вызовет SQLITE_FCNTL_COMMIT_ATOMIC_WRITE без предварительного успешного вызова &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78b45f1d52cb17aec209a2fdf03a83375e0b951e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS after a transaction has been committed immediately but before the database is unlocked. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitphasetwo&quot; id=&quot;sqlitefcntlcommitphasetwo&quot;&gt;SQLITE_FCNTL_COMMIT_PHASETWO&lt;/a&gt; генерируется внутри SQLite и отправляется в VFS сразу после того, как транзакция была зафиксирована, но до разблокировки базы данных. VFS, которым этот сигнал не нужен, должны игнорировать этот код операции. Приложения не должны вызывать &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; с этим кодом операции, так как это может нарушить работу специализированных VFS, которые в этом нуждаются.</target>
        </trans-unit>
        <trans-unit id="fe01cd54971699e5fe35af1a0adc94faad95fbe1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provide a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; используется для обнаружения изменений в файле базы данных. Аргумент - указатель на 32-битовое целое число без знака. &amp;laquo;Версия данных&amp;raquo; для пейджера записывается в указатель. &amp;laquo;Версия данных&amp;raquo; изменяется всякий раз, когда происходит какое-либо изменение в соответствующем файле базы данных, либо посредством операторов SQL в том же соединении с базой данных, либо посредством транзакций, совершенных отдельными соединениями с базой данных, возможно, в других процессах. Интерфейс &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; можно использовать, чтобы узнать, изменилась ли какая-либо база данных в соединении, но этот интерфейс реагирует на изменения как на TEMP, так и на MAIN, и не предоставляет механизма для обнаружения изменений только в MAIN. Кроме того, &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt;интерфейс реагирует только на внутренние изменения и пропускает изменения, сделанные другими соединениями с базой данных. Команда &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; предоставляет механизм для обнаружения изменений в одной подключенной базе данных, которые происходят из-за других подключений к базе данных, но пропускает изменения, реализованные подключением к базе данных, на котором она вызывается. Этот файловый контроль - единственный механизм для обнаружения изменений, которые происходят внутри или снаружи и которые связаны с конкретной присоединенной базой данных.</target>
        </trans-unit>
        <trans-unit id="429853e91982da517f099946a428569f5a10010d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot; id=&quot;sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; opcode is used to detect changes to a database file. The argument is a pointer to a 32-bit unsigned integer. The &quot;data version&quot; for the pager is written into the pointer. The &quot;data version&quot; changes whenever any change occurs to the corresponding database file, either through SQL statements on the same database connection or through transactions committed by separate database connections possibly in other processes. The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface can be used to find if any database on the connection has changed, but that interface responds to changes on TEMP as well as MAIN and does not provide a mechanism to detect changes to MAIN only. Also, the &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interface responds to internal changes only and omits changes made by other database connections. The &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command provides a mechanism to detect changes to a single attached database that occur due to other database connections, but omits changes implemented by the database connection on which it is called. This file control is the only mechanism to detect changes that happen either internally or externally and that are associated with a particular attached database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0a05c22977d8b1dc9945aac16fc4626f1dd660" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot; id=&quot;sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; используется для получения указателя на объект &lt;a href=&quot;file&quot;&gt;sqlite3_file,&lt;/a&gt; связанный с конкретным подключением к базе данных. См. Также &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddddd8caea4f2699898b48925bf95b8d69764816" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; file control interprets its argument as a pointer to an integer and it writes a boolean into that integer depending on whether or not the file has been renamed, moved, or deleted since it was first opened.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlhasmoved&quot; id=&quot;sqlitefcntlhasmoved&quot;&gt;SQLITE_FCNTL_HAS_MOVED&lt;/a&gt; управления файлами интерпретирует свой аргумент как указатель на целое число и записывает логическое значение в этом целое число в зависимости от наличия или отсутствия файла был переименован, перемещен или удален , так как он был впервые открыт.</target>
        </trans-unit>
        <trans-unit id="bc589731780274c54e5cd365284382cd5887eded" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; opcode is used to obtain a pointer to the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object associated with the journal file (either the &lt;a href=&quot;../lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt;) for a particular database connection. See also &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot; id=&quot;sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; опкод используется для получения указателя на &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; объект , связанный с файлом журнал (либо &lt;a href=&quot;../lockingv3#rollback&quot;&gt;журнал откат&lt;/a&gt; или &lt;a href=&quot;../wal&quot;&gt;журнал запись вперед&lt;/a&gt; ) для конкретного соединения с базой данных. См. Также &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5d8ff8dd3d322caf95cdc56c272ff4998cee7a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to write the current state of the lock (one of &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt;, &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt;, or &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt;) into an integer that the pArg argument points to. This capability is used during testing and is only available when the SQLITE_TEST compile-time option is used.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot; id=&quot;sqlitefcntllockstate&quot;&gt;SQLITE_FCNTL_LOCKSTATE&lt;/a&gt; используется для отладки. Этот код операции заставляет метод xFileControl записывать текущее состояние блокировки (одно из &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; , &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; или &lt;a href=&quot;c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; ) в целое число, на которое указывает аргумент pArg. Эта возможность используется во время тестирования и доступна только при использовании параметра времени компиляции SQLITE_TEST.</target>
        </trans-unit>
        <trans-unit id="835bd4a6a4daee4b5c892d531fad550f3b7944bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode causes attempts to obtain a file lock using the xLock or xShmLock methods of the VFS to wait for up to M milliseconds before failing, where M is the single unsigned integer parameter.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; заставляет попытки получить блокировку файла с помощью методов xLock или xShmLock VFS для ожидания до M миллисекунд перед неудачей, где M - единственный целочисленный параметр без знака.</target>
        </trans-unit>
        <trans-unit id="f76db0b59ac49aa27a2ffafc1d9d0b7df64c41cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntllocktimeout&quot; id=&quot;sqlitefcntllocktimeout&quot;&gt;SQLITE_FCNTL_LOCK_TIMEOUT&lt;/a&gt; opcode is used to configure a VFS to block for up to M milliseconds before failing when attempting to obtain a file lock using the xLock or xShmLock methods of the VFS. The parameter is a pointer to a 32-bit signed integer that contains the value that M is to be set to. Before returning, the 32-bit signed integer is overwritten with the previous value of M.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9534ed4df1d95266c96610467198479542d6649c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; file control is used to query or set the maximum number of bytes that will be used for memory-mapped I/O. The argument is a pointer to a value of type sqlite3_int64 that is an advisory maximum number of bytes in the file to memory map. The pointer is overwritten with the old value. The limit is not changed if the value originally pointed to is negative, and so the current limit can be queried by passing in a pointer to a negative number. This file-control is used internally to implement &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot; id=&quot;sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; управления файлами используется для запроса или установить максимальное число байтов , которые будут использоваться для памяти отображенного ввода / вывода. Аргумент является указателем на значение типа sqlite3_int64, которое является рекомендуемым максимальным количеством байтов в файле для отображения памяти. Указатель заменяется старым значением. Предел не изменяется, если изначально указанное значение отрицательное, поэтому текущий предел можно запросить, передав указатель на отрицательное число. Этот файловый контроль используется внутри для реализации &lt;a href=&quot;../pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85959ccb42981e5ee3527aa791391f6482ac784e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; opcode is invoked by SQLite after opening a write transaction to indicate that, unless it is rolled back for some reason, the entire database file will be overwritten by the current transaction. This is used by VACUUM operations.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot; id=&quot;sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; вызывается SQLite после открытия транзакции записи, чтобы указать, что, если по какой-либо причине не будет выполнен откат, весь файл базы данных будет перезаписан текущей транзакцией. Это используется операциями ВАКУУМ.</target>
        </trans-unit>
        <trans-unit id="d2750128ef1083c346294ef6e3be361e6eba77af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; opcode is used to set or query the persistent &lt;a href=&quot;../wal&quot;&gt;Write Ahead Log&lt;/a&gt; setting. By default, the auxiliary write ahead log (&lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;) and shared memory files used for transaction control are automatically deleted when the latest connection to the database closes. Setting persistent WAL mode causes those files to persist after close. Persisting the files is useful when other processes that do not have write permission on the directory containing the database file want to read the database file, as the WAL and shared memory files must exist in order for the database to be readable. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable persistent WAL mode or 1 to enable persistent WAL mode. If the integer is -1, then it is overwritten with the current WAL persistence setting.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot; id=&quot;sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; используется для установки или запроса постоянной настройки &lt;a href=&quot;../wal&quot;&gt;журнала&lt;/a&gt; предварительной записи . По умолчанию вспомогательный журнал упреждающей записи ( &lt;a href=&quot;../wal#walfile&quot;&gt;файл WAL&lt;/a&gt; ) и файлы разделяемой памяти, используемые для управления транзакциями, автоматически удаляются при закрытии последнего подключения к базе данных. Установка постоянного режима WAL приводит к тому, что эти файлы сохраняются после закрытия. Сохранение файлов полезно, когда другие процессы, у которых нет разрешения на запись в каталог, содержащий файл базы данных, хотят прочитать файл базы данных, поскольку файлы WAL и разделяемой памяти должны существовать, чтобы база данных была доступна для чтения. Четвертый параметр &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt;для этого кода операции должен быть указатель на целое число. Это целое число равно 0 для отключения постоянного режима WAL или 1 для включения постоянного режима WAL. Если целое число равно -1, оно перезаписывается текущим параметром сохранения WAL.</target>
        </trans-unit>
        <trans-unit id="e3329771b09c8d9c17e5ba63393baaa851477f87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode is used to set or query the persistent &quot;powersafe-overwrite&quot; or &quot;PSOW&quot; setting. The PSOW setting determines the &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; bit of the xDeviceCharacteristics methods. The fourth parameter to &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; for this opcode should be a pointer to an integer. That integer is 0 to disable zero-damage mode or 1 to enable zero-damage mode. If the integer is -1, then it is overwritten with the current zero-damage mode setting.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot; id=&quot;sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; используется для установки или запроса постоянной настройки &amp;laquo;PowerSafe-overwrite&amp;raquo; или &amp;laquo;PSOW&amp;raquo;. Параметр PSOW определяет &lt;a href=&quot;c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; немного методов xDeviceCharacteristics. Четвертый параметр &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; для этого кода операции должен быть указателем на целое число. Это целое число равно 0, чтобы отключить режим нулевого урона, или 1, чтобы включить режим нулевого урона. Если целое число равно -1, то оно перезаписывается текущим значением режима нулевого повреждения.</target>
        </trans-unit>
        <trans-unit id="b7ebc915c79af1c389d3c702e8a0e217f15cd6b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; opcode is implemented by the special VFS used by the RBU extension only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrbu&quot; id=&quot;sqlitefcntlrbu&quot;&gt;SQLITE_FCNTL_RBU&lt;/a&gt; реализуется специальной VFS, используемой только расширением RBU. Все остальные VFS должны возвращать SQLITE_NOTFOUND для этого кода операции.</target>
        </trans-unit>
        <trans-unit id="d7a6279d094b2efb4418d75c6d39f8cf80f5db9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; opcode causes all write operations since the previous successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; to be rolled back. This file control takes the file descriptor out of batch write mode so that all subsequent write operations are independent. SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without a prior successful call to &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot; id=&quot;sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; вызывает откат всех операций записи с момента предыдущего успешного вызова &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; . Этот файловый элемент управления выводит файловый дескриптор из режима пакетной записи, так что все последующие операции записи независимы. SQLite никогда не будет вызывать SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE без предварительного успешного вызова &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="37dec85b72b827823523f2dbeaab4ae1365e897b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; opcode is used by SQLite to give the VFS layer a hint of how large the database file will grow to be during the current transaction. This hint is not guaranteed to be accurate but it is often close. The underlying VFS might choose to preallocate database file space based on this hint in order to help writes to the database file run faster.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot; id=&quot;sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt; используется SQLite, чтобы дать слою VFS подсказку о том, насколько большим будет файл базы данных во время текущей транзакции. Этот намек не гарантирует точность, но часто бывает близок. Базовая VFS может выбрать предварительное выделение файлового пространства базы данных на основе этой подсказки, чтобы ускорить запись в файл базы данных.</target>
        </trans-unit>
        <trans-unit id="53dec04041f2a1cd0f5d61ecfdd7363482736f2d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; opcode is used by in-memory VFS that implements &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; to set an upper bound on the size of the in-memory database. The argument is a pointer to a &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt;. If the integer pointed to is negative, then it is filled in with the current limit. Otherwise the limit is set to the larger of the value of the integer pointed to and the current database size. The integer pointed to is set to the new limit.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot; id=&quot;sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt; используется VFS в памяти, которая реализует &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; для установки верхней границы размера базы данных в памяти. Аргумент - указатель на &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; . Если указанное целое число отрицательно, то оно заполняется текущим пределом. В противном случае устанавливается максимальное значение из указанного целого числа и текущего размера базы данных. Указанное целое число установлено на новый предел.</target>
        </trans-unit>
        <trans-unit id="5eb8033743ca0212b9de7ee6d6d452df418e67e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions master-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; генерируется внутри SQLite и отправляется в VFS непосредственно перед вызовом метода xSync в дескрипторе файла базы данных. Или, если метод xSync не вызывается из-за того, что пользователь настроил SQLite с &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF,&lt;/a&gt; он вызывается вместо метода xSync. В большинстве случаев аргумент указателя, передаваемый с этим файловым элементом управления, имеет значение NULL. Однако, если файл базы данных синхронизируется как часть фиксации нескольких баз данных, аргумент указывает на строку с завершающим нулем, содержащую имя файла главного журнала транзакций. VFS, которым этот сигнал не нужен, должны игнорировать этот код операции. Приложения не должны вызывать &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; с этим кодом операции, так как это может нарушить работу специализированных VFS, которым он действительно нужен.</target>
        </trans-unit>
        <trans-unit id="ca40036ed80ac456626498e6b097f64ffd5f3c6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsync&quot; id=&quot;sqlitefcntlsync&quot;&gt;SQLITE_FCNTL_SYNC&lt;/a&gt; opcode is generated internally by SQLite and sent to the VFS immediately before the xSync method is invoked on a database file descriptor. Or, if the xSync method is not invoked because the user has configured SQLite with &lt;a href=&quot;../pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; it is invoked in place of the xSync method. In most cases, the pointer argument passed with this file-control is NULL. However, if the database file is being synced as part of a multi-database commit, the argument points to a nul-terminated string containing the transactions super-journal file name. VFSes that do not need this signal should silently ignore this opcode. Applications should not call &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with this opcode as doing so may disrupt the operation of the specialized VFSes that do require it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5b82162695e993bb266a9bcb74822b0cb0729d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file control provides advisory information to the VFS about what the higher layers of the SQLite stack are doing. This file control is used by some VFS activity tracing &lt;a href=&quot;../vfs#shim&quot;&gt;shims&lt;/a&gt;. The argument is a zero-terminated string. Higher layers in the SQLite stack may generate instances of this file control if the &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;SQLITE_USE_FCNTL_TRACE&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltrace&quot; id=&quot;sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; управления файлами предоставляет консультационную информацию для VFS о том , что высшие слои SQLite стека делают. Этот файловый элемент управления используется некоторыми &lt;a href=&quot;../vfs#shim&quot;&gt;прокладками&lt;/a&gt; отслеживания активности VFS . Аргумент - строка с нулевым символом в конце. Более высокие уровни в стеке SQLite могут генерировать экземпляры этого файлового &lt;a href=&quot;../compile#use_fcntl_trace&quot;&gt;элемента&lt;/a&gt; управления, если включена опция времени компиляции SQLITE_USE_FCNTL_TRACE .</target>
        </trans-unit>
        <trans-unit id="dc747f657ceac57a6b93ab7190def0e8a928303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; opcode can be used to obtain the names of all &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; in the VFS stack. The names are of all VFS shims and the final bottom-level VFS are written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and the result is stored in the char* variable that the fourth parameter of &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; points to. The caller is responsible for freeing the memory when done. As with all file-control actions, there is no guarantee that this will actually do anything. Callers should initialize the char* variable to a NULL pointer in case this file-control is not implemented. This file-control is intended for diagnostic use only.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfsname&quot; id=&quot;sqlitefcntlvfsname&quot;&gt;SQLITE_FCNTL_VFSNAME&lt;/a&gt; опкод может быть использован для получения имен всех &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; в стеке VFS. Имена всех прокладок VFS и последняя VFS нижнего уровня записываются в память, полученную из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; а результат сохраняется в переменной char *, на которую указывает четвертый параметр &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; . Вызывающий абонент отвечает за освобождение памяти по завершении. Как и в случае со всеми действиями по управлению файлами, нет никакой гарантии, что это действительно что-то сделает. Вызывающие должны инициализировать переменную char * указателем NULL в случае, если этот файловый контроль не реализован. Этот файл-контроль предназначен только для диагностического использования.</target>
        </trans-unit>
        <trans-unit id="8a271c98ba50f856db7d26935d70d5164c6f00e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; opcode finds a pointer to the top-level &lt;a href=&quot;../vfs&quot;&gt;VFSes&lt;/a&gt; currently in use. The argument X in sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be of type &quot;&lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&quot;. This opcodes will set *X to a pointer to the top-level VFS. When there are multiple VFS shims in the stack, this opcode finds the upper-most shim only.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlvfspointer&quot; id=&quot;sqlitefcntlvfspointer&quot;&gt;SQLITE_FCNTL_VFS_POINTER&lt;/a&gt; находит указатель на &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; верхнего уровня, которые используются в настоящее время. Аргумент X в sqlite3_file_control (db, SQLITE_FCNTL_VFS_POINTER, X) должен иметь тип &amp;laquo; &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; **&amp;raquo;. Эти коды операций устанавливают * X как указатель на VFS верхнего уровня. Если в стеке несколько прокладок VFS, этот код операции находит только самую верхнюю прокладку.</target>
        </trans-unit>
        <trans-unit id="5113389d53b260a388ff9b96ca66847bbd222b0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; is a signal to the VFS layer that it might be advantageous to block on the next WAL lock if the lock is not immediately available. The WAL subsystem issues this signal during rare circumstances in order to fix a problem with priority inversion. Applications should &lt;em&gt;not&lt;/em&gt; use this file-control.</source>
          <target state="translated">&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwalblock&quot; id=&quot;sqlitefcntlwalblock&quot;&gt;SQLITE_FCNTL_WAL_BLOCK&lt;/a&gt; является сигналом к слою VFS , что это может быть выгодно , чтобы блокировать на следующей блокировке WAL , если блокировка не доступна немедленно. Подсистема WAL выдает этот сигнал в редких случаях, чтобы устранить проблему с инверсией приоритета. Приложения &lt;em&gt;не&lt;/em&gt; должны использовать этот файловый контроль.</target>
        </trans-unit>
        <trans-unit id="6f1b780daaf82dc713d986bde97a154815b1318d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; opcode is used to configure automatic retry counts and intervals for certain disk I/O operations for the windows &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; in order to provide robustness in the presence of anti-virus programs. By default, the windows VFS will retry file read, file write, and file delete operations up to 10 times, with a delay of 25 milliseconds before the first retry and with the delay increasing by an additional 25 milliseconds with each subsequent retry. This opcode allows these two values (10 retries and 25 milliseconds of delay) to be adjusted. The values are changed for all database connections within the same process. The argument is a pointer to an array of two integers where the first integer is the new retry count and the second integer is the delay. If either integer is negative, then the setting is not changed but instead the prior value of that setting is written into the array entry, allowing the current retry settings to be interrogated. The zDbName parameter is ignored.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32avretry&quot; id=&quot;sqlitefcntlwin32avretry&quot;&gt;SQLITE_FCNTL_WIN32_AV_RETRY&lt;/a&gt; используется для настройки автоматического числа повторов и интервалов для определенных операций дискового ввода-вывода для Windows &lt;a href=&quot;../vfs&quot;&gt;VFS.&lt;/a&gt;для обеспечения устойчивости при наличии антивирусных программ. По умолчанию Windows VFS будет повторять операции чтения, записи и удаления файлов до 10 раз с задержкой 25 миллисекунд перед первой попыткой и с задержкой, увеличивающейся на дополнительные 25 миллисекунд с каждой последующей попыткой. Этот код операции позволяет настроить эти два значения (10 попыток и 25 миллисекунд задержки). Значения изменяются для всех подключений к базе данных в рамках одного процесса. Аргумент - это указатель на массив из двух целых чисел, где первое целое число - это новый счетчик повторов, а второе целое число - это задержка. Если любое из целых чисел является отрицательным, то параметр не изменяется, а вместо этого предыдущее значение этого параметра записывается в запись массива, позволяя запросить текущие параметры повторной попытки.Параметр zDbName игнорируется.</target>
        </trans-unit>
        <trans-unit id="937fe17d531247dde2a8c434e7c019ad55d302c9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; opcode can be used to obtain the underlying native file handle associated with a file handle. This file control interprets its argument as a pointer to a native file handle and writes the resulting value there.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot; id=&quot;sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; может использоваться для получения базового собственного дескриптора файла, связанного с дескриптором файла. Этот файловый элемент управления интерпретирует свой аргумент как указатель на собственный дескриптор файла и записывает туда полученное значение.</target>
        </trans-unit>
        <trans-unit id="e6e591e785c2547026326ba62eddb1a8e3a00235" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; opcode is used for debugging. This opcode causes the xFileControl method to swap the file handle with the one pointed to by the pArg argument. This capability is used during testing and only needs to be supported when SQLITE_TEST is defined.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlwin32sethandle&quot; id=&quot;sqlitefcntlwin32sethandle&quot;&gt;SQLITE_FCNTL_WIN32_SET_HANDLE&lt;/a&gt; используется для отладки. Этот код операции заставляет метод xFileControl заменять дескриптор файла на тот, на который указывает аргумент pArg. Эта возможность используется во время тестирования и должна поддерживаться только тогда, когда определен SQLITE_TEST.</target>
        </trans-unit>
        <trans-unit id="5d3e0696fb81e2cd89dc43dbc9ef7b0440a8b5e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; opcode is implemented by zipvfs only. All other VFS should return SQLITE_NOTFOUND for this opcode.</source>
          <target state="translated">Код операции &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlzipvfs&quot; id=&quot;sqlitefcntlzipvfs&quot;&gt;SQLITE_FCNTL_ZIPVFS&lt;/a&gt; реализуется только zipvfs. Все остальные VFS должны возвращать SQLITE_NOTFOUND для этого кода операции.</target>
        </trans-unit>
        <trans-unit id="15edb51b39cd83bfa83c4b8e2f7138c93f46e748" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; flag means the file should be deleted when it is closed. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; will be set for TEMP databases and their journals, transient databases, and subjournals.</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; флаг означает , что файл должен быть удален , если он закрыт. &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt; будет установлен для TEMP баз данных и их журналов, переходных баз данных и subjournals.</target>
        </trans-unit>
        <trans-unit id="fc3c6baa196558e15836748dd318cdd30a688ef6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; flag is always used in conjunction with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; flag, which are both directly analogous to the O_EXCL and O_CREAT flags of the POSIX open() API. The SQLITE_OPEN_EXCLUSIVE flag, when paired with the SQLITE_OPEN_CREATE, is used to indicate that file should always be created, and that it is an error if it already exists. It is</source>
          <target state="translated">&lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_EXCLUSIVE&lt;/a&gt; флаг всегда используется в сочетании с &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; флагом, которые оба непосредственно аналогичны флагам O_EXCL и O_CREAT в POSIX открытых () API. Флаг SQLITE_OPEN_EXCLUSIVE в сочетании с SQLITE_OPEN_CREATE используется для обозначения того, что файл всегда должен создаваться и что это ошибка, если он уже существует. это</target>
        </trans-unit>
        <trans-unit id="c2061592c87f5f999944ce29cf7569df9e8b3f69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; C preprocessor macro in the sqlite3.h header evaluates to a string literal that is the SQLite version in the format &quot;X.Y.Z&quot; where X is the major version number (always 3 for SQLite3) and Y is the minor version number and Z is the release number. The &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; C preprocessor macro resolves to an integer with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same numbers used in &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;. The SQLITE_VERSION_NUMBER for any given release of SQLite will also be larger than the release from which it is derived. Either Y will be held constant and Z will be incremented or else Y will be incremented and Z will be reset to zero.</source>
          <target state="translated">&lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; препроцессор макросов в заголовке sqlite3.h принимает значение строкового литерала , который является версией SQLite в формате &amp;laquo;XYZ&amp;raquo; , где Х представляет собой основной номер версии (всегда 3 для SQLite3) и Y это номер версии и незначительные Z является номер выпуска. &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt; С препроцессора макрос преобразуется в целое число со значением (Х * 1000000 + Y * 1000 + Z) , где X, Y и Z имеют те же номера , используемые в &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; . SQLITE_VERSION_NUMBER для любого данного выпуска SQLite также будет больше, чем выпуск, из которого он получен. Либо Y будет оставаться постоянным, а Z будет увеличиваться, либо Y будет увеличиваться, а Z будет сброшено на ноль.</target>
        </trans-unit>
        <trans-unit id="ffc6747416294fa8545c14bddccb7cfdc4ee3b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface unregisters the initialization routine X that was registered using a prior call to &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension(X)&lt;/a&gt;. The &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; отменяет регистрацию процедуры инициализации X, которая была зарегистрирована с использованием предыдущего вызова &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension (X)&lt;/a&gt; . В &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; подпрограмма возвращает 1 , если процедура инициализации X был успешно незарегистрированные и возвращает 0 , если X не был включен в список подпрограмм инициализации.</target>
        </trans-unit>
        <trans-unit id="5d6d6c3ad7f7d02755c43722a7a4b2dabb76ea67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carray&quot;&gt;carray table-valued function&lt;/a&gt; needs to accept a pointer to an array of C-language values from the application.</source>
          <target state="translated">Функция &lt;a href=&quot;carray&quot;&gt;carray с табличным значением&lt;/a&gt; должна принимать указатель на массив значений языка C от приложения.</target>
        </trans-unit>
        <trans-unit id="99b9d11b0a4071822aa18a343a895720b0d0af06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command now accepts multiple LIKE-pattern arguments and outputs the union of all matching tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c282faf1973e4f89130abe26a61f3f513af735e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; compile-time option can be used to change the default page size assigned to new databases.</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#default_page_size&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_DEFAULT_PAGE_SIZE можно использовать для изменения размера страницы по умолчанию, назначенного новым базам данных.</target>
        </trans-unit>
        <trans-unit id="5f025c2cb604da7be21c2713e7ae110d6fc22479" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; is increased from 1024 to 4096. The &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; is changed from 2000 to -2000 so the same amount of cache memory is used by default. See the application note on the &lt;a href=&quot;pgszchng2016&quot;&gt;version 3.12.0 page size change&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;a href=&quot;compile#default_page_size&quot;&gt;SQLITE_DEFAULT_PAGE_SIZE&lt;/a&gt; увеличен с 1024 до 4096. &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; изменяется от 2000 до -2000 так же объем кэш - памяти используется по умолчанию. См. Примечание по применению об &lt;a href=&quot;pgszchng2016&quot;&gt;изменении размера страницы версии 3.12.0&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="623f46dd8d1f8aedc876d36b9e6b7c6843fb38ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;-DSQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option causes SQLite to bypass its page cache when reading content from overflow pages. This helps database reads of 10K blobs run a little faster, but not all that much faster. SQLite still holds a speed advantage over direct filesystem reads without the SQLITE_DIRECT_OVERFLOW_READ compile-time option.</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;времени&lt;/a&gt; компиляции -DSQLITE_DIRECT_OVERFLOW_READ заставляет SQLite обходить свой кеш страницы при чтении содержимого с переполненных страниц. Это помогает читать базы данных из 10 КБ BLOB-объектов немного быстрее, но не намного быстрее. SQLite по-прежнему имеет преимущество в скорости по сравнению с прямым чтением файловой системы без параметра времени компиляции SQLITE_DIRECT_OVERFLOW_READ.</target>
        </trans-unit>
        <trans-unit id="e8d73bde2dc7785ffa127c202c3991e5af269a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option is now turned on by default in the standard builds.</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_EXPLAIN_COMMENTS теперь включен по умолчанию в стандартных сборках.</target>
        </trans-unit>
        <trans-unit id="ec9ba2ea4ea2e87921df34017de3d69d7b4137bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; compile-time option causes the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect a small histogram of each index, to help SQLite better select among competing range query indices.</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#enable_stat2&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_STAT2 заставляет команду &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; собирать небольшую гистограмму каждого индекса, чтобы помочь SQLite лучше выбирать среди конкурирующих индексов запроса диапазона.</target>
        </trans-unit>
        <trans-unit id="e0180c578d01206ca2260b932e5fe2d4e6cc6568" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options only work when building from canonical source files. They do &lt;u&gt;not&lt;/u&gt; work when you build from the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; or from the pre-processed source files.</source>
          <target state="translated">Параметры &lt;a href=&quot;compile#omitfeatures&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_OMIT _... работают только при построении из канонических исходных файлов. Они &lt;u&gt;не&lt;/u&gt; работают, когда вы строите из &lt;a href=&quot;amalgamation&quot;&gt;объединения&lt;/a&gt; SQLite или из предварительно обработанных исходных файлов.</target>
        </trans-unit>
        <trans-unit id="f951ab56418025da71fd3229ec924e7681f98557" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option sets an initial baseline value for the maximum number of index-and-constraint combinations that the query planner consider. The baseline query planner limit is increased by SQLITE_QUERY_PLANNER_LIMIT_INCR prior to processing each table of a join so that each table is guaranteed to be able to propose at least some index-and-constraint combinations to the optimizer even if prior tables of the join have exhausted the baseline limit. The default value for both this compile-time option and the &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; option are set high enough so that they should never be reached for real-world queries.</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; устанавливает начальное базовое значение для максимального количества комбинаций индекса и ограничения, которые учитывает планировщик запросов. Предел планировщика базовых запросов увеличивается на SQLITE_QUERY_PLANNER_LIMIT_INCR перед обработкой каждой таблицы объединения, так что каждая таблица гарантированно сможет предложить оптимизатору хотя бы некоторые комбинации индекса и ограничения, даже если предыдущие таблицы объединения исчерпали базовый предел. Значение по умолчанию как для этой опции времени компиляции, так и для опции &lt;a href=&quot;compile#query_planner_limit&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT&lt;/a&gt; установлено достаточно высоким, чтобы они никогда не могли быть достигнуты для запросов реального мира.</target>
        </trans-unit>
        <trans-unit id="4cd49b137fd67eca14bbcc5b6c746f08a2997711" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option fixed to make sure that content is deleted even when the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; applies.</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#secure_delete&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_SECURE_DELETE исправлен, чтобы гарантировать, что содержимое удаляется даже при применении &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;оптимизации усечения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="656d7af3931cb41fc80d6fdefc85a4cfb80b7c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is a #define whose value is an integer between 0 and 3, inclusive. The meaning of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is as follows:</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#temp_store&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TEMP_STORE - это #define, значение которого является целым числом от 0 до 3 включительно. Значение параметра времени компиляции &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; следующее:</target>
        </trans-unit>
        <trans-unit id="4c11588171d30d65004665748aee39867b770ec3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option can be used to limit the length of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt; expansion in the output of sqlite3_trace().</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#trace_size_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TRACE_SIZE_LIMIT можно использовать для ограничения длины расширения &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанного параметра&lt;/a&gt; в выводе sqlite3_trace ().</target>
        </trans-unit>
        <trans-unit id="355c715bbc78271373ada3410d668232a6d1cc69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option limits the size of bound parameter expansions. The &lt;a href=&quot;compile#omit_trace&quot;&gt;SQLITE_OMIT_TRACE&lt;/a&gt; compile-time option causes sqlite3_expanded_sql() to always return NULL.</source>
          <target state="translated">Параметр &lt;a href=&quot;compile#trace_size_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_TRACE_SIZE_LIMIT ограничивает размер расширений связанных параметров. Параметр &lt;a href=&quot;compile#omit_trace&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_OMIT_TRACE заставляет sqlite3_expanded_sql () всегда возвращать NULL.</target>
        </trans-unit>
        <trans-unit id="d80a700ed456a052f14722da1654635b16877833" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option will cause this setting to default to OFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f82d70cfe7739c80fc41874304dfb1e1ffafd3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;, ...) interface can register an alternative page cache implementation by passing in an instance of the sqlite3_pcache_methods2 structure. In many applications, most of the heap memory allocated by SQLite is used for the page cache. By implementing a custom page cache using this API, an application can better control the amount of memory consumed by SQLite, the way in which that memory is allocated and released, and the policies used to determine exactly which parts of a database file are cached and for how long.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...) может зарегистрировать альтернативную реализацию кеширования страниц, передав экземпляр структуры sqlite3_pcache_methods2. Во многих приложениях большая часть памяти кучи, выделенной SQLite, используется для кеширования страниц. Реализуя настраиваемый кеш страницы с помощью этого API, приложение может лучше контролировать объем памяти, потребляемой SQLite, способ выделения и освобождения этой памяти, а также политики, используемые для точного определения того, какие части файла базы данных кэшируются и как долго.</target>
        </trans-unit>
        <trans-unit id="28bbb907be12b8d8d6cb3f58bde73db3db4a2a3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output no longer shows an estimate of the number of rows generated by each loop in a join.</source>
          <target state="translated">&lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY ПЛАН&lt;/a&gt; выходных больше не отображается оценка числа строк , порожденных каждой петли в объединении.</target>
        </trans-unit>
        <trans-unit id="0403e12475b1041021c7db25c8bbeab40ee20902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface makes a direct call to the xFileControl method for the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object associated with a particular database identified by the second argument. The name of the database is &quot;main&quot; for the main database or &quot;temp&quot; for the TEMP database, or the name that appears after the AS keyword for databases that are added using the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command. A NULL pointer can be used in place of &quot;main&quot; to refer to the main database file. The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method. The return value of the xFileControl method becomes the return value of this routine.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; выполняет прямой вызов метода xFileControl для объекта &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods,&lt;/a&gt; связанного с конкретной базой данных, указанной вторым аргументом. Имя базы данных - &amp;laquo;main&amp;raquo; для основной базы данных или &amp;laquo;temp&amp;raquo; для базы данных TEMP, или имя, которое появляется после ключевого слова AS для баз данных, добавленных с помощью команды &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL. Указатель NULL может использоваться вместо &amp;laquo;main&amp;raquo; для ссылки на основной файл базы данных. Третий и четвертый параметры этой подпрограммы передаются напрямую второму и третьему параметрам метода xFileControl. Возвращаемое значение метода xFileControl становится возвращаемым значением этой процедуры.</target>
        </trans-unit>
        <trans-unit id="c477329521e0c202c4f6312a9b20720b0061408f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2&quot;&gt;underlying file format&lt;/a&gt; for SQLite databases does not change in incompatible ways. There are literally hundreds of billions, perhaps trillions, of SQLite database files in circulation and the SQLite developers are committing to supporting those files for decades into the future.</source>
          <target state="translated">&lt;a href=&quot;fileformat2&quot;&gt;Основной формат файла&lt;/a&gt; для баз данных SQLite не меняется несовместимыми способами. В обращении находятся буквально сотни миллиардов, возможно, триллионы файлов базы данных SQLite, и разработчики SQLite обязуются поддерживать эти файлы на десятилетия вперед.</target>
        </trans-unit>
        <trans-unit id="019a9b5a0c4bab7b2872e5382ef484fc4c667e1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#validfor&quot;&gt;version-valid-for number&lt;/a&gt;.</source>
          <target state="translated">Номер &lt;a href=&quot;fileformat2#validfor&quot;&gt;версии, действительной для которой&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47ad55bfdbffd81a341414cce2caff94549fb57d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL file format&lt;/a&gt; is precisely defined and is cross-platform.</source>
          <target state="translated">Формат &lt;a href=&quot;fileformat2#walformat&quot;&gt;файла WAL&lt;/a&gt; точно определен и является кросс-платформенным.</target>
        </trans-unit>
        <trans-unit id="d24509e4b9939bc43b94f948e05ab88b6b7e58c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;floatingpoint#decext&quot;&gt;decimal extension&lt;/a&gt; and the &lt;a href=&quot;floatingpoint#ieee754ext&quot;&gt;ieee754 extension&lt;/a&gt; are built-in to the CLI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e921edb70343a6bdb367da8f2286bed023bed5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent key&lt;/a&gt; of a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; is not allowed to use the rowid. The parent key must used named columns only.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;Родительский ключ&lt;/a&gt; из &lt;a href=&quot;foreignkeys&quot;&gt;внешнего ключа&lt;/a&gt; не допускается использовать ROWID. В родительском ключе должны использоваться только именованные столбцы.</target>
        </trans-unit>
        <trans-unit id="94136fe2e1cb36bfe5b8895ca9db2e90ee44f1f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; MATCH operator passes pointers into &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; оператор MATCH передает указатели во &lt;a href=&quot;fts3#snippet&quot;&gt;фрагмент ()&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;смещение ()&lt;/a&gt; , и &lt;a href=&quot;fts3#matchinfo&quot;&gt;MatchInfo ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43eb5ae7856e6e2985afc5b90e134ad6efe6a669" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4 &quot;rebuild&quot; command&lt;/a&gt; deletes the entire full-text index and rebuilds it based on the current set of documents in the content table. Assuming again that &quot;t3&quot; is the name of the external content FTS4 table, the rebuild command looks like this:</source>
          <target state="translated">Команда &lt;a href=&quot;fts3#*fts4rebuidcmd&quot;&gt;FTS4 &amp;laquo;rebuild&amp;raquo;&lt;/a&gt; удаляет весь полнотекстовый индекс и перестраивает его на основе текущего набора документов в таблице содержимого. Если снова предположить, что &amp;laquo;t3&amp;raquo; - это имя таблицы FTS4 внешнего содержимого, команда перестроения будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="a98c7bde5e55ca0fc0875001b5230f001bb8d1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function always returns NULL unless either the legacy application-defined FTS3 tokenizers interface are enabled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting, or unless the first argument to fts3_tokenizer() is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;.</source>
          <target state="translated">Функция &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; всегда возвращает NULL, если какой-либо из устаревших интерфейсов токенизаторов FTS3, определенных приложением, не включен с помощью параметра &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; ), или если первый аргумент fts3_tokenizer () не является &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанным параметром&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1574210b17663fb17af96bfd5572d4febc918bf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator is supported for queries based on the built-in full-text index.</source>
          <target state="translated">Оператор &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; поддерживается для запросов на основе встроенного полнотекстового индекса.</target>
        </trans-unit>
        <trans-unit id="afda903a3f03dcbd2f01644e1f0a3ea9a0e62818" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#matchinfo-x&quot;&gt;matchinfo 'x' flag&lt;/a&gt; would report a single hit for the phrases &quot;a&quot; and &quot;c&quot;. However, the 'y' directive reports the number of hits for &quot;c&quot; as zero, as it is part of a sub-expression that does not match the document - (b AND c). For queries that do not contain AND operators descended from OR operators, the result values returned by 'y' are always the same as those returned by 'x'.</source>
          <target state="translated">&lt;a href=&quot;fts3#matchinfo-x&quot;&gt;Флаг MatchInfo &amp;laquo;х&amp;raquo;&lt;/a&gt; сообщит один хит для фраз &amp;laquo;а&amp;raquo; и &amp;laquo;с&amp;raquo;. Однако директива 'y' сообщает количество совпадений для &quot;c&quot; как ноль, поскольку это часть подвыражения, которое не соответствует документу - (b AND c). Для запросов, не содержащих операторов И, производных от операторов ИЛИ, значения результатов, возвращаемые &amp;laquo;y&amp;raquo;, всегда такие же, как и возвращаемые &amp;laquo;x&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="5a3b429b14a3a0c21190f0bbe4a4fec620e8c35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;, &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt;, &lt;a href=&quot;fts3#offsets&quot;&gt;offsets()&lt;/a&gt;, and &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; are available to support full-text queries.</source>
          <target state="translated">В &lt;a href=&quot;fts3#snippet&quot;&gt;FTS вспомогательные функции&lt;/a&gt; , &lt;a href=&quot;fts3#snippet&quot;&gt;фрагмент кода ()&lt;/a&gt; , &lt;a href=&quot;fts3#offsets&quot;&gt;зачеты ()&lt;/a&gt; , и &lt;a href=&quot;fts3#matchinfo&quot;&gt;MatchInfo ()&lt;/a&gt; доступны для поддержки полнотекстовых запросов.</target>
        </trans-unit>
        <trans-unit id="986cc21a6b9f4c0f213b24757430a9834e1ed2e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#snippet&quot;&gt;snippet&lt;/a&gt; function cannot be used with the above query. Because the outer query does not include a &quot;WHERE ... MATCH&quot; clause, the snippet function may not be used with it. One solution is to duplicate the WHERE clause used by the sub-query in the outer query. The overhead associated with this is usually negligible.</source>
          <target state="translated">&lt;a href=&quot;fts3#snippet&quot;&gt;Фрагмент кода&lt;/a&gt; функция не может быть использована с указанным выше запроса. Поскольку внешний запрос не включает предложение WHERE ... MATCH, функцию сниппета нельзя использовать с ним. Одно из решений - продублировать предложение WHERE, используемое подзапросом во внешнем запросе. Связанные с этим накладные расходы обычно незначительны.</target>
        </trans-unit>
        <trans-unit id="6bce43282ea827774137f471cf2a2f9eafebbd71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer is now included in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;fts3#unicode61&quot;&gt;Unicode61&lt;/a&gt; токенизатор теперь включен в &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="d0b9e4179a7690f373db2c622ddd029271ea2c29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25() auxiliary function&lt;/a&gt; returns a real value reflecting the accuracy of the current match. Better matches are assigned numerically lower values.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;Вспомогательная функция BM25 ()&lt;/a&gt; возвращает реальное значение , отражающее точность текущего матча. Лучшим совпадениям присваиваются более низкие численные значения.</target>
        </trans-unit>
        <trans-unit id="86d537287fe3b1d151168bae58fabce38b16555d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt;, used to configure whether or not the size in tokens of each value in the FTS5 table is stored separately within the database.</source>
          <target state="translated">Параметр &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&amp;laquo;columnsize&amp;raquo;&lt;/a&gt; , используемый для настройки, будет ли размер в токенах каждого значения в таблице FTS5 храниться отдельно в базе данных.</target>
        </trans-unit>
        <trans-unit id="4542957e1a08fcc6a2bdcd49b04a58f559cf1ff8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_detail_option&quot;&gt;&quot;detail&quot; option&lt;/a&gt;. This option may be used to reduce the size of the FTS index on disk by omitting some information from it.</source>
          <target state="translated">Вариант &lt;a href=&quot;fts5#the_detail_option&quot;&gt;&amp;laquo;детализация&amp;raquo;&lt;/a&gt; . Эта опция может использоваться для уменьшения размера индекса FTS на диске путем исключения из него некоторой информации.</target>
        </trans-unit>
        <trans-unit id="e41a2e84baae07818885bfa4f91b936da5a1f958" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_highlight_function&quot;&gt;highlight() auxiliary function&lt;/a&gt; returns a copy of the text from one of the columns of the current match with each instance of a queried term within the result surrounded by specified markup (for example &quot;&amp;lt;b&amp;gt;&quot; and &quot;&amp;lt;/b&amp;gt;&quot;).</source>
          <target state="translated">&lt;a href=&quot;fts5#the_highlight_function&quot;&gt;Момент () вспомогательные функции&lt;/a&gt; возвращают копию текста из одного из столбцов текущего матча с каждым экземпляром запрашиваемого термина в результате в окружении указанной разметки (например , &amp;laquo;&amp;lt;Ь&amp;gt;&amp;raquo; и &amp;laquo;&amp;lt;/ B&amp;gt;&amp;raquo; ).</target>
        </trans-unit>
        <trans-unit id="b98a3fb75c4347301e0a46ec5f5ca45961387193" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet() auxiliary function&lt;/a&gt; selects a short fragment of text from one of the columns of the matched row and returns it with each instance of a queried term surrounded by markup in the same manner as the highlight() function. The fragment of text is selected so as to maximize the number of queried terms it contains.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_snippet_function&quot;&gt;Вспомогательная функция фрагмента коды ()&lt;/a&gt; выбирает короткий фрагмент текста из одного из столбцов согласованной строки и возвращает его с каждым экземпляром запрашиваемого термина в окружении разметки таким же образом , как функции выделения (). Фрагмент текста выбирается таким образом, чтобы в нем было максимальное количество запрашиваемых терминов.</target>
        </trans-unit>
        <trans-unit id="3a9eabcd215930eb738f36712bb83d6c0b14ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; or &quot;AFL&quot; fuzzer is a recent (circa 2014) innovation from Michal Zalewski. Unlike most other fuzzers that blindly generate random inputs, the AFL fuzzer instruments the program being tested (by modifying the assembly-language output from the C compiler) and uses that instrumentation to detect when an input causes the program to do something different - to follow a new control path or loop a different number of times. Inputs that provoke new behavior are retained and further mutated. In this way, AFL is able to &quot;discover&quot; new behaviors of the program under test, including behaviors that were never envisioned by the designers.</source>
          <target state="translated">&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;American Fuzzy Lop&lt;/a&gt; или &amp;laquo;AFL&amp;raquo; fuzzer недавний (около 2014 г.) инновация от Михала Залевского. В отличие от большинства других фаззеров, которые слепо генерируют случайные входные данные, фаззер AFL инструментирует тестируемую программу (путем изменения выходных данных на языке ассемблера из компилятора C) и использует этот инструментарий, чтобы определять, когда входные данные заставляют программу делать что-то другое - следовать новый путь управления или цикл другое количество раз. Входные данные, которые вызывают новое поведение, сохраняются и далее видоизменяются. Таким образом, AFL может &amp;laquo;обнаруживать&amp;raquo; новые модели поведения тестируемой программы, включая поведение, которое никогда не предполагалось разработчиками.</target>
        </trans-unit>
        <trans-unit id="8ddbb2bd7ba87408b594939a6917d04da89a5349" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; is the version control system used to track all of the SQLite source code. A Fossil repository is an SQLite database file. (Readers are invited to ponder this recursion as an independent exercise.) Fossil is both the version-control system for SQLite and a test platform for SQLite. Whenever enhancements are made to SQLite, Fossil is one of the first applications to test and evaluate those enhancements. So Fossil was an early adopter of the NGQP.</source>
          <target state="translated">В &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;ископаемом DVCS&lt;/a&gt; это система контроля версий используется для отслеживания всех исходного кода SQLite. Репозиторий Fossil - это файл базы данных SQLite. (Читателям предлагается обдумать эту рекурсию как самостоятельное упражнение.) Fossil - это одновременно система контроля версий для SQLite и тестовая платформа для SQLite. Всякий раз, когда в SQLite вносятся улучшения, Fossil является одним из первых приложений, которое тестирует и оценивает эти улучшения. Итак, компания Fossil была одним из первых последователей NGQP.</target>
        </trans-unit>
        <trans-unit id="cca3e4effc9207d5a63c711cbfd8ac97defe5fba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL Logic Test&lt;/b&gt;&lt;/a&gt; or SLT test harness is used to run huge numbers of SQL statements against both SQLite and several other SQL database engines and verify that they all get the same answers. SLT currently compares SQLite against PostgreSQL, MySQL, Microsoft SQL Server, and Oracle 10g. SLT runs 7.2 million queries comprising 1.12GB of test data.</source>
          <target state="translated">&lt;a href=&quot;http://www.sqlite.org/sqllogictest&quot; id=&quot;slt&quot;&gt;&lt;b&gt;SQL Logic Test&lt;/b&gt;&lt;/a&gt; Жгут тест или SLT используется для выполнения огромного количества заявлений SQL против как SQLite и несколько других СУБД SQL и убедитесь , что все они получают одни и те же ответы. SLT в настоящее время сравнивает SQLite с PostgreSQL, MySQL, Microsoft SQL Server и Oracle 10g. SLT выполняет 7,2 миллиона запросов, содержащих 1,12 ГБ тестовых данных.</target>
        </trans-unit>
        <trans-unit id="154e70bf20f83a327304d76749961d8773743242" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; interface to webkit allowed any webpage to run arbitrary SQL in the browser for Chrome and Safari. That arbitrary SQL was supposed to be run inside a sandbox where it could do no harm even if exploited, but that sandbox turned out to be less secure than people supposed. In the spring of 2017, one team of hackers was able to root an iMac using a long sequence of exploits, one of which involved corrupting the pointers passed as BLOB values to the snippet() FTS3 function of an SQLite database running via the WebSQL interface inside of Safari.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;https://en.wikipedia.org/wiki/Web_SQL_Database&quot;&gt;WebSQL&lt;/a&gt; для webkit позволял любой веб-странице запускать произвольный SQL в браузере для Chrome и Safari. Предполагалось, что этот произвольный SQL будет запускаться внутри песочницы, где он не может причинить вреда даже в случае использования, но эта песочница оказалась менее безопасной, чем предполагалось. Весной 2017 года одна команда хакеров смогла получить root права на iMac, используя длинную последовательность эксплойтов, один из которых включал повреждение указателей, переданных как значения BLOB в функцию snippet () FTS3 базы данных SQLite, работающую через интерфейс WebSQL. внутри Safari.</target>
        </trans-unit>
        <trans-unit id="6101be379589e2c8cd0e728015188ca8e192b3db" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil Distributed Version Control&lt;/a&gt; system provides users with the option to download check-ins as either Tarballs, ZIP Archives, or SQLite Archives.</source>
          <target state="translated">Система управления &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;распределенными&lt;/a&gt; версиями Fossil предоставляет пользователям возможность загружать чеки-ин в виде Tarballs, ZIP-архивов или SQLite-архивов.</target>
        </trans-unit>
        <trans-unit id="6106b2007efa210c8ee70fed3636c5f43bb5c12d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; that allows an SQLite database to be appended to some other file. This allows (for example) a database to be appended to an executable that then opens and reads the database.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;Append VFS&lt;/a&gt; является &lt;a href=&quot;vfs#shim&quot;&gt;VFS прокладкой&lt;/a&gt; , которая позволяет SQLite базы данных , которая будет добавлена к какому - либо другому файлу. Это позволяет (например) добавить базу данных к исполняемому файлу, который затем откроет и прочитает базу данных.</target>
        </trans-unit>
        <trans-unit id="80173a6349ab4ffb46f02ada86de670d66a57b26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;sqlite_btreeinfo&lt;/a&gt; eponymous virtual table for introspecting and estimating the sizes of the btrees in a database.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/btreeinfo.c&quot;&gt;Sqlite_btreeinfo&lt;/a&gt; одноименная виртуальная таблица для интроспекции и оценки размеры btrees в базе данных.</target>
        </trans-unit>
        <trans-unit id="ab07c049c01997dbb19b575504dcb74af616cde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember() extension&lt;/a&gt; needs a pointer to a C-language integer variable in which to remember the value it passes.</source>
          <target state="translated">Расширению &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/remember.c&quot;&gt;Remember ()&lt;/a&gt; требуется указатель на целочисленную переменную языка C, в которой можно запомнить передаваемое значение.</target>
        </trans-unit>
        <trans-unit id="56d93d46695516053b394cd5886b780db3048dfe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; extension show an example of a loadable extension that persistently registers both a new VFS and a new virtual table. The &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init()&lt;/a&gt; initialization routine in that extension is called only once, when the extension is first loaded. It registers the new &quot;vfslog&quot; VFS just that one time, and it returns SQLITE_OK_LOAD_PERMANENTLY so that the code used to implement the &quot;vfslog&quot; VFS will remain in memory. The initialization routine also invokes &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a pointer to the &quot;vstatRegister()&quot; function so that all subsequent database connections will invoke the &quot;vstatRegister()&quot; function as they start up, and hence register the &quot;vfsstat&quot; virtual table.</source>
          <target state="translated">Расширение &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; показывает пример загружаемого расширения, которое постоянно регистрирует как новую VFS, так и новую виртуальную таблицу. Процедура инициализации &lt;a href=&quot;https://sqlite.org/src/info/77b5b4235c9f7f11?ln=801-819&quot;&gt;sqlite3_vfsstat_init ()&lt;/a&gt; в этом расширении вызывается только один раз при первой загрузке расширения. Он регистрирует новую VFS &amp;laquo;vfslog&amp;raquo; только один раз и возвращает SQLITE_OK_LOAD_PERMANENTLY, так что код, используемый для реализации VFS &amp;laquo;vfslog&amp;raquo;, остается в памяти. Процедура инициализации также вызывает &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; для указателя на функцию &amp;laquo;vstatRegister ()&amp;raquo;, чтобы все последующие соединения с базой данных вызывали функцию &amp;laquo;vstatRegister ()&amp;raquo; при запуске и, следовательно, регистрировали виртуальную таблицу &amp;laquo;vfsstat&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="037dcdadc7444a9f8e13871793682a198eab41e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script, also in the canonical source tree, is used to run the speedtest1.c program. To replicate the performance measurements, collect the following files into a single directory:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;Speed-check.sh&lt;/a&gt; сценарий оболочки, а также в исходном дереве каноническим, используется для запуска программы speedtest1.c. Чтобы повторить измерения производительности, соберите следующие файлы в один каталог:</target>
        </trans-unit>
        <trans-unit id="3427f1e6f488cf0eccc944462552651c0021ca21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;src/shell.c&lt;/a&gt; source code to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; is no longer under version control. That file is now generated as part of the build process.</source>
          <target state="translated">Не &lt;a href=&quot;https://sqlite.org/src/finfo?name=src/shell.c&quot;&gt;SRC / shell.c&lt;/a&gt; исходный код в &lt;a href=&quot;cli&quot;&gt;оболочке командной строки&lt;/a&gt; больше не находится под контролем версий. Этот файл теперь создается как часть процесса сборки.</target>
        </trans-unit>
        <trans-unit id="c808a45cb504200c3f1dbb6bdafa2749899db0fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite Fossil Repository&lt;/a&gt; contains links for downloading a Tarball, ZIP Archive, or &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; for any historical version of SQLite. The URLs for these downloads are simple and can be incorporated easily into automated tools. The format is:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;SQLite Fossil Repository&lt;/a&gt; содержит ссылки для скачивания архива, ZIP архив или &lt;a href=&quot;sqlar&quot;&gt;SQLite Архива&lt;/a&gt; для любой исторической версии SQLite. URL-адреса для этих загрузок просты и могут быть легко включены в автоматизированные инструменты. Формат:</target>
        </trans-unit>
        <trans-unit id="d3fbdd1d270cc576e74540d52236d70c3135bcb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON standard&lt;/a&gt; is syntax for exchanging geospatial information using JSON. GeoJSON is a rich standard that can describe nearly any kind of geospatial content.</source>
          <target state="translated">Стандарт &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;GeoJSON&lt;/a&gt; - это синтаксис для обмена геопространственной информацией с использованием JSON. GeoJSON - это обширный стандарт, который может описывать практически любой геопространственный контент.</target>
        </trans-unit>
        <trans-unit id="103a9865440a893fd3c0abf774146aac35769fd1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil Version Control System&lt;/a&gt; uses its own printf() implementation that is derived from an early version of the SQLite printf() implementation, but those two implementations have since diverged.</source>
          <target state="translated">Система &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;управления&lt;/a&gt; версиями Fossil использует собственную реализацию printf (), которая является производной от ранней версии SQLite реализации printf (), но с тех пор эти две реализации разошлись.</target>
        </trans-unit>
        <trans-unit id="6c9ad5b94e94e6f0742495238eb4e3e441c282ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system (designed and written for the purpose of supporting SQLite development) allows mildly trusted users to enter arbitrary SQL for generating trouble-ticket reports. That SQL is sanitized using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface, and no exploits have ever been found. But this is an example of potentially hostile agents being able to inject arbitrary SQL into the system.</source>
          <target state="translated">Система контроля версий &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; (разработанная и написанная для поддержки разработки SQLite) позволяет пользователям с умеренным доверием вводить произвольный SQL для создания отчетов о проблемах. Этот SQL обрабатывается с помощью интерфейса &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; , и никаких эксплойтов обнаружено не было. Но это пример того, как потенциально враждебные агенты могут вводить в систему произвольный SQL.</target>
        </trans-unit>
        <trans-unit id="d3062c93a43df260caeb23ab2e3ad2153f90cd2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;Sqlite3_int64&lt;/a&gt; переменной , на которую указывает параметр T будет установлен на общее количество строк осмотрен всех итераций X-го цикла.</target>
        </trans-unit>
        <trans-unit id="db1220ff947aa3310307b8d1e97a7892f5326b35" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the T parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="translated">&lt;a href=&quot;int64&quot;&gt;Sqlite3_int64&lt;/a&gt; переменной , на которую указывает параметр Т будет установлен на общее число раз , что Х-го цикла, закончилась.</target>
        </trans-unit>
        <trans-unit id="ffcdafee896254e841c8ceef0c82d886514030ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of rows examined by all iterations of the X-th loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0533f74a6fe1362e5ed7a748ce1c72de0f80c71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; variable pointed to by the V parameter will be set to the total number of times that the X-th loop has run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d635355782e5d01fca2019b73467bea006012ad0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article on this website is an earlier investigation (circa 2011) that uses the same approach as the Jim Gray paper &amp;mdash; storing the blob filenames as entries in the database &amp;mdash; but for SQLite instead of SQL Server.</source>
          <target state="translated">&lt;a href=&quot;intern-v-extern-blob&quot;&gt;Внутреннее Versus Внешнего BLOB&lt;/a&gt; - статья на этом сайте , является ранее исследованием (около 2011) , который использует тот же подход, что и Джим Грей бумага - хранящей блобы имена файлов, записей в базе данных - но для SQLite вместо SQL Server.</target>
        </trans-unit>
        <trans-unit id="cf7fb4a466758f27d2e851f548bb98e33d7f26c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang&quot;&gt;SQL language documentation&lt;/a&gt; is converted to use &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt; instead of BNF.</source>
          <target state="translated">Документация по &lt;a href=&quot;lang&quot;&gt;языку SQL&lt;/a&gt; преобразована для использования &lt;a href=&quot;syntaxdiagrams&quot;&gt;синтаксических диаграмм&lt;/a&gt; вместо BNF.</target>
        </trans-unit>
        <trans-unit id="e0edaa5ff21911b0f3da41c0480fbb1aa18847d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command works differently in two respects when foreign key constraints are enabled:</source>
          <target state="translated">Команда &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; работает по-разному в двух отношениях, когда включены ограничения внешнего ключа:</target>
        </trans-unit>
        <trans-unit id="7f9caf431fddd0486fb12661e16a4ade73718c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command now gathers statistics on tables even if they have no indices.</source>
          <target state="translated">Команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; теперь собирает статистику по таблицам, даже если у них нет индексов.</target>
        </trans-unit>
        <trans-unit id="2e90c478519d8e9b1bd82d0dd1c5b19da711cd5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement is an SQLite extension that allows two or more databases to be associated to the same database connection and to operate as if they were a single database. The number of simultaneously attached databases is limited to SQLITE_MAX_ATTACHED which is set to 10 by default. The maximum number of attached databases cannot be increased above 125.</source>
          <target state="translated">Оператор &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; - это расширение SQLite, которое позволяет двум или более базам данных быть связанными с одним и тем же подключением к базе данных и работать так, как если бы они были одной базой данных. Количество одновременно подключенных баз данных ограничено значением SQLITE_MAX_ATTACHED, которое по умолчанию равно 10. Максимальное количество подключенных баз данных не может быть больше 125.</target>
        </trans-unit>
        <trans-unit id="e65f9f430c67e4418373e91a58e15ed50bb5c875" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;ON КОНФЛИКТ&lt;/a&gt; раздел</target>
        </trans-unit>
        <trans-unit id="3e1a4fb3e81abe601d6a76ca6511292629d722a1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;ifnull()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; SQL functions are now implemented using in-line VDBE code rather than calling external functions, so that unused arguments need never be evaluated.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#ifnull&quot;&gt;IFNULL ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;сливается ()&lt;/a&gt; функция SQL теперь реализована с использованием в линии коды VDBE вместо вызова внешних функций, так что неиспользуемые аргументы никогда не должны быть оценены.</target>
        </trans-unit>
        <trans-unit id="c97e1aa1d73b591cf5ec83039aad0924cf633432" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; is subject to the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; limit of &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. Hence any printf() result with a width or precision more than the SQLITE_LIMIT_LENGTH will cause an &lt;a href=&quot;rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; error. However, the low-level formatting for the printf() function is done by a subroutine that does not have access to SQLITE_LIMIT_LENGTH. So the low-level formatting is done into a memory allocation that might be considerably larger than SQLITE_LIMIT_LENGTH and the SQLITE_LIMIT_LENGTH check is only performed after all formatting is complete. Thus there might be a transient buffer that exceeds SQLITE_LIMIT_LENGTH. The SQLITE_PRINTF_PRECISION_LIMIT option is an additional check that prevents excess sizes for the transient buffer used inside the low-level formatting subroutine, prior to the SQLITE_LIMIT_LENGTH check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38d1ab83adc6d5e3ecac3108de3718b731fffb5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#random&quot;&gt;random()&lt;/a&gt; function is obviously non-deterministic because it gives a different answer every time it is invoked. The answers from &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid()&lt;/a&gt; depend on prior SQL statements, and so they are also non-deterministic. The &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version()&lt;/a&gt; function is mostly constant, but it can change when SQLite is upgraded, and so even though it always returns the same answer for any particular session, because it can change answers across sessions it is still considered non-deterministic.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#random&quot;&gt;Случайная ()&lt;/a&gt; функция, очевидно , не детерминированной , поскольку он дает другой ответ каждый раз , когда она вызывается. Ответы от &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes ()&lt;/a&gt; и &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid ()&lt;/a&gt; зависят от предыдущих операторов SQL, поэтому они также недетерминированы. Функция &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_version ()&lt;/a&gt; в основном постоянна, но она может измениться при обновлении SQLite, и поэтому, хотя она всегда возвращает один и тот же ответ для любого конкретного сеанса, поскольку она может изменять ответы между сеансами, она по-прежнему считается недетерминированной.</target>
        </trans-unit>
        <trans-unit id="201a260c8bdbe59035cb4cd8dc3341936a60ec2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function requires a new interface on the B-tree storage engine, a new opcode in the &lt;a href=&quot;opcode&quot;&gt;virtual machine&lt;/a&gt; that runs SQL statements, and a new conditional in a critical path of the code generator. To avoid that overhead in applications that do not need the utility of sqlite_offset(X), the function is disabled by default.</source>
          <target state="translated">Для SQL-функции &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X)&lt;/a&gt; требуется новый интерфейс в механизме хранения B-дерева, новый код операции на &lt;a href=&quot;opcode&quot;&gt;виртуальной машине,&lt;/a&gt; которая выполняет операторы SQL, и новое условие в критическом пути генератора кода. Чтобы избежать этих накладных расходов в приложениях, которым не требуется утилита sqlite_offset (X), функция по умолчанию отключена.</target>
        </trans-unit>
        <trans-unit id="5130992bbae98a73266f7f76541f0aac8e1ee306" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; SQL function does not bother to measure the length its entire input string if it is only computing a prefix</source>
          <target state="translated">Функция SQL &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr ()&lt;/a&gt; не заботится об измерении длины всей входной строки, если она вычисляет только префикс.</target>
        </trans-unit>
        <trans-unit id="051b877cf20f31f8d1edc5b8d94b799ecd70ba91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; of a rowid table (if there is one) is usually not the true primary key for the table, in the sense that it is not the unique key used by the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine. The exception to this rule is when the rowid table declares an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. In the exception, the INTEGER PRIMARY KEY becomes an alias for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;ПЕРВИЧНЫЙ КЛЮЧ&lt;/a&gt; таблицы RowId (если таковой имеется), как правило , не является истинным первичным ключом для таблицы, в том смысле , что это не единственный ключ , используемый базовым &lt;a href=&quot;fileformat2#btree&quot;&gt;Б-дереве&lt;/a&gt; хранения двигателя. Исключением из этого правила является ситуация, когда таблица rowid объявляет &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; . В исключении INTEGER PRIMARY KEY становится псевдонимом для &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d236ba188ef88897dc53c50ffce983697148b3b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a rowid table can be accessed (or changed) by reading or writing to any of the &quot;rowid&quot; or &quot;oid&quot; or &quot;_rowid_&quot; columns. Except, if there is a declared columns in the table that use those special names, then those names refer to the declared columns, not to the underlying &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; из RowId таблиц может быть доступен (или изменен) путем считывания или записи на любой из &amp;laquo;ROWID&amp;raquo; или &amp;laquo;OID&amp;raquo; или &amp;laquo;_ROWID_&amp;raquo; столбцов. За исключением случаев, когда в таблице есть объявленные столбцы, которые используют эти специальные имена, тогда эти имена относятся к объявленным столбцам, а не к базовому &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатору строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57ebcd163f26bc17678c31c9203482eaa22d5842" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a table must be an integer. Attempt to set the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to anything other than an integer (or a NULL which will be automatically converted into the next available integer rowid) results in an SQLITE_MISMATCH error.</source>
          <target state="translated">Идентификатор &lt;a href=&quot;lang_createtable#rowid&quot;&gt;строки&lt;/a&gt; таблицы должен быть целым числом. Попытка установить для &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; значение, отличное от целого (или NULL, которое будет автоматически преобразовано в следующий доступный целочисленный rowid), приводит к ошибке SQLITE_MISMATCH.</target>
        </trans-unit>
        <trans-unit id="feca6ba206a41f2092893b9e83da76d7c569ae87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement now accepts an optional list of column names following the view name.</source>
          <target state="translated">Оператор &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; теперь принимает необязательный список имен столбцов, следующих за именем представления.</target>
        </trans-unit>
        <trans-unit id="140e631b88f462024e846431476301a80f59bb76" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_datefunc&quot;&gt;Date And Time Functions&lt;/a&gt; are enhanced so that the current time (ex: julianday('now')) is always the same for multiple function invocations within the same &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call.</source>
          <target state="translated">Функции &lt;a href=&quot;lang_datefunc&quot;&gt;даты и времени&lt;/a&gt; улучшены, поэтому текущее время (например, julianday ('now')) всегда одинаково для нескольких вызовов функций в одном вызове &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50e6d59e6b5b950615232d8af21bbe3ba88f948d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; SQL command is used to obtain a high-level description of the strategy or plan that SQLite uses to implement a specific SQL query. Most significantly, EXPLAIN QUERY PLAN reports on the way in which the query uses database indices. This document is a guide to understanding and interpreting the EXPLAIN QUERY PLAN output. Background information is available separately:</source>
          <target state="translated">&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; команда SQL используется для получения описания высокого уровня стратегии или плана , который использует SQLite для выполнения запроса конкретной SQL. Наиболее важно то, что EXPLAIN QUERY PLAN сообщает о том, как запрос использует индексы базы данных. Этот документ представляет собой руководство по пониманию и интерпретации вывода EXPLAIN QUERY PLAN. Справочная информация доступна отдельно:</target>
        </trans-unit>
        <trans-unit id="20275284a3bb298e3ed89b5acd684907f3305751" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; prefixes to SQL statements only affect the behavior of the statement during &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. That means that PRAGMA statements that take effect during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; will behave the same way regardless of whether or not they are prefaced by &quot;EXPLAIN&quot;.</source>
          <target state="translated">В &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; и &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; префиксы на заявления SQL влияют только на поведение во время заявления &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; . Это означает, что операторы PRAGMA, которые вступают в силу во время &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare (),&lt;/a&gt; будут вести себя одинаково, независимо от того, предваряется ли им &amp;laquo;EXPLAIN&amp;raquo; или нет.</target>
        </trans-unit>
        <trans-unit id="65133dc98116af2c7f0912fa88b4b43954bbc4b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator</source>
          <target state="translated">&lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; оператор</target>
        </trans-unit>
        <trans-unit id="0fa44fcf9bdf1d542216cc05466871344f55fb9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt;</source>
          <target state="translated">Оператор &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b92948d462015f78d114a35cb7f278e70f987a87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS operator&lt;/a&gt; is now able to drive indexes.</source>
          <target state="translated">Оператор &lt;a href=&quot;lang_expr#isisnot&quot;&gt;IS&lt;/a&gt; теперь может управлять индексами.</target>
        </trans-unit>
        <trans-unit id="b253f85844781796ef1ae81936dfc99cf231cc5a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_expr#like&quot;&gt;ESCAPE&lt;/a&gt; clause of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator now overrides wildcard characters, so that the behavior matches what PostgreSQL does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d7aaefd27d25ac767f490e47e6b7c9452f7e20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause</source>
          <target state="translated">&lt;a href=&quot;lang_indexedby&quot;&gt;Проиндексированных&lt;/a&gt; раздел</target>
        </trans-unit>
        <trans-unit id="2b3b6b4eb30c653aa6f7ff986fc3927d49da19df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command only works if the transaction stack is empty, or in other words if there are no pending transactions. If the transaction stack is not empty when the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command is invoked, then the command fails with an error.</source>
          <target state="translated">Команда &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; работает только в том случае, если стек транзакций пуст, или, другими словами, если нет ожидающих транзакций. Если при вызове команды &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; стек транзакции не пуст , команда завершается ошибкой.</target>
        </trans-unit>
        <trans-unit id="68024f72adbd8a0a422c4b54cc30c9ba1ec76d4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command commits all outstanding transactions and leaves the transaction stack empty.</source>
          <target state="translated">Команда &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; фиксирует все невыполненные транзакции и оставляет стек транзакций пустым.</target>
        </trans-unit>
        <trans-unit id="6b3d11e09f03993abe204e129a5f26dcc598fb68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command now succeeds even if there are pending queries. It returns &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are pending incremental BLOB I/O requests.</source>
          <target state="translated">Команда &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; теперь выполняется успешно, даже если есть ожидающие запросы. Он возвращает &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; если есть отложенные дополнительные запросы ввода-вывода BLOB.</target>
        </trans-unit>
        <trans-unit id="502339818ec9310f1093ba4d9556feff42c6ac87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command without a TO clause rolls backs all transactions and leaves the transaction stack empty.</source>
          <target state="translated">Команда &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; без предложения TO выполняет откат всех транзакций и оставляет стек транзакций пустым.</target>
        </trans-unit>
        <trans-unit id="22ed8eeff156b9ac5c3272aebc736d20e9be8ea0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements within triggers do not support the full syntax for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, and &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statements. The following restrictions apply:</source>
          <target state="translated">Операторы &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; и &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; в триггерах не поддерживают полный синтаксис операторов &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; и &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; . Действуют следующие ограничения:</target>
        </trans-unit>
        <trans-unit id="25fa7af4817ff50638a1d09b6077bfa20413eee0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command packs the database about 1% tighter.</source>
          <target state="translated">Команда &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; уплотняет базу данных примерно на 1%.</target>
        </trans-unit>
        <trans-unit id="6f6f65ccce3c60bd3538bde45dbba0bdabdce834" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command preserves the setting of the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt;. (Ticket #2804.)</source>
          <target state="translated">Команда &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; сохраняет настройку &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;прагмы legacy_file_format&lt;/a&gt; . (Билет №2804.)</target>
        </trans-unit>
        <trans-unit id="47212a8707d0f0bd1679c6ba64f918cc5f5c6039" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command works by creating a temporary file and then rebuilding the entire database into that temporary file. Then the content of the temporary file is copied back into the original database file and the temporary file is deleted.</source>
          <target state="translated">Команда &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; работает путем создания временного файла и последующего преобразования всей базы данных в этот временный файл. Затем содержимое временного файла копируется обратно в исходный файл базы данных, а временный файл удаляется.</target>
        </trans-unit>
        <trans-unit id="bdf2bbad9bfa5eb4a9865a13c14cd208bf3e40df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; clause must occur on the first SELECT of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt;. It cannot follow a &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt;.</source>
          <target state="translated">Предложение &lt;a href=&quot;lang_with&quot;&gt;WITH&lt;/a&gt; должно встречаться в первом SELECT &lt;a href=&quot;lang_select#compound&quot;&gt;составного SELECT&lt;/a&gt; . Он не может следовать за &lt;a href=&quot;syntax/compound-operator&quot;&gt;составным оператором&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db6f4f9f7ee46543ffd0410e2806fc648ca23245" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; creates a faster parser.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;Генератор парсер Лимонный&lt;/a&gt; создает более быстрый анализатор.</target>
        </trans-unit>
        <trans-unit id="a0ba7e4dcf6a75ed4b1ebb47695358df4a104180" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; documentation describes how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt; as shared libraries. The techniques described there work fine for the json1 module.</source>
          <target state="translated">Документация по &lt;a href=&quot;loadext&quot;&gt;загружаемым расширениям&lt;/a&gt; описывает, как &lt;a href=&quot;loadext#build&quot;&gt;компилировать загружаемые расширения&lt;/a&gt; как разделяемые библиотеки. Описанные здесь методы отлично подходят для модуля json1.</target>
        </trans-unit>
        <trans-unit id="01edd329b33f240dcc5cfa34ddb1e15eb22f3ff1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface writes a message into the &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt; established by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; option to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;. If logging is enabled, the zFormat string and subsequent arguments are used with &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to generate the final output string.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; записывает сообщение в &lt;a href=&quot;../errlog&quot;&gt;журнал ошибок,&lt;/a&gt; созданный параметром &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; для &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; . Если ведение журнала включено, строка zFormat и последующие аргументы используются с &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; для генерации окончательной выходной строки.</target>
        </trans-unit>
        <trans-unit id="4883693c0c81d8dd1cc3d7c0223f243712aeaf0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; is enhanced to support two separate memory pools with different sized allocations in each pool. This allows more memory allocations to be covered by lookaside while at the same time reducing the heap memory usage to 48KB per connection, down from 120KB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d8579383d45cb472d3a4833d1ee2e13e4c3902" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="translated">Дополнительный &lt;a href=&quot;malloc#lookaside&quot;&gt;распределитель памяти&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6272b90c1e46ccb51f6a211fb05dce0a9b88e6f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;malloc#pagecache&quot;&gt;Распределитель памяти кэша страниц&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2033aab7c928977e8c566f6458591e6094a394bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently outstanding (malloced but not freed). The &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; routine returns the maximum value of &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; since the high-water mark was last reset. The values returned by &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; include any overhead added by SQLite in its implementation of &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, but not overhead added by the any underlying system library routines that &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; may call.</source>
          <target state="translated">В &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; подпрограмма возвращает число байт памяти в настоящее время в обращении (malloced но не освобожденные). В &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; подпрограмма возвращает максимальное значение &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , так как знак высокой воды последнего сброс. Значения, возвращаемые &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; и &lt;a href=&quot;memory_highwater&quot;&gt;sqlite3_memory_highwater (),&lt;/a&gt; включают любые накладные расходы, добавленные SQLite в его реализацию &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , но не накладные расходы, добавленные любыми базовыми подпрограммами системной библиотеки, которые может вызывать &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54555d04b0b2355ea81551452a102d3dd5b8966e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; interface takes a single argument which is one of these integer constants.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; принимает единственный аргумент, который является одной из этих целочисленных констант.</target>
        </trans-unit>
        <trans-unit id="69f893d6e4ed45be57e659539245cae9d67b977d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; program created by the code generator is run by a virtual machine.</source>
          <target state="translated">Программа &lt;a href=&quot;opcode&quot;&gt;байт-кода,&lt;/a&gt; созданная генератором кода, запускается виртуальной машиной.</target>
        </trans-unit>
        <trans-unit id="6f82427ae6db3af3b60ee7889919a09e27176099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Delete&quot;&gt;Delete&lt;/a&gt; does the work of this loop; it pops an integer key off the stack (placed there by the preceding ListRead) and deletes the record of cursor P1 that has that key. Because P2 is true, the row change counter is incremented.</source>
          <target state="translated">&lt;a href=&quot;opcode#Delete&quot;&gt;Delete&lt;/a&gt; делает работу этого цикла; он извлекает из стека целочисленный ключ (помещенный туда предыдущим ListRead) и удаляет запись курсора P1, который имеет этот ключ. Поскольку P2 истинно, счетчик изменения строки увеличивается.</target>
        </trans-unit>
        <trans-unit id="49cbb2109ea61f54a2e0e215073c0e8f4e901d2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Ge&quot;&gt;Ge&lt;/a&gt; operator compares the top two elements on the stack, pops them, and then branches based on the result of the comparison. If the second element is &amp;gt;= the top element, then jump to address P2 (the Next instruction at the end of the loop). Because P1 is true, if either operand is NULL (and thus the result is NULL) then take the jump. If we don't jump, just advance to the next instruction.</source>
          <target state="translated">Оператор &lt;a href=&quot;opcode#Ge&quot;&gt;Ge&lt;/a&gt; сравнивает два верхних элемента в стеке, выталкивает их, а затем выполняет переход на основе результата сравнения. Если второй элемент&amp;gt; = верхний элемент, то перейдите к адресу P2 (инструкция Next в конце цикла). Поскольку P1 истинно, если любой из операндов равен NULL (и, следовательно, результат равен NULL), выполните переход. Если мы не перескочим, просто переходим к следующей инструкции.</target>
        </trans-unit>
        <trans-unit id="04783e2a879da777c9928b0ae80c86689e955e7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Gosub&quot;&gt;Gosub&lt;/a&gt; opcode stores the current program counter into register P1 then jumps to address P2. The &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; opcode jumps to address P1+1. Hence, every subroutine is associated with two integers: the address of the entry point in the subroutine and the register number that is used to hold the return address.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#Gosub&quot;&gt;Gosub&lt;/a&gt; сохраняет текущий счетчик программ в регистре P1, а затем переходит к адресу P2. Код операции &lt;a href=&quot;opcode#Return&quot;&gt;возврата&lt;/a&gt; переходит к адресу P1 + 1. Следовательно, каждая подпрограмма связана с двумя целыми числами: адресом точки входа в подпрограмме и номером регистра, который используется для хранения адреса возврата.</target>
        </trans-unit>
        <trans-unit id="cc4a6e0d461e428b5be9265ddcc51214a7a17162" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; jumps back to the beginning of the loop. This is the end of the loop.</source>
          <target state="translated">&lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; прыгает обратно к началу цикла. Это конец цикла.</target>
        </trans-unit>
        <trans-unit id="36b42b8529eed45ca4088e7606ce454bf579c098" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead&lt;/a&gt; instruction reads an element from the temporary storage list and pushes it onto the stack. If this was successful, it continues to the next instruction. If this fails because the list is empty, it branches to P2, which is the instruction just after the loop. Afterwards the stack looks like:</source>
          <target state="translated">&lt;a href=&quot;opcode#ListRead&quot;&gt;ListRead&lt;/a&gt; инструкция считывает элемент из списка , временного хранения и помещает его в стек. Если это было успешно, переходит к следующей инструкции. Если это не удается, потому что список пуст, он переходит к P2, который является инструкцией сразу после цикла. После этого стек выглядит так:</target>
        </trans-unit>
        <trans-unit id="4879ed312fe574048c51b739d2a2e0c47c1cf28a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset&lt;/a&gt; instruction empties the temporary storage list. This list is emptied automatically when the VDBE program terminates, so it isn't necessary in this case. The Close instruction closes the cursor P1. Again, this is done by the VDBE engine when it is finished running this program. The Commit ends the current transaction successfully, and causes all changes that occurred in this transaction to be saved to the database. The final Halt is also unnecessary, since it is added to every VDBE program when it is prepared to run.</source>
          <target state="translated">Команда &lt;a href=&quot;opcode#ListReset&quot;&gt;ListReset&lt;/a&gt; очищает список временного хранилища. Этот список очищается автоматически при завершении программы VDBE, поэтому в этом случае в этом нет необходимости. Команда Close закрывает курсор P1. Опять же, это выполняется механизмом VDBE, когда он завершает выполнение этой программы. Фиксация успешно завершает текущую транзакцию и приводит к тому, что все изменения, произошедшие в этой транзакции, сохраняются в базе данных. Последний Halt также не нужен, так как он добавляется к каждой программе VDBE, когда она готова к запуску.</target>
        </trans-unit>
        <trans-unit id="50c0b593163bf5647baef877e0e92b5b46f19553" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind&lt;/a&gt; instruction rewinds the temporary storage list to the beginning. This prepares it for use in the second loop.</source>
          <target state="translated">Команда &lt;a href=&quot;opcode#ListRewind&quot;&gt;ListRewind&lt;/a&gt; перематывает список временного хранилища в начало. Это подготавливает его к использованию во втором цикле.</target>
        </trans-unit>
        <trans-unit id="d684585d2e3d5fa36d7d1264c013ad5c814a5d30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; действителен только после кода операции &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; или &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind,&lt;/a&gt; используемого для позиционирования курсора. &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; не может следовать &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt; или &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4bec0991ede69ff0f5b657d6da948ae6ccecdc12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; instruction pops the top stack element and uses it as an integer key. If a record with that key does not exist in table P1, then jump to P2. If a record does exist, then fall through to the next instruction. In this case P2 takes us to the Goto at the end of the loop, which jumps back to the ListRead at the beginning. This could have been coded to have P2 be 16, the ListRead at the start of the loop, but the SQLite parser which generated this code didn't make that optimization.</source>
          <target state="translated">&lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; инструкция выталкивает элемент верхнего стека и использует его в качестве целого ключа. Если записи с этим ключом нет в таблице P1, перейдите к P2. Если запись действительно существует, переходите к следующей инструкции. В этом случае P2 переводит нас к Goto в конце цикла, который возвращается к ListRead в начале. Это могло быть закодировано так, чтобы P2 было 16, ListRead в начале цикла, но синтаксический анализатор SQLite, который сгенерировал этот код, не произвел такой оптимизации.</target>
        </trans-unit>
        <trans-unit id="1d15a242c00ad338da3936112e42488d3db597cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; opcode performs the same operation, but with &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; the P3 register must be guaranteed to contain an integer value. With this opcode, register P3 might not contain an integer.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; выполняет ту же операцию, но с &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; регистр P3 должен гарантированно содержать целочисленное значение. С этим кодом операции регистр P3 может не содержать целое число.</target>
        </trans-unit>
        <trans-unit id="2ea51892f8acadad179e6f2fd2f42516a5edf44d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; opcode performs the same operation on index btrees (with arbitrary multi-value keys).</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; выполняет ту же операцию с индексными b-деревьями (с произвольными многозначными ключами).</target>
        </trans-unit>
        <trans-unit id="066073395b0144e2fa69bed2cb062af29a031388" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcode is only valid following an &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt;, or &lt;a href=&quot;opcode#Last&quot;&gt;Last&lt;/a&gt; opcode used to position the cursor. &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; is not allowed to follow &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt;, &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt;, or &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; действителен только после кода операции &lt;a href=&quot;opcode#SeekLT&quot;&gt;SeekLT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekLE&quot;&gt;SeekLE&lt;/a&gt; или &lt;a href=&quot;opcode#Last&quot;&gt;Last,&lt;/a&gt; используемого для позиционирования курсора. &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; не может следовать &lt;a href=&quot;opcode#SeekGT&quot;&gt;SeekGT&lt;/a&gt; , &lt;a href=&quot;opcode#SeekGE&quot;&gt;SeekGE&lt;/a&gt; или &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7073f193fc700364fff65aec536137cac5241f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Recno&quot;&gt;Recno&lt;/a&gt; instruction pushes onto the stack an integer which is the first 4 bytes of the key to the current entry in a sequential scan of the table pointed to by cursor P1. The &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite&lt;/a&gt; instruction writes the integer on the top of the stack into a temporary storage list and pops the top element. This is the important work of this loop, to store the keys of the records to be deleted so we can delete them in the second loop. After this ListWrite instruction the stack is empty again.</source>
          <target state="translated">Команда &lt;a href=&quot;opcode#Recno&quot;&gt;Recno помещает&lt;/a&gt; в стек целое число, которое является первыми 4 байтами ключа текущей записи при последовательном сканировании таблицы, на которую указывает курсор P1. &lt;a href=&quot;opcode#ListWrite&quot;&gt;ListWrite&lt;/a&gt; инструкция записывает число на вершине стека в список временного хранения и выталкивает верхний элемент. Это важная работа этого цикла - сохранить ключи удаляемых записей, чтобы мы могли удалить их во втором цикле. После этой инструкции ListWrite стек снова пуст.</target>
        </trans-unit>
        <trans-unit id="ee3dc9b6c04eaf92dc7b817ad9cb3a0c30096f49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode may only be used with P5==0 or P5==OPFLAG_SEEKEQ and with P4 being a P4_KEYINFO object. Furthermore, the P3 value must be the same as every other &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; or &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; for the same cursor number.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; может использоваться только с P5 == 0 или P5 == OPFLAG_SEEKEQ и с P4, являющимся объектом P4_KEYINFO. Кроме того, значение Р3 должно быть таким же , как и любой другой &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; или &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; для того же самого числа курсора.</target>
        </trans-unit>
        <trans-unit id="f1b24140a6cba2cd01303fe562cef908cbaa8ca3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; opcode works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it first checks to see if the cursor on P1 is already open on the same b-tree and if it is this opcode becomes a no-op. In other words, if the cursor is already open, do not reopen it.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt; работает так же, как &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead,&lt;/a&gt; за исключением того, что сначала он проверяет, открыт ли уже курсор на P1 в том же b-дереве, и если это так, то этот код операции перестает работать . Другими словами, если курсор уже открыт, не открывайте его повторно.</target>
        </trans-unit>
        <trans-unit id="02cd685549e7ced789f6d67a2427e140b8a8620d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; opcode causes the bytecode engine to pause and the corresponding &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call to return &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;. Before invoking &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt;, the bytecoded program will have loaded the results for a single row of a query into a series of registers. C-language APIs such as &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int()&lt;/a&gt; or &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text()&lt;/a&gt; extract the query results from those registers. The bytecode engine resumes with the next instruction after the &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; on the next call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; заставляет обработчик байт-кода приостанавливаться, а соответствующий вызов &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; возвращает &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; . Перед &lt;a href=&quot;opcode#ResultRow&quot;&gt;вызовом ResultRow&lt;/a&gt; программа с байтовым кодом загрузит результаты для одной строки запроса в серию регистров. API-интерфейсы языка C, такие как &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_int ()&lt;/a&gt; или &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text (),&lt;/a&gt; извлекают результаты запроса из этих регистров. Механизм байт-кода возобновляет выполнение следующей инструкции после &lt;a href=&quot;opcode#ResultRow&quot;&gt;ResultRow&lt;/a&gt; при следующем вызове &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f2441406e5ac75bb5fd7cf1919c714faf20d6ab5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction initializes a loop that iterates over the &quot;examp&quot; table. It rewinds the cursor P1 to the first entry in its table. This is required by the Column and Next instructions, which use the cursor to iterate through the table. If the table is empty, then jump to P2 (10), which is the instruction just past the loop. If the table is not empty, fall through to the following instruction at 6, which is the beginning of the loop body.</source>
          <target state="translated">&lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; инструкция инициализирует цикл , который выполняет итерацию по таблице &amp;laquo;examp&amp;raquo;. Он перематывает курсор P1 на первую запись в своей таблице. Это требуется инструкциями Column и Next, которые используют курсор для итерации по таблице. Если таблица пуста, перейдите к P2 (10), который является инструкцией сразу после цикла. Если таблица не пуста, перейдите к следующей инструкции в 6, которая является началом тела цикла.</target>
        </trans-unit>
        <trans-unit id="2de14c27a6545978f9bf6b60627e8141b94b7884" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; opcode performs the same operation but also allows the P3 register to contain a non-integer value, in which case the jump is always taken. This opcode requires that P3 always contain an integer.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt; выполняет ту же операцию, но также позволяет регистру P3 содержать нецелочисленное значение, и в этом случае всегда выполняется переход. Этот код операции требует, чтобы P3 всегда содержал целое число.</target>
        </trans-unit>
        <trans-unit id="4b451f841c2d23194bca9774c72889abafce37d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; opcode swaps the value of the program counter with the integer value in register P1. This opcode is used to implement coroutines. Coroutines are often used to implement subqueries from which content is pulled on an as-needed basis.</source>
          <target state="translated">Код операции &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; меняет местами значение программного счетчика на целочисленное значение в регистре P1. Этот код операции используется для реализации сопрограмм. Сопрограммы часто используются для реализации подзапросов, из которых по мере необходимости извлекается контент.</target>
        </trans-unit>
        <trans-unit id="2bf8499185976fd90927b75af83cad8ae29ef209" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; optimization is now capable of generating a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; if that is appropriate.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;Автоматическая индексация&lt;/a&gt; оптимизация теперь способна генерировать &lt;a href=&quot;partialindex&quot;&gt;частичный индекс&lt;/a&gt; , если это необходимо.</target>
        </trans-unit>
        <trans-unit id="430bd4f8cb87deb1b045d791ee37f7bd1ef6a250" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt; is allowed to proceed even if the OR expression has also been converted into an IN expression. Uses of the OR optimization are now also &lt;a href=&quot;eqp#or-opt&quot;&gt;more clearly shown&lt;/a&gt; in the &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output.</source>
          <target state="translated">&lt;a href=&quot;optoverview#or_opt&quot;&gt;ИЛИ оптимизации&lt;/a&gt; позволяют протекать даже если OR выражение также преобразуется в выражение IN. Использование оптимизации OR теперь также &lt;a href=&quot;eqp#or-opt&quot;&gt;более четко показано&lt;/a&gt; в выходных данных &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9e2344b1a8686faee26008aaf6a744a538483c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt; PRAGMA auto_vacuum=incremental&lt;/a&gt; setting is now persistent.</source>
          <target state="translated">Параметр &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum = incremental&lt;/a&gt; теперь постоянен .</target>
        </trans-unit>
        <trans-unit id="80d34339badbc8db002db2288680cbe2b4fee1a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA compile_options&lt;/a&gt; command now attempts to show the version number of the compiler that generated the library.</source>
          <target state="translated">Команда &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;PRAGMA compile_options&lt;/a&gt; теперь пытается показать номер версии компилятора, создавшего библиотеку.</target>
        </trans-unit>
        <trans-unit id="e347c28fc2dc6a091d91c4397055e68e6edfd76f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;data_store_directory pragma&lt;/a&gt; should be avoided.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;Data_store_directory прагма&lt;/a&gt; может изменять эту переменную и вызвать его точку к памяти , полученной из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; . Кроме того, &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;прагма data_store_directory&lt;/a&gt; всегда предполагает, что любая строка, на которую указывает эта переменная, хранится в памяти, полученной из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc,&lt;/a&gt; и прагма может попытаться освободить эту память с помощью &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt; . Следовательно, если эта переменная изменяется напрямую, либо она должна быть сделана NULL, либо указывать на память, полученную из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc,&lt;/a&gt; в &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;противном&lt;/a&gt; случае следует избегать использования прагмы data_store_directory .</target>
        </trans-unit>
        <trans-unit id="dace9501e55329de3c436aaaf6d76500923f6803" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;PRAGMA defer_foreign_keys=ON&lt;/a&gt; statement now also disables &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;RESTRICT actions&lt;/a&gt; on foreign key.</source>
          <target state="translated">Оператор &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;PRAGMA defer_foreign_keys = ON&lt;/a&gt; теперь также отключает &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;действия RESTRICT&lt;/a&gt; для внешнего ключа.</target>
        </trans-unit>
        <trans-unit id="182946c7ddef87f825c408a1e9bcb94b2aebed4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; can be used to temporarily change all foreign key constraints to deferred regardless of how they are declared.</source>
          <target state="translated">В &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys Прагма&lt;/a&gt; может быть использована для временного изменения всех внешних ключей для будущих периодов , независимо от того, как они были объявлены.</target>
        </trans-unit>
        <trans-unit id="be06db32b407171ea5432f85af4fdd64982ffbf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;database encoding&lt;/a&gt; is UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f76b3a27760e9d216beb8e378b627c5a5752f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt; commands are now enabled in all builds by default. Disable them using &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_function_list&quot;&gt;ПРАГМА function_list&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;ПРАГМА module_list&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;Pragma pragma_list&lt;/a&gt; команда теперь включены во всех сборках по умолчанию. Отключите их с помощью &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;-DSQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="530eb5492fa66c41d47c216aab5658b932f1fde0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; pragmas are enhanced to provide information about the on-disk representation of &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_index_info&quot;&gt;Index_info&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo&lt;/a&gt; прагм увеличены , чтобы предоставить информацию о представлении на диске из &lt;a href=&quot;withoutrowid&quot;&gt;БЕЗ RowId&lt;/a&gt; таблиц.</target>
        </trans-unit>
        <trans-unit id="e422cf4cf15df880c393dd24dbfb049b1fcebe08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; is enhanced to detect out-of-order rowids.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;Integrity_check Прагма&lt;/a&gt; усиливается обнаружить испорченный ROWID'ы тех .</target>
        </trans-unit>
        <trans-unit id="2e10d900e5bf7e69cd4dd309e31da996954ece3c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is not OFF, MEMORY, or WAL</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;Journal_mode ПРАГМА&lt;/a&gt; не OFF, ПАМЯТЬ, или WAL</target>
        </trans-unit>
        <trans-unit id="c602efe807a207ac9abab9847aa84a66f50dd768" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; statement.</source>
          <target state="translated">Оператор &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = OFF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49dd3e21f049f6bfedb0b7b5b1043722f3e1e37c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; setting is enabled prior to invoking this method, and the value for legacy_alter_table is restored after this method finishes. This is necessary for the correct operation of virtual tables that make use of &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; where the shadow tables must be renamed to match the new virtual table name. If the legacy_alter_format is off, then the xConnect method will be invoked for the virtual table every time the xRename method tries to change the name of the shadow table.</source>
          <target state="translated">Параметр &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;legacy_alter_table PRAGMA&lt;/a&gt; включается до вызова этого метода, и значение legacy_alter_table восстанавливается после завершения этого метода. Это необходимо для правильной работы виртуальных таблиц, которые используют &lt;a href=&quot;vtab#xshadowname&quot;&gt;теневые таблицы,&lt;/a&gt; где теневые таблицы должны быть переименованы в соответствии с новым именем виртуальной таблицы. Если legacy_alter_format выключен, то метод xConnect будет вызываться для виртуальной таблицы каждый раз, когда метод xRename пытается изменить имя теневой таблицы.</target>
        </trans-unit>
        <trans-unit id="cd4d57758d0157882a76f0628926b46c59a64bbe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; is deactivated. It is now a no-op. In its place, the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is provided. The legacy_file_format pragma is deactivated because (1) it is rarely useful and (2) it is incompatible with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in schemas that have tables with both generated columns and descending indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6484e6ce678fffab&quot;&gt;6484e6ce678fffab&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb34969d518c763e5a52bf4853965875f5d7c504" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt; max_page_count PRAGMA&lt;/a&gt; can be used to raise or lower this limit at run-time.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;Max_page_count ПРАГМА&lt;/a&gt; может быть использован для увеличения или уменьшения этого предела во время выполнения.</target>
        </trans-unit>
        <trans-unit id="ed5ae39d1285e1f44b4d8e91bc72231ec08350d0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will never increase the amount of address space used for memory-mapped I/O above the hard limit set by the &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; compile-time option, nor the hard limit set start-time by the second argument to sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;)</source>
          <target state="translated">Оператор &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; никогда не увеличит объем адресного пространства, используемого для отображаемого в память ввода-вывода, выше жесткого предела, установленного параметром &lt;a href=&quot;compile#max_mmap_size&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_MAX_MMAP_SIZE , ни времени начала, установленного жестким ограничением вторым аргументом sqlite3_config ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3bccc6c555afb6a2715bad46795ba129af0dfe49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command was first introduced with SQLite 3.18.0 (2017-03-28) and is a no-op for all prior releases of SQLite.</source>
          <target state="translated">Команда &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; была впервые представлена ​​в SQLite 3.18.0 (2017-03-28) и не используется во всех предыдущих выпусках SQLite.</target>
        </trans-unit>
        <trans-unit id="ce8494947b4ce168119d270366337d52ae940b6c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command will automatically run ANALYZE on individual tables on an as-needed basis. The recommended practice is for applications to invoke the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; statement just before closing each database connection.</source>
          <target state="translated">Команда &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; автоматически запускает ANALYZE для отдельных таблиц по мере необходимости. Рекомендуется, чтобы приложения &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;вызывали&lt;/a&gt; оператор PRAGMA optimize непосредственно перед закрытием каждого соединения с базой данных.</target>
        </trans-unit>
        <trans-unit id="433dda316207c42123f3ff5f78471afdde0a76ae" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; is usually a no-op but it will occasionally run ANALYZE if it seems like doing so will be useful to the query planner. The &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;analysis_limit pragma&lt;/a&gt; limits the scope of any ANALYZE command that the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;optimize pragma&lt;/a&gt; runs so that it does not consume too many CPU cycles. The constant &quot;400&quot; can be adjusted as needed. Values between 100 and 1000 work well for most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb4e7b95d0d162ecc58614e1af3f3f6380ba85b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting is not OFF</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;Синхронная ПРАГМА&lt;/a&gt; установка не OFF</target>
        </trans-unit>
        <trans-unit id="7b30b153f5bd150efb6f72a306c286fdddb45c5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; has an integer value which also influences the decision of where to store temporary files. The values of the temp_store pragma have the following meanings:</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;Temp_store прагма&lt;/a&gt; имеет целочисленное значение , которое также влияет на решение о том, где хранить временные файлы. Значения прагмы temp_store имеют следующие значения:</target>
        </trans-unit>
        <trans-unit id="f4fb45c2bb944888554bf90c8cb9a47bf3f2a979" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; may modify this variable and cause it to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt;. Furthermore, the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; always assumes that any string that this variable points to is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; and the pragma may attempt to free that memory using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;. Hence, if this variable is modified directly, either it should be made NULL or made to point to memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; or else the use of the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; should be avoided. Except when requested by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, SQLite does not free the memory that sqlite3_temp_directory points to. If the application wants that memory to be freed, it must do so itself, taking care to only do so after all &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; objects have been destroyed.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;Temp_store_directory прагма&lt;/a&gt; может изменять эту переменную и вызвать его точку к памяти , полученной из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; . Кроме того, &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;прагма temp_store_directory&lt;/a&gt; всегда предполагает, что любая строка, на которую указывает эта переменная, хранится в памяти, полученной из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc,&lt;/a&gt; и прагма может попытаться освободить эту память с помощью &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt; . Следовательно, если эта переменная изменяется напрямую, либо она должна быть сделана NULL или указывать на память, полученную из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc,&lt;/a&gt; либо следует избегать использования &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;прагмы temp_store_directory&lt;/a&gt; . За исключением случаев, когда этого &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;требует прагма temp_store_directory&lt;/a&gt;, SQLite не освобождает память, на которую указывает sqlite3_temp_directory. Если приложение хочет освободить эту память, оно должно сделать это само, заботясь об этом только после того, как все объекты &lt;a href=&quot;#sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; будут уничтожены.</target>
        </trans-unit>
        <trans-unit id="b7aff6f6a70787230cfdaa84381a4df9ff6088c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; pragmas correctly set their column names in the result set</source>
          <target state="translated">В &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version&lt;/a&gt; и &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version&lt;/a&gt; псевдокомментарии правильно установить их имена столбцов в наборе результатов</target>
        </trans-unit>
        <trans-unit id="e69bec34ec00cc126a20d5db14b73449e907cdd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;Wal_autocheckpoint Прагма&lt;/a&gt; можно использовать для вызова этого интерфейса из SQL.</target>
        </trans-unit>
        <trans-unit id="dae72cb78cf83086aebe14bf09934eef63425e9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt; command can be used to invoke this interface from SQL.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;ПРАГМА wal_checkpoint&lt;/a&gt; команда может быть использована для вызова этого интерфейса из SQL.</target>
        </trans-unit>
        <trans-unit id="65a223c3d19041fa0b396d7e3f3b2e302f5459e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; statement.</source>
          <target state="translated">Оператор &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA Writable_schema = ON&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="684edbb611cbfa5623d7b600fa16d86090b5ff1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count(D)&lt;/a&gt; interface returns the number of columns in the row that is being inserted, updated, or deleted.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count (D)&lt;/a&gt; возвращает количество столбцов в строке, которая вставляется, обновляется или удаляется.</target>
        </trans-unit>
        <trans-unit id="ba2d35feb7b268110f32aac36c1f5d65016e60f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth(D)&lt;/a&gt; interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth (D)&lt;/a&gt; возвращает 0, если обратный вызов перед обновлением был вызван в результате прямой операции вставки, обновления или удаления; или 1 для вставок, обновлений или удалений, вызываемых триггерами верхнего уровня; или 2 для изменений, вызванных триггерами, вызванными триггерами верхнего уровня; и так далее.</target>
        </trans-unit>
        <trans-unit id="61dec61cb0cf17103a6811f56ba836ebb2ef7198" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interface registers a callback function that is invoked prior to each &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation on a database table. At most one preupdate hook may be registered at a time on a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; each call to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; overrides the previous setting. The preupdate hook is disabled by invoking &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; with a NULL pointer as the second parameter. The third parameter to &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; is passed through as the first parameter to callbacks.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; регистрирует функцию обратного вызова, которая вызывается перед каждой операцией &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; в таблице базы данных. В лучшем случае один preupdate крючок может быть зарегистрирован в то время , на одном &lt;a href=&quot;sqlite3&quot;&gt;соединении с базой данных&lt;/a&gt; ; каждый вызов &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; отменяет предыдущую настройку. Ловушка preupdate отключается путем вызова &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; с указателем NULL в качестве второго параметра. Третий параметр &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; передается в качестве первого параметра обратным вызовам.</target>
        </trans-unit>
        <trans-unit id="8df93bf8497a2d78f6914976e1609ba432170056" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row after it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE preupdate callbacks; if it is used by an SQLITE_DELETE callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new (D, N, P)&lt;/a&gt; записывает в P указатель на &lt;a href=&quot;value&quot;&gt;защищенное значение sqlite3_value,&lt;/a&gt; которое содержит значение N-го столбца строки таблицы после его обновления. Параметр N должен быть между 0 и на единицу меньше количества столбцов, иначе поведение будет неопределенным. Это должно использоваться только в обратных вызовах SQLITE_INSERT и SQLITE_UPDATE перед обновлением; если он используется обратным вызовом SQLITE_DELETE, то поведение не определено. Значение &lt;a href=&quot;value&quot;&gt;sqlite3_value, на&lt;/a&gt; которое указывает P, будет уничтожено при возврате обратного вызова preupdate.</target>
        </trans-unit>
        <trans-unit id="aeb8933cda6d990d1669eb3665d8053606aee0ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new()&lt;/a&gt;, &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count()&lt;/a&gt;, and &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth()&lt;/a&gt; interfaces provide additional information about a preupdate event. These routines may only be called from within a preupdate callback. Invoking any of these routines from outside of a preupdate callback or with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old ()&lt;/a&gt; , &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_new ()&lt;/a&gt; , &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_count ()&lt;/a&gt; и &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_depth ()&lt;/a&gt; предоставляют дополнительную информацию о событии preupdate. Эти подпрограммы можно вызывать только из обратного вызова перед обновлением. Вызов любой из этих подпрограмм вне функции обратного вызова перед обновлением или с указателем &lt;a href=&quot;sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных, который отличается от указателя, предоставленного для обратного вызова перед обновлением, приводит к неопределенному и, вероятно, нежелательному поведению.</target>
        </trans-unit>
        <trans-unit id="dd30234761e0c7ea9f1053536a7bfab89c37bb25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old(D,N,P)&lt;/a&gt; interface writes into P a pointer to a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; that contains the value of the Nth column of the table row before it is updated. The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE preupdate callbacks; if it is used by an SQLITE_INSERT callback then the behavior is undefined. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; that P points to will be destroyed when the preupdate callback returns.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_old (D, N, P)&lt;/a&gt; записывает в P указатель на &lt;a href=&quot;value&quot;&gt;защищенное значение sqlite3_value,&lt;/a&gt; которое содержит значение N-го столбца строки таблицы до его обновления. Параметр N должен быть между 0 и на единицу меньше количества столбцов, иначе поведение будет неопределенным. Это должно использоваться только в обратных вызовах SQLITE_UPDATE и SQLITE_DELETE перед обновлением; если он используется обратным вызовом SQLITE_INSERT, то поведение не определено. Значение &lt;a href=&quot;value&quot;&gt;sqlite3_value, на&lt;/a&gt; которое указывает P, будет уничтожено при возврате обратного вызова preupdate.</target>
        </trans-unit>
        <trans-unit id="6f6dd20be85a6ee9376cfe67d011732f51298a56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;queryplanner-ng&quot;&gt;Запроса планировщик следующего поколения&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0815af1640f3451efe07a076fe65835b297a94b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt; describes steps that application developers should following to help resolve query planner problems. Notice the that the use of INDEXED BY is a last resort, to be used only when all other measures fail.</source>
          <target state="translated">Контрольный &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;список планировщика запросов&lt;/a&gt; описывает шаги, которые разработчики приложений должны выполнить, чтобы решить проблемы планировщика запросов. Обратите внимание на то, что использование INDEXED BY - это последнее средство, которое следует использовать только тогда, когда все другие меры не работают.</target>
        </trans-unit>
        <trans-unit id="0c1b5fdf8ac1234008ffa858abbdb051486a832c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; extended error code is returned in WAL mode when a read transaction cannot be upgraded to a write transaction because the read is on an older snapshot.</source>
          <target state="translated">&lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; расширенного код ошибки возвращается в режиме WAL , когда транзакция чтения не может быть повышена до операции записи , так как чтение на старом снимке.</target>
        </trans-unit>
        <trans-unit id="a55e40d30155becf01edc33f7916ec42f8c15006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface does not change the values of any &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; on the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; не изменяет значения каких-либо &lt;a href=&quot;bind_blob&quot;&gt;привязок&lt;/a&gt; в &lt;a href=&quot;stmt&quot;&gt;подготовленном операторе&lt;/a&gt; S.</target>
        </trans-unit>
        <trans-unit id="3841b0084bc10aa5540a5c6c5c96fb98131e7bf0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; interface resets the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S back to the beginning of its program.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; сбрасывает &lt;a href=&quot;stmt&quot;&gt;подготовленный оператор&lt;/a&gt; S обратно в начало своей программы.</target>
        </trans-unit>
        <trans-unit id="540e7b1566721b5eeac705b77c4d701d37c07cab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; returns this result code when an attempt is made to update the R-Tree while another prepared statement is actively reading the R-Tree. The update cannot proceed because any change to an R-Tree might involve reshuffling and rebalancing of nodes, which would disrupt read cursors, causing some rows to be repeated and other rows to be omitted.</source>
          <target state="translated">Расширение &lt;a href=&quot;rtree&quot;&gt;R-Tree&lt;/a&gt; возвращает этот код результата, когда делается попытка обновить R-Tree, когда другой подготовленный оператор активно читает R-Tree. Обновление не может быть продолжено, потому что любое изменение R-дерева может включать перестановку и перебалансировку узлов, что нарушит работу курсоров чтения, в результате чего некоторые строки будут повторяться, а другие строки будут пропущены.</target>
        </trans-unit>
        <trans-unit id="b4b6d7c356a19c81f66c0c808b762014df51dab6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; supports shared-cache read and write locks in the same way as all other database tables (see description above). The following special rules also apply:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7707f3c0dce0c68c0fd1c390c4bccf3ca9ffcb57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API is called to create and initialize an iterator to iterate through the contents of a changeset. Initially, the iterator points to no element at all.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;Sqlite3changeset_start ()&lt;/a&gt; API вызывается для создания и инициализации итератор для перебора содержимого ревизией. Первоначально итератор вообще не указывает ни на один элемент.</target>
        </trans-unit>
        <trans-unit id="e2c05e642dac6053ce210738d48ce79ebc45ba34" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;authorizer callback function&lt;/a&gt; must return either &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or one of these two constants in order to signal SQLite whether or not the action is permitted. See the &lt;a href=&quot;set_authorizer&quot;&gt;authorizer documentation&lt;/a&gt; for additional information.</source>
          <target state="translated">Функция &lt;a href=&quot;set_authorizer&quot;&gt;обратного вызова авторизатора&lt;/a&gt; должна возвращать либо &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK,&lt;/a&gt; либо одну из этих двух констант, чтобы сигнализировать SQLite, разрешено действие или нет. Дополнительную информацию см. В &lt;a href=&quot;set_authorizer&quot;&gt;документации авторизатора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b9f192cd368c894585cf856c53081dab4346439" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface registers a callback function that is invoked to authorize certain SQL statement actions. The second parameter to the callback is an integer code that specifies what action is being authorized. These are the integer action codes that the authorizer callback may be passed.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; регистрирует функцию обратного вызова, которая вызывается для авторизации определенных действий оператора SQL. Второй параметр обратного вызова - это целочисленный код, указывающий, какое действие разрешается. Это целочисленные коды действий, которые может быть передан обратному вызову авторизатора.</target>
        </trans-unit>
        <trans-unit id="c88888932989847ef34ae0441a4a296cbf9342ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object returned from a successful call to &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; must be freed using &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; to avoid a memory leak.</source>
          <target state="translated">Объект &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; возвращенный в результате успешного вызова &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get (),&lt;/a&gt; должен быть освобожден с помощью &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free (),&lt;/a&gt; чтобы избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="334527e56ba0a296ee1d1034ee6898a348187ebd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="41f028c2f95ad413ccf78f4f0e636bf684908330" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free(P)&lt;/a&gt; interface destroys &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. The application must eventually free every &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object using this routine to avoid a memory leak.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;snapshot_free&quot;&gt;sqlite3_snapshot_free (P)&lt;/a&gt; уничтожает &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; P. В конечном итоге приложение должно освободить каждый объект &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; используя эту процедуру, чтобы избежать утечки памяти.</target>
        </trans-unit>
        <trans-unit id="b60983fe9853f804b509f3ca97ea438091fe792b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="f3e22e1c7c111b00a70790db9ce08d967e255fcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface attempts to make a new &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object that records the current state of schema S in database connection D. On success, the &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get(D,S,P)&lt;/a&gt; interface writes a pointer to the newly created &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object into *P and returns SQLITE_OK. If there is not already a read-transaction open on schema S when this function is called, one is opened automatically.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; пытается создать новый объект &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot,&lt;/a&gt; который записывает текущее состояние схемы S в соединении с базой данных D. В случае успеха интерфейс &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get (D, S, P)&lt;/a&gt; записывает указатель на вновь созданный &lt;a href=&quot;snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; в * P и возвращает SQLITE_OK. Если при вызове этой функции в схеме S еще не открыта транзакция чтения, она открывается автоматически.</target>
        </trans-unit>
        <trans-unit id="086ca737ecffa34122715fb37e08e08253d88ee7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface is only available when the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; доступен только при использовании &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;параметра времени&lt;/a&gt; компиляции SQLITE_ENABLE_SNAPSHOT .</target>
        </trans-unit>
        <trans-unit id="511890649947f63b55f8621e1cda37e48d68f4cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open(D,S,P)&lt;/a&gt; interface either starts a new read transaction or upgrades an existing one for schema S of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D such that the read transaction refers to historical &lt;a href=&quot;snapshot&quot;&gt;snapshot&lt;/a&gt; P, rather than the most recent change to the database. The &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface returns SQLITE_OK on success or an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if it fails.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open (D, S, P)&lt;/a&gt; либо запускает новую транзакцию чтения, либо обновляет существующую для схемы S &lt;a href=&quot;sqlite3&quot;&gt;подключения к базе данных&lt;/a&gt; D, так что транзакция чтения относится к историческому &lt;a href=&quot;snapshot&quot;&gt;снимку&lt;/a&gt; P, а не к самому последнему изменению в базе данных. Интерфейс &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; возвращает SQLITE_OK в случае успеха или соответствующий &lt;a href=&quot;../rescode&quot;&gt;код ошибки в&lt;/a&gt; случае неудачи.</target>
        </trans-unit>
        <trans-unit id="4cef92cfdf633fc0c634b624e8f2e6727a6b4196" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension allows the application to optionally specify the rowid for each INSERT.</source>
          <target state="translated">Расширение &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; позволяет приложению дополнительно указывать идентификатор строки для каждого INSERT.</target>
        </trans-unit>
        <trans-unit id="d837c3195216596d022a1ac6dfae8f94ace29826" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function can also be selected or deselected at run-time by inserting an appropriate string into the &quot;command&quot; column of the virtual table:</source>
          <target state="translated">&lt;a href=&quot;spellfix1#editdist3&quot;&gt;Editdist3 ()&lt;/a&gt; функцию редактирования расстояния также можно выбрать или отменить во время выполнения посредством вставки соответствующей строки в столбец &amp;laquo;команды&amp;raquo; из виртуальной таблицы:</target>
        </trans-unit>
        <trans-unit id="832a2975224a148de7d49b3ae21cbf638061bcda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; idea shows how SQLite can be used as a substitute for ZIP archives or Tarballs. An archive of files stored in SQLite is only very slightly larger, and in some cases actually smaller, than the equivalent ZIP archive. And an SQLite archive features incremental and atomic updating and the ability to store much richer metadata.</source>
          <target state="translated">В &lt;a href=&quot;sqlar&quot;&gt;SQLite Архив&lt;/a&gt; идея показывает , как SQLite могут быть использованы в качестве замены для ZIP архивов или тарболах. Архив файлов, хранящихся в SQLite, лишь немного больше, а в некоторых случаях даже меньше, чем эквивалентный архив ZIP. А архив SQLite имеет инкрементное и атомарное обновление, а также возможность хранить гораздо более обширные метаданные.</target>
        </trans-unit>
        <trans-unit id="e695129653037caa8407461dbbd9ea2a46762ce1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pointer D in a call to &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt(D,S)&lt;/a&gt; must refer to an open database connection and in particular must not be a NULL pointer.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;Подключение к базе данных&lt;/a&gt; указателя D в вызове &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt (D, S)&lt;/a&gt; должен относиться к соединению с открытой базой данных и , в частности , не должны быть указателем NULL.</target>
        </trans-unit>
        <trans-unit id="48a912a810b3a28ec149be0106a75289dbfa6333" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append(X,S,N)&lt;/a&gt; method appends exactly N bytes from string S onto the end of the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. N must be non-negative. S must contain at least N non-zero bytes of content. To append a zero-terminated string in its entirety, use the &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall()&lt;/a&gt; method instead.</source>
          <target state="translated">Метод &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_append (X, S, N)&lt;/a&gt; добавляет ровно N байтов из строки S в конец объекта &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; X. N должно быть неотрицательным. S должен содержать не менее N ненулевых байтов содержимого. Чтобы добавить строку с нулевым символом в конце, используйте вместо этого метод &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fad1c80b91150cb25ef6b94b5eb5de73c5d25b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall(X,S)&lt;/a&gt; method appends the complete content of zero-terminated string S onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">Метод &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendall (X, S)&lt;/a&gt; добавляет полное содержимое строки S с нулевым завершением в конец объекта &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; X.</target>
        </trans-unit>
        <trans-unit id="b0fd412f541ab2a0f3d35988066ed4e8e4128c77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar(X,N,C)&lt;/a&gt; method appends N copies of the single-byte character C onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. This method can be used, for example, to add whitespace indentation.</source>
          <target state="translated">Метод &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendchar (X, N, C)&lt;/a&gt; добавляет N копий однобайтового символа C в конец объекта &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; X. Этот метод можно использовать, например, для добавления отступа между пробелами.</target>
        </trans-unit>
        <trans-unit id="8a49ade027432cc3ca56bc0bb1633c34a874ad30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf(X,F,...)&lt;/a&gt; and &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf(X,F,V)&lt;/a&gt; interfaces uses the &lt;a href=&quot;../printf&quot;&gt;built-in printf&lt;/a&gt; functionality of SQLite to append formatted text onto the end of &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X.</source>
          <target state="translated">Интерфейсы &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf (X, F, ...)&lt;/a&gt; и &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_vappendf (X, F, V)&lt;/a&gt; используют &lt;a href=&quot;../printf&quot;&gt;встроенные функции printf&lt;/a&gt; SQLite для добавления форматированного текста в конец объекта &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; X.</target>
        </trans-unit>
        <trans-unit id="8207628b57fa2acb2222184f79be191c7783d2ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset(X)&lt;/a&gt; method resets the string under construction inside &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X back to zero bytes in length.</source>
          <target state="translated">Метод &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_reset (X)&lt;/a&gt; сбрасывает строящуюся строку внутри объекта &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; X обратно до нулевой длины в байтах.</target>
        </trans-unit>
        <trans-unit id="3979188fa64e50e829929b1acf8c993dc30e5490" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; method returns the current length, in bytes, of the dynamic string under construction in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X. The length returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; does not include the zero-termination byte.</source>
          <target state="translated">Метод &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; возвращает текущую длину в байтах динамической строки, &lt;a href=&quot;str&quot;&gt;создаваемой в&lt;/a&gt; объекте sqlite3_str X. Длина, возвращаемая &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; , не включает байт нулевого завершения.</target>
        </trans-unit>
        <trans-unit id="94c6db74a667c1ebd14fbec47092019e01e83407" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; method returns a pointer to the current content of the dynamic string under construction in X. The value returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. Applications must not used the pointer returned &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; after any subsequent method call on the same object. Applications may change the content of the string returned by &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value(X)&lt;/a&gt; as long as they do not write into any bytes outside the range of 0 to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length(X)&lt;/a&gt; and do not read or write any byte after any subsequent sqlite3_str method call.</source>
          <target state="translated">Метод &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; возвращает указатель на текущее содержимое динамической строки, строящейся в X. Значение, возвращаемое &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; , управляется объектом sqlite3_str X и может быть освобождено или изменено любым последующим методом того же &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; объект. Приложения не должны использовать указатель, возвращаемый &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X)&lt;/a&gt; после любого последующего вызова метода для того же объекта. Приложения могут изменять содержимое строки, возвращаемой &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_value (X),&lt;/a&gt; при условии, что они не записывают ни в какие байты вне диапазона от 0 до &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length (X)&lt;/a&gt; и не читают и не записывают ни одного байта после любого последующего вызова метода sqlite3_str.</target>
        </trans-unit>
        <trans-unit id="7e06028d8d9a37c76976481d45631c9360b94773" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; that contains the constructed string. The calling application should pass the returned value to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; to avoid a memory leak. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface may return a NULL pointer if any errors were encountered during construction of the string. The &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt; interface will also return a NULL pointer if the string in &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object X is zero bytes long.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; уничтожает объект sqlite3_str X и возвращает указатель на буфер памяти, полученный из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 (),&lt;/a&gt; который содержит построенную строку. Вызывающее приложение должно передать возвращаемое значение в &lt;a href=&quot;free&quot;&gt;sqlite3_free (),&lt;/a&gt; чтобы избежать утечки памяти. Интерфейс &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; может вернуть указатель NULL, если во время построения строки были обнаружены какие-либо ошибки. Интерфейс &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; также вернет указатель NULL, если длина строки в объекте &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; X равна нулю байтов.</target>
        </trans-unit>
        <trans-unit id="893b46b38f797cff31c49b4ea957f7271c4d11b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface allocates and initializes a new &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object. To avoid memory leaks, the object returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt; must be freed by a subsequent call to &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; выделяет и инициализирует новый объект &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; . Чтобы избежать утечки памяти, объект, возвращаемый &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (),&lt;/a&gt; должен быть освобожден последующим вызовом &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c8f2751d83d7d253a00544efb010e3f4e128798b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; interface always returns a pointer to a valid &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object, though in the event of an out-of-memory error the returned object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM from &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode()&lt;/a&gt;, always return 0 for &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length()&lt;/a&gt;, and always return NULL from &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish(X)&lt;/a&gt;. It is always safe to use the value returned by &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; as the sqlite3_str parameter to any of the other &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; methods.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; всегда возвращает указатель на действительный объект &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; , хотя в случае ошибки нехватки памяти возвращаемый объект может быть специальным синглтоном, который будет молча отклонять новый текст, всегда возвращать SQLITE_NOMEM из &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode ()&lt;/a&gt; , всегда возвращать 0 для &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_length ()&lt;/a&gt; и всегда возвращать NULL из &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish (X)&lt;/a&gt; . Всегда безопасно использовать значение, возвращаемое &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D),&lt;/a&gt; в качестве параметра sqlite3_str для любого другого метода &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4893933da22367d13b4236043c7aa3ee536ea00a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern P. The definition of &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; pattern matching used in &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; is the same as for the &quot;X GLOB P&quot; operator in the SQL dialect understood by SQLite. The &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob(P,X)&lt;/a&gt; function is case sensitive.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; возвращает ноль тогда и только тогда, когда строка X совпадает с &lt;a href=&quot;../lang_expr#glob&quot;&gt;шаблоном GLOB&lt;/a&gt; P. Определение &lt;a href=&quot;../lang_expr#glob&quot;&gt;сопоставления с&lt;/a&gt; шаблоном GLOB, используемое в &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob (P, X),&lt;/a&gt; такое же, как и для оператора &amp;laquo;X GLOB P&amp;raquo; в Диалект SQL, понятный SQLite. Функция &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob (P, X)&lt;/a&gt; чувствительна к регистру.</target>
        </trans-unit>
        <trans-unit id="e174ba8e6223c998f458135f997fdab25603db49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt; APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of &quot;case independence&quot; that SQLite uses internally when comparing identifiers.</source>
          <target state="translated">&lt;a href=&quot;stricmp&quot;&gt;Sqlite3_stricmp ()&lt;/a&gt; и &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; API - интерфейсы позволяют приложения и расширения для сравнения содержимого двух буферов , содержащих UTF - 8 строк в случае независимым способом, используя такое же определение &amp;laquo;случая независимости&amp;raquo; , что SQLite использует внутренне при сравнении идентификаторов.</target>
        </trans-unit>
        <trans-unit id="f2f61b252192f444bf8f6f8d93e248db03a4d372" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function matches Unicode characters, though only ASCII characters are case folded.</source>
          <target state="translated">Функция &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; сопоставляет символы Unicode, но только символы ASCII складываются по регистру.</target>
        </trans-unit>
        <trans-unit id="8540813014d56ead7baf2b2daf047a27f8df8c32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; interface returns zero if and only if string X matches the &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern P with escape character E. The definition of &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern matching used in &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; is the same as for the &quot;X LIKE P ESCAPE E&quot; operator in the SQL dialect understood by SQLite. For &quot;X LIKE P&quot; without the ESCAPE clause, set the E parameter of &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; to 0. As with the LIKE operator, the &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike(P,X,E)&lt;/a&gt; function is case insensitive - equivalent upper and lower case ASCII characters match one another.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; возвращает ноль тогда и только тогда, когда строка X совпадает с &lt;a href=&quot;../lang_expr#like&quot;&gt;шаблоном LIKE&lt;/a&gt; P с escape-символом E. Определение сопоставления с образцом &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE,&lt;/a&gt; используемое в &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E),&lt;/a&gt; такое же, как и для Оператор &amp;laquo;X LIKE P ESCAPE E&amp;raquo; в диалекте SQL, понятном SQLite. Для &amp;laquo;X LIKE P&amp;raquo; без предложения ESCAPE установите для параметра E &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; значение 0. Как и в случае с оператором LIKE, функция &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike (P, X, E)&lt;/a&gt; нечувствительна к регистру - эквивалентно верхнему и Строчные символы ASCII соответствуют друг другу.</target>
        </trans-unit>
        <trans-unit id="4c4bc6f080bcb0613b19c8e24f2c8215e3263de6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; has been enhanced to use the &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;Non-Recursive Engine (NRE)&lt;/a&gt; interface to the TCL interpreter when linked against TCL 8.6 or later.</source>
          <target state="translated">&lt;a href=&quot;tclsqlite&quot;&gt;TCL интерфейс&lt;/a&gt; был усовершенствован для использования &lt;a href=&quot;http://www.tcl-lang.org/cgi-bin/tct/tip/322.html&quot;&gt;нерекурсивно двигатель (ЯРД)&lt;/a&gt; интерфейса для интерпретатора TCL при связывании с TCL 8.6 или более поздней версией.</target>
        </trans-unit>
        <trans-unit id="23310616ad13ff4bf64157f6f266be2fa9a80e64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer also does an excellent job of verifying that SQLite responds sanely to malformed database files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4e73f7d156e22fa7106d9f30fd3d58ff51bfbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;testing#slt&quot;&gt;SQL Logic Tests&lt;/a&gt; are a set of test cases designed to show that SQLite behaves the same as other SQL database engines. These tests are hosted in a separate code public repository.</source>
          <target state="translated">В &lt;a href=&quot;testing#slt&quot;&gt;тестах SQL логиков&lt;/a&gt; представляют собой набор тестов , предназначенных , чтобы показать , что SQLite ведет себя так же , как и другой СУБД SQL. Эти тесты размещены в отдельном публичном репозитории кода.</target>
        </trans-unit>
        <trans-unit id="5f65ab47a0f86c2f22ae6f2632075f4320a179c7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;th3&quot;&gt;Test Harness #3&lt;/a&gt; or &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test suite is a private set of test cases used to test SQLite to 100% MC/DC in an as-delivered configuration. TH3 sources are served on the same servers as the other SQLite repositories, but differ from the others in being proprietary. The TH3 code is only accessible to SQLite developers.</source>
          <target state="translated">&lt;a href=&quot;th3&quot;&gt;Тест жгут провода # 3&lt;/a&gt; или &lt;a href=&quot;th3&quot;&gt;ТН3&lt;/a&gt; тестовый набор является частным набора тестовых случаев используются для проверки SQLite до 100% MC / DC в качестве поставляемой-конфигурации. Источники TH3 обслуживаются на тех же серверах, что и другие репозитории SQLite, но отличаются от других тем, что являются собственностью. Код TH3 доступен только разработчикам SQLite.</target>
        </trans-unit>
        <trans-unit id="e8a696ccc2b635cda261283e62314013cf8db5a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes(D)&lt;/a&gt; interface only reports the number of rows that changed due to SQL statement run against database connection D. Any changes by other database connections are ignored. To detect changes against a database file from other database connections use the &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command or the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt;.</source>
          <target state="translated">Интерфейс &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes (D)&lt;/a&gt; сообщает только количество строк, которые изменились из-за выполнения оператора SQL для соединения с базой данных D. Любые изменения, сделанные другими соединениями с базой данных, игнорируются. Чтобы обнаружить изменения файла базы данных из других подключений к базе данных, используйте команду &lt;a href=&quot;../pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; или &lt;a href=&quot;file_control&quot;&gt;файловый элемент управления &lt;/a&gt;&lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f49c08b6ed161fe2560890c885dd50855619ba24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;uintcseq&quot;&gt;UINT collating sequence&lt;/a&gt; extension is automatically loaded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2803f974353bfc4cbf30a15e234d493460a39f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;versionnumbers&quot;&gt;version numbering conventions&lt;/a&gt; for SQLite are revised to use the emerging standard of &lt;a href=&quot;http://semver.org/&quot;&gt;semantic versioning&lt;/a&gt;.</source>
          <target state="translated">Соглашения о &lt;a href=&quot;versionnumbers&quot;&gt;нумерации версий&lt;/a&gt; для SQLite пересмотрены для использования развивающегося стандарта &lt;a href=&quot;http://semver.org/&quot;&gt;семантического управления версиями&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ca284a5c0b69f330d98de127457542bdad0ece1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16) adds a new device characteristic named &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt;. Database files that report this characteristic are assumed to reside on storage systems that have the powersafe overwrite property. The default unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now report &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; if SQLite is compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=1&lt;/a&gt; or they make the legacy assumption that storage does not have the powersafe overwrite property if compiled with &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE=0&lt;/a&gt;. For now, the default is for powersafe overwrite to be turned on, though we may revisit this in the future and default it off.</source>
          <target state="translated">В &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; для SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;версии 3.7.10&lt;/a&gt; (2012-01-16) добавляет новую характеристику устройства под названием &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; . Предполагается, что файлы базы данных, которые сообщают об этой характеристике, находятся в системах хранения, которые имеют свойство перезаписи в режиме powerafe. &lt;a href=&quot;vfs&quot;&gt;VFS по&lt;/a&gt; умолчанию для unix и windows теперь сообщают о &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE,&lt;/a&gt; если SQLite скомпилирован с &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 1&lt;/a&gt; или они исходят из предположения, что хранилище не имеет свойства перезаписи в режиме PowerSafe, если оно скомпилировано с &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;-DSQLITE_POWERSAFE_OVERWRITE = 0&lt;/a&gt; . На данный момент по умолчанию включена функция перезаписи в режиме энергосбережения, хотя мы можем вернуться к этому вопросу в будущем и выключить его по умолчанию.</target>
        </trans-unit>
        <trans-unit id="28df118ed088f75e95fa60751c2ccab88df9bbf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method in the implementation of this table checks for equality constraints against the HIDDEN columns, and uses those as input parameters to determine the range of integer &quot;value&quot; outputs to generate. Reasonable defaults are used for any unconstrained columns. For example, to list all integers between 5 and 50:</source>
          <target state="translated">Метод &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; в реализации этой таблицы проверяет ограничения равенства для столбцов HIDDEN и использует их в качестве входных параметров для определения диапазона выходных целочисленных &amp;laquo;значений&amp;raquo; для генерации. Разумные значения по умолчанию используются для любых неограниченных столбцов. Например, чтобы перечислить все целые числа от 5 до 50:</target>
        </trans-unit>
        <trans-unit id="e9cea685ebbde84bdb5186b0eb1062c8517be452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and is not checked again by SQLite.</source>
          <target state="translated">Метод &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; должен заполнить aConstraintUsage [] информацией о том, какие параметры передать в xFilter. Если argvIndex&amp;gt; 0, тогда правая часть соответствующего aConstraint [] оценивается и становится записью argvIndex-й в argv. Если aConstraintUsage []. Omit истинно, то предполагается, что ограничение полностью обрабатывается виртуальной таблицей и не проверяется SQLite снова.</target>
        </trans-unit>
        <trans-unit id="f8ae1ca39afc04ccf6f18ad86632ba85cedd64de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method must fill aConstraintUsage[] with information about what parameters to pass to xFilter. If argvIndex&amp;gt;0 then the right-hand side of the corresponding aConstraint[] is evaluated and becomes the argvIndex-th entry in argv. If aConstraintUsage[].omit is true, then the constraint is assumed to be fully handled by the virtual table and might not be checked again by the byte code. The aConstraintUsage[].omit flag is an optimization hint. When the omit flag is left in its default setting of false, the constraint will always be checked separately in byte code. If the omit flag is change to true, then the constraint may or may not be checked in byte code. In other words, when the omit flag is true there is no guarantee that the constraint will not be checked again using byte code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b191bb31eb6d4e8bdeb7b48904acffd3c2dfc6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; methods of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.</source>
          <target state="translated">В &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; и &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; методы в &lt;a href=&quot;#sqlite3_module&quot;&gt;модуле виртуальной таблицы&lt;/a&gt; называют этот интерфейс , чтобы объявить формат (имена и типы данных столбцов) из виртуальных таблиц , которые они реализуют.</target>
        </trans-unit>
        <trans-unit id="d6feb2481a619b82b0e2f46a25f49c2e66551dca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method is called whenever a database connection that uses a virtual table is closed. The xDestroy method is only called when a &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement is executed against the virtual table.</source>
          <target state="translated">Метод &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; вызывается всякий раз, когда закрывается соединение с базой данных, использующее виртуальную таблицу. Метод xDestroy вызывается только тогда, когда для виртуальной таблицы выполняется инструкция &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0ce4af06185c37b128ad21eebbd21f3f9ac244" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method was originally designed around having a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; as a single value. The &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method has been expanded to accommodate an arbitrary PRIMARY KEY in place of the ROWID, but the PRIMARY KEY must still be only one column. For this reason, SQLite will reject any WITHOUT ROWID virtual table that has more than one PRIMARY KEY column and a non-NULL xUpdate method.</source>
          <target state="translated">&lt;a href=&quot;vtab#xupdate&quot;&gt;XUpdate&lt;/a&gt; метод был первоначально разработан вокруг , имеющий &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; как одно значение. Метод &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; был расширен для размещения произвольного PRIMARY KEY вместо ROWID, но PRIMARY KEY по-прежнему должен быть только одним столбцом. По этой причине SQLite отклонит любую виртуальную таблицу БЕЗ ROWID, которая имеет более одного столбца PRIMARY KEY и метод xUpdate, отличный от NULL.</target>
        </trans-unit>
        <trans-unit id="e8e22d8d27e272cb6edbc57854c2655aac986253" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal#advantages&quot;&gt;second advantage of WAL-mode&lt;/a&gt; is that writers do not block readers and readers to do not block writers. This is &lt;u&gt;mostly&lt;/u&gt; true. But there are some obscure cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, so applications should be prepared for that happenstance.</source>
          <target state="translated">&lt;a href=&quot;wal#advantages&quot;&gt;Второе преимущество WAL режима&lt;/a&gt; является то , что писатели не блокируют читателей и читателей не блокируют писателей. В &lt;u&gt;основном это&lt;/u&gt; правда. Но есть несколько неясных случаев, когда запрос к базе данных в режиме WAL может возвращать &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; , поэтому приложения должны быть готовы к такой случайности.</target>
        </trans-unit>
        <trans-unit id="73dd67efef2f2aca70b69d53d116d51359c36e68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint(D,N)&lt;/a&gt; is a wrapper around &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; that causes any database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to automatically &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; after committing a transaction if there are N or more frames in the &lt;a href=&quot;../wal&quot;&gt;write-ahead log&lt;/a&gt; file. Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.</source>
          <target state="translated">&lt;a href=&quot;wal_autocheckpoint&quot;&gt;Sqlite3_wal_autocheckpoint (D, N)&lt;/a&gt; является оберткой &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; , что приводит к любой базе данных на &lt;a href=&quot;sqlite3&quot;&gt;базу данных соединения&lt;/a&gt; D автоматически &lt;a href=&quot;../wal#ckpt&quot;&gt;контрольную точку&lt;/a&gt; после совершения сделки , если есть N или больше кадров в &lt;a href=&quot;../wal&quot;&gt;записи вперед лог&lt;/a&gt; - файле. Передача нуля или отрицательного значения в качестве параметра nFrame полностью отключает автоматические контрольные точки.</target>
        </trans-unit>
        <trans-unit id="70220a93d132293d087792692e0745eaa50f6944" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; function is used to register a callback that is invoked each time data is committed to a database in wal mode.</source>
          <target state="translated">Функция &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; используется для регистрации обратного вызова, который вызывается каждый раз, когда данные фиксируются в базе данных в режиме wal.</target>
        </trans-unit>
        <trans-unit id="82c4cc754894816f7c5238173cc6918a40c6ae4d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#locks&quot;&gt;WAL-mode locks&lt;/a&gt; are described above.</source>
          <target state="translated">В &lt;a href=&quot;walformat#locks&quot;&gt;WAL-режим блокировки&lt;/a&gt; описаны выше.</target>
        </trans-unit>
        <trans-unit id="2815c286729fb6fca3fa728a7812f5c530ea71ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; is implemented using an ordinary file that is mmapped for robustness. Early (pre-release) implementations of WAL mode stored the wal-index in volatile shared-memory, such as files created in /dev/shm on Linux or /tmp on other unix systems. The problem with that approach is that processes with a different root directory (changed via &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;) will see different files and hence use different shared memory areas, leading to database corruption. Other methods for creating nameless shared memory blocks are not portable across the various flavors of unix. And we could not find any method to create nameless shared memory blocks on windows. The only way we have found to guarantee that all processes accessing the same database file use the same shared memory is to create the shared memory by mmapping a file in the same directory as the database itself.</source>
          <target state="translated">&lt;a href=&quot;walformat#shm&quot;&gt;Валь-индекс&lt;/a&gt; реализуется с помощью обычного файла , который mmapped для надежности. Ранние (предварительные) реализации режима WAL сохраняли wal-index в энергозависимой разделяемой памяти, например в файлах, созданных в / dev / shm в Linux или / tmp в других системах Unix. Проблема с этим подходом заключается в том, что процессы с другим корневым каталогом (измененным через &lt;a href=&quot;http://en.wikipedia.org/wiki/Chroot&quot;&gt;chroot&lt;/a&gt;) будут видеть разные файлы и, следовательно, использовать разные области общей памяти, что приведет к повреждению базы данных. Другие методы создания безымянных блоков разделяемой памяти не переносятся между различными разновидностями unix. И мы не смогли найти никакого метода для создания безымянных блоков разделяемой памяти в Windows. Единственный найденный нами способ гарантировать, что все процессы, обращающиеся к одному и тому же файлу базы данных, используют одну и ту же общую память, - это создать общую память путем сопоставления файла в том же каталоге, что и сама база данных.</target>
        </trans-unit>
        <trans-unit id="e0f2b794ee3e27ce7edc3429510c9bf44ed6503d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;whentouse#website&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; page says that dynamic pages on the SQLite website typically do about 200 SQL statements each. This has provoked criticism from readers. Examples:</source>
          <target state="translated">На странице &amp;laquo; &lt;a href=&quot;whentouse#website&quot;&gt;Соответствующее использование для SQLite&amp;raquo;&lt;/a&gt; говорится, что динамические страницы на веб-сайте SQLite обычно выполняют около 200 операторов SQL каждая. Это вызвало критику со стороны читателей. Примеры:</target>
        </trans-unit>
        <trans-unit id="edb12d8d86687eb25304ab545c4bdc2adb558bbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; can read and write a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;zipfile&quot;&gt;Виртуальная таблица ZipFile&lt;/a&gt; может читать и писать &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP архива&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d23698ad6db1bcbbe81ce38782af791870223128" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 26.9 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1264 files totaling 20.5MB in size. There are 44792 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="translated">В &lt;b id=&quot;tcl&quot;&gt;тестах TCL&lt;/b&gt; являются старейшем набором тестов для SQLite. Они содержатся в том же исходном дереве, что и ядро ​​SQLite, и, как и ядро ​​SQLite, находятся в общественном достоянии. Тесты TCL - это основные тесты, используемые во время разработки. Тесты TCL написаны с использованием &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;языка сценариев TCL&lt;/a&gt; . Сама тестовая программа TCL состоит из 26,9 KSLOC кода C, используемого для создания интерфейса TCL. Сценарии тестирования содержатся в 1264 файлах общим размером 20,5 МБ. Существует 44792 различных тестовых примера, но многие из них параметризованы и запускаются несколько раз (с разными параметрами), так что при полном тестовом прогоне выполняются миллионы отдельных тестов.</target>
        </trans-unit>
        <trans-unit id="1ec2f6c6133a8488b1cdbdaeca80a7abf2b8d280" translate="yes" xml:space="preserve">
          <source>The &lt;b id=&quot;tcl&quot;&gt;TCL Tests&lt;/b&gt; are the oldest set of tests for SQLite. They are contained in the same source tree as the SQLite core and like the SQLite core are in the public domain. The TCL tests are the primary tests used during development. The TCL tests are written using the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;TCL scripting language&lt;/a&gt;. The TCL test harness itself consists of 27.0 KSLOC of C code used to create the TCL interface. The test scripts are contained in 1272 files totaling 21.1MB in size. There are 46363 distinct test cases, but many of the test cases are parameterized and run multiple times (with different parameters) so that on a full test run millions of separate tests are performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6c5521cf56a12cd7c97f53a6e81f778a626555" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 69.4 MB or 948.1 KSLOC of C code implementing 44753 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.7 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; тест Жгут представляет собой набор собственных тестов, написанных на C , которые обеспечивают 100% тестовое покрытие (филиал и &lt;a href=&quot;testing#mcdc&quot;&gt;100% тестовое покрытие MC / DC&lt;/a&gt; ) в библиотеку ядра SQLite. Тесты TH3 предназначены для работы на встроенных и специализированных платформах, которые не поддерживают TCL или другие сервисы рабочих станций. Тесты TH3 используют только опубликованные интерфейсы SQLite. TH3 состоит из примерно 69,4 МБ или 948,1 KSLOC кода C, реализующего 44753 различных тестовых случая. Однако тесты TH3 сильно параметризованы, поэтому тест с полным покрытием запускает около 1,7 миллиона различных тестовых экземпляров. Кейсы, которые обеспечивают 100% охват тестированием ветвей, составляют подмножество всего набора тестов TH3. Тест выдержки перед выпуском включает сотни миллионов тестов. Дополнительная информация о TH3 &lt;a href=&quot;th3&quot;&gt;доступна отдельно.&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d6d35eb6cfeae174de2bae520fa16645d47318a8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt;&lt;/b&gt; test harness is a set of proprietary tests, written in C that provide 100% branch test coverage (and &lt;a href=&quot;testing#mcdc&quot;&gt;100% MC/DC test coverage&lt;/a&gt;) to the core SQLite library. The TH3 tests are designed to run on embedded and specialized platforms that would not easily support TCL or other workstation services. TH3 tests use only the published SQLite interfaces. TH3 consists of about 71.5 MB or 978.3 KSLOC of C code implementing 46622 distinct test cases. TH3 tests are heavily parameterized, though, so a full-coverage test runs about 1.9 million different test instances. The cases that provide 100% branch test coverage constitute a subset of the total TH3 test suite. A soak test prior to release does hundreds of millions of tests. Additional information on TH3 is &lt;a href=&quot;th3&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd8f15572230ed1f58d51c1d5372e68bc7d3339" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;&lt;i&gt;page number&lt;/i&gt;&lt;/b&gt; of the cached page. Pages are sequentially numbered within a database file starting from page 1 (page 1 begins at byte offset 0). Refer to</source>
          <target state="translated">Номер &lt;b&gt;&lt;i&gt;страницы&lt;/i&gt;&lt;/b&gt; кэшированной страницы. Страницы в файле базы данных последовательно нумеруются, начиная со страницы 1 (страница 1 начинается со смещения байта 0). Ссылаться на</target>
        </trans-unit>
        <trans-unit id="81a39adda694af530886e4e9df6d7182a049eea0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; compile-time flag no longer functions. I/O procedures are now always redefinable.</source>
          <target state="translated">&lt;b&gt;SQLITE_ENABLE_REDEF_IO&lt;/b&gt; время компиляции флаг больше не функционирует. Процедуры ввода-вывода теперь всегда можно переопределить.</target>
        </trans-unit>
        <trans-unit id="66961c7dbacae09d459d2962003215ef6b06eee5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ascii&lt;/b&gt; tokenizer, which assumes all characters outside of the ASCII codepoint range (0-127) are to be treated as token characters.</source>
          <target state="translated">&lt;b&gt;ASCII&lt;/b&gt; токенизатор, который принимает на себя все символы вне диапазона ASCII (0-127 элемент кода), должны рассматриваться в качестве маркеров символов.</target>
        </trans-unit>
        <trans-unit id="da7024788e6b267f1ba270622b866f7355ceaff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;atomic-write&lt;/b&gt; property. A system that supports this property also specifies the size or sizes of the blocks that it is capable of writing. Valid sizes are powers of two greater than 512. If a write operation modifies a block of</source>
          <target state="translated">Свойство &lt;b&gt;атомарной записи&lt;/b&gt; . Система, поддерживающая это свойство, также определяет размер или размеры блоков, которые она может записывать. Допустимые размеры - это степени двойки больше 512. Если операция записи изменяет блок</target>
        </trans-unit>
        <trans-unit id="d4ac7f6fa28d8af8532959a7c557a99ffb086e4a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;cached data&lt;/b&gt;; a blob of data</source>
          <target state="translated">В &lt;b&gt;кэшированных данных&lt;/b&gt; ; капля данных</target>
        </trans-unit>
        <trans-unit id="4bdaa687775a7cc6ed8f468435ceaab97dc48b3c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum initializer&lt;/b&gt; field is set to a pseudo-random value. It is used as part of the algorithm to calculate the checksum for all</source>
          <target state="translated">В поле &lt;b&gt;инициализатора контрольной суммы&lt;/b&gt; установлено псевдослучайное значение. Он используется как часть алгоритма для расчета контрольной суммы для всех</target>
        </trans-unit>
        <trans-unit id="9732c0255b0b0de3b180d5a5b9e6e0e0de10ed21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;checksum&lt;/b&gt; field contains a checksum value stored as a 4-byte big-endian signed integer. The checksum value is calculated as the sum of the bytes that make up the</source>
          <target state="translated">Поле &lt;b&gt;контрольной суммы&lt;/b&gt; содержит значение контрольной суммы, хранимое как 4-байтовое целое число со знаком прямого порядка байтов. Значение контрольной суммы рассчитывается как сумма байтов, составляющих</target>
        </trans-unit>
        <trans-unit id="808b646bb572829a50a12856cab578c0ba1273b4" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child key&lt;/b&gt; is the column or set of columns in the child table that are constrained by the foreign key constraint and which hold the REFERENCES clause.</source>
          <target state="translated">&lt;b&gt;Ключ ребенка&lt;/b&gt; является столбец или набор столбцов в таблице ребенка, которые сдерживается ограничением внешнего ключа и которые удерживают положение ЛИТЕРАТУРЫ.</target>
        </trans-unit>
        <trans-unit id="4eb5a92cd04b8762d6cafb14dc40e6502ca97d4b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;child table&lt;/b&gt; is the table that a foreign key constraint is applied to and the table that contains the REFERENCES clause. The example in this section uses the</source>
          <target state="translated">&lt;b&gt;Дочерняя таблица&lt;/b&gt; является таблицей , что ограничение внешнего ключа подается и таблица , которая содержит пункт ЛИТЕРАТУРЫ. В примере в этом разделе используется</target>
        </trans-unit>
        <trans-unit id="d2c172ce98989ce0e6fad8d66979d45e11202395" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;columns=&lt;/b&gt;</source>
          <target state="translated">В &lt;b&gt;столбцах =&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4bbf98eb754afaa644e3f69b92d0dc2195f52253" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;data=&lt;/b&gt; argument specifies that</source>
          <target state="translated">Эти &lt;b&gt;данные =&lt;/b&gt; аргумент указывает , что</target>
        </trans-unit>
        <trans-unit id="6baedccfb53deaad3fb37afa8fc4d96019b82c5a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbhash&lt;/b&gt; (or &lt;b&gt;dbhash.exe&lt;/b&gt; on Windows) utility is a command-line program that computes the SHA1 hash of the schema and content for an SQLite database.</source>
          <target state="translated">&lt;b&gt;Dbhash&lt;/b&gt; (или &lt;b&gt;dbhash.exe&lt;/b&gt; на Windows) утилиты командной строки программа , которая вычисляет хэш SHA1 схемы и контента для базы данных SQLite.</target>
        </trans-unit>
        <trans-unit id="d6a3ef16a0b39b8edb4795fe8274619e6786a20a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;dbstat&lt;/b&gt; virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option. The dbstat virtual table provides low-level information about btree and overflow pages in a database file.</source>
          <target state="translated">&lt;b&gt;Dbstat&lt;/b&gt; виртуальная таблица доступна на всех &lt;a href=&quot;c3ref/sqlite3&quot;&gt;подключений к базе данных&lt;/a&gt; , когда SQLite построен с использованием &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; опции компиляции. Виртуальная таблица dbstat предоставляет низкоуровневую информацию о btree и страницах переполнения в файле базы данных.</target>
        </trans-unit>
        <trans-unit id="76a580c33e2e93bdaf2b8468f5fe69cbcb6b77c7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;filename=&lt;/b&gt; argument specifies an external file from which CSV content is read. Every CSV virtual table must have either a &lt;b&gt;filename=&lt;/b&gt; argument or a &lt;b&gt;data=&lt;/b&gt; argument and not both.</source>
          <target state="translated">&lt;b&gt;Имя_файла =&lt;/b&gt; аргумент определяет внешний файл , из которого считывается содержимое CSV. Каждая виртуальная таблица CSV должна иметь либо аргумент &lt;b&gt;filename =,&lt;/b&gt; либо аргумент &lt;b&gt;data =,&lt;/b&gt; но не оба сразу.</target>
        </trans-unit>
        <trans-unit id="b993a193dd09d944f6699b7d9c40cd91aa1faf7c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;journal magic&lt;/b&gt; field always contains a well-known 8-byte string value used to identify SQLite journal files. The well-known sequence of byte values is:</source>
          <target state="translated">&lt;b&gt;Журнал магия&lt;/b&gt; поле всегда содержит известное значение строки 8-байт , используемый для идентификации SQLite файлов журнала. Хорошо известная последовательность байтовых значений:</target>
        </trans-unit>
        <trans-unit id="a2e5b0d62ca7f429d717982cbc08462058d705f1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb60bd76a6daf3fc22f58ff7ed03bdcd9faa9a0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;json1&lt;/b&gt; extension is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements fifteen &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that are useful for managing &lt;a href=&quot;http://json.org/&quot;&gt;JSON&lt;/a&gt; content stored in an SQLite database. There are thirteen scalar functions:</source>
          <target state="translated">Расширение &lt;b&gt;json1&lt;/b&gt; - это &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение,&lt;/a&gt; которое реализует пятнадцать &lt;a href=&quot;c3ref/create_function&quot;&gt;определяемых приложением функций SQL&lt;/a&gt; и две функции с &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличным значением&lt;/a&gt; , которые полезны для управления содержимым &lt;a href=&quot;http://json.org/&quot;&gt;JSON,&lt;/a&gt; хранящимся в базе данных SQLite. Всего существует тринадцать скалярных функций:</target>
        </trans-unit>
        <trans-unit id="74a8fe72057fb6a9d52ebf2366e8ca3d47b3ef51" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;master journal name&lt;/b&gt; field contains the name of the master journal file, encoded as a utf-8 string. There is no nul-terminator appended to the string.</source>
          <target state="translated">Поле имени &lt;b&gt;главного журнала&lt;/b&gt; содержит имя файла главного журнала, закодированное в виде строки utf-8. К строке не добавляется нуль-терминатор.</target>
        </trans-unit>
        <trans-unit id="32cd399bbb4e1a23152d71a26f07f3eec308179e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;name-length&lt;/b&gt; field contains the length of the previous field in bytes, formatted as a 4-byte big-endian unsigned integer.</source>
          <target state="translated">Поле &lt;b&gt;длины имени&lt;/b&gt; содержит длину предыдущего поля в байтах, отформатированную как 4-байтовое целое число без знака с прямым порядком байтов.</target>
        </trans-unit>
        <trans-unit id="fae22eeca9bdb678bd49709e0047fc71684a2c64" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;page size&lt;/b&gt; field contains the database page size used by the corresponding</source>
          <target state="translated">Поле &lt;b&gt;размера страницы&lt;/b&gt; содержит размер страницы базы данных, используемый соответствующими</target>
        </trans-unit>
        <trans-unit id="b47567cd5b3319ed0502d81821002b32b190c8e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent key&lt;/b&gt; is the column or set of columns in the parent table that the foreign key constraint refers to. This is normally, but not always, the primary key of the parent table. The parent key must be a named column or columns in the parent table, not the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;Родительский ключ&lt;/b&gt; является столбец или набор столбцов в родительской таблице , что ограничение внешнего ключа относится. Обычно, но не всегда, это первичный ключ родительской таблицы. Родительский ключ должен быть именованным столбцом или столбцами в родительской таблице, а не &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатором строки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec4c139f470f21c5fe4e5b5cefa7700a1825e05d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent table&lt;/b&gt; is the table that a foreign key constraint refers to. The parent table in the example in this section is the</source>
          <target state="translated">&lt;b&gt;Родительская таблица&lt;/b&gt; представляет собой таблицу , что ограничение внешнего ключа ссылается. Родительская таблица в примере в этом разделе - это</target>
        </trans-unit>
        <trans-unit id="36aa5afa4e61953d1ec495c1b005644b052981bb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;porter&lt;/b&gt; tokenizer, which implements the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt;.</source>
          <target state="translated">&lt;b&gt;Портер&lt;/b&gt; токенизатор, который реализует &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;алгоритм швейцар , вытекающие&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a37111e2fe594df629017fae4b6e16c1ee66e480" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;safe-append&lt;/b&gt; property. If a system supports the</source>
          <target state="translated">Свойство &lt;b&gt;safe-append&lt;/b&gt; . Если система поддерживает</target>
        </trans-unit>
        <trans-unit id="d6885cc42a1a11dedbc2ecde02a62efeb92c5994" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;schema=&lt;/b&gt; argument specifies a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that the CSV virtual table passes to the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; interface in order to define the names of the columns in the virtual table.</source>
          <target state="translated">&lt;b&gt;Схема =&lt;/b&gt; аргумент задает &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; заявление , что виртуальная таблица CSV переходит к &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; интерфейса для того , чтобы определить имена столбцов в виртуальной таблице.</target>
        </trans-unit>
        <trans-unit id="062e562546606b031a29c9b1538d01a4933fdf4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sequential-write&lt;/b&gt; property. A system that supports the</source>
          <target state="translated">Свойство &lt;b&gt;последовательной записи&lt;/b&gt; . Система, поддерживающая</target>
        </trans-unit>
        <trans-unit id="9a93bd9a21f342ac487fc44f9c521120beed1f0d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command is used as follows:</source>
          <target state="translated">Команда &lt;b&gt;sqlite3&lt;/b&gt; используется следующим образом:</target>
        </trans-unit>
        <trans-unit id="6bd9a1c77e9aedcf3a7d203f467b8767663fc753" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command opens the database named in the second argument. If the database does not already exist, the default behavior is for it to be created automatically (though this can be changed by using the &quot;&lt;b&gt;-create false&lt;/b&gt;&quot; option). The &lt;b&gt;sqlite3&lt;/b&gt; command always creates a new Tcl command to control the database. The name of the new Tcl command is given by the first argument. This approach is similar to the way widgets are created in Tk.</source>
          <target state="translated">Команда &lt;b&gt;sqlite3&lt;/b&gt; открывает базу данных, указанную во втором аргументе. Если база данных еще не существует, по умолчанию она создается автоматически (хотя это можно изменить с помощью параметра &amp;laquo; &lt;b&gt;-create false&lt;/b&gt; &amp;raquo;). Команда &lt;b&gt;sqlite3&lt;/b&gt; всегда создает новую команду Tcl для управления базой данных. Имя новой команды Tcl дается первым аргументом. Этот подход похож на способ создания виджетов в Tk.</target>
        </trans-unit>
        <trans-unit id="b032b475b9199ee134a35698c55445c506e1d56e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite&lt;/b&gt; command-line utility uses the &lt;b&gt;sqlite_complete&lt;/b&gt; function to know when it needs to call &lt;b&gt;sqlite_exec&lt;/b&gt;. After each line of input is received, &lt;b&gt;sqlite&lt;/b&gt; calls &lt;b&gt;sqlite_complete&lt;/b&gt; on all input in its buffer. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns true, then &lt;b&gt;sqlite_exec&lt;/b&gt; is called and the input buffer is reset. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then the prompt is changed to the continuation prompt and another line of text is read and added to the input buffer.</source>
          <target state="translated">&lt;b&gt;SQLite&lt;/b&gt; утилита командной строки использует &lt;b&gt;sqlite_complete&lt;/b&gt; функцию , чтобы знать , когда нужно вызвать &lt;b&gt;sqlite_exec&lt;/b&gt; . После получения каждой строки ввода &lt;b&gt;sqlite&lt;/b&gt; вызывает &lt;b&gt;sqlite_complete&lt;/b&gt; для всего ввода в своем буфере. Если &lt;b&gt;sqlite_complete&lt;/b&gt; возвращает true, то &lt;b&gt;вызывается sqlite_exec&lt;/b&gt; и входной буфер сбрасывается. Если &lt;b&gt;sqlite_complete&lt;/b&gt; возвращает false, то подсказка меняется на подсказку продолжения, и другая строка текста читается и добавляется во входной буфер.</target>
        </trans-unit>
        <trans-unit id="332726262d6ef917130298a44650660fb1ebc042" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_busy_handler&lt;/b&gt; procedure can be used to register a busy callback with an open SQLite database. The busy callback will be invoked whenever SQLite tries to access a database that is locked. The callback will typically do some other useful work, or perhaps sleep, in order to give the lock a chance to clear. If the callback returns non-zero, then SQLite tries again to access the database and the cycle repeats. If the callback returns zero, then SQLite aborts the current operation and returns SQLITE_BUSY.</source>
          <target state="translated">Процедуру &lt;b&gt;sqlite_busy_handler&lt;/b&gt; можно использовать для регистрации обратного вызова занятости в открытой базе данных SQLite. Обратный вызов занятости будет вызываться всякий раз, когда SQLite пытается получить доступ к заблокированной базе данных. Обратный вызов обычно выполняет другую полезную работу или, возможно, &amp;laquo;спит&amp;raquo;, чтобы дать блокировке шанс сбросить. Если обратный вызов возвращает ненулевое значение, SQLite снова пытается получить доступ к базе данных, и цикл повторяется. Если обратный вызов возвращает ноль, SQLite прерывает текущую операцию и возвращает SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="21449bf7fdcd477c05c71384163b9f8717a257f0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_changes&lt;/b&gt; API function returns the number of rows that have been inserted, deleted, or modified since the database was last quiescent. A &quot;quiescent&quot; database is one in which there are no outstanding calls to &lt;b&gt;sqlite_exec&lt;/b&gt; and no VMs created by &lt;b&gt;sqlite_compile&lt;/b&gt; that have not been finalized by &lt;b&gt;sqlite_finalize&lt;/b&gt;. In common usage, &lt;b&gt;sqlite_changes&lt;/b&gt; returns the number of rows inserted, deleted, or modified by the most recent &lt;b&gt;sqlite_exec&lt;/b&gt; call or since the most recent &lt;b&gt;sqlite_compile&lt;/b&gt;. But if you have nested calls to &lt;b&gt;sqlite_exec&lt;/b&gt; (that is, if the callback routine of one &lt;b&gt;sqlite_exec&lt;/b&gt; invokes another &lt;b&gt;sqlite_exec&lt;/b&gt;) or if you invoke &lt;b&gt;sqlite_compile&lt;/b&gt; to create a new VM while there is still another VM in existence, then the meaning of the number returned by &lt;b&gt;sqlite_changes&lt;/b&gt; is more complex. The number reported includes any changes that were later undone by a ROLLBACK or ABORT. But rows that are deleted because of a DROP TABLE are &lt;em&gt;not&lt;/em&gt; counted.</source>
          <target state="translated">Функция &lt;b&gt;sqlite_changes&lt;/b&gt; API возвращает количество строк, которые были вставлены, удалены или изменены с момента последнего перехода базы данных в состояние покоя. &amp;laquo;Неактивная&amp;raquo; база данных - это база данных, в которой нет невыполненных вызовов &lt;b&gt;sqlite_exec&lt;/b&gt; и нет виртуальных машин, созданных &lt;b&gt;sqlite_compile&lt;/b&gt; , которые не были завершены &lt;b&gt;sqlite_finalize&lt;/b&gt; . В общем использовании, &lt;b&gt;sqlite_changes&lt;/b&gt; возвращает количество строк , вставлены, удалены или изменены с помощью самого последнего &lt;b&gt;sqlite_exec&lt;/b&gt; вызова или с момента последнего &lt;b&gt;sqlite_compile&lt;/b&gt; . Но если у вас есть вложенные вызовы &lt;b&gt;sqlite_exec&lt;/b&gt; (то есть, если процедура обратного вызова одного &lt;b&gt;sqlite_exec&lt;/b&gt; вызывает другой&lt;b&gt;sqlite_exec&lt;/b&gt; ), или если вы вызываете &lt;b&gt;sqlite_compile&lt;/b&gt; для создания новой виртуальной машины, когда еще существует другая виртуальная машина, то значение числа, возвращаемого &lt;b&gt;sqlite_changes,&lt;/b&gt; будет более сложным. Сообщенное число включает любые изменения, которые позже были отменены посредством ROLLBACK или ABORT. Но строки, удаленные из-за DROP TABLE, &lt;em&gt;не&lt;/em&gt; учитываются.</target>
        </trans-unit>
        <trans-unit id="78ea929e712b658454a0d7a7507e5e6040d334f9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_compile&lt;/b&gt; &quot;compiles&quot; a single SQL statement (specified by the second parameter) and generates a virtual machine that is able to execute that statement. As with must interface routines, the first parameter must be a pointer to an sqlite structure that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="translated">В &lt;b&gt;sqlite_compile&lt;/b&gt; &amp;laquo;компилирует&amp;raquo; Один оператор SQL (задается вторым параметром) и создает виртуальную машину, которая в состоянии выполнить это заявление. Как и в случае с процедурами обязательного интерфейса, первый параметр должен быть указателем на структуру sqlite, полученную в результате предыдущего вызова &lt;b&gt;sqlite_open&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="11aed5342f0d3f43d8e5e9d1781269c400901176" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_create_function()&lt;/b&gt; interface is used to create regular functions and &lt;b&gt;sqlite_create_aggregate()&lt;/b&gt; is used to create new aggregate functions. In both cases, the &lt;b&gt;db&lt;/b&gt; parameter is an open SQLite database on which the functions should be registered, &lt;b&gt;zName&lt;/b&gt; is the name of the new function, &lt;b&gt;nArg&lt;/b&gt; is the number of arguments, and &lt;b&gt;pUserData&lt;/b&gt; is a pointer which is passed through unchanged to the C implementation of the function. Both routines return 0 on success and non-zero if there are any errors.</source>
          <target state="translated">Интерфейс &lt;b&gt;sqlite_create_function ()&lt;/b&gt; используется для создания обычных функций, а &lt;b&gt;sqlite_create_aggregate ()&lt;/b&gt; используется для создания новых агрегатных функций. В обоих случаях параметр &lt;b&gt;db&lt;/b&gt; - это открытая база данных SQLite, в которой должны быть зарегистрированы функции, &lt;b&gt;zName&lt;/b&gt; - это имя новой функции, &lt;b&gt;nArg&lt;/b&gt; - количество аргументов, а &lt;b&gt;pUserData&lt;/b&gt; - это указатель, который без изменений передается реализации C функции. Обе подпрограммы возвращают 0 в случае успеха и ненулевое значение в случае каких-либо ошибок.</target>
        </trans-unit>
        <trans-unit id="5689a09fe87990c5eb5859050a66b6bf0ba7128a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function is used to process SQL statements and queries. This function requires 5 parameters as follows:</source>
          <target state="translated">Функция &lt;b&gt;sqlite_exec&lt;/b&gt; используется для обработки операторов SQL и запросов. Для этой функции требуется 5 параметров:</target>
        </trans-unit>
        <trans-unit id="121679113b5d1c7ddf7783cb3755cec086d10308" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function normally returns SQLITE_OK. But if something goes wrong it can return a different value to indicate the type of error. Here is a complete list of the return codes:</source>
          <target state="translated">Функция &lt;b&gt;sqlite_exec&lt;/b&gt; обычно возвращает SQLITE_OK. Но если что-то пойдет не так, он может вернуть другое значение, чтобы указать тип ошибки. Вот полный список кодов возврата:</target>
        </trans-unit>
        <trans-unit id="655f344d54e7a8508c37039b0267420f9c98a884" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; routine described above used to be the only way to retrieve data from an SQLite database. But many programmers found it inconvenient to use a callback function to obtain results. So beginning with SQLite version 2.7.7, a second access interface is available that does not use callbacks.</source>
          <target state="translated">&lt;b&gt;Sqlite_exec&lt;/b&gt; процедура описана выше , используется , чтобы быть единственным способом для извлечения данных из базы данных SQLite. Но многим программистам неудобно использовать функцию обратного вызова для получения результатов. Итак, начиная с версии SQLite 2.7.7, доступен второй интерфейс доступа, который не использует обратные вызовы.</target>
        </trans-unit>
        <trans-unit id="0f4f5ac57e80af00b368fb64cb711d6dc8b648f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_finalize&lt;/b&gt; routine also returns the result code that indicates success or failure of the SQL operation that the virtual machine carried out. The value returned by sqlite_finalize() will be the same as would have been returned had the same SQL been executed by &lt;b&gt;sqlite_exec&lt;/b&gt;. The error message returned will also be the same.</source>
          <target state="translated">&lt;b&gt;Sqlite_finalize&lt;/b&gt; процедура также возвращает код результата , который указывает успех или неудачу операции SQL , что виртуальная машина выполняется. Значение, возвращаемое sqlite_finalize (), будет таким же, как если бы тот же SQL был выполнен &lt;b&gt;sqlite_exec&lt;/b&gt; . Возвращаемое сообщение об ошибке также будет таким же.</target>
        </trans-unit>
        <trans-unit id="e5fe3b872ae55549d978788ef7dd0751c76061d1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table()&lt;/b&gt; function now returns an error if you give it two or more SELECTs that return different numbers of columns.</source>
          <target state="translated">Функция &lt;b&gt;sqlite_get_table ()&lt;/b&gt; теперь возвращает ошибку, если вы дадите ей два или более SELECT, которые возвращают разное количество столбцов.</target>
        </trans-unit>
        <trans-unit id="6c359ecc30c529f766becf568f4c268c432080f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; function is a wrapper around &lt;b&gt;sqlite_exec&lt;/b&gt; that collects all the information from successive callbacks and writes it into memory obtained from malloc(). This is a convenience function that allows the application to get the entire result of a database query with a single function call.</source>
          <target state="translated">Функция &lt;b&gt;sqlite_get_table&lt;/b&gt; - это оболочка вокруг &lt;b&gt;sqlite_exec,&lt;/b&gt; которая собирает всю информацию из последовательных обратных вызовов и записывает ее в память, полученную из malloc (). Это удобная функция, которая позволяет приложению получить полный результат запроса к базе данных с помощью одного вызова функции.</target>
        </trans-unit>
        <trans-unit id="dc054248626971621053a5f41a56a6eacfcebb24" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; routine returns the same integer result code as &lt;b&gt;sqlite_exec&lt;/b&gt;.</source>
          <target state="translated">В &lt;b&gt;sqlite_get_table&lt;/b&gt; подпрограмма возвращает тот же целое число , код результата , как &lt;b&gt;sqlite_exec&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="bd292002416cc2983b3342d6c1953e82de8e1607" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_interrupt&lt;/b&gt; function can be called from a different thread or from a signal handler to cause the current database operation to exit at its first opportunity. When this happens, the &lt;b&gt;sqlite_exec&lt;/b&gt; routine (or the equivalent) that started the database operation will return SQLITE_INTERRUPT.</source>
          <target state="translated">Функция &lt;b&gt;sqlite_interrupt&lt;/b&gt; может быть вызвана из другого потока или из обработчика сигналов, чтобы вызвать завершение текущей операции с базой данных при первой же возможности. Когда это произойдет, процедура &lt;b&gt;sqlite_exec&lt;/b&gt; (или ее эквивалент), запустившая операцию с базой данных, вернет SQLITE_INTERRUPT.</target>
        </trans-unit>
        <trans-unit id="110634f7ff21aac9a3d6ba9124f053cdf818f538" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_mprintf()&lt;/b&gt; routine works like the standard library &lt;b&gt;sprintf()&lt;/b&gt; except that it writes its results into memory obtained from malloc() and returns a pointer to the malloced buffer. &lt;b&gt;sqlite_mprintf()&lt;/b&gt; also understands the %q and %Q extensions described above. The &lt;b&gt;sqlite_vmprintf()&lt;/b&gt; is a varargs version of the same routine. The string pointer that these routines return should be freed by passing it to &lt;b&gt;sqlite_freemem()&lt;/b&gt;.</source>
          <target state="translated">В &lt;b&gt;sqlite_mprintf ()&lt;/b&gt; рутинные работы как стандартная библиотека &lt;b&gt;Sprintf ()&lt;/b&gt; за исключением того, что он записывает результаты в память , полученной из таНоса () и возвращает указатель на буфер malloced. &lt;b&gt;sqlite_mprintf ()&lt;/b&gt; также понимает расширения% q и% Q, описанные выше. &lt;b&gt;Sqlite_vmprintf ()&lt;/b&gt; представляет собой версию переменных аргументов ту же самую процедуру. Строковый указатель, который возвращают эти подпрограммы, следует освободить, передав его в &lt;b&gt;sqlite_freemem ()&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1c001281fc04cb0f8f55a953f44815f9bb2acd94" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; routine can be used to register a callback routine with an SQLite database to be invoked periodically during long running calls to &lt;b&gt;sqlite_exec()&lt;/b&gt;, &lt;b&gt;sqlite_step()&lt;/b&gt; and the various wrapper functions.</source>
          <target state="translated">&lt;b&gt;Sqlite_progress_handler ()&lt;/b&gt; подпрограмма может быть использована , чтобы зарегистрировать процедуру обратного вызова с SQLite базы данных, которая вызывается периодически во время длительных звонков в &lt;b&gt;sqlite_exec ()&lt;/b&gt; , &lt;b&gt;sqlite_step ()&lt;/b&gt; и различных функций - оболочек.</target>
        </trans-unit>
        <trans-unit id="2365ff095ada5e9e18ca628c551aa06ded148313" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;unicode61&lt;/b&gt; tokenizer, based on the Unicode 6.1 standard. This is the default.</source>
          <target state="translated">&lt;b&gt;Unicode61&lt;/b&gt; токенизатор, основанный на стандарте Unicode 6.1. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c89f587843e082fe105c35ca8b1efaa6d37ded8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists and are readable</source>
          <target state="translated">В &lt;code&gt;-shm&lt;/code&gt; и &lt;code&gt;-wal&lt;/code&gt; файлы уже существует и читаемы</target>
        </trans-unit>
        <trans-unit id="ae74358eb64792c48dfddc93166fad33cb929d0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqldiff.exe&lt;/code&gt; binary is a command-line utility program that displays the differences between SQLite databases. Example usage:</source>
          <target state="translated">&lt;code&gt;sqldiff.exe&lt;/code&gt; двоичная это утилита командной строки , которая отображает различия между SQLite базами данных. Пример использования:</target>
        </trans-unit>
        <trans-unit id="d7c66765c0cb2c27b3a6401331165fc804dadc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; binary is a command-line utility program that measures and displays how much and how efficiently space is used by individual tables and indexes with an SQLite database file. Example usage:</source>
          <target state="translated">&lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; двоичная это утилита командной строки , которая измеряет и отображает сколько и как эффективно используется пространство отдельных таблиц и индексов с SQLite файла базы данных. Пример использования:</target>
        </trans-unit>
        <trans-unit id="6a1974b0f327d4817e6c9b37b72d6c96039edec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; program is a &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; program that uses the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; to gather information about the database file and then format that information neatly.</source>
          <target state="translated">Программа &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; - это программа &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL,&lt;/a&gt; которая использует &lt;a href=&quot;dbstat&quot;&gt;виртуальную таблицу dbstat&lt;/a&gt; для сбора информации о файле базы данных и затем аккуратно форматирует эту информацию.</target>
        </trans-unit>
        <trans-unit id="ef70743aa444e28fbab143ed138c4d54acc4ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;lt;name&amp;gt;&lt;/em&gt; is the name your application chooses for the R*Tree index and &lt;em&gt;&amp;lt;column-names&amp;gt;&lt;/em&gt; is a comma separated list of between 3 and 11 columns. The virtual &amp;lt;name&amp;gt; table creates three &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; to actually store its content. The names of these shadow tables are:</source>
          <target state="translated">&lt;em&gt;&amp;lt;Имя&amp;gt;&lt;/em&gt; это имя ваш выбирает приложение для индекса R * Tree и &lt;em&gt;&amp;lt;столбец названий&amp;gt;&lt;/em&gt; является список разделенных запятыми между 3 и 11 столбцов. Виртуальная таблица &amp;lt;name&amp;gt; создает три &lt;a href=&quot;vtab#xshadowname&quot;&gt;теневые таблицы&lt;/a&gt; для фактического хранения своего содержимого. Имена этих теневых таблиц:</target>
        </trans-unit>
        <trans-unit id="cfd2051780cda360472504e6c22be9c660375526" translate="yes" xml:space="preserve">
          <source>The ADD COLUMN syntax is used to add a new column to an existing table. The new column is always appended to the end of the list of existing columns. The &lt;a href=&quot;syntax/column-def&quot;&gt;column-def&lt;/a&gt; rule defines the characteristics of the new column. The new column may take any of the forms permissible in a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, with the following restrictions:</source>
          <target state="translated">Синтаксис ADD COLUMN используется для добавления нового столбца в существующую таблицу. Новый столбец всегда добавляется в конец списка существующих столбцов. &lt;a href=&quot;syntax/column-def&quot;&gt;Колонка четкость&lt;/a&gt; правило определяет характеристику нового столбца. Новый столбец может принимать любую из форм, допустимых в операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , со следующими ограничениями:</target>
        </trans-unit>
        <trans-unit id="dd4a8c42527cc6ad0b74da94ea18e9ecc2a5a9ab" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="translated">Команда ALTER TABLE работает путем изменения текста SQL схемы, хранящейся в &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;таблице sqlite_master&lt;/a&gt; . Никаких изменений в содержимом таблицы не производится. Из-за этого время выполнения команды ALTER TABLE не зависит от количества данных в таблице. Команда ALTER TABLE выполняется для таблицы с 10 миллионами строк так же быстро, как и для таблицы с 1 строкой.</target>
        </trans-unit>
        <trans-unit id="b0731871ca262efc59fc6d44f9562ddd3fdb4667" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3548d68842f13a30875b616a72010deb210b5992" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros are a weaker statement about the truth of X. The presence of ALWAYS(X) or NEVER(X) means that the developers believe X is always or never true, but there is no proof, or the proof is complex and error-prone, or the proof depends on other aspects of the system that seem likely to change.</source>
          <target state="translated">Макросы ALWAYS(X)и NEVER(X)являются более слабым утверждением об истинности X.Наличие макросов ALWAYS(X)или NEVER(X)означает,что разработчики верят в то,что X всегда или никогда не будет истинной,но доказательств нет,или же доказательства сложны и подвержены ошибкам,или же доказательство зависит от других аспектов системы,которые,кажется,могут измениться.</target>
        </trans-unit>
        <trans-unit id="6ae8b97d0df4ab8cc5246397daf337e302574c90" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros behave like assert(X) during functionality testing, because the developers want to be immediately alerted to the issue if the value of X is different from what is expected. But for delivery, ALWAYS(X) and NEVER(X) are simple pass-through macros, which provide defense-in-depth. For coverage testing ALWAYS(X) and NEVER(X) are hard-coded boolean values so that they do not cause unreachable machine code to be generated.</source>
          <target state="translated">Макросы ALWAYS(X)и NEVER(X)ведут себя как assert(X)во время тестирования функциональности,потому что разработчики хотят быть немедленно предупреждены о проблеме,если значение X отличается от ожидаемого.Но для доставки,ВСЕГДА(X)и NEVER(X)являются простыми проходными макросами,которые обеспечивают глубину защиты.Для тестирования покрытия ВСЕГДА(X)и НИКОГДА(X)являются жестко закодированными булевыми значениями,чтобы они не приводили к генерации недоступного машинного кода.</target>
        </trans-unit>
        <trans-unit id="e07bd491ac7cf8d45ca2e35ee71bfa7a388a2b49" translate="yes" xml:space="preserve">
          <source>The ANALYZE command gathers statistics about tables and indices and stores the collected information in &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; of the database where the query optimizer can access the information and use it to help make better query planning choices. If no arguments are given, all attached databases are analyzed. If a schema name is given as the argument, then all tables and indices in that one database are analyzed. If the argument is a table name, then only that table and the indices associated with that table are analyzed. If the argument is an index name, then only that one index is analyzed.</source>
          <target state="translated">Команда ANALYZE собирает статистику о таблицах и индексах и сохраняет собранную информацию во &lt;a href=&quot;fileformat2#intschema&quot;&gt;внутренних таблицах&lt;/a&gt; базы данных, где оптимизатор запросов может получить доступ к информации и использовать ее для улучшения выбора при планировании запросов. Если аргументы не указаны, анализируются все присоединенные базы данных. Если в качестве аргумента указано имя схемы, то анализируются все таблицы и индексы в этой базе данных. Если аргументом является имя таблицы, то анализируется только эта таблица и связанные с ней индексы. Если аргумент - имя индекса, то анализируется только этот индекс.</target>
        </trans-unit>
        <trans-unit id="eab24cd68f511dec396088e10ba12e5df9e965d6" translate="yes" xml:space="preserve">
          <source>The AND operator determines the &lt;b&gt;intersection&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">Оператор AND определяет &lt;b&gt;пересечение&lt;/b&gt; двух наборов документов.</target>
        </trans-unit>
        <trans-unit id="a3b6d448d425bac9ff08d9f7709bfd23114eaa1f" translate="yes" xml:space="preserve">
          <source>The AND operator may be implicitly specified. If two basic queries appear with no operator separating them in an FTS query string, the results are the same as if the two basic queries were separated by an AND operator. For example, the query expression &quot;implicit operator&quot; is a more succinct version of &quot;implicit AND operator&quot;.</source>
          <target state="translated">Оператор AND может быть неявно указан.Если в строке запроса FTS появляются два базовых запроса без оператора,разделяющего их,то результаты будут такими же,как если бы два базовых запроса были разделены оператором AND.Например,выражение запроса &quot;неявный оператор&quot; является более сжатой версией &quot;неявного оператора AND&quot;.</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="938085178daf2eb44e4c20ce7562d652c273a4d4" translate="yes" xml:space="preserve">
          <source>The API for SQLite 3.0 includes 83 separate functions in addition to several data structures and #defines. (A complete &lt;a href=&quot;c3ref/intro&quot;&gt;API reference&lt;/a&gt; is provided as a separate document.) Fortunately, the interface is not nearly as complex as its size implies. Simple programs can still make do with only 3 functions: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;. More control over the execution of the database engine is provided using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; to compile an SQLite statement into byte code and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; to execute that bytecode. A family of routines with names beginning with &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_&lt;/a&gt; is used to extract information about the result set of a query. Many interface functions come in pairs, with both a UTF-8 and UTF-16 version. And there is a collection of routines used to implement user-defined SQL functions and user-defined text collating sequences.</source>
          <target state="translated">API для SQLite 3.0 включает 83 отдельных функции в дополнение к нескольким структурам данных и #defines. (Полный &lt;a href=&quot;c3ref/intro&quot;&gt;справочник по API&lt;/a&gt; предоставляется в виде отдельного документа.) К счастью, интерфейс не так сложен, как предполагает его размер. Простые программы по-прежнему могут обходиться только тремя функциями: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; и &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; . Больше контроля над выполнением механизма базы данных обеспечивается с помощью &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; для компиляции оператора SQLite в байт-код и &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; для выполнения этого байт-кода. Семейство подпрограмм, имена которых начинаются с &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_&lt;/a&gt;используется для извлечения информации о наборе результатов запроса. Многие функции интерфейса идут парами, в версиях UTF-8 и UTF-16. И есть набор подпрограмм, используемых для реализации определяемых пользователем функций SQL и определяемых пользователем последовательностей сортировки текста.</target>
        </trans-unit>
        <trans-unit id="c44a4b3ab13cd66c53e9432e0d3af7281c445940" translate="yes" xml:space="preserve">
          <source>The API for version 3.0 is similar to the version 2.X API, but with some important changes. Most noticeably, the &quot;&lt;code&gt;sqlite_&lt;/code&gt;&quot; prefix that occurs on the beginning of all API functions and data structures are changed to &quot;&lt;code&gt;sqlite3_&lt;/code&gt;&quot;. This avoids confusion between the two APIs and allows linking against both SQLite 2.X and SQLite 3.0 at the same time.</source>
          <target state="translated">API для версии 3.0 аналогичен API версии 2.X, но с некоторыми важными изменениями. Наиболее заметно то, что префикс &amp;laquo; &lt;code&gt;sqlite_&lt;/code&gt; &amp;raquo;, который встречается в начале всех функций API и структур данных, изменен на &amp;laquo; &lt;code&gt;sqlite3_&lt;/code&gt; &amp;raquo;. Это позволяет избежать путаницы между двумя API-интерфейсами и позволяет одновременно связываться как с SQLite 2.X, так и с SQLite 3.0.</target>
        </trans-unit>
        <trans-unit id="36d190e36c6e5fa5963aab7e95daad2e70b8ee67" translate="yes" xml:space="preserve">
          <source>The ATTACH DATABASE statement adds another database file to the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Database files that were previously attached can be removed using the &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; command.</source>
          <target state="translated">Оператор ATTACH DATABASE добавляет еще один файл базы данных к текущему &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединению с базой данных&lt;/a&gt; . Файлы базы данных, которые были ранее прикреплены, можно удалить с помощью команды &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e719935b3c48aaab57f1043bcfdf280a49c9b8d" translate="yes" xml:space="preserve">
          <source>The AUTOINCREMENT keyword imposes extra CPU, memory, disk space, and disk I/O overhead and should be avoided if not strictly needed. It is usually not needed.</source>
          <target state="translated">Ключевое слово AUTOINCREMENT (АВТОИНКРЕМЕНТ)накладывает дополнительную нагрузку на процессор,память,дисковое пространство и дисковый ввод/вывод,и его следует избегать,если в этом нет строгой необходимости.Обычно в этом нет необходимости.</target>
        </trans-unit>
        <trans-unit id="48851d12ae740edbaa05f50e23f70eaa76ffb64c" translate="yes" xml:space="preserve">
          <source>The Ascii tokenizer is similar to the Unicode61 tokenizer, except that:</source>
          <target state="translated">Токенайзер Ascii аналогичен токенайзеру Unicode61,за исключением этого:</target>
        </trans-unit>
        <trans-unit id="12502ac36995aeed690062079cb8e1d738f368d7" translate="yes" xml:space="preserve">
          <source>The B-tree module requests information from the disk in fixed-size pages. The default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; is 4096 bytes but can be any power of two between 512 and 65536 bytes. The page cache is responsible for reading, writing, and caching these pages. The page cache also provides the rollback and atomic commit abstraction and takes care of locking of the database file. The B-tree driver requests particular pages from the page cache and notifies the page cache when it wants to modify pages or commit or rollback changes. The page cache handles all the messy details of making sure the requests are handled quickly, safely, and efficiently.</source>
          <target state="translated">Модуль B-tree запрашивает информацию с диска в виде страниц фиксированного размера. По умолчанию &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; составляет 4096 байт, но может быть любой степенью двойки от 512 до 65536 байт. Кеш страницы отвечает за чтение, запись и кеширование этих страниц. Кеш страницы также обеспечивает абстракцию отката и атомарной фиксации и заботится о блокировке файла базы данных. Драйвер B-дерева запрашивает определенные страницы из кеша страниц и уведомляет кеш страниц, когда он хочет изменить страницы или зафиксировать или откатить изменения. Кеш страницы обрабатывает все беспорядочные детали, чтобы запросы обрабатывались быстро, безопасно и эффективно.</target>
        </trans-unit>
        <trans-unit id="a9c46870576aba5a82ba72dd5f506b8ec80b72f2" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row.</source>
          <target state="translated">Ключевое слово BEFORE или AFTER определяет,когда будут выполнены триггерные действия относительно вставки,изменения или удаления связанной строки.</target>
        </trans-unit>
        <trans-unit id="21f8310c8a4f643230a41569cc835883561b2976" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row. BEFORE is the default when neither keyword is present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63dc07d0b34107d9ff47bbfc25d958a7f1dde76" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator</source>
          <target state="translated">Оператор BETWEEN</target>
        </trans-unit>
        <trans-unit id="bf7d42c3d7c926828f621e364e6fa7e162b22076" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator is logically equivalent to a pair of comparisons. &quot;</source>
          <target state="translated">Оператор BETWEEN логически эквивалентен паре сравнений.&quot;</target>
        </trans-unit>
        <trans-unit id="b2bdb770820ef0c5e362d9c32237f45d4cd0627c" translate="yes" xml:space="preserve">
          <source>The BLOB argument to snippet() does not have the correct subtype, so the snippet function ignores it, makes no changes to any data structures, and harmlessly returns NULL.</source>
          <target state="translated">BLOB аргумент snippet()не имеет правильного подтипа,поэтому функция snippet игнорирует его,не вносит никаких изменений ни в какие структуры данных,и безвредно возвращает NULL.</target>
        </trans-unit>
        <trans-unit id="3210a7f9aaf2f66bd9905568531663be357a3b69" translate="yes" xml:space="preserve">
          <source>The BTree module allocates large buffers using malloc() instead of off of the stack, in order to play better on machines with limited stack space.</source>
          <target state="translated">Модуль BTree выделяет большие буферы с помощью malloc()вместо выключения стека,чтобы лучше играть на машинах с ограниченным пространством стека.</target>
        </trans-unit>
        <trans-unit id="21f5d882ac3e8071ceb7ad0fcec2c3ef4f2e3e7c" translate="yes" xml:space="preserve">
          <source>The C code below implements a simple window aggregate function named sumint(). This works in the same way as the built-in sum() function, except that it throws an exception if passed an argument that is not an integer value.</source>
          <target state="translated">Нижеприведенный код на языке Си реализует простую функцию агрегации окон,называемую sumint().Она работает так же,как и встроенная функция sum(),за исключением того,что она бросает исключение,если передан аргумент,не являющийся целочисленным значением.</target>
        </trans-unit>
        <trans-unit id="d5cf82df30f7e154d46c9db25174e218f7ef9aef" translate="yes" xml:space="preserve">
          <source>The C function to the right demonstrates one of the simplest, and most common, uses of the backup API: loading and saving the contents of an in-memory database to a file on disk. The backup API is used as follows in this example:</source>
          <target state="translated">Функция C справа демонстрирует одно из самых простых и часто используемых API резервного копирования:загрузку и сохранение содержимого базы данных в памяти в файл на диске.В данном примере API резервного копирования используется следующим образом:</target>
        </trans-unit>
        <trans-unit id="d54a9c2fa57a9ea05dba3dee97529bc735dc5276" translate="yes" xml:space="preserve">
          <source>The C language interface to SQLite Version 2</source>
          <target state="translated">Интерфейс языка C к SQLite версии 2</target>
        </trans-unit>
        <trans-unit id="fe37317d6916dca66fe00426df36e00a240b1501" translate="yes" xml:space="preserve">
          <source>The C language is old and boring. It is a well-known and well-understood language. This is exactly what one wants when developing a module like SQLite. Writing a small, fast, and reliable database engine is hard enough as it is without the implementation language changing out from under you with each update to the implementation language specification.</source>
          <target state="translated">Язык C-старый и скучный.Это хорошо известный и хорошо понимаемый язык.Именно этого хочется добиться при разработке такого модуля,как SQLite.Написать маленький,быстрый и надежный движок базы данных достаточно сложно,так как при каждом обновлении язык реализации меняется из-под вас в спецификацию языка реализации.</target>
        </trans-unit>
        <trans-unit id="7245ee6098ebc8d6b59383d4e63478298246efb9" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">Параметр C для &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close (C)&lt;/a&gt; и &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2 (C)&lt;/a&gt; должен быть либо указателем NULL, либо указателем объекта &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3,&lt;/a&gt; полученным из &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и не закрытым ранее. Вызов sqlite3_close () или sqlite3_close_v2 () с аргументом указателя NULL является безвредным бездействием.</target>
        </trans-unit>
        <trans-unit id="7c0540d8d33318130da25d1e55f755e6a1ecc3bb" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="translated">Параметр C для &lt;a href=&quot;close&quot;&gt;sqlite3_close (C)&lt;/a&gt; и &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2 (C)&lt;/a&gt; должен быть либо указателем NULL, либо указателем объекта &lt;a href=&quot;sqlite3&quot;&gt;sqlite3,&lt;/a&gt; полученным из &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; и не закрытым ранее. Вызов sqlite3_close () или sqlite3_close_v2 () с аргументом указателя NULL является безвредным бездействием.</target>
        </trans-unit>
        <trans-unit id="c6b84eb128b8b4492347bcdafbeda21b63c03f1b" translate="yes" xml:space="preserve">
          <source>The C-language API for SQLite provides the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; which gives &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations the opportunity to add new PRAGMA statements or to override the meaning of built-in PRAGMA statements.</source>
          <target state="translated">API языка C для SQLite предоставляет &lt;a href=&quot;c3ref/file_control&quot;&gt;файловый элемент управления &lt;/a&gt;&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA,&lt;/a&gt; который дает реализациям &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; возможность добавлять новые операторы PRAGMA или переопределять значение встроенных операторов PRAGMA.</target>
        </trans-unit>
        <trans-unit id="3cdde2acd27b2b36bcb4e6d376af3a07b88f1a00" translate="yes" xml:space="preserve">
          <source>The CASE expression</source>
          <target state="translated">Выражение CASE</target>
        </trans-unit>
        <trans-unit id="b66ba15f2fad294f2684c4bed978c753222465dc" translate="yes" xml:space="preserve">
          <source>The CAST operator understands decimal integers only &amp;mdash; conversion of &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integers&lt;/a&gt; stops at the &quot;x&quot; in the &quot;0x&quot; prefix of the hexadecimal integer string and thus result of the CAST is always zero.</source>
          <target state="translated">Оператор CAST понимает только десятичные целые числа - преобразование &lt;a href=&quot;lang_expr#hexint&quot;&gt;шестнадцатеричных целых чисел&lt;/a&gt; останавливается на &amp;laquo;x&amp;raquo; в префиксе &amp;laquo;0x&amp;raquo; строки шестнадцатеричных целых чисел, и поэтому результат CAST всегда равен нулю.</target>
        </trans-unit>
        <trans-unit id="a234c8e77cd8f0401958366a773fd160b49e7507" translate="yes" xml:space="preserve">
          <source>The CLI has another build-in SQL function named edit(). Edit() takes one or two arguments. The first argument is a value - usually a large multi-line string to be edited. The second argument is the name of a text editor. If the second argument is omitted, the VISUAL environment variable is used. The edit() function writes its first argument into a temporary file, invokes the editor on the temporary file, rereads the file back into memory after the editor is done, then returns the edited text.</source>
          <target state="translated">В CLI есть еще одна встроенная SQL-функция под названием edit().Функция edit()принимает один или два аргумента.Первым аргументом является значение-обычно это большая многострочная строка,которую нужно отредактировать.Второй аргумент-имя текстового редактора.Если второй аргумент опущен,то используется переменная окружения VISUAL.Функция edit()записывает свой первый аргумент во временный файл,вызывает редактор во временном файле,перечитывает файл обратно в память после завершения редактирования,затем возвращает отредактированный текст.</target>
        </trans-unit>
        <trans-unit id="19b42365ba0a7a06fdcdf543ad6806dc3520342c" translate="yes" xml:space="preserve">
          <source>The CLI ignores whitespace (including comments) at the end of lines</source>
          <target state="translated">CLI игнорирует пробелы (включая комментарии)в конце строк</target>
        </trans-unit>
        <trans-unit id="dd9e96d76e423f66ac741c4a46deda1233291328" translate="yes" xml:space="preserve">
          <source>The COLLATE clause optionally following each column name or expression defines a collating sequence used for text entries in that column. The default collating sequence is the collating sequence defined for that column in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Or if no collating sequence is otherwise defined, the built-in BINARY collating sequence is used.</source>
          <target state="translated">Предложение COLLATE, необязательно следующее за каждым именем или выражением столбца, определяет последовательность сортировки, используемую для текстовых записей в этом столбце. Последовательность сортировки по умолчанию - это последовательность сортировки, определенная для этого столбца в операторе &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Или, если последовательность сортировки не определена иначе, используется встроенная ДВОИЧНАЯ последовательность сортировки.</target>
        </trans-unit>
        <trans-unit id="cce4b68250de466854c34f5909554bfe291d7ca1" translate="yes" xml:space="preserve">
          <source>The COLLATE clause specifies the name of a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to use as the default collation sequence for the column. If no COLLATE clause is specified, the default collation sequence is &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;.</source>
          <target state="translated">Предложение COLLATE указывает имя &lt;a href=&quot;datatype3#collation&quot;&gt;последовательности сортировки, которая&lt;/a&gt; будет использоваться в качестве последовательности сортировки по умолчанию для столбца. Если предложение COLLATE не указано, последовательность сопоставления по умолчанию - &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b44ceebb8207f8e640174bbe459b285c5b2aace" translate="yes" xml:space="preserve">
          <source>The COLLATE operator is a unary postfix operator that assigns a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to an expression. The COLLATE operator has a higher precedence (binds more tightly) than any binary operator and any unary prefix operator except &quot;~&quot;. (COLLATE and &quot;~&quot; are associative so their binding order does not matter.) The collating sequence set by the COLLATE operator overrides the collating sequence determined by the COLLATE clause in a table &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. See the &lt;a href=&quot;datatype3#collation&quot;&gt;detailed discussion on collating sequences&lt;/a&gt; in the &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; document for additional information.</source>
          <target state="translated">Оператор COLLATE - это унарный постфиксный оператор, который присваивает выражению &lt;a href=&quot;datatype3#collation&quot;&gt;последовательность сортировки&lt;/a&gt; . Оператор COLLATE имеет более высокий приоритет (связывает более жестко), чем любой бинарный оператор и любой унарный префиксный оператор, кроме &quot;~&quot;. (COLLATE и &quot;~&quot; являются ассоциативными, поэтому их порядок привязки не имеет значения.) Последовательность сортировки, установленная оператором COLLATE, переопределяет последовательность сортировки, определенную предложением COLLATE в определении &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;столбца&lt;/a&gt; таблицы . См. &lt;a href=&quot;datatype3#collation&quot;&gt;Подробное обсуждение последовательностей сортировки&lt;/a&gt; в документе &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="a680bd512c99945ec1f5ce6f701753b4eac29105" translate="yes" xml:space="preserve">
          <source>The COMPLETION extension implements a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; named &quot;completion&quot; that can be used to suggest completions of partially entered words during interactive SQL input. The completion table can be used to help implement tab-completion, for example.</source>
          <target state="translated">Расширение COMPLETION реализует возвращающую &lt;a href=&quot;vtab#tabfunc2&quot;&gt;табличное значение функцию с&lt;/a&gt; именем &amp;laquo;завершение&amp;raquo;, которую можно использовать для подсказки завершения частично введенных слов во время интерактивного ввода SQL. Таблицу завершения можно использовать, например, для помощи в реализации завершения по табуляции.</target>
        </trans-unit>
        <trans-unit id="f18272789e8a6f151079fbc600b2b7e84d838750" translate="yes" xml:space="preserve">
          <source>The COMPLETION() Table-Valued Function</source>
          <target state="translated">Функция оценки таблицы (COMPLETION())</target>
        </trans-unit>
        <trans-unit id="6a7ddb1a93117b2b3bde0c54048509560ea3634c" translate="yes" xml:space="preserve">
          <source>The COPY command puts NULLs in columns whose data is '\N'.</source>
          <target state="translated">Команда COPY помещает NULL в столбцы,данные которых '\N'.</target>
        </trans-unit>
        <trans-unit id="13eb987eb47f3316a50f4573a4bd655a2e5a8454" translate="yes" xml:space="preserve">
          <source>The CORRUPT_DB macro is used in many assert() statements. In functional testing builds, CORRUPT_DB references a global variable that is true if the database file might contain corruption. This variable is true by default, since we do not normally know whether or not a database is corrupt, but during testing while working on databases that are known to be well-formed, that global variable can be set to false. Then the CORRUPT_DB macro can be used in assert() statements such as seen at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&lt;/a&gt;. Those assert()s specify pre-conditions to the routine that are true for consistent database files, but which might be false if the database file is corrupt. Knowledge of these kinds of conditions is very helpful to readers who are trying to understand a block of code in isolation.</source>
          <target state="translated">Макрос CORRUPT_DB используется во многих операторах assert (). В сборках функционального тестирования CORRUPT_DB ссылается на глобальную переменную, которая имеет значение true, если файл базы данных может содержать повреждение. По умолчанию эта переменная имеет значение true, поскольку обычно мы не знаем, повреждена ли база данных, но во время тестирования при работе с базами данных, которые заведомо являются правильно сформированными, этой глобальной переменной можно присвоить значение false. Затем макрос CORRUPT_DB можно использовать в операторах assert (), например, на &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&lt;/a&gt;. Эти assert () задают предварительные условия для процедуры, которые верны для согласованных файлов базы данных, но могут быть ложными, если файл базы данных поврежден. Знание такого рода условий очень полезно для читателей, которые пытаются понять блок кода изолированно.</target>
        </trans-unit>
        <trans-unit id="87b68f64512a185516fdf233a80a1c3ea3aa60fd" translate="yes" xml:space="preserve">
          <source>The CREATE INDEX command consists of the keywords &quot;CREATE INDEX&quot; followed by the name of the new index, the keyword &quot;ON&quot;, the name of a previously created table that is to be indexed, and a parenthesized list of table column names and/or expressions that are used for the index key. If the optional WHERE clause is included, then the index is a &quot;&lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;&quot;.</source>
          <target state="translated">Команда CREATE INDEX состоит из ключевых слов &amp;laquo;CREATE INDEX&amp;raquo;, за которыми следует имя нового индекса, ключевое слово &amp;laquo;ON&amp;raquo;, имя ранее созданной таблицы, которая должна быть проиндексирована, и заключенный в скобки список имен столбцов таблицы и / или выражения, которые используются для ключа индекса. Если включено необязательное предложение WHERE, то индекс является &amp;laquo; &lt;a href=&quot;partialindex&quot;&gt;частичным индексом&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="abdfd2b1dd5fd6ecf72fce71bade948329a001e4" translate="yes" xml:space="preserve">
          <source>The CREATE TRIGGER statement is used to add triggers to the database schema. Triggers are database operations that are automatically performed when a specified database event occurs.</source>
          <target state="translated">Оператор CREATE TRIGGER используется для добавления триггеров в схему БД.Триггеры-это операции с БД,которые выполняются автоматически при наступлении заданного события в БД.</target>
        </trans-unit>
        <trans-unit id="598d64a270f59326bd978afae12168eba5f52ca0" translate="yes" xml:space="preserve">
          <source>The CREATE VIEW command assigns a name to a pre-packaged &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. Once the view is created, it can be used in the FROM clause of another &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; in place of a table name.</source>
          <target state="translated">Команда CREATE VIEW присваивает имя предварительно упакованному &lt;a href=&quot;lang_select&quot;&gt;оператору SELECT&lt;/a&gt; . После создания представления его можно использовать в предложении FROM другого &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; вместо имени таблицы.</target>
        </trans-unit>
        <trans-unit id="174705dc4a8b591705076f7ea08e69231535552a" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE &quot;tokenize&quot; option is used to configure the specific tokenizer used by the FTS5 table. The option argument must be either an FTS5 bareword, or an SQL text literal. The text of the argument is itself treated as a white-space series of one or more FTS5 barewords or SQL text literals. The first of these is the name of the tokenizer to use. The second and subsequent list elements, if they exist, are arguments passed to the tokenizer implementation.</source>
          <target state="translated">Опция &quot;tokenize&quot; CREATE VIRTUAL TABLE используется для настройки конкретного токенайзера,используемого таблицей FTS5.Аргумент опции должен быть либо пустым словом FTS5,либо текстовым литералом SQL.Текст аргумента сам по себе рассматривается как серия из белого пробела одного или нескольких пустых слов FTS5 или SQL-текстовых литералов.Первым из них является название токенайзера.Второй и последующие элементы списка,если они существуют,являются аргументами,передаваемыми в реализацию токенайзера.</target>
        </trans-unit>
        <trans-unit id="5585953bde77b974603ba3ea6e6ff59c9cc91b38" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE statement creates a new table called table-name derived from the class class module-name. The module-name is the name that is registered for the virtual table by the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface.</source>
          <target state="translated">Оператор CREATE VIRTUAL TABLE создает новую таблицу с именем имя-таблицы, производную от имени модуля класса класса. Имя модуля - это имя, зарегистрированное для виртуальной таблицы интерфейсом &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1062968fd409aff74d10cea95e91438b9101e01c" translate="yes" xml:space="preserve">
          <source>The CREATE, TABLE, VIEW, TRIGGER, and INDEX keywords at the beginning of the statement are converted to all upper case letters.</source>
          <target state="translated">Ключевые слова CREATE,TABLE,VIEW,TRIGGER и INDEX в начале оператора преобразуются во все прописные буквы.</target>
        </trans-unit>
        <trans-unit id="640a12b822aa85aa459e9a1bb86ef50f7f04eecb" translate="yes" xml:space="preserve">
          <source>The CSV Virtual Table</source>
          <target state="translated">Виртуальная таблица CSV</target>
        </trans-unit>
        <trans-unit id="7457dbcb832f7358700e049001b26f6040f77dbe" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is not built into the SQLite amalgamation. It is available as a &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;separate source file&lt;/a&gt; that can be compiled into a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. Typical usage of the CSV virtual table from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; would be something like this:</source>
          <target state="translated">Виртуальная таблица CSV не встроена в объединение SQLite. Он доступен как &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;отдельный исходный файл,&lt;/a&gt; который можно скомпилировать в &lt;a href=&quot;loadext&quot;&gt;загружаемое расширение&lt;/a&gt; . Типичное использование виртуальной таблицы CSV из &lt;a href=&quot;cli&quot;&gt;оболочки командной строки&lt;/a&gt; будет примерно таким:</target>
        </trans-unit>
        <trans-unit id="15b49f55e220937bbbf59d823ad49d5a9aa75e6b" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is useful to applications that need to bulk-load large amounts of comma-separated value content. The CSV virtual table is also useful as a template source file for implementing other virtual tables.</source>
          <target state="translated">Виртуальная таблица CSV полезна для приложений,которым необходимо загружать большие объемы содержимого,разделенного запятыми.Виртуальная таблица CSV также полезна в качестве исходного файла шаблона для реализации других виртуальных таблиц.</target>
        </trans-unit>
        <trans-unit id="ea497adefbfc963344834dc953220548ab21ec73" translate="yes" xml:space="preserve">
          <source>The CSV virtual table reads &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated values, and returns that content as if it were rows and columns of an SQL table.</source>
          <target state="translated">Виртуальная таблица CSV считывает значения, разделенные запятыми в формате &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; , и возвращает это содержимое, как если бы это были строки и столбцы таблицы SQL.</target>
        </trans-unit>
        <trans-unit id="701ea259a9685ea4d0bc43814eed54520d975a72" translate="yes" xml:space="preserve">
          <source>The Callback instruction in this example has to generate data for three result columns instead of two, but is otherwise the same as in the first query. When the Callback instruction is invoked, the left-most column of the result should be the lowest in the stack and the right-most result column should be the top of the stack. We can see the stack being set up this way at addresses 11 through 15. The Column instructions at 11 and 12 push the values for the first two columns in the result. The two Column instructions at 13 and 14 pull in the values needed to compute the third result column and the Concat instruction at 15 joins them together into a single entry on the stack.</source>
          <target state="translated">Инструкция Callback в этом примере должна генерировать данные для трех столбцов результата вместо двух,но в остальном она такая же,как и в первом запросе.При вызове команды Callback самый левый столбец результата должен быть самым низким в стеке,а самый правый столбец результата должен быть верхним в стеке.Мы видим,что стек настраивается таким образом по адресам с 11 по 15.Инструкции по установке столбцов по адресам 11 и 12 нажимают на значения первых двух столбцов результата.Две инструкции для столбцов с адресами 13 и 14 втягивают значения,необходимые для вычисления третьего столбца результата,а инструкция Контакт с адресами 15 объединяет их в единую запись в стеке.</target>
        </trans-unit>
        <trans-unit id="421f0a20824677ed3aab71d6f46b98a38cc2b1ed" translate="yes" xml:space="preserve">
          <source>The Carray() Table-Valued Function</source>
          <target state="translated">Функция Carray()Таблица-оценка</target>
        </trans-unit>
        <trans-unit id="b6379901f8c254a706f0c6dbee9e66ad0809b055" translate="yes" xml:space="preserve">
          <source>The Checklist Manifesto</source>
          <target state="translated">Манифест о Контрольном перечне</target>
        </trans-unit>
        <trans-unit id="b16740a57ff0b848b3dcfa1e89789fe4179b42d5" translate="yes" xml:space="preserve">
          <source>The Clang/LLVM compiler is not competitive with GCC. Clang-generated binaries are consistently larger and slower than GCC-generated binaries.</source>
          <target state="translated">Компилятор Clang/LLVM не конкурирует с GCC.Двоичные файлы,генерируемые Clang,постоянно больше и медленнее,чем сгенерированные GCC.</target>
        </trans-unit>
        <trans-unit id="78bc8f511390974d6caf83474dc6a28ef2586f49" translate="yes" xml:space="preserve">
          <source>The Close instruction at the end of the program closes the cursor that points into the table &quot;examp&quot;. It is not really necessary to call Close here since all cursors will be automatically closed by the VDBE when the program halts. But we needed an instruction for the Rewind to jump to so we might as well go ahead and have that instruction do something useful. The Halt instruction ends the VDBE program.</source>
          <target state="translated">Инструкция &quot;Закрыть&quot; в конце программы закрывает курсор,который указывает на таблицу &quot;экзамен&quot;.На самом деле нет необходимости вызывать Close здесь,так как все курсоры будут автоматически закрыты VDBE,когда программа остановится.Но нам нужна была инструкция для перемотки,к которой можно было бы перейти,чтобы эта инструкция сделала что-нибудь полезное.Команда Halt завершает работу программы VDBE.</target>
        </trans-unit>
        <trans-unit id="b524e42667c1ac047d027b2497617d613c12fde4" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">Аргументы D и N для sqlite3_backup_init (D, N, S, M) - это &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, связанное с целевой базой данных, и имя базы данных, соответственно. Имя базы данных - &amp;laquo;main&amp;raquo; для основной базы данных, &amp;laquo;temp&amp;raquo; для временной базы данных или имя, указанное после ключевого слова AS в операторе &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; для присоединенной базы данных. Аргументы S и M, передаваемые sqlite3_backup_init (D, N, S, M), идентифицируют &lt;a href=&quot;#sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных и имя базы данных исходной базы данных соответственно. Соединения с исходной и целевой &lt;a href=&quot;#sqlite3&quot;&gt;базами данных&lt;/a&gt; (параметры S и D) должны быть разными, иначе sqlite3_backup_init (D, N, S, M) завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="f80ea416ab3893dba34d3603b147323625f4c5ae" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="translated">Аргументы D и N для sqlite3_backup_init (D, N, S, M) - это &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных, связанное с целевой базой данных, и имя базы данных, соответственно. Имя базы данных - &amp;laquo;main&amp;raquo; для основной базы данных, &amp;laquo;temp&amp;raquo; для временной базы данных или имя, указанное после ключевого слова AS в операторе &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; для присоединенной базы данных. Аргументы S и M, передаваемые sqlite3_backup_init (D, N, S, M), идентифицируют &lt;a href=&quot;sqlite3&quot;&gt;соединение&lt;/a&gt; с базой данных и имя базы данных исходной базы данных соответственно. Соединения с исходной и целевой &lt;a href=&quot;sqlite3&quot;&gt;базами данных&lt;/a&gt; (параметры S и D) должны быть разными, иначе sqlite3_backup_init (D, N, S, M) завершится ошибкой.</target>
        </trans-unit>
        <trans-unit id="8f1eeb8e873e48b54ccf8adc2382597a61daec29" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">Параметр D для &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; может иметь значение NULL. Если параметр D в &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; не равен NULL, то максимальная длина строки, содержащейся в объекте &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str,&lt;/a&gt; будет значением, установленным для &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; (D, &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; ) вместо &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7435a55126fe3b0801a03e561888366bace9433" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="translated">Параметр D для &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; может иметь значение NULL. Если параметр D в &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new (D)&lt;/a&gt; не равен NULL, то максимальная длина строки, содержащейся в объекте &lt;a href=&quot;str&quot;&gt;sqlite3_str,&lt;/a&gt; будет значением, установленным для &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; (D, &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; ) вместо &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="091a2ba2d55b0a7d15b54d374b18e4d57aa3a683" translate="yes" xml:space="preserve">
          <source>The DBSTAT Virtual Table</source>
          <target state="translated">Виртуальная таблица ДБСТАТ</target>
        </trans-unit>
        <trans-unit id="97ceb7c4621bdd8f62a9cfbb2a879b8e9e999bd7" translate="yes" xml:space="preserve">
          <source>The DBSTAT table only reports on the content of btrees within the database file. Freelist pages, pointer-map pages, and the lock page are omitted from the analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76cd10f2092ca8f1b285dee48937f8c50e332d42" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about the amount of disk space used to store the content of an SQLite database. Example use cases for the DBSTAT virtual table include the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program and the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53bde0cca31e9e282f188b556d84747d1c6f1e06" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about which pages of the database files are used by which tables and indexes in the schema. The DBSTAT virtual table is used to implement &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program, and to help compute the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="translated">Виртуальная таблица DBSTAT - это &lt;a href=&quot;vtab#epovtab&quot;&gt;одноименная виртуальная таблица&lt;/a&gt; только для чтения, которая возвращает информацию о том, какие страницы файлов базы данных используются какими таблицами и индексами в схеме. Виртуальная таблица DBSTAT используется для реализации служебной программы &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; и для помощи в вычислении &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;круговой диаграммы размера таблицы&lt;/a&gt; в &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;реализованной Fossil&lt;/a&gt; системе управления версиями для SQLite.</target>
        </trans-unit>
        <trans-unit id="a9ce5a525fa3a87844d5ab55ef30cdd54b0cc3c2" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f357b6765d9672540c415d35375e9c82ab3dde27" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is available on all &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; when SQLite is built using the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e77f3a2af88468cea075512b7c593d618135668" translate="yes" xml:space="preserve">
          <source>The DEFAULT clause specifies a default value to use for the column if no value is explicitly provided by the user when doing an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;. If there is no explicit DEFAULT clause attached to a column definition, then the default value of the column is NULL. An explicit DEFAULT clause may specify that the default value is NULL, a string constant, a blob constant, a signed-number, or any constant expression enclosed in parentheses. A default value may also be one of the special case-independent keywords CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP. For the purposes of the DEFAULT clause, an expression is considered constant if it contains no sub-queries, column or table references, &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;, or string literals enclosed in double-quotes instead of single-quotes.</source>
          <target state="translated">Предложение DEFAULT указывает значение по умолчанию, которое будет использоваться для столбца, если при выполнении &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; значение не указано явно пользователем . Если к определению столбца не прикреплено явное предложение DEFAULT, то значение столбца по умолчанию - NULL. Явное предложение DEFAULT может указывать, что значением по умолчанию является NULL, строковая константа, константа большого двоичного объекта, число со знаком или любое константное выражение, заключенное в круглые скобки. Значение по умолчанию также может быть одним из специальных независимых от регистра ключевых слов CURRENT_TIME, CURRENT_DATE или CURRENT_TIMESTAMP. В рамках предложения DEFAULT выражение считается постоянным, если оно не содержит подзапросов, ссылок на столбцы или таблицы, &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанных параметров&lt;/a&gt; или строковых литералов, заключенных в двойные кавычки вместо одинарных кавычек.</target>
        </trans-unit>
        <trans-unit id="f30a44f7fde1290a9d66490fe4c7fc9d343db0a2" translate="yes" xml:space="preserve">
          <source>The DELETE command removes records from the table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;.</source>
          <target state="translated">Команда DELETE удаляет записи из таблицы, идентифицированной &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;квалифицированным именем таблицы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="549ed1cfefc84f8dde1745ba5b3bb051dd3b5008" translate="yes" xml:space="preserve">
          <source>The DELETE command without a WHILE clause just removes the database files from the disk, rather than going through and deleting record by record.</source>
          <target state="translated">Команда DELETE без пункта WHILE просто удаляет файлы БД с диска,а не просматривает и удаляет запись за записью.</target>
        </trans-unit>
        <trans-unit id="0c69d162dd597ca7eb6e965c55e71ba6c6554cc2" translate="yes" xml:space="preserve">
          <source>The DELETE journaling mode is the normal behavior. In the DELETE mode, the rollback journal is deleted at the conclusion of each transaction. Indeed, the delete operation is the action that causes the transaction to commit. (See the document titled &lt;a href=&quot;atomiccommit&quot;&gt; Atomic Commit In SQLite&lt;/a&gt; for additional detail.)</source>
          <target state="translated">Режим ведения журнала DELETE - нормальное поведение. В режиме DELETE журнал отката удаляется при завершении каждой транзакции. Действительно, операция удаления - это действие, которое вызывает фиксацию транзакции. (Дополнительные сведения см. В документе под названием &amp;laquo; &lt;a href=&quot;atomiccommit&quot;&gt;Атомарная фиксация в SQLite&amp;raquo;&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="1da9a7936dc2b558a9310f00abb6a148be159cba" translate="yes" xml:space="preserve">
          <source>The DELETE trigger must be fired before the actual delete takes place on the content table. This is so that FTS4 can still retrieve the original values in order to update the full-text index. And the INSERT trigger must be fired after the new row is inserted, so as to handle the case where the rowid is assigned automatically within the system. The UPDATE trigger must be split into two parts, one fired before and one after the update of the content table, for the same reasons.</source>
          <target state="translated">Триггер DELETE должен быть запущен до того,как произойдет фактическое удаление в таблице содержания.Это необходимо для того,чтобы FTS4 все еще мог получить исходные значения для обновления полнотекстового индекса.И триггер INSERT должен быть запущен после вставки новой строки,чтобы обрабатывать тот случай,когда rowid назначается автоматически внутри системы.Триггер UPDATE должен быть разделен на две части,одна из которых должна быть выпущена до и одна после обновления таблицы содержимого по тем же самым причинам.</target>
        </trans-unit>
        <trans-unit id="3ab4459caaad95b429957125366d895b4021e494" translate="yes" xml:space="preserve">
          <source>The DELETE-mode locks are stored on the &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;lock-byte page&lt;/a&gt; of the main database file. Only SQLITE_LOCK_SHARED and SQLITE_LOCK_EXCLUSIVE are factors for WAL-mode databases. The other locking states are used in rollback-mode, but not in WAL-mode.</source>
          <target state="translated">Блокировки в режиме DELETE хранятся на &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;странице байтов блокировки&lt;/a&gt; основного файла базы данных. Только SQLITE_LOCK_SHARED и SQLITE_LOCK_EXCLUSIVE являются факторами для баз данных в режиме WAL. Остальные состояния блокировки используются в режиме отката, но не в режиме WAL.</target>
        </trans-unit>
        <trans-unit id="577fca03e1d22d54957a27f6f46f602e956a7f46" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword in an aggregate query</source>
          <target state="translated">Ключевое слово DISTINCT в совокупном запросе</target>
        </trans-unit>
        <trans-unit id="5960207cc3ff80c8b76aafd25f9f8b94d8c8f42b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword now will sometimes use an INDEX if an appropriate index is available and the optimizer thinks its use might be advantageous.</source>
          <target state="translated">Ключевое слово DISTINCT теперь будет иногда использовать INDEX,если соответствующий индекс доступен,и оптимизатор считает,что его использование может быть выгодным.</target>
        </trans-unit>
        <trans-unit id="fc7140e369fedc4714b9ea0083c995ff08e24d5b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword on an aggregate query is implemented by creating a transient index in a temporary file and storing each result row in that index. As new result rows are computed a check is made to see if they already exist in the transient index and if they do the new result row is discarded.</source>
          <target state="translated">Ключевое слово DISTINCT на агрегированном запросе реализуется путем создания индекса переходных процессов во временном файле и хранения каждой строки результата в этом индексе.По мере вычисления новых строк результата проверяется,существуют ли они уже в переходном индексе и отбрасывается ли новая строка результата.</target>
        </trans-unit>
        <trans-unit id="3c8c0a43ed7404e0a2eaed887060f73b06109a61" translate="yes" xml:space="preserve">
          <source>The DROP INDEX statement removes an index added with the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement. The index is completely removed from the disk. The only way to recover the index is to reenter the appropriate &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command.</source>
          <target state="translated">Оператор DROP INDEX удаляет индекс, добавленный оператором &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; . Индекс полностью удален с диска. Единственный способ восстановить индекс - повторно ввести соответствующую команду &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf79716c365aa3a9096fb80997c218efa52bf726" translate="yes" xml:space="preserve">
          <source>The DROP TABLE statement removes a table added with the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The name specified is the table name. The dropped table is completely removed from the database schema and the disk file. The table can not be recovered. All indices and triggers associated with the table are also deleted.</source>
          <target state="translated">Оператор DROP TABLE удаляет таблицу, добавленную оператором &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; . Указанное имя является именем таблицы. Отброшенная таблица полностью удаляется из схемы базы данных и файла на диске. Таблица не подлежит восстановлению. Все индексы и триггеры, связанные с таблицей, также удаляются.</target>
        </trans-unit>
        <trans-unit id="8134f9df85fa3c68e953f09b317e3c27f145a52e" translate="yes" xml:space="preserve">
          <source>The DROP TRIGGER statement removes a trigger created by the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement. Once removed, the trigger definition is no longer present in the sqlite_master (or sqlite_temp_master) table and is not fired by any subsequent INSERT, UPDATE or DELETE statements.</source>
          <target state="translated">Оператор DROP TRIGGER удаляет триггер, созданный оператором &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; . После удаления определение триггера больше не присутствует в таблице sqlite_master (или sqlite_temp_master) и не запускается никакими последующими операторами INSERT, UPDATE или DELETE.</target>
        </trans-unit>
        <trans-unit id="5c4386299e0353e3df19809c98731f022556c566" translate="yes" xml:space="preserve">
          <source>The DROP VIEW statement removes a view created by the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement. The view definition is removed from the database schema, but no actual data in the underlying base tables is modified.</source>
          <target state="translated">Оператор DROP VIEW удаляет представление, созданное оператором &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; . Определение представления удаляется из схемы базы данных, но фактические данные в базовых таблицах не изменяются.</target>
        </trans-unit>
        <trans-unit id="81bf67a5e4628332f9b58ee8c6d173a4c4f911e2" translate="yes" xml:space="preserve">
          <source>The Dbbe abstraction and the GDBM and memory drivers were removed.</source>
          <target state="translated">Абстракция Dbbe,а также GDBM и драйверы памяти были удалены.</target>
        </trans-unit>
        <trans-unit id="b8ac6ee150153e29d6eb02ac712357b33cd11445" translate="yes" xml:space="preserve">
          <source>The Default Page Size Change of SQLite 3.12.0</source>
          <target state="translated">Изменение размера страницы по умолчанию в SQLite 3.12.0.</target>
        </trans-unit>
        <trans-unit id="9fa7fe014de7884ad65be67fee11ca70cb61f51e" translate="yes" xml:space="preserve">
          <source>The EXCEPT operator for compound queries is implemented by creating a transient index in a temporary file, storing the results of the left subquery in this transient index, then removing the result from right subquery from the transient index, and finally walking the index from beginning to end to obtain the final output.</source>
          <target state="translated">Оператор EXCEPT для составных запросов реализуется путем создания переходного индекса во временном файле,сохраняя результаты левого подзапроса в этом переходном индексе,затем удаляя результат из правого подзапроса из переходного индекса,и,наконец,проходя по индексу от начала до конца,получать конечный результат.</target>
        </trans-unit>
        <trans-unit id="5ae9f97f03202a131a787390ace280bc0296d78b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator</source>
          <target state="translated">Оператор ЭКСИСТА</target>
        </trans-unit>
        <trans-unit id="84773fe1424e26217a7a2df622779c7708ba171b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator always evaluates to one of the integer values 0 and 1. If executing the SELECT statement specified as the right-hand operand of the EXISTS operator would return one or more rows, then the EXISTS operator evaluates to 1. If executing the SELECT would return no rows at all, then the EXISTS operator evaluates to 0.</source>
          <target state="translated">Оператор EXISTS всегда оценивает до одного из целочисленных значений 0 и 1.Если при выполнении оператора EXISTS оператор SELECT,указанный как правый операнд EXISTS,возвращает одну или несколько строк,то оператор EXISTS оценивает до 1.Если при выполнении оператора SELECT вообще не возвращает ни одной строки,то оператор EXISTS оценивает до 0.</target>
        </trans-unit>
        <trans-unit id="93ef1c61206801602304d02bd0314e2e805ed955" translate="yes" xml:space="preserve">
          <source>The EXPLAIN QUERY PLAN command is described in &lt;a href=&quot;eqp&quot;&gt;more detail here&lt;/a&gt;.</source>
          <target state="translated">Команда EXPLAIN QUERY PLAN &lt;a href=&quot;eqp&quot;&gt;более подробно описана здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c62b11f7e5c5d50c87cb37698a2dd96b4ced3ac8" translate="yes" xml:space="preserve">
          <source>The EXPLAIN and EXPLAIN QUERY PLAN prefixes affect the behavior of running a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. The process of generating a new prepared statement using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or similar is (mostly) unaffected by EXPLAIN. (The exception to the previous sentence is that some special opcodes used by EXPLAIN QUERY PLAN are omitted when building an EXPLAIN QUERY PLAN prepared statement, as a performance optimization.)</source>
          <target state="translated">Префиксы EXPLAIN и EXPLAIN QUERY PLAN влияют на поведение выполнения &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленного оператора&lt;/a&gt; с использованием &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; . EXPLAIN (в основном) не влияет на процесс создания нового подготовленного оператора с помощью &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или аналогичного. (Исключением из предыдущего предложения является то, что некоторые специальные коды операций, используемые EXPLAIN QUERY PLAN, опускаются при построении подготовленного оператора EXPLAIN QUERY PLAN в целях оптимизации производительности.)</target>
        </trans-unit>
        <trans-unit id="c3ee00b5769ef7f7d7fa11249f75b6c728fff5d2" translate="yes" xml:space="preserve">
          <source>The Error And Warning Log</source>
          <target state="translated">Журнал ошибок и предупреждений</target>
        </trans-unit>
        <trans-unit id="d0e00804aea114acdf8c7482e29e4b6fc1dd022a" translate="yes" xml:space="preserve">
          <source>The FAIL behavior only works for uniqueness, NOT NULL, and CHECK constraints. A &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation causes an ABORT.</source>
          <target state="translated">Поведение FAIL работает только для ограничений уникальности, NOT NULL и CHECK. &lt;a href=&quot;foreignkeys&quot;&gt;Ключ ограничения внешнего&lt;/a&gt; нарушение вызывает ABORT.</target>
        </trans-unit>
        <trans-unit id="adadb0f9269151516b0ccaba4b14756b3c80bd9b" translate="yes" xml:space="preserve">
          <source>The FOR EACH STATEMENT clause on a trigger now causes a syntax error. It used to be silently ignored.</source>
          <target state="translated">Пункт FOR EACH STATEMENT на триггере теперь вызывает синтаксическую ошибку.Раньше его молча игнорировали.</target>
        </trans-unit>
        <trans-unit id="9cd48fd724eca1ec736eda16ef97971212fd20e2" translate="yes" xml:space="preserve">
          <source>The FTS modules may be compiled to use one of two slightly different versions of the full-text query syntax, the &quot;standard&quot; query syntax and the &quot;enhanced&quot; query syntax. The basic term, term-prefix, phrase and NEAR queries described above are the same in both versions of the syntax. The way in which set operations are specified is slightly different. The following two sub-sections describe the part of the two query syntaxes that pertains to set operations. Refer to the description of how to &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;compile fts&lt;/a&gt; for compilation notes.</source>
          <target state="translated">Модули FTS могут быть скомпилированы для использования одной из двух немного разных версий синтаксиса полнотекстового запроса, &amp;laquo;стандартного&amp;raquo; синтаксиса запроса и &amp;laquo;расширенного&amp;raquo; синтаксиса запроса. Базовый термин, термин-префикс, фраза и запросы NEAR, описанные выше, одинаковы в обеих версиях синтаксиса. Способ задания операций над множествами немного отличается. В следующих двух подразделах описывается часть двух синтаксисов запросов, относящаяся к операциям с наборами. Обратитесь к описанию того, как &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;скомпилировать fts,&lt;/a&gt; для получения информации о компиляции.</target>
        </trans-unit>
        <trans-unit id="b82e31fa29aba07c9204f92b3f977e0bafebbf9f" translate="yes" xml:space="preserve">
          <source>The FTS query syntax (right hand side of the MATCH operator) has changed in some ways. The FTS5 syntax is quite close to the FTS4 &quot;enhanced syntax&quot;. The main difference is that FTS5 is fussier about unrecognized punctuation characters and similar within query strings. Most queries that work with FTS3/4 should also work with FTS5, and those that do not should return parse errors.</source>
          <target state="translated">Синтаксис FTS-запроса (правая сторона MATCH-оператора)несколько изменился.Синтаксис FTS5 достаточно близок к &quot;расширенному синтаксису&quot; FTS4.Основное отличие заключается в том,что FTS5 более жестко относится к нераспознанным знакам препинания и подобен им внутри строк запроса.Большинство запросов,которые работают с FTS3/4,также должны работать с FTS5,а те,которые не должны возвращать ошибки при разборе.</target>
        </trans-unit>
        <trans-unit id="452e2c3759f6eb486841492aa116e202a1ab1f44" translate="yes" xml:space="preserve">
          <source>The FTS table column number to extract the returned fragments of text from. Columns are numbered from left to right starting with zero. A negative value indicates that the text may be extracted from any column.</source>
          <target state="translated">Номер столбца таблицы FTS для извлечения возвращаемых фрагментов текста.Колонки нумеруются слева направо,начиная с нуля.Отрицательное значение означает,что текст может быть извлечен из любой колонки.</target>
        </trans-unit>
        <trans-unit id="e03bf1e933cfbb832357f37ab56f4975c4a387f7" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 extension modules allows users to create special tables with a built-in full-text index (hereafter &quot;FTS tables&quot;). The full-text index allows the user to efficiently query the database for all rows that contain one or more words (hereafter &quot;tokens&quot;), even if the table contains many large documents.</source>
          <target state="translated">Модули расширения FTS3 и FTS4 позволяют пользователям создавать специальные таблицы со встроенным полнотекстовым индексом (далее &quot;таблицы FTS&quot;).Полнотекстовый индекс позволяет пользователю эффективно опрашивать базу данных по всем строкам,содержащим одно или несколько слов (далее &quot;токены&quot;),даже если таблица содержит много больших документов.</target>
        </trans-unit>
        <trans-unit id="7d4bac9786b108503576084f19784d9481dfe5de" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 modules provide three special SQL scalar functions that may be useful to the developers of full-text query systems: &quot;snippet&quot;, &quot;offsets&quot; and &quot;matchinfo&quot;. The purpose of the &quot;snippet&quot; and &quot;offsets&quot; functions is to allow the user to identify the location of queried terms in the returned documents. The &quot;matchinfo&quot; function provides the user with metrics that may be useful for filtering or sorting query results according to relevance.</source>
          <target state="translated">Модули FTS3 и FTS4 предоставляют три специальные функции SQL-скаляра,которые могут быть полезны разработчикам полнотекстовых систем запросов:&quot;фрагмент&quot;,&quot;смещение&quot; и &quot;информация о совпадении&quot;.Назначение функций &quot;сниппет&quot; и &quot;смещений&quot;-дать пользователю возможность определить расположение запрашиваемых терминов в возвращаемых документах.Функция &quot;matchinfo&quot; предоставляет пользователю метрики,которые могут быть полезны для фильтрации или сортировки результатов запроса по релевантности.</target>
        </trans-unit>
        <trans-unit id="cd165aec23f192a3f9f07347a0254f2d27b32b66" translate="yes" xml:space="preserve">
          <source>The FTS3 extension has undergone a major rework and cleanup. New &lt;a href=&quot;fts3&quot;&gt;FTS3 documentation&lt;/a&gt; is now available.</source>
          <target state="translated">Расширение FTS3 подверглось серьезной переработке и очистке. Новая &lt;a href=&quot;fts3&quot;&gt;FTS3 документация&lt;/a&gt; теперь доступна.</target>
        </trans-unit>
        <trans-unit id="9cae97c9c8daf8017ea793bf4be64df945be883c" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;automerge=X&quot; command has been replaced by the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt;.</source>
          <target state="translated">Команда FTS3 / 4 &amp;laquo;automerge = X&amp;raquo; была заменена &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;опцией автоматического объединения FTS5&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ba1806c7cd7bdfbbc2b404c832b1beab23a209" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;merge=X,Y&quot; command has been replaced by the &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt;.</source>
          <target state="translated">Команда FTS3 / 4 &quot;merge = X, Y&quot; была заменена командой &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2c4e64578a5475fd4fbd32b9347a70fbc56baad" translate="yes" xml:space="preserve">
          <source>The FTS4 prefix option causes FTS to index term prefixes of specified lengths in the same way that it always indexes complete terms. The prefix option must be set to a comma separated list of positive non-zero integers. For each value N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed. FTS4 uses term prefix indexes to speed up &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt;. The cost, of course, is that indexing term prefixes as well as complete terms increases the database size and slows down write operations on the FTS4 table.</source>
          <target state="translated">Параметр префикса FTS4 заставляет FTS индексировать префиксы терминов определенной длины так же, как он всегда индексирует полные термины. Параметр префикса должен быть установлен в виде списка положительных ненулевых целых чисел, разделенных запятыми. Для каждого значения N в списке индексируются префиксы длиной N байтов (при кодировании с использованием UTF-8). FTS4 использует индексы префиксов терминов для ускорения &lt;a href=&quot;fts3#termprefix&quot;&gt;запросов префиксов&lt;/a&gt; . Цена, конечно же, заключается в том, что префиксы терминов индексации, а также полные термины увеличивают размер базы данных и замедляют операции записи в таблицу FTS4.</target>
        </trans-unit>
        <trans-unit id="f3623dd8b5a2a6147fa4bef6afa8dea8c88c6337" translate="yes" xml:space="preserve">
          <source>The F_FULLSYNC ioctl (currently only supported on Mac OS X) is disabled if the synchronous pragma is set to something other than &quot;full&quot;.</source>
          <target state="translated">F_FULLSYNC ioctl (в настоящее время поддерживается только на Mac OS X)отключается,если синхронный прагматик установлен на что-то,отличное от &quot;полного&quot;.</target>
        </trans-unit>
        <trans-unit id="4a8e5028bc3ed89b6a1dc3d8dc7eba9bd090d027" translate="yes" xml:space="preserve">
          <source>The Fossil NGQP Upgrade Case Study</source>
          <target state="translated">Тематический пример модернизации NGQP в области ископаемого топлива</target>
        </trans-unit>
        <trans-unit id="6dc92de118e5e87426474c7d89d8139659caa059" translate="yes" xml:space="preserve">
          <source>The Fossil performance problem described in the previous section of this document arose because there were over ten-thousand entries in the TAGXREF table with the same value for the left-most column (the TAGID column) of the TAGXREF_I1 index.</source>
          <target state="translated">Ископаемая проблема производительности,описанная в предыдущем разделе настоящего документа,возникла в связи с тем,что в таблице TAGXREF было более десяти тысяч записей с одинаковым значением для крайнего левого столбца (столбец TAGID)индекса TAGXREF_I1.</target>
        </trans-unit>
        <trans-unit id="d2cc3db361bc3155e6c06330a65fa4635f5425d3" translate="yes" xml:space="preserve">
          <source>The Fossil view clearly shows that the branch was eventually merged back into trunk. It shows where the branch started, and it shows two occasions where changes on trunk were merged into the branch. GitHub shows none of this. In fact, the GitHub display is mostly useless in trying to figure out what happened.</source>
          <target state="translated">Вид ископаемого ясно показывает,что в конце концов ветка была слита обратно в ствол.Здесь показано,с чего начиналось ответвление,и два случая,когда изменения в стволе были слиты в ответвление.GitHub ничего из этого не показывает.На самом деле,изображение GitHub в основном бесполезно при попытке выяснить,что произошло.</target>
        </trans-unit>
        <trans-unit id="6b63744d939cc984f1b96440853e8df6692826ba" translate="yes" xml:space="preserve">
          <source>The Fts5PhraseIter structure is defined above. Applications should not modify this structure directly - it should only be used as shown above with the xPhraseFirst() and xPhraseNext() API methods (and by xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).</source>
          <target state="translated">Структура Fts5PhraseIter определена выше.Приложения не должны изменять эту структуру напрямую-она должна использоваться только так,как показано выше с помощью API методов xPhraseFirst()и xPhraseNext()(а также с помощью xPhraseFirstColumn()и xPhraseNextColumn(),как проиллюстрировано ниже).</target>
        </trans-unit>
        <trans-unit id="a5efd19f10743bd231ab41e35fd5ac44fc6fbe77" translate="yes" xml:space="preserve">
          <source>The GLOB operator is always case sensitive. The column on the left side of the GLOB operator must always use the built-in BINARY collating sequence or no attempt will be made to optimize that operator with indices.</source>
          <target state="translated">Оператор GLOB всегда чувствителен к регистру.В столбце слева от GLOB-оператора всегда должна использоваться встроенная BINARY-коллидирующая последовательность,иначе не будет предпринято никаких попыток оптимизировать этот оператор с индексами.</target>
        </trans-unit>
        <trans-unit id="ebb21a9ebdf2dcd06a6d1e05cc13a1948a1a0378" translate="yes" xml:space="preserve">
          <source>The GLOB operator is similar to LIKE but uses the Unix file globbing syntax for its wildcards. Also, GLOB is case sensitive, unlike LIKE. Both GLOB and LIKE may be preceded by the NOT keyword to invert the sense of the test. The infix GLOB operator is implemented by calling the function &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; and can be modified by overriding that function.</source>
          <target state="translated">Оператор GLOB похож на LIKE, но использует синтаксис подстановки файлов Unix для своих подстановочных знаков. Кроме того, GLOB чувствителен к регистру, в отличие от LIKE. И GLOB, и LIKE могут предшествовать ключевому слову NOT, чтобы изменить смысл теста. Инфиксный оператор GLOB реализуется путем вызова функции &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob ( &lt;i&gt;Y&lt;/i&gt; , &lt;i&gt;X&lt;/i&gt; )&lt;/a&gt; и может быть изменен путем переопределения этой функции.</target>
        </trans-unit>
        <trans-unit id="6bf488312da9736e109b0de15500f2677c1ccca1" translate="yes" xml:space="preserve">
          <source>The Geopoly Interface To The SQLite R*Tree Module</source>
          <target state="translated">Геополитический интерфейс к модулю R*Tree SQLite</target>
        </trans-unit>
        <trans-unit id="768b26bb16f751e006af08115829d3719bded2a3" translate="yes" xml:space="preserve">
          <source>The Geopoly module is an alternative interface to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; that uses the &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; notation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt;) to describe two-dimensional polygons. Geopoly includes functions for detecting when one polygon is contained within or overlaps with another, for computing the area enclosed by a polygon, for doing linear transformations of polygons, for rendering polygons as &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;, and other similar operations.</source>
          <target state="translated">Модуль Geopoly - это альтернативный интерфейс для &lt;a href=&quot;rtree&quot;&gt;расширения R-Tree,&lt;/a&gt; который использует нотацию &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt; ) для описания двумерных полигонов. Geopoly включает функции для определения того, когда один многоугольник содержится внутри или перекрывается с другим, для вычисления площади, заключенной в многоугольник, для выполнения линейных преобразований многоугольников, для визуализации многоугольников как &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt; и других подобных операций.</target>
        </trans-unit>
        <trans-unit id="a237ed77d23b0a3e93b7e807216496727ce2d486" translate="yes" xml:space="preserve">
          <source>The Geopoly module only understands a small subset of GeoJSON, but a critical subset. In particular, GeoJSON understands the JSON array of vertexes that describes a simple polygon.</source>
          <target state="translated">Модуль Geopoly понимает только небольшое подмножество GeoJSON,но является критическим подмножеством.В частности,GeoJSON понимает массив вершин JSON,который описывает простой многоугольник.</target>
        </trans-unit>
        <trans-unit id="be3160b95c10c837d23b555d2d76ced7f5c9c397" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer implementation is very simple. It splits the input text according to the ICU rules for finding word boundaries and discards any tokens that consist entirely of white-space. This may be suitable for some applications in some locales, but not all. If more complex processing is required, for example to implement stemming or discard punctuation, this can be done by creating a tokenizer implementation that uses the ICU tokenizer as part of its implementation.</source>
          <target state="translated">Реализация ICU-токенайзера очень проста.Он разделяет вводимый текст по правилам ICU для поиска границ слов и отбрасывает любые токены,полностью состоящие из белого пробела.Это может подойти для некоторых приложений в некоторых локалях,но не для всех.Если требуется более сложная обработка,например,для реализации препинания или отбрасывания знаков препинания,это можно сделать,создав реализацию токенайзера,использующего токенайзер ICU как часть своей реализации.</target>
        </trans-unit>
        <trans-unit id="a6ddce9bb57f20218d7a75f29be10f1ad340213b" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer is not available.</source>
          <target state="translated">Токенайзер ICU недоступен.</target>
        </trans-unit>
        <trans-unit id="975a07114fdeda8b12153b2d0d474cd1f76f40a8" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators</source>
          <target state="translated">Операторы ВХОДА и НЕ ВХОД</target>
        </trans-unit>
        <trans-unit id="ae86038950b2d471648c3c6d1b5cdb4844f71708" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators take an expression on the left and a list of values or a subquery on the right. When the right operand of an IN or NOT IN operator is a subquery, the subquery must have the same number of columns as there are columns in the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the left operand. The subquery on the right of an IN or NOT IN operator must be a scalar subquery if the left expression is not a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; expression. If the right operand of an IN or NOT IN operator is a list of values, each of those values must be scalars and the left expression must also be a scalar. The right-hand side of an IN or NOT IN operator can be a table</source>
          <target state="translated">Операторы IN и NOT IN принимают выражение слева и список значений или подзапрос справа. Когда правый операнд оператора IN или NOT IN является подзапросом, подзапрос должен иметь такое же количество столбцов, как и столбцов в &lt;a href=&quot;rowvalue&quot;&gt;значении строки&lt;/a&gt; левого операнда. Подзапрос справа от оператора IN или NOT IN должен быть скалярным подзапросом, если левое выражение не является выражением &lt;a href=&quot;rowvalue&quot;&gt;значения строки&lt;/a&gt; . Если правый операнд оператора IN или NOT IN является списком значений, каждое из этих значений должно быть скаляром, а левое выражение также должно быть скаляром. Правая часть оператора IN или NOT IN может быть таблицей.</target>
        </trans-unit>
        <trans-unit id="a79accc7fc2bc30ac0fead525b227ad7d9b1df52" translate="yes" xml:space="preserve">
          <source>The IN operator is now a candidate for optimization even if the left-hand side is not the left-most term of the index. Multiple IN operators can be used with the same index.</source>
          <target state="translated">Оператор IN теперь является кандидатом на оптимизацию,даже если левая сторона не является крайним левым членом индекса.С одним и тем же индексом можно использовать несколько операторов IN.</target>
        </trans-unit>
        <trans-unit id="84955ffcf9bdb1365dbcf57de003852e491d0f74" translate="yes" xml:space="preserve">
          <source>The IN-early-out optimization: When doing a look-up on a multi-column index and an IN operator is used on a column other than the left-most column, then if no rows match against the first IN value, check to make sure there exist rows that match the columns to the right before continuing with the next IN value.</source>
          <target state="translated">Оптимизация в начале:При выполнении поиска по многостолбцовому индексу и при использовании оператора IN в столбце,отличном от крайнего левого столбца,если ни одна строка не совпадает с первым значением IN,проверьте,есть ли строки,совпадающие со столбцами справа,прежде чем продолжать со следующим значением IN.</target>
        </trans-unit>
        <trans-unit id="c69ea675978574ca724f9055d892093e6e8c8e6f" translate="yes" xml:space="preserve">
          <source>The INDEXED BY Clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f2969be40943bb47a40ea44d17f6c5eac58206" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on DELETE statements within triggers.</source>
          <target state="translated">Оговорки,ЗАПИСАННЫЕ и НЕ ЗАПИСАННЫЕ,не допускаются к заявлениям об УДАЛЕНИИ в триггерах.</target>
        </trans-unit>
        <trans-unit id="f74b8a2cb9b68ac44cbe1110518350bde980f1d2" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on UPDATE statements within triggers.</source>
          <target state="translated">Оговорки,ЗАПИСАННЫЕ и НЕ ЗАПИСАННЫЕ,не допускаются к заявлениям об UPDATE внутри триггеров.</target>
        </trans-unit>
        <trans-unit id="b6f68ce27c8cff5cc2a071306e82e684ac57bb2a" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="translated">Предложения INDEXED BY и NOT INDEXED не поддерживаются для операторов &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c219f61fe4cd1e708d4fe79c89efa6776605815d" translate="yes" xml:space="preserve">
          <source>The INDEXED BY clause is &lt;em&gt;not&lt;/em&gt; intended for use in tuning the performance of a query. The intent of the INDEXED BY clause is to raise a run-time error if a schema change, such as dropping or creating an index, causes the query plan for a time-sensitive query to change. The INDEXED BY clause is designed to help detect undesirable query plan changes during regression testing. Application developers are admonished to omit all use of INDEXED BY during application design, implementation, testing, and tuning. If INDEXED BY is to be used at all, it should be inserted at the very end of the development process when &quot;locking down&quot; a design.</source>
          <target state="translated">Предложение INDEXED BY &lt;em&gt;не&lt;/em&gt; предназначено для использования при настройке производительности запроса. Назначение предложения INDEXED BY - вызвать ошибку времени выполнения, если изменение схемы, например удаление или создание индекса, вызывает изменение плана запроса для чувствительного ко времени запроса. Предложение INDEXED BY предназначено для помощи в обнаружении нежелательных изменений плана запроса во время регрессионного тестирования. Разработчикам приложений рекомендуется не использовать INDEXED BY во время разработки, внедрения, тестирования и настройки приложения. Если INDEXED BY вообще будет использоваться, он должен быть вставлен в самом конце процесса разработки, когда &amp;laquo;блокирует&amp;raquo; дизайн.</target>
        </trans-unit>
        <trans-unit id="2f4cc404750644d945353fc113cb9dba262e1c3b" translate="yes" xml:space="preserve">
          <source>The INDEXED BY phrase forces the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; to use a particular named index on a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. The INDEXED BY phrase is an SQLite extension and is not portable to other SQL database engines.</source>
          <target state="translated">Фраза INDEXED BY заставляет &lt;a href=&quot;optoverview&quot;&gt;планировщик запросов SQLite&lt;/a&gt; использовать конкретный именованный индекс в операторе &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; или &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; . Фраза INDEXED BY является расширением SQLite и не переносима на другие механизмы баз данных SQL.</target>
        </trans-unit>
        <trans-unit id="272773ebe8d5f9cc82e317b171f77d7379a1e581" translate="yes" xml:space="preserve">
          <source>The INSERT change remains in the changegroup. The values in the INSERT change are modified as if the row was inserted by the existing change and then updated according to the new change.</source>
          <target state="translated">Смена INSERT остается в группе изменений.Значения в изменении INSERT изменяются так,как если бы строка была вставлена существующим изменением,а затем обновляются в соответствии с новым изменением.</target>
        </trans-unit>
        <trans-unit id="110ff0538d0b835d343c6aa7fc9be56d02650901" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_master table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_master table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="translated">Вышеприведенный оператор INSERT добавляет в таблицу sqlite_master новую строку,определяющую таблицу &quot;t2&quot;,имеющую тот же формат на диске,что и индекс &quot;t1bc&quot;,и указывающую на то же самое b-дерево.После добавления этой записи в таблицу sqlite_master необходимо закрыть и снова открыть БД,чтобы SQLite смог перечитать схему.Затем можно запросить таблицу &quot;t2&quot;,чтобы увидеть содержимое индекса &quot;t1bc&quot;.</target>
        </trans-unit>
        <trans-unit id="cfe3ae8d2c81f2e60d52f407b340e91b2e1ca71c" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_schema table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_schema table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d21ad99ed5f4abc02a63a43ee6d040107fe785" translate="yes" xml:space="preserve">
          <source>The INSERT statement comes in three basic forms.</source>
          <target state="translated">Заявление ИНСЕРТ приходит в трех основных формах.</target>
        </trans-unit>
        <trans-unit id="47c4a334a3fe174333881ca555ae014ebc13040d" translate="yes" xml:space="preserve">
          <source>The INTERSECT operator for compound queries is implemented by creating two separate transient indices, each in a separate temporary file. The left and right subqueries are evaluated each into a separate transient index. Then the two indices are walked together and entries that appear in both indices are output.</source>
          <target state="translated">Оператор INTERSECT для составных запросов реализован путем создания двух отдельных индексов переходных процессов,каждый из которых находится в отдельном временном файле.Левый и правый подзапросы оцениваются каждый в отдельном временном файле.Затем эти два индекса проходят вместе и выводятся записи,которые появляются в обоих индексах.</target>
        </trans-unit>
        <trans-unit id="24b1f06632bef12995013965847655934cbf7975" translate="yes" xml:space="preserve">
          <source>The Idx1 index is scanned from top to bottom (or from bottom to top if &quot;ORDER BY fruit DESC&quot; is used) in order to find the rowids for each item in order by fruit. Then for each rowid, a binary search is done to lookup and output that row. In this way, the output appears in the requested order without the need to gather the entire output and sort it using a separate step.</source>
          <target state="translated">Индекс Idx1 сканируется сверху вниз (или снизу вверх,если используется &quot;ORDER BY fruit DESC&quot;)для того,чтобы найти рядки для каждого товара в порядке по фруктам.Затем для каждой строки выполняется двоичный поиск,чтобы найти и вывести эту строку.Таким образом,вывод выводится в запрошенном порядке без необходимости собирать весь вывод и сортировать его с помощью отдельного шага.</target>
        </trans-unit>
        <trans-unit id="2840ff0c49d75f050e9ec79f4cca0962bc4cd995" translate="yes" xml:space="preserve">
          <source>The JSON1 Extension</source>
          <target state="translated">Расширение JSON1</target>
        </trans-unit>
        <trans-unit id="9880ae6264f9c31927d61592bb6cec20147ead44" translate="yes" xml:space="preserve">
          <source>The LIKE operator can be made case sensitive using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="translated">Оператор LIKE можно сделать чувствительным к регистру с помощью &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;прагмы case_sensitive_like&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d553aca858e8d5460148027e2f586810cb9b2c44" translate="yes" xml:space="preserve">
          <source>The LIKE operator does a pattern matching comparison. The operand to the right of the LIKE operator contains the pattern and the left hand operand contains the string to match against the pattern. A percent symbol (&quot;%&quot;) in the LIKE pattern matches any sequence of zero or more characters in the string. An underscore (&quot;_&quot;) in the LIKE pattern matches any single character in the string. Any other character matches itself or its lower/upper case equivalent (i.e. case-insensitive matching). &lt;u&gt;Important Note:&lt;/u&gt; SQLite only understands upper/lower case for ASCII characters by default. The LIKE operator is case sensitive by default for unicode characters that are beyond the ASCII range. For example, the expression &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is TRUE but &lt;b&gt;'&amp;aelig;' LIKE '&amp;AElig;'&lt;/b&gt; is FALSE. The ICU extension to SQLite includes an enhanced version of the LIKE operator that does case folding across all unicode characters.</source>
          <target state="translated">Оператор LIKE выполняет сравнение сопоставления с образцом. Операнд справа от оператора LIKE содержит шаблон, а левый операнд содержит строку для сопоставления с шаблоном. Символ процента (&quot;%&quot;) в шаблоне LIKE соответствует любой последовательности из нуля или более символов в строке. Знак подчеркивания (&quot;_&quot;) в шаблоне LIKE соответствует любому одиночному символу в строке. Любой другой символ соответствует самому себе или его эквиваленту в нижнем / верхнем регистре (т. Е. Соответствие без учета регистра). &lt;u&gt;Важное примечание:&lt;/u&gt; SQLite по умолчанию понимает только верхний / нижний регистр для символов ASCII. Оператор LIKE по умолчанию чувствителен к регистру для символов Юникода, выходящих за пределы диапазона ASCII. Например, выражение &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; ИСТИННО, но &lt;b&gt;'&amp;aelig;' LIKE '&amp;AElig; '&lt;/b&gt;ЛОЖЬ. Расширение ICU для SQLite включает расширенную версию оператора LIKE, которая выполняет сворачивание регистра по всем символам Юникода.</target>
        </trans-unit>
        <trans-unit id="1dc39afda5c7dfd4c06c9ca219ccdec668d80d92" translate="yes" xml:space="preserve">
          <source>The LIKE operator has two modes that can be set by a &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma&lt;/a&gt;. The default mode is for LIKE comparisons to be insensitive to differences of case for latin1 characters. Thus, by default, the following expression is true:</source>
          <target state="translated">Оператор LIKE имеет два режима, которые могут быть установлены с помощью &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;прагмы&lt;/a&gt; . По умолчанию сравнения LIKE нечувствительны к различию в регистре символов latin1. Таким образом, по умолчанию верно следующее выражение:</target>
        </trans-unit>
        <trans-unit id="1212c823074bac84702844422e3c272b2bd97163" translate="yes" xml:space="preserve">
          <source>The LIKE operator is case insensitive by default because this is what the SQL standard requires. You can change the default behavior at compile time by using the &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt; command-line option to the compiler.</source>
          <target state="translated">Оператор LIKE по умолчанию нечувствителен к регистру, потому что этого требует стандарт SQL. Вы можете изменить поведение по умолчанию во время компиляции, используя &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;параметр&lt;/a&gt; командной строки SQLITE_CASE_SENSITIVE_LIKE для компилятора.</target>
        </trans-unit>
        <trans-unit id="974b1e3eeffaa9ed2ed23dfb8ae4c0123aeb3aed" translate="yes" xml:space="preserve">
          <source>The LIKE optimization might occur if the column named on the left of the operator is indexed using the built-in BINARY collating sequence and case_sensitive_like is turned on. Or the optimization might occur if the column is indexed using the built-in NOCASE collating sequence and the case_sensitive_like mode is off. These are the only two combinations under which LIKE operators will be optimized.</source>
          <target state="translated">Оптимизация LIKE может произойти,если колонка,названная слева от оператора,индексируется с использованием встроенной BINARY-коллидирующей последовательности и включена переменная case_sensitive_like.Или оптимизация может произойти,если столбец проиндексирован с использованием встроенной коллекционной последовательности NOCASE и выключен режим if_sensitive_like.Это единственные две комбинации,при которых будут оптимизированы операторы LIKE.</target>
        </trans-unit>
        <trans-unit id="93b8dceb670473d258369826a0e1bcdc46904ecc" translate="yes" xml:space="preserve">
          <source>The LIKE optimization was generating incorrect byte-code and hence getting the wrong answer if the left-hand operand has numeric affinity and the right-hand-side pattern is '/%' or if the pattern begins with the ESCAPE character. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b&lt;/a&gt;</source>
          <target state="translated">Оптимизация LIKE генерировала неправильный байт-код и, следовательно, получала неправильный ответ, если левый операнд имеет числовое сродство, а правый шаблон - '/%' или если шаблон начинается с символа ESCAPE. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50c934a9b19a46fe0d3c49a41fee7d1fdd7083c0" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="translated">Оптимизация LIKE будет предпринята только в том случае, если правая часть оператора GLOB или LIKE является либо буквальной строкой, либо &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром&lt;/a&gt; , &lt;a href=&quot;c3ref/bind_blob&quot;&gt;привязанным&lt;/a&gt; к строковому литералу. Строковый литерал не должен начинаться с подстановочного знака; если правая часть начинается с символа подстановки, то предпринимается попытка оптимизации. Если правая часть является &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром&lt;/a&gt; , привязанным к строке, то эта оптимизация выполняется только в том случае, если &lt;a href=&quot;c3ref/stmt&quot;&gt;подготовленный оператор,&lt;/a&gt; содержащий выражение, был скомпилирован с помощью &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; или &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; . Оптимизация LIKE не выполняется, если правая часть является &lt;a href=&quot;lang_expr#varparam&quot;&gt;параметром,&lt;/a&gt; а оператор был подготовлен с использованием&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; или &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75a37b85ec9af203958779031808e1e864da0987" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is not attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdfb505c18eab193b8701d8963abc89096358bd" translate="yes" xml:space="preserve">
          <source>The LIKE, GLOB, REGEXP, and MATCH operators</source>
          <target state="translated">Операторы LIKE,GLOB,REGEXP и MATCH.</target>
        </trans-unit>
        <trans-unit id="bd6f903f94d0893c11340df485d7ab2df47a60ff" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses (described below) are unsupported for DELETE statements within triggers.</source>
          <target state="translated">Оговорки LIMIT и ORDER BY (описанные ниже)не поддерживаются для заявлений об УДАЛЕНИИ внутри триггеров.</target>
        </trans-unit>
        <trans-unit id="ac40736f7c111bc231ce85d71233af9ca860229d" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses for UPDATE are unsupported within triggers, regardless of the compilation options used to build SQLite.</source>
          <target state="translated">Оговорки LIMIT и ORDER BY для UPDATE не поддерживаются в триггерах,независимо от опций компиляции,используемых для сборки SQLite.</target>
        </trans-unit>
        <trans-unit id="8e074183b71823eb43ac076c4294086172e78dd9" translate="yes" xml:space="preserve">
          <source>The LIMIT clause</source>
          <target state="translated">Оговорка LIMIT</target>
        </trans-unit>
        <trans-unit id="0504a702a97dc6330d2a4e4c66843d71b8b8976c" translate="yes" xml:space="preserve">
          <source>The LIMIT clause is used to place an upper bound on the number of rows returned by the entire SELECT statement.</source>
          <target state="translated">Оговорка LIMIT используется для того,чтобы поставить верхнюю границу на количество строк,возвращаемых полным заявлением SELECT.</target>
        </trans-unit>
        <trans-unit id="077d300ed4cc15ee3f95aa8d7373e80b1b912e57" translate="yes" xml:space="preserve">
          <source>The LIMIT clause now works on subselects</source>
          <target state="translated">Клаузула LIMIT теперь работает на подгруппах.</target>
        </trans-unit>
        <trans-unit id="243d546893ed2d7dba744bb55553e651413994ea" translate="yes" xml:space="preserve">
          <source>The LIMIT clause, if present, determines the maximum number of rows that will ever be added to the recursive table in step 2b. Once the limit is reached, the recursion stops. A limit of zero means that no rows are ever added to the recursive table, and a negative limit means an unlimited number of rows may be added to the recursive table.</source>
          <target state="translated">Оговорка LIMIT,если она присутствует,определяет максимальное количество строк,которые когда-либо будут добавлены в рекурсивную таблицу на шаге 2b.Как только лимит достигнут,рекурсия прекращается.Нулевой лимит означает,что ни одна строка никогда не будет добавлена в рекурсивную таблицу,а отрицательный лимит означает,что в рекурсивную таблицу может быть добавлено неограниченное количество строк.</target>
        </trans-unit>
        <trans-unit id="9ff51df664023512f948df1ac796d229e7d0e9d2" translate="yes" xml:space="preserve">
          <source>The LOCKING_STYLE extension is now enabled by default on Mac OS X</source>
          <target state="translated">Расширение LOCKING_STYLE теперь включено по умолчанию в Mac OS X.</target>
        </trans-unit>
        <trans-unit id="0d323fe988c47fdc7cf51035f151e1d7348afa80" translate="yes" xml:space="preserve">
          <source>The Lemon LALR(1) Parser Generator</source>
          <target state="translated">Генератор парсеров Lemon LALR(1)</target>
        </trans-unit>
        <trans-unit id="cac145bc2534e8394ef262506cd070ba23b13005" translate="yes" xml:space="preserve">
          <source>The Lemon source code was originally written as separate source files, and only later merged into a single &quot;lemon.c&quot; source file.</source>
          <target state="translated">Исходный код Lemon изначально был написан как отдельные исходные файлы,и только позже был объединен в один исходный файл &quot;lemon.c&quot;.</target>
        </trans-unit>
        <trans-unit id="f3666de7d407bd838db280e08d40dcf3369cd962" translate="yes" xml:space="preserve">
          <source>The MATCH operator is a special syntax for the match() application-defined function. The default match() function implementation raises an exception and is not really useful for anything. But extensions can override the match() function with more helpful logic.</source>
          <target state="translated">MATCH-оператор-это специальный синтаксис для функции,определяемой приложением match().Реализация функции match()по умолчанию вызывает исключение и ни к чему не приводит.Однако расширения могут переопределять функцию match()с более полезной логикой.</target>
        </trans-unit>
        <trans-unit id="42afa4f5f59a4dbd2c306334064e90d9b1a32220" translate="yes" xml:space="preserve">
          <source>The MATCH operator of a custom R*Tree query function must be a top-level AND-connected term of the WHERE clause, or else it will not be usable by the R*Tree query optimizer and the query will not be runnable. If the MATCH operator is connected to other terms of the WHERE clause via an OR operator, for example, the query will fail with an error.</source>
          <target state="translated">MATCH-оператор пользовательской функции R*Tree запроса должен быть И-связанным термином верхнего уровня пункта WHERE,иначе он не будет использоваться оптимизатором R*Tree запроса и запрос не будет запущен.Если,например,MATCH-оператор связан с другими терминами выражения &quot;WHERE&quot; через оператор &quot;ИЛИ&quot;,то запрос не будет выполнен с ошибкой.</target>
        </trans-unit>
        <trans-unit id="a59083e3614cc05a48a3bbb667742c5ff714f7ae" translate="yes" xml:space="preserve">
          <source>The MEMORY journaling mode stores the rollback journal in volatile RAM. This saves disk I/O but at the expense of database safety and integrity. If the application using SQLite crashes in the middle of a transaction when the MEMORY journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;.</source>
          <target state="translated">В режиме ведения журнала MEMORY журнал отката хранится в энергозависимой оперативной памяти. Это экономит дисковые операции ввода-вывода, но за счет безопасности и целостности базы данных. Если приложение, использующее SQLite, вылетает в середине транзакции, когда установлен режим журналирования MEMORY, то файл базы данных, скорее всего, &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;будет поврежден&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f83732bb3e32c92cf54961a7828a9a9bf48899eb" translate="yes" xml:space="preserve">
          <source>The MySQL UPDATE statement does not have just one target table like other systems. Any of the tables that participate in the join can be modified in the SET clause. The MySQL UPDATE syntax allows you to update multiple tables at once!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f3e583df88fe87cd750b4e8f9145cc25dd009e" translate="yes" xml:space="preserve">
          <source>The Mythical Man-Month</source>
          <target state="translated">Мифический Человек-Месяц</target>
        </trans-unit>
        <trans-unit id="47382a1ade54ee985c5d1e4d884a10d978c3d9d5" translate="yes" xml:space="preserve">
          <source>The NGQP has no way of knowing that TAGXREF_I1 is almost useless in this query, unless &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run on the database. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command gathers statistics on the quality of the various indexes and stores those statistics in &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; table. Having access to this statistical information, the NGQP easily chooses algorithm-1 as the best algorithm, by a wide margin.</source>
          <target state="translated">NGQP не имеет возможности узнать, что TAGXREF_I1 почти бесполезен в этом запросе, если &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; не был запущен в базе данных. Команда &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; собирает статистику качества различных индексов и сохраняет эту статистику в таблице &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; . Имея доступ к этой статистической информации, NGQP легко выбирает алгоритм-1 как лучший алгоритм с большим отрывом.</target>
        </trans-unit>
        <trans-unit id="143a4238d4916cb63313c4577ca26b997b836c83" translate="yes" xml:space="preserve">
          <source>The NGQP is almost always better than the legacy query planner. However, there may exist legacy applications that unknowingly depend on undefined and/or suboptimal behavior in the legacy query planner, and upgrading to the NGQP on those legacy applications could cause performance regressions. This risk is considered and a checklist is provided for reducing the risk and for fixing any issues that do arise.</source>
          <target state="translated">NGQP почти всегда лучше,чем старый планировщик запросов.Однако могут существовать устаревшие приложения,которые неосознанно зависят от неопределённого и/или неоптимального поведения планировщика устаревших запросов,и переход на NGQP на этих приложениях может вызвать регрессию производительности.Этот риск учитывается,и для уменьшения риска и исправления любых возникающих проблем предоставляется контрольный список.</target>
        </trans-unit>
        <trans-unit id="2965ed7439648bc6c724543a8009a196c9039cf3" translate="yes" xml:space="preserve">
          <source>The NGQP uses a new heuristic for seeking the best path through the graph: &quot;N Nearest Neighbors&quot; (hereafter &quot;N3&quot;). With N3, instead of choosing just one nearest neighbor for each step, the algorithm keeps track of the N bests paths at each step for some small integer N.</source>
          <target state="translated">NGQP использует новый эвристический метод для поиска наилучшего пути через график:&quot;Ближайшие соседи&quot; (здесь и далее &quot;N3&quot;).С N3,вместо того,чтобы выбирать только одного ближайшего соседа на каждом шаге,алгоритм отслеживает пути N-бестселлеров на каждом шаге для некоторого маленького целого N.</target>
        </trans-unit>
        <trans-unit id="0cc9ac5c6c19fb4a0c339daee645a66512bd3730" translate="yes" xml:space="preserve">
          <source>The NGQP will always find a good query plan as long as the schema does not contain indexes that have more than about 10 or 20 rows with the same value in the left-most column of the index.</source>
          <target state="translated">NGQP всегда найдет хороший план запроса до тех пор,пока схема не будет содержать индексов,содержащих более 10 или 20 строк с одинаковым значением в самом левом столбце индекса.</target>
        </trans-unit>
        <trans-unit id="64782e52a0662885b1e4e8b616fd2a06e03a36a9" translate="yes" xml:space="preserve">
          <source>The NGQP will always find an equal or better query plan, compared to prior query planners, as long as it has access to accurate &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; data in the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; file.</source>
          <target state="translated">NGQP всегда найдет план запроса равный или лучший по сравнению с предыдущими планировщиками запросов, если у него есть доступ к точным данным &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; в файле &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19150b2c84a3f9ff0a3cf33ed2fd4c984408dbd2" translate="yes" xml:space="preserve">
          <source>The NOCASE collation is like BINARY except that uppercase ASCII characters ('A' through 'Z') are folded into their lowercase equivalents prior to running the comparison. Only ASCII characters are case-folded. NOCASE does not implement a general purpose unicode caseless comparison.</source>
          <target state="translated">Сравнение NOCASE похоже на БИНАРИЙ,за исключением того,что прописные ASCII-символы (&quot;A&quot;-&quot;Z&quot;)перед началом сравнения складываются в их строчные эквиваленты.Символы ASCII складываются только в регистр.NOCASE не реализует сравнение без регистров в юникоде общего назначения.</target>
        </trans-unit>
        <trans-unit id="e84b5eaf17b803151297f975dc355cb961ea61cd" translate="yes" xml:space="preserve">
          <source>The NOT operator (or, if using the standard syntax, a unary &quot;-&quot; operator) may be used to compute the &lt;b&gt;relative complement&lt;/b&gt; of one set of documents with respect to another.</source>
          <target state="translated">Оператор НЕ (или, если используется стандартный синтаксис, унарный оператор &amp;laquo;-&amp;raquo;) может использоваться для вычисления &lt;b&gt;относительного дополнения&lt;/b&gt; одного набора документов по отношению к другому.</target>
        </trans-unit>
        <trans-unit id="0622850d3c0896e3d4a2cdc1368b8e7708693108" translate="yes" xml:space="preserve">
          <source>The NOT operator is not supported. Instead of the NOT operator, the standard query syntax supports a unary &quot;-&quot; operator that may be applied to basic term and term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix that has a unary &quot;-&quot; operator attached to it may not appear as an operand to an OR operator. An FTS query may not consist entirely of terms or term-prefix queries with unary &quot;-&quot; operators attached to them.</source>
          <target state="translated">Оператор НЕ поддерживается.Вместо оператора NOT стандартный синтаксис запроса поддерживает унарный оператор &quot;-&quot;,который может быть применен к базовым и префиксным запросам терминов (но не к запросам фраз или NEAR).Термин или термин-префикс,к которому прикреплен унарный оператор &quot;-&quot;,может не отображаться в виде операнда к оператору &quot;ИЛИ&quot;.Запрос ФСТ может состоять не полностью из терминов или терминов-префиксов с прикрепленными к ним унарными операторами &quot;-&quot;.</target>
        </trans-unit>
        <trans-unit id="92f10f8b9e2a034cee1135ad17b2a216a2126edd" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hence NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a314ee0d4a8c6c880fc2de97d4d977bd035a9e6" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hences NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="translated">Предикаты NULLS FIRST и NULLS LAST не поддерживаются для индексов. В &lt;a href=&quot;datatype3#sortorder&quot;&gt;целях сортировки&lt;/a&gt; SQLite считает значения NULL меньшими, чем все остальные значения. Значения NULL Hences всегда появляются в начале индекса ASC и в конце индекса DESC.</target>
        </trans-unit>
        <trans-unit id="df615076dd2b352c1767b46fb626e9bea1df01d8" translate="yes" xml:space="preserve">
          <source>The Next instruction increments the cursor to point to the next element in the table pointed to by cursor P0, and if it was successful branches to P2 (6, the beginning of the loop body). The Close instruction closes cursor P1. It doesn't affect the temporary storage list because it isn't associated with cursor P1; it is instead a global working list (which can be saved with ListPush).</source>
          <target state="translated">Следующая инструкция увеличивает курсор до точки,указывающей на следующий элемент в таблице,на который указывает курсор P0,и в случае успешной ветки до P2 (6,начало тела цикла).Инструкция Close закрывает курсор P1.Она не влияет на список временного хранения,так как не связана с курсором P1,а является глобальным рабочим списком (который можно сохранить с помощью ListPush).</target>
        </trans-unit>
        <trans-unit id="ead51814a41f1aee68f72130d432c2d7adca2550" translate="yes" xml:space="preserve">
          <source>The Next-Generation Query Planner</source>
          <target state="translated">Планировщик запросов следующего поколения</target>
        </trans-unit>
        <trans-unit id="72bb3fb56f491dbfd70c567055e36bba4fdf8c24" translate="yes" xml:space="preserve">
          <source>The ODP ZIP archive contains four different XML files: content.xml, styles.xml, meta.xml, and settings.xml. Those four files define the slide layout, text content, and styling. This particular presentation contains 62 images, ranging from full-screen pictures to tiny icons, each stored as a separate file in the Pictures folder. The &quot;mimetype&quot; file contains a single line of text that says:</source>
          <target state="translated">ZIP-архив ODP содержит четыре различных XML-файла:content.xml,styles.xml,meta.xml и settings.xml.Эти четыре файла определяют макет слайдов,текстовое содержание и стиль.Эта конкретная презентация содержит 62 изображения,от полноэкранных до крошечных иконок,каждое из которых хранится в отдельном файле в папке Pictures (Изображения).Файл &quot;mimetype&quot; содержит одну строку текста,которая гласит:</target>
        </trans-unit>
        <trans-unit id="bd2fb71eee9ad290a0e9bebe4f7b07ef57d97050" translate="yes" xml:space="preserve">
          <source>The OFF journaling mode disables the rollback journal completely. No rollback journal is ever created and hence there is never a rollback journal to delete. The OFF journaling mode disables the atomic commit and rollback capabilities of SQLite. The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command no longer works; it behaves in an undefined way. Applications must avoid using the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command when the journal mode is OFF. If the application crashes in the middle of a transaction when the OFF journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;. Without a journal, there is no way for a statement to unwind partially completed operations following a constraint error. This might also leave the database in a corrupted state. For example, if a duplicate entry causes a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; statement to fail half-way through, it will leave behind a partially created, and hence corrupt, index. Because OFF journaling mode allows the database file to be corrupted using ordinary SQL, it is disabled when &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; is enabled.</source>
          <target state="translated">Выключенный режим ведения журнала полностью отключает журнал отката. Журнал отката никогда не создается, и, следовательно, никогда не бывает журнала отката для удаления. Режим журналирования OFF отключает возможности атомарной фиксации и отката SQLite. Команда &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; больше не работает; он ведет себя неопределенным образом. Приложения не должны использовать команду &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK,&lt;/a&gt; когда режим журнала выключен. Если приложение выйдет из строя в середине транзакции, когда установлен режим журналирования OFF, то файл базы данных, скорее всего, &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;будет поврежден&lt;/a&gt; . Без журнала оператор не может открутить частично завершенные операции после ошибки ограничения. Это также может привести к повреждению базы данных. Например, если повторяющаяся запись вызывает&lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX, если&lt;/a&gt; на полпути произойдет сбой, останется частично созданный и, следовательно, поврежденный индекс. Так как режим журналирования OFF позволяет повреждать файл базы данных с помощью обычного SQL, он отключается, когда включен &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="374ba8e6eebafb57002a1dcdb7b0375a9e1ef0e6" translate="yes" xml:space="preserve">
          <source>The OFFSET clause, if it is present and has a positive value N, prevents the first N rows from being added to the recursive table. The first N rows are still processed by the recursive-select &amp;mdash; they just are not added to the recursive table. Rows are not counted toward fulfilling the LIMIT until all OFFSET rows have been skipped.</source>
          <target state="translated">Предложение OFFSET, если оно присутствует и имеет положительное значение N, предотвращает добавление первых N строк в рекурсивную таблицу. Первые N строк по-прежнему обрабатываются методом рекурсивного выбора - они просто не добавляются в рекурсивную таблицу. Строки не учитываются при выполнении LIMIT, пока не будут пропущены все строки OFFSET.</target>
        </trans-unit>
        <trans-unit id="0b277e3e2e965c40320745de00278d14c1b4c238" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT Clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549fba753f3ce9487855ba9f0e10547cd8338f25" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause applies to &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;, and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints. The ON CONFLICT algorithm does not apply to &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY constraints&lt;/a&gt;. There are five conflict resolution algorithm choices: ROLLBACK, ABORT, FAIL, IGNORE, and REPLACE. The default conflict resolution algorithm is ABORT. This is what they mean:</source>
          <target state="translated">Предложение ON CONFLICT применяется к ограничениям &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; , &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; , &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; и &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; . Алгоритм ON CONFLICT не применяется к &lt;a href=&quot;foreignkeys&quot;&gt;ограничениям FOREIGN KEY&lt;/a&gt; . Существует пять вариантов алгоритма разрешения конфликтов: ROLLBACK, ABORT, FAIL, IGNORE и REPLACE. Алгоритм разрешения конфликтов по умолчанию - ABORT. Вот что они означают:</target>
        </trans-unit>
        <trans-unit id="1bdda41615452e17b3f0971a7f023b71ba464bbb" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause described here has been a part of SQLite since before version 3.0.0 (2004-06-18). The phrase &quot;ON CONFLICT&quot; is also part of &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;, which is an extension to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; added in version 3.24.0 (2018-06-04). Do not confuse these two separate uses of the &quot;ON CONFLICT&quot; phrase.</source>
          <target state="translated">Описанное здесь предложение ON CONFLICT было частью SQLite еще до версии 3.0.0 (2004-06-18). Фраза &amp;laquo;ON CONFLICT&amp;raquo; также является частью &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; , который является расширением &lt;a href=&quot;lang_insert&quot;&gt;INSERT,&lt;/a&gt; добавленным в версии 3.24.0 (2018-06-04). Не путайте эти два разных употребления фразы &amp;laquo;В КОНФЛИКТЕ&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="cdcbfd707214ce0a425024950f0078c8093a672f" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause is a non-standard extension specific to SQLite that can appear in many other SQL commands. It is given its own section in this document because it is not part of standard SQL and therefore might not be familiar.</source>
          <target state="translated">Оговорка ON CONFLICT является нестандартным расширением,специфичным для SQLite,которое может появляться во многих других командах SQL.В данном документе ему дан свой раздел,поскольку оно не является частью стандартного SQL и поэтому может быть незнакомо.</target>
        </trans-unit>
        <trans-unit id="0b1442e3d6081cb327542a1dfef2a119f6cc8762" translate="yes" xml:space="preserve">
          <source>The ON DELETE and ON UPDATE action associated with each foreign key in an SQLite database is one of &quot;NO ACTION&quot;, &quot;RESTRICT&quot;, &quot;SET NULL&quot;, &quot;SET DEFAULT&quot; or &quot;CASCADE&quot;. If an action is not explicitly specified, it defaults to &quot;NO ACTION&quot;.</source>
          <target state="translated">Действие ON DELETE и ON UPDATE,связанное с каждым внешним ключом в базе данных SQLite,является одним из действий &quot;NO ACTION&quot;,&quot;RESTRICT&quot;,&quot;SET NULL&quot;,&quot;SET DEFAULT&quot; или &quot;CASCADE&quot;.Если действие явно не указано,по умолчанию оно имеет значение &quot;NO ACTION&quot;.</target>
        </trans-unit>
        <trans-unit id="6bf1202b648eb0b4a5f050a8c6d05340c107e859" translate="yes" xml:space="preserve">
          <source>The ON and USING clauses of an inner join are converted into additional terms of the WHERE clause prior to WHERE clause analysis described above in paragraph 1.0. Thus with SQLite, there is no computational advantage to use the newer SQL92 join syntax over the older SQL89 comma-join syntax. They both end up accomplishing exactly the same thing on inner joins.</source>
          <target state="translated">Оговорки ON и USING внутреннего соединения конвертируются в дополнительные условия пункта WHERE перед анализом пункта WHERE,описанным выше в пункте 1.0.Таким образом,в SQLite нет вычислительных преимуществ использования более нового синтаксиса SQL92 join по сравнению со старым синтаксисом SQL89 comma-join.В конечном итоге они оба достигают одного и того же на внутренних соединениях.</target>
        </trans-unit>
        <trans-unit id="bb4c3f3b3997cb8490367acdbc7718d009c8a562" translate="yes" xml:space="preserve">
          <source>The OR operator calculates the &lt;b&gt;union&lt;/b&gt; of two sets of documents.</source>
          <target state="translated">Оператор ИЛИ вычисляет &lt;b&gt;объединение&lt;/b&gt; двух наборов документов.</target>
        </trans-unit>
        <trans-unit id="4ba92a05446009b56fe03f1afc3e8240d551a35c" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization is not valid unless the inner-most IN operator loop is actually used by the query plan. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92&lt;/a&gt;.</source>
          <target state="translated">Оптимизация ORDER BY LIMIT недопустима, если только внутренний цикл оператора IN фактически не используется планом запроса. Исправление для билета &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8e2023ca7e681416d915e1d1b8f5b26d152e1f" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization might have caused an infinite loop in the byte code of the prepared statement under very obscure circumstances, due to a confluence of minor defects in the query optimizer. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt;</source>
          <target state="translated">Оптимизация ORDER BY LIMIT могла вызвать бесконечный цикл в байтовом коде подготовленного оператора при очень неясных обстоятельствах из-за совокупности мелких дефектов в оптимизаторе запросов. Исправление для билета &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b25ea5983496f08c601930c1bfec228ee9f65c25" translate="yes" xml:space="preserve">
          <source>The ORDER BY and LIMIT clauses on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements are not supported. ORDER BY and LIMIT are not normally supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; in any context but can be enabled for top-level statements using the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option. However, that compile-time option only applies to top-level &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements, not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements within triggers.</source>
          <target state="translated">Предложения ORDER BY и LIMIT в операторах &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; не поддерживаются. ORDER BY и LIMIT обычно не поддерживаются для &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; или &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; в любом контексте, но могут быть включены для операторов верхнего уровня с помощью параметра &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_UPDATE_DELETE_LIMIT . Тем не менее, этот вариант компиляции применяется только для верхнего уровня &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; заявления, а не &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; и &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; заявления внутри триггеров.</target>
        </trans-unit>
        <trans-unit id="3cfee8a3cdd0f5ece05fc4719284d9ca35cb1ece" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause</source>
          <target state="translated">ЗАКАЗКА ЗАЯВЛЕНИЯ ЗАКАЗЧИКОМ</target>
        </trans-unit>
        <trans-unit id="30dc9fe3a4d009f8e23f54fc9886804eb6fd68d9" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on a DELETE statement is used only to determine which rows fall within the LIMIT. The order in which rows are deleted is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">Пункт ЗАКАЗАТЬ ПО ЗАКАЗУ в заявлении об УДАЛЕНИИ используется только для того,чтобы определить,какие строки попадают под ОГРАНИЧЕНИЕ.Порядок,в котором удаляются строки,является произвольным и на него не влияет пункт ЗАКАЗАТЬ ПО.</target>
        </trans-unit>
        <trans-unit id="838347206eac0478c704f6fe626059a265388ac1" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on an UPDATE statement is used only to determine which rows fall within the LIMIT. The order in which rows are modified is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="translated">Пункт &quot;ЗАКАЗАТЬ ПО&quot; в операторе UPDATE используется только для того,чтобы определить,какие строки попадают в LIMIT.Порядок,в котором строки изменяются,является произвольным и не подвержен влиянию пункта &quot;ЗАКАЗАТЬ ПО&quot;.</target>
        </trans-unit>
        <trans-unit id="db6946cde6c76ae16df632182494e97889b98107" translate="yes" xml:space="preserve">
          <source>The OS Interface - also called the &quot;VFS&quot; - is what makes SQLite portable across operating systems. Whenever any of the other modules in SQLite needs to communicate with the operating system, they invoke methods in the VFS. The VFS then invokes the operating-specific code needed to satisfy the request. Hence, porting SQLite to a new operating system is simply a matter of writing a new OS interface layer or &quot;VFS&quot;.</source>
          <target state="translated">Интерфейс операционной системы-также называемый &quot;VFS&quot;-это то,что делает SQLite портативным для всех операционных систем.Всякий раз,когда какому-либо из других модулей SQLite необходимо взаимодействовать с операционной системой,они ссылаются на методы в VFS.Затем VFS вызывает специфический для работы код,необходимый для удовлетворения запроса.Следовательно,перенос SQLite на новую операционную систему-это просто вопрос написания нового уровня интерфейса операционной системы или &quot;VFS&quot;.</target>
        </trans-unit>
        <trans-unit id="61b9ed4bbd7c64412bf999ddb3735b90a9006325" translate="yes" xml:space="preserve">
          <source>The OS interface layer has been completely reworked:</source>
          <target state="translated">Интерфейсный уровень ОС был полностью переработан:</target>
        </trans-unit>
        <trans-unit id="7db34215d6389d29f797bd445ad557bb97d4d35b" translate="yes" xml:space="preserve">
          <source>The OVER clause is required for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; and is prohibited otherwise. The DISTINCT keyword is only allowed in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;. The FILTER clause may not appear on a &lt;a href=&quot;lang_corefunc&quot;&gt;simple function&lt;/a&gt;.</source>
          <target state="translated">Предложение OVER требуется для &lt;a href=&quot;windowfunctions&quot;&gt;оконных функций&lt;/a&gt; и запрещено в противном случае. Ключевое слово DISTINCT разрешено только в &lt;a href=&quot;lang_aggfunc&quot;&gt;агрегатных функциях&lt;/a&gt; . Предложение FILTER может не появляться в &lt;a href=&quot;lang_corefunc&quot;&gt;простой функции&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97086bd49779ce0aff6b3d28109cebe94640094e" translate="yes" xml:space="preserve">
          <source>The OpenDocument file format is used for office applications: word processors, spreadsheets, and presentations. It was originally designed for the OpenOffice suite but has since been incorporated into other desktop application suites. The OpenOffice application has been forked and renamed a few times. This author's primary use for OpenDocument is building slide presentations with either &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt; on Mac, or &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt; on Linux and Windows.</source>
          <target state="translated">Формат файла OpenDocument используется для офисных приложений: текстовых редакторов, электронных таблиц и презентаций. Первоначально он был разработан для пакета OpenOffice, но с тех пор был включен в другие наборы настольных приложений. Приложение OpenOffice было разветвлено и переименовано несколько раз. Основное использование этим автором OpenDocument - создание слайд-презентаций с помощью &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt; на Mac или &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt; в Linux и Windows.</target>
        </trans-unit>
        <trans-unit id="a12f97809890d0843d3b379960cdb5a48586d66d" translate="yes" xml:space="preserve">
          <source>The P parameter in sqlite3_create_filename(D,J,W,N,P) should be an array of 2*N pointers to strings. Each pair of pointers in this array corresponds to a key and value for a query parameter. The P parameter may be a NULL pointer if N is zero. None of the 2*N pointers in the P array may be NULL pointers and key pointers should not be empty strings. None of the D, J, or W parameters to sqlite3_create_filename(D,J,W,N,P) may be NULL pointers, though they can be empty strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e13d51d1ef218d337ca9fb917ffdb16cbc244df" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. If P1 is not open then the behavior is undefined.</source>
          <target state="translated">Курсор P1 должен быть для реальной таблицы,а не для псевдо-таблицы.Если P1 не открыт,то поведение не определено.</target>
        </trans-unit>
        <trans-unit id="5b81ca2502b2715c59c443936643d2e3be1132fa" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. P1 must have been opened prior to this opcode or the program will segfault.</source>
          <target state="translated">Курсор P1 должен быть для реальной таблицы,а не для псевдо-таблицы.P1 должен быть открыт до этого опкода,иначе программа будет сегментирована.</target>
        </trans-unit>
        <trans-unit id="607ac7f84bdc4d441c6cb285c55a825dad256470" translate="yes" xml:space="preserve">
          <source>The P1 parameter is not actually used by this opcode. However, it is sometimes set to 1 instead of 0 as a hint to the command-line shell that this &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; is the bottom of a loop and that the lines from P2 down to the current line should be indented for EXPLAIN output.</source>
          <target state="translated">Параметр P1 фактически не используется этим кодом операции. Однако иногда он устанавливается в 1 вместо 0 в качестве подсказки оболочке командной строки, что этот &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; является нижней частью цикла и что строки от P2 до текущей строки должны иметь отступ для вывода EXPLAIN.</target>
        </trans-unit>
        <trans-unit id="28dbb0803ca5b349efaf91bc329608b765d512d1" translate="yes" xml:space="preserve">
          <source>The P3 argument of instruction 11 is of particular interest. The sort key is formed by prepending one character from P3 to each string and concatenating all the strings. The sort comparison function will look at this character to determine whether the sort order is ascending or descending, and whether to sort as a string or number. In this example, the first column should be sorted as a string in descending order so its prefix is &quot;D&quot; and the second column should sorted numerically in ascending order so its prefix is &quot;+&quot;. Ascending string sorting uses &quot;A&quot;, and descending numeric sorting uses &quot;-&quot;.</source>
          <target state="translated">Особый интерес представляет аргумент P3 инструкции 11.Ключ сортировки формируется путем префиксации одного символа из P3 к каждой строке и конкапсуляции всех строк.Функция сравнения сортировки посмотрит на этот символ,чтобы определить,идет ли порядок сортировки по возрастанию или по убыванию,и сортировать ли его как строку или число.В данном примере первый столбец должен быть отсортирован как строка в порядке убывания,поэтому его префикс-&quot;D&quot;,а второй столбец должен быть отсортирован численно в порядке возрастания,поэтому его префикс-&quot;+&quot;.Сортировка по возрастанию строки использует &quot;A&quot;,а по убыванию-&quot;-&quot;.</target>
        </trans-unit>
        <trans-unit id="55ff312bc89d3e83256edc55b23ecd77e64741ac" translate="yes" xml:space="preserve">
          <source>The P3 value is a hint to the btree implementation. If P3==1, that means P1 is an SQL index and that this instruction could have been omitted if that index had been unique. P3 is usually 0. P3 is always either 0 or 1.</source>
          <target state="translated">Значение P3 является подсказкой к реализации btree.Если P3==1,то это значит,что P1-это SQL-индекс,и что эту инструкцию можно было бы опустить,если бы этот индекс был уникальным.P3 обычно равен 0,P3 всегда либо 0,либо 1.</target>
        </trans-unit>
        <trans-unit id="f0f52e542da01be92f32d06abf2506b4a2d4f31b" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY or ROWID. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID on the P1 index.</source>
          <target state="translated">Значения регистров P4, начинающиеся с P3, образуют распакованный индексный ключ, в котором отсутствует ПЕРВИЧНЫЙ КЛЮЧ или ROWID. &lt;a href=&quot;opcode#Compare&quot;&gt;Сравните&lt;/a&gt; это значение ключа с индексом, на который в настоящее время указывает P1, игнорируя PRIMARY KEY или ROWID в индексе P1.</target>
        </trans-unit>
        <trans-unit id="4c2c023857d26616de9f3d4b0976bd5072c920ee" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID fields at the end.</source>
          <target state="translated">Значения регистра P4, начинающиеся с P3, образуют распакованный индексный ключ, в котором отсутствует ПЕРВИЧНЫЙ КЛЮЧ. &lt;a href=&quot;opcode#Compare&quot;&gt;Сравните&lt;/a&gt; это значение ключа с индексом, на который в настоящее время указывает P1, игнорируя поля PRIMARY KEY или ROWID в конце.</target>
        </trans-unit>
        <trans-unit id="19d27257909a32ae5401b59e606c768db9ed4065" translate="yes" xml:space="preserve">
          <source>The P4 value may be either an integer (P4_INT32) or a pointer to a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo object, then table being opened must be an &lt;a href=&quot;fileformat2#btypes&quot;&gt;index b-tree&lt;/a&gt; where the KeyInfo object defines the content and collating sequence of that index b-tree. Otherwise, if P4 is an integer value, then the table being opened must be a &lt;a href=&quot;fileformat2#btypes&quot;&gt;table b-tree&lt;/a&gt; with a number of columns no less than the value of P4.</source>
          <target state="translated">Значение P4 может быть целым числом (P4_INT32) или указателем на структуру KeyInfo (P4_KEYINFO). Если это указатель на объект KeyInfo, то открываемая таблица должна быть &lt;a href=&quot;fileformat2#btypes&quot;&gt;индексным b-деревом,&lt;/a&gt; где объект KeyInfo определяет содержимое и последовательность сортировки этого индексного b-дерева. В противном случае, если P4 является целочисленным значением, то открываемая таблица должна быть &lt;a href=&quot;fileformat2#btypes&quot;&gt;b-деревом таблицы&lt;/a&gt; с числом столбцов не меньше, чем значение P4.</target>
        </trans-unit>
        <trans-unit id="21923e08794e63280a41a6b5f859992f400d98cc" translate="yes" xml:space="preserve">
          <source>The P5 arguments are taken from register P2 and its successors.</source>
          <target state="translated">Аргументы P5 взяты из регистра P2 и его преемников.</target>
        </trans-unit>
        <trans-unit id="6017964a6129b7a7e8f6a3da3f0784c73d2078ba" translate="yes" xml:space="preserve">
          <source>The P5 parameter can be a mask of the BTREE_* flags defined in btree.h. These flags control aspects of the operation of the btree. The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are added automatically.</source>
          <target state="translated">Параметр P5 может быть маской флагов BTREE_*,определенных в btree.h.Эти флаги управляют аспектами работы btree.Флаги BTREE_OMIT_JOURNAL и BTREE_SINGLE добавляются автоматически.</target>
        </trans-unit>
        <trans-unit id="3f1c0ff5695ef10ade1f6c3734423a4eb3077d3e" translate="yes" xml:space="preserve">
          <source>The PERSIST journaling mode prevents the rollback journal from being deleted at the end of each transaction. Instead, the header of the journal is overwritten with zeros. This will prevent other database connections from rolling the journal back. The PERSIST journaling mode is useful as an optimization on platforms where deleting or truncating a file is much more expensive than overwriting the first block of a file with zeros. See also: &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; and &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;.</source>
          <target state="translated">Режим ведения журнала PERSIST предотвращает удаление журнала отката в конце каждой транзакции. Вместо этого заголовок журнала перезаписывается нулями. Это предотвратит откат журнала для других подключений к базе данных. Режим журналирования PERSIST полезен в качестве оптимизации на платформах, где удаление или усечение файла намного дороже, чем перезапись первого блока файла нулями. См. Также: &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; и &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="161bece08ac2f5702ce5212ddbeeb1a41f2dbaee" translate="yes" xml:space="preserve">
          <source>The PLINK table holds parent-child relationships between check-ins. The TAGXREF table maps tags into check-ins. For reference, the relevant portions of the schemas for these two tables is shown here:</source>
          <target state="translated">Таблица PLINK содержит отношения между родителями и детьми.Таблица TAGXREF сопоставляет теги с контрольными элементами.Для справки,здесь показаны соответствующие части схем для этих двух таблиц:</target>
        </trans-unit>
        <trans-unit id="e4bd8ba431ab4e0d31722f8db284b8bb979b0c36" translate="yes" xml:space="preserve">
          <source>The PRAGMA statement is an SQL extension specific to SQLite and used to modify the operation of the SQLite library or to query the SQLite library for internal (non-table) data. The PRAGMA statement is issued using the same interface as other SQLite commands (e.g. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;) but is different in the following important respects:</source>
          <target state="translated">Оператор PRAGMA - это расширение SQL, специфичное для SQLite, которое используется для изменения работы библиотеки SQLite или для запроса библиотеки SQLite для внутренних (не табличных) данных. Оператор PRAGMA выполняется с использованием того же интерфейса, что и другие команды SQLite (например, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ), но отличается в следующих важных отношениях:</target>
        </trans-unit>
        <trans-unit id="c66b0cfca97f029db26ea6f18637a49f7fab6a97" translate="yes" xml:space="preserve">
          <source>The PRAGMA synchronous=off statement now disables syncing of the master journal file in addition to the normal rollback journals</source>
          <target state="translated">Оператор PRAGMA synchronous=off теперь отключает синхронизацию главного файла журнала в дополнение к обычным журналам отката</target>
        </trans-unit>
        <trans-unit id="b37fa685a4763fe504598bdda8b4b2f3d3eef491" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY constraint for a rowid table (as long as it is not the true primary key or INTEGER PRIMARY KEY) is really the same thing as a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt;. Because it is not a true primary key, columns of the PRIMARY KEY are allowed to be NULL, in violation of all SQL standards.</source>
          <target state="translated">Ограничение PRIMARY KEY для таблицы rowid (если это не истинный первичный ключ или INTEGER PRIMARY KEY) на самом деле то же самое, что и &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;ограничение UNIQUE&lt;/a&gt; . Поскольку это не настоящий первичный ключ, столбцы PRIMARY KEY могут иметь значение NULL, что нарушает все стандарты SQL.</target>
        </trans-unit>
        <trans-unit id="ebe8c7b0a4b69dc3800a6f41776c565d6842c281" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY values identifying the modified row,</source>
          <target state="translated">Значения PRIMARY KEY определяют модифицированную строку,</target>
        </trans-unit>
        <trans-unit id="90caad2286223b2e029c8d716238518e674a76d1" translate="yes" xml:space="preserve">
          <source>The Page Cache</source>
          <target state="translated">Кэш страниц</target>
        </trans-unit>
        <trans-unit id="1f5eb567adef7decaf2acc8e4aa86ec1481f2a20" translate="yes" xml:space="preserve">
          <source>The PostgreSQL and MySQL servers used were as delivered by default on RedHat 7.2. (PostgreSQL version 7.1.3 and MySQL version 3.23.41.) No effort was made to tune these engines. Note in particular the default MySQL configuration on RedHat 7.2 does not support transactions. Not having to support transactions gives MySQL a big speed advantage, but SQLite is still able to hold its own on most tests.</source>
          <target state="translated">Используемые серверы PostgreSQL и MySQL по умолчанию поставлялись на RedHat 7.2.(PostgreSQL версии 7.1.3 и MySQL версии 3.23.41.)Настройка этих движков не производилась.Обратите внимание,в частности,что конфигурация MySQL по умолчанию на RedHat 7.2 не поддерживает транзакции.Отсутствие поддержки транзакций дает MySQL большое преимущество в скорости,но SQLite все еще способен держать себя в руках на большинстве тестов.</target>
        </trans-unit>
        <trans-unit id="3d04a38a1d2743c1862a6cfdba60ded14ba2896a" translate="yes" xml:space="preserve">
          <source>The PutIntKey instruction (also described during the discussion about INSERT) writes an entry into the database file whose data is the top of the stack and whose key is the next on the stack, and then pops the stack twice. The PutIntKey instruction will overwrite the data of an existing record with the same key, which is what we want here. Overwriting was not an issue with INSERT because with INSERT the key was generated by the NewRecno instruction which is guaranteed to provide a key that has not been used before.</source>
          <target state="translated">Инструкция PutIntKey (также описанная во время обсуждения INSERT)записывает в файл базы данных запись,данные которой являются верхней частью стека,а ключ-следующей частью стека,после чего дважды выпадает стек.Инструкция PutIntKey перезапишет данные существующей записи тем же ключом,что и здесь.Перезапись не была проблемой с INSERT,потому что с INSERT ключ был сгенерирован командой NewRecno,которая гарантированно предоставит ключ,который раньше не использовался.</target>
        </trans-unit>
        <trans-unit id="7408173a3218822a3bb6af7f7e3d86be256cefca" translate="yes" xml:space="preserve">
          <source>The QPSG is disabled by default. It can be enabled at compile-time using the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option, or at run-time by invoking &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;,1,0).</source>
          <target state="translated">По умолчанию QPSG отключен. Его можно включить во время компиляции с помощью параметра &lt;a href=&quot;compile#enable_qpsg&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_QPSG или во время выполнения, вызвав &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; , 1,0).</target>
        </trans-unit>
        <trans-unit id="7ff5d03d1a40249005abd9682f890ac5af94c96e" translate="yes" xml:space="preserve">
          <source>The QPSG means that if all of your queries run efficiently during testing, and if your application does not change the schema, then SQLite will not suddenly decide to start using a different query plan, possibly causing a performance problem, after your application is released to users. If your application works in the lab, it will continue working the same way after deployment.</source>
          <target state="translated">QPSG означает,что если все ваши запросы будут эффективно выполняться во время тестирования,и если ваше приложение не изменит схему,то SQLite не примет внезапного решения начать использовать другой план запросов,что может привести к проблемам с производительностью,после того,как ваше приложение будет выпущено для пользователей.Если ваше приложение работает в лаборатории,оно будет продолжать работать так же после развертывания.</target>
        </trans-unit>
        <trans-unit id="e7c6137b874e291f7e936bf89d2438f289c1e9a2" translate="yes" xml:space="preserve">
          <source>The R-Tree concept originated with &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt;: &lt;em&gt;R-Trees: A Dynamic Index Structure for Spatial Searching&lt;/em&gt;, Proc. 1984 ACM SIGMOD International Conference on Management of Data, pp. 47-57. The implementation found in SQLite is a refinement of Guttman's original idea, commonly called &quot;R*Trees&quot;, that was described by Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger: &lt;em&gt;The R*-Tree: An Efficient and Robust Access Method for Points and Rectangles.&lt;/em&gt; SIGMOD Conference 1990: 322-331.</source>
          <target state="translated">Концепция R-Tree возникла у &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Тони Гуттмана&lt;/a&gt; : &lt;em&gt;R-Trees: динамическая структура индекса для пространственного поиска&lt;/em&gt; , Proc. 1984 ACM SIGMOD Международная конференция по управлению данными, стр. 47-57. Реализация, найденная в SQLite, является усовершенствованием оригинальной идеи Гуттмана, обычно называемой &amp;laquo;R * Trees&amp;raquo;, которая была описана Норбертом Бекманном, Гансом-Петером Кригелем, Ральфом Шнайдером, Бернхардом &lt;em&gt;Зигером: R * -Tree: эффективный и надежный доступ Метод точек и прямоугольников.&lt;/em&gt; Конференция SIGMOD 1990: 322-331.</target>
        </trans-unit>
        <trans-unit id="5d3074807f0a652cf6707800a925f23953d72a9a" translate="yes" xml:space="preserve">
          <source>The RAISE() function</source>
          <target state="translated">Функция RAISE()</target>
        </trans-unit>
        <trans-unit id="c69d2de0461d9e5577928a8a0c182e55c377b7ea" translate="yes" xml:space="preserve">
          <source>The RBU Extension</source>
          <target state="translated">Расширение RBU</target>
        </trans-unit>
        <trans-unit id="f271a1dcb4b99763d2ff19003d2b360191882c40" translate="yes" xml:space="preserve">
          <source>The RBU database table contains a single row for each target database row inserted, updated or deleted by the update. Populating the RBU database tables is described in &lt;a href=&quot;rbu#database_contents&quot;&gt;the following section&lt;/a&gt;.</source>
          <target state="translated">Таблица базы данных RBU содержит одну строку для каждой строки целевой базы данных, вставленной, обновленной или удаленной обновлением. Заполнение таблиц базы данных RBU описано в &lt;a href=&quot;rbu#database_contents&quot;&gt;следующем разделе&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5b9dd90a4d99e081d94181c982214ebaab88f1ab" translate="yes" xml:space="preserve">
          <source>The RBU extension interface allows an application to apply an RBU update stored in an RBU database to an existing target database. The procedure is as follows:</source>
          <target state="translated">Интерфейс расширения RBU позволяет приложению применять обновление RBU,хранящееся в базе данных RBU,к существующей целевой базе данных.Процедура выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="fb0cbd808e0878559e4326851133fccc2e2e33dd" translate="yes" xml:space="preserve">
          <source>The RBU extension is an add-on for SQLite designed for use with large SQLite database files on low-power devices at the edge of a network. RBU may be used for two separate tasks:</source>
          <target state="translated">Расширение RBU является надстройкой для SQLite,предназначенной для использования с большими файлами базы данных SQLite на маломощных устройствах на границе сети.RBU может использоваться для двух отдельных задач:</target>
        </trans-unit>
        <trans-unit id="dc51cf7dfcbe19fae28d177efed486cafebfaa37" translate="yes" xml:space="preserve">
          <source>The RBU extension is not enabled by default. To enable it, compile the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; with the &lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt; compile-time option.</source>
          <target state="translated">Расширение RBU не включено по умолчанию. Чтобы включить его, скомпилируйте &lt;a href=&quot;amalgamation&quot;&gt;объединение&lt;/a&gt; с параметром &lt;a href=&quot;compile#enable_rbu&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ENABLE_RBU .</target>
        </trans-unit>
        <trans-unit id="0d487cd05415f0ab5a85f8a6d6877a414f0dad6c" translate="yes" xml:space="preserve">
          <source>The RBU update will not detect or prevent foreign key or CHECK constraint violations.</source>
          <target state="translated">Обновление RBU не выявит и не предотвратит нарушения иностранных ключей или ограничений CHECK.</target>
        </trans-unit>
        <trans-unit id="593961271c55fed248c83e9d463fa6fd9e121437" translate="yes" xml:space="preserve">
          <source>The RBU update will not fire any triggers.</source>
          <target state="translated">Обновление RBU не будет запускать никаких триггеров.</target>
        </trans-unit>
        <trans-unit id="c6564cc776de2c808e8f2b66fc117a6728b91dc4" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e251943a38b26d445d7abf3f883e482037ceab" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="translated">Оператор REGEXP - это специальный синтаксис для пользовательской функции regexp (). По умолчанию пользовательская функция regexp () не определена, поэтому использование оператора REGEXP обычно приводит к сообщению об ошибке. Если определяемая &lt;a href=&quot;c3ref/create_function&quot;&gt;приложением функция SQL с&lt;/a&gt; именем &quot;regexp&quot; добавляется во время выполнения, то &quot;</target>
        </trans-unit>
        <trans-unit id="f6504d5094ffa58be5ab1ac79df65f0b1aba5e47" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed, or when there are &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt; involving a function whose definition has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a60389a484988aa39c6d8ad03d71480c4d40ec6" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed.</source>
          <target state="translated">Команда REINDEX используется для удаления и воссоздания индексов с нуля.Это полезно,когда изменилось определение последовательности сравнения.</target>
        </trans-unit>
        <trans-unit id="26337c24aa4b0f0ab8be7c9f3c788f1a63917d77" translate="yes" xml:space="preserve">
          <source>The REINDEX command was added.</source>
          <target state="translated">Добавлена команда REINDEX.</target>
        </trans-unit>
        <trans-unit id="25bdb1a8b2079e760c4eabb862683c2777d36a53" translate="yes" xml:space="preserve">
          <source>The RELEASE command is like a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; for a SAVEPOINT. The RELEASE command causes all savepoints back to and including the most recent savepoint with a matching name to be removed from the transaction stack. The RELEASE of an inner transaction does not cause any changes to be written to the database file; it merely removes savepoints from the transaction stack such that it is no longer possible to ROLLBACK TO those savepoints. If a RELEASE command releases the outermost savepoint, so that the transaction stack becomes empty, then RELEASE is the same as &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command may be used to release all savepoints and commit the transaction even if the transaction was originally started by a SAVEPOINT command instead of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="translated">Команда RELEASE похожа на &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; для SAVEPOINT. Команда RELEASE заставляет все точки сохранения вернуться к самой последней точке сохранения с совпадающим именем, включая ее удаление из стека транзакций. RELEASE внутренней транзакции не вызывает записи каких-либо изменений в файл базы данных; он просто удаляет точки сохранения из стека транзакций, так что ОТКАТ к этим точкам больше невозможен. Если команда RELEASE освобождает самую внешнюю точку сохранения, так что стек транзакции становится пустым, то RELEASE совпадает с &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; . &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; команда может быть использована , чтобы освободить все точки сохранения и совершить сделку , даже если сделка была изначально командой SAVEPOINT вместо того , чтобы &lt;a href=&quot;lang_transaction&quot;&gt;НАЧАТЬ&lt;/a&gt; команда.</target>
        </trans-unit>
        <trans-unit id="2ca08634243012d2e2bc4d0598e7fea902f6787a" translate="yes" xml:space="preserve">
          <source>The RELEASE command starts with the most recent addition to the transaction stack and releases savepoints backwards in time until it releases a savepoint with a matching savepoint-name. Prior savepoints, even savepoints with matching savepoint-names, are unchanged. If the RELEASE command causes the transaction stack to become empty (if the RELEASE command releases the outermost transaction from the stack) then the transaction commits.</source>
          <target state="translated">Команда RELEASE начинается с последнего добавления в стек транзакций и освобождает точки сохранения назад по времени,пока не освободит точку сохранения с совпадающим именем точки сохранения.Предыдущие точки сохранения,даже точки сохранения с совпадающими именами,остаются неизменными.Если команда RELEASE приводит к тому,что стек транзакций становится пустым (если команда RELEASE освобождает самую внешнюю транзакцию из стека),то транзакция фиксируется.</target>
        </trans-unit>
        <trans-unit id="00402a1bc7f00a30656be0c0b84db4535fdee37b" translate="yes" xml:space="preserve">
          <source>The RENAME COLUMN TO syntax changes the column-name of table table-name into new-column-name. The column name is changed both within the table definition itself and also within all indexes, triggers, and views that reference the column. If the column name change would result in a semantic ambiguity in a trigger or view, then the RENAME COLUMN fails with an error and no changes are applied.</source>
          <target state="translated">Синтаксис RENAME COLUMN TO изменяет название столбца таблицы на новое название столбца.Имя столбца изменяется как внутри самого определения таблицы,так и внутри всех индексов,триггеров и представлений,на которые ссылается столбец.Если изменение имени столбца приведет к семантической неоднозначности в триггере или представлении,то ОГРАНИЧЕНИЕ РЕМЕНА не удается с ошибкой и никакие изменения не применяются.</target>
        </trans-unit>
        <trans-unit id="4fd18ba9ff83bdc2461dca0a5dcb6bdcec775c80" translate="yes" xml:space="preserve">
          <source>The RENAME TO syntax changes the name of table-name to new-table-name. This command cannot be used to move a table between attached databases, only to rename a table within the same database. If the table being renamed has triggers or indices, then these remain attached to the table after it has been renamed.</source>
          <target state="translated">Синтаксис RENAME TO изменяет имя таблицы на новое имя таблицы.Данная команда не может быть использована для перемещения таблицы между подключенными БД,а только для переименования таблицы внутри одной и той же БД.Если переименовываемая таблица имеет триггеры или индексы,то после переименования они остаются прикрепленными к таблице.</target>
        </trans-unit>
        <trans-unit id="802816683a1617052efa11363c7e7856de219468" translate="yes" xml:space="preserve">
          <source>The REPLACE command is an alias for the &quot;&lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt;&quot; variant of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command. This alias is provided for compatibility other SQL database engines. See the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command documentation for additional information.</source>
          <target state="translated">Команда REPLACE - это псевдоним для варианта &lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt; команды &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; . Этот псевдоним предоставляется для совместимости с другими механизмами баз данных SQL. См &lt;a href=&quot;lang_insert&quot;&gt;ВСТАВИТЬ&lt;/a&gt; команду документации для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="f900ded58f3c3fd3840ddc24eb90dbbf605e279b" translate="yes" xml:space="preserve">
          <source>The ROLLBACK TO command reverts the state of the database back to what it was just after the corresponding SAVEPOINT. Note that unlike that plain &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command (without the TO keyword) the ROLLBACK TO command does not cancel the transaction. Instead of cancelling the transaction, the ROLLBACK TO command restarts the transaction again at the beginning. All intervening SAVEPOINTs are canceled, however.</source>
          <target state="translated">Команда ROLLBACK TO возвращает состояние базы данных к тому, что было сразу после соответствующей точки SAVEPOINT. Обратите внимание, что в отличие от этой простой команды &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; (без ключевого слова TO) команда ROLLBACK TO не отменяет транзакцию. Вместо отмены транзакции команда ROLLBACK TO снова перезапускает транзакцию с самого начала. Однако все промежуточные SAVEPOINT отменяются.</target>
        </trans-unit>
        <trans-unit id="cd447cb0f90571617cf670fb9ebcb0a187d10c25" translate="yes" xml:space="preserve">
          <source>The ROLLBACK command with a TO clause rolls back transactions going backwards in time back to the most recent SAVEPOINT with a matching name. The SAVEPOINT with the matching name remains on the transaction stack, but all database changes that occurred after that SAVEPOINT was created are rolled back. If the savepoint-name in a ROLLBACK TO command does not match any SAVEPOINT on the stack, then the ROLLBACK command fails with an error and leaves the state of the database unchanged.</source>
          <target state="translated">Команда ROLLBACK с пунктом TO откатывает транзакции,идущие назад во времени,к самому последнему SAVEPOINT с совпадающим именем.SAVEPOINT с совпадающим именем остается в стеке транзакций,но все изменения в базе данных,произошедшие после создания SAVEPOINT,откатываются назад.Если имя точки сохранения в команде ROLLBACK TO не совпадает ни с каким SAVEPOINT в стеке,то команда ROLLBACK дает сбой с ошибкой и оставляет состояние базы данных неизменным.</target>
        </trans-unit>
        <trans-unit id="62a43e8d492ce5e858bd1d1f31b22f0ef1c5e90c" translate="yes" xml:space="preserve">
          <source>The ROWS and GROUPS frame types are similar in that they both determine the extent of a frame by counting relative to the current row. The difference is that ROWS counts individual rows and GROUPS counts peer groups. The RANGE frame type is different. The RANGE frame type determines the extent of a frame by looking for expression values that are within some band of values relative to the current row.</source>
          <target state="translated">Типы кадров ROWS и GROUPS похожи в том,что они оба определяют протяженность кадра путем подсчета относительно текущего ряда.Разница заключается в том,что ROWS считает отдельные строки,а GROUPS-одноранговые группы.Тип кадра RANGE отличается.Тип кадра RANGE определяет протяженность кадра путем поиска значений выражений,которые находятся в пределах некоторого диапазона значений относительно текущей строки.</target>
        </trans-unit>
        <trans-unit id="6cd583a191932218eb3314e3e838d31fd080381b" translate="yes" xml:space="preserve">
          <source>The Robson proof applies separately to each of the memory allocators used by SQLite:</source>
          <target state="translated">Доказательство Робсона применяется отдельно к каждому из аллокаторов памяти,используемых SQLite:</target>
        </trans-unit>
        <trans-unit id="ebd8832f03de287c31f207b9169a825dcdfbcb2a" translate="yes" xml:space="preserve">
          <source>The RowSet object is optimized for the case where sets of integers are inserted in distinct phases, which each set contains no duplicates. Each set is identified by a unique P4 value. The first set must have P4==0, the final set must have P4==-1, and for all other sets must have P4&amp;gt;0.</source>
          <target state="translated">Объект RowSet оптимизирован для случая, когда наборы целых чисел вставляются в отдельные фазы, каждый из которых не содержит дубликатов. Каждый набор идентифицируется уникальным значением P4. Первый набор должен иметь P4 == 0, последний набор должен иметь P4 == - 1, а для всех остальных наборов P4&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="69b35696d5bc7e8c253762e4c23df59d339d7859" translate="yes" xml:space="preserve">
          <source>The SAVEPOINT command starts a new transaction with a name. The transaction names need not be unique. A SAVEPOINT can be started either within or outside of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. When a SAVEPOINT is the outer-most savepoint and it is not within a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then the behavior is the same as BEGIN DEFERRED TRANSACTION.</source>
          <target state="translated">Команда SAVEPOINT запускает новую транзакцию с именем. Имена транзакций не обязательно должны быть уникальными. SAVEPOINT может быть запущен как внутри, так и вне &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; . Когда SAVEPOINT является самой внешней точкой сохранения и не находится внутри &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT,&lt;/a&gt; то поведение такое же, как и BEGIN DEFERRED TRANSACTION.</target>
        </trans-unit>
        <trans-unit id="ce13fbd458ee477db75220e11cabd929def8f2a4" translate="yes" xml:space="preserve">
          <source>The SCHEMA column is NULL, except for cases when the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface is used to interrogate the ZIPVFS backend. As this only happens when the memstat.c module is compiled with -DSQLITE_ENABLE_ZIPVFS and when &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; is in use, SCHEMA is usually NULL.</source>
          <target state="translated">Столбец SCHEMA имеет значение NULL, за исключением случаев, когда интерфейс &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; используется для опроса серверной части ZIPVFS. Поскольку это происходит только тогда, когда модуль memstat.c скомпилирован с -DSQLITE_ENABLE_ZIPVFS, и когда используется &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; , SCHEMA обычно имеет значение NULL.</target>
        </trans-unit>
        <trans-unit id="c6115bd106a2add942203424bfde4ef5e373053a" translate="yes" xml:space="preserve">
          <source>The SELECT begins in a familiar fashion. First the column names are initialized and the table being queried is opened. Things become different beginning with instructions 5 and 6 where the index file is also opened. Instructions 7 and 8 make a key with the value of 50. The &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; instruction at 9 stores the index key in VDBE memory location 0. The VDBE memory is used to avoid having to fetch a value from deep in the stack, which can be done, but makes the program harder to generate. The following instruction &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; at address 10 pops the key off the stack and moves the index cursor to the first row of the index with that key. This initializes the cursor for use in the following loop.</source>
          <target state="translated">SELECT начинается знакомым образом. Сначала инициализируются имена столбцов и открывается запрашиваемая таблица. Все меняется, начиная с инструкций 5 и 6, где также открывается индексный файл. Команды 7 и 8 создают ключ со значением 50. Инструкция &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; в 9 сохраняет индексный ключ в ячейке памяти VDBE 0. Память VDBE используется, чтобы избежать необходимости извлекать значение из глубины стека, что можно сделать , но затрудняет создание программы. Следующая инструкция &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; по адресу 10 извлекает ключ из стека и перемещает указатель индекса в первую строку индекса с этим ключом. Это инициализирует курсор для использования в следующем цикле.</target>
        </trans-unit>
        <trans-unit id="7a0eced3e1981106cb4ea9f622f50ad79cd9e5a4" translate="yes" xml:space="preserve">
          <source>The SELECT statement is the most complicated command in the SQL language. To make the description easier to follow, some of the passages below describe the way the data returned by a SELECT statement is determined as a series of steps. It is important to keep in mind that this is purely illustrative - in practice neither SQLite nor any other SQL engine is required to follow this or any other specific process.</source>
          <target state="translated">Оператор SELECT является самой сложной командой в языке SQL.Чтобы упростить описание,некоторые из приведенных ниже отрывков описывают,как данные,возвращаемые оператором SELECT,определяются в виде серии шагов.Важно помнить,что это чисто иллюстративное описание-на практике ни SQLite,ни любой другой SQL-движок не обязаны следовать этому или любому другому конкретному процессу.</target>
        </trans-unit>
        <trans-unit id="ecb8c3356a31e99d0c2a4414b1c0627a922137ba" translate="yes" xml:space="preserve">
          <source>The SELECT statement is used to query the database. The result of a SELECT is zero or more rows of data where each row has a fixed number of columns. A SELECT statement does not make any changes to the database.</source>
          <target state="translated">Оператор SELECT используется для запроса к базе данных.Результатом SELECT является ноль или более строк данных,где каждая строка имеет фиксированное количество столбцов.Оператор SELECT не вносит никаких изменений в базу данных.</target>
        </trans-unit>
        <trans-unit id="06f43e1f8274aa8dc54f915ee9dedc6e51d7565a" translate="yes" xml:space="preserve">
          <source>The SELECT statement on the left returns a single row since '0' and '0.0' are treated as numbers and are therefore indistinct. But the SELECT statement on the right returns two rows since 0 and 0.0 are treated a strings which are different.</source>
          <target state="translated">Оператор SELECT слева возвращает одну строку,так как '0' и '0.0' рассматриваются как числа и поэтому являются нечеткими.Но оператор SELECT справа возвращает две строки,так как 0 и 0.0 обрабатываются как разные строки.</target>
        </trans-unit>
        <trans-unit id="e902534831ef4c318239e243a80c6ae4bb31b6d1" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;BEGIN TRANSACTION&quot; (the TRANSACTION keyword is optional) is used to take SQLite out of autocommit mode. Note that the BEGIN command does not acquire any locks on the database. After a BEGIN command, a SHARED lock will be acquired when the first SELECT statement is executed. A RESERVED lock will be acquired when the first INSERT, UPDATE, or DELETE statement is executed. No EXCLUSIVE lock is acquired until either the memory cache fills up and must be spilled to disk or until the transaction commits. In this way, the system delays blocking read access to the file file until the last possible moment.</source>
          <target state="translated">Команда SQL &quot;BEGIN TRANSACTION&quot; (ключевое слово &quot;TRANSACTION&quot; является необязательным)используется для вывода SQLite из режима автокомитации.Обратите внимание,что команда BEGIN не приобретает никаких замков в БД.После команды BEGIN при выполнении первого оператора SELECT будет получена блокировка SHARED.ЗАЩИЩЕННАЯ БЛОКИРОВКА будет получена при выполнении первого оператора INSERT,UPDATE или DELETE.EXCLUSIVE-блокировка не будет получена до тех пор,пока кэш памяти не заполнится и не будет пролит на диск,или пока транзакция не будет зафиксирована.Таким образом,система задерживает блокирование доступа на чтение к файлу до последнего возможного момента.</target>
        </trans-unit>
        <trans-unit id="af8ff773b8faa66109f99e9e85b3a719b5cf7712" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;COMMIT&quot; does not actually commit the changes to disk. It just turns autocommit back on. Then, at the conclusion of the command, the regular autocommit logic takes over and causes the actual commit to disk to occur. The SQL command &quot;ROLLBACK&quot; also operates by turning autocommit back on, but it also sets a flag that tells the autocommit logic to rollback rather than commit.</source>
          <target state="translated">Команда SQL &quot;COMMIT&quot; на самом деле не фиксирует изменения на диске.Она просто включает автокоммитацию.Затем,по завершении команды,происходит обычная логика автокоммитации,которая приводит к фактической фиксации на диске.SQL-команда &quot;ROLLBACK&quot; также работает путем включения автокоммита,но она также устанавливает флаг,который указывает логике автокоммита на откат,а не на фиксацию.</target>
        </trans-unit>
        <trans-unit id="82504fd949554ebcdca052a7976082cbbc273023" translate="yes" xml:space="preserve">
          <source>The SQL fuzz generator tests are part of the TCL test suite. During a full test run, about 111.3 thousand fuzz SQL statements are generated and tested.</source>
          <target state="translated">Тесты генератора SQL fuzz являются частью набора тестов TCL.Во время полного запуска тестов генерируется и тестируется около 111,3 тысяч SQL-операторов fuzz.</target>
        </trans-unit>
        <trans-unit id="3044d65e21f066cf67f7a5007e05a25a7bcd19f9" translate="yes" xml:space="preserve">
          <source>The SQL language features several contexts where an expression is evaluated and the result converted to a boolean (true or false) value. These contexts are:</source>
          <target state="translated">Язык SQL имеет несколько контекстов,где выражение вычисляется,а результат преобразуется в булевое (истинное или ложное)значение.Такими контекстами являются:</target>
        </trans-unit>
        <trans-unit id="8b4f854d9a377d64ee6ebf1ef026f57adf3093a6" translate="yes" xml:space="preserve">
          <source>The SQL language is a &quot;standard&quot;. Even so, no two SQL database engines work exactly alike. Every SQL implementation has it own peculiarities and oddities, and SQLite is no exception to this rule.</source>
          <target state="translated">Язык SQL является &quot;стандартом&quot;.Тем не менее,ни один из двух движков баз данных SQL не работает одинаково.Каждая реализация SQL имеет свои особенности и особенности,и SQLite не является исключением из этого правила.</target>
        </trans-unit>
        <trans-unit id="10de2fe05ef5e79065921e1cfe79576a9514e5b1" translate="yes" xml:space="preserve">
          <source>The SQL language is rich in keywords. Most SQL implementations do not allow keywords to be used as identifiers (the names of table or columns) unless they are enclosed in double-quotes. But SQLite is more flexible. Many keywords can be used as identifiers without needing to be quoted, as long as those keywords are used in a context where it is clear that they are intended to be an identifier.</source>
          <target state="translated">Язык SQL богат ключевыми словами.Большинство реализаций SQL не позволяют использовать ключевые слова в качестве идентификаторов (названия таблиц или столбцов),если только они не заключены в двойные кавычки.Но SQLite более гибкий.Многие ключевые слова могут использоваться в качестве идентификаторов без необходимости заключать их в кавычки,при условии,что эти ключевые слова используются в контексте,когда ясно,что они предназначены для использования в качестве идентификатора.</target>
        </trans-unit>
        <trans-unit id="a6afa95ef6a6482806d3030ee240e85ae2e39791" translate="yes" xml:space="preserve">
          <source>The SQL language is very powerful, and so it is always possible for malicious SQL inputs (or erroneous SQL inputs caused by an application bug) to submit SQL that runs for a very long time. To prevent this from becoming a denial-of-service attack, consider using the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface to invoke a callback periodically as each SQL statement runs, and have that callback return non-zero to abort the statement if the statement runs for too long. Alternatively, set a timer in a separate thread and invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; when the timer goes off to prevent the SQL statement from running forever.</source>
          <target state="translated">Язык SQL очень мощный, поэтому для злонамеренных вводов SQL (или ошибочных вводов SQL, вызванных ошибкой приложения) всегда есть возможность отправить SQL, который выполняется в течение очень долгого времени. Чтобы это не превратилось в атаку отказа в обслуживании, рассмотрите возможность использования интерфейса &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; для периодического вызова обратного вызова при выполнении каждого оператора SQL и чтобы этот обратный вызов возвращал ненулевое значение, чтобы прервать выполнение оператора, если оператор выполняется слишком долго. . В качестве альтернативы можно установить таймер в отдельном потоке и вызывать &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt (),&lt;/a&gt; когда таймер срабатывает, чтобы предотвратить выполнение оператора SQL вечно.</target>
        </trans-unit>
        <trans-unit id="48efb4a27989fcb1221b7de6665fb9fdbe5be779" translate="yes" xml:space="preserve">
          <source>The SQL language parser for SQLite is generated using a code-generator program called &quot;Lemon&quot;. The Lemon program reads a grammar of the input language and emits C-code to implement a parser for that language.</source>
          <target state="translated">Парсер языка SQL для SQLite генерируется с помощью программы-генератора кода под названием &quot;Lemon&quot;.Программа Lemon читает грамматику языка ввода и излучает C-код для реализации синтаксического анализатора для этого языка.</target>
        </trans-unit>
        <trans-unit id="3001af76a5af3b3d6822f17dc4d8570b011ad5be" translate="yes" xml:space="preserve">
          <source>The SQL output resulting from &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; is now modified to include the values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="translated">Выходные данные SQL, полученные в результате &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; , теперь изменены, чтобы включать значения &lt;a href=&quot;lang_expr#varparam&quot;&gt;связанных параметров&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="677e1e6ba30ceb96b1361fef9b1a12b6f65a8d13" translate="yes" xml:space="preserve">
          <source>The SQL query in the example above uses less CPU than the first example in this section, but still has a non-obvious performance problem. SQLite satisfies this query by retrieving the value of the &quot;title&quot; column and matchinfo data from the FTS module for every row matched by the users query before it sorts and limits the results. Because of the way SQLite's virtual table interface works, retrieving the value of the &quot;title&quot; column requires loading the entire row from disk (including the &quot;content&quot; field, which may be quite large). This means that if the users query matches several thousand documents, many megabytes of &quot;title&quot; and &quot;content&quot; data may be loaded from disk into memory even though they will never be used for any purpose.</source>
          <target state="translated">SQL-запрос в приведенном выше примере использует меньше CPU,чем в первом примере в этом разделе,но все же имеет неочевидную проблему с производительностью.SQLite удовлетворяет этот запрос,извлекая значение столбца &quot;заголовок&quot; и совпадающие данные из модуля FTS для каждой строки,совпадающей с пользовательским запросом,прежде чем он сортирует и ограничивает результаты.В связи с тем,как работает интерфейс виртуальной таблицы SQLite,для получения значения столбца &quot;title&quot; необходимо загрузить с диска всю строку (в том числе и поле &quot;content&quot;,которое может быть достаточно большим).Это означает,что если пользовательский запрос соответствует нескольким тысячам документов,то многие мегабайты данных &quot;title&quot; и &quot;content&quot; могут быть загружены с диска в память,несмотря на то,что они никогда не будут использоваться для каких бы то ни было целей.</target>
        </trans-unit>
        <trans-unit id="44349eaec4c0440f46685e284dc3b9bdf9db6763" translate="yes" xml:space="preserve">
          <source>The SQL query in the following example block is one solution to this problem. In SQLite, when a &lt;a href=&quot;optoverview#flattening&quot;&gt;sub-query used in a join contains a LIMIT clause&lt;/a&gt;, the results of the sub-query are calculated and stored in temporary table before the main query is executed. This means that SQLite will load only the docid and matchinfo data for each row matching the users query into memory, determine the docid values corresponding to the ten most relevant documents, then load only the title and content information for those 10 documents only. Because both the matchinfo and docid values are gleaned entirely from the full-text index, this results in dramatically less data being loaded from the database into memory.</source>
          <target state="translated">SQL-запрос в следующем примере блока - одно из решений этой проблемы. В SQLite, когда &lt;a href=&quot;optoverview#flattening&quot;&gt;подзапрос, используемый в соединении, содержит предложение LIMIT&lt;/a&gt; , результаты подзапроса вычисляются и сохраняются во временной таблице перед выполнением основного запроса. Это означает, что SQLite будет загружать в память только данные docid и matchinfo для каждой строки, соответствующей запросу пользователя, определять значения docid, соответствующие десяти наиболее релевантным документам, а затем загружать только заголовок и информацию о содержимом только для этих 10 документов. Поскольку значения matchinfo и docid полностью извлекаются из полнотекстового индекса, это приводит к значительно меньшему количеству данных, загружаемых из базы данных в память.</target>
        </trans-unit>
        <trans-unit id="a5256c5c7d2eb97fecf26da60392ff96d1a9f664" translate="yes" xml:space="preserve">
          <source>The SQL standard requires double-quotes around identifiers and single-quotes around string literals. For example:</source>
          <target state="translated">Стандарт SQL требует использования двойных кавычек вокруг идентификаторов и одинарных кавычек вокруг строковых литералов.Например:</target>
        </trans-unit>
        <trans-unit id="7e7a261f0a3880c45baf726e85dad9e7315752c4" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that a UNIQUE constraint be enforced even if one or more of the columns in the constraint are NULL, but SQLite does not do this. Isn't that a bug?</source>
          <target state="translated">Стандарт SQL требует,чтобы ограничение UNIQUE применялось даже в том случае,если один или несколько столбцов в ограничении NULL,но SQLite этого не делает.Разве это не ошибка?</target>
        </trans-unit>
        <trans-unit id="7a04eb23eef56ed5f467e10f54232c8a27c42d7f" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies a large number of keywords which may not be used as the names of tables, indices, columns, databases, user-defined functions, collations, virtual table modules, or any other named object. The list of keywords is so long that few people can remember them all. For most SQL code, your safest bet is to never use any English language word as the name of a user-defined object.</source>
          <target state="translated">Стандарт SQL определяет большое количество ключевых слов,которые не могут быть использованы в качестве названий таблиц,индексов,столбцов,баз данных,пользовательских функций,колонок,модулей виртуальных таблиц или любого другого названного объекта.Список ключевых слов настолько длинный,что мало кто может запомнить их все.Для большинства SQL-кодов,ваша самая безопасная ставка-никогда не использовать любое английское слово в качестве имени пользовательского объекта.</target>
        </trans-unit>
        <trans-unit id="f8004c4c668fddca439c94d74dc1d6f7c7684dbe" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that single-quotes in strings are escaped by putting two single quotes in a row. SQL works like the Pascal programming language in this regard. Example:</source>
          <target state="translated">Стандарт SQL устанавливает,что одинарные кавычки в строках экранируются путем помещения двух одинарных кавычек в строку.В этом отношении SQL работает подобно языку программирования Pascal.Пример:</target>
        </trans-unit>
        <trans-unit id="59242cd06ef98d5456a2038bc8b7aff22753485f" translate="yes" xml:space="preserve">
          <source>The SQL statement is a UTF-8 string for sqlite3_prepare(). The sqlite3_prepare16() works the same way except that it expects a UTF-16 string as SQL input. Only the first SQL statement in the input string is compiled. The fifth parameter is filled in with a pointer to the next (uncompiled) SQLite statement in the input string, if any. The sqlite3_finalize() routine deallocates a prepared SQL statement. All prepared statements must be finalized before the database can be closed. The sqlite3_reset() routine resets a prepared SQL statement so that it can be executed again.</source>
          <target state="translated">SQL-оператор представляет собой UTF-8 строку для sqlite3_prepare().Функция sqlite3_prepare16()работает точно так же,за исключением того,что она ожидает строку в кодировке UTF-16 в качестве SQL-входа.Компилируется только первый SQL-оператор в входной строке.Пятый параметр заполняется указателем на следующий (некомпилированный)SQLite-оператор в входной строке,если таковой имеется.Рутина sqlite3_finalize()распределяет подготовленный SQL-оператор.Все подготовленные операторы должны быть завершены до того,как БД будет закрыта.Рутина sqlite3_reset()сбрасывает подготовленный SQL-оператор,чтобы его можно было выполнить заново.</target>
        </trans-unit>
        <trans-unit id="05506ce34afb730ccba4a9b42a033056b9bc26b4" translate="yes" xml:space="preserve">
          <source>The SQL statement may contain tokens of the form &quot;?&quot; or &quot;?nnn&quot; or &quot;:aaa&quot; where &quot;nnn&quot; is an integer and &quot;aaa&quot; is an identifier. Such tokens represent unspecified literal values (or &quot;wildcards&quot;) to be filled in later by the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; interface. Each wildcard has an associated number which is its sequence in the statement or the &quot;nnn&quot; in the case of a &quot;?nnn&quot; form. It is allowed for the same wildcard to occur more than once in the same SQL statement, in which case all instance of that wildcard will be filled in with the same value. Unbound wildcards have a value of NULL.</source>
          <target state="translated">Оператор SQL может содержать токены в форме &quot;?&quot; или &amp;laquo;? nnn&amp;raquo; или &amp;laquo;: aaa&amp;raquo;, где &amp;laquo;nnn&amp;raquo; - целое число, а &amp;laquo;aaa&amp;raquo; - идентификатор. Такие токены представляют собой неопределенные буквальные значения (или &amp;laquo;подстановочные знаки&amp;raquo;), которые позже будут заполнены интерфейсом &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; . Каждому подстановочному знаку соответствует номер, который является его последовательностью в операторе или &amp;laquo;nnn&amp;raquo; в случае формы &amp;laquo;? Nnn&amp;raquo;. Один и тот же подстановочный знак может встречаться более одного раза в одном операторе SQL, и в этом случае все экземпляры этого подстановочного знака будут заполнены одним и тем же значением. Несвязанные подстановочные знаки имеют значение NULL.</target>
        </trans-unit>
        <trans-unit id="449ffcbd2d390b1586ef94ae6aaf64cdfbb6cfbd" translate="yes" xml:space="preserve">
          <source>The SQL statement supplied as the argument to the CREATE VIRTUAL TABLE statement is executed when the table is created. It must return either four or five columns. Each row returned describes one of the component tables. The first four columns are interpreted, from first to last, as:</source>
          <target state="translated">SQL-оператор,поставляемый в качестве аргумента к оператору CREATE VIRTUAL TABLE,выполняется при создании таблицы.Он должен возвращать либо четыре,либо пять столбцов.Каждая возвращаемая строка описывает одну из компонентных таблиц.Первые четыре столбца интерпретируются,от первого до последнего,как:</target>
        </trans-unit>
        <trans-unit id="dd374f0003c79e47aa8712ac4ea58e570b4758d5" translate="yes" xml:space="preserve">
          <source>The SQL statements used to implement SQLite Archive operations make use of various &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. These extensions are all available in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt; in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext/misc/ subfolder&lt;/a&gt;. The extensions needed for full SQLite Archive support include:</source>
          <target state="translated">Операторы SQL, используемые для реализации операций с архивом SQLite, используют различные &lt;a href=&quot;loadext&quot;&gt;загружаемые расширения&lt;/a&gt; . Все эти расширения доступны в &lt;a href=&quot;https://sqlite.org/src&quot;&gt;дереве исходных текстов SQLite&lt;/a&gt; в &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;подпапке ext / misc /&lt;/a&gt; . Расширения, необходимые для полной поддержки архива SQLite, включают:</target>
        </trans-unit>
        <trans-unit id="cc6ae8d6fb78d715b5f8b26d43534dafb12ea942" translate="yes" xml:space="preserve">
          <source>The SQL syntax for custom queries is the same regardless of which interface, sqlite3_rtree_geometry_callback() or sqlite3_rtree_query_callback(), is used to register the SQL function. However, the newer query-style callbacks give the application greater control over how the query proceeds.</source>
          <target state="translated">Синтаксис SQL для пользовательских запросов одинаков,независимо от того,какой интерфейс,sqlite3_rtree_geometry_callback()или sqlite3_rtree_query_callback(),используется для регистрации SQL-функции.Однако более новые обратные вызовы в стиле запроса дают приложению больший контроль над тем,как выполняется запрос.</target>
        </trans-unit>
        <trans-unit id="f9308701d68c8225498cd757f7331dde6f73adc8" translate="yes" xml:space="preserve">
          <source>The SQL:1999 spec requires that the RECURSIVE keyword follow WITH in any WITH clause that includes a recursive common table expression. However, for compatibility with SqlServer and Oracle, SQLite does not enforce this rule.</source>
          <target state="translated">Спецификация SQL:1999 требует,чтобы ключевое слово RECURSIVE следовало за WITH в любом пункте WITH,включающем рекурсивное общее выражение таблицы.Однако,для совместимости с SqlServer и Oracle,SQLite не применяет это правило.</target>
        </trans-unit>
        <trans-unit id="b5ddf5e6785ea3822394b6d6a54fb42d4acd1778" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;.</source>
          <target state="translated">Код результата SQLITE_ABORT указывает, что операция была прервана до завершения, обычно это запрос приложения. См. Также: &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1613fab985744b29bc64a3b7d315d71db7102a20" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.</source>
          <target state="translated">Код ошибки SQLITE_ABORT_ROLLBACK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT,&lt;/a&gt; указывающий на то, что выполнение инструкции SQL было прервано из- за отката транзакции, которая была активной при первом запуске инструкции SQL. При откате отложенные операции записи всегда завершаются сбоем с этой ошибкой. &lt;a href=&quot;lang_transaction&quot;&gt;ОТКАТА&lt;/a&gt; вызовет отложенное чтение не выполняется операция , только если схема была изменена в пределах сделки будет произведен откатом.</target>
        </trans-unit>
        <trans-unit id="9776b801900694be8692d527b6b6a5014611c72c" translate="yes" xml:space="preserve">
          <source>The SQLITE_AFF_MASK portion of P5 must be an affinity character - SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made to coerce both inputs according to this affinity before the comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric affinity is used. Note that the affinity conversions are stored back into the input registers P1 and P3. So this opcode can cause persistent changes to registers P1 and P3.</source>
          <target state="translated">SQLITE_AFF_MASK часть P5 должна быть символом родства-SQLITE_AFF_TEXT,SQLITE_AFF_INTEGER и так далее.Перед проведением сравнения делается попытка принудить оба входа в соответствии с этим сродством.Если символ SQLITE_AFF_MASK равен 0x00,то используется числовое сродство.Обратите внимание,что преобразования аффинности хранятся обратно во входных регистрах P1 и P3.Поэтому данный опкод может вызвать постоянные изменения в регистрах P1 и P3.</target>
        </trans-unit>
        <trans-unit id="dfa8cf2714776524ecdde2f427b30f632065e986" translate="yes" xml:space="preserve">
          <source>The SQLITE_AUTH error is returned when the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; indicates that an SQL statement being prepared is not authorized.</source>
          <target state="translated">Ошибка SQLITE_AUTH возвращается, когда &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;обратный вызов авторизатора&lt;/a&gt; указывает, что подготавливаемый оператор SQL не авторизован.</target>
        </trans-unit>
        <trans-unit id="a716819bd21e33b0b83c8f1def818df42717b54a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code differs from &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; in that SQLITE_BUSY indicates a conflict with a separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, probably in a separate process, whereas &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicates a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or sometimes a database connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;).</source>
          <target state="translated">Код результата SQLITE_BUSY отличается от &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; тем, что SQLITE_BUSY указывает на конфликт с отдельным &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединением&lt;/a&gt; с базой данных , вероятно, в отдельном процессе, тогда как &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; указывает на конфликт внутри того же &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; (или иногда соединения с базой данных с &lt;a href=&quot;sharedcache&quot;&gt;общим кешем&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6847ec78063b3fe6af5cc42bad60bb51ac404849" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, usually a database connection in a separate process.</source>
          <target state="translated">Код результата SQLITE_BUSY указывает, что файл базы данных не может быть записан (или в некоторых случаях прочитан) из-за одновременной активности какого-либо другого &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединения&lt;/a&gt; с базой данных , обычно соединения с базой данных в отдельном процессе.</target>
        </trans-unit>
        <trans-unit id="3cfe6b580ae13113f460c28fc71a7b4dbcf6c75a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that indicates that an operation could not continue because another process is busy recovering a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases.</source>
          <target state="translated">Код ошибки SQLITE_BUSY_RECOVERY - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; который указывает, что операция не может быть продолжена, поскольку другой процесс занят восстановлением файла базы данных в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; после сбоя. Код ошибки SQLITE_BUSY_RECOVERY возникает только в базах данных в &lt;a href=&quot;wal&quot;&gt;режиме WAL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc5599d49b00bbca3062bad1e4d863f9643aada6" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_SNAPSHOT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases when a database connection tries to promote a read transaction into a write transaction but finds that another &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has already written to the database and thus invalidated prior reads.</source>
          <target state="translated">Код ошибки SQLITE_BUSY_SNAPSHOT - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY,&lt;/a&gt; который возникает в базах данных в &lt;a href=&quot;wal&quot;&gt;режиме WAL,&lt;/a&gt; когда соединение с базой данных пытается преобразовать транзакцию чтения в транзакцию записи, но обнаруживает, что другое &lt;a href=&quot;c3ref/sqlite3&quot;&gt;соединение с базой данных&lt;/a&gt; уже записано в базу данных и, таким образом, делает недействительными предыдущие чтения.</target>
        </trans-unit>
        <trans-unit id="9ff4a95f8927914c1763adf9045af4ab62d2f754" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="translated">Код результата SQLITE_CANTOPEN указывает, что SQLite не удалось открыть файл. Рассматриваемый файл может быть основным файлом базы данных или одним из нескольких &lt;a href=&quot;tempfiles&quot;&gt;временных файлов на диске&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="500408920c5afff76382c31e4489f9ce53192205" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</source>
          <target state="translated">Код ошибки SQLITE_CANTOPEN_CONVPATH - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN,&lt;/a&gt; используемый только Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; и указывающий на то, что системный вызов cygwin_conv_path () завершился неудачно при попытке открыть файл. См. Также: &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55203070958c2991ba87f3b32bd40d536d90189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_DIRTYWAL result code is not used at this time.</source>
          <target state="translated">В настоящее время код результата SQLITE_CANTOPEN_DIRTYWAL не используется.</target>
        </trans-unit>
        <trans-unit id="13b8dd7bacea04f63a2cb5fbae43d894d6332998" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_FULLPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.</source>
          <target state="translated">Код ошибки SQLITE_CANTOPEN_FULLPATH - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN,&lt;/a&gt; указывающий на то, что операция открытия файла не удалась, поскольку операционная система не смогла преобразовать имя файла в полный путь.</target>
        </trans-unit>
        <trans-unit id="c1b7e5d009e56aefb1e5fa74fb773f95be397ef4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_ISDIR error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the file is really a directory.</source>
          <target state="translated">Код ошибки SQLITE_CANTOPEN_ISDIR - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN,&lt;/a&gt; указывающий, что операция открытия файла не удалась, поскольку файл действительно является каталогом.</target>
        </trans-unit>
        <trans-unit id="3ff11cefb3f88aae4a84bf8291076f3bac03ede6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.</source>
          <target state="translated">Код ошибки SQLITE_CANTOPEN_NOTEMPDIR больше не используется.</target>
        </trans-unit>
        <trans-unit id="06f769e27f147dfdd680f8a17a2bfe539caf9796" translate="yes" xml:space="preserve">
          <source>The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the exclusive &quot;writer&quot; lock on the database file. If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained. The busy-handler is also invoked while waiting for database readers as described above. If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible without blocking any further. SQLITE_BUSY is returned in this case.</source>
          <target state="translated">Режимы SQLITE_CHECKPOINT_FULL,RESTART и TRUNCATE также получают эксклюзивную блокировку &quot;writeer&quot; на файле базы данных.Если блокировка записи не может быть получена немедленно,и обработчик занятости сконфигурирован,он вызывается и блокировка записи перепроверяется до тех пор,пока обработчик занятости не вернет 0 или блокировка не будет успешно получена.Обработчик также вызывается в ожидании читателей БД,как описано выше.Если обработчик возвращает 0 до получения блокировки записи или в ожидании читателей БД,то работа с контрольной точкой продолжается так же,как и с SQLITE_CHECKPOINT_PASSIVE-проверка как можно большего количества кадров без дальнейшей блокировки.В этом случае возвращается SQLITE_BUSY.</target>
        </trans-unit>
        <trans-unit id="5f7466fb166d62399d9f0072e0370315299af5b1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">Параметр SQLITE_CONFIG_COVERING_INDEX_SCAN принимает один целочисленный аргумент, который интерпретируется как логическое значение, чтобы разрешить или запретить использование покрывающих индексов для полного сканирования таблиц в оптимизаторе запросов. Значение по умолчанию определяется параметром &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ALLOW_COVERING_INDEX_SCAN или &quot; включено &quot;, если этот параметр времени компиляции опущен. Возможность отключить использование покрывающих индексов для полного сканирования таблицы обусловлена ​​тем, что некоторые неправильно закодированные устаревшие приложения могут работать со сбоями при включении оптимизации. Предоставление возможности отключить оптимизацию позволяет старому, ошибочному коду приложения работать без изменений даже с более новыми версиями SQLite.</target>
        </trans-unit>
        <trans-unit id="7d7ecdbc601a4823c2b08a2a5337606f8d30aa46" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="translated">Параметр SQLITE_CONFIG_COVERING_INDEX_SCAN принимает один целочисленный аргумент, который интерпретируется как логическое значение, чтобы разрешить или запретить использование покрывающих индексов для полного сканирования таблиц в оптимизаторе запросов. Значение по умолчанию определяется параметром &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_ALLOW_COVERING_INDEX_SCAN или &quot; включено &quot;, если этот параметр времени компиляции опущен. Возможность отключить использование покрывающих индексов для полного сканирования таблицы обусловлена ​​тем, что некоторые неправильно закодированные устаревшие приложения могут работать со сбоями при включении оптимизации. Предоставление возможности отключить оптимизацию позволяет старому, ошибочному коду приложения работать без изменений даже с более новыми версиями SQLite.</target>
        </trans-unit>
        <trans-unit id="ff83d1ba90843c7f9c3dc720386b86f9f35e0379" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">Параметр SQLITE_CONFIG_GETMALLOC принимает единственный аргумент, который является указателем на экземпляр структуры &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; . Структура &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; заполняется определенными в настоящий момент процедурами выделения памяти. Этот параметр можно использовать для перегрузки стандартных процедур выделения памяти с помощью оболочки, которая, например, имитирует сбой выделения памяти или отслеживает использование памяти.</target>
        </trans-unit>
        <trans-unit id="27c7cd5a1eddca0fbdae5b53b4edcfcd1711ca82" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="translated">Параметр SQLITE_CONFIG_GETMALLOC принимает единственный аргумент, который является указателем на экземпляр структуры &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; . Структура &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; заполняется определенными в настоящий момент процедурами выделения памяти. Этот параметр можно использовать для перегрузки стандартных процедур выделения памяти с помощью оболочки, которая, например, имитирует сбой выделения памяти или отслеживает использование памяти.</target>
        </trans-unit>
        <trans-unit id="be1078933a2f48f4ba63fb92d6b093d628661727" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">Параметр SQLITE_CONFIG_GETMUTEX принимает единственный аргумент, который является указателем на экземпляр структуры &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; . Структура &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; заполнена определенными в настоящий момент подпрограммами мьютекса. Эту опцию можно использовать для перегрузки стандартных процедур распределения мьютексов оболочкой, используемой, например, для отслеживания использования мьютексов для профилирования производительности или тестирования. Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда вся подсистема мьютексирования не включается в сборку и, следовательно, вызовы &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; с параметром конфигурации &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; вернут SQLITE_ERROR .</target>
        </trans-unit>
        <trans-unit id="4910d5633ae70fa15de2ae4b340873caa0f78feb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">Параметр SQLITE_CONFIG_GETMUTEX принимает единственный аргумент, который является указателем на экземпляр структуры &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; . Структура &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; заполнена определенными в настоящий момент подпрограммами мьютекса. Эту опцию можно использовать для перегрузки стандартных процедур распределения мьютексов оболочкой, используемой, например, для отслеживания использования мьютексов для профилирования производительности или тестирования. Если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда вся подсистема мьютексирования не включается в сборку и, следовательно, вызовы &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; с параметром конфигурации &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; вернут SQLITE_ERROR .</target>
        </trans-unit>
        <trans-unit id="480ac6642108db12dacb128d029ff61248587e74" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">Параметр SQLITE_CONFIG_GETPCACHE2 принимает единственный аргумент, который является указателем на объект &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; . SQLite копирует реализацию кеша текущей страницы в этот объект.</target>
        </trans-unit>
        <trans-unit id="d15656e2a537c4d062ffc1a4a28c224d21946fb5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="translated">Параметр SQLITE_CONFIG_GETPCACHE2 принимает единственный аргумент, который является указателем на объект &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; . SQLite копирует реализацию кеша текущей страницы в этот объект.</target>
        </trans-unit>
        <trans-unit id="41bf906d256dc3dcf8d1b8d18fc31630de1f686b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">Параметр SQLITE_CONFIG_HEAP указывает буфер статической памяти, который SQLite будет использовать для всех своих потребностей в распределении динамической памяти, помимо тех, которые предусмотрены &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; . Параметр SQLITE_CONFIG_HEAP доступен только в том случае, если SQLite скомпилирован с &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; или &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; и возвращает &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается в противном случае. У SQLITE_CONFIG_HEAP есть три аргумента: 8-байтовый выровненный указатель на память, количество байтов в буфере памяти и минимальный размер выделения. Если первый указатель (указатель памяти) равен NULL, то SQLite возвращается к использованию своего распределителя памяти по умолчанию (системная реализация malloc ()), отменяя любой предыдущий вызов &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. Если указатель памяти не равен NULL, то задействуется альтернативный распределитель памяти для обработки всех потребностей в распределении памяти SQLite. Первый указатель (указатель памяти) должен быть выровнен по 8-байтовой границе, иначе последующее поведение SQLite будет неопределенным. Минимальный размер выделения ограничен 2 ** 12. Разумные значения минимального размера выделения: от 2 ** 5 до 2 ** 8.</target>
        </trans-unit>
        <trans-unit id="3fe54eb9feb326e6993f5e80b5d7f631fea68373" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="translated">Параметр SQLITE_CONFIG_HEAP указывает буфер статической памяти, который SQLite будет использовать для всех своих потребностей в распределении динамической памяти, помимо тех, которые предусмотрены &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; . Параметр SQLITE_CONFIG_HEAP доступен только в том случае, если SQLite скомпилирован с &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; или &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; и возвращает &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR,&lt;/a&gt; если вызывается в противном случае. У SQLITE_CONFIG_HEAP есть три аргумента: 8-байтовый выровненный указатель на память, количество байтов в буфере памяти и минимальный размер выделения. Если первый указатель (указатель памяти) равен NULL, то SQLite возвращается к использованию своего распределителя памяти по умолчанию (системная реализация malloc ()), отменяя любой предыдущий вызов &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. Если указатель памяти не равен NULL, то задействуется альтернативный распределитель памяти для обработки всех потребностей в распределении памяти SQLite. Первый указатель (указатель памяти) должен быть выровнен по 8-байтовой границе, иначе последующее поведение SQLite будет неопределенным. Минимальный размер выделения ограничен 2 ** 12. Разумные значения минимального размера выделения: от 2 ** 5 до 2 ** 8.</target>
        </trans-unit>
        <trans-unit id="01d248a0a82b03a7f001692e75d24ae19d015766" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">Параметр SQLITE_CONFIG_LOG используется для настройки глобального &lt;a href=&quot;../errlog&quot;&gt;журнала ошибок&lt;/a&gt; SQLite . (Параметр SQLITE_CONFIG_LOG принимает два аргумента: указатель на функцию с сигнатурой вызова void (*) (void *, int, const char *) и указатель на void. Если указатель функции не равен NULL, он вызывается с помощью &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; для обработки каждого события регистрации. Если указатель на функцию равен NULL, интерфейс &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; становится бездействующим. Указатель void, который является вторым аргументом SQLITE_CONFIG_LOG, передается как первый параметр в определяемую приложением logger каждый раз, когда эта функция вызывается. Второй параметр функции logger является копией первого параметра соответствующего вызова &lt;a href=&quot;log&quot;&gt;sqlite3_log ()&lt;/a&gt; и предназначен для использования&lt;a href=&quot;../rescode&quot;&gt;код результата&lt;/a&gt; или &lt;a href=&quot;../rescode#extrc&quot;&gt;расширенный код результата&lt;/a&gt; . Третий параметр, передаваемый регистратору, - это сообщение журнала после форматирования с помощью &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; . Интерфейс ведения журнала SQLite не реентерабелен; функция регистратора, предоставляемая приложением, не должна вызывать какой-либо интерфейс SQLite. В многопоточном приложении функция регистратора, определяемая приложением, должна быть потокобезопасной.</target>
        </trans-unit>
        <trans-unit id="59e287bb60474979eb8cefde91438388d0375975" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="translated">Параметр SQLITE_CONFIG_LOG используется для настройки глобального &lt;a href=&quot;errlog&quot;&gt;журнала ошибок&lt;/a&gt; SQLite . (Параметр SQLITE_CONFIG_LOG принимает два аргумента: указатель на функцию с сигнатурой вызова void (*) (void *, int, const char *) и указатель на void. Если указатель функции не равен NULL, он вызывается с помощью &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; для обработки каждого события регистрации. Если указатель на функцию равен NULL, интерфейс &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; становится бездействующим. Указатель void, который является вторым аргументом SQLITE_CONFIG_LOG, передается как первый параметр в определяемую приложением logger каждый раз, когда эта функция вызывается. Второй параметр функции logger является копией первого параметра соответствующего вызова &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log ()&lt;/a&gt; и предназначен для использования&lt;a href=&quot;rescode&quot;&gt;код результата&lt;/a&gt; или &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код результата&lt;/a&gt; . Третий параметр, передаваемый регистратору, - это сообщение журнала после форматирования с помощью &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; . Интерфейс ведения журнала SQLite не реентерабелен; функция регистратора, предоставляемая приложением, не должна вызывать какой-либо интерфейс SQLite. В многопоточном приложении функция регистратора, определяемая приложением, должна быть потокобезопасной.</target>
        </trans-unit>
        <trans-unit id="ab0156b86adc81defa456094d6dda8a22884243b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">Параметр SQLITE_CONFIG_LOOKASIDE принимает два аргумента, которые определяют размер резервной памяти по умолчанию для каждого &lt;a href=&quot;#sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; . Первый аргумент - это размер каждого слота резервного буфера, а второй - количество слотов, выделенных для каждого соединения с базой данных. SQLITE_CONFIG_LOOKASIDE устанавливает</target>
        </trans-unit>
        <trans-unit id="517e0ab9da5cb1067d00b2d40dff6d21a15492c5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="translated">Параметр SQLITE_CONFIG_LOOKASIDE принимает два аргумента, которые определяют размер резервной памяти по умолчанию для каждого &lt;a href=&quot;sqlite3&quot;&gt;соединения с базой данных&lt;/a&gt; . Первый аргумент - это размер каждого слота резервного буфера, а второй - количество слотов, выделенных для каждого соединения с базой данных. SQLITE_CONFIG_LOOKASIDE устанавливает</target>
        </trans-unit>
        <trans-unit id="5f5ea304960d2945164c69cf799e956ea26314e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">Параметр SQLITE_CONFIG_MALLOC принимает единственный аргумент, который является указателем на экземпляр структуры &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; . Аргумент указывает альтернативные подпрограммы выделения памяти низкого уровня, которые будут использоваться вместо подпрограмм выделения памяти, встроенных в SQLite. SQLite создает свою собственную частную копию содержимого структуры &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; перед возвратом вызова &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="212fa0cc6b6461ceacd5f53dcf7fed283b480c6d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">Параметр SQLITE_CONFIG_MALLOC принимает единственный аргумент, который является указателем на экземпляр структуры &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; . Аргумент указывает альтернативные подпрограммы выделения памяти низкого уровня, которые будут использоваться вместо подпрограмм выделения памяти, встроенных в SQLite. SQLite создает свою собственную частную копию содержимого структуры &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; перед возвратом вызова &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0f6142b40b1216838367535e150c109342d48bb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">Параметр SQLITE_CONFIG_MEMDB_MAXSIZE принимает один параметр &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64,&lt;/a&gt; который является максимальным размером по умолчанию для базы данных в памяти, созданной с помощью &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; . Этот максимальный размер по умолчанию может быть увеличен или уменьшен для отдельных баз данных с помощью &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;файлового элемента &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;управления &lt;/a&gt;SQLITE_FCNTL_SIZE_LIMIT . Если этот параметр конфигурации никогда не используется, то максимальное значение по умолчанию определяется параметром &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_MEMDB_DEFAULT_MAXSIZE . Если этот параметр времени компиляции не установлен, то максимальное значение по умолчанию - 1073741824.</target>
        </trans-unit>
        <trans-unit id="81e7b78f6947d183a3f90000da914d03e1bc727e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="translated">Параметр SQLITE_CONFIG_MEMDB_MAXSIZE принимает один параметр &lt;a href=&quot;int64&quot;&gt;sqlite3_int64,&lt;/a&gt; который является максимальным размером по умолчанию для базы данных в памяти, созданной с помощью &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; . Этот максимальный размер по умолчанию может быть увеличен или уменьшен для отдельных баз данных с помощью &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;файлового элемента &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;управления &lt;/a&gt;SQLITE_FCNTL_SIZE_LIMIT . Если этот параметр конфигурации никогда не используется, то максимальное значение по умолчанию определяется параметром &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_MEMDB_DEFAULT_MAXSIZE . Если этот параметр времени компиляции не установлен, то максимальное значение по умолчанию - 1073741824.</target>
        </trans-unit>
        <trans-unit id="0f876ee04fb467dec2e88424ad542eb53469ec0b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int, interpreted as a boolean, which enables or disables the collection of memory allocation statistics. When memory allocation statistics are disabled, the following SQLite interfaces become non-operational:</source>
          <target state="translated">Опция SQLITE_CONFIG_MEMSTATUS принимает единственный аргумент типа int,интерпретируемый как логический,который включает или выключает сбор статистики выделения памяти.Когда статистика выделения памяти отключена,следующие интерфейсы SQLite становятся нерабочими:</target>
        </trans-unit>
        <trans-unit id="c9d36e0270700e44060555bf77969beca0ef1bb6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">Параметр SQLITE_CONFIG_MUTEX принимает единственный аргумент, который является указателем на экземпляр структуры &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; . Аргумент определяет альтернативные низкоуровневые процедуры мьютекса, которые будут использоваться вместо подпрограмм мьютекса, встроенных в SQLite. SQLite делает копию содержимого структуры &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; перед возвратом вызова &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; . Если SQLite скомпилирован с параметром &lt;a href=&quot;compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда вся подсистема мьютекса не включается в сборку, и, следовательно, вызовы &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; с параметром конфигурации &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; вернут SQLITE_ERROR .</target>
        </trans-unit>
        <trans-unit id="6b773ada2ea4912cbbe3a1e1cebfe063f6d8a1c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="translated">Параметр SQLITE_CONFIG_MUTEX принимает единственный аргумент, который является указателем на экземпляр структуры &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; . Аргумент определяет альтернативные низкоуровневые процедуры мьютекса, которые будут использоваться вместо подпрограмм мьютекса, встроенных в SQLite. SQLite делает копию содержимого структуры &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; перед возвратом вызова &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; . Если SQLite скомпилирован с параметром &lt;a href=&quot;../compile#threadsafe&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_THREADSAFE = 0, тогда вся подсистема мьютекса не включается в сборку, и, следовательно, вызовы &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; с параметром конфигурации &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; вернут SQLITE_ERROR .</target>
        </trans-unit>
        <trans-unit id="09e3ca8fa4415d94f70fc44a6276555caf14748e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">Параметр SQLITE_CONFIG_PAGECACHE указывает пул памяти, который SQLite может использовать для кеширования страниц базы данных с реализацией кеширования страниц по умолчанию. Эта опция конфигурации не работает, если реализация кэша страницы, определяемая приложением, загружается с использованием &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; . У SQLITE_CONFIG_PAGECACHE есть три аргумента: указатель на 8-байтовую выровненную память (pMem), размер каждой строки кэша страницы (sz) и количество строк кэша (N). Аргумент sz должен быть размером самой большой страницы базы данных (степень двойки между 512 и 65536) плюс несколько дополнительных байтов для каждого заголовка страницы. Количество дополнительных байтов, необходимых для заголовка страницы, можно определить с помощью &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. Если не считать потери памяти, безвредно, если параметр sz будет больше необходимого. Аргумент pMem должен быть либо указателем NULL, либо указателем на 8-байтовый выровненный блок памяти размером не менее sz * N байт, в противном случае последующее поведение не определено. Когда pMem не равен NULL, SQLite будет стремиться использовать предоставленную память для удовлетворения потребностей в кэше страниц, возвращаясь к &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; если строка кэша страницы превышает sz байтов или если весь буфер pMem исчерпан. Если pMem имеет значение NULL, а N не равно нулю, то каждое соединение с базой данных выполняет начальное массовое выделение памяти кеш-памяти страниц из &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt;достаточно для N строк кэша, если N положительно, или -1024 * N байт, если N отрицательно,. Если требуется дополнительная кеш-память страницы сверх того, что предусмотрено начальным выделением, то SQLite переходит к &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; отдельно для каждой дополнительной строки кеша.</target>
        </trans-unit>
        <trans-unit id="cc50296996fcaf95f25672cd009256aa14c36a0e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="translated">Параметр SQLITE_CONFIG_PAGECACHE указывает пул памяти, который SQLite может использовать для кеширования страниц базы данных с реализацией кеширования страниц по умолчанию. Эта опция конфигурации не работает, если реализация кэша страницы, определяемая приложением, загружается с использованием &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; . У SQLITE_CONFIG_PAGECACHE есть три аргумента: указатель на 8-байтовую выровненную память (pMem), размер каждой строки кэша страницы (sz) и количество строк кэша (N). Аргумент sz должен быть размером самой большой страницы базы данных (степень двойки между 512 и 65536) плюс несколько дополнительных байтов для каждого заголовка страницы. Количество дополнительных байтов, необходимых для заголовка страницы, можно определить с помощью &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. Если не считать потери памяти, безвредно, если параметр sz будет больше необходимого. Аргумент pMem должен быть либо указателем NULL, либо указателем на 8-байтовый выровненный блок памяти размером не менее sz * N байт, в противном случае последующее поведение не определено. Когда pMem не равен NULL, SQLite будет стремиться использовать предоставленную память для удовлетворения потребностей в кэше страниц, возвращаясь к &lt;a href=&quot;free&quot;&gt;sqlite3_malloc (),&lt;/a&gt; если строка кэша страницы превышает sz байтов или если весь буфер pMem исчерпан. Если pMem имеет значение NULL, а N не равно нулю, то каждое соединение с базой данных выполняет начальное массовое выделение памяти кеш-памяти страниц из &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt;достаточно для N строк кэша, если N положительно, или -1024 * N байт, если N отрицательно,. Если требуется дополнительная кеш-память страницы сверх того, что предусмотрено начальным выделением, то SQLite переходит к &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; отдельно для каждой дополнительной строки кеша.</target>
        </trans-unit>
        <trans-unit id="373c6de3bbf7db29ed258a5d09d9109fe9568cc5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2e2404fd6d076f4a9442bd42821a9709933fc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-defined page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1911f8a733a42d2b6026789f4ef363d83afb65d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">Параметр SQLITE_CONFIG_PCACHE2 принимает единственный аргумент, который является указателем на объект &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; . Этот объект определяет интерфейс для реализации пользовательского кэша страницы. SQLite создает копию объекта &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe0c16b7c9692df379eddfaf23502a1d2deb56c4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="translated">Параметр SQLITE_CONFIG_PCACHE2 принимает единственный аргумент, который является указателем на объект &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; . Этот объект определяет интерфейс для реализации пользовательского кэша страницы. SQLite создает копию объекта &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ecb0f208e89787f9a7f11980392d2014f2ef02a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">Параметр SQLITE_CONFIG_PCACHE_HDRSZ принимает один параметр, который является указателем на целое число, и записывает в это целое число количество дополнительных байтов на страницу, необходимое для каждой страницы в &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; . Требуемый объем дополнительного места может меняться в зависимости от компилятора, целевой платформы и версии SQLite.</target>
        </trans-unit>
        <trans-unit id="efc57facbbb1ece8f5d6410e99a1c9a1fcbbbc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="translated">Параметр SQLITE_CONFIG_PCACHE_HDRSZ принимает один параметр, который является указателем на целое число, и записывает в это целое число количество дополнительных байтов на страницу, необходимое для каждой страницы в &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; . Требуемый объем дополнительного места может меняться в зависимости от компилятора, целевой платформы и версии SQLite.</target>
        </trans-unit>
        <trans-unit id="c693040f9e2e760d6e4cb06df98665a33285d6df" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">Параметр SQLITE_CONFIG_PMASZ принимает единственный параметр, который представляет собой целое число без знака, и устанавливает &amp;laquo;Минимальный размер PMA&amp;raquo; для многопоточного сортировщика равным этому целому числу. Минимальный размер PMA по умолчанию устанавливается параметром &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_SORTER_PMASZ . Новые потоки запускаются для помощи в операциях сортировки, когда включена многопоточная сортировка (с использованием команды &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; ) и объем сортируемого содержимого превышает размер страницы, умноженный на минимум параметра &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; и этого значения.</target>
        </trans-unit>
        <trans-unit id="667ddbb0eaa86ffc653459dd23bacb289f6854a7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="translated">Параметр SQLITE_CONFIG_PMASZ принимает единственный параметр, который представляет собой целое число без знака, и устанавливает &amp;laquo;Минимальный размер PMA&amp;raquo; для многопоточного сортировщика равным этому целому числу. Минимальный размер PMA по умолчанию устанавливается параметром &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_SORTER_PMASZ . Новые потоки запускаются для помощи в операциях сортировки, когда включена многопоточная сортировка (с использованием команды &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; ) и объем сортируемого содержимого превышает размер страницы, умноженный на минимум параметра &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; и этого значения.</target>
        </trans-unit>
        <trans-unit id="109fdd8da62f03c0d4a96a618a19a71e802f905e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SCRATCH option is no longer used.</source>
          <target state="translated">Опция SQLITE_CONFIG_SCRATCH больше не используется.</target>
        </trans-unit>
        <trans-unit id="29ca3b2106e1eec121b349f9609e0d465c220d3d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SMALL_MALLOC option takes single argument of type int, interpreted as a boolean, which if true provides a hint to SQLite that it should avoid large memory allocations if possible. SQLite will run faster if it is free to make large memory allocations, but some application might prefer to run slower in exchange for guarantees about memory fragmentation that are possible if large allocations are avoided. This hint is normally off.</source>
          <target state="translated">Опция SQLITE_CONFIG_SMALL_MALLOC принимает единственный аргумент типа int,интерпретируемый как логический,который если переменная true дает подсказку SQLite,что по возможности следует избегать выделения больших объемов памяти.SQLite будет работать быстрее,если он может свободно выделять большие объемы памяти,но некоторое приложение может предпочесть работать медленнее в обмен на гарантии о фрагментации памяти,которая возможна,если избегать больших распределений.Эта подсказка обычно отключена.</target>
        </trans-unit>
        <trans-unit id="05ddcc0bca5d82f48fed51db87e518d3912d859e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">Параметр SQLITE_CONFIG_SORTERREF_SIZE принимает единственный параметр типа (int) - новое значение порога размера ссылки на сортировщик. Обычно, когда SQLite использует внешнюю сортировку для упорядочения записей в соответствии с предложением ORDER BY, все поля, требуемые вызывающей стороной, присутствуют в отсортированных записях. Однако, если SQLite определяет на основе объявленного типа столбца таблицы, что его значения, вероятно, будут очень большими - больше, чем настроенный порог размера ссылки сортировщика - тогда ссылка сохраняется в каждой отсортированной записи, а требуемые значения столбца загружаются из база данных в виде записей возвращается в отсортированном порядке. Значение по умолчанию для этой опции - никогда не использовать эту оптимизацию. Указание отрицательного значения для этого параметра восстанавливает поведение по умолчанию. Эта опция доступна, только если SQLite скомпилирован с&lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; параметр времени компиляции.</target>
        </trans-unit>
        <trans-unit id="8e4676f31515701431b60d8c3fec0783441a3fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="translated">Параметр SQLITE_CONFIG_SORTERREF_SIZE принимает единственный параметр типа (int) - новое значение порога размера ссылки на сортировщик. Обычно, когда SQLite использует внешнюю сортировку для упорядочения записей в соответствии с предложением ORDER BY, все поля, требуемые вызывающей стороной, присутствуют в отсортированных записях. Однако, если SQLite определяет на основе объявленного типа столбца таблицы, что его значения, вероятно, будут очень большими - больше, чем настроенный порог размера ссылки сортировщика - тогда ссылка сохраняется в каждой отсортированной записи, а требуемые значения столбца загружаются из база данных в виде записей возвращается в отсортированном порядке. Значение по умолчанию для этой опции - никогда не использовать эту оптимизацию. Указание отрицательного значения для этого параметра восстанавливает поведение по умолчанию. Эта опция доступна, только если SQLite скомпилирован с&lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; параметр времени компиляции.</target>
        </trans-unit>
        <trans-unit id="605f0b5884691b12b17ca06f9366cc2ade4cfd24" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">Параметр SQLITE_CONFIG_STMTJRNL_SPILL принимает единственный параметр, который становится порогом утечки &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;журнала операторов&lt;/a&gt; на диск. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;Журналы операторов&lt;/a&gt; хранятся в памяти до тех пор, пока их размер (в байтах) не превысит этот порог, после чего они записываются на диск. Или, если порог равен -1, журналы операторов всегда хранятся исключительно в памяти. Поскольку многие журналы операторов никогда не становятся большими, установка для порога утечки значения, такого как 64 КБ, может значительно уменьшить объем операций ввода-вывода, необходимых для поддержки отката операторов. Значение по умолчанию для этого параметра контролируется параметром &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_STMTJRNL_SPILL .</target>
        </trans-unit>
        <trans-unit id="c96a7bbc95d6882993f7d0afda36dce9d7d4b5c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="translated">Параметр SQLITE_CONFIG_STMTJRNL_SPILL принимает единственный параметр, который становится порогом утечки &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;журнала операторов&lt;/a&gt; на диск. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Журналы операторов&lt;/a&gt; хранятся в памяти до тех пор, пока их размер (в байтах) не превысит этот порог, после чего они записываются на диск. Или, если порог равен -1, журналы операторов всегда хранятся исключительно в памяти. Поскольку многие журналы операторов никогда не становятся большими, установка для порога утечки значения, такого как 64 КБ, может значительно уменьшить объем операций ввода-вывода, необходимых для поддержки отката операторов. Значение по умолчанию для этого параметра контролируется параметром &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;времени&lt;/a&gt; компиляции SQLITE_STMTJRNL_SPILL .</target>
        </trans-unit>
        <trans-unit id="e7c94d69eb75e63340f2383ddf68d20c1d31a18d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">Параметр SQLITE_CONFIG_URI принимает единственный аргумент типа int. Если не равно нулю, то обработка URI включена глобально. Если параметр равен нулю, то обработка URI отключена глобально. Если обработка URI включена глобально, все имена файлов, переданные в &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или указанные как часть команд &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; , интерпретируются как URI, независимо от того, установлен &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;ли&lt;/a&gt; флаг SQLITE_OPEN_URI при открытии соединения с базой данных. . Если он отключен глобально, имена файлов интерпретируются как URI, только если флаг SQLITE_OPEN_URI установлен при открытии соединения с базой данных. По умолчанию обработка URI отключена глобально. Значение по умолчанию может быть изменено путем компиляции с&lt;a href=&quot;compile#use_uri&quot;&gt;Определен&lt;/a&gt; символ SQLITE_USE_URI .</target>
        </trans-unit>
        <trans-unit id="4ab4ffd66152d39e37a9eeebeb02a7852ae9ede8" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="translated">Параметр SQLITE_CONFIG_URI принимает единственный аргумент типа int. Если не равно нулю, то обработка URI включена глобально. Если параметр равен нулю, то обработка URI отключена глобально. Если обработка URI включена глобально, все имена файлов, переданные в &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; или указанные как часть команд &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; , интерпретируются как URI, независимо от того, установлен &lt;a href=&quot;c_open_autoproxy&quot;&gt;ли&lt;/a&gt; флаг SQLITE_OPEN_URI при открытии соединения с базой данных. . Если он отключен глобально, имена файлов интерпретируются как URI, только если флаг SQLITE_OPEN_URI установлен при открытии соединения с базой данных. По умолчанию обработка URI отключена глобально. Значение по умолчанию может быть изменено путем компиляции с&lt;a href=&quot;../compile#use_uri&quot;&gt;Определен&lt;/a&gt; символ SQLITE_USE_URI .</target>
        </trans-unit>
        <trans-unit id="b4ea1f91dd128d45077ef6aab24be62cde2c08e4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">Параметр SQLITE_CONFIG_WIN32_HEAPSIZE доступен только в том случае, если SQLite скомпилирован для Windows с определенным &lt;a href=&quot;../compile#win32_malloc&quot;&gt;макросом препроцессора SQLITE_WIN32_MALLOC&lt;/a&gt; . SQLITE_CONFIG_WIN32_HEAPSIZE принимает 32-разрядное целое число без знака, которое указывает максимальный размер создаваемой кучи.</target>
        </trans-unit>
        <trans-unit id="55987e1e9f78159dc547356995af9fe3ce5c9817" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="translated">Параметр SQLITE_CONFIG_WIN32_HEAPSIZE доступен только в том случае, если SQLite скомпилирован для Windows с определенным &lt;a href=&quot;compile#win32_malloc&quot;&gt;макросом препроцессора SQLITE_WIN32_MALLOC&lt;/a&gt; . SQLITE_CONFIG_WIN32_HEAPSIZE принимает 32-разрядное целое число без знака, которое указывает максимальный размер создаваемой кучи.</target>
        </trans-unit>
        <trans-unit id="90354942dff120bb22a653ae9fa0d244342b89da" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT code can also be used as the return value from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.</source>
          <target state="translated">Код SQLITE_CONSTRAINT также можно использовать как возвращаемое значение из &lt;a href=&quot;vtab#xbestindex&quot;&gt;метода xBestIndex ()&lt;/a&gt; реализации &lt;a href=&quot;vtab&quot;&gt;виртуальной таблицы&lt;/a&gt; . Когда xBestIndex () возвращает SQLITE_CONSTRAINT, это указывает на то, что конкретная комбинация входных данных, отправленных в xBestIndex (), не может привести к пригодному для использования плану запроса и не должна рассматриваться в дальнейшем.</target>
        </trans-unit>
        <trans-unit id="cd3afc5f9dc7b86d4db8138dda7591ba7ea2f042" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt;) or by looking at the &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT означает, что при попытке обработать оператор SQL произошло нарушение ограничения SQL. Дополнительную информацию о неудавшемся ограничении можно найти, просмотрев сопроводительное сообщение об ошибке (возвращаемое через &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; или &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; ) или просмотрев &lt;a href=&quot;rescode#extrc&quot;&gt;расширенный код ошибки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1402b83ad789cf26361c62d000ccad7aa66cb251" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_CHECK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; failed.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_CHECK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT,&lt;/a&gt; указывающий на сбой &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;ограничения CHECK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59f7b5e1d1fc684ffe767053e5ae405c247a79ff" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_COMMITHOOK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;c3ref/commit_hook&quot;&gt;commit hook callback&lt;/a&gt; returned non-zero that thus caused the SQL statement to be rolled back.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_COMMITHOOK - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT,&lt;/a&gt; указывающий, что &lt;a href=&quot;c3ref/commit_hook&quot;&gt;обратный вызов ловушки фиксации&lt;/a&gt; вернул ненулевое значение, что, таким образом, вызвало откат оператора SQL.</target>
        </trans-unit>
        <trans-unit id="c857f1295fd44fc161f41f3c36b1faa547511cbf" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FOREIGNKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; failed.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_FOREIGNKEY - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT,&lt;/a&gt; указывающий на сбой &lt;a href=&quot;foreignkeys&quot;&gt;ограничения внешнего ключа&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa48ddcf19118820df2cdaa1b78eb70d4071dd14" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_FUNCTION в настоящее время не используется ядром SQLite.Однако этот код ошибки доступен для использования функциями расширения.</target>
        </trans-unit>
        <trans-unit id="3c4481d9380cb514a86e596c21d0da6c70c2337c" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_NOTNULL error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL constraint&lt;/a&gt; failed.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_NOTNULL - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT,&lt;/a&gt; указывающий на сбой &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;ограничения NOT NULL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b921914ef5b1ae6eddb9ee04650c5c235d49ed11" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_PRIMARYKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; failed.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_PRIMARYKEY - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT,&lt;/a&gt; указывающий на сбой &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;ограничения PRIMARY KEY&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d2416f0eb5c1e4932d96de2c633168fe0745690" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_ROWID error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not unique.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_ROWID - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT,&lt;/a&gt; указывающий, что &lt;a href=&quot;lang_createtable#rowid&quot;&gt;идентификатор &lt;/a&gt;строки не является уникальным.</target>
        </trans-unit>
        <trans-unit id="d42ea811023ed01aef8eff1b26fe2bb9abe7bb95" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_TRIGGER error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE function&lt;/a&gt; within a &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt; fired, causing the SQL statement to abort.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_TRIGGER - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT,&lt;/a&gt; указывающий, что сработала &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;функция RAISE&lt;/a&gt; в &lt;a href=&quot;lang_createtrigger&quot;&gt;триггере&lt;/a&gt; , в результате чего оператор SQL был прерван.</target>
        </trans-unit>
        <trans-unit id="360095776d45f4673d25e1354d178fe2a9b1bd8f" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_UNIQUE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; failed.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_UNIQUE - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT,&lt;/a&gt; указывающий на сбой &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;ограничения UNIQUE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2591670580b26a952a816bde9a68b915c405d78" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">Код ошибки SQLITE_CONSTRAINT_VTAB в настоящее время не используется ядром SQLite. Однако этот код ошибки доступен для использования &lt;a href=&quot;vtab&quot;&gt;виртуальными таблицами,&lt;/a&gt; определяемыми приложением .</target>
        </trans-unit>
        <trans-unit id="ca22607c1bc11adbc4850780682a00fc2af063db" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt; for further discussion on how corruption can occur.</source>
          <target state="translated">Код результата SQLITE_CORRUPT указывает, что файл базы данных был поврежден. См. &amp;laquo; &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;Как повредить файлы базы данных&amp;raquo;&lt;/a&gt; для дальнейшего обсуждения того, как может произойти повреждение.</target>
        </trans-unit>
        <trans-unit id="83192f645bf11cddd8fa598bcc30dab724111331" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_SEQUENCE result code means that the schema of the sqlite_sequence table is corrupt. The sqlite_sequence table is used to help implement the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. The sqlite_sequence table should have the following format:</source>
          <target state="translated">Код результата SQLITE_CORRUPT_SEQUENCE означает, что схема таблицы sqlite_sequence повреждена. Таблица sqlite_sequence используется для помощи в реализации функции &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; . Таблица sqlite_sequence должна иметь следующий формат:</target>
        </trans-unit>
        <trans-unit id="e605977504524c24f74112f64c7f554569d710cb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_VTAB error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; used by &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.</source>
          <target state="translated">Код ошибки SQLITE_CORRUPT_VTAB - это &lt;a href=&quot;rescode#pve&quot;&gt;расширенный код ошибки&lt;/a&gt; для &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT,&lt;/a&gt; используемый &lt;a href=&quot;vtab&quot;&gt;виртуальными таблицами&lt;/a&gt; . &lt;a href=&quot;vtab&quot;&gt;Виртуальная таблица&lt;/a&gt; может вернуться SQLITE_CORRUPT_VTAB , чтобы указать , что содержание в виртуальной таблице повреждено.</target>
        </trans-unit>
        <trans-unit id="6f5aeac16ee13da96d49c9c69d5a1efa4f1ec4c7" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DEFENSIVE option activates or deactivates the &quot;defensive&quot; flag for a database connection. When the defensive flag is enabled, language features that allow ordinary SQL to deliberately corrupt the database file are disabled. The disabled features include but are not limited to the following:</source>
          <target state="translated">Опция SQLITE_DBCONFIG_DEFENSIVE активирует или деактивирует флаг &quot;оборонительный&quot; для подключения к БД.Когда флаг защиты включен,функции языка,которые позволяют обычному SQL сознательно повреждать файл базы данных,отключаются.Отключенные функции включают в себя,но не ограничиваются следующим:</target>
        </trans-unit>
        <trans-unit id="b1c89dddb1e567654969cbefc3cb66f653fb53df" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_DQS активирует или деактивирует устаревший &lt;a href=&quot;../quirks#dblquote&quot;&gt;строковый литерал с&lt;/a&gt; двойными кавычками для операторов DDL, таких как CREATE TABLE и CREATE INDEX. Значение по умолчанию для этого параметра определяется параметром &lt;a href=&quot;../compile#dqs&quot;&gt;времени&lt;/a&gt; компиляции -DSQLITE_DQS .</target>
        </trans-unit>
        <trans-unit id="5fa9af190de834f94817db4398afc2b28f903d62" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_DQS активирует или деактивирует устаревший &lt;a href=&quot;quirks#dblquote&quot;&gt;строковый литерал с&lt;/a&gt; двойными кавычками для операторов DDL, таких как CREATE TABLE и CREATE INDEX. Значение по умолчанию для этого параметра определяется параметром &lt;a href=&quot;compile#dqs&quot;&gt;времени&lt;/a&gt; компиляции -DSQLITE_DQS .</target>
        </trans-unit>
        <trans-unit id="7a4f8ed114b3f33c0656fd3fe462891e36a86bca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_DQS_DML активирует или деактивирует устаревшую ошибку &lt;a href=&quot;../quirks#dblquote&quot;&gt;строкового литерала&lt;/a&gt; в двойных кавычках только для оператора DML, то есть операторов DELETE, INSERT, SELECT и UPDATE. Значение по умолчанию для этого параметра определяется параметром &lt;a href=&quot;../compile#dqs&quot;&gt;времени&lt;/a&gt; компиляции -DSQLITE_DQS .</target>
        </trans-unit>
        <trans-unit id="5ef07fd34a275a246ee518a98e66084fe0a55fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statements only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23b83b3528f7ad3365bcce16b9fcdca7b11634b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="translated">Параметр SQLITE_DBCONFIG_DQS_DML активирует или деактивирует устаревшую ошибку &lt;a href=&quot;quirks#dblquote&quot;&gt;строкового литерала&lt;/a&gt; в двойных кавычках только для оператора DML, то есть операторов DELETE, INSERT, SELECT и UPDATE. Значение по умолчанию для этого параметра определяется параметром &lt;a href=&quot;compile#dqs&quot;&gt;времени&lt;/a&gt; компиляции -DSQLITE_DQS .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
