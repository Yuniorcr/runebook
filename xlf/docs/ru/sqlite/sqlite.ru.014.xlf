<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="ec4c139f470f21c5fe4e5b5cefa7700a1825e05d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parent table&lt;/b&gt; is the table that a foreign key constraint refers to. The parent table in the example in this section is the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36aa5afa4e61953d1ec495c1b005644b052981bb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;porter&lt;/b&gt; tokenizer, which implements the &lt;a href=&quot;http://tartarus.org/martin/PorterStemmer/&quot;&gt;porter stemming algorithm&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37111e2fe594df629017fae4b6e16c1ee66e480" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;safe-append&lt;/b&gt; property. If a system supports the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6885cc42a1a11dedbc2ecde02a62efeb92c5994" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;schema=&lt;/b&gt; argument specifies a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement that the CSV virtual table passes to the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; interface in order to define the names of the columns in the virtual table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062e562546606b031a29c9b1538d01a4933fdf4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sequential-write&lt;/b&gt; property. A system that supports the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a93bd9a21f342ac487fc44f9c521120beed1f0d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command is used as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd9a1c77e9aedcf3a7d203f467b8767663fc753" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite3&lt;/b&gt; command opens the database named in the second argument. If the database does not already exist, the default behavior is for it to be created automatically (though this can be changed by using the &quot;&lt;b&gt;-create false&lt;/b&gt;&quot; option). The &lt;b&gt;sqlite3&lt;/b&gt; command always creates a new Tcl command to control the database. The name of the new Tcl command is given by the first argument. This approach is similar to the way widgets are created in Tk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b032b475b9199ee134a35698c55445c506e1d56e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite&lt;/b&gt; command-line utility uses the &lt;b&gt;sqlite_complete&lt;/b&gt; function to know when it needs to call &lt;b&gt;sqlite_exec&lt;/b&gt;. After each line of input is received, &lt;b&gt;sqlite&lt;/b&gt; calls &lt;b&gt;sqlite_complete&lt;/b&gt; on all input in its buffer. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns true, then &lt;b&gt;sqlite_exec&lt;/b&gt; is called and the input buffer is reset. If &lt;b&gt;sqlite_complete&lt;/b&gt; returns false, then the prompt is changed to the continuation prompt and another line of text is read and added to the input buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332726262d6ef917130298a44650660fb1ebc042" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_busy_handler&lt;/b&gt; procedure can be used to register a busy callback with an open SQLite database. The busy callback will be invoked whenever SQLite tries to access a database that is locked. The callback will typically do some other useful work, or perhaps sleep, in order to give the lock a chance to clear. If the callback returns non-zero, then SQLite tries again to access the database and the cycle repeats. If the callback returns zero, then SQLite aborts the current operation and returns SQLITE_BUSY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21449bf7fdcd477c05c71384163b9f8717a257f0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_changes&lt;/b&gt; API function returns the number of rows that have been inserted, deleted, or modified since the database was last quiescent. A &quot;quiescent&quot; database is one in which there are no outstanding calls to &lt;b&gt;sqlite_exec&lt;/b&gt; and no VMs created by &lt;b&gt;sqlite_compile&lt;/b&gt; that have not been finalized by &lt;b&gt;sqlite_finalize&lt;/b&gt;. In common usage, &lt;b&gt;sqlite_changes&lt;/b&gt; returns the number of rows inserted, deleted, or modified by the most recent &lt;b&gt;sqlite_exec&lt;/b&gt; call or since the most recent &lt;b&gt;sqlite_compile&lt;/b&gt;. But if you have nested calls to &lt;b&gt;sqlite_exec&lt;/b&gt; (that is, if the callback routine of one &lt;b&gt;sqlite_exec&lt;/b&gt; invokes another &lt;b&gt;sqlite_exec&lt;/b&gt;) or if you invoke &lt;b&gt;sqlite_compile&lt;/b&gt; to create a new VM while there is still another VM in existence, then the meaning of the number returned by &lt;b&gt;sqlite_changes&lt;/b&gt; is more complex. The number reported includes any changes that were later undone by a ROLLBACK or ABORT. But rows that are deleted because of a DROP TABLE are &lt;em&gt;not&lt;/em&gt; counted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ea929e712b658454a0d7a7507e5e6040d334f9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_compile&lt;/b&gt; &quot;compiles&quot; a single SQL statement (specified by the second parameter) and generates a virtual machine that is able to execute that statement. As with must interface routines, the first parameter must be a pointer to an sqlite structure that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11aed5342f0d3f43d8e5e9d1781269c400901176" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_create_function()&lt;/b&gt; interface is used to create regular functions and &lt;b&gt;sqlite_create_aggregate()&lt;/b&gt; is used to create new aggregate functions. In both cases, the &lt;b&gt;db&lt;/b&gt; parameter is an open SQLite database on which the functions should be registered, &lt;b&gt;zName&lt;/b&gt; is the name of the new function, &lt;b&gt;nArg&lt;/b&gt; is the number of arguments, and &lt;b&gt;pUserData&lt;/b&gt; is a pointer which is passed through unchanged to the C implementation of the function. Both routines return 0 on success and non-zero if there are any errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5689a09fe87990c5eb5859050a66b6bf0ba7128a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function is used to process SQL statements and queries. This function requires 5 parameters as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="121679113b5d1c7ddf7783cb3755cec086d10308" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; function normally returns SQLITE_OK. But if something goes wrong it can return a different value to indicate the type of error. Here is a complete list of the return codes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655f344d54e7a8508c37039b0267420f9c98a884" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_exec&lt;/b&gt; routine described above used to be the only way to retrieve data from an SQLite database. But many programmers found it inconvenient to use a callback function to obtain results. So beginning with SQLite version 2.7.7, a second access interface is available that does not use callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4f5ac57e80af00b368fb64cb711d6dc8b648f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_finalize&lt;/b&gt; routine also returns the result code that indicates success or failure of the SQL operation that the virtual machine carried out. The value returned by sqlite_finalize() will be the same as would have been returned had the same SQL been executed by &lt;b&gt;sqlite_exec&lt;/b&gt;. The error message returned will also be the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fe3b872ae55549d978788ef7dd0751c76061d1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table()&lt;/b&gt; function now returns an error if you give it two or more SELECTs that return different numbers of columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c359ecc30c529f766becf568f4c268c432080f6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; function is a wrapper around &lt;b&gt;sqlite_exec&lt;/b&gt; that collects all the information from successive callbacks and writes it into memory obtained from malloc(). This is a convenience function that allows the application to get the entire result of a database query with a single function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc054248626971621053a5f41a56a6eacfcebb24" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_get_table&lt;/b&gt; routine returns the same integer result code as &lt;b&gt;sqlite_exec&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd292002416cc2983b3342d6c1953e82de8e1607" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_interrupt&lt;/b&gt; function can be called from a different thread or from a signal handler to cause the current database operation to exit at its first opportunity. When this happens, the &lt;b&gt;sqlite_exec&lt;/b&gt; routine (or the equivalent) that started the database operation will return SQLITE_INTERRUPT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110634f7ff21aac9a3d6ba9124f053cdf818f538" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_mprintf()&lt;/b&gt; routine works like the standard library &lt;b&gt;sprintf()&lt;/b&gt; except that it writes its results into memory obtained from malloc() and returns a pointer to the malloced buffer. &lt;b&gt;sqlite_mprintf()&lt;/b&gt; also understands the %q and %Q extensions described above. The &lt;b&gt;sqlite_vmprintf()&lt;/b&gt; is a varargs version of the same routine. The string pointer that these routines return should be freed by passing it to &lt;b&gt;sqlite_freemem()&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c001281fc04cb0f8f55a953f44815f9bb2acd94" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; routine can be used to register a callback routine with an SQLite database to be invoked periodically during long running calls to &lt;b&gt;sqlite_exec()&lt;/b&gt;, &lt;b&gt;sqlite_step()&lt;/b&gt; and the various wrapper functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2365ff095ada5e9e18ca628c551aa06ded148313" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;unicode61&lt;/b&gt; tokenizer, based on the Unicode 6.1 standard. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89f587843e082fe105c35ca8b1efaa6d37ded8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files already exists and are readable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae74358eb64792c48dfddc93166fad33cb929d0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqldiff.exe&lt;/code&gt; binary is a command-line utility program that displays the differences between SQLite databases. Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c66765c0cb2c27b3a6401331165fc804dadc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; binary is a command-line utility program that measures and displays how much and how efficiently space is used by individual tables and indexes with an SQLite database file. Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1974b0f327d4817e6c9b37b72d6c96039edec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sqlite3_analyzer.exe&lt;/code&gt; program is a &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; program that uses the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; to gather information about the database file and then format that information neatly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef70743aa444e28fbab143ed138c4d54acc4ad9c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;lt;name&amp;gt;&lt;/em&gt; is the name your application chooses for the R*Tree index and &lt;em&gt;&amp;lt;column-names&amp;gt;&lt;/em&gt; is a comma separated list of between 3 and 11 columns. The virtual &amp;lt;name&amp;gt; table creates three &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; to actually store its content. The names of these shadow tables are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfd2051780cda360472504e6c22be9c660375526" translate="yes" xml:space="preserve">
          <source>The ADD COLUMN syntax is used to add a new column to an existing table. The new column is always appended to the end of the list of existing columns. The &lt;a href=&quot;syntax/column-def&quot;&gt;column-def&lt;/a&gt; rule defines the characteristics of the new column. The new column may take any of the forms permissible in a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, with the following restrictions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4a8c42527cc6ad0b74da94ea18e9ecc2a5a9ab" translate="yes" xml:space="preserve">
          <source>The ALTER TABLE command works by modifying the SQL text of the schema stored in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;. No changes are made to table content. Because of this, the execution time of the ALTER TABLE command is independent of the amount of data in the table. The ALTER TABLE command runs as quickly on a table with 10 million rows as it does on a table with 1 row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3548d68842f13a30875b616a72010deb210b5992" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros are a weaker statement about the truth of X. The presence of ALWAYS(X) or NEVER(X) means that the developers believe X is always or never true, but there is no proof, or the proof is complex and error-prone, or the proof depends on other aspects of the system that seem likely to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae8b97d0df4ab8cc5246397daf337e302574c90" translate="yes" xml:space="preserve">
          <source>The ALWAYS(X) and NEVER(X) macros behave like assert(X) during functionality testing, because the developers want to be immediately alerted to the issue if the value of X is different from what is expected. But for delivery, ALWAYS(X) and NEVER(X) are simple pass-through macros, which provide defense-in-depth. For coverage testing ALWAYS(X) and NEVER(X) are hard-coded boolean values so that they do not cause unreachable machine code to be generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07bd491ac7cf8d45ca2e35ee71bfa7a388a2b49" translate="yes" xml:space="preserve">
          <source>The ANALYZE command gathers statistics about tables and indices and stores the collected information in &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; of the database where the query optimizer can access the information and use it to help make better query planning choices. If no arguments are given, all attached databases are analyzed. If a schema name is given as the argument, then all tables and indices in that one database are analyzed. If the argument is a table name, then only that table and the indices associated with that table are analyzed. If the argument is an index name, then only that one index is analyzed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab24cd68f511dec396088e10ba12e5df9e965d6" translate="yes" xml:space="preserve">
          <source>The AND operator determines the &lt;b&gt;intersection&lt;/b&gt; of two sets of documents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b6d448d425bac9ff08d9f7709bfd23114eaa1f" translate="yes" xml:space="preserve">
          <source>The AND operator may be implicitly specified. If two basic queries appear with no operator separating them in an FTS query string, the results are the same as if the two basic queries were separated by an AND operator. For example, the query expression &quot;implicit operator&quot; is a more succinct version of &quot;implicit AND operator&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938085178daf2eb44e4c20ce7562d652c273a4d4" translate="yes" xml:space="preserve">
          <source>The API for SQLite 3.0 includes 83 separate functions in addition to several data structures and #defines. (A complete &lt;a href=&quot;c3ref/intro&quot;&gt;API reference&lt;/a&gt; is provided as a separate document.) Fortunately, the interface is not nearly as complex as its size implies. Simple programs can still make do with only 3 functions: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;. More control over the execution of the database engine is provided using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; to compile an SQLite statement into byte code and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; to execute that bytecode. A family of routines with names beginning with &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_&lt;/a&gt; is used to extract information about the result set of a query. Many interface functions come in pairs, with both a UTF-8 and UTF-16 version. And there is a collection of routines used to implement user-defined SQL functions and user-defined text collating sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44a4b3ab13cd66c53e9432e0d3af7281c445940" translate="yes" xml:space="preserve">
          <source>The API for version 3.0 is similar to the version 2.X API, but with some important changes. Most noticeably, the &quot;&lt;code&gt;sqlite_&lt;/code&gt;&quot; prefix that occurs on the beginning of all API functions and data structures are changed to &quot;&lt;code&gt;sqlite3_&lt;/code&gt;&quot;. This avoids confusion between the two APIs and allows linking against both SQLite 2.X and SQLite 3.0 at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d190e36c6e5fa5963aab7e95daad2e70b8ee67" translate="yes" xml:space="preserve">
          <source>The ATTACH DATABASE statement adds another database file to the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Database files that were previously attached can be removed using the &lt;a href=&quot;lang_detach&quot;&gt;DETACH DATABASE&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e719935b3c48aaab57f1043bcfdf280a49c9b8d" translate="yes" xml:space="preserve">
          <source>The AUTOINCREMENT keyword imposes extra CPU, memory, disk space, and disk I/O overhead and should be avoided if not strictly needed. It is usually not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48851d12ae740edbaa05f50e23f70eaa76ffb64c" translate="yes" xml:space="preserve">
          <source>The Ascii tokenizer is similar to the Unicode61 tokenizer, except that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12502ac36995aeed690062079cb8e1d738f368d7" translate="yes" xml:space="preserve">
          <source>The B-tree module requests information from the disk in fixed-size pages. The default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; is 4096 bytes but can be any power of two between 512 and 65536 bytes. The page cache is responsible for reading, writing, and caching these pages. The page cache also provides the rollback and atomic commit abstraction and takes care of locking of the database file. The B-tree driver requests particular pages from the page cache and notifies the page cache when it wants to modify pages or commit or rollback changes. The page cache handles all the messy details of making sure the requests are handled quickly, safely, and efficiently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c46870576aba5a82ba72dd5f506b8ec80b72f2" translate="yes" xml:space="preserve">
          <source>The BEFORE or AFTER keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63dc07d0b34107d9ff47bbfc25d958a7f1dde76" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7d42c3d7c926828f621e364e6fa7e162b22076" translate="yes" xml:space="preserve">
          <source>The BETWEEN operator is logically equivalent to a pair of comparisons. &quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2bdb770820ef0c5e362d9c32237f45d4cd0627c" translate="yes" xml:space="preserve">
          <source>The BLOB argument to snippet() does not have the correct subtype, so the snippet function ignores it, makes no changes to any data structures, and harmlessly returns NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3210a7f9aaf2f66bd9905568531663be357a3b69" translate="yes" xml:space="preserve">
          <source>The BTree module allocates large buffers using malloc() instead of off of the stack, in order to play better on machines with limited stack space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21f5d882ac3e8071ceb7ad0fcec2c3ef4f2e3e7c" translate="yes" xml:space="preserve">
          <source>The C code below implements a simple window aggregate function named sumint(). This works in the same way as the built-in sum() function, except that it throws an exception if passed an argument that is not an integer value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cf82df30f7e154d46c9db25174e218f7ef9aef" translate="yes" xml:space="preserve">
          <source>The C function to the right demonstrates one of the simplest, and most common, uses of the backup API: loading and saving the contents of an in-memory database to a file on disk. The backup API is used as follows in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54a9c2fa57a9ea05dba3dee97529bc735dc5276" translate="yes" xml:space="preserve">
          <source>The C language interface to SQLite Version 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe37317d6916dca66fe00426df36e00a240b1501" translate="yes" xml:space="preserve">
          <source>The C language is old and boring. It is a well-known and well-understood language. This is exactly what one wants when developing a module like SQLite. Writing a small, fast, and reliable database engine is hard enough as it is without the implementation language changing out from under you with each update to the implementation language specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7245ee6098ebc8d6b59383d4e63478298246efb9" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0540d8d33318130da25d1e55f755e6a1ecc3bb" translate="yes" xml:space="preserve">
          <source>The C parameter to &lt;a href=&quot;close&quot;&gt;sqlite3_close(C)&lt;/a&gt; and &lt;a href=&quot;close&quot;&gt;sqlite3_close_v2(C)&lt;/a&gt; must be either a NULL pointer or an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object pointer obtained from &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and not previously closed. Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer argument is a harmless no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b84eb128b8b4492347bcdafbeda21b63c03f1b" translate="yes" xml:space="preserve">
          <source>The C-language API for SQLite provides the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; which gives &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations the opportunity to add new PRAGMA statements or to override the meaning of built-in PRAGMA statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdde2acd27b2b36bcb4e6d376af3a07b88f1a00" translate="yes" xml:space="preserve">
          <source>The CASE expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66ba15f2fad294f2684c4bed978c753222465dc" translate="yes" xml:space="preserve">
          <source>The CAST operator understands decimal integers only &amp;mdash; conversion of &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integers&lt;/a&gt; stops at the &quot;x&quot; in the &quot;0x&quot; prefix of the hexadecimal integer string and thus result of the CAST is always zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a234c8e77cd8f0401958366a773fd160b49e7507" translate="yes" xml:space="preserve">
          <source>The CLI has another build-in SQL function named edit(). Edit() takes one or two arguments. The first argument is a value - usually a large multi-line string to be edited. The second argument is the name of a text editor. If the second argument is omitted, the VISUAL environment variable is used. The edit() function writes its first argument into a temporary file, invokes the editor on the temporary file, rereads the file back into memory after the editor is done, then returns the edited text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b42365ba0a7a06fdcdf543ad6806dc3520342c" translate="yes" xml:space="preserve">
          <source>The CLI ignores whitespace (including comments) at the end of lines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9e96d76e423f66ac741c4a46deda1233291328" translate="yes" xml:space="preserve">
          <source>The COLLATE clause optionally following each column name or expression defines a collating sequence used for text entries in that column. The default collating sequence is the collating sequence defined for that column in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Or if no collating sequence is otherwise defined, the built-in BINARY collating sequence is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce4b68250de466854c34f5909554bfe291d7ca1" translate="yes" xml:space="preserve">
          <source>The COLLATE clause specifies the name of a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to use as the default collation sequence for the column. If no COLLATE clause is specified, the default collation sequence is &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b44ceebb8207f8e640174bbe459b285c5b2aace" translate="yes" xml:space="preserve">
          <source>The COLLATE operator is a unary postfix operator that assigns a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; to an expression. The COLLATE operator has a higher precedence (binds more tightly) than any binary operator and any unary prefix operator except &quot;~&quot;. (COLLATE and &quot;~&quot; are associative so their binding order does not matter.) The collating sequence set by the COLLATE operator overrides the collating sequence determined by the COLLATE clause in a table &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. See the &lt;a href=&quot;datatype3#collation&quot;&gt;detailed discussion on collating sequences&lt;/a&gt; in the &lt;a href=&quot;datatype3&quot;&gt;Datatype In SQLite3&lt;/a&gt; document for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a680bd512c99945ec1f5ce6f701753b4eac29105" translate="yes" xml:space="preserve">
          <source>The COMPLETION extension implements a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; named &quot;completion&quot; that can be used to suggest completions of partially entered words during interactive SQL input. The completion table can be used to help implement tab-completion, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18272789e8a6f151079fbc600b2b7e84d838750" translate="yes" xml:space="preserve">
          <source>The COMPLETION() Table-Valued Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7ddb1a93117b2b3bde0c54048509560ea3634c" translate="yes" xml:space="preserve">
          <source>The COPY command puts NULLs in columns whose data is '\N'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eb987eb47f3316a50f4573a4bd655a2e5a8454" translate="yes" xml:space="preserve">
          <source>The CORRUPT_DB macro is used in many assert() statements. In functional testing builds, CORRUPT_DB references a global variable that is true if the database file might contain corruption. This variable is true by default, since we do not normally know whether or not a database is corrupt, but during testing while working on databases that are known to be well-formed, that global variable can be set to false. Then the CORRUPT_DB macro can be used in assert() statements such as seen at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=1679-1680&lt;/a&gt;. Those assert()s specify pre-conditions to the routine that are true for consistent database files, but which might be false if the database file is corrupt. Knowledge of these kinds of conditions is very helpful to readers who are trying to understand a block of code in isolation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b68f64512a185516fdf233a80a1c3ea3aa60fd" translate="yes" xml:space="preserve">
          <source>The CREATE INDEX command consists of the keywords &quot;CREATE INDEX&quot; followed by the name of the new index, the keyword &quot;ON&quot;, the name of a previously created table that is to be indexed, and a parenthesized list of table column names and/or expressions that are used for the index key. If the optional WHERE clause is included, then the index is a &quot;&lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abdfd2b1dd5fd6ecf72fce71bade948329a001e4" translate="yes" xml:space="preserve">
          <source>The CREATE TRIGGER statement is used to add triggers to the database schema. Triggers are database operations that are automatically performed when a specified database event occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="598d64a270f59326bd978afae12168eba5f52ca0" translate="yes" xml:space="preserve">
          <source>The CREATE VIEW command assigns a name to a pre-packaged &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. Once the view is created, it can be used in the FROM clause of another &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; in place of a table name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="174705dc4a8b591705076f7ea08e69231535552a" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE &quot;tokenize&quot; option is used to configure the specific tokenizer used by the FTS5 table. The option argument must be either an FTS5 bareword, or an SQL text literal. The text of the argument is itself treated as a white-space series of one or more FTS5 barewords or SQL text literals. The first of these is the name of the tokenizer to use. The second and subsequent list elements, if they exist, are arguments passed to the tokenizer implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5585953bde77b974603ba3ea6e6ff59c9cc91b38" translate="yes" xml:space="preserve">
          <source>The CREATE VIRTUAL TABLE statement creates a new table called table-name derived from the class class module-name. The module-name is the name that is registered for the virtual table by the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1062968fd409aff74d10cea95e91438b9101e01c" translate="yes" xml:space="preserve">
          <source>The CREATE, TABLE, VIEW, TRIGGER, and INDEX keywords at the beginning of the statement are converted to all upper case letters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640a12b822aa85aa459e9a1bb86ef50f7f04eecb" translate="yes" xml:space="preserve">
          <source>The CSV Virtual Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7457dbcb832f7358700e049001b26f6040f77dbe" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is not built into the SQLite amalgamation. It is available as a &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/csv.c&quot;&gt;separate source file&lt;/a&gt; that can be compiled into a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. Typical usage of the CSV virtual table from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; would be something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b49f55e220937bbbf59d823ad49d5a9aa75e6b" translate="yes" xml:space="preserve">
          <source>The CSV virtual table is useful to applications that need to bulk-load large amounts of comma-separated value content. The CSV virtual table is also useful as a template source file for implementing other virtual tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea497adefbfc963344834dc953220548ab21ec73" translate="yes" xml:space="preserve">
          <source>The CSV virtual table reads &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated values, and returns that content as if it were rows and columns of an SQL table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701ea259a9685ea4d0bc43814eed54520d975a72" translate="yes" xml:space="preserve">
          <source>The Callback instruction in this example has to generate data for three result columns instead of two, but is otherwise the same as in the first query. When the Callback instruction is invoked, the left-most column of the result should be the lowest in the stack and the right-most result column should be the top of the stack. We can see the stack being set up this way at addresses 11 through 15. The Column instructions at 11 and 12 push the values for the first two columns in the result. The two Column instructions at 13 and 14 pull in the values needed to compute the third result column and the Concat instruction at 15 joins them together into a single entry on the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421f0a20824677ed3aab71d6f46b98a38cc2b1ed" translate="yes" xml:space="preserve">
          <source>The Carray() Table-Valued Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6379901f8c254a706f0c6dbee9e66ad0809b055" translate="yes" xml:space="preserve">
          <source>The Checklist Manifesto</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16740a57ff0b848b3dcfa1e89789fe4179b42d5" translate="yes" xml:space="preserve">
          <source>The Clang/LLVM compiler is not competitive with GCC. Clang-generated binaries are consistently larger and slower than GCC-generated binaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bc8f511390974d6caf83474dc6a28ef2586f49" translate="yes" xml:space="preserve">
          <source>The Close instruction at the end of the program closes the cursor that points into the table &quot;examp&quot;. It is not really necessary to call Close here since all cursors will be automatically closed by the VDBE when the program halts. But we needed an instruction for the Rewind to jump to so we might as well go ahead and have that instruction do something useful. The Halt instruction ends the VDBE program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b524e42667c1ac047d027b2497617d613c12fde4" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f80ea416ab3893dba34d3603b147323625f4c5ae" translate="yes" xml:space="preserve">
          <source>The D and N arguments to sqlite3_backup_init(D,N,S,M) are the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; associated with the destination database and the database name, respectively. The database name is &quot;main&quot; for the main database, &quot;temp&quot; for the temporary database, or the name specified after the AS keyword in an &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for an attached database. The S and M arguments passed to sqlite3_backup_init(D,N,S,M) identify the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and database name of the source database, respectively. The source and destination &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; (parameters S and D) must be different or else sqlite3_backup_init(D,N,S,M) will fail with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1eeb8e873e48b54ccf8adc2382597a61daec29" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7435a55126fe3b0801a03e561888366bace9433" translate="yes" xml:space="preserve">
          <source>The D parameter to &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; may be NULL. If the D parameter in &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new(D)&lt;/a&gt; is not NULL, then the maximum length of the string contained in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object will be the value set for &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(D,&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) instead of &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="091a2ba2d55b0a7d15b54d374b18e4d57aa3a683" translate="yes" xml:space="preserve">
          <source>The DBSTAT Virtual Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53bde0cca31e9e282f188b556d84747d1c6f1e06" translate="yes" xml:space="preserve">
          <source>The DBSTAT virtual table is a read-only &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that returns information about which pages of the database files are used by which tables and indexes in the schema. The DBSTAT virtual table is used to implement &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer.exe&lt;/a&gt; utility program, and to help compute the &lt;a href=&quot;https://www.sqlite.org/src/repo-tabsize&quot;&gt;table size pie-chart&lt;/a&gt; in the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil-implemented&lt;/a&gt; version control system for SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e77f3a2af88468cea075512b7c593d618135668" translate="yes" xml:space="preserve">
          <source>The DEFAULT clause specifies a default value to use for the column if no value is explicitly provided by the user when doing an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;. If there is no explicit DEFAULT clause attached to a column definition, then the default value of the column is NULL. An explicit DEFAULT clause may specify that the default value is NULL, a string constant, a blob constant, a signed-number, or any constant expression enclosed in parentheses. A default value may also be one of the special case-independent keywords CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP. For the purposes of the DEFAULT clause, an expression is considered constant if it contains no sub-queries, column or table references, &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;, or string literals enclosed in double-quotes instead of single-quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f30a44f7fde1290a9d66490fe4c7fc9d343db0a2" translate="yes" xml:space="preserve">
          <source>The DELETE command removes records from the table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549ed1cfefc84f8dde1745ba5b3bb051dd3b5008" translate="yes" xml:space="preserve">
          <source>The DELETE command without a WHILE clause just removes the database files from the disk, rather than going through and deleting record by record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c69d162dd597ca7eb6e965c55e71ba6c6554cc2" translate="yes" xml:space="preserve">
          <source>The DELETE journaling mode is the normal behavior. In the DELETE mode, the rollback journal is deleted at the conclusion of each transaction. Indeed, the delete operation is the action that causes the transaction to commit. (See the document titled &lt;a href=&quot;atomiccommit&quot;&gt; Atomic Commit In SQLite&lt;/a&gt; for additional detail.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da9a7936dc2b558a9310f00abb6a148be159cba" translate="yes" xml:space="preserve">
          <source>The DELETE trigger must be fired before the actual delete takes place on the content table. This is so that FTS4 can still retrieve the original values in order to update the full-text index. And the INSERT trigger must be fired after the new row is inserted, so as to handle the case where the rowid is assigned automatically within the system. The UPDATE trigger must be split into two parts, one fired before and one after the update of the content table, for the same reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab4459caaad95b429957125366d895b4021e494" translate="yes" xml:space="preserve">
          <source>The DELETE-mode locks are stored on the &lt;a href=&quot;fileformat2#lockbyte&quot;&gt;lock-byte page&lt;/a&gt; of the main database file. Only SQLITE_LOCK_SHARED and SQLITE_LOCK_EXCLUSIVE are factors for WAL-mode databases. The other locking states are used in rollback-mode, but not in WAL-mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577fca03e1d22d54957a27f6f46f602e956a7f46" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword in an aggregate query</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5960207cc3ff80c8b76aafd25f9f8b94d8c8f42b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword now will sometimes use an INDEX if an appropriate index is available and the optimizer thinks its use might be advantageous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7140e369fedc4714b9ea0083c995ff08e24d5b" translate="yes" xml:space="preserve">
          <source>The DISTINCT keyword on an aggregate query is implemented by creating a transient index in a temporary file and storing each result row in that index. As new result rows are computed a check is made to see if they already exist in the transient index and if they do the new result row is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8c0a43ed7404e0a2eaed887060f73b06109a61" translate="yes" xml:space="preserve">
          <source>The DROP INDEX statement removes an index added with the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement. The index is completely removed from the disk. The only way to recover the index is to reenter the appropriate &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf79716c365aa3a9096fb80997c218efa52bf726" translate="yes" xml:space="preserve">
          <source>The DROP TABLE statement removes a table added with the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The name specified is the table name. The dropped table is completely removed from the database schema and the disk file. The table can not be recovered. All indices and triggers associated with the table are also deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8134f9df85fa3c68e953f09b317e3c27f145a52e" translate="yes" xml:space="preserve">
          <source>The DROP TRIGGER statement removes a trigger created by the &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement. Once removed, the trigger definition is no longer present in the sqlite_master (or sqlite_temp_master) table and is not fired by any subsequent INSERT, UPDATE or DELETE statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4386299e0353e3df19809c98731f022556c566" translate="yes" xml:space="preserve">
          <source>The DROP VIEW statement removes a view created by the &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; statement. The view definition is removed from the database schema, but no actual data in the underlying base tables is modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bf67a5e4628332f9b58ee8c6d173a4c4f911e2" translate="yes" xml:space="preserve">
          <source>The Dbbe abstraction and the GDBM and memory drivers were removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ac6ee150153e29d6eb02ac712357b33cd11445" translate="yes" xml:space="preserve">
          <source>The Default Page Size Change of SQLite 3.12.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa7fe014de7884ad65be67fee11ca70cb61f51e" translate="yes" xml:space="preserve">
          <source>The EXCEPT operator for compound queries is implemented by creating a transient index in a temporary file, storing the results of the left subquery in this transient index, then removing the result from right subquery from the transient index, and finally walking the index from beginning to end to obtain the final output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae9f97f03202a131a787390ace280bc0296d78b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84773fe1424e26217a7a2df622779c7708ba171b" translate="yes" xml:space="preserve">
          <source>The EXISTS operator always evaluates to one of the integer values 0 and 1. If executing the SELECT statement specified as the right-hand operand of the EXISTS operator would return one or more rows, then the EXISTS operator evaluates to 1. If executing the SELECT would return no rows at all, then the EXISTS operator evaluates to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ef1c61206801602304d02bd0314e2e805ed955" translate="yes" xml:space="preserve">
          <source>The EXPLAIN QUERY PLAN command is described in &lt;a href=&quot;eqp&quot;&gt;more detail here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62b11f7e5c5d50c87cb37698a2dd96b4ced3ac8" translate="yes" xml:space="preserve">
          <source>The EXPLAIN and EXPLAIN QUERY PLAN prefixes affect the behavior of running a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. The process of generating a new prepared statement using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or similar is (mostly) unaffected by EXPLAIN. (The exception to the previous sentence is that some special opcodes used by EXPLAIN QUERY PLAN are omitted when building an EXPLAIN QUERY PLAN prepared statement, as a performance optimization.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3ee00b5769ef7f7d7fa11249f75b6c728fff5d2" translate="yes" xml:space="preserve">
          <source>The Error And Warning Log</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e00804aea114acdf8c7482e29e4b6fc1dd022a" translate="yes" xml:space="preserve">
          <source>The FAIL behavior only works for uniqueness, NOT NULL, and CHECK constraints. A &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation causes an ABORT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adadb0f9269151516b0ccaba4b14756b3c80bd9b" translate="yes" xml:space="preserve">
          <source>The FOR EACH STATEMENT clause on a trigger now causes a syntax error. It used to be silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd48fd724eca1ec736eda16ef97971212fd20e2" translate="yes" xml:space="preserve">
          <source>The FTS modules may be compiled to use one of two slightly different versions of the full-text query syntax, the &quot;standard&quot; query syntax and the &quot;enhanced&quot; query syntax. The basic term, term-prefix, phrase and NEAR queries described above are the same in both versions of the syntax. The way in which set operations are specified is slightly different. The following two sub-sections describe the part of the two query syntaxes that pertains to set operations. Refer to the description of how to &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;compile fts&lt;/a&gt; for compilation notes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82e31fa29aba07c9204f92b3f977e0bafebbf9f" translate="yes" xml:space="preserve">
          <source>The FTS query syntax (right hand side of the MATCH operator) has changed in some ways. The FTS5 syntax is quite close to the FTS4 &quot;enhanced syntax&quot;. The main difference is that FTS5 is fussier about unrecognized punctuation characters and similar within query strings. Most queries that work with FTS3/4 should also work with FTS5, and those that do not should return parse errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452e2c3759f6eb486841492aa116e202a1ab1f44" translate="yes" xml:space="preserve">
          <source>The FTS table column number to extract the returned fragments of text from. Columns are numbered from left to right starting with zero. A negative value indicates that the text may be extracted from any column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03bf1e933cfbb832357f37ab56f4975c4a387f7" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 extension modules allows users to create special tables with a built-in full-text index (hereafter &quot;FTS tables&quot;). The full-text index allows the user to efficiently query the database for all rows that contain one or more words (hereafter &quot;tokens&quot;), even if the table contains many large documents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4bac9786b108503576084f19784d9481dfe5de" translate="yes" xml:space="preserve">
          <source>The FTS3 and FTS4 modules provide three special SQL scalar functions that may be useful to the developers of full-text query systems: &quot;snippet&quot;, &quot;offsets&quot; and &quot;matchinfo&quot;. The purpose of the &quot;snippet&quot; and &quot;offsets&quot; functions is to allow the user to identify the location of queried terms in the returned documents. The &quot;matchinfo&quot; function provides the user with metrics that may be useful for filtering or sorting query results according to relevance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd165aec23f192a3f9f07347a0254f2d27b32b66" translate="yes" xml:space="preserve">
          <source>The FTS3 extension has undergone a major rework and cleanup. New &lt;a href=&quot;fts3&quot;&gt;FTS3 documentation&lt;/a&gt; is now available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cae97c9c8daf8017ea793bf4be64df945be883c" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;automerge=X&quot; command has been replaced by the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ba1806c7cd7bdfbbc2b404c832b1beab23a209" translate="yes" xml:space="preserve">
          <source>The FTS3/4 &quot;merge=X,Y&quot; command has been replaced by the &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c4e64578a5475fd4fbd32b9347a70fbc56baad" translate="yes" xml:space="preserve">
          <source>The FTS4 prefix option causes FTS to index term prefixes of specified lengths in the same way that it always indexes complete terms. The prefix option must be set to a comma separated list of positive non-zero integers. For each value N in the list, prefixes of length N bytes (when encoded using UTF-8) are indexed. FTS4 uses term prefix indexes to speed up &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt;. The cost, of course, is that indexing term prefixes as well as complete terms increases the database size and slows down write operations on the FTS4 table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3623dd8b5a2a6147fa4bef6afa8dea8c88c6337" translate="yes" xml:space="preserve">
          <source>The F_FULLSYNC ioctl (currently only supported on Mac OS X) is disabled if the synchronous pragma is set to something other than &quot;full&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8e5028bc3ed89b6a1dc3d8dc7eba9bd090d027" translate="yes" xml:space="preserve">
          <source>The Fossil NGQP Upgrade Case Study</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc92de118e5e87426474c7d89d8139659caa059" translate="yes" xml:space="preserve">
          <source>The Fossil performance problem described in the previous section of this document arose because there were over ten-thousand entries in the TAGXREF table with the same value for the left-most column (the TAGID column) of the TAGXREF_I1 index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cc3db361bc3155e6c06330a65fa4635f5425d3" translate="yes" xml:space="preserve">
          <source>The Fossil view clearly shows that the branch was eventually merged back into trunk. It shows where the branch started, and it shows two occasions where changes on trunk were merged into the branch. GitHub shows none of this. In fact, the GitHub display is mostly useless in trying to figure out what happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b63744d939cc984f1b96440853e8df6692826ba" translate="yes" xml:space="preserve">
          <source>The Fts5PhraseIter structure is defined above. Applications should not modify this structure directly - it should only be used as shown above with the xPhraseFirst() and xPhraseNext() API methods (and by xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5efd19f10743bd231ab41e35fd5ac44fc6fbe77" translate="yes" xml:space="preserve">
          <source>The GLOB operator is always case sensitive. The column on the left side of the GLOB operator must always use the built-in BINARY collating sequence or no attempt will be made to optimize that operator with indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebb21a9ebdf2dcd06a6d1e05cc13a1948a1a0378" translate="yes" xml:space="preserve">
          <source>The GLOB operator is similar to LIKE but uses the Unix file globbing syntax for its wildcards. Also, GLOB is case sensitive, unlike LIKE. Both GLOB and LIKE may be preceded by the NOT keyword to invert the sense of the test. The infix GLOB operator is implemented by calling the function &lt;a href=&quot;lang_corefunc#glob&quot;&gt;glob(&lt;i&gt;Y&lt;/i&gt;,&lt;i&gt;X&lt;/i&gt;)&lt;/a&gt; and can be modified by overriding that function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf488312da9736e109b0de15500f2677c1ccca1" translate="yes" xml:space="preserve">
          <source>The Geopoly Interface To The SQLite R*Tree Module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768b26bb16f751e006af08115829d3719bded2a3" translate="yes" xml:space="preserve">
          <source>The Geopoly module is an alternative interface to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; that uses the &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; notation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7946&quot;&gt;RFC-7946&lt;/a&gt;) to describe two-dimensional polygons. Geopoly includes functions for detecting when one polygon is contained within or overlaps with another, for computing the area enclosed by a polygon, for doing linear transformations of polygons, for rendering polygons as &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG&lt;/a&gt;, and other similar operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a237ed77d23b0a3e93b7e807216496727ce2d486" translate="yes" xml:space="preserve">
          <source>The Geopoly module only understands a small subset of GeoJSON, but a critical subset. In particular, GeoJSON understands the JSON array of vertexes that describes a simple polygon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3160b95c10c837d23b555d2d76ced7f5c9c397" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer implementation is very simple. It splits the input text according to the ICU rules for finding word boundaries and discards any tokens that consist entirely of white-space. This may be suitable for some applications in some locales, but not all. If more complex processing is required, for example to implement stemming or discard punctuation, this can be done by creating a tokenizer implementation that uses the ICU tokenizer as part of its implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ddce9bb57f20218d7a75f29be10f1ad340213b" translate="yes" xml:space="preserve">
          <source>The ICU tokenizer is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975a07114fdeda8b12153b2d0d474cd1f76f40a8" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae86038950b2d471648c3c6d1b5cdb4844f71708" translate="yes" xml:space="preserve">
          <source>The IN and NOT IN operators take an expression on the left and a list of values or a subquery on the right. When the right operand of an IN or NOT IN operator is a subquery, the subquery must have the same number of columns as there are columns in the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the left operand. The subquery on the right of an IN or NOT IN operator must be a scalar subquery if the left expression is not a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; expression. If the right operand of an IN or NOT IN operator is a list of values, each of those values must be scalars and the left expression must also be a scalar. The right-hand side of an IN or NOT IN operator can be a table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79accc7fc2bc30ac0fead525b227ad7d9b1df52" translate="yes" xml:space="preserve">
          <source>The IN operator is now a candidate for optimization even if the left-hand side is not the left-most term of the index. Multiple IN operators can be used with the same index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84955ffcf9bdb1365dbcf57de003852e491d0f74" translate="yes" xml:space="preserve">
          <source>The IN-early-out optimization: When doing a look-up on a multi-column index and an IN operator is used on a column other than the left-most column, then if no rows match against the first IN value, check to make sure there exist rows that match the columns to the right before continuing with the next IN value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f2969be40943bb47a40ea44d17f6c5eac58206" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on DELETE statements within triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74b8a2cb9b68ac44cbe1110518350bde980f1d2" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not allowed on UPDATE statements within triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f68ce27c8cff5cc2a071306e82e684ac57bb2a" translate="yes" xml:space="preserve">
          <source>The INDEXED BY and NOT INDEXED clauses are not supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c219f61fe4cd1e708d4fe79c89efa6776605815d" translate="yes" xml:space="preserve">
          <source>The INDEXED BY clause is &lt;em&gt;not&lt;/em&gt; intended for use in tuning the performance of a query. The intent of the INDEXED BY clause is to raise a run-time error if a schema change, such as dropping or creating an index, causes the query plan for a time-sensitive query to change. The INDEXED BY clause is designed to help detect undesirable query plan changes during regression testing. Application developers are admonished to omit all use of INDEXED BY during application design, implementation, testing, and tuning. If INDEXED BY is to be used at all, it should be inserted at the very end of the development process when &quot;locking down&quot; a design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4cc404750644d945353fc113cb9dba262e1c3b" translate="yes" xml:space="preserve">
          <source>The INDEXED BY phrase forces the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; to use a particular named index on a &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. The INDEXED BY phrase is an SQLite extension and is not portable to other SQL database engines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272773ebe8d5f9cc82e317b171f77d7379a1e581" translate="yes" xml:space="preserve">
          <source>The INSERT change remains in the changegroup. The values in the INSERT change are modified as if the row was inserted by the existing change and then updated according to the new change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="110ff0538d0b835d343c6aa7fc9be56d02650901" translate="yes" xml:space="preserve">
          <source>The INSERT statement above adds a new row to the sqlite_master table that defines a table &quot;t2&quot; having the same on-disk format as index &quot;t1bc&quot; and pointing to the same b-tree. After adding this sqlite_master table entry, it is necessary to close and reopen the database in order to get SQLite to reread the schema. Then the &quot;t2&quot; table can be queried to see the content of the &quot;t1bc&quot; index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d21ad99ed5f4abc02a63a43ee6d040107fe785" translate="yes" xml:space="preserve">
          <source>The INSERT statement comes in three basic forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c4a334a3fe174333881ca555ae014ebc13040d" translate="yes" xml:space="preserve">
          <source>The INTERSECT operator for compound queries is implemented by creating two separate transient indices, each in a separate temporary file. The left and right subqueries are evaluated each into a separate transient index. Then the two indices are walked together and entries that appear in both indices are output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b1f06632bef12995013965847655934cbf7975" translate="yes" xml:space="preserve">
          <source>The Idx1 index is scanned from top to bottom (or from bottom to top if &quot;ORDER BY fruit DESC&quot; is used) in order to find the rowids for each item in order by fruit. Then for each rowid, a binary search is done to lookup and output that row. In this way, the output appears in the requested order without the need to gather the entire output and sort it using a separate step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2840ff0c49d75f050e9ec79f4cca0962bc4cd995" translate="yes" xml:space="preserve">
          <source>The JSON1 Extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9880ae6264f9c31927d61592bb6cec20147ead44" translate="yes" xml:space="preserve">
          <source>The LIKE operator can be made case sensitive using the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d553aca858e8d5460148027e2f586810cb9b2c44" translate="yes" xml:space="preserve">
          <source>The LIKE operator does a pattern matching comparison. The operand to the right of the LIKE operator contains the pattern and the left hand operand contains the string to match against the pattern. A percent symbol (&quot;%&quot;) in the LIKE pattern matches any sequence of zero or more characters in the string. An underscore (&quot;_&quot;) in the LIKE pattern matches any single character in the string. Any other character matches itself or its lower/upper case equivalent (i.e. case-insensitive matching). &lt;u&gt;Important Note:&lt;/u&gt; SQLite only understands upper/lower case for ASCII characters by default. The LIKE operator is case sensitive by default for unicode characters that are beyond the ASCII range. For example, the expression &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is TRUE but &lt;b&gt;'&amp;aelig;' LIKE '&amp;AElig;'&lt;/b&gt; is FALSE. The ICU extension to SQLite includes an enhanced version of the LIKE operator that does case folding across all unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc39afda5c7dfd4c06c9ca219ccdec668d80d92" translate="yes" xml:space="preserve">
          <source>The LIKE operator has two modes that can be set by a &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;pragma&lt;/a&gt;. The default mode is for LIKE comparisons to be insensitive to differences of case for latin1 characters. Thus, by default, the following expression is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1212c823074bac84702844422e3c272b2bd97163" translate="yes" xml:space="preserve">
          <source>The LIKE operator is case insensitive by default because this is what the SQL standard requires. You can change the default behavior at compile time by using the &lt;a href=&quot;compile#case_sensitive_like&quot;&gt;SQLITE_CASE_SENSITIVE_LIKE&lt;/a&gt; command-line option to the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974b1e3eeffaa9ed2ed23dfb8ae4c0123aeb3aed" translate="yes" xml:space="preserve">
          <source>The LIKE optimization might occur if the column named on the left of the operator is indexed using the built-in BINARY collating sequence and case_sensitive_like is turned on. Or the optimization might occur if the column is indexed using the built-in NOCASE collating sequence and the case_sensitive_like mode is off. These are the only two combinations under which LIKE operators will be optimized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b8dceb670473d258369826a0e1bcdc46904ecc" translate="yes" xml:space="preserve">
          <source>The LIKE optimization was generating incorrect byte-code and hence getting the wrong answer if the left-hand operand has numeric affinity and the right-hand-side pattern is '/%' or if the pattern begins with the ESCAPE character. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c94369cae9b561b1f996d0054b&quot;&gt;c94369cae9b561b1f996d0054b&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c934a9b19a46fe0d3c49a41fee7d1fdd7083c0" translate="yes" xml:space="preserve">
          <source>The LIKE optimization will only be attempted if the right-hand side of the GLOB or LIKE operator is either literal string or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that has been &lt;a href=&quot;c3ref/bind_blob&quot;&gt;bound&lt;/a&gt; to a string literal. The string literal must not begin with a wildcard; if the right-hand side begins with a wildcard character then this optimization is attempted. If the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a string, then this optimization is only attempted if the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; containing the expression was compiled with &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;. The LIKE optimization is not attempted if the right-hand side is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement was prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdfb505c18eab193b8701d8963abc89096358bd" translate="yes" xml:space="preserve">
          <source>The LIKE, GLOB, REGEXP, and MATCH operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6f903f94d0893c11340df485d7ab2df47a60ff" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses (described below) are unsupported for DELETE statements within triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac40736f7c111bc231ce85d71233af9ca860229d" translate="yes" xml:space="preserve">
          <source>The LIMIT and ORDER BY clauses for UPDATE are unsupported within triggers, regardless of the compilation options used to build SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e074183b71823eb43ac076c4294086172e78dd9" translate="yes" xml:space="preserve">
          <source>The LIMIT clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0504a702a97dc6330d2a4e4c66843d71b8b8976c" translate="yes" xml:space="preserve">
          <source>The LIMIT clause is used to place an upper bound on the number of rows returned by the entire SELECT statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077d300ed4cc15ee3f95aa8d7373e80b1b912e57" translate="yes" xml:space="preserve">
          <source>The LIMIT clause now works on subselects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243d546893ed2d7dba744bb55553e651413994ea" translate="yes" xml:space="preserve">
          <source>The LIMIT clause, if present, determines the maximum number of rows that will ever be added to the recursive table in step 2b. Once the limit is reached, the recursion stops. A limit of zero means that no rows are ever added to the recursive table, and a negative limit means an unlimited number of rows may be added to the recursive table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff51df664023512f948df1ac796d229e7d0e9d2" translate="yes" xml:space="preserve">
          <source>The LOCKING_STYLE extension is now enabled by default on Mac OS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d323fe988c47fdc7cf51035f151e1d7348afa80" translate="yes" xml:space="preserve">
          <source>The Lemon LALR(1) Parser Generator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac145bc2534e8394ef262506cd070ba23b13005" translate="yes" xml:space="preserve">
          <source>The Lemon source code was originally written as separate source files, and only later merged into a single &quot;lemon.c&quot; source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3666de7d407bd838db280e08d40dcf3369cd962" translate="yes" xml:space="preserve">
          <source>The MATCH operator is a special syntax for the match() application-defined function. The default match() function implementation raises an exception and is not really useful for anything. But extensions can override the match() function with more helpful logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42afa4f5f59a4dbd2c306334064e90d9b1a32220" translate="yes" xml:space="preserve">
          <source>The MATCH operator of a custom R*Tree query function must be a top-level AND-connected term of the WHERE clause, or else it will not be usable by the R*Tree query optimizer and the query will not be runnable. If the MATCH operator is connected to other terms of the WHERE clause via an OR operator, for example, the query will fail with an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59083e3614cc05a48a3bbb667742c5ff714f7ae" translate="yes" xml:space="preserve">
          <source>The MEMORY journaling mode stores the rollback journal in volatile RAM. This saves disk I/O but at the expense of database safety and integrity. If the application using SQLite crashes in the middle of a transaction when the MEMORY journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f3e583df88fe87cd750b4e8f9145cc25dd009e" translate="yes" xml:space="preserve">
          <source>The Mythical Man-Month</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47382a1ade54ee985c5d1e4d884a10d978c3d9d5" translate="yes" xml:space="preserve">
          <source>The NGQP has no way of knowing that TAGXREF_I1 is almost useless in this query, unless &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run on the database. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command gathers statistics on the quality of the various indexes and stores those statistics in &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; table. Having access to this statistical information, the NGQP easily chooses algorithm-1 as the best algorithm, by a wide margin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143a4238d4916cb63313c4577ca26b997b836c83" translate="yes" xml:space="preserve">
          <source>The NGQP is almost always better than the legacy query planner. However, there may exist legacy applications that unknowingly depend on undefined and/or suboptimal behavior in the legacy query planner, and upgrading to the NGQP on those legacy applications could cause performance regressions. This risk is considered and a checklist is provided for reducing the risk and for fixing any issues that do arise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2965ed7439648bc6c724543a8009a196c9039cf3" translate="yes" xml:space="preserve">
          <source>The NGQP uses a new heuristic for seeking the best path through the graph: &quot;N Nearest Neighbors&quot; (hereafter &quot;N3&quot;). With N3, instead of choosing just one nearest neighbor for each step, the algorithm keeps track of the N bests paths at each step for some small integer N.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc9ac5c6c19fb4a0c339daee645a66512bd3730" translate="yes" xml:space="preserve">
          <source>The NGQP will always find a good query plan as long as the schema does not contain indexes that have more than about 10 or 20 rows with the same value in the left-most column of the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64782e52a0662885b1e4e8b616fd2a06e03a36a9" translate="yes" xml:space="preserve">
          <source>The NGQP will always find an equal or better query plan, compared to prior query planners, as long as it has access to accurate &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; data in the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;SQLITE_STAT1&lt;/a&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19150b2c84a3f9ff0a3cf33ed2fd4c984408dbd2" translate="yes" xml:space="preserve">
          <source>The NOCASE collation is like BINARY except that uppercase ASCII characters ('A' through 'Z') are folded into their lowercase equivalents prior to running the comparison. Only ASCII characters are case-folded. NOCASE does not implement a general purpose unicode caseless comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84b5eaf17b803151297f975dc355cb961ea61cd" translate="yes" xml:space="preserve">
          <source>The NOT operator (or, if using the standard syntax, a unary &quot;-&quot; operator) may be used to compute the &lt;b&gt;relative complement&lt;/b&gt; of one set of documents with respect to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0622850d3c0896e3d4a2cdc1368b8e7708693108" translate="yes" xml:space="preserve">
          <source>The NOT operator is not supported. Instead of the NOT operator, the standard query syntax supports a unary &quot;-&quot; operator that may be applied to basic term and term-prefix queries (but not to phrase or NEAR queries). A term or term-prefix that has a unary &quot;-&quot; operator attached to it may not appear as an operand to an OR operator. An FTS query may not consist entirely of terms or term-prefix queries with unary &quot;-&quot; operators attached to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a314ee0d4a8c6c880fc2de97d4d977bd035a9e6" translate="yes" xml:space="preserve">
          <source>The NULLS FIRST and NULLS LAST predicates are not supported for indexes. For &lt;a href=&quot;datatype3#sortorder&quot;&gt;sorting purposes&lt;/a&gt;, SQLite considers NULL values to be smaller than all other values. Hences NULL values always appear at the beginning of an ASC index and at the end of a DESC index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df615076dd2b352c1767b46fb626e9bea1df01d8" translate="yes" xml:space="preserve">
          <source>The Next instruction increments the cursor to point to the next element in the table pointed to by cursor P0, and if it was successful branches to P2 (6, the beginning of the loop body). The Close instruction closes cursor P1. It doesn't affect the temporary storage list because it isn't associated with cursor P1; it is instead a global working list (which can be saved with ListPush).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead51814a41f1aee68f72130d432c2d7adca2550" translate="yes" xml:space="preserve">
          <source>The Next-Generation Query Planner</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bb3fb56f491dbfd70c567055e36bba4fdf8c24" translate="yes" xml:space="preserve">
          <source>The ODP ZIP archive contains four different XML files: content.xml, styles.xml, meta.xml, and settings.xml. Those four files define the slide layout, text content, and styling. This particular presentation contains 62 images, ranging from full-screen pictures to tiny icons, each stored as a separate file in the Pictures folder. The &quot;mimetype&quot; file contains a single line of text that says:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2fb71eee9ad290a0e9bebe4f7b07ef57d97050" translate="yes" xml:space="preserve">
          <source>The OFF journaling mode disables the rollback journal completely. No rollback journal is ever created and hence there is never a rollback journal to delete. The OFF journaling mode disables the atomic commit and rollback capabilities of SQLite. The &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command no longer works; it behaves in an undefined way. Applications must avoid using the &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command when the journal mode is OFF. If the application crashes in the middle of a transaction when the OFF journaling mode is set, then the database file will very likely &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;go corrupt&lt;/a&gt;. Without a journal, there is no way for a statement to unwind partially completed operations following a constraint error. This might also leave the database in a corrupted state. For example, if a duplicate entry causes a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE UNIQUE INDEX&lt;/a&gt; statement to fail half-way through, it will leave behind a partially created, and hence corrupt, index. Because OFF journaling mode allows the database file to be corrupted using ordinary SQL, it is disabled when &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374ba8e6eebafb57002a1dcdb7b0375a9e1ef0e6" translate="yes" xml:space="preserve">
          <source>The OFFSET clause, if it is present and has a positive value N, prevents the first N rows from being added to the recursive table. The first N rows are still processed by the recursive-select &amp;mdash; they just are not added to the recursive table. Rows are not counted toward fulfilling the LIMIT until all OFFSET rows have been skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="549fba753f3ce9487855ba9f0e10547cd8338f25" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause applies to &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt;, &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt;, &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt;, and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints. The ON CONFLICT algorithm does not apply to &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY constraints&lt;/a&gt;. There are five conflict resolution algorithm choices: ROLLBACK, ABORT, FAIL, IGNORE, and REPLACE. The default conflict resolution algorithm is ABORT. This is what they mean:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdda41615452e17b3f0971a7f023b71ba464bbb" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause described here has been a part of SQLite since before version 3.0.0 (2004-06-18). The phrase &quot;ON CONFLICT&quot; is also part of &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;, which is an extension to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; added in version 3.24.0 (2018-06-04). Do not confuse these two separate uses of the &quot;ON CONFLICT&quot; phrase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdcbfd707214ce0a425024950f0078c8093a672f" translate="yes" xml:space="preserve">
          <source>The ON CONFLICT clause is a non-standard extension specific to SQLite that can appear in many other SQL commands. It is given its own section in this document because it is not part of standard SQL and therefore might not be familiar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b1442e3d6081cb327542a1dfef2a119f6cc8762" translate="yes" xml:space="preserve">
          <source>The ON DELETE and ON UPDATE action associated with each foreign key in an SQLite database is one of &quot;NO ACTION&quot;, &quot;RESTRICT&quot;, &quot;SET NULL&quot;, &quot;SET DEFAULT&quot; or &quot;CASCADE&quot;. If an action is not explicitly specified, it defaults to &quot;NO ACTION&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf1202b648eb0b4a5f050a8c6d05340c107e859" translate="yes" xml:space="preserve">
          <source>The ON and USING clauses of an inner join are converted into additional terms of the WHERE clause prior to WHERE clause analysis described above in paragraph 1.0. Thus with SQLite, there is no computational advantage to use the newer SQL92 join syntax over the older SQL89 comma-join syntax. They both end up accomplishing exactly the same thing on inner joins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4c3f3b3997cb8490367acdbc7718d009c8a562" translate="yes" xml:space="preserve">
          <source>The OR operator calculates the &lt;b&gt;union&lt;/b&gt; of two sets of documents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba92a05446009b56fe03f1afc3e8240d551a35c" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization is not valid unless the inner-most IN operator loop is actually used by the query plan. Fix for ticket &lt;a href=&quot;https://sqlite.org/src/info/0c4df46116e90f92&quot;&gt;0c4df46116e90f92&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8e2023ca7e681416d915e1d1b8f5b26d152e1f" translate="yes" xml:space="preserve">
          <source>The ORDER BY LIMIT optimization might have caused an infinite loop in the byte code of the prepared statement under very obscure circumstances, due to a confluence of minor defects in the query optimizer. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/9936b2fa443fec03ff25&quot;&gt;9936b2fa443fec03ff25&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b25ea5983496f08c601930c1bfec228ee9f65c25" translate="yes" xml:space="preserve">
          <source>The ORDER BY and LIMIT clauses on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements are not supported. ORDER BY and LIMIT are not normally supported for &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; in any context but can be enabled for top-level statements using the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option. However, that compile-time option only applies to top-level &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements, not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements within triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfee8a3cdd0f5ece05fc4719284d9ca35cb1ece" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30dc9fe3a4d009f8e23f54fc9886804eb6fd68d9" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on a DELETE statement is used only to determine which rows fall within the LIMIT. The order in which rows are deleted is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838347206eac0478c704f6fe626059a265388ac1" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause on an UPDATE statement is used only to determine which rows fall within the LIMIT. The order in which rows are modified is arbitrary and is not influenced by the ORDER BY clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db6946cde6c76ae16df632182494e97889b98107" translate="yes" xml:space="preserve">
          <source>The OS Interface - also called the &quot;VFS&quot; - is what makes SQLite portable across operating systems. Whenever any of the other modules in SQLite needs to communicate with the operating system, they invoke methods in the VFS. The VFS then invokes the operating-specific code needed to satisfy the request. Hence, porting SQLite to a new operating system is simply a matter of writing a new OS interface layer or &quot;VFS&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b9ed4bbd7c64412bf999ddb3735b90a9006325" translate="yes" xml:space="preserve">
          <source>The OS interface layer has been completely reworked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db34215d6389d29f797bd445ad557bb97d4d35b" translate="yes" xml:space="preserve">
          <source>The OVER clause is required for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt; and is prohibited otherwise. The DISTINCT keyword is only allowed in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;. The FILTER clause may not appear on a &lt;a href=&quot;lang_corefunc&quot;&gt;simple function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97086bd49779ce0aff6b3d28109cebe94640094e" translate="yes" xml:space="preserve">
          <source>The OpenDocument file format is used for office applications: word processors, spreadsheets, and presentations. It was originally designed for the OpenOffice suite but has since been incorporated into other desktop application suites. The OpenOffice application has been forked and renamed a few times. This author's primary use for OpenDocument is building slide presentations with either &lt;a href=&quot;https://www.neooffice.org/neojava/en/index.php&quot;&gt;NeoOffice&lt;/a&gt; on Mac, or &lt;a href=&quot;http://www.libreoffice.org/&quot;&gt;LibreOffice&lt;/a&gt; on Linux and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e13d51d1ef218d337ca9fb917ffdb16cbc244df" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. If P1 is not open then the behavior is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b81ca2502b2715c59c443936643d2e3be1132fa" translate="yes" xml:space="preserve">
          <source>The P1 cursor must be for a real table, not a pseudo-table. P1 must have been opened prior to this opcode or the program will segfault.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="607ac7f84bdc4d441c6cb285c55a825dad256470" translate="yes" xml:space="preserve">
          <source>The P1 parameter is not actually used by this opcode. However, it is sometimes set to 1 instead of 0 as a hint to the command-line shell that this &lt;a href=&quot;opcode#Goto&quot;&gt;Goto&lt;/a&gt; is the bottom of a loop and that the lines from P2 down to the current line should be indented for EXPLAIN output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dbb0803ca5b349efaf91bc329608b765d512d1" translate="yes" xml:space="preserve">
          <source>The P3 argument of instruction 11 is of particular interest. The sort key is formed by prepending one character from P3 to each string and concatenating all the strings. The sort comparison function will look at this character to determine whether the sort order is ascending or descending, and whether to sort as a string or number. In this example, the first column should be sorted as a string in descending order so its prefix is &quot;D&quot; and the second column should sorted numerically in ascending order so its prefix is &quot;+&quot;. Ascending string sorting uses &quot;A&quot;, and descending numeric sorting uses &quot;-&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ff312bc89d3e83256edc55b23ecd77e64741ac" translate="yes" xml:space="preserve">
          <source>The P3 value is a hint to the btree implementation. If P3==1, that means P1 is an SQL index and that this instruction could have been omitted if that index had been unique. P3 is usually 0. P3 is always either 0 or 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0f52e542da01be92f32d06abf2506b4a2d4f31b" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY or ROWID. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID on the P1 index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2c023857d26616de9f3d4b0976bd5072c920ee" translate="yes" xml:space="preserve">
          <source>The P4 register values beginning with P3 form an unpacked index key that omits the PRIMARY KEY. &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; this key value against the index that P1 is currently pointing to, ignoring the PRIMARY KEY or ROWID fields at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d27257909a32ae5401b59e606c768db9ed4065" translate="yes" xml:space="preserve">
          <source>The P4 value may be either an integer (P4_INT32) or a pointer to a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo object, then table being opened must be an &lt;a href=&quot;fileformat2#btypes&quot;&gt;index b-tree&lt;/a&gt; where the KeyInfo object defines the content and collating sequence of that index b-tree. Otherwise, if P4 is an integer value, then the table being opened must be a &lt;a href=&quot;fileformat2#btypes&quot;&gt;table b-tree&lt;/a&gt; with a number of columns no less than the value of P4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21923e08794e63280a41a6b5f859992f400d98cc" translate="yes" xml:space="preserve">
          <source>The P5 arguments are taken from register P2 and its successors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6017964a6129b7a7e8f6a3da3f0784c73d2078ba" translate="yes" xml:space="preserve">
          <source>The P5 parameter can be a mask of the BTREE_* flags defined in btree.h. These flags control aspects of the operation of the btree. The BTREE_OMIT_JOURNAL and BTREE_SINGLE flags are added automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1c0ff5695ef10ade1f6c3734423a4eb3077d3e" translate="yes" xml:space="preserve">
          <source>The PERSIST journaling mode prevents the rollback journal from being deleted at the end of each transaction. Instead, the header of the journal is overwritten with zeros. This will prevent other database connections from rolling the journal back. The PERSIST journaling mode is useful as an optimization on platforms where deleting or truncating a file is much more expensive than overwriting the first block of a file with zeros. See also: &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;PRAGMA journal_size_limit&lt;/a&gt; and &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161bece08ac2f5702ce5212ddbeeb1a41f2dbaee" translate="yes" xml:space="preserve">
          <source>The PLINK table holds parent-child relationships between check-ins. The TAGXREF table maps tags into check-ins. For reference, the relevant portions of the schemas for these two tables is shown here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4bd8ba431ab4e0d31722f8db284b8bb979b0c36" translate="yes" xml:space="preserve">
          <source>The PRAGMA statement is an SQL extension specific to SQLite and used to modify the operation of the SQLite library or to query the SQLite library for internal (non-table) data. The PRAGMA statement is issued using the same interface as other SQLite commands (e.g. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;) but is different in the following important respects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c66b0cfca97f029db26ea6f18637a49f7fab6a97" translate="yes" xml:space="preserve">
          <source>The PRAGMA synchronous=off statement now disables syncing of the master journal file in addition to the normal rollback journals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37fa685a4763fe504598bdda8b4b2f3d3eef491" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY constraint for a rowid table (as long as it is not the true primary key or INTEGER PRIMARY KEY) is really the same thing as a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt;. Because it is not a true primary key, columns of the PRIMARY KEY are allowed to be NULL, in violation of all SQL standards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe8c7b0a4b69dc3800a6f41776c565d6842c281" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY values identifying the modified row,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90caad2286223b2e029c8d716238518e674a76d1" translate="yes" xml:space="preserve">
          <source>The Page Cache</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f5eb567adef7decaf2acc8e4aa86ec1481f2a20" translate="yes" xml:space="preserve">
          <source>The PostgreSQL and MySQL servers used were as delivered by default on RedHat 7.2. (PostgreSQL version 7.1.3 and MySQL version 3.23.41.) No effort was made to tune these engines. Note in particular the default MySQL configuration on RedHat 7.2 does not support transactions. Not having to support transactions gives MySQL a big speed advantage, but SQLite is still able to hold its own on most tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d04a38a1d2743c1862a6cfdba60ded14ba2896a" translate="yes" xml:space="preserve">
          <source>The PutIntKey instruction (also described during the discussion about INSERT) writes an entry into the database file whose data is the top of the stack and whose key is the next on the stack, and then pops the stack twice. The PutIntKey instruction will overwrite the data of an existing record with the same key, which is what we want here. Overwriting was not an issue with INSERT because with INSERT the key was generated by the NewRecno instruction which is guaranteed to provide a key that has not been used before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7408173a3218822a3bb6af7f7e3d86be256cefca" translate="yes" xml:space="preserve">
          <source>The QPSG is disabled by default. It can be enabled at compile-time using the &lt;a href=&quot;compile#enable_qpsg&quot;&gt;SQLITE_ENABLE_QPSG&lt;/a&gt; compile-time option, or at run-time by invoking &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt;,1,0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff5d03d1a40249005abd9682f890ac5af94c96e" translate="yes" xml:space="preserve">
          <source>The QPSG means that if all of your queries run efficiently during testing, and if your application does not change the schema, then SQLite will not suddenly decide to start using a different query plan, possibly causing a performance problem, after your application is released to users. If your application works in the lab, it will continue working the same way after deployment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c6137b874e291f7e936bf89d2438f289c1e9a2" translate="yes" xml:space="preserve">
          <source>The R-Tree concept originated with &lt;a href=&quot;http://www.baymoon.com/~tg2/&quot;&gt;Toni Guttman&lt;/a&gt;: &lt;em&gt;R-Trees: A Dynamic Index Structure for Spatial Searching&lt;/em&gt;, Proc. 1984 ACM SIGMOD International Conference on Management of Data, pp. 47-57. The implementation found in SQLite is a refinement of Guttman's original idea, commonly called &quot;R*Trees&quot;, that was described by Norbert Beckmann, Hans-Peter Kriegel, Ralf Schneider, Bernhard Seeger: &lt;em&gt;The R*-Tree: An Efficient and Robust Access Method for Points and Rectangles.&lt;/em&gt; SIGMOD Conference 1990: 322-331.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3074807f0a652cf6707800a925f23953d72a9a" translate="yes" xml:space="preserve">
          <source>The RAISE() function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69d2de0461d9e5577928a8a0c182e55c377b7ea" translate="yes" xml:space="preserve">
          <source>The RBU Extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f271a1dcb4b99763d2ff19003d2b360191882c40" translate="yes" xml:space="preserve">
          <source>The RBU database table contains a single row for each target database row inserted, updated or deleted by the update. Populating the RBU database tables is described in &lt;a href=&quot;rbu#database_contents&quot;&gt;the following section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9dd90a4d99e081d94181c982214ebaab88f1ab" translate="yes" xml:space="preserve">
          <source>The RBU extension interface allows an application to apply an RBU update stored in an RBU database to an existing target database. The procedure is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0cbd808e0878559e4326851133fccc2e2e33dd" translate="yes" xml:space="preserve">
          <source>The RBU extension is an add-on for SQLite designed for use with large SQLite database files on low-power devices at the edge of a network. RBU may be used for two separate tasks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc51cf7dfcbe19fae28d177efed486cafebfaa37" translate="yes" xml:space="preserve">
          <source>The RBU extension is not enabled by default. To enable it, compile the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; with the &lt;a href=&quot;compile#enable_rbu&quot;&gt;SQLITE_ENABLE_RBU&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d487cd05415f0ab5a85f8a6d6877a414f0dad6c" translate="yes" xml:space="preserve">
          <source>The RBU update will not detect or prevent foreign key or CHECK constraint violations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593961271c55fed248c83e9d463fa6fd9e121437" translate="yes" xml:space="preserve">
          <source>The RBU update will not fire any triggers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e251943a38b26d445d7abf3f883e482037ceab" translate="yes" xml:space="preserve">
          <source>The REGEXP operator is a special syntax for the regexp() user function. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If an &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL function&lt;/a&gt; named &quot;regexp&quot; is added at run-time, then the &quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a60389a484988aa39c6d8ad03d71480c4d40ec6" translate="yes" xml:space="preserve">
          <source>The REINDEX command is used to delete and recreate indices from scratch. This is useful when the definition of a collation sequence has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26337c24aa4b0f0ab8be7c9f3c788f1a63917d77" translate="yes" xml:space="preserve">
          <source>The REINDEX command was added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25bdb1a8b2079e760c4eabb862683c2777d36a53" translate="yes" xml:space="preserve">
          <source>The RELEASE command is like a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; for a SAVEPOINT. The RELEASE command causes all savepoints back to and including the most recent savepoint with a matching name to be removed from the transaction stack. The RELEASE of an inner transaction does not cause any changes to be written to the database file; it merely removes savepoints from the transaction stack such that it is no longer possible to ROLLBACK TO those savepoints. If a RELEASE command releases the outermost savepoint, so that the transaction stack becomes empty, then RELEASE is the same as &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; command may be used to release all savepoints and commit the transaction even if the transaction was originally started by a SAVEPOINT command instead of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ca08634243012d2e2bc4d0598e7fea902f6787a" translate="yes" xml:space="preserve">
          <source>The RELEASE command starts with the most recent addition to the transaction stack and releases savepoints backwards in time until it releases a savepoint with a matching savepoint-name. Prior savepoints, even savepoints with matching savepoint-names, are unchanged. If the RELEASE command causes the transaction stack to become empty (if the RELEASE command releases the outermost transaction from the stack) then the transaction commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00402a1bc7f00a30656be0c0b84db4535fdee37b" translate="yes" xml:space="preserve">
          <source>The RENAME COLUMN TO syntax changes the column-name of table table-name into new-column-name. The column name is changed both within the table definition itself and also within all indexes, triggers, and views that reference the column. If the column name change would result in a semantic ambiguity in a trigger or view, then the RENAME COLUMN fails with an error and no changes are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd18ba9ff83bdc2461dca0a5dcb6bdcec775c80" translate="yes" xml:space="preserve">
          <source>The RENAME TO syntax changes the name of table-name to new-table-name. This command cannot be used to move a table between attached databases, only to rename a table within the same database. If the table being renamed has triggers or indices, then these remain attached to the table after it has been renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802816683a1617052efa11363c7e7856de219468" translate="yes" xml:space="preserve">
          <source>The REPLACE command is an alias for the &quot;&lt;a href=&quot;lang_conflict&quot;&gt;INSERT OR REPLACE&lt;/a&gt;&quot; variant of the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command. This alias is provided for compatibility other SQL database engines. See the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; command documentation for additional information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f900ded58f3c3fd3840ddc24eb90dbbf605e279b" translate="yes" xml:space="preserve">
          <source>The ROLLBACK TO command reverts the state of the database back to what it was just after the corresponding SAVEPOINT. Note that unlike that plain &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; command (without the TO keyword) the ROLLBACK TO command does not cancel the transaction. Instead of cancelling the transaction, the ROLLBACK TO command restarts the transaction again at the beginning. All intervening SAVEPOINTs are canceled, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd447cb0f90571617cf670fb9ebcb0a187d10c25" translate="yes" xml:space="preserve">
          <source>The ROLLBACK command with a TO clause rolls back transactions going backwards in time back to the most recent SAVEPOINT with a matching name. The SAVEPOINT with the matching name remains on the transaction stack, but all database changes that occurred after that SAVEPOINT was created are rolled back. If the savepoint-name in a ROLLBACK TO command does not match any SAVEPOINT on the stack, then the ROLLBACK command fails with an error and leaves the state of the database unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a43e8d492ce5e858bd1d1f31b22f0ef1c5e90c" translate="yes" xml:space="preserve">
          <source>The ROWS and GROUPS frame types are similar in that they both determine the extent of a frame by counting relative to the current row. The difference is that ROWS counts individual rows and GROUPS counts peer groups. The RANGE frame type is different. The RANGE frame type determines the extent of a frame by looking for expression values that are within some band of values relative to the current row.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd583a191932218eb3314e3e838d31fd080381b" translate="yes" xml:space="preserve">
          <source>The Robson proof applies separately to each of the memory allocators used by SQLite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd8832f03de287c31f207b9169a825dcdfbcb2a" translate="yes" xml:space="preserve">
          <source>The RowSet object is optimized for the case where sets of integers are inserted in distinct phases, which each set contains no duplicates. Each set is identified by a unique P4 value. The first set must have P4==0, the final set must have P4==-1, and for all other sets must have P4&amp;gt;0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b35696d5bc7e8c253762e4c23df59d339d7859" translate="yes" xml:space="preserve">
          <source>The SAVEPOINT command starts a new transaction with a name. The transaction names need not be unique. A SAVEPOINT can be started either within or outside of a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. When a SAVEPOINT is the outer-most savepoint and it is not within a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then the behavior is the same as BEGIN DEFERRED TRANSACTION.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce13fbd458ee477db75220e11cabd929def8f2a4" translate="yes" xml:space="preserve">
          <source>The SCHEMA column is NULL, except for cases when the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface is used to interrogate the ZIPVFS backend. As this only happens when the memstat.c module is compiled with -DSQLITE_ENABLE_ZIPVFS and when &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; is in use, SCHEMA is usually NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6115bd106a2add942203424bfde4ef5e373053a" translate="yes" xml:space="preserve">
          <source>The SELECT begins in a familiar fashion. First the column names are initialized and the table being queried is opened. Things become different beginning with instructions 5 and 6 where the index file is also opened. Instructions 7 and 8 make a key with the value of 50. The &lt;a href=&quot;opcode#MemStore&quot;&gt;MemStore&lt;/a&gt; instruction at 9 stores the index key in VDBE memory location 0. The VDBE memory is used to avoid having to fetch a value from deep in the stack, which can be done, but makes the program harder to generate. The following instruction &lt;a href=&quot;opcode#MoveTo&quot;&gt;MoveTo&lt;/a&gt; at address 10 pops the key off the stack and moves the index cursor to the first row of the index with that key. This initializes the cursor for use in the following loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a0eced3e1981106cb4ea9f622f50ad79cd9e5a4" translate="yes" xml:space="preserve">
          <source>The SELECT statement is the most complicated command in the SQL language. To make the description easier to follow, some of the passages below describe the way the data returned by a SELECT statement is determined as a series of steps. It is important to keep in mind that this is purely illustrative - in practice neither SQLite nor any other SQL engine is required to follow this or any other specific process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb8c3356a31e99d0c2a4414b1c0627a922137ba" translate="yes" xml:space="preserve">
          <source>The SELECT statement is used to query the database. The result of a SELECT is zero or more rows of data where each row has a fixed number of columns. A SELECT statement does not make any changes to the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f43e1f8274aa8dc54f915ee9dedc6e51d7565a" translate="yes" xml:space="preserve">
          <source>The SELECT statement on the left returns a single row since '0' and '0.0' are treated as numbers and are therefore indistinct. But the SELECT statement on the right returns two rows since 0 and 0.0 are treated a strings which are different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e902534831ef4c318239e243a80c6ae4bb31b6d1" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;BEGIN TRANSACTION&quot; (the TRANSACTION keyword is optional) is used to take SQLite out of autocommit mode. Note that the BEGIN command does not acquire any locks on the database. After a BEGIN command, a SHARED lock will be acquired when the first SELECT statement is executed. A RESERVED lock will be acquired when the first INSERT, UPDATE, or DELETE statement is executed. No EXCLUSIVE lock is acquired until either the memory cache fills up and must be spilled to disk or until the transaction commits. In this way, the system delays blocking read access to the file file until the last possible moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af8ff773b8faa66109f99e9e85b3a719b5cf7712" translate="yes" xml:space="preserve">
          <source>The SQL command &quot;COMMIT&quot; does not actually commit the changes to disk. It just turns autocommit back on. Then, at the conclusion of the command, the regular autocommit logic takes over and causes the actual commit to disk to occur. The SQL command &quot;ROLLBACK&quot; also operates by turning autocommit back on, but it also sets a flag that tells the autocommit logic to rollback rather than commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82504fd949554ebcdca052a7976082cbbc273023" translate="yes" xml:space="preserve">
          <source>The SQL fuzz generator tests are part of the TCL test suite. During a full test run, about 111.3 thousand fuzz SQL statements are generated and tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3044d65e21f066cf67f7a5007e05a25a7bcd19f9" translate="yes" xml:space="preserve">
          <source>The SQL language features several contexts where an expression is evaluated and the result converted to a boolean (true or false) value. These contexts are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4f854d9a377d64ee6ebf1ef026f57adf3093a6" translate="yes" xml:space="preserve">
          <source>The SQL language is a &quot;standard&quot;. Even so, no two SQL database engines work exactly alike. Every SQL implementation has it own peculiarities and oddities, and SQLite is no exception to this rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10de2fe05ef5e79065921e1cfe79576a9514e5b1" translate="yes" xml:space="preserve">
          <source>The SQL language is rich in keywords. Most SQL implementations do not allow keywords to be used as identifiers (the names of table or columns) unless they are enclosed in double-quotes. But SQLite is more flexible. Many keywords can be used as identifiers without needing to be quoted, as long as those keywords are used in a context where it is clear that they are intended to be an identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6afa95ef6a6482806d3030ee240e85ae2e39791" translate="yes" xml:space="preserve">
          <source>The SQL language is very powerful, and so it is always possible for malicious SQL inputs (or erroneous SQL inputs caused by an application bug) to submit SQL that runs for a very long time. To prevent this from becoming a denial-of-service attack, consider using the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface to invoke a callback periodically as each SQL statement runs, and have that callback return non-zero to abort the statement if the statement runs for too long. Alternatively, set a timer in a separate thread and invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; when the timer goes off to prevent the SQL statement from running forever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48efb4a27989fcb1221b7de6665fb9fdbe5be779" translate="yes" xml:space="preserve">
          <source>The SQL language parser for SQLite is generated using a code-generator program called &quot;Lemon&quot;. The Lemon program reads a grammar of the input language and emits C-code to implement a parser for that language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3001af76a5af3b3d6822f17dc4d8570b011ad5be" translate="yes" xml:space="preserve">
          <source>The SQL output resulting from &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; is now modified to include the values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677e1e6ba30ceb96b1361fef9b1a12b6f65a8d13" translate="yes" xml:space="preserve">
          <source>The SQL query in the example above uses less CPU than the first example in this section, but still has a non-obvious performance problem. SQLite satisfies this query by retrieving the value of the &quot;title&quot; column and matchinfo data from the FTS module for every row matched by the users query before it sorts and limits the results. Because of the way SQLite's virtual table interface works, retrieving the value of the &quot;title&quot; column requires loading the entire row from disk (including the &quot;content&quot; field, which may be quite large). This means that if the users query matches several thousand documents, many megabytes of &quot;title&quot; and &quot;content&quot; data may be loaded from disk into memory even though they will never be used for any purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44349eaec4c0440f46685e284dc3b9bdf9db6763" translate="yes" xml:space="preserve">
          <source>The SQL query in the following example block is one solution to this problem. In SQLite, when a &lt;a href=&quot;optoverview#flattening&quot;&gt;sub-query used in a join contains a LIMIT clause&lt;/a&gt;, the results of the sub-query are calculated and stored in temporary table before the main query is executed. This means that SQLite will load only the docid and matchinfo data for each row matching the users query into memory, determine the docid values corresponding to the ten most relevant documents, then load only the title and content information for those 10 documents only. Because both the matchinfo and docid values are gleaned entirely from the full-text index, this results in dramatically less data being loaded from the database into memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5256c5c7d2eb97fecf26da60392ff96d1a9f664" translate="yes" xml:space="preserve">
          <source>The SQL standard requires double-quotes around identifiers and single-quotes around string literals. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7a261f0a3880c45baf726e85dad9e7315752c4" translate="yes" xml:space="preserve">
          <source>The SQL standard requires that a UNIQUE constraint be enforced even if one or more of the columns in the constraint are NULL, but SQLite does not do this. Isn't that a bug?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a04eb23eef56ed5f467e10f54232c8a27c42d7f" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies a large number of keywords which may not be used as the names of tables, indices, columns, databases, user-defined functions, collations, virtual table modules, or any other named object. The list of keywords is so long that few people can remember them all. For most SQL code, your safest bet is to never use any English language word as the name of a user-defined object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8004c4c668fddca439c94d74dc1d6f7c7684dbe" translate="yes" xml:space="preserve">
          <source>The SQL standard specifies that single-quotes in strings are escaped by putting two single quotes in a row. SQL works like the Pascal programming language in this regard. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59242cd06ef98d5456a2038bc8b7aff22753485f" translate="yes" xml:space="preserve">
          <source>The SQL statement is a UTF-8 string for sqlite3_prepare(). The sqlite3_prepare16() works the same way except that it expects a UTF-16 string as SQL input. Only the first SQL statement in the input string is compiled. The fifth parameter is filled in with a pointer to the next (uncompiled) SQLite statement in the input string, if any. The sqlite3_finalize() routine deallocates a prepared SQL statement. All prepared statements must be finalized before the database can be closed. The sqlite3_reset() routine resets a prepared SQL statement so that it can be executed again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05506ce34afb730ccba4a9b42a033056b9bc26b4" translate="yes" xml:space="preserve">
          <source>The SQL statement may contain tokens of the form &quot;?&quot; or &quot;?nnn&quot; or &quot;:aaa&quot; where &quot;nnn&quot; is an integer and &quot;aaa&quot; is an identifier. Such tokens represent unspecified literal values (or &quot;wildcards&quot;) to be filled in later by the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; interface. Each wildcard has an associated number which is its sequence in the statement or the &quot;nnn&quot; in the case of a &quot;?nnn&quot; form. It is allowed for the same wildcard to occur more than once in the same SQL statement, in which case all instance of that wildcard will be filled in with the same value. Unbound wildcards have a value of NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449ffcbd2d390b1586ef94ae6aaf64cdfbb6cfbd" translate="yes" xml:space="preserve">
          <source>The SQL statement supplied as the argument to the CREATE VIRTUAL TABLE statement is executed when the table is created. It must return either four or five columns. Each row returned describes one of the component tables. The first four columns are interpreted, from first to last, as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd374f0003c79e47aa8712ac4ea58e570b4758d5" translate="yes" xml:space="preserve">
          <source>The SQL statements used to implement SQLite Archive operations make use of various &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;. These extensions are all available in the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;SQLite source tree&lt;/a&gt; in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc&quot;&gt;ext/misc/ subfolder&lt;/a&gt;. The extensions needed for full SQLite Archive support include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6ae8d6fb78d715b5f8b26d43534dafb12ea942" translate="yes" xml:space="preserve">
          <source>The SQL syntax for custom queries is the same regardless of which interface, sqlite3_rtree_geometry_callback() or sqlite3_rtree_query_callback(), is used to register the SQL function. However, the newer query-style callbacks give the application greater control over how the query proceeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9308701d68c8225498cd757f7331dde6f73adc8" translate="yes" xml:space="preserve">
          <source>The SQL:1999 spec requires that the RECURSIVE keyword follow WITH in any WITH clause that includes a recursive common table expression. However, for compatibility with SqlServer and Oracle, SQLite does not enforce this rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ddf5e6785ea3822394b6d6a54fb42d4acd1778" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT result code indicates that an operation was aborted prior to completion, usually be application request. See also: &lt;a href=&quot;rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1613fab985744b29bc64a3b7d315d71db7102a20" translate="yes" xml:space="preserve">
          <source>The SQLITE_ABORT_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; indicating that an SQL statement aborted because the transaction that was active when the SQL statement first started was rolled back. Pending write operations always fail with this error when a rollback occurs. A &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; will cause a pending read operation to fail only if the schema was changed within the transaction being rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9776b801900694be8692d527b6b6a5014611c72c" translate="yes" xml:space="preserve">
          <source>The SQLITE_AFF_MASK portion of P5 must be an affinity character - SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made to coerce both inputs according to this affinity before the comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric affinity is used. Note that the affinity conversions are stored back into the input registers P1 and P3. So this opcode can cause persistent changes to registers P1 and P3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa8cf2714776524ecdde2f427b30f632065e986" translate="yes" xml:space="preserve">
          <source>The SQLITE_AUTH error is returned when the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer callback&lt;/a&gt; indicates that an SQL statement being prepared is not authorized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a716819bd21e33b0b83c8f1def818df42717b54a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code differs from &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; in that SQLITE_BUSY indicates a conflict with a separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, probably in a separate process, whereas &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicates a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or sometimes a database connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6847ec78063b3fe6af5cc42bad60bb51ac404849" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY result code indicates that the database file could not be written (or in some cases read) because of concurrent activity by some other &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, usually a database connection in a separate process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfe6b580ae13113f460c28fc71a7b4dbcf6c75a" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that indicates that an operation could not continue because another process is busy recovering a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file following a crash. The SQLITE_BUSY_RECOVERY error code only occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5599d49b00bbca3062bad1e4d863f9643aada6" translate="yes" xml:space="preserve">
          <source>The SQLITE_BUSY_SNAPSHOT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; that occurs on &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases when a database connection tries to promote a read transaction into a write transaction but finds that another &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has already written to the database and thus invalidated prior reads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ff4a95f8927914c1763adf9045af4ab62d2f754" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN result code indicates that SQLite was unable to open a file. The file in question might be a primary database file or one of several &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500408920c5afff76382c31e4489f9ce53192205" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed while trying to open a file. See also: &lt;a href=&quot;rescode#ioerr_convpath&quot;&gt;SQLITE_IOERR_CONVPATH&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55203070958c2991ba87f3b32bd40d536d90189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_DIRTYWAL result code is not used at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b8dd7bacea04f63a2cb5fbae43d894d6332998" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_FULLPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the operating system was unable to convert the filename into a full pathname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b7e5d009e56aefb1e5fa74fb773f95be397ef4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_ISDIR error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; indicating that a file open operation failed because the file is really a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff11cefb3f88aae4a84bf8291076f3bac03ede6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CANTOPEN_NOTEMPDIR error code is no longer used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f769e27f147dfdd680f8a17a2bfe539caf9796" translate="yes" xml:space="preserve">
          <source>The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the exclusive &quot;writer&quot; lock on the database file. If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained. The busy-handler is also invoked while waiting for database readers as described above. If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible without blocking any further. SQLITE_BUSY is returned in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f7466fb166d62399d9f0072e0370315299af5b1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;../compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7ecdbc601a4823c2b08a2a5337606f8d30aa46" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer argument which is interpreted as a boolean in order to enable or disable the use of covering indices for full table scans in the query optimizer. The default setting is determined by the &lt;a href=&quot;compile#allow_covering_index_scan&quot;&gt;SQLITE_ALLOW_COVERING_INDEX_SCAN&lt;/a&gt; compile-time option, or is &quot;on&quot; if that compile-time option is omitted. The ability to disable the use of covering indices for full table scans is because some incorrectly coded legacy applications might malfunction when the optimization is enabled. Providing the ability to disable the optimization allows the older, buggy application code to work without change even with newer versions of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff83d1ba90843c7f9c3dc720386b86f9f35e0379" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c7cd5a1eddca0fbdae5b53b4edcfcd1711ca82" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure is filled with the currently defined memory allocation routines. This option can be used to overload the default memory allocation routines with a wrapper that simulations memory allocation failure or tracks memory usage, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1078933a2f48f4ba63fb92d6b093d628661727" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4910d5633ae70fa15de2ae4b340873caa0f78feb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETMUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure is filled with the currently defined mutex routines. This option can be used to overload the default mutex allocation routines with a wrapper used to track mutex usage for performance profiling or testing, for example. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_GETMUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480ac6642108db12dacb128d029ff61248587e74" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15656e2a537c4d062ffc1a4a28c224d21946fb5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. SQLite copies of the current page cache implementation into that object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bf906d256dc3dcf8d1b8d18fc31630de1f686b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fe54eb9feb326e6993f5e80b5d7f631fea68373" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_HEAP option specifies a static memory buffer that SQLite will use for all of its dynamic memory allocation needs beyond those provided for by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled with either &lt;a href=&quot;../compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; or &lt;a href=&quot;../compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; and returns &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if invoked otherwise. There are three arguments to SQLITE_CONFIG_HEAP: An 8-byte aligned pointer to the memory, the number of bytes in the memory buffer, and the minimum allocation size. If the first pointer (the memory pointer) is NULL, then SQLite reverts to using its default memory allocator (the system malloc() implementation), undoing any prior invocation of &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;. If the memory pointer is not NULL then the alternative memory allocator is engaged to handle all of SQLites memory allocation needs. The first pointer (the memory pointer) must be aligned to an 8-byte boundary or subsequent behavior of SQLite will be undefined. The minimum allocation size is capped at 2**12. Reasonable values for the minimum allocation size are 2**5 through 2**8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d248a0a82b03a7f001692e75d24ae19d015766" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;../errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e287bb60474979eb8cefde91438388d0375975" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOG option is used to configure the SQLite global &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;. (The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a function with a call signature of void(*)(void*,int,const char*), and a pointer to void. If the function pointer is not NULL, it is invoked by &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; to process each logging event. If the function pointer is NULL, the &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; interface becomes a no-op. The void pointer that is the second argument to SQLITE_CONFIG_LOG is passed through as the first parameter to the application-defined logger function whenever that function is invoked. The second parameter to the logger function is a copy of the first parameter to the corresponding &lt;a href=&quot;#sqlite3_log&quot;&gt;sqlite3_log()&lt;/a&gt; call and is intended to be a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt;. The third parameter passed to the logger is log message after formatting via &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt;. The SQLite logging interface is not reentrant; the logger function supplied by the application must not invoke any SQLite interface. In a multi-threaded application, the application-defined logger function must be threadsafe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0156b86adc81defa456094d6dda8a22884243b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517e0ab9da5cb1067d00b2d40dff6d21a15492c5" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine the default size of lookaside memory on each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the size of each lookaside buffer slot and the second is the number of slots allocated to each database connection. SQLITE_CONFIG_LOOKASIDE sets the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5ea304960d2945164c69cf799e956ea26314e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212fa0cc6b6461ceacd5f53dcf7fed283b480c6d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MALLOC option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure. The argument specifies alternative low-level memory allocation routines to be used in place of the memory allocation routines built into SQLite. SQLite makes its own private copy of the content of the &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; structure before the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f6142b40b1216838367535e150c109342d48bb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;#sqlite3_int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e7b78f6947d183a3f90000da914d03e1bc727e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMDB_MAXSIZE option accepts a single parameter &lt;a href=&quot;int64&quot;&gt;sqlite3_int64&lt;/a&gt; parameter which is the default maximum size for an in-memory database created using &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This default maximum size can be adjusted up or down for individual databases using the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file-control&lt;/a&gt;. If this configuration setting is never used, then the default maximum is determined by the &lt;a href=&quot;../compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt; compile-time option. If that compile-time option is not set, then the default maximum is 1073741824.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f876ee04fb467dec2e88424ad542eb53469ec0b" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int, interpreted as a boolean, which enables or disables the collection of memory allocation statistics. When memory allocation statistics are disabled, the following SQLite interfaces become non-operational:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d36e0270700e44060555bf77969beca0ef1bb6" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;#sqlite3_mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b773ada2ea4912cbbe3a1e1cebfe063f6d8a1c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_MUTEX option takes a single argument which is a pointer to an instance of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure. The argument specifies alternative low-level mutex routines to be used in place the mutex routines built into SQLite. SQLite makes a copy of the content of the &lt;a href=&quot;mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; structure before the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then the entire mutexing subsystem is omitted from the build and hence calls to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the SQLITE_CONFIG_MUTEX configuration option will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e3ca8fa4415d94f70fc44a6276555caf14748e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc50296996fcaf95f25672cd009256aa14c36a0e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PAGECACHE option specifies a memory pool that SQLite can use for the database page cache with the default page cache implementation. This configuration option is a no-op if an application-define page cache implementation is loaded using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;. There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to 8-byte aligned memory (pMem), the size of each page cache line (sz), and the number of cache lines (N). The sz argument should be the size of the largest database page (a power of two between 512 and 65536) plus some extra bytes for each page header. The number of extra bytes needed by the page header can be determined using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt;. It is harmless, apart from the wasted memory, for the sz parameter to be larger than necessary. The pMem argument must be either a NULL pointer or a pointer to an 8-byte aligned block of memory of at least sz*N bytes, otherwise subsequent behavior is undefined. When pMem is not NULL, SQLite will strive to use the memory provided to satisfy page cache needs, falling back to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; if a page cache line is larger than sz bytes or if all of the pMem buffer is exhausted. If pMem is NULL and N is non-zero, then each database connection does an initial bulk allocation for page cache memory from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; sufficient for N cache lines if N is positive or of -1024*N bytes if N is negative, . If additional page cache memory is needed beyond what is provided by the initial allocation, then SQLite goes to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; separately for each additional cache line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1911f8a733a42d2b6026789f4ef363d83afb65d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0c16b7c9692df379eddfaf23502a1d2deb56c4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE2 option takes a single argument which is a pointer to an &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object. This object specifies the interface to a custom page cache implementation. SQLite makes a copy of the &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecb0f208e89787f9a7f11980392d2014f2ef02a" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc57facbbb1ece8f5d6410e99a1c9a1fcbbbc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which is a pointer to an integer and writes into that integer the number of extra bytes per page required for each page in &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The amount of extra space required can change depending on the compiler, target platform, and SQLite version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c693040f9e2e760d6e4cb06df98665a33285d6df" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;../compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;../pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;../pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667ddbb0eaa86ffc653459dd23bacb289f6854a7" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_PMASZ option takes a single parameter which is an unsigned integer and sets the &quot;Minimum PMA Size&quot; for the multithreaded sorter to that integer. The default minimum PMA Size is set by the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option. New threads are launched to help with sort operations when multithreaded sorting is enabled (using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command) and the amount of content to be sorted exceeds the page size times the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; setting and this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109fdd8da62f03c0d4a96a618a19a71e802f905e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SCRATCH option is no longer used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ca3b2106e1eec121b349f9609e0d465c220d3d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SMALL_MALLOC option takes single argument of type int, interpreted as a boolean, which if true provides a hint to SQLite that it should avoid large memory allocations if possible. SQLite will run faster if it is free to make large memory allocations, but some application might prefer to run slower in exchange for guarantees about memory fragmentation that are possible if large allocations are avoided. This hint is normally off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ddcc0bca5d82f48fed51db87e518d3912d859e" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e4676f31515701431b60d8c3fec0783441a3fad" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_SORTERREF_SIZE option accepts a single parameter of type (int) - the new value of the sorter-reference size threshold. Usually, when SQLite uses an external sort to order records according to an ORDER BY clause, all fields required by the caller are present in the sorted records. However, if SQLite determines based on the declared type of a table column that its values are likely to be very large - larger than the configured sorter-reference size threshold - then a reference is stored in each sorted record and the required column values loaded from the database as records are returned in sorted order. The default value for this option is to never use this optimization. Specifying a negative value for this option restores the default behaviour. This option is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_sorter_references&quot;&gt;SQLITE_ENABLE_SORTER_REFERENCES&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605f0b5884691b12b17ca06f9366cc2ade4cfd24" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;../tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;../compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96a7bbc95d6882993f7d0afda36dce9d7d4b5c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which becomes the &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; spill-to-disk threshold. &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;Statement journals&lt;/a&gt; are held in memory until their size (in bytes) exceeds this threshold, at which point they are written to disk. Or if the threshold is -1, statement journals are always held exclusively in memory. Since many statement journals never become large, setting the spill threshold to a value such as 64KiB can greatly reduce the amount of I/O required to support statement rollback. The default value for this setting is controlled by the &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c94d69eb75e63340f2383ddf68d20c1d31a18d" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab4ffd66152d39e37a9eeebeb02a7852ae9ede8" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_URI option takes a single argument of type int. If non-zero, then URI handling is globally enabled. If the parameter is zero, then URI handling is globally disabled. If URI handling is globally enabled, all filenames passed to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt; or specified as part of &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands are interpreted as URIs, regardless of whether or not the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set when the database connection is opened. If it is globally disabled, filenames are only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the database connection is opened. By default, URI handling is globally disabled. The default value may be changed by compiling with the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; symbol defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ea1f91dd128d45077ef6aab24be62cde2c08e4" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;../compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55987e1e9f78159dc547356995af9fe3ce5c9817" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; pre-processor macro defined. SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value that specifies the maximum size of the created heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90354942dff120bb22a653ae9fa0d244342b89da" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT code can also be used as the return value from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation. When xBestIndex() returns SQLITE_CONSTRAINT, that indicates that the particular combination of inputs submitted to xBestIndex() cannot result in a usable query plan and should not be given further consideration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3afc5f9dc7b86d4db8138dda7591ba7ea2f042" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT error code means that an SQL constraint violation occurred while trying to process an SQL statement. Additional information about the failed constraint can be found by consulting the accompanying error message (returned via &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt;) or by looking at the &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1402b83ad789cf26361c62d000ccad7aa66cb251" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_CHECK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f7b5e1d1fc684ffe767053e5ae405c247a79ff" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_COMMITHOOK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;c3ref/commit_hook&quot;&gt;commit hook callback&lt;/a&gt; returned non-zero that thus caused the SQL statement to be rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c857f1295fd44fc161f41f3c36b1faa547511cbf" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FOREIGNKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa48ddcf19118820df2cdaa1b78eb70d4071dd14" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_FUNCTION error code is not currently used by the SQLite core. However, this error code is available for use by extension functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4481d9380cb514a86e596c21d0da6c70c2337c" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_NOTNULL error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL constraint&lt;/a&gt; failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b921914ef5b1ae6eddb9ee04650c5c235d49ed11" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_PRIMARYKEY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2416f0eb5c1e4932d96de2c633168fe0745690" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_ROWID error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not unique.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d42ea811023ed01aef8eff1b26fe2bb9abe7bb95" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_TRIGGER error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtrigger#raise&quot;&gt;RAISE function&lt;/a&gt; within a &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt; fired, causing the SQL statement to abort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360095776d45f4673d25e1354d178fe2a9b1bd8f" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_UNIQUE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; indicating that a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2591670580b26a952a816bde9a68b915c405d78" translate="yes" xml:space="preserve">
          <source>The SQLITE_CONSTRAINT_VTAB error code is not currently used by the SQLite core. However, this error code is available for use by application-defined &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca22607c1bc11adbc4850780682a00fc2af063db" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT result code indicates that the database file has been corrupted. See the &lt;a href=&quot;lockingv3#how_to_corrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt; for further discussion on how corruption can occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83192f645bf11cddd8fa598bcc30dab724111331" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_SEQUENCE result code means that the schema of the sqlite_sequence table is corrupt. The sqlite_sequence table is used to help implement the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. The sqlite_sequence table should have the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e605977504524c24f74112f64c7f554569d710cb" translate="yes" xml:space="preserve">
          <source>The SQLITE_CORRUPT_VTAB error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; used by &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. A &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; might return SQLITE_CORRUPT_VTAB to indicate that content in the virtual table is corrupt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5aeac16ee13da96d49c9c69d5a1efa4f1ec4c7" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DEFENSIVE option activates or deactivates the &quot;defensive&quot; flag for a database connection. When the defensive flag is enabled, language features that allow ordinary SQL to deliberately corrupt the database file are disabled. The disabled features include but are not limited to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c89dddb1e567654969cbefc3cb66f653fb53df" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa9af190de834f94817db4398afc2b28f903d62" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DDL statements, such as CREATE TABLE and CREATE INDEX. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4f8ed114b3f33c0656fd3fe462891e36a86bca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;../quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;../compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23b83b3528f7ad3365bcce16b9fcdca7b11634b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_DQS_DML option activates or deactivates the legacy &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature for DML statement only, that is DELETE, INSERT, SELECT, and UPDATE statements. The default value of this setting is determined by the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763206f446e43106378de90da986cb3503647378" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;../queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62faf35588a5d4eafe007180e96f2c0c110300b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG). When the QPSG is active, a single SQL query statement will always use the same algorithm regardless of values of &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. The QPSG disables some query optimizations that look at the values of bound parameters, which can make some queries slower. But the QPSG has the advantage of more predictable behavior. With the QPSG active, SQLite will always use the same query plan in the field as was used during testing in the lab. The first argument to this setting is an integer which is 0 to disable the QPSG, positive to enable QPSG, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the QPSG is disabled or enabled following this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bef3f5951097e41221958d251dd3bbb9ce96dee" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;../lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;../pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c20d63d2e6b14f99d190fcacbd95a681ec8f6a" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_LEGACY_ALTER_TABLE option activates or deactivates the legacy behavior of the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command such it behaves as it did prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_24_0.html&quot;&gt;version 3.24.0&lt;/a&gt; (2018-06-04). See the &quot;Compatibility Notice&quot; on the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME documentation&lt;/a&gt; for additional information. This feature can also be turned on and off using the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8460a489883d4335645b0e8208feef234ba632" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;../pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46872dc1f07ab31c88fb7c7af6f4fae5ff78bc83" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBCONFIG_WRITABLE_SCHEMA option activates or deactivates the &quot;writable_schema&quot; flag. This has the same effect and is logically equivalent to setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=OFF&lt;/a&gt;. The first argument to this setting is an integer which is 0 to disable the writable_schema, positive to enable writable_schema, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether the writable_schema is enabled or disabled following this call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b85aa8ea894875435c445b85abe99205949918e" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE Virtual Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cd1369214f0f32feaaff6ac1895398317fe842" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides direct access to the underlying database file by interacting with the pager. SQLITE_DBPAGE is capable of both reading and writing any page of the database. Because interaction is through the pager layer, all changes are transactional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bc6095f9cb7b42e8d331fa1d325222ae39eae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6759306b08f50bd9c66f3b5fb6678d1fa27bfe11" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option to enable the SQLITE_DBPAGE extension. The SQLITE_DBPAGE extension makes use of unpublished internal interfaces and is not run-time loadable. The only way to add SQLITE_DBPAGE to an application is to compile it in using the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;SQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29d747e639293b4d0174864bbfeb0a0f144170ea" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table allows an application to view or replace the raw binary content of each page of the database file. No attempt is made to interpret the content of the page. Content is returned byte-for-byte as it appears on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b8d935ab9300d2651f69fa35d68c10b3cdb857" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table can participate in a join just like any other table. Hence, to see the content of the first page to all connected database files, one might run a statement like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15d4ed3f8e0c537ab57736b4ad4d051438f525bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table has one row for each page in the database file. SQLITE_DBPAGE allows pages to be read or to be overwritten. However the size of the database file cannot be changed. It is not possible to change the number of rows in the SQLITE_DBPAGE table by running DELETE or INSERT operations against that table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c5162b414c69b11a7519aa50aa6d53d70b24f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE table schema shown above is incomplete. There is a third &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;schema&quot; that determines which &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed database&lt;/a&gt; should be read or written. Because the &quot;schema&quot; column is hidden, it can be used as a parameter when SQLITE_DBPAGE is invoked as a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518c52e0806550bfb6aa69b1fed15fbc4111a9ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_DBPAGE virtual table read/write table that provides direct access to the underlying disk file on a page-by-page basis. The virtual table appears to have a schema like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1930c1236dfcd2ca69ef991dff0ceab5ad493f1" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76631b67d929ebcd295444bce3ec1691bb16c502" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization in the P argument is held in memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and that SQLite should take ownership of this memory and automatically free it when it has finished using it. Without this flag, the caller is responsible for freeing any dynamically allocated memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fffd4707786aad32f12960ea601bc8b62704db6b" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database should be treated as read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="684cad9c07969122877d4a208d11cefd54e63c00" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80121a4afb11422b1c8bfdaf5caf6ca8a41c2e89" translate="yes" xml:space="preserve">
          <source>The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to grow the size of the database using calls to &lt;a href=&quot;free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;. This flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used. Without this flag, the deserialized database cannot increase in size beyond the number of bytes specified by the M parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a817ebcb8adde635efe8cf6f019a45cbccc77452" translate="yes" xml:space="preserve">
          <source>The SQLITE_DETERMINISTIC flag means that the new function will always maps the same inputs into the same output. The abs() function is deterministic, for example, but randomblob() is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfa7a3aa99efd025281e40fa4911eb7511574c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5270c7d2917dccd93322da5fb7248f9aa949c0" translate="yes" xml:space="preserve">
          <source>The SQLITE_DIRECTONLY flag means that the function may only be invoked from top-level SQL, and cannot be used in VIEWs or TRIGGERs. This is a security feature which is recommended for all &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side-effects. This flag prevents an attacker from adding triggers and views to a schema then tricking a high-privilege application into causing unintended side-effects while performing ordinary queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec40aca0df374578f31a734ba1f44f72205f5695" translate="yes" xml:space="preserve">
          <source>The SQLITE_DONE result code indicates that an operation has completed. The SQLITE_DONE result code is most commonly seen as a return value from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicating that the SQL statement has run to completion. But SQLITE_DONE can also be returned by other multi-step interfaces such as &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb790f9dfaacb5c859298fcd4607429394630f86" translate="yes" xml:space="preserve">
          <source>The SQLITE_EMPTY result code is not currently used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae12a93b43b3b42e7d80f8bbf0372c74ffcd4aa7" translate="yes" xml:space="preserve">
          <source>The SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE options are not documented in &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; document because they are not officially supported. What they do is activate the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; dot-commands in the command-line shell, which provide low-level tracing output for the logic that generates code for SELECT statements and WHERE clauses, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270e8d29bbaf2c173c8af4cf652d5609825ae163" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR result code is a generic error code that is used when no other more specific error code is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c271c04ddb7b453a82bc99e0c9a2f05fc01521" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_MISSING_COLLSEQ result code means that an SQL statement could not be prepared because a collating sequence named in that SQL statement could not be located.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8f59027948d8336d219d332d3588711710c0d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_RETRY is used internally to provoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; (or one of its sibling routines for creating prepared statements) to try again to prepare a statement that failed with an error on the previous attempt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb2dd2db61b6baf0b7083d2230974437265ca99" translate="yes" xml:space="preserve">
          <source>The SQLITE_ERROR_SNAPSHOT result code might be returned when attempting to start a read transaction on an historical version of the database by using the &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface. If the historical snapshot is no longer available, then the read transaction will fail with the SQLITE_ERROR_SNAPSHOT. This error code is only possible if SQLite is compiled with &lt;a href=&quot;compile#enable_snapshot&quot;&gt;-DSQLITE_ENABLE_SNAPSHOT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbfe2b69087f0c646cf57766f8596a36d37fac1" translate="yes" xml:space="preserve">
          <source>The SQLITE_EXTRA_DURABLE compile-time option that used to cause the default &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting to be EXTRA, rather than FULL. This option is no longer supported. Use &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS=3&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13fb7c225046a481ec4f5c3de65895a35d5a534" translate="yes" xml:space="preserve">
          <source>The SQLITE_FORMAT error code is not currently used by SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b0edcf7878a4f55c879fd1aba1c1f540342aa6" translate="yes" xml:space="preserve">
          <source>The SQLITE_FULL result code indicates that a write could not complete because the disk is full. Note that this error can occur when trying to write information into the main database file, or it can also occur when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c86e9943e29fd3d57282b842d9c3bedce88e03" translate="yes" xml:space="preserve">
          <source>The SQLITE_HISTORY environment variable, if it exists, specifies the name of the command-line editing history file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521e2762edbf8211c7cbb9d7bfb58da8a1f086c6" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERNAL result code indicates an internal malfunction. In a working version of SQLite, an application should never see this result code. If application does encounter this result code, it shows that there is a bug in the database engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38d579654b4f1182c07a8a6f5867deba9d19d28" translate="yes" xml:space="preserve">
          <source>The SQLITE_INTERRUPT result code indicates that an operation was interrupted by the &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; interface. See also: &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1b9bcba49ffcf44baa9a43853834f3537e3646" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfdb556dc4a2d2c3aee5156579c0505409a3242" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite(). The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that after reboot following a crash or power loss, the only bytes in a file that were written at the application level might have changed and that adjacent bytes, even bytes within the same sector are guaranteed to be unchanged. The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN flag indicates that a file cannot be deleted when open. The SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on read-only media and cannot be changed even by processes with elevated privileges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e9041084560f5cee1cd0f7e8b2669a77b404b5" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb11acb1c9a7effbe4c566606f90f111aeaa51c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying filesystem supports doing multiple write operations atomically when those write operations are bracketed by &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abba910b15531d36f82588d451d0981d7b760afc" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR result code says that the operation could not finish because the operating system reported an I/O error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6217042802c9b2c3161cf544abc5162c5330d1de" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xAccess method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2437ab6f22990f68cc3c6b6ab11345e11bf39ab" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_ACCESS error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xClose method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cdfe432186a7333ec15fb6eebac01e4168d421" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_BLOCKED error code is no longer used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52b5d2e176049b701cd38566a1ec537e178a582" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CHECKRESERVEDLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xCheckReservedLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad717c7b1ad0bbb8f95440fa25c68effa605b2e" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_CONVPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; used only by Cygwin &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; and indicating that the cygwin_conv_path() system call failed. See also: &lt;a href=&quot;rescode#cantopen_convpath&quot;&gt;SQLITE_CANTOPEN_CONVPATH&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1351f2d6333fe014b3d2efb02bea78fd2458ea8" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DELETE_NOENT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object failed because the file being deleted does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4ef8736b02588e9ecd702311e3b92f76c71f42" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_CLOSE error code is no longer used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="257039837e1e28ae4885f94438deef37c72bcb03" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_DIR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fsync() on a directory. The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; attempts to fsync() directories after creating or deleting certain files to ensure that those files will still appear in the filesystem following a power loss or system crash. This error code indicates a problem attempting to perform that fsync().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703a40890c81baa50195428ead914670c8029bb4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSTAT error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to invoke fstat() (or the equivalent) on a file in order to determine information such as the file size or access permissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4411956ede5824f9653b6f7288932d4d59a1407a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_FSYNC error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to flush previously written content out of OS and/or disk-control buffers and into persistent storage. In other words, this code indicates a problem with the fsync() system call in unix or the FlushFileBuffers() system call in windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a80a6afbc34a7c330788ef9f803a0b5991e12c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_GETTEMPPATH error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is unable to determine a suitable directory in which to place temporary files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb09e15d8dd94c07c078d48b512a0e609b4a1ec7" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_LOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the advisory file locking logic. Usually an SQLITE_IOERR_LOCK error indicates a problem obtaining a &lt;a href=&quot;lockingv3#pending_lock&quot;&gt;PENDING lock&lt;/a&gt;. However it can also indicate miscellaneous locking errors on some of the specialized &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; used on Macs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928b9fb773e51d9b98d4eea6c5ad41e7a120edb9" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_MMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xFetch or xUnfetch methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map or unmap part of the database file into the process address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e769d752ed0575abbf0db74e042a1d936197ca" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_NOMEM error code is sometimes returned by the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer to indicate that an operation could not be completed due to the inability to allocate sufficient memory. This error code is normally converted into &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; by the higher layers of SQLite before being returned to the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8545169dd7924f6c6604c36309fb09b48638942a" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to read from a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b973a2eb159aa040eee4609af08e2a1feaa8688" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SEEK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xRead or xWrite methods on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to seek a file descriptor to the beginning point of the file where the read or write is to occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105abf471dd5b51825236d9c7cd0fbb3eb6cb7cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMLOCK error code is no longer used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19454e66c26708e9c7b0cf7de58d9fc407f5f14b" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMMAP error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to map a shared memory segment into the process address space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc7d56b93948bb563eb131a1d4f4001df7a785f" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMOPEN error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to open a new shared memory segment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38683c7c8ec002f5c2268623f613c65a832d0744" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHMSIZE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within the xShmMap method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to enlarge a &lt;a href=&quot;walformat#shm&quot;&gt;&quot;shm&quot; file&lt;/a&gt; as part of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; transaction processing. This error may indicate that the underlying filesystem volume is out of space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9742197ad61d509380008ae49be67afbc4a5ec72" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_SHORT_READ error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating that a read attempt in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer was unable to obtain as many bytes as was requested. This might be due to a truncated file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a04eeb47de957ef3978cba210956d9cb5d652c" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_TRUNCATE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to truncate a file to a smaller size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fea43ead41e3ee8f14dc4f738a5d86af22fa9867" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xDelete method on the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b74fa52836b69d8f9666b0cd822fdd7307145f4" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xLock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object while trying to obtain a read lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c346b35d66f482df6af0e3e742d33c4546a4dc99" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_UNLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error within xUnlock method on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8d955a87bc68c4a0c5a3d4a1efee03acc84572" translate="yes" xml:space="preserve">
          <source>The SQLITE_IOERR_WRITE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; indicating an I/O error in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; layer while trying to write into a file on disk. This error might result from a hardware malfunction or because a filesystem came unmounted while the file was open. This error should not occur if the filesystem is full as there is a separate error code (SQLITE_FULL) for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a8e9c53d139815a64f5839604fdd22fadaa0e7" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code differs from &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; in that SQLITE_LOCKED indicates a conflict on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or on a connection with a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;) whereas &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; indicates a conflict with a different database connection, probably in a different process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a782dd7cfb6d09bfdc0225cdd7b256e70fd078f6" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED result code indicates that a write operation could not continue because of a conflict within the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or a conflict with a different database connection that uses a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a5261f187f8bb18f86e6b8f8f93ccb09c0a9f0" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHARECACHE error code works very much like the &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error code except that SQLITE_LOCKED_SHARECACHE is for separate database connections that share a cache whereas SQLITE_BUSY is for the much more common case of separate database connections that do not share the same cache. Also, the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; interfaces do not help in resolving SQLITE_LOCKED_SHAREDCACHE conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43736bf56a426c4b58c2bec90f4d48ac9099897c" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_SHAREDCACHE error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; indicating that the locking conflict has occurred due to contention with a different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that happens to hold a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; with the database connection to which the error was returned. For example, if the other database connection is holding an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;exclusive lock&lt;/a&gt; on the database, then the database connection that receives this error will be unable to read or write any part of the database file unless it has the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted pragma&lt;/a&gt; enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cda10b684d70e57b826f0fa4c4df09ccba017aa" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCKED_VTAB result code is not used by the SQLite core, but it is available for use by extensions. Virtual table implementations can return this result code to indicate that they cannot complete the current operation because of locks held by other threads or processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51cbf2f4ccfc41ba0ad01c890bead2935bfa934" translate="yes" xml:space="preserve">
          <source>The SQLITE_LOCK_EXCLUSIVE lock must be held by a connection that wants to transition into our out of WAL mode. Transitioning into WAL mode is, therefore, just like any other write transaction, since every write transaction in rollback mode requires the SQLITE_LOCK_EXCLUSIVE lock. If the database file is already in WAL mode (hence if the desire it to change it back into rollback mode) and if there are two or more connections to the database, then each of these connections will be holding an SQLITE_LOCK_SHARED lock. That means that the SQLITE_LOCK_EXCLUSIVE cannot be obtained, and the transition out of WAL mode will not be allowed. This prevents one connection from deleting WAL mode out from under another. It also means that the only way to move a database from WAL mode into rollback mode is to close all but one connection to the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc70544c321ca8a14f098bcf8a7d9ab71f0f189a" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_COLUMN compile-time parameter is used to set an upper bound on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6525988f532e320cb712d12a43eb0921bdec4dc2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_EXPR_DEPTH parameter determines the maximum expression tree depth. If the value is 0, then no limit is enforced. The current implementation has a default value of 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87bafa8316c35e0283e8d900b37b61b6cd965c07" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_FUNCTION_ARG parameter determines the maximum number of parameters that can be passed to an SQL function. The default value of this limit is 100. SQLite should work with functions that have thousands of parameters. However, we suspect that anybody who tries to invoke a function with more than a few parameters is really trying to find security exploits in systems that use SQLite, not do useful work, and so for that reason we have set this parameter relatively low.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189922ac7fd95f7c9bc12f9ce7e9ab04f1adf79f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MAX_PAGE_SIZE compile-time option is now silently ignored. The maximum page size is hard-coded at 65536 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862c9c40eeff1a20092e93732416f94a8f2c333f" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMDEBUG option causes an instrumented &lt;a href=&quot;malloc#memdebug&quot;&gt;debugging memory allocator&lt;/a&gt; to be used as the default memory allocator within SQLite. The instrumented memory allocator checks for misuse of dynamically allocated memory. Examples of misuse include using memory after it is freed, writing off the ends of a memory allocation, freeing memory not previously obtained from the memory allocator, or failing to initialize newly allocated memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d3984ec504895ac3fbb00da3cebcbba9dedbe7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT Virtual Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d4cb84411a45f761656443b3561b46a357ff18" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad795204ac31f320600f752e689de3d922a2bd2" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT table appears to have the following schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c71018abf94b8f9efc3c61940d93dd9b424da6" translate="yes" xml:space="preserve">
          <source>The SQLITE_MEMSTAT virtual table is a read-only table that can be queried to determine performance characteristics (primarily the amount of memory being used) of the current instance of SQLite. The SQLITE_MEMSTATE table is essentially a wrapper around the C-language APIs &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;. If the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;memstat.c&lt;/a&gt; source file is compiled with the -DSQLITE_ENABLE_ZIPVFS option, then SQLITE_MEMSTAT will also do some &lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt; calls to extract memory usage information about the &lt;a href=&quot;https://www.hwaci.com/sw/sqlite/zipvfs.html&quot;&gt;ZIPVFS&lt;/a&gt; subsystem, if that subsystem as been licensed, installed, and is in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3941fc28dfa25db6c38115ec794332d498f61a67" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISMATCH error code indicates a datatype mismatch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="545fecc55ea90185cbbd63fd3b5f04d2c005fc32" translate="yes" xml:space="preserve">
          <source>The SQLITE_MISUSE return code might be returned if the application uses any SQLite interface in a way that is undefined or unsupported. For example, using a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; after that prepared statement has been &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; might result in an SQLITE_MISUSE error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7378cf4ec519f0105a315e8c418689ed2c8b9d03" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time option is no longer supported. Alternative mutex implementations can now be added at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb. *** Potentially incompatible change ***</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b652223c3c3d5b396101734631bda4e93654d297" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_APPDEF compile-time parameter is no longer recognized. As a replacement, alternative &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex implementations&lt;/a&gt; may be created at runtime using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; operator and the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c0584076e7e10d1a5a608c7c90ebdabce289b7" translate="yes" xml:space="preserve">
          <source>The SQLITE_MUTEX_NOOP implementation is a set of routines that does no real locking and is appropriate for use in a single-threaded application. The SQLITE_MUTEX_PTHREADS and SQLITE_MUTEX_W32 implementations are appropriate for use on Unix and Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd7fbf941fcd0cbf4106dee4f6ff2100d3cc081" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOLFS error can be returned on systems that do not support large files when the database grows to be larger than what the filesystem can handle. &quot;NOLFS&quot; stands for &quot;NO Large File Support&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cda63147d327bf25d081e640b795908860d57cd" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOMEM result code indicates that SQLite was unable to allocate all the memory it needed to complete the operation. In other words, an internal call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt; has failed in a case where the memory being allocated was required in order to continue the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90348aff38a7fe2d16e98097b8d995eefcd13821" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is also used internally by the SQLite implementation, but those internal uses are not exposed to the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b892d49dde78c36512aea678380b1b3cb4740c" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTFOUND result code is used in two contexts. SQLITE_NOTFOUND can be returned by the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface to indicate that the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write&quot;&gt;file control opcode&lt;/a&gt; passed as the third argument was not recognized by the underlying &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. SQLITE_NOTFOUND can also be returned by the xSetSystemCall() method of an &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2006836e7cf841369d470c41165b6630c3c15ae9" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE result code is not returned by any C/C++ interface. However, SQLITE_NOTICE (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual operation is taking place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cb61634cf3f64c55c04a76d9ecf0d6931de129" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_ROLLBACK result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; is rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f198e3499c541e2a07f04094a1095a33b4f9550d" translate="yes" xml:space="preserve">
          <source>The SQLITE_NOTICE_RECOVER_WAL result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; when a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database file is recovered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee291eadebc9e5d4151fc8b157f062bbbf6ed568" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK result code means that the operation was successful and that there were no errors. Most other result codes indicate an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1bbd15a81f09ee87a066e983ed6980b9d26517" translate="yes" xml:space="preserve">
          <source>The SQLITE_OK_LOAD_PERMANENTLY return code is useful to &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; that register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6becbabbe4a84dad21c1b1544eb673040cac46e2" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_* options are unsupported. By this we mean that an SQLITE_OMIT_* option that omits code from the build in the current release might become a no-op in the next release. Or the other way around: an SQLITE_OMIT_* that is a no-op in the current release might cause code to be excluded in the next release. Also, not all SQLITE_OMIT_* options are tested. Some SQLITE_OMIT_* options might cause SQLite to malfunction and/or provide incorrect answers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d47886ed69e3788c34a2d6c9a632c5948855a34" translate="yes" xml:space="preserve">
          <source>The SQLITE_OMIT_MERGE_SORT option has been removed. The merge sorter is now a required component of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ace5bda746aeaa5497bcf0c7e8c12395a91c1c1" translate="yes" xml:space="preserve">
          <source>The SQLITE_PERM result code indicates that the requested access mode for a newly created database could not be provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57074805a6a2909f8660b15999da8d8adc66e584" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad4cab077701a7da0038bd41b3f79ceedfd12d8" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NORMALIZE flag is a no-op. This flag used to be required for any prepared statement that wanted to use the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface. However, the &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface is now available to all prepared statements, regardless of whether or not they use this flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0438ba55e3894ec50e9427fa15e7d877e35f842" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_NO_VTAB flag causes the SQL compiler to return an error (error code SQLITE_ERROR) if the statement uses any virtual tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c6b699083a20e7dac515dfb0a940a1d2fa1d0a" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799dbb7451dd41ca217be627d63018af5431d1bf" translate="yes" xml:space="preserve">
          <source>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner that the prepared statement will be retained for a long time and probably reused many times. Without this flag, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; assume that the prepared statement will be used just once or at most a few times and then destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; relatively soon. The current implementation acts on this hint by avoiding the use of &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; so as not to deplete the limited store of lookaside memory. Future versions of SQLite may act on this hint differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c11fb868fc472e55f703cb835b3c6a27d603969" translate="yes" xml:space="preserve">
          <source>The SQLITE_PROTOCOL result code indicates a problem with the file locking protocol used by SQLite. The SQLITE_PROTOCOL error is currently only returned when using &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and attempting to start a new transaction. There is a race condition that can occur when two separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; both try to start a transaction at the same time in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The loser of the race backs off and tries again, after a brief delay. If the same connection loses the locking race dozens of times over a span of multiple seconds, it will eventually give up and return SQLITE_PROTOCOL. The SQLITE_PROTOCOL error should appear in practice very, very rarely, and only when there are many separate processes all competing intensely to write to the same database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2290c0085d649d3364cd3e13fd796218538f0c97" translate="yes" xml:space="preserve">
          <source>The SQLITE_RANGE error indices that the parameter number argument to one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind&lt;/a&gt; routines or the column number in one of the &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column&lt;/a&gt; routines is out of range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81db86b91239da795ab1877a821491920db31614" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY result code is returned when an attempt is made to alter some data for which the current database connection does not have write permission.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a2e61649ed0f39a9f887714e92e822fd9ead1d" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTINIT result code originates in the xShmMap method of a &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to indicate that the shared memory region used by &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; exists buts its content is unreliable and unusable by the current process since the current process does not have write permission on the shared memory region. (The shared memory region for WAL mode is normally a file with a &quot;-wal&quot; suffix that is mmapped into the process space. If the current process does not have write permission on that file, then it cannot write into shared memory.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc5d69c49bd0049fa508081d686d1a3ef3d0153" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_CANTLOCK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_CANTLOCK error code indicates that SQLite is unable to obtain a read lock on a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database because the shared-memory file associated with that database is read-only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19656bfe231a68e2b6cce42b55c5197d3d416be0" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DBMOVED error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_DBMOVED error code indicates that a database cannot be modified because the database file has been moved since it was opened, and so any attempt to modify the database might result in database corruption if the processes crashes because the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; would not be correctly named.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ecb30affe77245ceb751ab6c0b2e9fce929efd" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_DIRECTORY result code indicates that the database is read-only because process does not have permission to create a journal file in the same directory as the database and the creation of a journal file is a prerequisite for writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2523ec31f0b9a2d33cf73109d61b1e043f8086c" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_RECOVERY error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_RECOVERY error code indicates that a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database cannot be opened because the database file needs to be recovered and recovery requires write access but only read access is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba838fe9f900034dae5111194ba7ea1d5270d1c2" translate="yes" xml:space="preserve">
          <source>The SQLITE_READONLY_ROLLBACK error code is an &lt;a href=&quot;rescode#pve&quot;&gt;extended error code&lt;/a&gt; for &lt;a href=&quot;rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;. The SQLITE_READONLY_ROLLBACK error code indicates that a database cannot be opened because it has a &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal&lt;/a&gt; that needs to be rolled back but cannot because the database is readonly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25154fd2f20b85ded4823ebe97f48106c96d4d1" translate="yes" xml:space="preserve">
          <source>The SQLITE_ROW result code returned by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; indicates that another row of output is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d91aee6732a465a4cc20090bf5eb9177f9e582c" translate="yes" xml:space="preserve">
          <source>The SQLITE_SCHEMA result code indicates that the database schema has changed. This result code can be returned from &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; for a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that was generated using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. If the database schema was changed by some other process in between the time that the statement was prepared and the time the statement was run, this error can result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccaf372951fcf999b80b85d54115242255c5910" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT Virtual Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0210be179f988cfe689d56f75f4d1fa3e0b6bb8b" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/memstat.c&quot;&gt;https://sqlite.org/src/file/ext/misc/memstat.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79456ebf36875bab38cefa2c6e55d9482f8dca7" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension implements an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt; that provides information about all &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514c2473199b17afc5dd1d8c02362217c121606a" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is enabled in default builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53abd5cd3368a9c18b0e2f006747b4e8c1e98ad" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT extension is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; though it is disabled by default. Use the &lt;a href=&quot;compile#enable_stmtvtab&quot;&gt;SQLITE_ENABLE_STMTVTAB&lt;/a&gt; compile-time option to enable the SQLITE_STMT extension. The SQLITE_STMT extension can also be loaded at run-time by compiling the extension into a shared library or DLL using the source code at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/stmt.c&quot;&gt;https://sqlite.org/src/file/ext/misc/stmt.c&lt;/a&gt; and following the instructions for how to &lt;a href=&quot;loadext#build&quot;&gt;compile loadable extensions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff6d72f1420a16df254227915d0745e46f60ade" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table can also be used to access performance information about prepared statements, to aid in optimization an application. For example, to find out how much memory is being used by &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; that have never been used, one could run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a652edafe32e1a6a69623202e497c2b84971e5" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMT virtual table is a read-only table that can be directly queried to access information about all prepared statements on the current database connection. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c57e4bb46f13bf2108682321d36a64fbe9c7f037" translate="yes" xml:space="preserve">
          <source>The SQLITE_STMTJRNL_SPILL compile-time option determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt; start-time setting. That setting determines the size threshold above which &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journals&lt;/a&gt; are moved from memory to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53aa1b2835c1a75b5cdfb5b24f66527df47e52af" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;#sqlite3_value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bfb18749058a748b6ef8d70f30272423e2e061" translate="yes" xml:space="preserve">
          <source>The SQLITE_SUBTYPE flag indicates to SQLite that a function may call &lt;a href=&quot;value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; to inspect the sub-types of its arguments. Specifying this flag makes no difference for scalar or aggregate user functions. However, if it is not specified for a user-defined window function, then any sub-types belonging to arguments passed to the window function may be discarded before the window function is called (i.e. sqlite3_value_subtype() will always return 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebb912b265a126853dad1960970bce68414c982" translate="yes" xml:space="preserve">
          <source>The SQLITE_TMPDIR environment variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73fb526ebe5bd57bd3e299a92027075f6d77195" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code can also result when an oversized SQL statement is passed into one of the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interfaces. The maximum length of an SQL statement defaults to a much smaller value of 1,000,000 bytes. The maximum SQL statement length can be set at compile-time using &lt;a href=&quot;limits#max_sql_length&quot;&gt;SQLITE_MAX_SQL_LENGTH&lt;/a&gt; or at run-time using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitsqllength&quot;&gt;SQLITE_LIMIT_SQL_LENGTH&lt;/a&gt;,...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a063038fc4fca17964bc0777d759cfc88b33bd" translate="yes" xml:space="preserve">
          <source>The SQLITE_TOOBIG error code indicates that a string or BLOB was too large. The default maximum length of a string or BLOB in SQLite is 1,000,000,000 bytes. This maximum length can be changed at compile-time using the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; compile-time option, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;,...) interface. The SQLITE_TOOBIG error results when SQLite encounters a string or BLOB that exceeds the compile-time or run-time limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22248b709740e89a9f8d423ea84335819e1ee2a" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING result code is not returned by any C/C++ interface. However, SQLITE_WARNING (or rather one of its &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;) is sometimes used as the first argument in an &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; callback to indicate that an unusual and possibly ill-advised operation is taking place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd54655a92d09c02b918de6e8114904fcbbd22b3" translate="yes" xml:space="preserve">
          <source>The SQLITE_WARNING_AUTOINDEX result code is passed to the callback of &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; whenever &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; is used. This can serve as a warning to application designers that the database might benefit from additional indexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76259d82167d5f943a68fb0352bace5b64fab37" translate="yes" xml:space="preserve">
          <source>The SQLite Amalgamation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e12b48e05726457e7db136c89d439a466ab852" translate="yes" xml:space="preserve">
          <source>The SQLite Archive is a relatively new format. It was first described in in 2014. ZIP Archives and Tarballs, on the other hand, have been around for decades and are well-entrenched as standard formats. Most programmers know what a ZIP Archive or Tarball is, but if you say &quot;SQLite Archive&quot; you are more likely to get a reply of &quot;What?&quot; Tooling to process ZIP Archives and Tarballs is more likely to be installed on stock computers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b38e43f93cb1f6666b258c1070654e3f60d3ab" translate="yes" xml:space="preserve">
          <source>The SQLite Bytecode Engine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d2d0a8c73ed165c49cdebcf186c3bd62509aba" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &quot;VFS&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67edc3d607c153611c830c05dc44105c120df169" translate="yes" xml:space="preserve">
          <source>The SQLite OS Interface or &amp;quot;VFS&amp;quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb768474c2c960b1f80b5ec4636fc5c556432ed7" translate="yes" xml:space="preserve">
          <source>The SQLite Query Optimizer Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656be9ece72b3b3c8af07774a0a4473889d5a0ca" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree Module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f3e9d21d121d5b3e8db61ea6e7dde70d17b4dd" translate="yes" xml:space="preserve">
          <source>The SQLite R*Tree module is implemented as a &lt;a href=&quot;c3ref/create_module&quot;&gt;virtual table&lt;/a&gt;. Each R*Tree index is a virtual table with an odd number of columns between 3 and 11. The first column is always a 64-bit signed integer primary key. The other columns are pairs, one pair per dimension, containing the minimum and maximum values for that dimension, respectively. A 1-dimensional R*Tree thus has 3 columns. A 2-dimensional R*Tree has 5 columns. A 3-dimensional R*Tree has 7 columns. A 4-dimensional R*Tree has 9 columns. And a 5-dimensional R*Tree has 11 columns. The SQLite R*Tree implementation does not support R*Trees wider than 5 dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26287506df7d739659f92d570a45374e9d6b203" translate="yes" xml:space="preserve">
          <source>The SQLite Zipfile Module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a322992d7eadef1cbb665cdba826abcbe8d4bc9" translate="yes" xml:space="preserve">
          <source>The SQLite approach of storing the schema as text has advantages for an embedded relational database. For one, it means that the schema takes up less space in the database file. This is important since a common SQLite usage pattern is to have many small, separate database files instead of putting everything in one big global database file, which is the usual approach for client/server database engines. Since the schema is duplicated in each separate database file, it is important to keep the schema representation compact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4156bb8a5bb8b9775d5b39350cba56f0d4323350" translate="yes" xml:space="preserve">
          <source>The SQLite code is broken up into multiple repositories, each described in a separate section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50c10f7a2161303f10be1e978ecf9c20c8b5ff8a" translate="yes" xml:space="preserve">
          <source>The SQLite community has been a kind, welcoming and well-mannered community since its inception nearly two decades ago. In that time many of the qualities we've worked hard to bring to our project - safety, consistency, usability and integrity among them - have become part of our community's culture as well. Much like the care and effort we've put into securing the longevity of SQLite, we'd like to do the same for that community by clarifying our goals and expectations for all involved. To that end the SQLite project has officially adopted the &lt;a href=&quot;https://www.mozilla.org/en-US/about/governance/policies/participation/&quot;&gt;Mozilla Community Participation Guidelines&lt;/a&gt; as its Code of Conduct with the exception that the reporting email address is changed to &lt;a href=&quot;mailto:codeofconduct@sqlite.org&quot;&gt;codeofconduct@sqlite.org&lt;/a&gt;. While we are not doing so in reaction to any current or ongoing issues, we believe that this will be a helpful part of maintaining the long-term sustainability of the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e54c3c7cfbe74cbcff4d32cf11ceb85c2d59225" translate="yes" xml:space="preserve">
          <source>The SQLite core and its memory allocation subsystem provides the following capabilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8db7c1ed47d07dc8525eeb4fe9e3c2cadccf8a" translate="yes" xml:space="preserve">
          <source>The SQLite core calls the xBestIndex method when it is compiling a query that involves a virtual table. In other words, SQLite calls this method when it is running &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or the equivalent. By calling this method, the SQLite core is saying to the virtual table that it needs to access some subset of the rows in the virtual table and it wants to know the most efficient way to do that access. The xBestIndex method replies with information that the SQLite core can then use to conduct an efficient search of the virtual table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0101337cc0cb6fad83f4b1e21e8fd59c6d10699a" translate="yes" xml:space="preserve">
          <source>The SQLite core communicates with the xBestIndex method by filling in certain fields of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure and passing a pointer to that structure into xBestIndex as the second parameter. The xBestIndex method fills out other fields of this structure which forms the reply. The &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d592f9a3c73be507b58cc4d8ef9e1e11527c40f2" translate="yes" xml:space="preserve">
          <source>The SQLite core contains 5665 &lt;code&gt;assert()&lt;/code&gt; statements that verify function preconditions and postconditions and loop invariants. Assert() is a macro which is a standard part of ANSI-C. The argument is a boolean value that is assumed to always be true. If the assertion is false, the program prints an error message and halts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a046e08f75eaccd925ae647cf15c7aa3a8226b9" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsyncomitted&quot;&gt;SQLITE_FCNTL_SYNC_OMITTED&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; to the VFS in place of a call to xSync if the database has &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9454a146cdf6bd63746f75afc554dedcf8a89f3d" translate="yes" xml:space="preserve">
          <source>The SQLite core invokes this method in order to find the value for the N-th column of the current row. N is zero-based so the first column is numbered 0. The xColumn method may return its result back to SQLite using one of the following interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81909f2a4a51a96b134a34a4888c44983e2d76d3" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these routines for thread synchronization. Though they are intended for internal use by SQLite, code that links against SQLite is permitted to use any of these routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22d82769d3da3cfaaf7c30bf60dfe3d4e431d6a" translate="yes" xml:space="preserve">
          <source>The SQLite core uses these three routines for all of its own internal memory allocation needs. &quot;Core&quot; in the previous sentence does not include operating-system specific VFS implementation. The Windows VFS uses native malloc() and free() for some operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="310e86b319144a9b8ab497d9dda0fd59a92fa402" translate="yes" xml:space="preserve">
          <source>The SQLite core will call &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; early. The auxiliary C code file can contain an implementation of sqlite3_initialize() that registers an appropriate VFS and also perhaps initializes an alternative mutex system (if mutexes are required) or does any memory allocation subsystem initialization that is required. The SQLite core never calls &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; but it is part of the official SQLite API and is not otherwise provided when compiled with -DSQLITE_OS_OTHER=1, so the auxiliary C code file should probably provide it for completeness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3389235261ef05c3ad08031ba3272b1839ea345" translate="yes" xml:space="preserve">
          <source>The SQLite core, including the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, has 100% branch test coverage under &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; in its default configuration as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt;. Extensions such as FTS3 and RTree are excluded from this analysis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f0f08e26b5d1ff28a9d0772acbc6ec5d4dc8bf" translate="yes" xml:space="preserve">
          <source>The SQLite database allows multiple simultaneous readers or a single writer but not both. If any process is writing to the database no other process is allows to read or write. If any process is reading the database other processes are allowed to read but not write. The entire database shared a single lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e7754ee2f8ef030d3e0c4851d0ab23e5bf681e" translate="yes" xml:space="preserve">
          <source>The SQLite database file (&quot;self2014.sqlar&quot;) is about a half percent smaller than the equivalent ODP file! How can this be? Apparently the ZIP archive generator logic in NeoOffice is not as efficient as it could be, because when the same pile-of-files is recompressed using the command-line &quot;zip&quot; utility, one gets a file (&quot;zip.odp&quot;) that is smaller still, by another half percent, as seen in the third line above. So, a well-written ZIP archive can be slightly smaller than the equivalent SQLite database, as one would expect. But the difference is slight. The key take-away is that an SQLite database is size-competitive with a ZIP archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20b6f43ea15deb4c44a24b00c6944cb60a4b8d86" translate="yes" xml:space="preserve">
          <source>The SQLite database file format is also stable. All releases of SQLite version 3 can read and write database files created by the very first SQLite 3 release (version 3.0.0) going back to 2004-06-18. This is &quot;backwards compatibility&quot;. The developers promise to maintain backwards compatibility of the database file format for all future releases of SQLite 3. &quot;Forwards compatibility&quot; means that older releases of SQLite can also read and write databases created by newer releases. SQLite is usually, but not completely forwards compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9896b9f0acf4d53bbeb650db03c052b65e4b39c" translate="yes" xml:space="preserve">
          <source>The SQLite developers use an on-line checklist to coordinate testing activity and to verify that all tests pass prior each SQLite release. &lt;a href=&quot;http://www.sqlite.org/checklists/index.html&quot;&gt;Past checklists&lt;/a&gt; are retained for historical reference. (The checklists are read-only for anonymous internet viewers, but developers can log in and update checklist items in their web browsers.) The use of checklists for SQLite testing and other development activities is inspired by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f35e69a2395e538db8157dc3dbb68d5b6f19b6e" translate="yes" xml:space="preserve">
          <source>The SQLite file format is cross-platform. A database file written on one machine can be copied to and used on a different machine with a different architecture. Big-endian or little-endian, 32-bit or 64-bit does not matter. All machines use the same file format. Furthermore, the developers have pledged to keep the file format stable and backwards compatible, so newer versions of SQLite can read and write older database files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a470f0b14147aeef040dd5381d7be5b2946cd2d3" translate="yes" xml:space="preserve">
          <source>The SQLite interface elements can be grouped into three categories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2127d3816b52817dc6b4ce63d16e29894ba0878" translate="yes" xml:space="preserve">
          <source>The SQLite library consists of 102 files of C code (as of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;Version 3.9.0&lt;/a&gt; - 2015-10-14) in the core with 32 additional files that implement the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;, &lt;a href=&quot;dbstat&quot;&gt;DBSTAT&lt;/a&gt;, &lt;a href=&quot;json1&quot;&gt;JSON1&lt;/a&gt;, and &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extensions. Of the 102 main source files, about 75% are C code and about 25% are C header files. Most of these are &quot;source&quot; files in the sense that they are stored in the &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;SQLite version control system&lt;/a&gt; and are edited manually in an ordinary text editor. But some of the C-language files are generated using scripts or auxiliary programs. For example, the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=src/parse.y&quot;&gt;parse.y&lt;/a&gt; file contains an LALR(1) grammar of the SQL language which is compiled down into are parser in files &quot;parse.c&quot; and &quot;parse.h&quot; by the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fdfec2d5c500b7ac74b77876e6dfdaa2cdecb05" translate="yes" xml:space="preserve">
          <source>The SQLite library exports the string constant named &lt;b&gt;sqlite_version&lt;/b&gt; which contains the version number of the library. The header file contains a macro SQLITE_VERSION with the same information. If desired, a program can compare the SQLITE_VERSION macro against the &lt;b&gt;sqlite_version&lt;/b&gt; string constant to verify that the version number of the header file and the library match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f89e1941b8b597af45ed78a7c716ad9e7232f89" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;Tcl or Tcl/Tk&lt;/a&gt; script. SQLite began as a &lt;a href=&quot;http://www.tcl-lang.org/doc/tea/&quot;&gt;Tcl extension&lt;/a&gt; and the primary &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt; for SQLite is written in TCL. SQLite can be used with any programming language, but its connections to TCL run deep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0e8965a9252a8aca8a477026acb0a17bd84805b" translate="yes" xml:space="preserve">
          <source>The SQLite library is designed to be very easy to use from a C or C++ program. This document gives an overview of the C/C++ programming interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0602c28d1654d00a16d8fb7d7632cbb5225eb5e8" translate="yes" xml:space="preserve">
          <source>The SQLite library may need less RAM since it shares pages with the operating-system page cache and does not always need its own copy of working pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68ac5f0b4be242c75b75b113e85779b0d2d24fb" translate="yes" xml:space="preserve">
          <source>The SQLite library supplies the VDBE with a pointer to the callback function and the &lt;b&gt;pUserData&lt;/b&gt; pointer. (Both the callback and the user data were originally passed in as arguments to the &lt;b&gt;sqlite_exec()&lt;/b&gt; API function.) The job of the VDBE is to come up with values for &lt;b&gt;nColumn&lt;/b&gt;, &lt;b&gt;azData[]&lt;/b&gt;, and &lt;b&gt;azColumnName[]&lt;/b&gt;. &lt;b&gt;nColumn&lt;/b&gt; is the number of columns in the results, of course. &lt;b&gt;azColumnName[]&lt;/b&gt; is an array of strings where each string is the name of one of the result columns. &lt;b&gt;azData[]&lt;/b&gt; is an array of strings holding the actual data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec59993baf9ef121d8c6051be0842d34bbcc286" translate="yes" xml:space="preserve">
          <source>The SQLite library was compiled with &lt;a href=&quot;compile#use_uri&quot;&gt;-DSQLITE_USE_URI=1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d928b1fc0f8261eeda1295ec9247d5985e38f7" translate="yes" xml:space="preserve">
          <source>The SQLite project provides a simple command-line program named &lt;b&gt;sqlite3&lt;/b&gt; (or &lt;b&gt;sqlite3.exe&lt;/b&gt; on Windows) that allows the user to manually enter and execute SQL statements against an SQLite database. This document provides a brief introduction on how to use the &lt;b&gt;sqlite3&lt;/b&gt; program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c372f90b5ac62e99b6357128106b66701a0411a3" translate="yes" xml:space="preserve">
          <source>The SQLite query planner will consider using an index on an expression when the expression that is indexed appears in the WHERE clause or in the ORDER BY clause of a query,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dfbc1d18bbce16026bdcc86a5bffbbe6b1beb8b" translate="yes" xml:space="preserve">
          <source>The SQLite source code and the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; are stored together in a single repository. This one repository is all that is required to build the SQLite. The source repository is public and is readable by anonymous passers by on the internet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1097f713df32cd3a870e17f648d7622d77d22cd2" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains 992 uses of the &lt;code&gt;testcase()&lt;/code&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200e89ebce3af8e9c7c026a8d18cac87a1da0318" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains literally thousands of assert() statements used to verify internal assumptions and subroutine preconditions and postconditions. These assert() statements are normally turned off (they generate no code) since turning them on makes SQLite run approximately three times slower. But for testing and analysis, it is useful to turn the assert() statements on. The SQLITE_DEBUG compile-time option does this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7203161cfe6b6f33980e05611daeaed418ec5ae9" translate="yes" xml:space="preserve">
          <source>The SQLite source code contains multiple implementations of these mutex routines. An appropriate implementation is selected automatically at compile-time. The following implementations are available in the SQLite core:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="519e11bf2b879a67e8b0e9134459d439da57e623" translate="yes" xml:space="preserve">
          <source>The SQLite source code includes several different memory allocation modules that can be selected at compile-time, or to a limited extent at start-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b459704fa1dc2f133cc1300473552a0909311a3d" translate="yes" xml:space="preserve">
          <source>The SQLite source code provides multiple implementations of these APIs, suitable for varying environments. If SQLite is compiled with the SQLITE_THREADSAFE=0 flag then a no-op mutex implementation that is fast but does no real mutual exclusion is provided. That implementation is suitable for use in single-threaded applications or applications that only use SQLite in a single thread. Other real mutex implementations are provided based on the underlying operating system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4146cdfa0001cfa5a66203144506da17c3646968" translate="yes" xml:space="preserve">
          <source>The SQLite source tree actually contains multiple versions of the memory allocator. The default high-speed version found in the &quot;mem1.c&quot; source file is used for most builds. But if the SQLITE_MEMDEBUG flag is enabled, a separate memory allocator the &quot;mem2.c&quot; source file is used instead. The mem2.c allocator implements lots of hooks to do error checking and to simulate memory allocation failures for testing purposes. Both of these allocators use the malloc()/free() implementation in the standard C library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba1f99040a37a507011c1205b1aef886c686eaf" translate="yes" xml:space="preserve">
          <source>The SQLite version identifier returned by the &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt; SQL function and the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C API and found in the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; macro is now a 64-digit SHA3-256 hash instead of a 40-digit SHA1 hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3d7b8c49e09915f93340abac558621318ffacf" translate="yes" xml:space="preserve">
          <source>The SQLite website (&lt;a href=&quot;https://www.sqlite.org/&quot;&gt;https://www.sqlite.org/&lt;/a&gt;) uses SQLite itself, of course, and as of this writing (2015) it handles about 400K to 500K HTTP requests per day, about 15-20% of which are dynamic pages touching the database. Dynamic content uses &lt;a href=&quot;np1queryprob&quot;&gt;about 200 SQL statements per webpage&lt;/a&gt;. This setup runs on a single VM that shares a physical server with 23 others and yet still keeps the load average below 0.1 most of the time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc3cc55be8b0168568fc5c682e636d1909810e07" translate="yes" xml:space="preserve">
          <source>The SQLite-specific printf() supports a new flag (!) called the &quot;alternate-form-2&quot; flag. The alternate-form-2 flag changes the processing of floating-point conversions in subtle ways so that the output is always an SQL-compatible text representation of a floating-point number - something that is not possible to achieve with standard-library printf(). For string substitutions, the alternate-form-2 flag causes the width and precision to be measured in characters instead of bytes, which simplifies processing of strings containing multi-byte UTF8 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1ef24a2c3d89dbbf816b75c5ebad085546d51d" translate="yes" xml:space="preserve">
          <source>The SUM function detects integer overflow and converts to accumulating an approximate result using floating point numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d27464a9b4c0f0bdd924575293003beb50c81e1" translate="yes" xml:space="preserve">
          <source>The SUM() function throws an error on integer overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc003a9427832539005b297ca058e10476ece22" translate="yes" xml:space="preserve">
          <source>The Session Extension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa8192c55de05490d2622bfdb109c271f14a02d" translate="yes" xml:space="preserve">
          <source>The Spellfix1 Virtual Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7366e749b34cc79e46fd62658a2ec13bee8b7b92" translate="yes" xml:space="preserve">
          <source>The T argument is the name of the target database file. The A argument is the name of the RBU database file. The S argument is the name of a &quot;state database&quot; used to store state information needed to resume the update after an interruption. The S argument can be NULL in which case the state information is stored in the RBU database in various tables whose names all begin with &quot;rbu_&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d051df5b386db985e4647bccdf4da6546279c0" translate="yes" xml:space="preserve">
          <source>The TCL bindings transfer data without necessarily doing a conversion to a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bc381e62f8723019edd6efca853c02189bf80a" translate="yes" xml:space="preserve">
          <source>The TCL interface for SQLite is a small module that is added into the regular amalgamation. The result is a new amalgamated source file called &quot;&lt;b&gt;tclsqlite3.c&lt;/b&gt;&quot;. This single source file is all that is needed to generate a shared library that can be loaded into a standard &lt;a href=&quot;http://wiki.tcl-lang.org/2541&quot;&gt;tclsh&lt;/a&gt; or &lt;a href=&quot;http://wiki.tcl-lang.org/2364&quot;&gt;wish&lt;/a&gt; using the &lt;a href=&quot;http://wiki.tcl-lang.org/9830&quot;&gt;TCL load command&lt;/a&gt;, or to generate a standalone tclsh that comes with SQLite built in. A copy of the tcl amalgamation is included on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file in the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e41f74fbcda169959b0e1c5ad24699dcf79aca" translate="yes" xml:space="preserve">
          <source>The TEMP database file is very similar to auxiliary database files added using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement, though with a few special properties. The TEMP database is always automatically deleted when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed. The TEMP database always uses the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous=OFF&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=PERSIST&lt;/a&gt; PRAGMA settings. And, the TEMP database cannot be used with &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; nor can another process &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; the TEMP database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f0498bc726c9a2250102fc1ce88dd0e04a9743" translate="yes" xml:space="preserve">
          <source>The TEMP or TEMPORARY keyword is removed if it occurs after the initial CREATE keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b9ade3b04856b7f86ec94b71b3743aaff256ca8" translate="yes" xml:space="preserve">
          <source>The TEMP schema always has synchronous=OFF since the content of of TEMP is ephemeral and is not expected to survive a power outage. Attempts to change the synchronous setting for TEMP are silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8090269fd066de5e15019d6f63ecc9dd8e6b9f" translate="yes" xml:space="preserve">
          <source>The TEMP_STORE and DEFAULT_TEMP_STORE pragmas now work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbd6ac1d86267c3b2604d6573027830c458f6aa" translate="yes" xml:space="preserve">
          <source>The TH3 program generator is a TCL script named &quot;&lt;code&gt;mkth3.tcl&lt;/code&gt;&quot;. To generate a test program, one has merely to run this script and supply the names of files containing test modules and configurations on the command line. Test modules are files that use the &quot;&lt;code&gt;.test&lt;/code&gt;&quot; suffix and configurations are files that use the &quot;&lt;code&gt;.cfg&lt;/code&gt;&quot; suffix. A typical invocation of mkth3.tcl might look something like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c8240b8bebcede58e6b71d1007e7276f3ab838" translate="yes" xml:space="preserve">
          <source>The TH3 repository also includes the &quot;multitest.tcl&quot; script, another TCL script used to automate TH3 testing on workstations. Multitest.tcl automatically compiles SQLite, then runs ./th3make repeatedly with a variety of alignments, and captures the output in a succinct summary screen. A typical multitest.tcl run generates output that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f9b2cda115a994b187cb0154afbb957f0c6ad7" translate="yes" xml:space="preserve">
          <source>The TH3 source tree contains a scripted name &quot;mutation-test.tcl&quot; that automates the process of &lt;a href=&quot;testing#mutationtests&quot;&gt;mutation testing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdfe00d64176fc80b6e066f8b6b12526ed3a13b" translate="yes" xml:space="preserve">
          <source>The TH3 test harness needs to run on embedded systems that do not necessarily have the ability to spawn child processes, so it uses an in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to simulate crashes. The in-memory &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be rigged to make a snapshot of the entire filesystem after a set number of I/O operations. Crash tests run in a loop. On each iteration of the loop, the point at which a snapshot is made is advanced until the SQLite operations being tested run to completion without ever hitting a snapshot. Within the loop, after the SQLite operation under test has completed, the filesystem is reverted to the snapshot and random file damage is introduced that is characteristic of the kinds of damage one expects to see following a power loss. Then the database is opened and checks are made to ensure that it is well-formed and that the transaction either ran to completion or was completely rolled back. The interior of the loop is repeated multiple times for each snapshot with different random damage each time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fbf6e9083452ddac2fd083a957049cd4961ff8" translate="yes" xml:space="preserve">
          <source>The TMPDIR environment variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b5c9a4012ba043f6ac023992fea614e9559aac" translate="yes" xml:space="preserve">
          <source>The TRUNCATE journaling mode commits transactions by truncating the rollback journal to zero-length instead of deleting it. On many systems, truncating a file is much faster than deleting the file since the containing directory does not need to be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6a576f2a0740b1d820bb0b389ef9405211a467" translate="yes" xml:space="preserve">
          <source>The Tcl interface to the SQLite library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea435d43ff01f7eaaaed2d71b4ee7a4a7d014eaf" translate="yes" xml:space="preserve">
          <source>The Tcl script language is used to help translate canonical source code into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and to manage testing. Tcl is not used directly by SQLite itself (unless requested by a compile-time option). End users of the SQLite amalgamation sources do not need Tcl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea1be33d0917718998fde5f34057649d7f00dc5" translate="yes" xml:space="preserve">
          <source>The Truncate Optimization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663111ce13348e029be0eb29fd78279aef78534e" translate="yes" xml:space="preserve">
          <source>The UNION Virtual Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a6780922b4732cbc0add9d73d09070752444e6" translate="yes" xml:space="preserve">
          <source>The UNION operator for compound queries is implemented by creating a transient index in a temporary file and storing the results of the left and right subquery in the transient index, discarding duplicates. After both subqueries have been evaluated, the transient index is walked from beginning to end to generate the final output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7930c62c86f89ebc6a986709239760afad2bba9f" translate="yes" xml:space="preserve">
          <source>The UNION virtual table (hereafter: &quot;union-vtab&quot;) is a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; that makes multiple independent &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; tables look like a single large table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16da95be83b926d661aef977fab4f723fc62a011" translate="yes" xml:space="preserve">
          <source>The UPDATE and DELETE statements are coded using a template that is very similar to the SELECT statement template. The main difference, of course, is that the end action is to modify the database rather than invoke a callback function. Because it modifies the database it will also use transactions. Let's begin by looking at a DELETE statement:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d012a450cb6e8a62342d872acae64f627c638672" translate="yes" xml:space="preserve">
          <source>The UPDATE statement was not working when the WHERE clause contained some terms that could be satisfied using indices and other terms that could not. Fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45a66b4cdc4b1cad87f2ad44961d2b0a1e7cb34" translate="yes" xml:space="preserve">
          <source>The Use Of assert() In SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cb86d3be85bb36d2918c344be4f7a7dbe55738" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command is transactional in the sense that the generated output database is a consistent snapshot of the original database. However, if the VACUUM INTO command is interrupted by an unplanned shutdown or power lose, then the generated output database might be incomplete and corrupt. Also, SQLite does not invoke fsync() or FlushFileBuffers() on the generated database to ensure that it has reached non-volatile storage before completing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122691010e5d737070edb247661b2776162b982c" translate="yes" xml:space="preserve">
          <source>The VACUUM INTO command works the same way except that it uses the file named on the INTO clause in place of the temporary database and omits the step of copying the vacuumed database back over top of the original database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b858ec9bacb824cb3d161c5dbed06b788759184" translate="yes" xml:space="preserve">
          <source>The VACUUM command may change the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; of entries in any tables that do not have an explicit &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41696dc3c99878e16f90bac54782d308e462d0f3" translate="yes" xml:space="preserve">
          <source>The VACUUM command now works with the non-callback API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27866863317458114de851c82a30b86b318d52b6" translate="yes" xml:space="preserve">
          <source>The VACUUM command rebuilds the database file, repacking it into a minimal amount of disk space. There are several reasons an application might do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa5f71406817eba130230946d703a26da25090a" translate="yes" xml:space="preserve">
          <source>The VACUUM command with an INTO clause is an alternative to the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; for generating backup copies of a live database. The advantage of using VACUUM INTO is that the resulting backup database is minimal in size and hence the amount of filesystem I/O may be reduced. Also, all deleted content is purged from the backup, leaving behind no forensic traces. On the other hand, the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; uses fewer CPU cycles and can be executed incrementally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a189fd9e3d1e02aa0528451d9b2483299ef4e9" translate="yes" xml:space="preserve">
          <source>The VACUUM command works by copying the contents of the database into a temporary database file and then overwriting the original with the contents of the temporary file. When overwriting the original, a rollback journal or &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; WAL file is used just as it would be for any other database transaction. This means that when VACUUMing a database, as much as twice the size of the original database file is required in free disk space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778738485f953e3a9b76b31822d939e887b55074" translate="yes" xml:space="preserve">
          <source>The VALUE and HIWTR columns report the current value of the measure and its &quot;high-water mark&quot;. The high-water mark is the highest value ever seen for the measurement, at least since the last reset. The SQLITE_MEMSTAT virtual table does not provide a mechanism for resetting the high-water mark.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2ece5b4ab8b91b62ace8f0cc0040f19a643253" translate="yes" xml:space="preserve">
          <source>The VALUES clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a859f7de071f48cff5a7fe9193dabc82e472c2" translate="yes" xml:space="preserve">
          <source>The VALUES clause of an INSERT can now contain expressions, including scalar SELECT clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222a8cea06637d3ca462a60582d77b6f51ecd46d" translate="yes" xml:space="preserve">
          <source>The VDBE code generated by the above statement looks like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914b54584037bedb35946860061828500f1bc504" translate="yes" xml:space="preserve">
          <source>The VDBE code generated for this query is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e862e51e63dc8e6d2cfc4ebc01e6bf18bd5d5d" translate="yes" xml:space="preserve">
          <source>The VDBE implements a virtual computer that runs a program in its virtual machine language. The goal of each program is to interrogate or change the database. Toward this end, the machine language that the VDBE implements is specifically designed to search, read, and modify databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dceeabf6f031eb26374896fc49e25ce44afb511" translate="yes" xml:space="preserve">
          <source>The VDBE program generated for this SQL statement is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80bc0b2de97d753f617c4eaf5d3c9b6776ea43cf" translate="yes" xml:space="preserve">
          <source>The VERSION table shown above has columns to record a check-in comment (presumably supplied by the user) and the time and date at which the File/Save action occurred. It also records the parent version to record the history of changes. Perhaps the manifest could be stored as a delta from the parent version, though typically the manifest will be small enough that storing a delta might be more trouble than it is worth. The SLIDE table also contains a derivedFrom column which could be used for delta encoding if it is determined that saving the slide content as a delta from its previous version is a worthwhile optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0766456a2002e4475782706d0b0fb713540038a5" translate="yes" xml:space="preserve">
          <source>The VFS interface is sometimes extended by adding new methods onto the end. Each time such an extension occurs, the iVersion field is incremented. The iVersion value started out as 1 in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; on 2007-09-04, then increased to 2 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; on 2010-07-21, and then increased to 3 with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; on 2011-04-12. Additional fields may be appended to the sqlite3_vfs object and the iVersion value may increase again in future versions of SQLite. Note that the structure of the sqlite3_vfs object changes in the transition from SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_9.html&quot;&gt;version 3.5.9&lt;/a&gt; to &lt;a href=&quot;https://sqlite.org/releaselog/3_6_0.html&quot;&gt;version 3.6.0&lt;/a&gt; on 2008-07-16 and yet the iVersion field was not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9428f4f61873bedbb7fa546ce9da2878f0f6b46f" translate="yes" xml:space="preserve">
          <source>The VFS specified by a URI has the highest priority. After that comes a VFS specified as the fourth argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The default VFS is used if no VFS is specified otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f617b8350433543bfe3f6503e9062a84ed6414" translate="yes" xml:space="preserve">
          <source>The Virtual Database Engine of SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc007776417aa54116dbc71f8065ab7e3ac76ea" translate="yes" xml:space="preserve">
          <source>The Virtual Table Mechanism Of SQLite</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a47770692c502c7c39564cd0fc7b210860b676a" translate="yes" xml:space="preserve">
          <source>The WAL approach inverts this. The original content is preserved in the database file and the changes are appended into a separate WAL file. A &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when a special record indicating a commit is appended to the WAL. Thus a COMMIT can happen without ever writing to the original database, which allows readers to continue operating from the original unaltered database while changes are simultaneously being committed into the WAL. Multiple transactions can be appended to the end of a single WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b1501dab1e647276daeb770adadd0f94b39bd1" translate="yes" xml:space="preserve">
          <source>The WAL file can optionally be truncated on a reset, but it need not be. Performance is usually a little better if the WAL is not truncated, since filesystems generally will overwrite an existing file faster than they will grow a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee114cc7fc43aace09ed2f31fdb137fc0cc57b0" translate="yes" xml:space="preserve">
          <source>The WAL file exists for as long as any &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has the database open. Usually, the WAL file is deleted automatically when the last connection to the database closes. However, if the last process to have the database open exits without cleanly shutting down the database connection, or if the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file control&lt;/a&gt; is used, then the WAL file might be retained on disk after all connections to the database have been closed. The WAL file is part of the persistent state of the database and should be kept with the database if the database is copied or moved. If a database file is separated from its WAL file, then transactions that were previously committed to the database might be lost, or the database file might become corrupted. The only safe way to remove a WAL file is to open the database file using one of the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; interfaces then immediately close the database using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79014b745cf0a5f8595085db33b3a7e639f66d1c" translate="yes" xml:space="preserve">
          <source>The WAL header is 32 bytes in size and consists of the following eight big-endian 32-bit unsigned integer values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad8fc65cf4c28a6553ebe75589fa3de09b97b25" translate="yes" xml:space="preserve">
          <source>The WAL journal mode will be set on all connections to the same database file if it is set on any one connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2da5fc09a01446274895178b9f5584cc12d72c9" translate="yes" xml:space="preserve">
          <source>The WAL journaling mode uses a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; instead of a rollback journal to implement transactions. The WAL journaling mode is persistent; after being set it stays in effect across multiple database connections and after closing and reopening the database. A database in WAL journaling mode can only be accessed by SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21) or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbeadb5beff9552e41ebfc0aed8339e43743fd64" translate="yes" xml:space="preserve">
          <source>The WAL-index format version number. Always 3007000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0470594be37c3f0ff60237d02ae37bf43150bc8" translate="yes" xml:space="preserve">
          <source>The WAL-index or &quot;shm&quot; file is used to coordinate access to the database by multiple clients, and as a cache to help clients quickly locate frames within the wal file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa0bf716018ca8d2c184cf21d82cae1245d9415" translate="yes" xml:space="preserve">
          <source>The WAL_CKPT_LOCK is only locked exclusively. There is never a shared lock taken on WAL_CKPT_LOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42d567271c4a4abf54f649e6218b2a342b7491c5" translate="yes" xml:space="preserve">
          <source>The WAL_RECOVER_LOCK is only locked exclusively. There is never a shared lock taken on WAL_RECOVER_LOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f378361895c3312e72c176b00bbf1af957e8b29d" translate="yes" xml:space="preserve">
          <source>The WAL_WRITE_LOCK is only locked exclusively. There is never a shared lock taken on WAL_WRITE_LOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cddb2fff96db0eb2561a8fa9288188bd61c4a17a" translate="yes" xml:space="preserve">
          <source>The WHERE clause is implemented by instructions 6 through 8. The job of the where clause is to skip the ListWrite if the WHERE condition is false. To this end, it jumps ahead to the Next instruction if the &quot;two&quot; column (extracted by the Column instruction) is greater than or equal to 50.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f1ffc6e309ea1c4b2ff1d0678fe7459979e894" translate="yes" xml:space="preserve">
          <source>The WHERE clause on a query is broken up into &quot;terms&quot; where each term is separated from the others by an AND operator. If the WHERE clause is composed of constraints separate by the OR operator then the entire clause is considered to be a single &quot;term&quot; to which the &lt;a href=&quot;#or_opt&quot;&gt;OR-clause optimization&lt;/a&gt; is applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67af3225970c5961856bbb922d2677740529dd45" translate="yes" xml:space="preserve">
          <source>The WINDOW clause, when one is present, comes after any HAVING clause and before any ORDER BY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f006cfccb1b0c07b582f38b2b03e476dd1faa4" translate="yes" xml:space="preserve">
          <source>The WITH Clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bb3b8074d7fe6469254452d39dc417f079e333" translate="yes" xml:space="preserve">
          <source>The WITH clause cannot be used within a &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469f423bf145b329a62c79e892ff06f00b735aaa" translate="yes" xml:space="preserve">
          <source>The WITH clause must appear at the beginning of a top-level &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement or at the beginning of a subquery. The WITH clause cannot be prepended to the second or subsequent SELECT statement of a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0790118e4cc64a2949db095a0b8b9579da7d5654" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID optimization is likely to be helpful for tables that have non-integer or composite (multi-column) PRIMARY KEYs and that do not store large strings or BLOBs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b74650aa10ba4b42e039edd4a2cc74f6b68fb08b" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID syntax is an optimization. It provides no new capabilities. Anything that can be done using a WITHOUT ROWID table can also be done in exactly the same way, and exactly the same syntax, using an ordinary rowid table. The only advantage of a WITHOUT ROWID table is that it can sometimes use less disk space and/or perform a little faster than an ordinary rowid table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d979d02523b8b3c921a385853078f31581834f" translate="yes" xml:space="preserve">
          <source>The WITHOUT ROWID table that has the same structure as the t1bc index would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd241bcb9edacf4c26a21a11fc0d3a7cc0b5d00" translate="yes" xml:space="preserve">
          <source>The X callback is invoked whenever any of the events identified by mask M occur. The integer return value from the callback is currently ignored, though this may change in future releases. Callback implementations should return zero to ensure future compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9560a5bff3ce71963e342a5450ede2debbbea82" translate="yes" xml:space="preserve">
          <source>The aConstraintUsage[] array contains one element for each of the nConstraint constraints in the inputs section of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. The aConstraintUsage[] array is used by xBestIndex to tell the core how it is using the constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3276fd18c87b4e795759956677bbdc04f564672d" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array contains information about all constraints that apply to the virtual table. But some of the constraints might not be usable because of the way tables are ordered in a join. The xBestIndex method must therefore only consider constraints that have an aConstraint[].usable flag which is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f35e14867214bff1de15c06eccca3a8c64a445" translate="yes" xml:space="preserve">
          <source>The aConstraint[] array records WHERE clause constraints of the form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201991425b66ed2865e7a91ab0511b280556125f" translate="yes" xml:space="preserve">
          <source>The ability to add &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, including aggregate and table-valued functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3094b48cb721d2768a7d14f0821434de8cd0a90" translate="yes" xml:space="preserve">
          <source>The ability to index expressions was added to SQLite with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). A database that uses an index on expressions will not be usable by earlier versions of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e647580ce3a971bdf9683f9f823fdf4aa9345057" translate="yes" xml:space="preserve">
          <source>The ability to store BLOBs in indexed columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7fcdb984584a84897317afa23740edc4a933b7" translate="yes" xml:space="preserve">
          <source>The above code creates a new table named &lt;b&gt;t1&lt;/b&gt; with columns &lt;b&gt;a&lt;/b&gt; and &lt;b&gt;b&lt;/b&gt;. What could be simpler?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e597cdc48d987ee3a37507f5f4f64e4eebc9821" translate="yes" xml:space="preserve">
          <source>The above command should be run from the MSVC Native Tools Command Prompt. If you have MSVC installed on your machine, you probably have multiple versions of this Command Prompt, for native builds for x86 and x64, and possibly also for cross-compiling to ARM. Use the appropriate Command Prompt depending on the desired DLL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e5d3c82a1f28fca2d855ebabf947c2e6309d01" translate="yes" xml:space="preserve">
          <source>The above is all you really need to know in order to use SQLite in your C or C++ programs. There are other interface functions available (and described below) but we will begin by describing the core functions shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d8b560084e958b9b180ef1ea3e4c34811a8e33" translate="yes" xml:space="preserve">
          <source>The above means that executing the 'merge' command with a negative parameter until the before and after difference in the return value of &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is less than two optimizes the FTS index in the same way as the &lt;a href=&quot;fts5#the_optimize_command&quot;&gt;FTS5 optimize command&lt;/a&gt;. However, if a new b-tree is added to the FTS index while this process is ongoing, FTS5 will move the new b-tree to the same level as the existing b-trees and restart the merge. To avoid this, only the first call to 'merge' should specify a negative parameter. Each subsequent call to 'merge' should specify a positive value so that the merge started by the first call is run to completion even if new b-trees are added to the FTS index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9200726c1128b95e04b731c9b7e036f2a699198" translate="yes" xml:space="preserve">
          <source>The above two assumptions may be interpreted to mean that if a system failure occurs after file truncation but before the truncated file is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e4faf9292fbb17cef84d7ffb499ec94358865c" translate="yes" xml:space="preserve">
          <source>The above will return something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0861e077c18aeb6848f0b5c9c63fbc9c90c17596" translate="yes" xml:space="preserve">
          <source>The abs(X) function returns the absolute value of the numeric argument X. Abs(X) returns NULL if X is NULL. Abs(X) returns 0.0 if X is a string or blob that cannot be converted to a numeric value. If X is the integer -9223372036854775808 then abs(X) throws an integer overflow error since there is no equivalent positive 64-bit two complement value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb517318225f5fe795733968275ce4a51bc681e" translate="yes" xml:space="preserve">
          <source>The absolute value of this integer argument is used as the (approximate) number of tokens to include in the returned text value. The maximum allowable absolute value is 64. The value of this argument is referred to as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85ca4a9788c6f1b476159c0eeb6719f0a0122577" translate="yes" xml:space="preserve">
          <source>The acctchng_magnitude index is over the account number (&quot;acct_no&quot;) and on the absolute value of the amount. This index allows one to do efficient queries over the magnitude of a change to the account. For example, to list all changes to account number $xyz that are more than $100.00, one can say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e14d586171fc852b529e7898dae84a1afce65ec" translate="yes" xml:space="preserve">
          <source>The acronym RBU stands for &quot;Resumable Bulk Update&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd26fea06f2a519581c858bc894c62df5370dfe9" translate="yes" xml:space="preserve">
          <source>The act of deleting a file is expensive on many systems. As an optimization, SQLite can be configured to truncate the journal file to zero bytes in length or overwrite the journal file header with zeros. In either case, the resulting journal file is no longer capable of rolling back and so the transaction still commits. Truncating a file to zero length, like deleting a file, is assumed to be an atomic operation from the point of view of a user process. Overwriting the header of the journal with zeros is not atomic, but if any part of the header is malformed the journal will not roll back. Hence, one can say that the commit occurs as soon as the header is sufficiently changed to make it invalid. Typically this happens as soon as the first byte of the header is zeroed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb72a7b6e0cde775aa0861a739588c085322d8b5" translate="yes" xml:space="preserve">
          <source>The action of the preupdate hook is similar to the &lt;a href=&quot;c3ref/update_hook&quot;&gt;update hook&lt;/a&gt; except that the callback is invoked before the change, not afterwards, and the preupdate hook interfaces are omitted unless this compile-time option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d730b41c0c65afc48bf2186d2e78971f79c0ae93" translate="yes" xml:space="preserve">
          <source>The actual remote head</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5942dd3b483843b4b3b13169967e9623c12cf60" translate="yes" xml:space="preserve">
          <source>The actual value of the automerge parameter determines the number of index segments merged simultaneously by an automatic inverted index merge. If the value is set to N, the system waits until there are at least N segments on a single level before beginning to incrementally merge them. Setting a lower value of N causes segments to be merged more quickly, which may speed up full-text queries and, if the workload contains UPDATE or DELETE operations as well as INSERTs, reduce the space on disk consumed by the full-text index. However, it also increases the amount of data written to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcad8bd16dfc8bbae32259b89340b3c09c02938b" translate="yes" xml:space="preserve">
          <source>The address of the cell in the parent frame is determined by adding the value of the P1 argument to the value of the P1 argument to the calling &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e600ae2c57bf2172dc311ec955786ffac68bdb53" translate="yes" xml:space="preserve">
          <source>The advantage of the table-valued function format is that the query can return just a subset of the PRAGMA columns, can include a WHERE clause, can use aggregate functions, and the table-valued function can be just one of several data sources in a join. For example, to get a list of all indexed columns in a schema, one could query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98ae93ba70e0ca59260993947a4e24c760765d2" translate="yes" xml:space="preserve">
          <source>The advantages of doing many smaller sorts instead of a single large sort are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b97dc5f9d1078668a6ce572dccbfb387883173" translate="yes" xml:space="preserve">
          <source>The affinity of a column is determined by the declared type of the column, according to the following rules in the order shown:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81c1ff1ba114ea49399c70cede12a7ccd08cc3d4" translate="yes" xml:space="preserve">
          <source>The affinity of the v1.x column will be the same as the affinity of t1.b (TEXT), since v1.x maps directly into t1.b. But columns v1.y and v1.z both have no affinity, since those columns map into expression a+c and 42, and expressions always have no affinity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab16418452d7d68b0bd05abd8cefe39ddc38000d" translate="yes" xml:space="preserve">
          <source>The aggregate functions shown below are available by default. Additional aggregate functions written in C may be added using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084c900ab7b78b8fb14c15704a0ab2585c905626" translate="yes" xml:space="preserve">
          <source>The algorithm above works quite well for most cases, but there are exceptions. These exceptions can be dealt with by making additional entries in the virtual table using the &quot;soundslike&quot; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db0be7814305eaba73945c0429fa38151c410e55" translate="yes" xml:space="preserve">
          <source>The algorithm specified in the OR clause of an INSERT or UPDATE overrides any algorithm specified in a CREATE TABLE. If no algorithm is specified anywhere, the ABORT algorithm is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1bb5e260f6d6940f8038960690efd8a13241e0" translate="yes" xml:space="preserve">
          <source>The algorithm used by memsys5 can be called &quot;power-of-two, first-fit&quot;. The sizes of all memory allocation requests are rounded up to a power of two and the request is satisfied by the first free slot in pBuf that is large enough. Adjacent freed allocations are coalesced using a buddy system. When used appropriately, this algorithm provides mathematical guarantees against fragmentation and breakdown, as described further &lt;a href=&quot;#nofrag&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91caf7e2c108fa5ca12a12fe7d7f1b642ba24d6e" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_prepare_v2() function is similar, except that step 4 (resetting the statement handle) is omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae289508ac99f821f2b991e22b21782588d9eaa" translate="yes" xml:space="preserve">
          <source>The algorithm used by the sqlite3_blocking_step() function is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce63f03e43853b117cae180b17d7d91a1fc4423c" translate="yes" xml:space="preserve">
          <source>The alternate-form-2 flag is a non-standard extension that appears in no other printf() implementations, as far as we know.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b22ace0382822e0d79f9e1827563fce76153d6" translate="yes" xml:space="preserve">
          <source>The alternative page cache mechanism is an extreme measure that is only needed by the most demanding applications. The built-in page cache is recommended for most uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4794d01495b7d8ad2197d5e4f4f33e4044492d" translate="yes" xml:space="preserve">
          <source>The alternative query formulations shown above are conceptual only. SQLite does not really transform the query. The actual query plan is like this: SQLite locates the first possible value for &quot;role&quot;, which it can do by rewinding the &quot;people_idx1&quot; index to the beginning and reading the first record. SQLite stores this first &quot;role&quot; value in an internal variable that we will here call &quot;$role&quot;. Then SQLite runs a query like: &quot;SELECT name FROM people WHERE role=$role AND height&amp;gt;=180&quot;. This query has an equality constraint on the left-most column of the index and so the index can be used to resolve that query. Once that query is finished, SQLite then uses the &quot;people_idx1&quot; index to locate the next value of the &quot;role&quot; column, using code that is logically similar to &quot;SELECT role FROM people WHERE role&amp;gt;$role LIMIT 1&quot;. This new &quot;role&quot; value overwrites the $role variable, and the process repeats until all possible values for &quot;role&quot; have been examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a91f523f7f1e692f775ff82bc9d632716d5637ec" translate="yes" xml:space="preserve">
          <source>The amalgamation and the sqlite3.h header file are available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; as a file named sqlite-amalgamation-X.zip where the X is replaced by the appropriate version number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a154d12ef5a44def7683dee324b4a87567d061" translate="yes" xml:space="preserve">
          <source>The amalgamation contains everything you need to integrate SQLite into a larger project. Just copy the amalgamation into your source directory and compile it along with the other C code files in your project. (A &lt;a href=&quot;howtocompile&quot;&gt;more detailed discussion&lt;/a&gt; of the compilation process is available.) You may also want to make use of the &quot;sqlite3.h&quot; header file that defines the programming API for SQLite. The sqlite3.h header file is available separately. The sqlite3.h file is also contained within the amalgamation, in the first few thousand lines. So if you have a copy of sqlite3.c but cannot seem to locate sqlite3.h, you can always regenerate the sqlite3.h by copying and pasting from the amalgamation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5760ad296baf5ccd7d73666c3833985afa715a2" translate="yes" xml:space="preserve">
          <source>The amount of payload that spills onto overflow pages also depends on the page type. For the following computations, let U be the usable size of a database page, the total page size less the reserved space at the end of each page. And let P be the payload size. In the following, symbol X represents the maximum amount of payload that can be stored directly on the b-tree page without spilling onto an overflow page and symbol M represents the minimum amount of payload that must be stored on the btree page before spilling is allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3035b3f13a8c2eedd1a82b2e759ec82828d6061b" translate="yes" xml:space="preserve">
          <source>The amount of space allocated by sqlite3_aggregate_context(C,N) is determined by the N parameter on first successful call. Changing the value of N in subsequent call to sqlite3_aggregate_context() within the same aggregate function instance will not resize the memory allocation. Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context(C,N) so that no pointless memory allocations occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fa74a585edf255bca976e35bf58c2115a55266" translate="yes" xml:space="preserve">
          <source>The android performance numbers for the write experiments are omitted because the performance tests on the Galaxy S3 are so random. Two consecutive runs of the exact same experiment would give wildly different times. And, to be fair, the performance of SQLite on android is slightly slower than writing directly to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba25e29078b648c595b0c513af632a78976e2d1a" translate="yes" xml:space="preserve">
          <source>The application file is portable across all operating systems, 32-bit and 64-bit and big- and little-endian architectures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553858a0531981a9db580aff8d49f00f4db9f6bc" translate="yes" xml:space="preserve">
          <source>The application has made changes to the &lt;a href=&quot;fts3#*shadowtab&quot;&gt;FTS shadow tables&lt;/a&gt; directly, without using the FTS3/4 virtual table, causing the shadow tables to become out of sync with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744b17ec690883f96b76e631855849a6884a7431" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a416f0180cf818dc5e0d104e2af8fd17ae77d32" translate="yes" xml:space="preserve">
          <source>The application must ensure that the 1st parameter to sqlite3_exec() is a valid and open &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbea7596a56ecae7226dfed468f733b0ebf473a" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5d8c6646b2fcb9cbadc4a78abf91f82a6d7868" translate="yes" xml:space="preserve">
          <source>The application must finalize every &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in order to avoid resource leaks. It is a grievous error for the application to try to use a prepared statement after it has been finalized. Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99cabfda3eb8aea847c63c772b815f9008f98dc6" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e45e1c6c5dd0bb0af2de4709122fb9b7f5aa23a" translate="yes" xml:space="preserve">
          <source>The application must not close the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified by the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec93d570d3944810e00416d33fc158ef0b8df22" translate="yes" xml:space="preserve">
          <source>The application must not modify the SQL statement text passed into the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd08aa5c98a2b87e47c47375f85e57ce41e870bc" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04da8df88f025325ec4119082e7436a2ab79cfbf" translate="yes" xml:space="preserve">
          <source>The application must not read or write any part of a block of memory after it has been released using &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7136e470c61d513b5e2e7bb04278f687766f03e3" translate="yes" xml:space="preserve">
          <source>The application only has to load the data it needs, rather than reading the entire file and holding a complete parse in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e521cca41ad74c95daa61ed9901e7bb27bdf7838" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;../custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;../compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9522c8f8708f8f795d05750d26ac94e862ee81" translate="yes" xml:space="preserve">
          <source>The application should never invoke either sqlite3_os_init() or sqlite3_os_end() directly. The application should only invoke sqlite3_initialize() and sqlite3_shutdown(). The sqlite3_os_init() interface is called automatically by sqlite3_initialize() and sqlite3_os_end() is called by sqlite3_shutdown(). Appropriate implementations for sqlite3_os_init() and sqlite3_os_end() are built into SQLite when it is compiled for Unix, Windows, or OS/2. When &lt;a href=&quot;custombuild&quot;&gt;built for other platforms&lt;/a&gt; (using the &lt;a href=&quot;compile#os_other&quot;&gt;SQLITE_OS_OTHER=1&lt;/a&gt; compile-time option) the application must supply a suitable implementation for sqlite3_os_init() and sqlite3_os_end(). An application-supplied implementation of sqlite3_os_init() or sqlite3_os_end() must return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success and some other &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; upon failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371b08e858c1c9c61f57bffa9ac30d2c2c9616ae" translate="yes" xml:space="preserve">
          <source>The application wants to prevent other processes from accessing the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9edea5d79c9c534eb8f394ef49ec7d996e51c8" translate="yes" xml:space="preserve">
          <source>The application_id PRAGMA is used to query or set the 32-bit signed big-endian &quot;Application ID&quot; integer located at offset 68 into the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. Applications that use SQLite as their &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt; should set the Application ID integer to a unique integer so that utilities such as &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine the specific file type rather than just reporting &quot;SQLite3 Database&quot;. A list of assigned application IDs can be seen by consulting the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=magic.txt&quot;&gt;magic.txt&lt;/a&gt; file in the SQLite source repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbebe3f29ae821a203a540ede83fca7a51f6300e" translate="yes" xml:space="preserve">
          <source>The applications using this database are entitled to assume that for each row in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4abdec20da55bda36a7679394be4f500b633ccf" translate="yes" xml:space="preserve">
          <source>The argc parameter specifies the number of entries in the argv array. The value of argc will be 1 for a pure delete operation or N+2 for an insert or replace or update where N is the number of columns in the table. In the previous sentence, N includes any hidden columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66b85dc16bc6667c3624ba8e6f64b24df3ac149" translate="yes" xml:space="preserve">
          <source>The argument N is the maximum number of bytes of the database file that will be accessed using memory-mapped I/O. If N is zero then memory mapped I/O is disabled. If N is negative, then the limit reverts to the default value determined by the most recent &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;), or to the compile time default determined by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; if not start-time limit has been set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61127b621c6e57d8aaaae340d80e94025b5867" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in decimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c92aff7ca85efdc01cd4da9e4f23a18dad234e0" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in either normal decimal notation or if the exponent is not close to zero, in exponential notation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2096ff23b8873f39597795db4f99b816ed776fc9" translate="yes" xml:space="preserve">
          <source>The argument is a double which is displayed in exponential notation. The exponent character is 'e' or 'E' depending on the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11129b8da0d471f1bf24142ea87e57c0024e71a8" translate="yes" xml:space="preserve">
          <source>The argument is a pointer to an integer. Nothing is displayed for this substitution type. Instead, the integer to which the argument points is overwritten with the number of characters in the generated string that result from all format symbols to the left of the %n.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6906c7030bdaf7b36a456360b0fbb4934d1a4ca" translate="yes" xml:space="preserve">
          <source>The argument is a pointer which is displayed as a hexadecimal address. Since the SQL language has no concept of a pointer, the %p substitution for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; works like %x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27c7fe9a83c9f08bcef3b205174fd7f4958e0c9" translate="yes" xml:space="preserve">
          <source>The argument is a signed integer which is displayed in decimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b566b967632a4d496722ab350e0797c5b50a8e6" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string that is displayed. For the %z type in C-language interfaces, &lt;a href=&quot;c3ref/free&quot; id=&quot;percentz&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on the string after it has be copied into the output. The %s and %z substitutions are identical for the SQL printf() function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbbea9fc49916ff3eab8108379983087fe602ea" translate="yes" xml:space="preserve">
          <source>The argument is a zero-terminated string. The string is printed with all single quote (') characters doubled so that the string can safely appear inside an SQL string literal. The %Q substitution type also puts single-quotes on both ends of the substituted string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7cdf0497339bca82de3b36c80d3d61e29bc5c49" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in hexadecimal. Lower-case hexadecimal is used for %x and upper-case is used for %X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8fcc09e116d95e79ec104c4fc555cc628b5c95b" translate="yes" xml:space="preserve">
          <source>The argument is an integer which is displayed in octal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544017bf0d02198d9d372e60ce173d51892cc644" translate="yes" xml:space="preserve">
          <source>The argument is an unsigned integer which is displayed in decimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c161c084d3e3e79567bd33437dedcb35b7796bf" translate="yes" xml:space="preserve">
          <source>The argument is the symbolic name for the desired VFS. If the argument is a NULL pointer, then the default VFS is returned. The function returns a pointer to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object that implements the VFS. Or it returns a NULL pointer if no object could be found that matched the search criteria.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850af1642ffa208db124c3d32de875df305d3783" translate="yes" xml:space="preserve">
          <source>The argument to INTO can be a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; if URI filenames are enabled. URL filenames are enabled if any of the following are true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b032a307670cabd16d781ba02c89e270db9d32d" translate="yes" xml:space="preserve">
          <source>The argument to the timeout method is the maximum number of milliseconds to wait for the lock to clear. So in the example above, the maximum delay would be 2 seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6304247ca5d53ec4d2f27644451268a5fc4c44d5" translate="yes" xml:space="preserve">
          <source>The arguments passed to the &quot;tokenchars=&quot; or &quot;separators=&quot; options are case-sensitive. In the example above, specifying that &quot;X&quot; is a separator character does not affect the way &quot;x&quot; is handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42ca2142ac7440fc4af993ad46bce7740b98121" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;b&gt;sqlite_busy_handler&lt;/b&gt; are the opaque structure returned from &lt;b&gt;sqlite_open&lt;/b&gt;, a pointer to the busy callback function, and a generic pointer that will be passed as the first argument to the busy callback. When SQLite invokes the busy callback, it sends it three arguments: the generic pointer that was passed in as the third argument to &lt;b&gt;sqlite_busy_handler&lt;/b&gt;, the name of the database table or index that the library is trying to access, and the number of times that the library has attempted to access the database table or index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa9f93d8e2b44eeb698d1ed1229d89e77acc71a" translate="yes" xml:space="preserve">
          <source>The argv[0] parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of a row in the virtual table to be deleted. If argv[0] is an SQL NULL, then no deletion occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f42e72810bd428d0a06485b57a23695591e88c" translate="yes" xml:space="preserve">
          <source>The argv[1] parameter is the rowid of a new row to be inserted into the virtual table. If argv[1] is an SQL NULL, then the implementation must choose a rowid for the newly inserted row. Subsequent argv[] entries contain values of the columns of the virtual table, in the order that the columns were declared. The number of columns will match the table declaration that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method made using the &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; call. All hidden columns are included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960c591f856ba7201455da5f944d6e4f1ebae33d" translate="yes" xml:space="preserve">
          <source>The arrows from the small circles labeled with &quot;*&quot; indicate the cost of running each loop with no dependencies. The outer loop must use this *-cost. Inner loops have the option of using the *-cost or a cost assuming one of the other terms is in an outer loop, whichever gives the best result. One can think of the *-costs as a short-hand notation indicating multiple arcs, one from each of the other nodes in the graph. The graph is therefore &quot;complete&quot;, meaning that there are arcs (some explicit and some implied) in both directions between every pair of nodes in the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a2923f627b3acd76aca2425895d68fa7fb43f5" translate="yes" xml:space="preserve">
          <source>The assert(X) macro is &lt;a href=&quot;https://en.wikipedia.org/wiki/Assert.h&quot;&gt;part of standard C&lt;/a&gt;, in the &amp;lt;assert.h&amp;gt; header file. SQLite adds three other assert()-like macros named NEVER(X), ALWAYS(X), and testcase(X).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da4f4835817f9b4a63cc18fb5421f7207d5d808" translate="yes" xml:space="preserve">
          <source>The asynchronous I/O VFS is registered (and unregistered) by calls to the API functions sqlite3async_initialize() and sqlite3async_shutdown(). See section &quot;Compilation and Usage&quot; below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535287426332e5a1ad8bec16b3d83b02751661a5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO VFS API is described in detail in comments in sqlite3async.h. Using the API usually consists of the following steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f2292b58193481d23d957b96b6816c332c0bd5" translate="yes" xml:space="preserve">
          <source>The asynchronous IO extension consists of a single file of C code (sqlite3async.c), and a header file (sqlite3async.h), located in the &lt;a href=&quot;http://www.sqlite.org/src/dir?name=ext/async&quot;&gt; &lt;code&gt;ext/async/&lt;/code&gt; subfolder&lt;/a&gt; of the SQLite source tree, that defines the C API used by applications to activate and control the modules functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3d3b11288ba36989fe692263c29b42026caa0f" translate="yes" xml:space="preserve">
          <source>The asynchronous SQLite is just a shade slower than MySQL on this test. (MySQL seems to be especially adept at INSERT...SELECT statements.) The PostgreSQL engine is still thrashing - most of the 61 seconds it used were spent waiting on disk I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f0791bf3a9c39b17b6897fd1eef3b3d7a8e21f" translate="yes" xml:space="preserve">
          <source>The atomic commit mechanism in SQLite has proven to be robust, but it can be circumvented by a sufficiently creative adversary or a sufficiently broken operating system implementation. This section describes a few of the ways in which an SQLite database might be corrupted by a power failure or system crash. (See also: &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt Your Database Files&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7497e373861cdeb1f861bd3cb7a15f476a8a4234" translate="yes" xml:space="preserve">
          <source>The author of Lemon and SQLite (Hipp) reports that his C programming skills were greatly enhanced by studying John Ousterhout's original source code to Tcl. Hipp discovered and studied Tcl in 1993. Lemon was written before then, and SQLite afterwards. There is a clear difference in the coding styles of these two products, with SQLite seeming to be cleaner, more readable, and easier to maintain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01615602e972abb3c5942edbe63b3d8efbfa2ac" translate="yes" xml:space="preserve">
          <source>The authority may be omitted, may be blank, or may be &quot;&lt;code&gt;localhost&lt;/code&gt;&quot;. Any other authority results in an error. Exception: If SQLite is compiled with &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; then any authority value other than &quot;localhost&quot; is passed through to the underlying operating system as a UNC filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="939e9fe5172b44eee1c6df02720143adc80675d6" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0b9544f8e0ba2efe9de0f3a90df70febb9c84b" translate="yes" xml:space="preserve">
          <source>The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861ac52bff28d8b37d00f46c9e8ab0bcdffeef17" translate="yes" xml:space="preserve">
          <source>The automatic indexing capability can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;automatic_index pragma&lt;/a&gt;. Automatic indexing is turned on by default, but this can be changed so that automatic indexing is off by default using the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. The ability to create automatic indices can be completely disabled by compiling with the &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea88f1175fb0f90865a8970907b5e05e253378e5" translate="yes" xml:space="preserve">
          <source>The avg() function returns the average value of all non-NULL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c29cb183c63bdd561faeb944d923a238a65c8f1b" translate="yes" xml:space="preserve">
          <source>The b-tree algorithm provides key/data storage with unique and ordered keys on page-oriented storage devices. For background information on b-trees, see Knuth, &lt;u&gt;The Art Of Computer Programming&lt;/u&gt;, Volume 3 &quot;Sorting and Searching&quot;, pages 471-479. Two kinds of b-trees are used by SQLite. The algorithm that Knuth calls &quot;B*-Tree&quot; stores all data in the leaves of the tree. SQLite calls this variety of b-tree a &quot;table b-tree&quot;. The algorithm that Knuth calls simply &quot;B-Tree&quot; stores both the key and the data together in both leaves and in interior pages. In the SQLite implementation, the original B-Tree algorithm stores keys only, omitting the data entirely, and is called an &quot;index b-tree&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8fb65a49101b4953ed3553fa6d2836b2742f88" translate="yes" xml:space="preserve">
          <source>The b-tree page header is 8 bytes in size for leaf pages and 12 bytes for interior pages. All multibyte values in the page header are big-endian. The b-tree page header is composed of the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cbe5b0fd4215124588bcf352c662cc2398e510" translate="yes" xml:space="preserve">
          <source>The backup API copies the content of one database into another. It is useful either for creating backups of databases or for copying in-memory databases to or from persistent files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf1eb05a922a766ec8d7dd18ed7d6f4aa38bd5f" translate="yes" xml:space="preserve">
          <source>The backupDb() function uses the sqlite3_backup_remaining() and sqlite3_backup_pagecount() functions to report its progress via the user-supplied xProgress() callback. Function sqlite3_backup_remaining() returns the number of pages left to copy and sqlite3_backup_pagecount() returns the total number of pages in the source database (in this case the database opened by pDb). So the percentage completion of the process may be calculated as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b553d2761ee3fe64acd25548c40d0f8e4d42c23" translate="yes" xml:space="preserve">
          <source>The base window may not specify a frame specification. The frame specification can only be given in the new window specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2a91b9a2da4a8d6526f62c2bd849ce606c97d4" translate="yes" xml:space="preserve">
          <source>The basic algorithm for computing the content of the recursive table is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc257445d9ceee252762e517b278c85329543c96" translate="yes" xml:space="preserve">
          <source>The basic principals described above apply to both ordinary rowid tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. The only difference is that the rowid column that serves as the key for tables and that appears as the right-most term in indexes is replaced by the PRIMARY KEY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07bf749b7aaedba2ca3c53251a2ebc2903cbff5d" translate="yes" xml:space="preserve">
          <source>The basic procedure above may modified by the following additional rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5580fafc283a76d74ea47e0554226ba42ea5bc40" translate="yes" xml:space="preserve">
          <source>The behavior implemented by the AUTOINCREMENT keyword is subtly different from the default behavior. With AUTOINCREMENT, rows with automatically selected ROWIDs are guaranteed to have ROWIDs that have never been used before by the same table in the same database. And the automatically generated ROWIDs are guaranteed to be monotonically increasing. These are important properties in certain applications. But if your application does not need these properties, you should probably stay with the default behavior since the use of AUTOINCREMENT requires additional work to be done as each row is inserted and thus causes INSERTs to run a little slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ddd9ac28fbcaf8f2c3233a5b531ac7ced77a80" translate="yes" xml:space="preserve">
          <source>The behavior of cache_size with a negative N was different prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16). In earlier versions, the number of pages in the cache was set to the absolute value of N.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478ce327d17671071ecdc539934c95e63faeda7c" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETAPPLY_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e75893c7d343c6a289f5aa0da4c1e36a51499e7" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_apply_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetapply_invert&quot;&gt;supported flags&lt;/a&gt; as the 9th parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b226ef505264d45ed6c9760d30054930a97eb46" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;#SQLITE_CHANGESETSTART_INVERT&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462fed9af71f32884c9943463dae76b5706b0104" translate="yes" xml:space="preserve">
          <source>The behavior of sqlite3changeset_start_v2() and its streaming equivalent may be modified by passing a combination of &lt;a href=&quot;c_changesetstart_invert&quot;&gt;supported flags&lt;/a&gt; as the 4th parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd600a43e57a68ed3c7e61e8926b28cfcf03236" translate="yes" xml:space="preserve">
          <source>The behaviour described above may be modified slightly by using the &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;read_uncommitted&lt;/a&gt; pragma to change the isolation level from serialized (the default), to read-uncommitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d91219df791273fdd065b20fbe3a1ddef8cd79ad" translate="yes" xml:space="preserve">
          <source>The behaviour of queries when a column-filter is specified both as part of the FTS query and by using a column as the LHS of a MATCH operator is slightly different. For a table with columns &quot;a&quot; and &quot;b&quot; and a query similar to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b74d0e5579c64699d464837588df4c3744c10fa" translate="yes" xml:space="preserve">
          <source>The best approach to make reliable backup copies of an SQLite database is to make use of the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt; that is part of the SQLite library. Failing that, it is safe to make a copy of an SQLite database file as long as there are no transactions in progress by any process. If the previous transaction failed, then it is important that any rollback journal (the &lt;code&gt;*-journal&lt;/code&gt; file) or write-ahead log (the &lt;code&gt;*-wal&lt;/code&gt; file) be copied together with the database file itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4c95bce459286798ea2a27bd9ecd8decb1253c" translate="yes" xml:space="preserve">
          <source>The best feature of SQL (in &lt;u&gt;all&lt;/u&gt; its implementations, not just SQLite) is that it is a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc958ef4fbaadd7154585494d4a1f0d8657cd355" translate="yes" xml:space="preserve">
          <source>The block above uses a shorthand form to create the foreign key constraint. Attaching a &quot;REFERENCES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be5a6e82c647cd58e78eb343df366b2a12164999" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the leaf node with the largest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8114ba8fdc8ebfe0e7461c055a0e2fd44faa8a98" translate="yes" xml:space="preserve">
          <source>The blockid that corresponds to the node with the smallest blockid that belongs to this segment b-tree. Or zero if the entire segment b-tree fits on the root node. If it exists, this node is always a leaf node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a2b7b8a28aace68acd7dc6116c16ed08d188be" translate="yes" xml:space="preserve">
          <source>The boolean identifiers TRUE and FALSE are usually just aliases for the integer values 1 and 0, respectively. However, if TRUE or FALSE occur on the right-hand side of an IS operator, then they form new unary postfix operators &quot;IS TRUE&quot; and &quot;IS FALSE&quot; which test the boolean value of the operand on the left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab234605422320bfe969b5533e06293770750e7" translate="yes" xml:space="preserve">
          <source>The boundary between a file format and an application format is fuzzy. This article calls JPEG a file format, but for an image editor, JPEG might be considered the application format. Much depends on context. For this article, let us say that a file format stores a single object and an application format stores many different objects and their relationships to one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47707c3fbd653507bcb6765a57019dc2e9df3e77" translate="yes" xml:space="preserve">
          <source>The boundary description &quot;0 PRECEDING&quot; always means the same thing as &quot;CURRENT ROW&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e8d52b8ac553953a11325088115a059c247d93" translate="yes" xml:space="preserve">
          <source>The build process makes extensive use of the &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;Tcl&lt;/a&gt; scripting language. You will need to have a copy of TCL installed in order for the make targets above to work. Easy-to-use installers can be obtained from &lt;a href=&quot;http://www.tcl-lang.org/&quot;&gt;http://www.tcl-lang.org/&lt;/a&gt;. Many unix workstations have Tcl installed by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9c97359a7945f825df70e8e7d3bf03b435fc83" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; have been enhanced so that they can be used in &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, and in the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, provided that they do not use the 'now', 'localtime', or 'utc' keywords. &lt;a href=&quot;deterministic#dtexception&quot;&gt;More information&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96663fb71968ae34b1131b3cb53ad7ba03319209" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite are a special case. These functions are usually considered deterministic. However, if these functions use the string &quot;now&quot; as the date, or if they use the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; or the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;utc modifier&lt;/a&gt;, then they are considered non-deterministic. Because the function inputs are not necessarily known until run-time, the date/time functions will throw an exception if they encounter any of the non-deterministic features in a context where only deterministic functions are allows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf744ca87e6c1a5f3b9a68b24961edea60809eb" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; of SQLite understand date/times in all of the formats above, and can freely change between them. Which format you use, is entirely up to your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5b38222ac4fb96f9a2b189215735dd804f8b2d" translate="yes" xml:space="preserve">
          <source>The built-in BINARY collation compares strings byte by byte using the memcmp() function from the standard C library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9d8615812e1b5dddaadf330db3704ed6104526" translate="yes" xml:space="preserve">
          <source>The built-in SQLite has compile-time options such as SQLITE_PRINTF_PRECISION_LIMIT that provide defense against denial-of-service attacks for application that expose the printf() functionality to untrusted users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ca16581ef8177476edac12f1cd562f40820547" translate="yes" xml:space="preserve">
          <source>The built-in Wagner edit-distance function with fixed weights can be replaced by the &lt;a href=&quot;spellfix1#editdist3&quot;&gt;editdist3()&lt;/a&gt; edit-distance function with application-defined weights and support for unicode, by specifying the &quot;edit_cost_table=</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919d1860b9bd16d4532d25388f1ffc8375baa209" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary function bm25() returns a real value indicating how well the current row matches the full-text query. The better the match, the numerically smaller the value returned. A query such as the following may be used to return matches in order from best to worst match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89afdc49975b5af95582dcbca838ad26684b8aa6" translate="yes" xml:space="preserve">
          <source>The built-in auxiliary functions provided as part of FTS5 are described in the following section. Applications may also implement &lt;a href=&quot;fts5#custom_auxiliary_functions&quot;&gt;custom auxiliary functions in C&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9249ce5cc7f5a31c9f40d1d2aedadc1d6c797929" translate="yes" xml:space="preserve">
          <source>The built-in functions used to implement LIKE and GLOB must not have been overloaded using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a23aa1a5c2e20f2c3c4ac966e9783cdfed04b2" translate="yes" xml:space="preserve">
          <source>The built-in memory allocators in SQLite also provide the following additional interfaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa083c0cbf6940d57170ea9aa2f51d37713e7a7" translate="yes" xml:space="preserve">
          <source>The built-in min() and max() functions now honor the difference between NUMERIC and TEXT datatypes. Formerly, min() and max() always assumed their arguments were of type NUMERIC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09829581870ec4ebe1c207006b15fd18f63554a5" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation does not handle posix positional referencing modifiers that allow the order of arguments to printf() to be different from the order of the %-substitutions. In the built-in printf(), the order of the arguments must exactly match the order of the %-substitutions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86ab3d5db7f0615044de9985403c55275e95eaf" translate="yes" xml:space="preserve">
          <source>The built-in printf() implementation uses extra code space (about 7800 bytes on GCC 5.4 with -Os).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68470e8ed26cf7ace0d2e09f00b9eab48903fc0b" translate="yes" xml:space="preserve">
          <source>The built-in tokenizers and auxiliary functions described in this document are all implemented using the publicly available API described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc396222878f092f3ee1e16fde31353451d89d0" translate="yes" xml:space="preserve">
          <source>The busy callback should not take any actions which modify the database connection that invoked the busy handler. In other words, the busy handler is not reentrant. Any such actions result in undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f573b1a486bc41f01b46a6d80d9ecec47641b0" translate="yes" xml:space="preserve">
          <source>The byte offset of the matching term within the column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbb76aa2fa15c5bd4f4468b266b4d77ab34c0a75" translate="yes" xml:space="preserve">
          <source>The bytecode engine begins execution on instruction number 0. Execution continues until a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction is seen, or until the program counter becomes greater than the address of last instruction, or until there is an error. When the bytecode engine halts, all memory that it allocated is released and all database cursors it may have had open are closed. If the execution stopped due to an error, any pending transactions are terminated and changes made to the database are rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6398c9082248055b1fbc77ff5022201f3b1441" translate="yes" xml:space="preserve">
          <source>The bytecode engine has no stack on which to store the return address of a subroutine. Return addresses must be stored in registers. Hence, bytecode subroutines are not reentrant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f086fcda9ebdf902655d03a38811e78fc96fb9" translate="yes" xml:space="preserve">
          <source>The bytecode engine is &lt;u&gt;not&lt;/u&gt; an API of SQLite. Details about the bytecode engine change from one release of SQLite to the next. Applications that use SQLite should not depend on any of the details found in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f39ef66488b6211208c988daf5ffcab23760705" translate="yes" xml:space="preserve">
          <source>The bytecode virtual machine is the heart of SQLite. Programmers who want to understand how SQLite operates internally must be familiar with the bytecode engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efeaf3fe17bdefca5b34d3df41725c68d1db2de0" translate="yes" xml:space="preserve">
          <source>The cFrom and cTo columns show edit transformation strings. Either or both columns may contain more than one character. Or either column (but not both) may hold an empty string. When cFrom is empty, that is the cost of inserting cTo. When cTo is empty, that is the cost of deleting cFrom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334e7f3d3c0f1d00666221b0f79b06086771f2a0" translate="yes" xml:space="preserve">
          <source>The cache must not perform any reference counting. A single call to xUnpin() unpins the page regardless of the number of prior calls to xFetch().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba91e47edf5c7de46f6d683125d4647799118c05" translate="yes" xml:space="preserve">
          <source>The cache query parameter determines if the new database is opened using &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; or with a private cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c24d3d1b52233a8d1d33d1521f0d40a35115941" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37b504a453065b9fe4d5c4bf29c4836a5d7646e" translate="yes" xml:space="preserve">
          <source>The cache sharing mode set by this interface effects all subsequent calls to &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;. Existing database connections continue use the sharing mode that was in effect at the time they were opened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e474b4529162f0cc96b1a00a4049ab5a12dcf32d" translate="yes" xml:space="preserve">
          <source>The cache-flush method &lt;a href=&quot;c3ref/finalize&quot;&gt;finalizes&lt;/a&gt; all prepared statements currently in the cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8d3b22c77f42c07d50a96703e45047516a539f" translate="yes" xml:space="preserve">
          <source>The cache_spill pragma enables or disables the ability of the pager to spill dirty cache pages to the database file in the middle of a transaction. Cache_spill is enabled by default and most applications should leave it that way as cache spilling is usually advantageous. However, a cache spill has the side-effect of acquiring an &lt;a href=&quot;lockingv3#excl_lock&quot;&gt;EXCLUSIVE lock&lt;/a&gt; on the database file. Hence, some applications that have large long-running transactions may want to disable cache spilling in order to prevent the application from acquiring an exclusive lock on the database until the moment that the transaction &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9721a1202302bdb3675cb33fdaf401b47649ef3f" translate="yes" xml:space="preserve">
          <source>The callback function is used to receive the results of a query. A prototype for the callback function is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce299de07269b78871b3c034bf37ba0c0271573" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f29aa702b9f0b66493dfb5e14c2df5fa8051eb" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_profile() is invoked as each SQL statement finishes. The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run. The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless. Future versions of SQLite might provide greater resolution on the profiler callback. Invoking either &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; or &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; will cancel the profile callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc8b0e0c1561082e8c35dc0acaf0338a474ad77" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce29a09fb52c337eecabbd8bc599ef45377bf00d" translate="yes" xml:space="preserve">
          <source>The callback function registered by sqlite3_trace() is invoked at various times when an SQL statement is being run by &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;. The sqlite3_trace() callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing. Additional sqlite3_trace() callbacks might occur as each triggered subprogram is entered. The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f2fd31e08bf7a8ddd0b8f8f2559aa236b781e8" translate="yes" xml:space="preserve">
          <source>The callback function should normally return 0. If the callback function returns non-zero, the query is immediately aborted and &lt;b&gt;sqlite_exec&lt;/b&gt; will return SQLITE_ABORT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2394e983e60bde9a89a8173fd3ab1cfc913e1dc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e115553094195c6d671fc1803e4945ba335eedc5" translate="yes" xml:space="preserve">
          <source>The callback function should normally return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If an error code is returned, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred. If the callback returns &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2c627a789615e3efe180bdedfefe32d9d62d76" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17f517957de57a117a3b4627294584d44e59419" translate="yes" xml:space="preserve">
          <source>The callback function should register the desired collation using &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;, &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation16()&lt;/a&gt;, or &lt;a href=&quot;create_collation&quot;&gt;sqlite3_create_collation_v2()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefabcb34707d427a36b9901ef209a203d46bf9f" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;../wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4a8d646e0cbd66ca6c45574aae0dd0351286a" translate="yes" xml:space="preserve">
          <source>The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; the database as required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="facad5f03164aa5e049b3e0fcdccc7d1ce7b086d" translate="yes" xml:space="preserve">
          <source>The callback is invoked every N virtual machine operations, where N is supplied as the second argument to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt;. The third and fourth arguments to &lt;b&gt;sqlite_progress_handler()&lt;/b&gt; are a pointer to the routine to be invoked and a void pointer to be passed as the first argument to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ae791199d0c0d2e25d25668478f3c97d6fcbcf" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;#sqlite3_wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95427739ef742c846008bdf4e9ade466f5ff0b68" translate="yes" xml:space="preserve">
          <source>The callback registered by this function replaces any existing callback registered using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;. Likewise, registering a callback using &lt;a href=&quot;wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; disables the automatic checkpoint mechanism configured by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af79ec8f0bec910d80bc717aab639238d9ea73fe" translate="yes" xml:space="preserve">
          <source>The caller could distinguish between this special &quot;DROP TABLE|INDEX&quot; case and other cases by using &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. When it is appropriate to call &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt;, the extended error code is SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the &quot;DROP TABLE|INDEX&quot; case, it is just plain SQLITE_LOCKED. Another solution might be to limit the number of times that any single query could be reattempted (to say 100). Although this might be less efficient than one might wish, the situation in question is not likely to occur often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f82dd9e0519120922fe3d796ee7df0852a43b3" translate="yes" xml:space="preserve">
          <source>The canonical FTS5 source code consists of a series of *.c and other files in the &quot;ext/fts5&quot; directory of the SQLite source tree. A build process reduces this to just two files - &quot;fts5.c&quot; and &quot;fts5.h&quot; - which may be used to build an SQLite loadable extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821b27603ed5a2bcfa634bb0e0d6241eee07c748" translate="yes" xml:space="preserve">
          <source>The carray() function can be used in the FROM clause of a query. For example, to query two entries from the OBJ table using rowids taken from a C-language array at address $PTR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44fb31ec0ece772e4bff94846b749fc144432db5" translate="yes" xml:space="preserve">
          <source>The carray() function is not compiled into SQLite by default. It is available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/carray.c&quot;&gt;ext/misc/carray.c&lt;/a&gt; source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="435764c5d08e172eacd91d4b4315996e3f48003b" translate="yes" xml:space="preserve">
          <source>The carray() function takes two or three arguments. The first argument is a pointer to an array. Since pointer values cannot be specified directly in SQL, the first argument must be a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; that is bound to a pointer value using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface using a pointer-type of &quot;carray&quot;. The second argument is the number of elements in the array. The optional third argument is a string that determines the datatype of the elements in the C-language array. Allowed values for the third argument are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b5d7c612b8b2127750760016443da99495e2ab" translate="yes" xml:space="preserve">
          <source>The casual reader is not expected to understand or remember any part of the list above. The point of this list is to demonstrate that the decision of whether or not to flatten a query is complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf344511369b084d726030fdafcea463d5dc468" translate="yes" xml:space="preserve">
          <source>The cell content area</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5d403004805e89c7f707b8add474e39df5ebd7" translate="yes" xml:space="preserve">
          <source>The cell pointer array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c56d9636275558f42c1d09a95b01d119d13bcb" translate="yes" xml:space="preserve">
          <source>The cell pointer array of a b-tree page immediately follows the b-tree page header. Let K be the number of cells on the btree. The cell pointer array consists of K 2-byte integer offsets to the cell contents. The cell pointers are arranged in key order with left-most cell (the cell with the smallest key) first and the right-most cell (the cell with the largest key) last.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1302721086a59f9c1c80a0439335aec4ebc89654" translate="yes" xml:space="preserve">
          <source>The cell_size_check pragma enables or disables additional sanity checking on database b-tree pages as they are initially read from disk. With cell size checking enabled, database corruption is detected earlier and is less likely to &quot;spread&quot;. However, there is a small performance hit for doing the extra checks and so cell size checking is turned off by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b13b4df554f0eca9f783dc081206c3c433b689" translate="yes" xml:space="preserve">
          <source>The cg_anno.tcl script removes extraneous details from the default cachegrind annotation output so that before-and-after reports can be compared using a side-by-side diff to view specific details of how a micro-optimization attempt affected performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc2d39d7bf4988a1e3259d80bd003ba0f7f2a24" translate="yes" xml:space="preserve">
          <source>The change is made by an SQL trigger or foreign key action instead of directly as a result of a users SQL statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b6de28efb13f598ab97e8c9b2ad359898d3863" translate="yes" xml:space="preserve">
          <source>The changes must consist of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operations only. CREATE and DROP operations are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204b32b2b5c56879d06b01e160a1a35686edf225" translate="yes" xml:space="preserve">
          <source>The changes to locking and concurrency control in SQLite version 3 also introduce some subtle changes in the way transactions work at the SQL language level. By default, SQLite version 3 operates in &lt;em&gt;autocommit&lt;/em&gt; mode. In autocommit mode, all changes to the database are committed as soon as all operations associated with the current database connection complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec4059d42e348f2d46482a218570373eadf5d72" translate="yes" xml:space="preserve">
          <source>The changes() function returns the number of database rows that were changed or inserted or deleted by the most recently completed INSERT, DELETE, or UPDATE statement, exclusive of statements in lower-level triggers. The changes() SQL function is a wrapper around the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; C/C++ function and hence follows the same rules for counting changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67c4e9392e6b6f9ae02f045b5dfeb70fe9c0330" translate="yes" xml:space="preserve">
          <source>The char(X1,X2,...,XN) function returns a string composed of characters having the unicode code point values of integers X1 through XN, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37f1486781d28feebc971db6315e3ab886799387" translate="yes" xml:space="preserve">
          <source>The chart below shows average time to read a blob directly from the filesystem versus the time needed to read the same blob from the SQLite database. The actual timings vary considerably from one system to another (the Ubuntu desktop is much faster than the Galaxy S3 phone, for example). This chart shows the ratio of the times needed to read blobs from a file divided by the time needed to from the database. The left-most column in the chart is the normalized time to read from the database, for reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11b1918c906d3777fe0d3b93cddb4875a03b224" translate="yes" xml:space="preserve">
          <source>The chart below shows data collected using &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; on five different systems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7328593ed0585c2ca2a1685910b260ca61685e5b" translate="yes" xml:space="preserve">
          <source>The chart below shows the relative size and performance for SQLite as of 2017-10-08 for various compilers and optimization settings as tested on Ubuntu 16.04.3 on x86_64. General observations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6947bf2e572c7854301cde9f7c5737935d4086" translate="yes" xml:space="preserve">
          <source>The chart shows that on Windows10, content can be read from the SQLite database about 5 times faster than it can be read directly from disk. On Android, SQLite is only about 35% faster than reading from disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b79be443470ce0f3ea4b17f53ee3e0a63d67172" translate="yes" xml:space="preserve">
          <source>The check-in has a &quot;trunk&quot; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b47a927090544c586621a60b2916e19fae4550" translate="yes" xml:space="preserve">
          <source>The check-in has a child that has a &quot;trunk&quot; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c61bcc8ce340ae3a9c5cbdd0d35b553d2386d8" translate="yes" xml:space="preserve">
          <source>The check-in has a parent that has a &quot;trunk&quot; tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b751a07c985fa86fe7c3c40b3bf6704b7852bcb1" translate="yes" xml:space="preserve">
          <source>The checksum algorithm only works for content which is a multiple of 8 bytes in length. In other words, if the inputs are x(0) through x(N) then N must be odd. The checksum algorithm is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9654e9833d2bad18eac61dc57f147c1ed15a761f" translate="yes" xml:space="preserve">
          <source>The checksum is an unsigned 32-bit integer computed as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="270f933e45ef3250cf9dcd69e18f5fd196bd90a0" translate="yes" xml:space="preserve">
          <source>The checksum is computed by interpreting the input as an even number of unsigned 32-bit integers: x(0) through x(N). The 32-bit integers are big-endian if the magic number in the first 4 bytes of the WAL header is 0x377f0683 and the integers are little-endian if the magic number is 0x377f0682. The checksum values are always stored in the frame header in a big-endian format regardless of which byte order is used to compute the checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc24b6f9af8e44f6ff2e41a4a1721f4bd21f35c7" translate="yes" xml:space="preserve">
          <source>The checksum value is used to guard against incomplete writes of a journal page record following a power failure. A different random nonce is used each time a transaction is started in order to minimize the risk that unwritten sectors might by chance contain data from the same page that was a part of prior journals. By changing the nonce for each transaction, stale data on disk will still generate an incorrect checksum and be detected with high probability. The checksum only uses a sparse sample of 32-bit words from the data record for performance reasons - design studies during the planning phases of SQLite 3.0.0 showed a significant performance hit in checksumming the entire page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3990c0ed7263ce684acb68c345cf784357432dbe" translate="yes" xml:space="preserve">
          <source>The checksum value written to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ac1ab95620d7ae472b49582dcc0e306b38c020" translate="yes" xml:space="preserve">
          <source>The checksum values in the final 8 bytes of the frame-header exactly match the checksum computed consecutively on the first 24 bytes of the WAL header and the first 8 bytes and the content of all frames up to and including the current frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5140842eec97f2402faa79d3b18bc3769b3084" translate="yes" xml:space="preserve">
          <source>The child table references the primary key of the parent without specifying the primary key columns and the number of primary key columns in the parent do not match the number of child key columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da194c4576594e7457a28ceeefa6139ab020edb1" translate="yes" xml:space="preserve">
          <source>The circumstances under which SQLite will enforce the soft heap limit may changes in future releases of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed6f77a1a12342f6f0e71580e9b4032c3ba5e49" translate="yes" xml:space="preserve">
          <source>The claim of the previous paragraph is extensively checked in the SQLite regression test suite using a special test harness that simulates the effects on a database file of operating system crashes and power failures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce6585a17c4368c809080175136a8937ad00861b" translate="yes" xml:space="preserve">
          <source>The coalesce() function returns a copy of its first non-NULL argument, or NULL if all arguments are NULL. Coalesce() must have at least 2 arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c2331fa2d3327c8c4beede4ed0b6e31a651048" translate="yes" xml:space="preserve">
          <source>The code above is for the general case. For the special case of an SQLite Archive that only stores uncompressed or uncompressible content (this might come up, for example, in an SQLite Archive that stores only JPEG, GIF, and/or PNG images) then the content can be inserted into and extracted from the database without using the sqlar_compress() and sqlar_uncompress() functions, and the sqlar.c extension is not required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb7b1d4fed609f9eafac0ed3cfa712e4a84c44c" translate="yes" xml:space="preserve">
          <source>The code appears stable so we are now calling it &quot;beta&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dcec88beb123f0b5fcd5b586036ea0a356cf753" translate="yes" xml:space="preserve">
          <source>The code audits used to ensure that memory allocation size computations do not overflow in SQLite are repeated prior to every SQLite release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a804ee343680af0bae1b47adaea7bd27c01026" translate="yes" xml:space="preserve">
          <source>The code for the swarmvtab virtual table is found in the ext/misc/unionvtab.c file of the main SQLite source tree. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="429be1d142052bd4928f94110562bdb201e97a74" translate="yes" xml:space="preserve">
          <source>The code for the zipfile module is found in the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/zipfile.c&quot;&gt;ext/misc/zipfile.c&lt;/a&gt; file of the &lt;a href=&quot;https://sqlite.org/src&quot;&gt;main SQLite source tree&lt;/a&gt;. It may be compiled into an SQLite &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; using a command like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f5bceb13445c13d968dff10e26983b65675c68" translate="yes" xml:space="preserve">
          <source>The code generated in this last example is the same as the previous except for the addition of two conditional jumps used to implement the extra WHERE and HAVING clauses. The WHERE clause is implemented by instructions 9 through 11 in the query loop. The HAVING clause is implemented by instruction 28 through 30 in the output loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecc7e2ea5797377ee55e53ff370e71d0a0432eb1" translate="yes" xml:space="preserve">
          <source>The code generated to implement this last query is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26011ad1079cb8255e24204fff9114945ad7804b" translate="yes" xml:space="preserve">
          <source>The code generator in SQLite processes compound SELECT statements using a recursive algorithm. In order to limit the size of the stack, we therefore limit the number of terms in a compound SELECT. The maximum number of terms is SQLITE_MAX_COMPOUND_SELECT which defaults to 500. We think this is a generous allotment since in practice we almost never see the number of terms in a compound select exceed single digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5ca134725357f1db49cf5e9aed85ae431b52f8" translate="yes" xml:space="preserve">
          <source>The code generator, and especially the logic in &lt;b&gt;where*.c&lt;/b&gt; and in &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, is sometimes called the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;. For any particular SQL statement, there might be hundreds, thousands, or millions of different algorithms to compute the answer. The query planner is an AI that strives to select the best algorithm from these millions of choices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e3614fe3c2a2058c86f93c8b850392e16eae8c" translate="yes" xml:space="preserve">
          <source>The code in &quot;fts5.c&quot; may then be compiled into a loadable extension or statically linked into an application as described in &lt;a href=&quot;loadext#build&quot;&gt;Compiling Loadable Extensions&lt;/a&gt;. There are two entry points defined, both of which do the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c15d2613b82ac42eff7d51f6a4257bfde77f5feb" translate="yes" xml:space="preserve">
          <source>The code in this article could be improved in at least two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d14a407fed1c180dec58abfdf7e1bfd2ff10aa" translate="yes" xml:space="preserve">
          <source>The code space used by the SQLite library depends on the target platform, the compiler, and optimization settings. These variables also affect performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4a1121bef63849753648d7ec67f82ac551ebbe" translate="yes" xml:space="preserve">
          <source>The colUsed field indicates which columns of the virtual table may be required by the current scan. Virtual table columns are numbered from zero in the order in which they appear within the CREATE TABLE statement passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62), the corresponding bit is set within the colUsed mask if the column may be required by SQLite. If the table has at least 64 columns and any column to the right of the first 63 is required, then bit 63 of colUsed is also set. In other words, column iCol may be required if the expression (colUsed &amp;amp; ((sqlite3_uint64)1 &amp;lt;&amp;lt; (iCol&amp;gt;=63 ? 63 : iCol))) evaluates to non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6add92b1a269fd1ee22788d7c2c68cbcfa3387" translate="yes" xml:space="preserve">
          <source>The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument. The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively. A collating function must always return the same answer given the same inputs. If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings. The collating function must obey the following properties for all strings A, B, and C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65d2bfaa5988de22a32b291f24dfa00da4fc2f70" translate="yes" xml:space="preserve">
          <source>The column is identified by the second, third and fourth parameters to this function. The second parameter is either the name of the database (i.e. &quot;main&quot;, &quot;temp&quot;, or an attached database) containing the specified table or NULL. If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7829593889659cca230ab3239645af748546a7d0" translate="yes" xml:space="preserve">
          <source>The column labels that appear on the first two lines of output can be turned on and off using the &quot;.header&quot; dot command. In the examples above, the column labels are on. To turn them off you could do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71d2d7e1bd431710201b6152bbbf86fa85eac1e5" translate="yes" xml:space="preserve">
          <source>The column may not have a PRIMARY KEY or UNIQUE constraint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d848b798067eee9317efc709f08dee3a25b0a8" translate="yes" xml:space="preserve">
          <source>The column may not have a default value of CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP, or an expression in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb879e73b7d88dc161320c793668864d27ae4e6" translate="yes" xml:space="preserve">
          <source>The column names and definitions for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16cccd51ed940f2dd9c18cb3d4d9b130c9ecd9e" translate="yes" xml:space="preserve">
          <source>The column names for the result sets of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements have been tweaked in some cases to work more like other SQL database engines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239fe7786e783e697b78c9df7c06b9daecb4d9f7" translate="yes" xml:space="preserve">
          <source>The column names of the virtual table are determined primarily by the &lt;b&gt;schema=&lt;/b&gt; argument. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted, but &lt;b&gt;header&lt;/b&gt; is true, then the values found in the first line of the CSV file become the column names. If the &lt;b&gt;schema=&lt;/b&gt; argument is omitted and &lt;b&gt;header&lt;/b&gt; is false, then the columns are named &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27cc219896194f2cbf6cb1853331dc30b6f1a32f" translate="yes" xml:space="preserve">
          <source>The column names reported by join subqueries have been modified slightly in order to work more like other database engines. Consider the following query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf988c97f1d408bf1402feb7e21744609abdb492" translate="yes" xml:space="preserve">
          <source>The column number (1 for the second leftmost column, etc.). This field is omitted for any term-offset list associated with column 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d64ee03e40c54227cba3f5e9c70df99b5d87845" translate="yes" xml:space="preserve">
          <source>The column number that the term instance occurs in (0 for the leftmost column of the FTS table, 1 for the next leftmost, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0d4c37f8f415ca48f1578c5fbfec2c6eeee2e7" translate="yes" xml:space="preserve">
          <source>The column-name list syntax was added in SQLite versions 3.9.0 (2015-10-14).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74b05d9163657d39d9cb9b3d5f80884cae70cb2c" translate="yes" xml:space="preserve">
          <source>The columns are provided by the SQLITE_STMT virtual table are summarized by the hypothetical CREATE TABLE statement show here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fc02c8d425b8c14b21527882dd349490360fd6" translate="yes" xml:space="preserve">
          <source>The columns referenced in the WHERE clause of a partial index can be any of the columns in the table, not just columns that happen to be indexed. However, it is very common for the WHERE clause expression of a partial index to be a simple expression on the column being indexed. The following is a typical example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36ceb732928b62fa9f17cf0516fa8ff6f38d20c" translate="yes" xml:space="preserve">
          <source>The command above created the new branch. But your checkout is still on the trunk - a fact you can see by running the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e91ef2d072dfac6ebe4c80889ed64220c2f4b1" translate="yes" xml:space="preserve">
          <source>The command above will make a copy of the complete development history of SQLite into the &quot;sqlite.fossil&quot; file on your computer. Making this copy takes about a minute and uses about 32 megabytes of transfer. After making the copy, &quot;open&quot; the repository by typing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3dc1d8af5139eaa56167ba29f9c2c18e9d510c" translate="yes" xml:space="preserve">
          <source>The command above writes the output of the query as CSV into a temporary file, invokes the default handler for CSV files (usually the preferred spreadsheet program such as Excel or LibreOffice), then deletes the temporary file. This is essentially a short-hand method of doing the sequence of &quot;.csv&quot;, &quot;.once&quot;, and &quot;.system&quot; commands described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b075c13635ba5e790ee4582ea35e32db5040da00" translate="yes" xml:space="preserve">
          <source>The command returns a new TCL channel for reading or writing to the BLOB. The channel is opened using the underlying &lt;a href=&quot;c3ref/blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; C-language interface. Close the channel using the &lt;b&gt;close&lt;/b&gt; command of TCL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a64c0d6110f60679f08571c4a254a77214045a1" translate="yes" xml:space="preserve">
          <source>The command-line shell adds two &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that facilitate reading content from a file into a table column, and writing the content of a column into a file, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d792fd30ad98774099bd3871331d49c13f01ab7" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837a3144fbcca3d5f0e20f9cd17c26bc03114566" translate="yes" xml:space="preserve">
          <source>The commit and rollback hook callbacks are not reentrant. The callback implementation must not do anything that will modify the database connection that invoked the callback. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the commit or rollback hook in the first place. Note that running any other SQL statements, including SELECT statements, or merely calling &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will modify the database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5854e2359472df03b69e7808b8ee34022d4a6816" translate="yes" xml:space="preserve">
          <source>The commit process shown in &lt;a href=&quot;#section_3_0&quot;&gt;section 3.0&lt;/a&gt; assumes that all database changes fit in memory until it is time to commit. This is the common case. But sometimes a larger change will overflow the user-space cache prior to transaction commit. In those cases, the cache must spill to the database before the transaction is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831de8c9305e21ddee6326436c38620139c51d57" translate="yes" xml:space="preserve">
          <source>The common table expression works without having to load an extension. On the other hand, the extension is easier to program and faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="975322957294bcdde1991bc8533b4c3c42c34fe5" translate="yes" xml:space="preserve">
          <source>The comparison is a sort comparison, so NULLs compare equal, NULLs are less than numbers, numbers are less than strings, and strings are less than blobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77fdffaa220770108e157d8f6fdf86e8984310f3" translate="yes" xml:space="preserve">
          <source>The compilation step shown immediately above is merely representative. In a working installation, one would normally want to specify optimization parameters and compile-time switches on the compiler command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06859965a5874b48e17ef99de2638103b952d1aa" translate="yes" xml:space="preserve">
          <source>The compile-time options for setting upper bounds are &lt;a href=&quot;limits&quot;&gt;documented separately&lt;/a&gt;. The following is a list of the available settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37610227543b6269c9a6c07ddb9c1381df5a58a" translate="yes" xml:space="preserve">
          <source>The complete state of an SQLite database is usually contained in a single file on disk called the &quot;main database file&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bf44cd55dc348e4e3f4d568f7843d225f7562d" translate="yes" xml:space="preserve">
          <source>The completion table is designed for interactive use. It will return answers at a speed appropriate for human typing. No effort is made to be unusually efficient, so long as the response time is nearly instantaneous in a user interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59eec775be7e50d6274c344c801f729c91ab804" translate="yes" xml:space="preserve">
          <source>The completion table is used to implement tab-completion in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; in conjunction with either the readline or linenoise input line editing packages for unix. See the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;https://sqlite.org/src/file/src/shell.c.in&lt;/a&gt; source file for example code. Search for &quot;FROM completion&quot; to find the relevant code sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e034c5722458a4ef5f557863bb00dfc415febe07" translate="yes" xml:space="preserve">
          <source>The completion table might return the same candidate more than once, and it will return candidates in an arbitrary order. The DISTINCT keyword and the ORDER BY in the sample query above are added to make the answers unique and in lexicographical order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf1657f4892b438bb6c981746dfe40cd870c0fa" translate="yes" xml:space="preserve">
          <source>The complexity of Git distracts attention from the software under development. A user of Git needs to keep all of the following in mind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15376f7aadf15df031fa31738229dcbaf3f18c9d" translate="yes" xml:space="preserve">
          <source>The compound SELECT operators UNION, INTERSECT and EXCEPT perform implicit comparisons between values. No affinity is applied to comparison operands for the implicit comparisons associated with UNION, INTERSECT, or EXCEPT - the values are compared as is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc11a925c84e89a2d79f62896a81bbc87b31205f" translate="yes" xml:space="preserve">
          <source>The compress and uncompress options allow FTS4 content to be stored in the database in a compressed form. Both options should be set to the name of an SQL scalar function registered using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; that accepts a single argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f77d8f289ab8ab189cc2f583f00d06f6f32d94d" translate="yes" xml:space="preserve">
          <source>The compress function should return a compressed version of the value passed to it as an argument. Each time data is written to the FTS4 table, each column value is passed to the compress function and the result value stored in the database. The compress function may return any type of SQLite value (blob, text, real, integer or null).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290b0a4fd26e950183bc56ef03571b78a9f077cd" translate="yes" xml:space="preserve">
          <source>The compress option is used to specify the compress function. It is an error to specify a compress function without also specifying an uncompress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5836c13f879c56ed967a4394bb1d7a4816e02cd2" translate="yes" xml:space="preserve">
          <source>The compress=, uncompress= and languageid= options are not available. There is as of yet no equivalent for their functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2469db0ecb30ed655de4891189661dea5b883567" translate="yes" xml:space="preserve">
          <source>The compression method used to compress the data (an integer). The value 0 indicates that the data is stored in the zip archive without compression. 8 means the raw deflate algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c682ba9f6178606617e01c8b48358fa9163f9c2c" translate="yes" xml:space="preserve">
          <source>The computation of local time depends heavily on the whim of politicians and is thus difficult to get correct for all locales. In this implementation, the standard C library function localtime_r() is used to assist in the calculation of local time. The localtime_r() C function normally only works for years between 1970 and 2037. For dates outside this range, SQLite attempts to map the year into an equivalent year within this range, do the calculation, then map the year back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c788bf48ee2358b78bb00bc56b593bb09c394d8" translate="yes" xml:space="preserve">
          <source>The configure script (on unix) automatically detects pread() and pwrite() and sets compile-time options to use those OS interfaces if they are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71509666058777b45e3ddaa4c2923ebc4c7fa2f" translate="yes" xml:space="preserve">
          <source>The configure-make works whether your are building from the canonical sources from the source tree, or from an amalgamated bundle. There are few dependencies. When building from canonical sources, a working &lt;a href=&quot;https://www.tcl.tk/man/tcl8.3/UserCmd/tclsh.htm&quot;&gt;tclsh&lt;/a&gt; is required. If using an amalgamation bundle, all the preprocessing work normally done by tclsh will have already been carried out and only normal build tools are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac9040eb64152e9af693ac6b3d6353d633a032f" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_DATA as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is present in the database, but one or more other (non primary-key) fields modified by the update do not contain the expected &quot;before&quot; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23fc4d91796bed566e82459162cebcab0cf84b45" translate="yes" xml:space="preserve">
          <source>The conflict handler is invoked with CHANGESET_NOTFOUND as the second argument when processing a DELETE or UPDATE change if a row with the required PRIMARY KEY fields is not present in the database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c661dc346561d136d5859295a5527b2af74324a7" translate="yes" xml:space="preserve">
          <source>The conflicting row in this case is the database row with the matching primary key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4298401952abf69332c686d0b1f446ca8e2e6344" translate="yes" xml:space="preserve">
          <source>The conflicting row, in this case, is the database row with the matching primary key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca62ceaf8e4848fb4512d05da76c6a9337ad0aa5" translate="yes" xml:space="preserve">
          <source>The connection checks if a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c42ad2c395427b5b34bc215df721de823e8688" translate="yes" xml:space="preserve">
          <source>The connection checks if the data in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed384d7e555153a17ceb13abbd6bca15763f13c" translate="yes" xml:space="preserve">
          <source>The content allows the text being indexed to be stored in a separate table distinct from the FTS4 table, or even outside of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbe292e23fdc57896771b367c267746f39de5b7" translate="yes" xml:space="preserve">
          <source>The content of P3 registers starting at register P2 form an unpacked index key. This opcode removes that entry from the index opened by cursor P1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53039aadd3f75ae33d382081b8b5f0e6fd60f4d6" translate="yes" xml:space="preserve">
          <source>The content of an R*Tree index is actually stored in three ordinary SQLite tables with names derived from the name of the R*Tree. These three tables are called &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;. This is their schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5b1eb070f31c8697b621bf1847b35fb7a8adaf" translate="yes" xml:space="preserve">
          <source>The content of each SQL table row is stored in the database file by first combining the values in the various columns into a byte array in the record format, then storing that byte array as the payload in an entry in the table b-tree. The order of values in the record is the same as the order of columns in the SQL table definition. When an SQL table includes an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column (which aliases the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;) then that column appears in the record as a NULL value. SQLite will always use the table b-tree key rather than the NULL value when referencing the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71920b63c9e6445164e490bc0f251a06d6bb693f" translate="yes" xml:space="preserve">
          <source>The content of each rollback journal is flushed to disk both before and after the master journal filename is written into the rollback journal header. It is important to do both of these flushes. Fortunately, the second flush is usually inexpensive since typically only a single page of the journal file (the first page) has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b372f8730aa69db1fd10c964b137259496c534" translate="yes" xml:space="preserve">
          <source>The content of each slide could still be stored as compressed XML. But now each page is stored separately. So when opening a new document, the application could simply run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef2de54ba7f62420a379fc46c4ab7cf3080ae413" translate="yes" xml:space="preserve">
          <source>The content of the statistics tables can be queried using &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; and can be changed using the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands. The &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command works on statistics tables as of SQLite version 3.7.9. (2011-11-01) The &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command does not work on statistics tables. Appropriate care should be used when changing the content of the statistics tables as invalid content can cause SQLite to select inefficient query plans. Generally speaking, one should not modify the content of the statistics tables by any mechanism other than invoking the ANALYZE command. See &quot;&lt;a href=&quot;optoverview#manctrl&quot;&gt;Manual Control Of Query Plans Using SQLITE_STAT Tables&lt;/a&gt;&quot; for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb0bc8e6cf7e707512464168a8333cd25f0f7228" translate="yes" xml:space="preserve">
          <source>The content option allows FTS4 to forego storing the text being indexed. The content option can be used in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fd4cd87f476ff7994844fe209f20e1e61a3e92" translate="yes" xml:space="preserve">
          <source>The content table may also be queried as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43da535bae3bfe186441cea4bad1d427988c63d1" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1fc4719b451a2f189cbf09b3af719ceaa1455fd" translate="yes" xml:space="preserve">
          <source>The contents of a changeset may be traversed using an iterator created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; API. A changeset may be applied to a database with a compatible schema using the &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17197a14b8f9ff583e2fbe7ec6a33d12aff2f981" translate="yes" xml:space="preserve">
          <source>The contents of an SQLite database file are formatted as a set of fixed size pages. See</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6741b03ffce89c3a2ca3addb1cadccc791915ce5" translate="yes" xml:space="preserve">
          <source>The contents of columns qualified with the UNINDEXED column option are not added to the FTS index. This means that for the purposes of MATCH queries and &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt;, the column contains no matchable tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4381b2c97365bdc1448864c183789c2d75a4c76" translate="yes" xml:space="preserve">
          <source>The contents of the logical full-text index is found by merging the contents of all segment b-trees. If a term is present in more than one segment b-tree, then it maps to the union of each individual doclist. If, for a single term, the same docid occurs in more than one doclist, then only the doclist that is part of the most recently created segment b-tree is considered valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603ef17ea7e8b979fdc97587b739002125ee3a17" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33c4566f4b0045dff066d31694e73d46d2bf6db" translate="yes" xml:space="preserve">
          <source>The contents of the sqlite3_pcache_methods2 structure are copied to an internal buffer by SQLite within the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;. Hence the application may discard the parameter after the call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e184948fbfc41a2f2c0c14809d37c70c80c03a2" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c0cad9919ee775dcafe683809a8efa13aeacfd" translate="yes" xml:space="preserve">
          <source>The context in which an SQL function executes is stored in an sqlite3_context object. A pointer to an sqlite3_context object is always first parameter to &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;. The application-defined SQL function implementation will pass this pointer through into calls to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result()&lt;/a&gt;, &lt;a href=&quot;aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt;, &lt;a href=&quot;user_data&quot;&gt;sqlite3_user_data()&lt;/a&gt;, &lt;a href=&quot;context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt;, &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_get_auxdata()&lt;/a&gt;, and/or &lt;a href=&quot;get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc88bed6dbd7abe62664d54e6bdaf4f83cf04fb" translate="yes" xml:space="preserve">
          <source>The copy is edited to change the branch instruction into either a no-op or an unconditional jump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1935e51d150180f58869cd5c4365f67de7c57a" translate="yes" xml:space="preserve">
          <source>The copy method implements similar functionality to the &lt;b&gt;.import&lt;/b&gt; SQLite shell command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d3c9b74d67dc166ca8e07aaa910e143f4d6cf96" translate="yes" xml:space="preserve">
          <source>The copy of sqlite3.s is assembled into sqlite3.o then linked again th3.o to generate the &quot;th3&quot; executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b047a98a10f78ed2613ab80ee6fd529ee912f70f" translate="yes" xml:space="preserve">
          <source>The core functions shown below are available by default. &lt;a href=&quot;lang_datefunc&quot;&gt;Date &amp;amp; Time functions&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt;, &lt;a href=&quot;windowfunctions#biwinfunc&quot;&gt;window functions&lt;/a&gt;, and &lt;a href=&quot;json1&quot;&gt;JSON functions&lt;/a&gt; are documented separately. An application may define additional functions written in C and added to the database engine using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7002ce76e139b64c91049472e1737291c84c664" translate="yes" xml:space="preserve">
          <source>The core idea is to create a special table (named &quot;UNDOLOG&quot; in the example) that holds information needed to undo/redo changes to the database. For each class (table) in the database that wants to participate in the undo/redo, triggers are created that cause entries to be made in the UNDOLOG table for each DELETE, INSERT, and UPDATE of the participating class. The UNDOLOG entries consist of ordinary SQL statements the can be played back to reverse the changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4619c14d9f61ffdd467d39188a12cbd3dab6b8b" translate="yes" xml:space="preserve">
          <source>The core of a SELECT statement is a &quot;simple SELECT&quot; shown by the &lt;a href=&quot;syntax/select-core&quot;&gt;select-core&lt;/a&gt; and &lt;a href=&quot;syntax/simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt; syntax diagrams below. In practice, most SELECT statements are simple SELECT statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202f127cc642aea639fbf4c524ee9db3a310c986" translate="yes" xml:space="preserve">
          <source>The core query used to generate the branch timeline is shown below. (Readers are not expected to understand the details of this query. Commentary will follow.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca59f51d09381d1b3447776404c915b9169882ab" translate="yes" xml:space="preserve">
          <source>The core string formatting routine is the sqlite3VXPrintf() function found in the &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; source file. All the various interfaces invoke (sometimes indirectly) this one core function. The sqlite3VXPrintf() function began as code written by the first author of SQLite (&lt;a href=&quot;https://sqlite.org/crew.html&quot;&gt;Hipp&lt;/a&gt;) when he was a graduate student a Duke University in the late 1980s. Hipp kept this printf() implementation in his personal toolbox until he started working on SQLite in 2000. The code was incorporated into the SQLite source tree on &lt;a href=&quot;https://sqlite.org/src/timeline?c=f9372072a6&quot;&gt;2000-10-08&lt;/a&gt; for SQLite version 1.0.9.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="093b78a42e1ecfed114ac694aeda4be18d47e5e9" translate="yes" xml:space="preserve">
          <source>The cost table can be named anything you want - it does not have to be called &quot;editcost&quot;. And the table can contain additional columns. The only requirement is that the table must contain the four columns show above, with exactly the names shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab3b915916ad100c2de3d193cbc3d8e54968ac9c" translate="yes" xml:space="preserve">
          <source>The costs are comprised of multiple numbers, not a single number as shown in the graph. SQLite computes several different estimated costs for each loop that apply at different times. For example, there is a &quot;setup&quot; cost that is incurred just once when the query starts. The setup cost is the cost of computing an &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; for a table that does not already have an index. Then there is the cost of running each step of the loop. Finally, there is an estimate of the number rows generated by the loop, which is information needed in estimating the costs of inner loops. Sorting costs may come into play if the query has an ORDER BY clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bc3b9522f26a7b0a814b17b06d2223be3c56f5" translate="yes" xml:space="preserve">
          <source>The count(X) function returns a count of the number of times that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3944d86225bf50f66350ca2264ab4a84abeb87d" translate="yes" xml:space="preserve">
          <source>The cov1 test set used to obtain 100% branch test coverage are only a subset of the tests currently implemented using TH3. New test modules are added on a regular basis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d677c2d682d4dade2e8fc2faf6167d79dbe61f08" translate="yes" xml:space="preserve">
          <source>The crash tests in SQLite have discovered a number of very subtle bugs (now fixed) in the recovery mechanism. Some of these bugs were very obscure and unlikely to have been found using only code inspection and analysis techniques. From this experience, the developers of SQLite feel confident that any other database system that does not use a similar crash test system likely contains undetected bugs that will lead to database corruption following a system crash or power failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ac0d26d4e9c7d412c89e095055cacaebdbb563" translate="yes" xml:space="preserve">
          <source>The cumulative distribution. Calculated as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3f4c9ed1a83693cad288a8dbbe975dd262d497" translate="yes" xml:space="preserve">
          <source>The current implementation of SQLite uses only loop joins. That is to say, joins are implemented as nested loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0595dd468ba4f2594b89c18514e0ce47ff0d0c46" translate="yes" xml:space="preserve">
          <source>The current implementation of this JSON library uses a recursive descent parser. In order to avoid using excess stack space, any JSON input that has more than 2000 levels of nesting is considered invalid. Limits on nesting depth are allowed for compatible implementations of JSON by &lt;a href=&quot;https://tools.ietf.org/html/rfc7159#section-9&quot;&gt;RFC-7159 section 9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1859423b8976d8bfae8dfc344c1935671c660093" translate="yes" xml:space="preserve">
          <source>The current implementation will only support a string or BLOB length up to 2&lt;small&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/small&gt;-1 or 2147483647. And some built-in functions such as hex() might fail well before that point. In security-sensitive applications it is best not to try to increase the maximum string and blob length. In fact, you might do well to lower the maximum string and blob length to something more in the range of a few million if that is possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce671671108a214d3061700585cfbe08230e46de" translate="yes" xml:space="preserve">
          <source>The current row. For RANGE and GROUPS frame types, peers of the current row are also included in the frame, unless specifically excluded by the EXCLUDE clause. This is true regardless of whether CURRENT ROW is used as the starting or ending frame boundary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2930f3fd3f6f19fc9ada96c54055098b67532e" translate="yes" xml:space="preserve">
          <source>The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr. If the resetFlg is true, then the highest instantaneous value is reset back down to the current value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c10a59b750c785e72b4dc21d7b05d270490210" translate="yes" xml:space="preserve">
          <source>The current working directory (&quot;.&quot;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c8be248703e890d36c7a3af0b628d68ce8275b" translate="yes" xml:space="preserve">
          <source>The current writer concludes its transaction, OR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d429ef679ef6041cdac168ab25fbc584b8f7c9d4" translate="yes" xml:space="preserve">
          <source>The cycle above can be repeated many times. The diagram shows a third SQLite release, 3.6.17 in circle (6). The private branch maintainer can do another merge in order to incorporate the changes moving from (4) to (6) into the private branch, resulting in version (7).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8810808ac8350e84a24599fba1a1c44e6d0fc9da" translate="yes" xml:space="preserve">
          <source>The cycle counts provided by cachegrind are a good proxy for actual performance, but they are not 100% accurate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac9319a6ade67af6ca8dc4d7c432433a5c8d584" translate="yes" xml:space="preserve">
          <source>The data and method columns may also be set as described for an INSERT above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062b3a0f8f6a4c6911f0379b0878b031acaf0a51" translate="yes" xml:space="preserve">
          <source>The data for a table b-tree leaf page and the key of an index b-tree page was characterized above as an arbitrary sequence of bytes. The prior discussion mentioned one key being less than another, but did not define what &quot;less than&quot; meant. The current section will address these omissions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c10539b9c59116b81ff7089713236e6e1327e8" translate="yes" xml:space="preserve">
          <source>The data for rowid tables is stored as a B-Tree structure containing one entry for each table row, using the rowid value as the key. This means that retrieving or sorting records by rowid is fast. Searching for a record with a specific rowid, or for all records with rowids within a specified range is around twice as fast as a similar search made by specifying any other PRIMARY KEY or indexed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8b09e33f29c0f7e2cdc53d761f0421d3f8a545" translate="yes" xml:space="preserve">
          <source>The data_% table must have all the same columns as the target table, plus one additional column named &quot;rbu_control&quot;. The data_% table should have no PRIMARY KEY or UNIQUE constraints, but each column should have the same type as the corresponding column in the target database. The rbu_control column should have no type at all. For example, if the target database contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17bee7a4a210b94f9cd35ef19e344d890d514950" translate="yes" xml:space="preserve">
          <source>The data_% tables may be created as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8fc42980131b74512111cf667ced537b6faec1f" translate="yes" xml:space="preserve">
          <source>The data_% tables themselves should have no PRIMARY KEY declarations. However, RBU is more efficient if reading the rows in from each data_% table in &quot;rowid&quot; order is roughly the same as reading them sorted by the PRIMARY KEY of the corresponding target database table. In other words, rows should be sorted using the destination table PRIMARY KEY fields before they are inserted into the data_% tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e861495335228dd9715b8957c822d148379befb" translate="yes" xml:space="preserve">
          <source>The data_ccc table may then be populated as normal with the updates intended for target database table ccc. The same updates will be read by RBU from the data0_ccc_fts view and applied to FTS table ccc_fts. Because &quot;data0_ccc_fts&quot; is smaller than &quot;data_ccc&quot;, the FTS table will be updated first, as required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a9df4aba808f0f7f287daab1202c053d1ad5c81" translate="yes" xml:space="preserve">
          <source>The database being vacuumed may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f84e31daf7f78443fa69ada7a9a8e535388ab9" translate="yes" xml:space="preserve">
          <source>The database connection can be changed between full and incremental autovacuum mode at any time. However, changing from &quot;none&quot; to &quot;full&quot; or &quot;incremental&quot; can only occur when the database is new (no tables have yet been created) or by running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. To change auto-vacuum modes, first use the auto_vacuum pragma to set the new desired mode, then invoke the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to reorganize the entire database file. To change from &quot;full&quot; or &quot;incremental&quot; back to &quot;none&quot; always requires running &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; even on an empty database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8669da1288d64c48a1d4da77efa2cfbe93e717" translate="yes" xml:space="preserve">
          <source>The database connection is opened using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17dc502f4a596e5beade9b059c41722a7380dd5f" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged for WAL mode. However, the WAL file and the &lt;a href=&quot;walformat#shm&quot;&gt;wal-index&lt;/a&gt; are new concepts and so older versions of SQLite will not know how to recover a crashed SQLite database that was operating in WAL mode when the crash occurred. To prevent older versions of SQLite (prior to version 3.7.0, 2010-07-22) from trying to recover a WAL-mode database (and making matters worse) the database file format version numbers (bytes 18 and 19 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;) are increased from 1 to 2 in WAL mode. Thus, if an older version of SQLite attempts to connect to an SQLite database that is operating in WAL mode, it will report an error along the lines of &quot;file is encrypted or is not a database&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1329ad6c1d5d5a9b13da19601459b465ae67ba" translate="yes" xml:space="preserve">
          <source>The database file format is unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d07edfc3d0d439a4f2d02bad68d889bf985841b" translate="yes" xml:space="preserve">
          <source>The database file header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042540519692f217502c3ae945ec1187e2e057d0" translate="yes" xml:space="preserve">
          <source>The database file is synced to ensure that all updates are stored safely on the persistent media.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23d0cd874d4749bf56cbe1f6d077df68f5dc7f5" translate="yes" xml:space="preserve">
          <source>The database file is unlocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f5b1b36f625c53227300ca5232e63d1f84ef897" translate="yes" xml:space="preserve">
          <source>The database for TEMP tables is not created until it is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bdbc9610964d617ffff9c05691c3e95d705203e" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;#sqlite3_get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94abbac71c91061eed5db3642683f70b586a784a" translate="yes" xml:space="preserve">
          <source>The database handle must not be in &lt;a href=&quot;get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915d44defd987e4d007442eec15de7482af138fa" translate="yes" xml:space="preserve">
          <source>The database in which the new table is created. Tables may be created in the main database, the temp database, or in any attached database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11c35a2d4a1cdd518b7cc45f596b046478c935a" translate="yes" xml:space="preserve">
          <source>The database is modified by the transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca1bec50c05a4f92423e17a029876db2e2195fa" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing if possible, or reading only if the file is write protected by the operating system. In either case the database must already exist, otherwise an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd4a4b6de8565a3e1cf815b4bc5b9706070cf17" translate="yes" xml:space="preserve">
          <source>The database is opened for reading and writing, and is created if it does not already exist. This is the behavior that is always used for sqlite3_open() and sqlite3_open16().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33053c4558a1f3729067b3cae6e30d0b922d25b" translate="yes" xml:space="preserve">
          <source>The database is opened in read-only mode. If the database does not already exist, an error is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c36f905350b3694fef2e907f7076bd6c0eb07bcf" translate="yes" xml:space="preserve">
          <source>The database may be read but not written. Any number of processes can hold SHARED locks at the same time, hence there can be many simultaneous readers. But no other thread or process is allowed to write to the database file while one or more SHARED locks are active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc9e66b5c02e09e5ad16f7b64822b0c58495bb9" translate="yes" xml:space="preserve">
          <source>The database page size in bytes, or 1 if the page size is 65536.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5fb001456adc96d15706d6924ffd2f301ed99f" translate="yes" xml:space="preserve">
          <source>The database page size in bytes. Must be a power of two between 512 and 32768 inclusive, or the value 1 representing a page size of 65536.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960363c84d760f550ea9fae647b23fad91849f93" translate="yes" xml:space="preserve">
          <source>The database schema (in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table) is not normally included in the hash, but can be added by the &quot;--schema&quot; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8594a821095f6391744d60f5433b9311564cee65" translate="yes" xml:space="preserve">
          <source>The database text encoding. A value of 1 means UTF-8. A value of 2 means UTF-16le. A value of 3 means UTF-16be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8474bd3b47622066afeb4b46c5b6be93034d3e7c" translate="yes" xml:space="preserve">
          <source>The datatype of columns now appear in the 4th argument to the callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9bbe0be9ce7cff21329528d0726ee0baa77cf6" translate="yes" xml:space="preserve">
          <source>The date and time functions use a subset of &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;IS0-8601&lt;/a&gt; date and time formats. The date() function returns the date in this format: YYYY-MM-DD. The time() function returns the time as HH:MM:SS. The datetime() function returns &quot;YYYY-MM-DD HH:MM:SS&quot;. The julianday() function returns the &lt;a href=&quot;http://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day&lt;/a&gt; - the number of days since noon in Greenwich on November 24, 4714 B.C. (&lt;a href=&quot;http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar&quot;&gt;Proleptic Gregorian calendar&lt;/a&gt;). The strftime() routine returns the date formatted according to the format string specified as the first argument. The format string supports the most common substitutions found in the &lt;a href=&quot;http://opengroup.org/onlinepubs/007908799/xsh/strftime.html&quot;&gt;strftime() function&lt;/a&gt; from the standard C library plus two new substitutions, %f and %J. The following is a complete list of valid strftime() substitutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f51b9af9bc71b6bb1cc99119d6849c39b622ad" translate="yes" xml:space="preserve">
          <source>The db parameter is a pointer to the SQLite &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that is executing the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The pAux argument is the copy of the client data pointer that was the fourth argument to the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; call that registered the &lt;a href=&quot;c3ref/module&quot;&gt;virtual table module&lt;/a&gt;. The argv parameter is an array of argc pointers to null terminated strings. The first string, argv[0], is the name of the module being invoked. The module name is the name provided as the second argument to &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; and as the argument to the USING clause of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement that is running. The second, argv[1], is the name of the database in which the new virtual table is being created. The database name is &quot;main&quot; for the primary database, or &quot;temp&quot; for TEMP database, or the name given at the end of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The third element of the array, argv[2], is the name of the new virtual table, as specified following the TABLE keyword in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If present, the fourth and subsequent strings in the argv[] array report the arguments to the module name in the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f728f7217f7fc88bd0e8e8228a6a594400b21afc" translate="yes" xml:space="preserve">
          <source>The dbhash program is implemented by a single file of C-code called &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=tool/dbhash.c&quot;&gt;dbhash.c&lt;/a&gt;. To build the dbhash program manually, simply compile the dbhash.c source file and link it against the SQLite library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16703d23a9ca6a2a8cb4ca235cc87a944a6dff5" translate="yes" xml:space="preserve">
          <source>The dbhash.exe Utility Program</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce23c499eac5efbdaf2dbb036cb7b2ac9a155ffe" translate="yes" xml:space="preserve">
          <source>The dbsqlfuzz fuzzer mutates both the SQL input and the database file at the same time. Dbsqlfuzz uses a custom &lt;a href=&quot;https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md&quot;&gt;Structure-Aware Mutator&lt;/a&gt; on a specialized input file that defines both an input database and SQL text to be run against that database. Because it mutates both the input database and the input SQL at the same time, dbsqlfuzz has been able to find some obscure faults in SQLite that were missed by prior fuzzers that mutated only SQL inputs or only the database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bae73cc22154360311af38fab160d5138d312f9" translate="yes" xml:space="preserve">
          <source>The dbstat virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;, meaning that is not necessary to run &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; to create an instance of the dbstat virtual table before using it. The &quot;dbstat&quot; module name can be used as if it were a table name to query the dbstat virtual table directly. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcc1572318b12d880dcf6c5ba6e48d567425a65" translate="yes" xml:space="preserve">
          <source>The decision of whether to implement a FROM-clause subquery as a co-routine or using &lt;a href=&quot;optoverview#flattening&quot;&gt;query flattening&lt;/a&gt; now considers whether the result set of the outer query is &quot;complex&quot; (if it contains functions or expression subqueries). A complex result set biases the decision toward the use of co-routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab20325df0acc9b2aa5397a0a5067782536af164" translate="yes" xml:space="preserve">
          <source>The decision of which collating sequence to use is controlled by the COLLATE clause in SQL. A COLLATE clause can occur on a table definition, to define a default collating sequence to a table column, or on field of an index, or in the ORDER BY clause of a SELECT statement. Planned enhancements to SQLite are to include standard CAST() syntax to allow the collating sequence of an expression to be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e04830dfd2e28b2697cd44ccf76543eadbcceb" translate="yes" xml:space="preserve">
          <source>The declared type of each column in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68032822fa262cd72f80461a11d217079b712edb" translate="yes" xml:space="preserve">
          <source>The default 'crisismerge' value is 16. There is no maximum limit. Attempting to set the 'crisismerge' parameter to a value of 0 or 1 is equivalent to setting it to the default value (16). It is an error to attempt to set the 'crisismerge' option to a negative value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fcbed48c760da194eb2fb040297255b4fffa15" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; is changed from 1 to 4. This means that, unless the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format=ON&lt;/a&gt; statement is run, newly created database files will be unreadable by version of SQLite prior to 3.3.0 (2006-01-10). It also means that the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; are enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d41b5a0a8527b81ce581d5cb059a7a0ef7283f" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format number&lt;/a&gt; used by SQLite when creating new database files is set by this macro. The schema formats are all very similar. The difference between formats 1 and 4 is that format 4 understands &lt;a href=&quot;lang_createindex#descidx&quot;&gt;descending indices&lt;/a&gt; and has a tighter encoding for boolean values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0921362c7fa29bf8c96529653cba6ff2aa4225" translate="yes" xml:space="preserve">
          <source>The default MASK is and always shall be 0xfffe. The 0xfffe mask means perform all of the optimizations listed above except Debug Mode. If new optimizations are added in the future that should be off by default, those new optimizations will be given a mask of 0x10000 or larger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a903124a6abce3d6d4d4bbe7f6d1f8b599823062" translate="yes" xml:space="preserve">
          <source>The default VFS can be changed by registering or re-registering the VFS using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface with a second parameter of 1. Hence, if a (unix) process wants to always use the &quot;unix-nolock&quot; VFS in place of &quot;unix&quot;, the following code would work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a51f22fb2e29520e6fcdc862dfe6400d4b2d95" translate="yes" xml:space="preserve">
          <source>The default behavior for a loadable extension is that it is unloaded from process memory when the database connection that originally invoked &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; closes. (In other words, the xDlUnload method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object is called for all extensions when a database connection closes.) However, if the initialization procedure returns &lt;a href=&quot;rescode#ok_load_permanently&quot;&gt;SQLITE_OK_LOAD_PERMANENTLY&lt;/a&gt; instead of SQLITE_OK, then the extension will not be unloaded (xDlClose will not be invoked) and the extension will remain in process memory indefinitely. The SQLITE_OK_LOAD_PERMANENTLY return value is useful for extensions that want to register new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35fa7584b655adc25cbf99cb25271bb088b3504f" translate="yes" xml:space="preserve">
          <source>The default behavior gives this results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929789505d4e7daeec8d95f7bd37c902d7905d6b" translate="yes" xml:space="preserve">
          <source>The default behavior of assert(X) in standard C is that it is enabled for release builds. This is a reasonable default. However, the SQLite code base has many assert() statements in performance-sensitive areas of the code. Leaving assert(X) turned on causes SQLite to run about three times slower. Also, SQLite strives to provide 100% MC/DC in an as-delivered configuration, which is obviously impossible if assert(X) statements are enabled. For these reasons, assert(X) is a no-op for release builds in SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b3b8cc178a304f2169b7fe7ac799ae14ab4502" translate="yes" xml:space="preserve">
          <source>The default behavior of the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator is to ignore case for ASCII characters. Hence, by default &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is true. The case_sensitive_like pragma installs a new application-defined LIKE function that is either case sensitive or insensitive depending on the value of the case_sensitive_like pragma. When case_sensitive_like is disabled, the default LIKE behavior is expressed. When case_sensitive_like is enabled, case becomes significant. So, for example, &lt;b&gt;'a' LIKE 'A'&lt;/b&gt; is false but &lt;b&gt;'a' LIKE 'a'&lt;/b&gt; is still true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edad614da3d9aaf086c0a5c5b068d92a4f96481" translate="yes" xml:space="preserve">
          <source>The default builds for SQLite on Unix, Windows, and OS/2 include a VFS appropriate for the target platform. SQLite builds for other operating systems do not contain a VFS by default, but the application can register one or more at run-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a78f3c92a0ec476b159128dcf1aca02c9237966" translate="yes" xml:space="preserve">
          <source>The default busy callback is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a139fc5b0808f70ee2866da438ce9a4197bf896c" translate="yes" xml:space="preserve">
          <source>The default collating function for all strings is BINARY. Alternative collating functions for table columns can be specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement using the COLLATE clause on the &lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;column definition&lt;/a&gt;. When a column is indexed, the same collating function specified in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement is used for the column in the index, by default, though this can be overridden using a COLLATE clause in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4196a7b520d0708c2ca6c2f0dd09284b39f44638" translate="yes" xml:space="preserve">
          <source>The default configuration for SQLite works great for most applications. But sometimes developers want to tweak the setup to try to squeeze out a little more performance, or take advantage of some obscure feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f629fe0c846fce25506268b75e0f95dc1a4e2cd" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite assumes the underlying filesystem supports long filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ca0f7d70101ac90e64f7de1b18481b2e2650e6" translate="yes" xml:space="preserve">
          <source>The default configuration of SQLite only supports case-insensitive comparisons of ASCII characters. The reason for this is that doing full Unicode case-insensitive comparisons and case conversions requires tables and logic that would nearly double the size of the SQLite library. The SQLite developers reason that any application that needs full Unicode case support probably already has the necessary tables and functions and so SQLite should not take up space to duplicate this ability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23763d0cb18af4da83857106ae71fb287c36d2b" translate="yes" xml:space="preserve">
          <source>The default datatype is 'int32'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ca93f20ecfcb67f54da8e6ff374c396f410f8d" translate="yes" xml:space="preserve">
          <source>The default deletion cost</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348ca4d833d68a6b457e44e2f51c5dde36928e20" translate="yes" xml:space="preserve">
          <source>The default directory for temporary files depends on the OS. Some OS interfaces may choose to ignore this variable and place temporary files in some other directory different from the directory specified here. In that sense, this pragma is only advisory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a19fe31cacf32f0a49986af2b636abaafd7a24" translate="yes" xml:space="preserve">
          <source>The default encoding will be UTF-8 for databases created using sqlite3_open() or sqlite3_open_v2(). The default encoding for databases created using sqlite3_open16() will be UTF-16 in the native byte order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93b91496e8c579b792f6528c1582f57d8e5307a9" translate="yes" xml:space="preserve">
          <source>The default file format is now 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f52e2687ee82b720aa1390843c77644fb57108" translate="yes" xml:space="preserve">
          <source>The default file format is set by the &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; compile-time option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc414446f05fe3ef5190b22cd556bce2036d0102" translate="yes" xml:space="preserve">
          <source>The default frame-spec is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9df385f1bced3c35670bbdf7a0e4f5a1cfdb4ca" translate="yes" xml:space="preserve">
          <source>The default implementation stores all statistics in a single table named &quot;&lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;&quot;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option and without the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;. If SQLite is compiled with the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; option, then additional histogram data is collected and stored in &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt;. Older versions of SQLite would make use of the &lt;a href=&quot;fileformat2#stat2tab&quot;&gt;sqlite_stat2&lt;/a&gt; table when compiled with &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; but all recent versions of SQLite ignore the sqlite_stat2 table. Future enhancements may create additional &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal tables&lt;/a&gt; with the same name pattern except with final digit larger than &quot;4&quot;. All of these tables are collectively referred to as &quot;statistics tables&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c0ee558e2a1a06a318ed232e40e1c0e6d83d45" translate="yes" xml:space="preserve">
          <source>The default insertion cost</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b061817ffc2eb0f5dadec06f4e66f4f81231c2" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking, but there are other options. By selecting an alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface, an application can make use of other locking protocols that might be more appropriate to certain filesystems. For example, dot-file locking might be select for use in an application that has to run on an NFS filesystem that does not support POSIX advisory locking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9e0888f3707dfa1a041c24c2a5eb623fe8f593b" translate="yes" xml:space="preserve">
          <source>The default locking mechanism used by SQLite on unix platforms is POSIX advisory locking. Unfortunately, POSIX advisory locking has design quirks that make it prone to misuse and failure. In particular, any thread in the same process with a file descriptor that is holding a POSIX advisory lock can override that lock using a different file descriptor. One particularly pernicious problem is that the &lt;code&gt;close()&lt;/code&gt; system call will cancel all POSIX advisory locks on the same file for all threads and all file descriptors in the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdf451db4759c12771bfb1206d604a686ee94bb6" translate="yes" xml:space="preserve">
          <source>The default mapping of the rank column for a table may be modified using the &lt;a href=&quot;fts5#the_rank_configuration_option&quot;&gt;FTS5 rank configuration option&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676ab2fe4bf4ab903767c236b27e9b63051796ee" translate="yes" xml:space="preserve">
          <source>The default maximum trigger recursion depth is 1000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5421bb6c7fc35d245339e5557eb27520f8453d" translate="yes" xml:space="preserve">
          <source>The default means that aggregate window functions read all rows from the beginning of the partition up to and including the current row and its peers. This implies that rows that have the same values for all ORDER BY expressions will also have the same value for the result of the window function (as the window frame is the same). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d78a92ed9db0e9db8d034d6998442b87734337c" translate="yes" xml:space="preserve">
          <source>The default mechanism by which SQLite accesses and updates database disk files is the xRead() and xWrite() methods of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; VFS object. These methods are typically implemented as &quot;read()&quot; and &quot;write()&quot; system calls which cause the operating system to copy disk content between the kernel buffer cache and user space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af6b4fd5a17994d4af89bdbebf0e8f01053d45e7" translate="yes" xml:space="preserve">
          <source>The default memory allocation settings in SQLite are appropriate for most applications. However, applications with unusual or particularly strict requirements may want to adjust the configuration to more closely align SQLite to their needs. Both compile-time and start-time configuration options are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62759f30ef7e2768a0dc269d58d4f224a639e96a" translate="yes" xml:space="preserve">
          <source>The default memory allocator is recommended for most applications. If you do not have a compelling need to use an alternative memory allocator, then use the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfc21fe3a44b7df155912e662a52083d37f6130" translate="yes" xml:space="preserve">
          <source>The default method by which SQLite implements &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit and rollback&lt;/a&gt; is a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt;. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), a new &quot;Write-Ahead Log&quot; option (hereafter referred to as &quot;WAL&quot;) is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03533018c376c706c7055694a5695128f6d5dba9" translate="yes" xml:space="preserve">
          <source>The default mode is serialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91c1c07eac44347101354cb661e73cefc49a14a" translate="yes" xml:space="preserve">
          <source>The default numeric file permissions for newly created database files under unix. If not specified, the default is 0644 which means that the files is globally readable but only writable by the creator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b908d4b0d2fc05c9ddc3f95f430fcff134a8ed" translate="yes" xml:space="preserve">
          <source>The default operation of edit() is to invoke a text editor. But by using an alternative edit program in the second argument, you can also get it to edit images or other non-text resources. For example, if you want to modify a JPEG image that happens to be stored in a field of a table, you could run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e15d9f7898bd04fad7c8bec9316feb2b3c4d67cc" translate="yes" xml:space="preserve">
          <source>The default order of the nested loops in a join is for the left-most table in the FROM clause to form the outer loop and the right-most table to form the inner loop. However, SQLite will nest the loops in a different order if doing so will help it to select better indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60124ec3003cce0626fc7fdd9909bdc4316bd6f" translate="yes" xml:space="preserve">
          <source>The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cae14327c7d6852834539912db17ff8fae315187" translate="yes" xml:space="preserve">
          <source>The default output shows the beginning and end of each configuration and test module combination. In the example above &quot;c1&quot; and &quot;64k&quot; are configurations and &quot;pager08&quot;, &quot;build33&quot;, &quot;orderby01&quot;, etc. are test modules. Compile-time and run-time options are available to increase or decrease the amount of output. The output can be increased by showing each test case within each test module. The output can be decreased by degrees: omitting test modules starts and stops, omitting configuration starts and stops, and finally by omitting all output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fe79158a35398aa7562b0fca6f1415aa39b894" translate="yes" xml:space="preserve">
          <source>The default page cache implemention does not allocate the full amount of cache memory all at once. Cache memory is allocated in smaller chunks on an as-needed basis. The page_cache setting is a (suggested) upper bound on the amount of memory that the cache can use, not the amount of memory it will use all of the time. This is the behavior of the default page cache implementation, but an &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application defined page cache&lt;/a&gt; is free to behave differently if it wants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40256b332aa600059fdd4657f3e43acb14b4e3d" translate="yes" xml:space="preserve">
          <source>The default page cache strives more diligently to avoid using memory beyond what is allocated to it by &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. Or if using page cache is allocating from the heap, it strives to avoid going over the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt;, even if &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; is not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619cdf9a91dcb3b5377126d1f738a21802c8e3aa" translate="yes" xml:space="preserve">
          <source>The default page size on windows is automatically adjusted to match the capabilities of the underlying filesystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df04859a275716c6652a67712d525008dc797ebb" translate="yes" xml:space="preserve">
          <source>The default setting for SQLITE_MAX_COLUMN is 2000. You can change it at compile time to values as large as 32767. On the other hand, many experienced database designers will argue that a well-normalized database will never need more than 100 columns in a table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0506f7d82e65a6fef4e6e411dc34fd230ff22185" translate="yes" xml:space="preserve">
          <source>The default setting for auto-vacuum is 0 or &quot;none&quot;, unless the &lt;a href=&quot;compile#default_autovacuum&quot;&gt;SQLITE_DEFAULT_AUTOVACUUM&lt;/a&gt; compile-time option is used. The &quot;none&quot; setting means that auto-vacuum is disabled. When auto-vacuum is disabled and data is deleted data from a database, the database file remains the same size. Unused database file pages are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot; and reused for subsequent inserts. So no database file space is lost. However, the database file does not shrink. In this mode the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command can be used to rebuild the entire database file and thus reclaim unused disk space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de25e032063f16295b8e77c37d21842694e060fe" translate="yes" xml:space="preserve">
          <source>The default setting for the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; is 0, which means to following the recommendation of &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d111baa1a5224d066ace9e922bc0723387d0391f" translate="yes" xml:space="preserve">
          <source>The default setting for this pragma is OFF, which means that all references to the table anywhere in the schema are converted to the new name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5060b84cc58c53853f2caf81d58480c0590b9ac5" translate="yes" xml:space="preserve">
          <source>The default setting is 1. Additional information can be found in &lt;a href=&quot;tempfiles#tempstore&quot;&gt;tempfiles.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7fc079075b7fd84d6268869958a93f9d4d68c3" translate="yes" xml:space="preserve">
          <source>The default sorting procedure is to gather all information that will ultimately be output into a &quot;record&quot; and pass that complete record to the sorter. But in some cases, for example if some of the output columns consists of large BLOB values, the size of the each record can be large, which means that the sorter has to either use more memory, and/or write more content to temporary storage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4517865a59fec2a530bec6db77e7cd99eb8490" translate="yes" xml:space="preserve">
          <source>The default strategy is to allow successive write transactions to grow the WAL until the WAL becomes about 1000 pages in size, then to run a checkpoint operation for each subsequent COMMIT until the WAL is reset to be smaller than 1000 pages. By default, the checkpoint will be run automatically by the same thread that does the COMMIT that pushes the WAL over its size limit. This has the effect of causing most COMMIT operations to be very fast but an occasional COMMIT (those that trigger a checkpoint) to be much slower. If that effect is undesirable, then the application can disable automatic checkpointing and run the periodic checkpoints in a separate thread, or separate process. (Links to commands and interfaces to accomplish this are &lt;a href=&quot;#how_to_checkpoint&quot;&gt;shown below&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aba3882e935c491d72d10d266cb950c10ccee5f" translate="yes" xml:space="preserve">
          <source>The default substitution cost</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6947c6a992789a324c997f5478292dca047e240d" translate="yes" xml:space="preserve">
          <source>The default synchronous setting is full so the above is what usually happens. However, if the synchronous setting is lowered to &quot;normal&quot;, SQLite only flushes the rollback journal once, after the page count has been written. This carries a risk of corruption because it might happen that the modified (non-zero) page count reaches the disk surface before all of the data does. The data will have been written first, but SQLite assumes that the underlying filesystem can reorder write requests and that the page count can be burned into oxide first even though its write request occurred last. So as a second line of defense, SQLite also uses a 32-bit checksum on every page of data in the rollback journal. This checksum is evaluated for each page during rollback while rolling back a journal as described in &lt;a href=&quot;#section_4_4&quot;&gt;section 4.4&lt;/a&gt;. If an incorrect checksum is seen, the rollback is abandoned. Note that the checksum does not guarantee that the page data is correct since there is a small but finite probability that the checksum might be right even if the data is corrupt. But the checksum does at least make such an error unlikely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5887e5cef0e652ea249c383a61a9790399db5025" translate="yes" xml:space="preserve">
          <source>The default value for languageid is 0. If an alternative language is specified in WHERE clause constraints, then that alternative is used instead of 0. There can only be a single languageid per query. In other words, the WHERE clause cannot contain a range constraint or IN operator on the languageid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6f85ef321cfdfaecfbd8525333d39487f3c884" translate="yes" xml:space="preserve">
          <source>The default value of a languageid column is 0. Any value inserted into a languageid column is converted to a 32-bit (not 64) signed integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb45f8540234b96b45cb058d442c35d3ea03bfa" translate="yes" xml:space="preserve">
          <source>The default value of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter is 1, which means to store temporary files on disk but provide the option of overriding the behavior using the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aae70c9121f536fa334d3f452170e8968ea3458" translate="yes" xml:space="preserve">
          <source>The default value of the usermerge option is 4. The minimum allowed value is 2, and the maximum 16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6973079b710b23783ded0a80f07fc117f677c334" translate="yes" xml:space="preserve">
          <source>The default virtual table (&quot;rtree&quot;) normally stores coordinates as single-precision (4-byte) floating point numbers. If integer coordinates are desired, declare the table using &quot;rtree_i32&quot; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f282a44d7dfb6c6134a7e29df48c07aa44737ff7" translate="yes" xml:space="preserve">
          <source>The demonstration code assumes that the SQLite database is opened used as a database object named &quot;db&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8837968f443dfe5005184f2c6a7e1c74103e5e88" translate="yes" xml:space="preserve">
          <source>The demonstration code below includes a status_refresh method that grays-out or activates the Undo and Redo buttons and menu entries depending on whether or not there is anything to be undone or redone. You will need to redefine this method to control the Undo and Redo buttons in your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e759858c504e056da064aff365282dc111db1fea" translate="yes" xml:space="preserve">
          <source>The depth of recursion for triggers has a hard upper limit set by the &lt;a href=&quot;limits#max_trigger_depth&quot;&gt;SQLITE_MAX_TRIGGER_DEPTH&lt;/a&gt; compile-time option and a run-time limit set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimittriggerdepth&quot;&gt;SQLITE_LIMIT_TRIGGER_DEPTH&lt;/a&gt;,...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40be115b96b882b5a59636c2c2b3cce3bdbb02d6" translate="yes" xml:space="preserve">
          <source>The descendants of OpenOffice tend to segfault more often than commercial competitors. Perhaps for this reason, the OpenOffice forks make periodic backups of their in-memory documents so that users do not lose all pending edits when the inevitable application crash does occur. This causes frustrating pauses in the application for the few seconds while each backup is being made. After restarting from a crash, the user is presented with a dialog box that walks them through the recovery process. Managing the crash recovery this way involves lots of extra application logic and is generally an annoyance to the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2b8799305e9ca9fdc0f3b11f07bd75b53378d6" translate="yes" xml:space="preserve">
          <source>The designed query interface is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d6b31a6dd13fa4a2b19e14c162e00851337050" translate="yes" xml:space="preserve">
          <source>The detail option may be set to &quot;full&quot; (the default value), &quot;column&quot; or &quot;none&quot;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de34563fa7a58730a8b8b8a025ab7bdcb0a2940" translate="yes" xml:space="preserve">
          <source>The details of optimizations performed by this pragma are expected to change and improve over time. Applications should anticipate that this pragma will perform new optimizations in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec6e7a356da9ba89cc679a27100e250b07d2b68" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66564cccde706fd2f76931336faa29d5380763d" translate="yes" xml:space="preserve">
          <source>The details of the behavior of the sqlite3_step() interface depend on whether the statement was prepared using the newer &quot;vX&quot; interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or the older legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;. The use of the new &quot;vX&quot; interface is recommended for new applications but the legacy interface will continue to be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cfb6e87da2bbb4d38b35a83664b9fdcddd81cb" translate="yes" xml:space="preserve">
          <source>The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice. Unlike most of the SQLite API, this function is not guaranteed to operate consistently from one release to the next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd71fb5d39136060492d732375a6fec71ebfc8ad" translate="yes" xml:space="preserve">
          <source>The developers are also on the lookout for new ways to optimize the commit mechanism. The current VFS implementations for Unix (Linux and Mac OS X) and Windows make pessimistic assumptions about the behavior of those systems. After consultation with experts on how these systems work, we might be able to relax some of the assumptions on these systems and allow them to run faster. In particular, we suspect that most modern filesystems exhibit the safe append property and that many of them might support atomic sector writes. But until this is known for certain, SQLite will take the conservative approach and assume the worst.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cba4f98976654b480368200cf64e4d7ca1caf336" translate="yes" xml:space="preserve">
          <source>The developers of SQLite are confident that it is robust in the face of power failures and system crashes because the automatic test procedures do extensive checks on the ability of SQLite to recover from simulated power loss. We call these the &quot;crash tests&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e3f42d8aa639c2f77c64f6029c9126e99e122e" translate="yes" xml:space="preserve">
          <source>The developers of SQLite have found that full coverage testing is an extremely effective method for locating and preventing bugs. Because every single branch instruction in SQLite core code is covered by test cases, the developers can be confident that changes made in one part of the code do not have unintended consequences in other parts of the code. The many new features and performance improvements that have been added to SQLite in recent years would not have been possible without the availability full-coverage testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e54cb667da50110192519bd611d69d7d2d59cd" translate="yes" xml:space="preserve">
          <source>The developers of SQLite intend to support the product through the year 2050. To this end, the source code is carefully documented to promote long-term maintainability. We prefer mature and stable over trendy and cutting-edge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1c82e2078fb346e28f27499859e5261dd7cb0d" translate="yes" xml:space="preserve">
          <source>The diagram above implies that SQLite computes all of the rowids first and then combines them with a union operation before starting to do rowid lookups on the original table. In reality, the rowid lookups are interspersed with rowid computations. SQLite uses one index at a time to find rowids while remembering which rowids it has seen before so as to avoid duplicates. That is just an implementation detail, though. The diagram, while not 100% accurate, provides a good overview of what is happening.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc06f8d8201603f348e84ed00b97e2bebb250253" translate="yes" xml:space="preserve">
          <source>The diagram at the right illustrates the concept. One begins with a standard SQLite release. For the sake of example, suppose that one intends to create a private branch off of SQLite version 3.6.15. In the diagram this is version (1). The maintainer makes an exact copy of the baseline SQLite into the branch space, shown as version (2). Note that (1) and (2) are exactly the same. Then the maintainer applies the private changes to version (2) resulting in version (3). In other words, version (3) is SQLite version 3.6.15 plus edits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b170d383461e4dd7d9f55e0934f811bdf7d240b" translate="yes" xml:space="preserve">
          <source>The difference between reading from the rank column and using the bm25() function directly within the query is only significant when sorting by the returned value. In this case, using &quot;rank&quot; is faster than using bm25().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6b573084b906296ca61d103b50efb82fd91899" translate="yes" xml:space="preserve">
          <source>The difference between this option and the 'automerge' option is that when the 'automerge' limit is reached FTS5 only begins to merge the b-trees together. Most of the work is performed as part of subsequent INSERT, UPDATE or DELETE operations. Whereas when the 'crisismerge' limit is reached, the offending b-trees are all merged immediately. This means that an INSERT, UPDATE or DELETE that triggers a crisis-merge may take a long time to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b73e10a6ce3d527b6333ec3f4b76095553830b9" translate="yes" xml:space="preserve">
          <source>The difference is that xConnect is called to establish a new connection to an existing virtual table whereas xCreate is called to create a new virtual table from scratch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f41e80a4cb41a6cee44f4eaec98226e9c29f84f" translate="yes" xml:space="preserve">
          <source>The differences between a patchset and a changeset are that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fa2acc79952a3a20f72fc7c3e0f092b1e96e820" translate="yes" xml:space="preserve">
          <source>The differences between an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; database and an &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; database is this: The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TEMP_DB&lt;/a&gt; is used for explicitly declared and named TEMP tables (using the CREATE TEMP TABLE syntax) or for named tables in a temporary database that is created by opening a database with a filename that is an empty string. An &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_TRANSIENT_DB&lt;/a&gt; holds a database table that SQLite creates automatically in order to evaluate a subquery or ORDER BY or GROUP BY clause. Both TEMP_DB and TRANSIENT_DB databases are private and are deleted automatically. TEMP_DB databases last for the duration of the database connection. TRANSIENT_DB databases last only for the duration of a single SQL statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea188c1a8a3d9f0d3afac3d8adfd72df27cd7aa2" translate="yes" xml:space="preserve">
          <source>The direct-to-disk writes are accomplished using fopen()/fwrite()/fclose(). By default, and in all the results shown below, the OS filesystem buffers are never flushed to persistent storage using fsync() or FlushFileBuffers(). In other words, there is no attempt to make the direct-to-disk writes transactional or power-safe. We found that invoking fsync() or FlushFileBuffers() on each file written causes direct-to-disk storage to be about 10 times or more slower than writes to SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480bdad0842ce92215a602c8e8a2e2ba5036d89a" translate="yes" xml:space="preserve">
          <source>The directory or folder in which temporary files are created is determined by the OS-specific &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c1fd9cf0b8fae2622f0a1831b48a0d95eaabc6" translate="yes" xml:space="preserve">
          <source>The directory set by &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt; or by the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e347995ace178c5b68534f7a6dde94c35392830" translate="yes" xml:space="preserve">
          <source>The directory used to hold temporary files on unix can now be set using the SQLITE_TMPDIR environment variable, which takes precedence over the TMPDIR environment variable. The &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable still has higher precedence than both environment variables, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081d4a11583041f4e8625a8cc56c88ce7150faa6" translate="yes" xml:space="preserve">
          <source>The docid value. The first entry in a doclist contains the literal docid value. The first field of each subsequent doclist entry contains the difference between the new docid and the previous one (always a positive number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49e2bf067b92acf951896b04368654ffcd3a3f99" translate="yes" xml:space="preserve">
          <source>The document only describes locking for the older rollback-mode transaction mechanism. Locking for the newer &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is described separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1297878fc527d5d7c17142be2f4f043e484d8aa6" translate="yes" xml:space="preserve">
          <source>The documentation is maintained in separate source repositories on those same servers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0017ab9193a6ed1029ad59fab58ce3ec88e592f" translate="yes" xml:space="preserve">
          <source>The documentation sources include documentation text and images with the scripts and makefile needed to construct the SQLite website documentation. This document is contained within the documentation sources. The document sources are kept in a separate repository distinct from the source code. The documentation sources repository is publicly readable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="278f1b137f0865ba684c7cde1fa14cf1c768e813" translate="yes" xml:space="preserve">
          <source>The documentation system automatically maintains a &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; of past releases, as well as a &lt;a href=&quot;changes&quot;&gt;complete list of SQLite releases&lt;/a&gt; with change summaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65988e654b808af94ee6da6f09345ac1241a1ac8" translate="yes" xml:space="preserve">
          <source>The dot-command must be entirely contained on a single input line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fcffd0a57b5ba6715e1715a67438a136bebf610" translate="yes" xml:space="preserve">
          <source>The dot-commands are interpreted by the sqlite3.exe command-line program, not by SQLite itself. So none of the dot-commands will work as an argument to SQLite interfaces like &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b101a4a2aed2c88c1089ef5e27eb7bd916289f" translate="yes" xml:space="preserve">
          <source>The downside of automatic incremental merging is that it makes every INSERT, UPDATE, and DELETE operation on an FTS3/4 table run a little slower, since extra time must be used to do the incremental merge. For maximum performance, it is recommended that applications disable automatic incremental merge and instead use the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;&quot;merge&quot; command&lt;/a&gt; in an idle process to keep the inverted indices well merged. But if the structure of an application does not easily allow for idle processes, the use of automatic incremental merge is a very reasonable fallback solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77ebced48dfa7e23a77c44a167057f7558d4f17" translate="yes" xml:space="preserve">
          <source>The downside of storing schema a text is that it can make the schema tricky to modify. And for that reason, the ALTER TABLE support in SQLite has traditionally lagged behind other SQL database engines that store their schemas as parsed system tables that are easier to modify.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
