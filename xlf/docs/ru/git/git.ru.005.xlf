<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="23b7a95dc6b5470754cb8fce020cce7d3aab1ac0" translate="yes" xml:space="preserve">
          <source>Due to the non-quarantine nature of the &lt;code&gt;fetch.fsckObjects&lt;/code&gt; implementation it cannot be relied upon to leave the object store clean like &lt;code&gt;receive.fsckObjects&lt;/code&gt; can.</source>
          <target state="translated">Из-за того, &lt;code&gt;fetch.fsckObjects&lt;/code&gt; реализация fetch.fsckObjects не является карантинной, нельзя полагаться на то, что хранилище объектов &lt;code&gt;receive.fsckObjects&lt;/code&gt; чистым, как это может сделать receive.fsckObjects .</target>
        </trans-unit>
        <trans-unit id="68e19d88dc6eefe7753376e94bb2d970e8771158" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Frontends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at checkpoint (or completion) the same path can also be safely given to --import-marks.</source>
          <target state="translated">По завершении выгружает внутреннюю таблицу меток в &amp;lt;файл&amp;gt;. Метки записываются по одной в строке как &lt;code&gt;:markid SHA-1&lt;/code&gt; . Фронтенды могут использовать этот файл для проверки импорта после того, как он был завершен, или для сохранения таблицы меток при инкрементальных запусках. Поскольку &amp;lt;file&amp;gt; открывается и усекается только в контрольной точке (или завершении), тот же путь можно безопасно передать параметру --import-mark.</target>
        </trans-unit>
        <trans-unit id="d5f9d9df34707e95a5d4be8e3705f8049d385295" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Only marks for revisions are dumped; marks for blobs are ignored. Backends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at completion, the same path can also be safely given to --import-marks. The file will not be written if no new object has been marked/exported.</source>
          <target state="translated">По завершении выгружает внутреннюю таблицу меток в &amp;lt;файл&amp;gt;. Метки записываются по одной в строке как &lt;code&gt;:markid SHA-1&lt;/code&gt; . Сбрасываются только отметки за ревизии; метки для капель игнорируются. Серверные ВМ могут использовать этот файл для проверки импорта после его завершения или для сохранения таблицы меток при инкрементальных запусках. Поскольку &amp;lt;file&amp;gt; открывается и обрезается только при завершении, тот же путь можно безопасно передать параметру --import-mark. Файл не будет записан, если новый объект не был отмечен / экспортирован.</target>
        </trans-unit>
        <trans-unit id="aec3ad9b971b7ff8255345b154c94258f560f0d2" translate="yes" xml:space="preserve">
          <source>During a merge, the working tree files are updated to reflect the result of the merge. Among the changes made to the common ancestor&amp;rsquo;s version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim. When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area.</source>
          <target state="translated">Во время слияния файлы рабочего дерева обновляются, чтобы отразить результат слияния. Среди изменений, внесенных в версию общего предка, неперекрывающиеся (то есть вы изменили область файла, а другая сторона оставила эту область нетронутой, или наоборот) дословно включаются в окончательный результат. Однако, когда обе стороны вносили изменения в одну и ту же область, Git не может случайным образом выбирать одну сторону над другой и просит вас разрешить это, оставив то, что обе стороны сделали с этой областью.</target>
        </trans-unit>
        <trans-unit id="d0b0f9a14f12b4d06a31ddb153754d3c653f1bb2" translate="yes" xml:space="preserve">
          <source>During fsck git may find issues with legacy data which wouldn&amp;rsquo;t be generated by current versions of git, and which wouldn&amp;rsquo;t be sent over the wire if &lt;code&gt;transfer.fsckObjects&lt;/code&gt; was set. This feature is intended to support working with legacy repositories containing such data.</source>
          <target state="translated">Во время fsck git может обнаружить проблемы с устаревшими данными, которые не будут генерироваться текущими версиями git и которые не будут отправлены по сети, если был установлен &lt;code&gt;transfer.fsckObjects&lt;/code&gt; . Эта функция предназначена для поддержки работы с устаревшими репозиториями, содержащими такие данные.</target>
        </trans-unit>
        <trans-unit id="0eedfc5c015b233e6082e4e46ded41bc5da25b25" translate="yes" xml:space="preserve">
          <source>During the merge, the index holds three versions of each file. Each of these three &quot;file stages&quot; represents a different version of the file:</source>
          <target state="translated">Во время слияния индекс содержит три версии каждого файла.Каждая из этих трех &quot;стадий файла&quot; представляет собой отдельную версию файла:</target>
        </trans-unit>
        <trans-unit id="338f11841fc746012903e84c16b88356c6508da5" translate="yes" xml:space="preserve">
          <source>During the normal execution of several Git commands, call-outs are made to optional scripts that allow a developer to add functionality or checking. Typically, the hooks allow for a command to be pre-verified and potentially aborted, and allow for a post-notification after the operation is done. The hook scripts are found in the &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; directory, and are enabled by simply removing the &lt;code&gt;.sample&lt;/code&gt; suffix from the filename. In earlier versions of Git you had to make them executable.</source>
          <target state="translated">Во время обычного выполнения нескольких команд Git в необязательные сценарии добавляются выноски, которые позволяют разработчику добавлять функциональные возможности или проверять. Как правило, хуки позволяют предварительно проверить команду и, возможно, прервать ее, а также позволяют получать пост-уведомление после завершения операции. Скрипты &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; находятся в каталоге $ GIT_DIR / hooks / и активируются простым удалением суффикса &lt;code&gt;.sample&lt;/code&gt; из имени файла. В более ранних версиях Git вам нужно было сделать их исполняемыми.</target>
        </trans-unit>
        <trans-unit id="0c9afe2970bcd3db38ea14d913886ce00bad52d6" translate="yes" xml:space="preserve">
          <source>E.g, &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; would show something like this:</source>
          <target state="translated">Например, &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; будет выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="f48496348ce670a87dfe7a89fce6efc7850de45b" translate="yes" xml:space="preserve">
          <source>EVENT Format</source>
          <target state="translated">формат EVENT</target>
        </trans-unit>
        <trans-unit id="6c7b6f5f1d21b52d57339a7396d0f52ff8e6b468" translate="yes" xml:space="preserve">
          <source>Each &quot;index&quot; entry has two bits worth of &quot;stage&quot; state. stage 0 is the normal one, and is the only one you&amp;rsquo;d see in any kind of normal use.</source>
          <target state="translated">Каждая &amp;laquo;индексная&amp;raquo; запись имеет два бита состояния &amp;laquo;стадии&amp;raquo;. стадия 0 является нормальной и единственной, которую вы можете встретить при любом обычном использовании.</target>
        </trans-unit>
        <trans-unit id="81f54a7f6a9b658757fad1b0dd5d1a9971c93ea4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;%feature&lt;/code&gt; hash element is a hash reference and has the following structure:</source>
          <target state="translated">Каждый &lt;code&gt;%feature&lt;/code&gt; хэша % feature является ссылкой на хэш и имеет следующую структуру:</target>
        </trans-unit>
        <trans-unit id="b26592933b83f1f492565be647afc2706b49b317" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;-p&lt;/code&gt; indicates the id of a parent commit object.</source>
          <target state="translated">Каждый &lt;code&gt;-p&lt;/code&gt; указывает идентификатор родительского объекта фиксации.</target>
        </trans-unit>
        <trans-unit id="e2a09fd45cc17448d565b97a290193dc0600d3ce" translate="yes" xml:space="preserve">
          <source>Each action is implemented as a subroutine, and must be present in %actions hash. Some actions are disabled by default, and must be turned on via feature mechanism. For example to enable &lt;code&gt;blame&lt;/code&gt; view add the following to gitweb configuration file:</source>
          <target state="translated">Каждое действие реализовано как подпрограмма и должно присутствовать в хэше% actions. Некоторые действия отключены по умолчанию и должны быть включены с помощью механизма функций. Например, чтобы включить просмотр &lt;code&gt;blame&lt;/code&gt; добавьте в файл конфигурации gitweb следующее:</target>
        </trans-unit>
        <trans-unit id="4a431caa46e2fb6d34e98615d6339148b9977f86" translate="yes" xml:space="preserve">
          <source>Each attribute can be in one of these states for a given path:</source>
          <target state="translated">Каждый атрибут может находиться в одном из этих состояний для заданного пути:</target>
        </trans-unit>
        <trans-unit id="80fa6b90c4af909cefe5f1fba5144ae109300923" translate="yes" xml:space="preserve">
          <source>Each blame entry always starts with a line of:</source>
          <target state="translated">Каждая запись об обвинении всегда начинается со строки:</target>
        </trans-unit>
        <trans-unit id="2235e2f29b242d64317e253060371b53dfcfe3a6" translate="yes" xml:space="preserve">
          <source>Each command for the &lt;code&gt;proc-receive&lt;/code&gt; hook may point to a pseudo-reference and always has a zero-old as its old-oid, while the &lt;code&gt;proc-receive&lt;/code&gt; hook may update an alternate reference and the alternate reference may exist already with a non-zero old-oid. For this case, this hook will use &quot;option&quot; directives to report extended attributes for the reference given by the leading &quot;ok&quot; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890525cbde82d7616c57fdec079512ee27038efd" translate="yes" xml:space="preserve">
          <source>Each commit imported by &lt;code&gt;git p4&lt;/code&gt; has a line at the end of the log message indicating the p4 depot location and change number. This line is used by later &lt;code&gt;git p4 sync&lt;/code&gt; operations to know which p4 changes are new.</source>
          <target state="translated">Каждая фиксация, импортированная &lt;code&gt;git p4&lt;/code&gt; , имеет строку в конце сообщения журнала, указывающую местоположение хранилища p4 и номер изменения. Эта строка используется более поздними операциями &lt;code&gt;git p4 sync&lt;/code&gt; чтобы узнать, какие изменения p4 являются новыми.</target>
        </trans-unit>
        <trans-unit id="0d7aba1c95771e1fa299e8f177a2cb8fdb72c0d3" translate="yes" xml:space="preserve">
          <source>Each event is a JSON-object containing multiple key/value pairs written as a single line and followed by a LF.</source>
          <target state="translated">Каждое событие представляет собой JSON-объект,содержащий несколько пар ключ/значение,записанных в виде одной строки,за которой следует LF.</target>
        </trans-unit>
        <trans-unit id="93024a055d9225f66feed1627e9698b1aeced23b" translate="yes" xml:space="preserve">
          <source>Each group of changes (called a &quot;hunk&quot;) in the textual diff output is prefixed with a line of the form:</source>
          <target state="translated">Каждая группа изменений (называемая &quot;hunk&quot;)в выводе текстового различия префиксована строкой формы:</target>
        </trans-unit>
        <trans-unit id="227cc42fafaaa73089d47f3a2585fc225301de56" translate="yes" xml:space="preserve">
          <source>Each helper is specified by a single string in the configuration variable &lt;code&gt;credential.helper&lt;/code&gt; (and others, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The string is transformed by Git into a command to be executed using these rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82afba91b0fbc1511d9d66475a7a1226634e3792" translate="yes" xml:space="preserve">
          <source>Each instruction has variable length. Instruction type is determined by the seventh bit of the first octet. The following diagrams follow the convention in RFC 1951 (Deflate compressed data format).</source>
          <target state="translated">Каждая инструкция имеет переменную длину.Тип инструкции определяется седьмым битом первого октета.Следующие диаграммы следуют условию RFC 1951 (Формат сжатых данных Deflate).</target>
        </trans-unit>
        <trans-unit id="e70c1e613f5f534aeea8db8eaf0d4059228f6833" translate="yes" xml:space="preserve">
          <source>Each line in &lt;code&gt;gitattributes&lt;/code&gt; file is of form:</source>
          <target state="translated">Каждая строка в файле &lt;code&gt;gitattributes&lt;/code&gt; имеет вид:</target>
        </trans-unit>
        <trans-unit id="1c072d6c2cdd76489a2967b2e7ee81381c672ff3" translate="yes" xml:space="preserve">
          <source>Each line in a &lt;code&gt;gitignore&lt;/code&gt; file specifies a pattern. When deciding whether to ignore a path, Git normally checks &lt;code&gt;gitignore&lt;/code&gt; patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):</source>
          <target state="translated">Каждая строка в файле &lt;code&gt;gitignore&lt;/code&gt; определяет шаблон. Решая, следует ли игнорировать путь, Git обычно проверяет шаблоны &lt;code&gt;gitignore&lt;/code&gt; из нескольких источников со следующим порядком приоритета, от самого высокого до самого низкого (в пределах одного уровня приоритета результат определяется последним совпадающим шаблоном):</target>
        </trans-unit>
        <trans-unit id="d043aa624315c625b39f19b7c5a71a08d0fbefd2" translate="yes" xml:space="preserve">
          <source>Each line of options has this format:</source>
          <target state="translated">Каждая строка опций имеет такой формат:</target>
        </trans-unit>
        <trans-unit id="ce263659ab1a0135f8fda2a68c8ecc96cb2e4b52" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, 'stage number', and the filename. The 'stage number' is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="translated">Каждая строка вывода &lt;code&gt;git ls-files --unmerged&lt;/code&gt; начинается с битов режима больших двоичных объектов, BLOB-объекта SHA-1, &amp;laquo;номера стадии&amp;raquo; и имени файла. &amp;laquo;Номер этапа&amp;raquo; - это способ Git сказать, из какого дерева он произошел: этап 1 соответствует дереву &lt;code&gt;$orig&lt;/code&gt; , этап 2 - дереву &lt;code&gt;HEAD&lt;/code&gt; , а этап 3 - дереву &lt;code&gt;$target&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e72e23a1ee3c2cf405696e86ad1ef3c4d6f422" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, &lt;code&gt;stage number&lt;/code&gt;, and the filename. The &lt;code&gt;stage number&lt;/code&gt; is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac1b4287ed9a44af81d40c798f15ea7666d1fc7e" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s $GIT_DIR/worktrees directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="translated">Каждое связанное рабочее дерево имеет личный подкаталог в каталоге репозитория $ GIT_DIR / worktrees. Имя частного подкаталога обычно является базовым именем пути связанного рабочего дерева, возможно, с добавленным числом, чтобы сделать его уникальным. Например, когда &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; команда &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; создает связанное рабочее дерево в &lt;code&gt;/path/other/test-next&lt;/code&gt; , а также создает &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; Каталог / test-next (или &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; если &lt;code&gt;test-next&lt;/code&gt; уже выполнен).</target>
        </trans-unit>
        <trans-unit id="08c05bcbce27635e929ab0aeef0154946c733deb" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e13434b85bdba9c36937ef9acd2f33c427adfe8" translate="yes" xml:space="preserve">
          <source>Each of the attribute requirements for the path takes one of these forms:</source>
          <target state="translated">Каждое из требований к атрибуту для пути принимает одну из этих форм:</target>
        </trans-unit>
        <trans-unit id="58398b8104bc9622bb9865f6e7c9793546a9471d" translate="yes" xml:space="preserve">
          <source>Each of the four branches is usually a direct descendant of the one above it.</source>
          <target state="translated">Каждая из четырех ветвей обычно является прямым потомком той,что находится над ней.</target>
        </trans-unit>
        <trans-unit id="dfc2dc1cc1f2e4f6e3d7ce6e6191c01415d0880b" translate="yes" xml:space="preserve">
          <source>Each of these options must appear first on the command line.</source>
          <target state="translated">Каждая из этих опций должна появиться первой в командной строке.</target>
        </trans-unit>
        <trans-unit id="79d9036a8f3f011f6caea432d8fa6198deb15d8c" translate="yes" xml:space="preserve">
          <source>Each other line contains a single pattern.</source>
          <target state="translated">Каждая вторая линия содержит единую деталь.</target>
        </trans-unit>
        <trans-unit id="36e6db0cb81d09d2c644d8a7c4b702648cc38f78" translate="yes" xml:space="preserve">
          <source>Each patch can be applied in order.</source>
          <target state="translated">Каждый патч может быть применен по порядку.</target>
        </trans-unit>
        <trans-unit id="6d39c2ae5926cd9b5a6631ab32e0430d3e598f09" translate="yes" xml:space="preserve">
          <source>Each patch includes a single logical change, together with a message explaining the change.</source>
          <target state="translated">Каждый патч включает в себя одно логическое изменение вместе с сообщением,объясняющим изменение.</target>
        </trans-unit>
        <trans-unit id="493d693b4f2b5ea37d0460dc9ff9f76e6d401041" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side.</source>
          <target state="translated">Каждая пара образцов состоит из стороны источника (перед двоеточием)и стороны назначения (после двоеточия).Ссылка,которую нужно толкнуть,определяется путем нахождения совпадения с исходной стороной,а место,куда ее нужно толкнуть,определяется с помощью целевой стороны.</target>
        </trans-unit>
        <trans-unit id="b313cea753099ce8f3968fb8a5c9e65e86c611ac" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side. The rules used to match a ref are the same rules used by &lt;code&gt;git rev-parse&lt;/code&gt; to resolve a symbolic ref name. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">Каждая пара шаблонов состоит из стороны источника (перед двоеточием) и стороны назначения (после двоеточия). Отправляемая ссылка определяется путем нахождения совпадения, которое соответствует исходной стороне, а место, куда она отправляется, определяется с помощью целевой стороны. Правила, используемые для сопоставления ссылки, - это те же правила, что и &lt;code&gt;git rev-parse&lt;/code&gt; для разрешения символьного имени ссылки. См. &lt;a href=&quot;git-rev-parse&quot;&gt;Git-rev-parse [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2aa7f4f33bfb7b26b4af691cb7e2c6d52612b8b" translate="yes" xml:space="preserve">
          <source>Each remote helper is expected to support only a subset of commands. The operations a helper supports are declared to Git in the response to the &lt;code&gt;capabilities&lt;/code&gt; command (see COMMANDS, below).</source>
          <target state="translated">Ожидается, что каждый удаленный помощник будет поддерживать только подмножество команд. Операции хелпер поддерживает объявленные в Git в ответ на &lt;code&gt;capabilities&lt;/code&gt; команды (см КОМАНДЫ, ниже).</target>
        </trans-unit>
        <trans-unit id="640db855296fc622a8934e713d8f1835acdff3f5" translate="yes" xml:space="preserve">
          <source>Each time a new shared index file is created, the old shared index files are deleted if their modification time is older than what is specified by the splitIndex.sharedIndexExpire config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Каждый раз, когда создается новый файл общего индекса, старые файлы общего индекса удаляются, если время их модификации старше, чем указано в переменной конфигурации splitIndex.sharedIndexExpire (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b67247d73793e579b74a9b09ccf935b5a398f89" translate="yes" xml:space="preserve">
          <source>Each time a superproject update moves a populated submodule (e.g. when switching between commits before and after the move) a stale submodule checkout will remain in the old location and an empty directory will appear in the new location. To populate the submodule again in the new location the user will have to run &quot;git submodule update&quot; afterwards. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. Both steps will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">Каждый раз,когда суперпроектное обновление перемещает заполненный субмодуль (например,при переключении между коммитами до и после перемещения),несвежий извлечённый субмодуль останется в старом месте,а в новом месте появится пустой каталог.Чтобы снова заполнить подмодуль в новом местоположении,пользователю придётся после этого выполнить &quot;обновление подмодуля git'а&quot;.Удаление старого каталога безопасно только при использовании git-файла,так как в противном случае история подмодуля тоже будет удалена.Оба шага будут устаревшими,когда будет реализовано рекурсивное обновление подмодуля.</target>
        </trans-unit>
        <trans-unit id="70398d4e57fc6de31488380bf7caac1138d58530" translate="yes" xml:space="preserve">
          <source>Each time a superproject update removes a populated submodule (e.g. when switching between commits before and after the removal) a stale submodule checkout will remain in the old location. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. This step will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">Каждый раз,когда суперпроектное обновление удаляет заполненный субмодуль (например,при переключении между коммитами до и после удаления),несвежий извлечённый субмодуль останется в старом месте.Удаление старого каталога безопасно только при использовании git-файла,так как в противном случае история подмодуля также будет удалена.Этот шаг будет устаревшим,когда будет реализовано рекурсивное обновление подмодуля.</target>
        </trans-unit>
        <trans-unit id="49035126eea24f612f322a34d235d8eeac55e17a" translate="yes" xml:space="preserve">
          <source>Each time you resolve the conflicts in a file and update the index:</source>
          <target state="translated">Каждый раз при разрешении конфликтов в файле и обновлении индекса:</target>
        </trans-unit>
        <trans-unit id="91df855bba63011edb2c56419d0fb8efa1e50e11" translate="yes" xml:space="preserve">
          <source>Earlier we said that trivial merges are done inside &lt;code&gt;git read-tree -m&lt;/code&gt;. For example, if the file did not change from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; or &lt;code&gt;$target&lt;/code&gt;, or if the file changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; the same way, obviously the final outcome is what is in &lt;code&gt;HEAD&lt;/code&gt;. What the above example shows is that file &lt;code&gt;hello.c&lt;/code&gt; was changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; in a different way. You could resolve this by running your favorite 3-way merge program, e.g. &lt;code&gt;diff3&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, or Git&amp;rsquo;s own merge-file, on the blob objects from these three stages yourself, like this:</source>
          <target state="translated">Ранее мы говорили, что тривиальные слияния выполняются внутри &lt;code&gt;git read-tree -m&lt;/code&gt; . Например, если файл не изменился с &lt;code&gt;$orig&lt;/code&gt; на &lt;code&gt;HEAD&lt;/code&gt; или &lt;code&gt;$target&lt;/code&gt; , или если файл изменился с &lt;code&gt;$orig&lt;/code&gt; на &lt;code&gt;HEAD&lt;/code&gt; и &lt;code&gt;$orig&lt;/code&gt; на &lt;code&gt;$target&lt;/code&gt; таким же образом, очевидно, что конечным результатом будет то, что находится в &lt;code&gt;HEAD&lt;/code&gt; . В приведенном выше примере показано, что файл &lt;code&gt;hello.c&lt;/code&gt; был изменен с &lt;code&gt;$orig&lt;/code&gt; на &lt;code&gt;HEAD&lt;/code&gt; и с &lt;code&gt;$orig&lt;/code&gt; на &lt;code&gt;$target&lt;/code&gt; другим способом. Вы можете решить эту проблему, запустив свою любимую программу трехстороннего слияния, например &lt;code&gt;diff3&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; или собственный файл слияния Git для объектов blob из этих трех этапов, например:</target>
        </trans-unit>
        <trans-unit id="cf0ee6adeaeadff98f7e216b0d8eb81b31226098" translate="yes" xml:space="preserve">
          <source>Earlier, we saw that one file under &lt;code&gt;.git/objects/??/&lt;/code&gt; directory is stored for each Git object you create. This representation is efficient to create atomically and safely, but not so convenient to transport over the network. Since Git objects are immutable once they are created, there is a way to optimize the storage by &quot;packing them together&quot;. The command</source>
          <target state="translated">Ранее мы видели, что один файл в каталоге &lt;code&gt;.git/objects/??/&lt;/code&gt; хранится для каждого создаваемого вами объекта Git. Такое представление эффективно создавать атомарно и безопасно, но не так удобно для передачи по сети. Поскольку объекты Git неизменяемы после их создания, есть способ оптимизировать хранилище, &amp;laquo;упаковав их вместе&amp;raquo;. Команда</target>
        </trans-unit>
        <trans-unit id="b4c8a83331a00582f4030fa5296077717cda7730" translate="yes" xml:space="preserve">
          <source>Ease of use. It is often much simpler to write a binary to text transformation than it is to perform your own diff. In many cases, existing programs can be used as textconv filters (e.g., exif, odt2txt).</source>
          <target state="translated">Простота использования.Часто намного проще написать двоичное преобразование в текст,чем выполнить свое собственное различие.Во многих случаях существующие программы могут быть использованы в качестве текстовых фильтровconv (например,exif,odt2txt).</target>
        </trans-unit>
        <trans-unit id="b4d52eb229c8c557c44ab0035085b989953060f9" translate="yes" xml:space="preserve">
          <source>Easily extendable as capabilities are moved into their own section of the protocol, no longer being hidden behind a NUL byte and limited by the size of a pkt-line</source>
          <target state="translated">Легко расширяется по мере перемещения возможностей в собственный раздел протокола,больше не скрываясь за NUL-байтом и ограничиваясь размером pkt-линии.</target>
        </trans-unit>
        <trans-unit id="c0ecd6c3f25fc4cb4d76566a21fece2ca48f95ab" translate="yes" xml:space="preserve">
          <source>Easy case: The changes are literally the same.</source>
          <target state="translated">Легкий случай:Изменения буквально одинаковые.</target>
        </trans-unit>
        <trans-unit id="d4f35a5d52e75e1ab425158dcb45339db600d3f4" translate="yes" xml:space="preserve">
          <source>Eclipse 3.0, 3.1.2 on MacOSX (see Eclipse CVS Client Notes)</source>
          <target state="translated">Затмение 3.0,3.1.2 на MacOSX (см.Затмение Клиентских Заметок CVS)</target>
        </trans-unit>
        <trans-unit id="f5e176bd2c2df731632b9ca0ee7983e84b3d8517" translate="yes" xml:space="preserve">
          <source>Eclipse cvs client notes</source>
          <target state="translated">Затмение клиентских записей cvs</target>
        </trans-unit>
        <trans-unit id="ea0675157801730c96e515d20a6ad02ac765e6d4" translate="yes" xml:space="preserve">
          <source>Edit an object&amp;rsquo;s content interactively. The existing content for &amp;lt;object&amp;gt; is pretty-printed into a temporary file, an editor is launched on the file, and the result is parsed to create a new object of the same type as &amp;lt;object&amp;gt;. A replacement ref is then created to replace &amp;lt;object&amp;gt; with the newly created object. See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details about how the editor will be chosen.</source>
          <target state="translated">Редактируйте содержимое объекта в интерактивном режиме. Существующее содержимое для &amp;lt;object&amp;gt; красиво распечатывается во временном файле, для файла запускается редактор, и результат анализируется для создания нового объекта того же типа, что и &amp;lt;object&amp;gt;. Затем создается замещающая ссылка для замены &amp;lt;object&amp;gt; вновь созданным объектом. См. &lt;a href=&quot;git-var&quot;&gt;Git-var [1]&lt;/a&gt; для получения подробной информации о том, как будет выбран редактор.</target>
        </trans-unit>
        <trans-unit id="0f76fc2a41a48ffbf729f7fe389bfe3f0b08de68" translate="yes" xml:space="preserve">
          <source>Edit the commit message before committing to SVN. This is off by default for objects that are commits, and forced on when committing tree objects.</source>
          <target state="translated">Отредактируйте сообщение о фиксации перед фиксацией в SVN.По умолчанию эта опция отключена для объектов,которые являются объектами коммита,и принудительно включается при фиксации древовидных объектов.</target>
        </trans-unit>
        <trans-unit id="c92b0955a7a67e8bc1f5f7afd177ec4ed55d0e4c" translate="yes" xml:space="preserve">
          <source>Edit the files in place.</source>
          <target state="translated">Отредактируйте файлы на месте.</target>
        </trans-unit>
        <trans-unit id="b87cea5cffa31e45fd50bcd7540894242796f029" translate="yes" xml:space="preserve">
          <source>Edit the notes for a given object (defaults to HEAD).</source>
          <target state="translated">Отредактируйте примечания для данного объекта (по умолчанию HEAD).</target>
        </trans-unit>
        <trans-unit id="81933d4e997d5f22262236af308c480381855b0f" translate="yes" xml:space="preserve">
          <source>Edit the todo list during an interactive rebase.</source>
          <target state="translated">Отредактируйте список тодо во время интерактивной перезагрузки.</target>
        </trans-unit>
        <trans-unit id="f392476dbdf7968fc4726a7173f15cf238dddd46" translate="yes" xml:space="preserve">
          <source>Editing patches</source>
          <target state="translated">Редактирование патчей</target>
        </trans-unit>
        <trans-unit id="8f25a859269ca51039632dd6bba28fb061cfb8d4" translate="yes" xml:space="preserve">
          <source>Effects</source>
          <target state="translated">Effects</target>
        </trans-unit>
        <trans-unit id="7002bc1d2bcb94f212817ade973f1baffe1d4266" translate="yes" xml:space="preserve">
          <source>Either a &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, or a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; together with the dependent &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; and tree objects (i.e. a stored representation of a working tree).</source>
          <target state="translated">Либо &lt;a href=&quot;#def_working_tree&quot;&gt;рабочее дерево&lt;/a&gt; , либо &lt;a href=&quot;#def_tree_object&quot;&gt;объект дерева&lt;/a&gt; вместе с зависимыми объектами &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; и tree (т. Е. Сохраненное представление рабочего дерева).</target>
        </trans-unit>
        <trans-unit id="bc0851580574fafe647ac3b5e7bd049ba47eee8d" translate="yes" xml:space="preserve">
          <source>Either the hash or the filename under [URL]/refs/ to pull.</source>
          <target state="translated">Или хэш или имя файла в разделе [URL]/refs/для извлечения.</target>
        </trans-unit>
        <trans-unit id="3c055884457fa0453683ceee26bbe41d08beb912" translate="yes" xml:space="preserve">
          <source>Either way, if you have a string of untestable commits, it might happen that the regression you are looking for has been introduced by one of these untestable commits. In this case it&amp;rsquo;s not possible to tell for sure which commit introduced the regression.</source>
          <target state="translated">В любом случае, если у вас есть строка непроверяемых коммитов, может случиться так, что регрессия, которую вы ищете, была введена одним из этих непроверяемых коммитов. В этом случае невозможно точно сказать, какая фиксация привела к регрессии.</target>
        </trans-unit>
        <trans-unit id="84add5b2952787581cb9a8851eef63d1ec75d22b" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="translated">Email</target>
        </trans-unit>
        <trans-unit id="727400f70d8ff4dd021cd3b46cd8407431accd18" translate="yes" xml:space="preserve">
          <source>Empty commits</source>
          <target state="translated">Пустые обязательства</target>
        </trans-unit>
        <trans-unit id="64c856db8d7087653e88ddbd52d985c5029c26f3" translate="yes" xml:space="preserve">
          <source>Empty context lines that do not have &lt;code&gt;any&lt;/code&gt; whitespace.</source>
          <target state="translated">Пустые строки контекста , которые не имеют &lt;code&gt;any&lt;/code&gt; пробелов.</target>
        </trans-unit>
        <trans-unit id="bc35de4b332414e34ea66c4e2722d1b3c677ee26" translate="yes" xml:space="preserve">
          <source>Enable &quot;sparse checkout&quot; feature. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">Включите функцию &amp;laquo;разреженной проверки&amp;raquo;. См. &lt;a href=&quot;git-sparse-checkout&quot;&gt;Git-sparse-checkout [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="b1506b425dd0a659b4e3f7dbaad1db76c1920ca2" translate="yes" xml:space="preserve">
          <source>Enable (1) or disable (0) debug output. If enabled, SMTP commands and replies will be printed. Useful to debug TLS connection and authentication problems.</source>
          <target state="translated">Включите (1)или отключите (0)вывод отладки.Если включено,будут печататься SMTP команды и ответы.Полезно для отладки TLS соединения и проблем с аутентификацией.</target>
        </trans-unit>
        <trans-unit id="5ca5f9ffb4eef636571b0732ca8e82f4b117bf57" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overridden by the &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="translated">Включите запрос пароля Git для сертификата SSL. В противном случае OpenSSL будет запрашивать пользователя, возможно, много раз, зашифрован ли сертификат или закрытый ключ. Может быть переопределено переменной среды &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22af37288ef16d6e96158d900edae0bae2453223" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the proxy SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overriden by the &lt;code&gt;GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202cfbf6c643ccf61c3e6855fb4942a959d7c88c" translate="yes" xml:space="preserve">
          <source>Enable and configure &quot;patches&quot; view, which displays list of commits in email (plain text) output format; see also &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;. The value is the maximum number of patches in a patchset generated in &quot;patches&quot; view. Set the &lt;code&gt;default&lt;/code&gt; field to a list containing single item of or to an empty list to disable patch view, or to a list containing a single negative number to remove any limit. Default value is 16.</source>
          <target state="translated">Включите и настройте вид &amp;laquo;патчей&amp;raquo;, который отображает список коммитов в формате вывода электронной почты (обычный текст); см. также &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; . Значение - это максимальное количество патчей в наборе патчей, созданном в представлении &amp;laquo;патчи&amp;raquo;. Задайте в качестве поля по &lt;code&gt;default&lt;/code&gt; список, содержащий один элемент, или пустой список, чтобы отключить просмотр исправлений, или список, содержащий одно отрицательное число, чтобы удалить любое ограничение. Значение по умолчанию - 16.</target>
        </trans-unit>
        <trans-unit id="3ec940cc58a7e0a3ca8323d3832e04ecb527aead" translate="yes" xml:space="preserve">
          <source>Enable and configure the &quot;snapshot&quot; action, which allows user to download a compressed archive of any tree or commit, as produced by &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; and possibly additionally compressed. This can potentially generate high traffic if you have large project.</source>
          <target state="translated">Включите и настройте действие &amp;laquo;моментальный снимок&amp;raquo;, которое позволяет пользователю загружать сжатый архив любого дерева или фиксации, созданный &lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt; и, возможно, дополнительно сжатый. Это может потенциально вызвать большой трафик, если у вас большой проект.</target>
        </trans-unit>
        <trans-unit id="875ff7ca114490b100a4ae7597d23eb505e57466" translate="yes" xml:space="preserve">
          <source>Enable and configure the ability to change a common time zone for dates in gitweb output via JavaScript. Dates in gitweb output include authordate and committerdate in &quot;commit&quot;, &quot;commitdiff&quot; and &quot;log&quot; views, and taggerdate in &quot;tag&quot; view. Enabled by default.</source>
          <target state="translated">Включите и настройте возможность изменения общего часового пояса для дат в gitweb-выведении через JavaScript.Даты в выводе gitweb включают authordate и committerdate в представлении &quot;commit&quot;,&quot;commitdiff&quot; и &quot;log&quot;,а также taggerdate в представлении &quot;tag&quot;.Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e1b8a656580e419265edb3d93e7fbf612f88122b" translate="yes" xml:space="preserve">
          <source>Enable config options that are new to Git, and are being considered for future defaults. Config settings included here may be added or removed with each release, including minor version updates. These settings may have unintended interactions since they are so new. Please enable this setting if you are interested in providing feedback on experimental features. The new default values are:</source>
          <target state="translated">Включите опции конфигурации,которые являются новыми для Git'а и рассматриваются на предмет будущих установок по умолчанию.Включённые здесь настройки конфигурации могут быть добавлены или удалены с каждым выпуском,включая незначительные обновления версий.Эти настройки могут взаимодействовать непреднамеренно,поскольку они являются новыми для Git'а.Пожалуйста,включите эту настройку,если вы заинтересованы в получении отзывов об экспериментальных возможностях.Новые значения по умолчанию:</target>
        </trans-unit>
        <trans-unit id="8740fb3b16d2502b6a07330a252227f128574417" translate="yes" xml:space="preserve">
          <source>Enable config options that optimize for repos with many files in the working directory. With many files, commands such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git checkout&lt;/code&gt; may be slow and these new defaults improve performance:</source>
          <target state="translated">Включите параметры конфигурации, оптимизированные для репозиториев с большим количеством файлов в рабочем каталоге. Для многих файлов такие команды, как &lt;code&gt;git status&lt;/code&gt; и &lt;code&gt;git checkout&lt;/code&gt; , могут быть медленными, и эти новые значения по умолчанию улучшают производительность:</target>
        </trans-unit>
        <trans-unit id="b62688a948f16b8896e24589781ecaee64693ffd" translate="yes" xml:space="preserve">
          <source>Enable displaying how much time and how many Git commands it took to generate and display each page in the page footer (at the bottom of page). For example the footer might contain: &quot;This page took 6.53325 seconds and 13 Git commands to generate.&quot; Disabled by default.</source>
          <target state="translated">Включите отображение того,сколько времени и команд Git'а потребовалось для генерации,и отобразите каждую страницу в нижнем колонтитуле страницы (внизу страницы).Например,нижний колонтитул может содержать:&quot;Сгенерация этой страницы заняла 6 53325 секунд,а также 13 команд Git'а&quot;.По умолчанию отключена.</target>
        </trans-unit>
        <trans-unit id="c9bd131fb11e7d8a575c789c619c56115c835cfc" translate="yes" xml:space="preserve">
          <source>Enable displaying remote heads (remote-tracking branches) in the &quot;heads&quot; list. In most cases the list of remote-tracking branches is an unnecessary internal private detail, and this feature is therefore disabled by default. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;, which is usually used to browse local repositories, enables and uses this feature.</source>
          <target state="translated">Включите отображение удаленных голов (ветвей удаленного отслеживания) в списке &amp;laquo;голов&amp;raquo;. В большинстве случаев список ветвей удаленного отслеживания представляет собой ненужную внутреннюю частную деталь, и поэтому эта функция по умолчанию отключена. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; , который обычно используется для просмотра локальных репозиториев, включает и использует эту функцию.</target>
        </trans-unit>
        <trans-unit id="39da6c4d119e094eeb647ff45a2f63bf34d04c9c" translate="yes" xml:space="preserve">
          <source>Enable grep search, which lists the files in currently selected tree (directory) containing the given string; see &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt;. This can be potentially CPU-intensive, of course. Enabled by default.</source>
          <target state="translated">Включить поиск grep, который выводит список файлов в выбранном в данный момент дереве (каталоге), содержащих заданную строку; см. &lt;a href=&quot;git-grep&quot;&gt;git-grep [1]&lt;/a&gt; . Конечно, это может быть потенциально ресурсоемким. Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="393e4a210cdfd96d50c3abf9958899d9c77b22c9" translate="yes" xml:space="preserve">
          <source>Enable more strict checking, namely to catch a file mode recorded with g+w bit set, which was created by older versions of Git. Existing repositories, including the Linux kernel, Git itself, and sparse repository have old objects that triggers this check, but it is recommended to check new projects with this flag.</source>
          <target state="translated">Включить более строгую проверку,а именно перехват файлового режима,записанного с набором битов g+w,который был создан старыми версиями Git'а.Существующие репозитории,включая ядро Linux,сам Git и разрежённый репозиторий,имеют старые объекты,которые запускают эту проверку,но рекомендуется проверять новые проекты с помощью этого флага.</target>
        </trans-unit>
        <trans-unit id="8081f1426d8047f2f5c9039fb2b3187c4aed51ad" translate="yes" xml:space="preserve">
          <source>Enable multipart/mixed attachments as the default for &lt;code&gt;format-patch&lt;/code&gt;. The value can also be a double quoted string which will enable attachments as the default and set the value as the boundary. See the --attach option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">Включите составные / смешанные вложения по умолчанию для &lt;code&gt;format-patch&lt;/code&gt; . Значение также может быть строкой в ​​двойных кавычках, которая разрешит вложения по умолчанию и установит значение в качестве границы. См. Параметр --attach в &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d973b021f64131371542864785f310ed020b9e66" translate="yes" xml:space="preserve">
          <source>Enable or disable files system monitor feature. These options take effect whatever the value of the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">Включение или отключение функции монитора файловой системы. Эти параметры действуют независимо от значения переменной конфигурации &lt;code&gt;core.fsmonitor&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ). Но когда изменение идет вразрез с настроенным значением, выдается предупреждение, поскольку настроенное значение вступит в силу при следующем чтении индекса, и это приведет к удалению предполагаемого эффекта параметра.</target>
        </trans-unit>
        <trans-unit id="d83423bb73684fa975c3f77aeba009920792cf88" translate="yes" xml:space="preserve">
          <source>Enable or disable split index mode. If split-index mode is already enabled and &lt;code&gt;--split-index&lt;/code&gt; is given again, all changes in $GIT_DIR/index are pushed back to the shared index file.</source>
          <target state="translated">Включение или отключение режима разделенного индекса. Если режим разделенного индекса уже включен и &lt;code&gt;--split-index&lt;/code&gt; , все изменения в $ GIT_DIR / index передаются обратно в файл общего индекса.</target>
        </trans-unit>
        <trans-unit id="f8b0173e3fdc03c4e03595346f1584e741b798c1" translate="yes" xml:space="preserve">
          <source>Enable or disable untracked cache feature. Please use &lt;code&gt;--test-untracked-cache&lt;/code&gt; before enabling it.</source>
          <target state="translated">Включение или отключение функции неотслеживаемого кеша. Пожалуйста, используйте &lt;code&gt;--test-untracked-cache&lt;/code&gt; перед его включением.</target>
        </trans-unit>
        <trans-unit id="5d058dbf876c4efd16b9ed5eae486a10be79bb86" translate="yes" xml:space="preserve">
          <source>Enable parallel index preload for operations like &lt;code&gt;git diff&lt;/code&gt;</source>
          <target state="translated">Включить предварительную загрузку параллельного индекса для таких операций, как &lt;code&gt;git diff&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1aa8a755e195170094ad7c0108b7874b637b96b6" translate="yes" xml:space="preserve">
          <source>Enable showing size of blobs (ordinary files) in a &quot;tree&quot; view, in a separate column, similar to what &lt;code&gt;ls -l&lt;/code&gt; does; see description of &lt;code&gt;-l&lt;/code&gt; option in &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; manpage. This costs a bit of I/O. Enabled by default.</source>
          <target state="translated">Включите отображение размера больших двоичных объектов (обычных файлов) в виде &amp;laquo;дерева&amp;raquo; в отдельном столбце, аналогично тому, как это делает &lt;code&gt;ls -l&lt;/code&gt; ; см. описание опции &lt;code&gt;-l&lt;/code&gt; в man-странице &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt; . Это немного стоит ввода-вывода. Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="72fa50bb7bb0362a9a5efa2aa6f34941c4906089" translate="yes" xml:space="preserve">
          <source>Enable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if &lt;code&gt;--quiet&lt;/code&gt; was not specified.</source>
          <target state="translated">Включите более строгую проверку ссылок, потребовав точный путь ссылки. Помимо возврата кода ошибки 1, он также распечатает сообщение об ошибке, если &lt;code&gt;--quiet&lt;/code&gt; не был указан.</target>
        </trans-unit>
        <trans-unit id="48730f76cba5f67862630837d3f93d8ce9288066" translate="yes" xml:space="preserve">
          <source>Enable text search, which will list the commits which match author, committer or commit text to a given string; see the description of &lt;code&gt;--author&lt;/code&gt;, &lt;code&gt;--committer&lt;/code&gt; and &lt;code&gt;--grep&lt;/code&gt; options in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; manpage. Enabled by default.</source>
          <target state="translated">Включить текстовый поиск, в котором будут перечислены коммиты, соответствующие тексту автора, коммиттера или коммита заданной строке; смотрите описание &lt;code&gt;--author&lt;/code&gt; , &lt;code&gt;--committer&lt;/code&gt; и &lt;code&gt;--grep&lt;/code&gt; опции в &lt;a href=&quot;git-log&quot;&gt;GIT-журнал [1]&lt;/a&gt; станице руководства. Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5bf942f17a0adbd66d5dff03794ede7ed6ce3a03" translate="yes" xml:space="preserve">
          <source>Enable the &quot;blame&quot; and &quot;blame_incremental&quot; blob views, showing for each line the last commit that modified it; see &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This can be very CPU-intensive and is therefore disabled by default.</source>
          <target state="translated">Включите представления blob &quot;blame&quot; и &quot;blame_incremental&quot;, показывая для каждой строки последний коммит, изменивший его; см. &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; . Это может сильно загружать процессор и поэтому по умолчанию отключено.</target>
        </trans-unit>
        <trans-unit id="d7fc03efc211d064bf3be01f125339a0be59fcba" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting. If the sparse-checkout file does not exist, then populate it with patterns that match every file in the root directory and no other directories, then will remove all directories tracked by Git. Add patterns to the sparse-checkout file to repopulate the working directory.</source>
          <target state="translated">Включите параметр &lt;code&gt;core.sparseCheckout&lt;/code&gt; . Если файл разреженной проверки не существует, заполните его шаблонами, которые соответствуют каждому файлу в корневом каталоге и никаким другим каталогам, а затем удалите все каталоги, отслеживаемые Git. Добавьте шаблоны в файл sparse-checkout, чтобы повторно заполнить рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="388296e4f7d314018094f8c18fc5c6de39a494b4" translate="yes" xml:space="preserve">
          <source>Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.</source>
          <target state="translated">Включите эвристику,которая сдвигает границы diff hunk,чтобы сделать патчи более легкими для чтения.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="01f1f887420f77509dbb30a6ca88007ca92eded6" translate="yes" xml:space="preserve">
          <source>Enable the reflog. Updates to a ref &amp;lt;ref&amp;gt; is logged to the file &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot;, by appending the new and old SHA-1, the date/time and the reason of the update, but only when the file exists. If this configuration variable is set to &lt;code&gt;true&lt;/code&gt;, missing &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot; file is automatically created for branch heads (i.e. under &lt;code&gt;refs/heads/&lt;/code&gt;), remote refs (i.e. under &lt;code&gt;refs/remotes/&lt;/code&gt;), note refs (i.e. under &lt;code&gt;refs/notes/&lt;/code&gt;), and the symbolic ref &lt;code&gt;HEAD&lt;/code&gt;. If it is set to &lt;code&gt;always&lt;/code&gt;, then a missing reflog is automatically created for any ref under &lt;code&gt;refs/&lt;/code&gt;.</source>
          <target state="translated">Включите рефлог. Обновления ссылки &amp;lt;ref&amp;gt; регистрируются в файле &quot; &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &quot; путем добавления нового и старого SHA-1, даты / времени и причины обновления, но только если файл существует , Если для этой переменной конфигурации установлено значение &lt;code&gt;true&lt;/code&gt; , отсутствующий &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &quot; $ GIT_DIR / logs / &amp;lt;ref&amp;gt; &quot; автоматически создается для заголовков веток (т.е. в разделе &lt;code&gt;refs/heads/&lt;/code&gt; ), удаленных ссылок (например, в разделе &lt;code&gt;refs/remotes/&lt;/code&gt; ), обратите внимание на ссылки ( т.е. в разделе &lt;code&gt;refs/notes/&lt;/code&gt; ) и символической ссылке &lt;code&gt;HEAD&lt;/code&gt; . Если установлено значение &lt;code&gt;always&lt;/code&gt; , то для любой ссылки в &lt;code&gt;refs/&lt;/code&gt; автоматически создается отсутствующий журнал ссылок .</target>
        </trans-unit>
        <trans-unit id="b50a25e099857665aa0b9ce95777350330756bcc" translate="yes" xml:space="preserve">
          <source>Enable the so called pickaxe search, which will list the commits that introduced or removed a given string in a file. This can be practical and quite faster alternative to &quot;blame&quot; action, but it is still potentially CPU-intensive. Enabled by default.</source>
          <target state="translated">Включите так называемый поиск по кирпичикам,в котором будут перечислены коммиты,которые ввели или удалили заданную строку в файле.Это может быть практичной и довольно быстрой альтернативой действию &quot;вины&quot;,но все равно это потенциально трудоемкий процессор.Включено по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e8928096a1d83fe75290fee4b17a3faa5d2c2864" translate="yes" xml:space="preserve">
          <source>Enable the specified feature. This requires that fast-import supports the specified feature, and aborts if it does not.</source>
          <target state="translated">Включите указанную функцию.Для этого требуется,чтобы быстрый импорт поддерживал указанную функцию,и отменял ее,если это не так.</target>
        </trans-unit>
        <trans-unit id="cb33ed4fbb60981dda9e34bad99e8fe5205271b1" translate="yes" xml:space="preserve">
          <source>Enable/disable the service site-wide per default. Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item.</source>
          <target state="translated">Включение/выключение всего сайта службы по умолчанию.Обратите внимание,что отключенный сервис может быть включен для каждого репозитория,если он помечен как переопределяемый,а репозиторий включает сервис с помощью элемента конфигурации.</target>
        </trans-unit>
        <trans-unit id="35a563959614f6c71c72cc0395ec6a9ebde3235d" translate="yes" xml:space="preserve">
          <source>Enables (or disables) progress messages displayed by the transport helper during a command.</source>
          <target state="translated">Включение (или отключение)сообщений о ходе выполнения,отображаемых помощником по транспорту во время выполнения команды.</target>
        </trans-unit>
        <trans-unit id="c889da55fe7b392cff2ceaa7f38c976ee6969838" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ef71c7bfb2fa4d7687d0c6a055c6d9acec70dd" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. This option overrides setting the &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; environment variable. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Включает полный дамп трассировки curl для всех входящих и исходящих данных, включая описательную информацию, транспортного протокола git. Это похоже на выполнение команды curl &lt;code&gt;--trace-ascii&lt;/code&gt; в командной строке. Эта опция отменяет установку переменной окружения &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; . См. &lt;code&gt;GIT_TRACE&lt;/code&gt; для доступных опций вывода трассировки.</target>
        </trans-unit>
        <trans-unit id="6691f775d187ea6f64d054b6823e9e86f9c085bf" translate="yes" xml:space="preserve">
          <source>Enables general trace messages, e.g. alias expansion, built-in command execution and external command execution.</source>
          <target state="translated">Включает общие сообщения о трассировке,например,расширение псевдонима,встроенное выполнение команды и внешнее выполнение команды.</target>
        </trans-unit>
        <trans-unit id="e48905b14288617c8ceaa87834665d923c04c051" translate="yes" xml:space="preserve">
          <source>Enables more detailed trace messages from the &quot;trace2&quot; library. Output from &lt;code&gt;GIT_TRACE2&lt;/code&gt; is a simple text-based format for human readability.</source>
          <target state="translated">Включает более подробные сообщения трассировки из библиотеки &quot;trace2&quot;. Вывод из &lt;code&gt;GIT_TRACE2&lt;/code&gt; - это простой текстовый формат для удобства чтения.</target>
        </trans-unit>
        <trans-unit id="660988c86be3da054f2d2df3321eefbdd55b0999" translate="yes" xml:space="preserve">
          <source>Enables performance related trace messages, e.g. total execution time of each Git command. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Включает сообщения трассировки, связанные с производительностью, например, общее время выполнения каждой команды Git. См. &lt;code&gt;GIT_TRACE&lt;/code&gt; для доступных опций вывода трассировки.</target>
        </trans-unit>
        <trans-unit id="dc7b8ed816ac9633bd1375cea1e49bf11b8f4cfe" translate="yes" xml:space="preserve">
          <source>Enables the &quot;cone mode&quot; of the sparse checkout feature. When the sparse-checkout file contains a limited set of patterns, then this mode provides significant performance advantages. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">Включает &quot;режим конуса&quot; функции разреженной проверки. Когда файл разреженной проверки содержит ограниченный набор шаблонов, этот режим обеспечивает значительные преимущества в производительности. См. &lt;a href=&quot;git-sparse-checkout&quot;&gt;Git-sparse-checkout [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="69a28feccce4c72bcadfb900d39f7f184847d39a" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all accesses to any packs. For each access, the pack file name and an offset in the pack is recorded. This may be helpful for troubleshooting some pack-related performance problems. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Включает сообщения трассировки для всех обращений к любым пакетам. Для каждого доступа записывается имя файла пакета и смещение в пакете. Это может быть полезно для устранения некоторых проблем с производительностью, связанных с пакетом. См. &lt;code&gt;GIT_TRACE&lt;/code&gt; для доступных опций вывода трассировки.</target>
        </trans-unit>
        <trans-unit id="facc11ad57d6672e51f919b154eb028564e3944e" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all packets coming in or out of a given program. This can help with debugging object negotiation or other protocol issues. Tracing is turned off at a packet starting with &quot;PACK&quot; (but see &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; below). See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Включает сообщения трассировки для всех пакетов, входящих или исходящих из данной программы. Это может помочь при отладке согласования объектов или других проблемах протокола. Отслеживание отключается для пакета, начинающегося с &quot;PACK&quot; (но см. &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; ниже). См. &lt;code&gt;GIT_TRACE&lt;/code&gt; для доступных опций вывода трассировки.</target>
        </trans-unit>
        <trans-unit id="edb9b39606e0f9447b27a5131ddede4062e0f50d" translate="yes" xml:space="preserve">
          <source>Enables trace messages for operations on the ref database. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a96e0b90f936140e14c4f59157281584502b280" translate="yes" xml:space="preserve">
          <source>Enables trace messages for the filesystem monitor extension. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Включает сообщения трассировки для расширения монитора файловой системы. См. &lt;code&gt;GIT_TRACE&lt;/code&gt; для доступных опций вывода трассировки.</target>
        </trans-unit>
        <trans-unit id="226b098ac2b03df2efedb4d6f3177d8a53d1323d" translate="yes" xml:space="preserve">
          <source>Enables trace messages printing the .git, working tree and current working directory after Git has completed its setup phase. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Позволяет сообщениям трассировки печатать .git, рабочее дерево и текущий рабочий каталог после того, как Git завершит этап установки. См. &lt;code&gt;GIT_TRACE&lt;/code&gt; для доступных опций вывода трассировки.</target>
        </trans-unit>
        <trans-unit id="0876ec8b14060e46110f6e776b65e26631e1613f" translate="yes" xml:space="preserve">
          <source>Enables trace messages that can help debugging fetching / cloning of shallow repositories. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Включает сообщения трассировки, которые могут помочь в отладке выборки / клонирования мелких репозиториев. См. &lt;code&gt;GIT_TRACE&lt;/code&gt; для доступных опций вывода трассировки.</target>
        </trans-unit>
        <trans-unit id="d9d84b12f1c34508f5365e4fa51faae6983f4d76" translate="yes" xml:space="preserve">
          <source>Enables tracing of packfiles sent or received by a given program. Unlike other trace output, this trace is verbatim: no headers, and no quoting of binary data. You almost certainly want to direct into a file (e.g., &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt;) rather than displaying it on the terminal or mixing it with other trace output.</source>
          <target state="translated">Включает отслеживание пакетов, отправленных или полученных данной программой. В отличие от других выходных данных трассировки, эта трассировка дословна: без заголовков и без цитирования двоичных данных. Вы почти наверняка захотите направить в файл (например, &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt; ), а не отображать его на терминале или смешивать с другим выводом трассировки.</target>
        </trans-unit>
        <trans-unit id="e7a1430764d62a995667824305a6bb53b99cb2fa" translate="yes" xml:space="preserve">
          <source>Enabling a Target</source>
          <target state="translated">Включение цели</target>
        </trans-unit>
        <trans-unit id="619b6ac53993b275b163fbd1d47132e1851812f0" translate="yes" xml:space="preserve">
          <source>Encode email headers that have non-ASCII characters with &quot;Q-encoding&quot; (described in RFC 2047) for email transmission. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae00f8479c80f28e526371cda478b9f2e76f78a" translate="yes" xml:space="preserve">
          <source>Encode email headers that have non-ASCII characters with &quot;Q-encoding&quot; (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the &lt;code&gt;format.encodeEmailHeaders&lt;/code&gt; configuration variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff218bfdfe647deb6f8afd9e1fb8602500fad3a" translate="yes" xml:space="preserve">
          <source>Encoding to use when displaying logs. (See &lt;code&gt;Discussion&lt;/code&gt; above.) Defaults to the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; if set, and UTF-8 otherwise.</source>
          <target state="translated">Кодировка, используемая при отображении журналов. (См. &lt;code&gt;Discussion&lt;/code&gt; выше.) По умолчанию используется значение &lt;code&gt;i18n.commitEncoding&lt;/code&gt; , если установлено, и UTF-8 в противном случае.</target>
        </trans-unit>
        <trans-unit id="89269a8275f94980b4ffe877e221e0d466987782" translate="yes" xml:space="preserve">
          <source>End-of-line conversion</source>
          <target state="translated">Преобразование в конец строки</target>
        </trans-unit>
        <trans-unit id="ab7c0d7ed2b514b7971808ab6a9cdbd8fa7e7be5" translate="yes" xml:space="preserve">
          <source>Enhanced option parser</source>
          <target state="translated">Расширенный парсер опций</target>
        </trans-unit>
        <trans-unit id="d48b2fd91c06d512d371b7025cd11deeb23b34ad" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored.</source>
          <target state="translated">Убедитесь, что не менее &amp;lt;n&amp;gt; строк окружающего контекста совпадают до и после каждого изменения. Когда существует меньше строк окружающего контекста, все они должны совпадать. По умолчанию ни один контекст не игнорируется.</target>
        </trans-unit>
        <trans-unit id="40fd8773c6f206a9063f0067c04f352f2f44d8bc" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored. Implies --apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6825ec27b2b654ed999d31628f8e31396467a23b" translate="yes" xml:space="preserve">
          <source>Ensure mod_cgi, mod_alias, and mod_env are enabled, set GIT_PROJECT_ROOT (or DocumentRoot) appropriately, and create a ScriptAlias to the CGI:</source>
          <target state="translated">Убедитесь,что включены mod_cgi,mod_alias и mod_env,установите GIT_PROJECT_ROOT (или DocumentRoot)соответствующим образом,и создайте ScriptAlias в CGI:</target>
        </trans-unit>
        <trans-unit id="136727d71b4774df6f61241cd1f96329e996c416" translate="yes" xml:space="preserve">
          <source>Ensure that &lt;code&gt;mod_cgi&lt;/code&gt;, &lt;code&gt;mod_alias&lt;/code&gt;, &lt;code&gt;mod_auth&lt;/code&gt;, &lt;code&gt;mod_setenv&lt;/code&gt; are loaded, then set &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; appropriately and redirect all requests to the CGI:</source>
          <target state="translated">Убедитесь , что &lt;code&gt;mod_cgi&lt;/code&gt; , &lt;code&gt;mod_alias&lt;/code&gt; , &lt;code&gt;mod_auth&lt;/code&gt; , &lt;code&gt;mod_setenv&lt;/code&gt; загружаются, а затем установите &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; надлежащим образом и перенаправить все запросы к CGI:</target>
        </trans-unit>
        <trans-unit id="05b99bf62f144f697a8ee2786cac4dbb9ea1f0fb" translate="yes" xml:space="preserve">
          <source>Ensures that a reference name is well formed</source>
          <target state="translated">Гарантирует,что ссылочное имя хорошо сформировано</target>
        </trans-unit>
        <trans-unit id="ced8b1d7750a47c0481b135a1b95578c79b545a4" translate="yes" xml:space="preserve">
          <source>Ensuring good performance</source>
          <target state="translated">Обеспечение хорошей производительности</target>
        </trans-unit>
        <trans-unit id="bbdd824923a22a7ee366da56344be9b791387ca5" translate="yes" xml:space="preserve">
          <source>Ensuring reliability</source>
          <target state="translated">Обеспечение надежности</target>
        </trans-unit>
        <trans-unit id="35254b488f033ee2fce6cea7c360bd0f51157448" translate="yes" xml:space="preserve">
          <source>Enter &lt;code&gt;git name-rev&lt;/code&gt;:</source>
          <target state="translated">Введите &lt;code&gt;git name-rev&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="35cd2b0a8df7f89252ec5f994efe80c34ae3bb81" translate="yes" xml:space="preserve">
          <source>Entries that begin with &lt;code&gt;&quot;&lt;/code&gt; (double-quote) will be interpreted as C-style quoted paths, removing leading and trailing double-quotes and respecting backslash escapes. E.g., the value &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; has two paths: &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; and &lt;code&gt;vanilla-path&lt;/code&gt;.</source>
          <target state="translated">Записи, начинающиеся с &lt;code&gt;&quot;&lt;/code&gt; (двойные кавычки), будут интерпретироваться как пути в кавычках в стиле C, удалив начальные и конечные двойные кавычки и соблюдая экранирование обратной косой черты. Например, значение &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; имеет два пути: &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; и &lt;code&gt;vanilla-path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="8403ba2a4a5aa9baffc30d3d46a39f555141e42f" translate="yes" xml:space="preserve">
          <source>Environment and configuration variables</source>
          <target state="translated">Переменные среды и конфигурационные переменные</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">Переменные среды</target>
        </trans-unit>
        <trans-unit id="2e9c1d645028b692809462da156b1ceab497759c" translate="yes" xml:space="preserve">
          <source>Environment variables passed to command</source>
          <target state="translated">Переменные среды,переданные в команду</target>
        </trans-unit>
        <trans-unit id="0939f663868ba2e69e812a3d630f787f9c5cfc8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given.</source>
          <target state="translated">Эквивалентен &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; , с &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1, если не указан.</target>
        </trans-unit>
        <trans-unit id="0c3185db11169cc7a29ed7dd80f79aa18ce0f759" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;--word-diff=color&lt;/code&gt; plus (if a regex was specified) &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;--word-diff=color&lt;/code&gt; plus (если было указано регулярное выражение) &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fce804cbafec5e50fdfe3953fee8d48f776185de" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;. Note that &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; does not need to be the exact branch point of the branches. Example: after rebasing a branch &lt;code&gt;my-topic&lt;/code&gt;, &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; would show the differences introduced by the rebase.</source>
          <target state="translated">Эквивалентно передаче &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; . Обратите внимание, что &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; не обязательно должна быть точной точкой ветвления. Пример: после перенастройки ветки &lt;code&gt;my-topic&lt;/code&gt; , &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; покажет различия, внесенные ребазом.</target>
        </trans-unit>
        <trans-unit id="fee223c131ae45dd7f0054cc61edf8587521b104" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно передаче &lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b3a0b879a412ed7b377d180ca1727a3b8f2d6d" translate="yes" xml:space="preserve">
          <source>Error out if the stream ends without a &lt;code&gt;done&lt;/code&gt; command. Without this feature, errors causing the frontend to end abruptly at a convenient point in the stream can go undetected. This may occur, for example, if an import front end dies in mid-operation without emitting SIGTERM or SIGKILL at its subordinate git fast-import instance.</source>
          <target state="translated">Ошибка выдается, если поток заканчивается без &lt;code&gt;done&lt;/code&gt; команды done . Без этой функции ошибки, вызывающие внезапное завершение клиентского интерфейса в удобной точке потока, могут остаться незамеченными. Это может произойти, например, если интерфейс импорта умирает в середине операции, не испуская SIGTERM или SIGKILL в подчиненном ему экземпляре git fast-import.</target>
        </trans-unit>
        <trans-unit id="137e434092ea32c83e7a34f0c9bc0aa62d172e84" translate="yes" xml:space="preserve">
          <source>Especially useful for interoperability with a foreign versioning system.</source>
          <target state="translated">Особенно полезен для совместимости с иностранной системой версионирования.</target>
        </trans-unit>
        <trans-unit id="058d99599bd9d3348c2826266e98651571ad20e7" translate="yes" xml:space="preserve">
          <source>Evaluates an arbitrary shell command in each checked out submodule. The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in &lt;code&gt;.gitmodules&lt;/code&gt;, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject. Note that to avoid conflicts with &lt;code&gt;$PATH&lt;/code&gt; on Windows, the &lt;code&gt;$path&lt;/code&gt; variable is now a deprecated synonym of &lt;code&gt;$sm_path&lt;/code&gt; variable. Any submodules defined in the superproject but not checked out are ignored by this command. Unless given &lt;code&gt;--quiet&lt;/code&gt;, foreach prints the name of each submodule before evaluating the command. If &lt;code&gt;--recursive&lt;/code&gt; is given, submodules are traversed recursively (i.e. the given shell command is evaluated in nested submodules as well). A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding &lt;code&gt;|| :&lt;/code&gt; to the end of the command.</source>
          <target state="translated">Оценивает произвольную команду оболочки в каждом извлеченном подмодуле. Команда имеет доступ к переменным $ name, $ sm_path, $ displaypath, $ sha1 и $ toplevel: $ name - это имя соответствующего раздела подмодуля в &lt;code&gt;.gitmodules&lt;/code&gt; , $ sm_path - это путь к подмодулю, записанный в непосредственном суперпроекте , $ displaypath содержит относительный путь от текущего рабочего каталога к корневому каталогу подмодулей, $ sha1 - это фиксация, записанная в непосредственном суперпроекте, а $ toplevel - это абсолютный путь к верхнему уровню непосредственного суперпроекта. Обратите внимание, что во избежание конфликтов с &lt;code&gt;$PATH&lt;/code&gt; в Windows переменная &lt;code&gt;$path&lt;/code&gt; теперь является устаревшим синонимом &lt;code&gt;$sm_path&lt;/code&gt; переменная. Любые подмодули, определенные в суперпроекте, но не извлеченные, этой командой игнорируются. Если не задано &lt;code&gt;--quiet&lt;/code&gt; , foreach печатает имя каждого подмодуля перед выполнением команды. Если задано &lt;code&gt;--recursive&lt;/code&gt; , подмодули просматриваются рекурсивно (т.е. данная команда оболочки также оценивается во вложенных подмодулях). Ненулевой возврат из команды в любом подмодуле вызывает прекращение обработки. Это можно изменить, добавив &lt;code&gt;|| :&lt;/code&gt; до конца команды.</target>
        </trans-unit>
        <trans-unit id="3346640c72369c22dbe8ece1ce186df75f62b7da" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t need to edit files but only want to e.g. rename or remove some and thus can avoid checking out each file (i.e. you can use --index-filter), you still are passing shell snippets for your filters. This means that for every commit, you have to have a prepared git repo where those filters can be run. That&amp;rsquo;s a significant setup.</source>
          <target state="translated">Даже если вам не нужно редактировать файлы, а нужно только, например, переименовать или удалить некоторые из них и, таким образом, избежать проверки каждого файла (т.е. вы можете использовать --index-filter), вы все равно передаете фрагменты оболочки для своих фильтров. Это означает, что для каждой фиксации у вас должно быть подготовленное репозиторий git, в котором можно запускать эти фильтры. Это важная установка.</target>
        </trans-unit>
        <trans-unit id="5eb6ad0af0ebc64a82d836be8d647670a50936f8" translate="yes" xml:space="preserve">
          <source>Even if you hide refs, a client may still be able to steal the target objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">Даже если вы скроете ссылки, клиент все равно сможет украсть целевые объекты с помощью методов, описанных в разделе &amp;laquo;БЕЗОПАСНОСТЬ&amp;raquo; &lt;a href=&quot;gitnamespaces&quot;&gt;справочной&lt;/a&gt; страницы gitnamespaces [7] ; лучше всего хранить личные данные в отдельном репозитории.</target>
        </trans-unit>
        <trans-unit id="631b3a432b8ec594fabc393b96af10483ed3b9bf" translate="yes" xml:space="preserve">
          <source>Even if you may have local modifications in your working tree, you can safely say &lt;code&gt;git pull&lt;/code&gt; when you know that the change in the other branch does not overlap with them.</source>
          <target state="translated">Даже если у вас могут быть локальные изменения в вашем рабочем дереве, вы можете смело сказать &lt;code&gt;git pull&lt;/code&gt; , если знаете, что изменения в другой ветке не перекрываются с ними.</target>
        </trans-unit>
        <trans-unit id="e9dc426299074d12c83589e674bb08692f265116" translate="yes" xml:space="preserve">
          <source>Even when version sort is used in &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;, tagnames with the same base version but different suffixes are still sorted lexicographically, resulting e.g. in prerelease tags appearing after the main release (e.g. &quot;1.0-rc1&quot; after &quot;1.0&quot;). This variable can be specified to determine the sorting order of tags with different suffixes.</source>
          <target state="translated">Даже когда сортировка версий используется в &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; , тэги с той же базовой версией, но с разными суффиксами по-прежнему сортируются лексикографически, в результате чего, например, предварительные теги появляются после основного выпуска (например, &amp;laquo;1.0-rc1&amp;raquo; после &amp;laquo;1.0&amp;raquo;) , Эта переменная может быть указана для определения порядка сортировки тегов с разными суффиксами.</target>
        </trans-unit>
        <trans-unit id="9e079d1f744d65307fba536fb55c673ed5690ed3" translate="yes" xml:space="preserve">
          <source>Event-Specific Key/Value Pairs</source>
          <target state="translated">Пары ключ/значение,зависящие от события</target>
        </trans-unit>
        <trans-unit id="574b5ade849d92dcfbdbf5ca26c3f1b37761f49f" translate="yes" xml:space="preserve">
          <source>Events are written as lines of the form:</source>
          <target state="translated">События записываются в виде строк формы:</target>
        </trans-unit>
        <trans-unit id="af0aec79a3d13a4c4b91dbf7a8bc02d48eb692d6" translate="yes" xml:space="preserve">
          <source>Eventually the conclusion started with:</source>
          <target state="translated">В конце концов,вывод начался с того:</target>
        </trans-unit>
        <trans-unit id="e1529d50cc2b2be76fa87bc3d3169dd428571183" translate="yes" xml:space="preserve">
          <source>Eventually there will be no more revisions left to inspect, and the command will print out a description of the first bad commit. The reference &lt;code&gt;refs/bisect/bad&lt;/code&gt; will be left pointing at that commit.</source>
          <target state="translated">В конце концов, больше не останется ревизий для проверки, и команда распечатает описание первой неверной фиксации. Ссылка &lt;code&gt;refs/bisect/bad&lt;/code&gt; останется указывающей на этот коммит.</target>
        </trans-unit>
        <trans-unit id="33494a61e10c94c6a655dac5cf7ce556eb778f1d" translate="yes" xml:space="preserve">
          <source>Every change in the history of a project is represented by a commit. The &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command shows the most recent commit on the current branch:</source>
          <target state="translated">Каждое изменение в истории проекта представлено фиксацией. Команда &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; показывает самую последнюю фиксацию в текущей ветке:</target>
        </trans-unit>
        <trans-unit id="c0294fb403c28f35bf86f99624f936e70c163f9d" translate="yes" xml:space="preserve">
          <source>Every commit (except the very first commit in a project) also has a parent commit which shows what happened before this commit. Following the chain of parents will eventually take you back to the beginning of the project.</source>
          <target state="translated">Каждый коммит (кроме самого первого коммита в проекте)также имеет родительский коммит,который показывает,что происходило до этого коммита.Следуя цепочке родительских коммитов,вы в конце концов вернётесь к началу проекта.</target>
        </trans-unit>
        <trans-unit id="2fd9540af511da41e4e859d7e772df1cd2e0716c" translate="yes" xml:space="preserve">
          <source>Every commit has a 40-hexdigit id, sometimes called the &quot;object name&quot; or the &quot;SHA-1 id&quot;, shown on the first line of the &lt;code&gt;git show&lt;/code&gt; output. You can usually refer to a commit by a shorter name, such as a tag or a branch name, but this longer name can also be useful. Most importantly, it is a globally unique name for this commit: so if you tell somebody else the object name (for example in email), then you are guaranteed that name will refer to the same commit in their repository that it does in yours (assuming their repository has that commit at all). Since the object name is computed as a hash over the contents of the commit, you are guaranteed that the commit can never change without its name also changing.</source>
          <target state="translated">Каждая фиксация имеет идентификатор из 40 шестнадцатеричных цифр, иногда называемый &amp;laquo;именем объекта&amp;raquo; или &amp;laquo;идентификатором SHA-1&amp;raquo;, который отображается в первой строке вывода &lt;code&gt;git show&lt;/code&gt; . Обычно вы можете ссылаться на фиксацию по более короткому имени, например, тегу или имени ветки, но это более длинное имя также может быть полезно. Что наиболее важно, это глобально уникальное имя для этого коммита: поэтому, если вы сообщите кому-то другому имя объекта (например, в электронном письме), то вам гарантировано, что это имя будет относиться к тому же коммиту в их репозитории, что и в вашем ( при условии, что в их репозитории есть эта фиксация). Поскольку имя объекта вычисляется как хэш содержимого фиксации, вам гарантируется, что фиксация никогда не может измениться без изменения его имени.</target>
        </trans-unit>
        <trans-unit id="2c58cc3c4a4eeeefba12cfd52db7d6b22833ae51" translate="yes" xml:space="preserve">
          <source>Every commit usually has one &quot;parent&quot; commit which points to the previous state of the project:</source>
          <target state="translated">Каждый коммит обычно имеет один &quot;родительский&quot; коммит,который указывает на предыдущее состояние проекта:</target>
        </trans-unit>
        <trans-unit id="1a873d3296fdc5740fd2d57065300557ff50e9de" translate="yes" xml:space="preserve">
          <source>Every git repository is marked with a numeric version in the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; key of its &lt;code&gt;config&lt;/code&gt; file. This version specifies the rules for operating on the on-disk repository data. An implementation of git which does not understand a particular version advertised by an on-disk repository MUST NOT operate on that repository; doing so risks not only producing wrong results, but actually losing data.</source>
          <target state="translated">Каждый репозиторий git отмечен числовой версией в ключе &lt;code&gt;core.repositoryformatversion&lt;/code&gt; его файла &lt;code&gt;config&lt;/code&gt; . В этой версии указаны правила работы с данными репозитория на диске. Реализация git, которая не понимает конкретную версию, объявленную дисковым репозиторием, НЕ ДОЛЖНА работать с этим репозиторием; это рискует не только дать неверные результаты, но и фактически потерять данные.</target>
        </trans-unit>
        <trans-unit id="62d7b4b8755b9c58dc64c45f9e43e9a1848ebae6" translate="yes" xml:space="preserve">
          <source>Every helper must support the &quot;capabilities&quot; command, which Git uses to determine what other commands the helper will accept. Those other commands can be used to discover and update remote refs, transport objects between the object database and the remote repository, and update the local object store.</source>
          <target state="translated">Каждый помощник должен поддерживать команду &quot;capabilities&quot;,которую Git использует для определения того,какие другие команды он примет.Эти другие команды могут использоваться для обнаружения и обновления удалённых ссылок,транспортировки объектов между базой данных объекта и удалённым хранилищем,а также для обновления локального хранилища объектов.</target>
        </trans-unit>
        <trans-unit id="a5adcecab706a9dd84c1d3eebe8cd1a4069a04b5" translate="yes" xml:space="preserve">
          <source>Every non-overlapping match of the &amp;lt;regex&amp;gt; is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append &lt;code&gt;|[^[:space:]]&lt;/code&gt; to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.</source>
          <target state="translated">Каждое неперекрывающееся совпадение &amp;lt;regex&amp;gt; считается словом. Все, что находится между этими совпадениями, считается пробелом и игнорируется (!) В целях поиска различий. Вы можете добавить &lt;code&gt;|[^[:space:]]&lt;/code&gt; к своему регулярному выражению, чтобы убедиться, что оно соответствует всем непробельным символам. Совпадение, содержащее новую строку, молча обрезается (!) На новой строке.</target>
        </trans-unit>
        <trans-unit id="ca9e8deab33d39332d7b528ab194c9573c58ac97" translate="yes" xml:space="preserve">
          <source>Every notes change creates a new commit at the specified notes ref. You can therefore inspect the history of the notes by invoking, e.g., &lt;code&gt;git log -p notes/commits&lt;/code&gt;. Currently the commit message only records which operation triggered the update, and the commit authorship is determined according to the usual rules (see &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;). These details may change in the future.</source>
          <target state="translated">Каждое изменение примечаний создает новую фиксацию в указанных примечаниях ref. Таким образом, вы можете просмотреть историю заметок, вызвав, например, &lt;code&gt;git log -p notes/commits&lt;/code&gt; . В настоящее время сообщение о фиксации фиксирует только то, какая операция инициировала обновление, а авторство фиксации определяется в соответствии с обычными правилами (см. &lt;a href=&quot;git-commit&quot;&gt;Git-commit [1]&lt;/a&gt; ). Эти детали могут измениться в будущем.</target>
        </trans-unit>
        <trans-unit id="5bfad9a034d5ed29730f0b4fba66efb6b1249b9d" translate="yes" xml:space="preserve">
          <source>Every once in a while have your frontend emit a &lt;code&gt;progress&lt;/code&gt; message to fast-import. The contents of the messages are entirely free-form, so one suggestion would be to output the current month and year each time the current commit date moves into the next month. Your users will feel better knowing how much of the data stream has been processed.</source>
          <target state="translated">Каждый раз в некоторое время ваш интерфейса испускать &lt;code&gt;progress&lt;/code&gt; сообщение для быстрого импорта. Содержимое сообщений имеет совершенно произвольную форму, поэтому можно было бы предложить выводить текущий месяц и год каждый раз, когда текущая дата фиксации перемещается в следующий месяц. Ваши пользователи будут чувствовать себя лучше, зная, какая часть потока данных была обработана.</target>
        </trans-unit>
        <trans-unit id="cda48ad1074123130b527f02f3f1db8c4fd5c129" translate="yes" xml:space="preserve">
          <source>Every once in a while, &lt;code&gt;git repack&lt;/code&gt; the public repository. Go back to step 5. and continue working.</source>
          <target state="translated">Время от времени &lt;code&gt;git repack&lt;/code&gt; публичный репозиторий. Вернитесь к шагу 5. и продолжайте работу.</target>
        </trans-unit>
        <trans-unit id="0196a37f323e9613bd5e5c6dc6db74a2907c6a83" translate="yes" xml:space="preserve">
          <source>Every time a client connects, first run an external command specified by the &amp;lt;path&amp;gt; with service name (e.g. &quot;upload-pack&quot;), path to the repository, hostname (%H), canonical hostname (%CH), IP address (%IP), and TCP port (%P) as its command-line arguments. The external command can decide to decline the service by exiting with a non-zero status (or to allow it by exiting with a zero status). It can also look at the $REMOTE_ADDR and &lt;code&gt;$REMOTE_PORT&lt;/code&gt; environment variables to learn about the requestor when making this decision.</source>
          <target state="translated">Каждый раз, когда клиент подключается, сначала запускайте внешнюю команду, указанную в &amp;lt;path&amp;gt; с именем службы (например, &amp;laquo;upload-pack&amp;raquo;), путем к репозиторию, именем хоста (% H), каноническим именем хоста (% CH), IP-адресом ( % IP) и порт TCP (% P) в качестве аргументов командной строки. Внешняя команда может принять решение об отклонении службы, завершив работу с ненулевым статусом (или разрешив ее, завершив работу с нулевым статусом). Он также может просматривать переменные среды $ REMOTE_ADDR и &lt;code&gt;$REMOTE_PORT&lt;/code&gt; чтобы узнать о запрашивающей стороне при принятии этого решения.</target>
        </trans-unit>
        <trans-unit id="ed1e82e85b3b43f7a452c7545f1946734ba8fe78" translate="yes" xml:space="preserve">
          <source>Everyday Git</source>
          <target state="translated">Ежедневный гит</target>
        </trans-unit>
        <trans-unit id="30edee05f0b86fdef0d1b80bced0b054568a2749" translate="yes" xml:space="preserve">
          <source>Everyday Git With 20 Commands Or So</source>
          <target state="translated">Ежедневный гит с 20 командами или около того.</target>
        </trans-unit>
        <trans-unit id="0043a64d3fef8a7a23f6cd840b45f8af10f67f75" translate="yes" xml:space="preserve">
          <source>Exact byte count format</source>
          <target state="translated">Точный формат подсчёта байтов</target>
        </trans-unit>
        <trans-unit id="6e07117d26445f4c876a2dd689294f11cef857f4" translate="yes" xml:space="preserve">
          <source>Examining an old version without creating a new branch</source>
          <target state="translated">Рассмотрение старой версии без создания новой ветки</target>
        </trans-unit>
        <trans-unit id="d496fa33f8661db7b0850d74bbd80c109526f113" translate="yes" xml:space="preserve">
          <source>Examining branches from a remote repository</source>
          <target state="translated">Исследование ветвей из удаленного репозитория</target>
        </trans-unit>
        <trans-unit id="bb504595062729729e7244c3229ce860c38e6b76" translate="yes" xml:space="preserve">
          <source>Examining dangling objects</source>
          <target state="translated">Осмотр висящих объектов</target>
        </trans-unit>
        <trans-unit id="9cb0f2fbccfd2e1df3b3fea66d90520dda3d9cf1" translate="yes" xml:space="preserve">
          <source>Examining the data</source>
          <target state="translated">Изучение данных</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="cfd85acb33cc1367c953b61c1f0a7ad60c2565a2" translate="yes" xml:space="preserve">
          <source>Example 1: Your history contains commits by two authors, Jane and Joe, whose names appear in the repository under several forms:</source>
          <target state="translated">Пример 1:Ваша история содержит коммиты двух авторов,Джейн и Джо,имена которых появляются в репозитории под несколькими формами:</target>
        </trans-unit>
        <trans-unit id="aa58f391e50840be9e94b87f72faa5f731cb5766" translate="yes" xml:space="preserve">
          <source>Example 2: Your repository contains commits from the following authors:</source>
          <target state="translated">Пример 2:Ваш репозиторий содержит коммиты от следующих авторов:</target>
        </trans-unit>
        <trans-unit id="8a76cea78511b0d3032b5011d701b256e4fa824c" translate="yes" xml:space="preserve">
          <source>Example contents:</source>
          <target state="translated">Пример содержания:</target>
        </trans-unit>
        <trans-unit id="ee2fa80210fe959342ddb79b523484b1b7a07d33" translate="yes" xml:space="preserve">
          <source>Example to exclude everything except a specific directory &lt;code&gt;foo/bar&lt;/code&gt; (note the &lt;code&gt;/*&lt;/code&gt; - without the slash, the wildcard would also exclude everything within &lt;code&gt;foo/bar&lt;/code&gt;):</source>
          <target state="translated">Пример для исключения всего, кроме определенной директории &lt;code&gt;foo/bar&lt;/code&gt; (обратите внимание на &lt;code&gt;/*&lt;/code&gt; - без косой черты подстановочный знак также исключит все, что находится внутри &lt;code&gt;foo/bar&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="59e08af9047abc909e804faec8919301def86320" translate="yes" xml:space="preserve">
          <source>Example trace2 api usage</source>
          <target state="translated">Пример использования трассы2 api</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="523ae6b1873ceced0f776c362dc256ed64902255" translate="yes" xml:space="preserve">
          <source>Example: If you know that there was some test case for &lt;code&gt;git bundle&lt;/code&gt;, but do not remember where it was (yes, you &lt;code&gt;could&lt;/code&gt;&lt;code&gt;git grep bundle t/&lt;/code&gt;, but that does not illustrate the point!):</source>
          <target state="translated">Пример: если вы знаете, что был какой-то тестовый пример для &lt;code&gt;git bundle&lt;/code&gt; , но не помните, где он был (да, вы &lt;code&gt;could&lt;/code&gt; &lt;code&gt;git grep bundle t/&lt;/code&gt; , но это не иллюстрирует суть!):</target>
        </trans-unit>
        <trans-unit id="14e4d3109673cecf5094a599bce7b8cb418a458c" translate="yes" xml:space="preserve">
          <source>Example: Let commits &lt;code&gt;1--2&lt;/code&gt; be the first iteration of a patch series and &lt;code&gt;A--C&lt;/code&gt; the second iteration. Let&amp;rsquo;s assume that &lt;code&gt;A&lt;/code&gt; is a cherry-pick of &lt;code&gt;2,&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; is a cherry-pick of &lt;code&gt;1&lt;/code&gt; but with a small modification (say, a fixed typo). Visualize the commits as a bipartite graph:</source>
          <target state="translated">Пример: пусть коммиты &lt;code&gt;1--2&lt;/code&gt; будут первой итерацией серии патчей, а &lt;code&gt;A--C&lt;/code&gt; - второй итерацией. Предположим, что &lt;code&gt;A&lt;/code&gt; - это выбор из &lt;code&gt;2,&lt;/code&gt; а &lt;code&gt;C&lt;/code&gt; - выбор из &lt;code&gt;1&lt;/code&gt; , но с небольшой модификацией (скажем, исправленной опечаткой). Визуализируйте коммиты как двудольный граф:</target>
        </trans-unit>
        <trans-unit id="d3bad2d15f343f55dc9f681daca1b6f3326d18b3" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">Пример: Следующее будет подсчитывать измененные файлы, игнорируя каталоги с менее чем 10% от общего количества измененных файлов, и накапливая счетчики дочерних каталогов в родительских каталогах: &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5998a18b5c87282a79f47b763c8725aa5e8349e" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">Пример: Следующее будет подсчитывать измененные файлы, игнорируя каталоги с менее чем 10% от общего количества измененных файлов, и накапливая счетчики дочерних каталогов в родительских каталогах: &lt;code&gt;files,10,cumulative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fe9add2c66b1dd7342bec4baea68d566885937" translate="yes" xml:space="preserve">
          <source>Example: let&amp;rsquo;s say I had renamed &lt;code&gt;commit.c&lt;/code&gt; to &lt;code&gt;git-commit.c&lt;/code&gt;, and I had done an &lt;code&gt;update-index&lt;/code&gt; to make that effective in the index file. &lt;code&gt;git diff-files&lt;/code&gt; wouldn&amp;rsquo;t show anything at all, since the index file matches my working directory. But doing a &lt;code&gt;git diff-index&lt;/code&gt; does:</source>
          <target state="translated">Пример: скажем, я переименовал &lt;code&gt;commit.c&lt;/code&gt; в &lt;code&gt;git-commit.c&lt;/code&gt; , и я сделал &lt;code&gt;update-index&lt;/code&gt; , чтобы сделать это эффективным в индексном файле. &lt;code&gt;git diff-files&lt;/code&gt; вообще ничего не покажет, так как индексный файл соответствует моему рабочему каталогу. Но выполнение &lt;code&gt;git diff-index&lt;/code&gt; делает:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="22540b4db15515332cef1b1a56998eebfeba111a" translate="yes" xml:space="preserve">
          <source>Examples for &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt; without &lt;code&gt;--combined-all-paths&lt;/code&gt;:</source>
          <target state="translated">Примеры для &lt;code&gt;-c&lt;/code&gt; и &lt;code&gt;--cc&lt;/code&gt; без &lt;code&gt;--combined-all-paths&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6ba2b2f11f2e1285e022c78a54e28e01334ece54" translate="yes" xml:space="preserve">
          <source>Examples when &lt;code&gt;--combined-all-paths&lt;/code&gt; added to either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt;:</source>
          <target state="translated">Примеры &lt;code&gt;--combined-all-paths&lt;/code&gt; к &lt;code&gt;-c&lt;/code&gt; или &lt;code&gt;--cc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b280d2c89a83a2bacb63527574e5853bea86f936" translate="yes" xml:space="preserve">
          <source>Examples.</source>
          <target state="translated">Examples.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="24d0d5f830ca936a2b1158c4418847e58a17c132" translate="yes" xml:space="preserve">
          <source>Except for the &lt;code&gt;simple&lt;/code&gt; variant, command-line parameters are likely to change as git gains new features.</source>
          <target state="translated">За исключением &lt;code&gt;simple&lt;/code&gt; варианта, параметры командной строки, вероятно, изменятся по мере появления новых функций git.</target>
        </trans-unit>
        <trans-unit id="16cb9d6dc5634fc561d2d614f979976dfee73770" translate="yes" xml:space="preserve">
          <source>Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents.</source>
          <target state="translated">За исключением слияния в ускоренном режиме (см.выше),ветви,подлежащие слиянию,должны быть связаны между собой коммитом слияния,родителями которого являются обе ветви.</target>
        </trans-unit>
        <trans-unit id="262c2a4eb81a10a2c9efd3343c2ae85fe92bbd6e" translate="yes" xml:space="preserve">
          <source>Exclude commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">Исключить коммиты, доступные из &amp;lt;rev&amp;gt; (т.е. &amp;lt;rev&amp;gt; и его предков).</target>
        </trans-unit>
        <trans-unit id="f270c263f13543cd4c2b3020f92a691a85883aa7" translate="yes" xml:space="preserve">
          <source>Exclude patterns</source>
          <target state="translated">Исключить закономерности</target>
        </trans-unit>
        <trans-unit id="87263b3bb52abcdab4a719253ddba1eca4b803f6" translate="yes" xml:space="preserve">
          <source>Exclude selected depot paths when cloning or syncing.</source>
          <target state="translated">Исключите выбранные пути депо при клонировании или синхронизации.</target>
        </trans-unit>
        <trans-unit id="80be5859c8610b0a7e5a0e2227ba09cb8e75bd2e" translate="yes" xml:space="preserve">
          <source>Exclude the given pack from repacking. This is the equivalent of having &lt;code&gt;.keep&lt;/code&gt; file on the pack. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">Исключить данную пачку из переупаковки. Это эквивалент наличия файла &lt;code&gt;.keep&lt;/code&gt; в пакете. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; - это имя файла пакета без ведущего каталога (например, &lt;code&gt;pack-123.pack&lt;/code&gt; ). Опция может быть указана несколько раз, чтобы хранить несколько пакетов.</target>
        </trans-unit>
        <trans-unit id="c21ad96ce2991b5c76c93826f8c1c709d756ef00" translate="yes" xml:space="preserve">
          <source>Exclude the specified patterns from the log decorations. This is similar to the &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; command-line option, but the config option can be overridden by the &lt;code&gt;--decorate-refs&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f719c666cee23f0f1f956fb1a3762ec3484afe81" translate="yes" xml:space="preserve">
          <source>Existing trailers are extracted from the input message by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers. The group must be preceded by one or more empty (or whitespace-only) lines. The group must either be at the end of the message or be the last non-whitespace lines before a line that starts with &lt;code&gt;---&lt;/code&gt; (followed by a space or the end of the line). Such three minus signs start the patch part of the message. See also &lt;code&gt;--no-divider&lt;/code&gt; below.</source>
          <target state="translated">Существующие трейлеры извлекаются из входного сообщения путем поиска группы из одной или нескольких строк, которые (i) все трейлеры, или (ii) содержат по крайней мере один трейлер, созданный Git или настроенный пользователем, и состоят как минимум из 25% трейлеров. , Группе должна предшествовать одна или несколько пустых (или только пробельных) строк. Группа должна быть либо в конце сообщения, либо быть последней строкой без пробелов перед строкой, которая начинается с &lt;code&gt;---&lt;/code&gt; (за которым следует пробел или конец строки). Такие три знака &amp;laquo;минус&amp;raquo; начинают патч-часть сообщения. См. Также &lt;code&gt;--no-divider&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="d3460174eb1c6ec5b3dd3ca9e87848d068de28a1" translate="yes" xml:space="preserve">
          <source>Exit code between 128 and 255 are special to &quot;git bisect run&quot;. They make it stop immediately the bisection process. This is useful for example if the command passed takes too long to complete, because you can kill it with a signal and it will stop the bisection process.</source>
          <target state="translated">Выходной код между 128 и 255 специальными для &quot;git-бисектного прогона&quot;.Они заставляют его немедленно остановить бисектный процесс.Это полезно,например,если переданная команда занимает слишком много времени,потому что можно убить её сигналом,и она остановит биссексуальный процесс.</target>
        </trans-unit>
        <trans-unit id="1de8b457f24c5f9f27dc6145c115a0b05b79738e" translate="yes" xml:space="preserve">
          <source>Exit difftool if the invoked diff tool returns a non-zero exit status.</source>
          <target state="translated">Выход из difftool,если вызываемый инструмент diff возвращает ненулевой статус выхода.</target>
        </trans-unit>
        <trans-unit id="105ec316e78b2e21f4200658aebb690c6bfce1c8" translate="yes" xml:space="preserve">
          <source>Exit status</source>
          <target state="translated">Статус выхода</target>
        </trans-unit>
        <trans-unit id="3a152e1aa09a1f7c436eafcd44ff191b58dde03b" translate="yes" xml:space="preserve">
          <source>Exit with a zero status even if no files matched.</source>
          <target state="translated">Выход с нулевым статусом,даже если файлы не совпадают.</target>
        </trans-unit>
        <trans-unit id="f661c1461c19e28f4ca3bd981e37f108a510e5f9" translate="yes" xml:space="preserve">
          <source>Exit with status &quot;2&quot; when no matching refs are found in the remote repository. Usually the command exits with status &quot;0&quot; to indicate it successfully talked with the remote repository, whether it found any matching refs.</source>
          <target state="translated">Выход со статусом &quot;2&quot;,когда в удаленном репозитории не найдено ни одного совпадающего ссылки.Обычно команда выходит со статусом &quot;0&quot;,чтобы показать,что она успешно общалась с удаленным репозиторием,независимо от того,нашла ли она соответствующие ссылки.</target>
        </trans-unit>
        <trans-unit id="a5a799b0a561590f135d49ee5ebae00be685efb3" translate="yes" xml:space="preserve">
          <source>Exit with zero status if &amp;lt;object&amp;gt; exists and is a valid object. If &amp;lt;object&amp;gt; is of an invalid format exit with non-zero and emits an error on stderr.</source>
          <target state="translated">Выйти с нулевым статусом, если &amp;lt;объект&amp;gt; существует и является допустимым объектом. Если &amp;lt;объект&amp;gt; имеет недопустимый формат, выйдите с ненулевым значением и выдает ошибку на stderr.</target>
        </trans-unit>
        <trans-unit id="a4fd2157951095e7b5d26b7c3906810fced8fee9" translate="yes" xml:space="preserve">
          <source>Expand the URL of the given remote repository taking into account any &quot;url.&amp;lt;base&amp;gt;.insteadOf&quot; config setting (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) and exit without talking to the remote.</source>
          <target state="translated">Разверните URL-адрес данного удаленного репозитория с учетом любого параметра конфигурации &quot;url. &amp;lt;base&amp;gt; .insteadOf&quot; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ) и выйдите, не разговаривая с удаленным компьютером.</target>
        </trans-unit>
        <trans-unit id="82a1b2399131b1d56f52c1e5725ea0754c8c3b25" translate="yes" xml:space="preserve">
          <source>Experimental. If set, clients will attempt to communicate with a server using the specified protocol version. If unset, no attempt will be made by the client to communicate using a particular protocol version, this results in protocol version 0 being used. Supported versions:</source>
          <target state="translated">Экспериментально.Если установлено,то клиенты будут пытаться взаимодействовать с сервером,используя указанную версию протокола.Если эта опция не установлена,то клиент не будет пытаться взаимодействовать с сервером,используя определенную версию протокола,в результате чего будет использоваться версия протокола 0.Поддерживаемые версии:</target>
        </trans-unit>
        <trans-unit id="374e58867af910990ca1f09ab8f9576e68a9b14e" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Can attempt to connect to a remote server for communication using git&amp;rsquo;s wire-protocol version 2. See the documentation for the stateless-connect command for more information.</source>
          <target state="translated">Экспериментальная; только для внутреннего использования. Может попытаться подключиться к удаленному серверу для связи с помощью git wire-protocol версии 2. Дополнительную информацию см. В документации по команде stateless-connect.</target>
        </trans-unit>
        <trans-unit id="a6c1ea190613127e3c33180eee19de027a289612" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. Response messages will then have a response end packet after the flush packet to indicate the end of a response. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed48ec751df29bb5c7b56db740a48bfdffd6f47" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="translated">Экспериментальная; только для внутреннего использования. Подключается к данной удаленной службе для связи с использованием проводного протокола git версии 2. Допустимые ответы на эту команду: пустая строка (соединение установлено), &lt;code&gt;fallback&lt;/code&gt; (без поддержки интеллектуального транспорта, откат к немым транспортным средствам) и просто выход с напечатанным сообщением об ошибке ( не могу подключиться, не пытайтесь отступить). После того, как перевод строки завершает положительный (пустой) ответ, запускается вывод службы. Сообщения (как запрос, так и ответ) должны состоять из нуля или более строк PKT-LINE, оканчивающихся пакетом очистки. Клиент не должен ожидать, что сервер сохранит какое-либо состояние между парами запрос-ответ. После завершения соединения удаленный помощник завершает работу.</target>
        </trans-unit>
        <trans-unit id="e024c1b1cf5dfc23f1661897286cc082f5684cef" translate="yes" xml:space="preserve">
          <source>Expire all reflogs with &lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt;.</source>
          <target state="translated">Удалите все рефлоги с помощью &lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f38f9dff86033ea204fa903651e0d6603ef28dd" translate="yes" xml:space="preserve">
          <source>Explicitly allow or ban the object filter corresponding to &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt; may be one of: &lt;code&gt;blob:none&lt;/code&gt;, &lt;code&gt;blob:limit&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;sparse:oid&lt;/code&gt;, or &lt;code&gt;combine&lt;/code&gt;. If using combined filters, both &lt;code&gt;combine&lt;/code&gt; and all of the nested filter kinds must be allowed. Defaults to &lt;code&gt;uploadpackfilter.allow&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5da57f58adf9c1ddf8dd03613cf7957a586adf" translate="yes" xml:space="preserve">
          <source>Exploring git history</source>
          <target state="translated">Изучение истории гитов</target>
        </trans-unit>
        <trans-unit id="89032b84259ca753da6ee3335cc874eda5aea88c" translate="yes" xml:space="preserve">
          <source>Exploring history</source>
          <target state="translated">Изучение истории</target>
        </trans-unit>
        <trans-unit id="9594b6cd33e22cedcea0b51e30d878456e8b0103" translate="yes" xml:space="preserve">
          <source>Export Git tags to p4 labels, as per --export-labels.</source>
          <target state="translated">Экспорт Git-тегов в этикетки p4,в соответствии с-экспортными этикетками.</target>
        </trans-unit>
        <trans-unit id="1d5637309048195a7021fdbec654e04c3399ceec" translate="yes" xml:space="preserve">
          <source>Export a single commit to a CVS checkout</source>
          <target state="translated">Экспорт одного коммита в CVS-кассу.</target>
        </trans-unit>
        <trans-unit id="3b1e75b4d51f1271061fcd403a0829e4ee2dbe12" translate="yes" xml:space="preserve">
          <source>Export files with a prefix</source>
          <target state="translated">Экспорт файлов с префиксом</target>
        </trans-unit>
        <trans-unit id="265e5cf875ec82b17c2d01a82792a32a43a95b55" translate="yes" xml:space="preserve">
          <source>Export tags from Git as p4 labels. Tags found in Git are applied to the perforce working directory.</source>
          <target state="translated">Экспортные метки из Git'а в виде этикеток p4.Тэги,найденные в Git'е,применяются к рабочей директории perforce.</target>
        </trans-unit>
        <trans-unit id="e1e5965077094d7c4756e516413e72a854f313c9" translate="yes" xml:space="preserve">
          <source>Exporting a Git repository via the Git protocol</source>
          <target state="translated">Экспорт Git-репозитория по Git-протоколу.</target>
        </trans-unit>
        <trans-unit id="70581f8681dac905a7c1fddd025df98d77759bfd" translate="yes" xml:space="preserve">
          <source>Exporting a git repository via HTTP</source>
          <target state="translated">Экспорт git-репозитория по HTTP</target>
        </trans-unit>
        <trans-unit id="7d0c2b669436b3c66b28c30bf0f8b2f1227f2bfb" translate="yes" xml:space="preserve">
          <source>Exports a commit from Git to a CVS checkout, making it easier to merge patches from a Git repository into a CVS repository.</source>
          <target state="translated">Экспорт коммита из Git'а в CVS-репозиторий,что облегчает слияние патчей из Git-репозитория в CVS-репозиторий.</target>
        </trans-unit>
        <trans-unit id="91d81689bc4c223caafef827873bd7159612ae71" translate="yes" xml:space="preserve">
          <source>External Systems</source>
          <target state="translated">Внешние системы</target>
        </trans-unit>
        <trans-unit id="fa9abe3df3ff3676c618be0248e4529ceae9c936" translate="yes" xml:space="preserve">
          <source>External data format</source>
          <target state="translated">Формат внешних данных</target>
        </trans-unit>
        <trans-unit id="0b01e11ac46c849a71c428abcd94e12009d5387f" translate="yes" xml:space="preserve">
          <source>Extract all commits that lead to &lt;code&gt;origin&lt;/code&gt; since the inception of the project:</source>
          <target state="translated">Извлеките все коммиты, ведущие к &lt;code&gt;origin&lt;/code&gt; с момента создания проекта:</target>
        </trans-unit>
        <trans-unit id="86dd39e46e8ada53c01392c7b98857ff781b5490" translate="yes" xml:space="preserve">
          <source>Extract all commits which are in the current branch but not in the origin branch:</source>
          <target state="translated">Извлечь все коммиты,которые находятся в текущей ветке,но не в исходной ветке:</target>
        </trans-unit>
        <trans-unit id="293a4ac8183e30cb22a3c912e62cea8f83a17a45" translate="yes" xml:space="preserve">
          <source>Extract commit ID from an archive created using git-archive</source>
          <target state="translated">Извлечь идентификатор коммита из архива,созданного с помощью git-архива</target>
        </trans-unit>
        <trans-unit id="e52c75685be818f69a594f72535500e2b5f0de7d" translate="yes" xml:space="preserve">
          <source>Extract commits between revisions R1 and R2, and apply them on top of the current branch using &lt;code&gt;git am&lt;/code&gt; to cherry-pick them:</source>
          <target state="translated">Извлеките коммиты между ревизиями R1 и R2 и примените их поверх текущей ветки, используя &lt;code&gt;git am&lt;/code&gt; , чтобы выделить их:</target>
        </trans-unit>
        <trans-unit id="a8d5387dbff833fee6e262477f3c484440daa076" translate="yes" xml:space="preserve">
          <source>Extract the last commit as a patch, and add a &lt;code&gt;Cc&lt;/code&gt; and a &lt;code&gt;Reviewed-by&lt;/code&gt; trailer to it:</source>
          <target state="translated">Извлеките последний коммит как патч и добавьте к нему трейлер &lt;code&gt;Cc&lt;/code&gt; и &lt;code&gt;Reviewed-by&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d9851ec1c9a62576efac72204eb04797ad73e77a" translate="yes" xml:space="preserve">
          <source>Extract three topmost commits from the current branch and format them as e-mailable patches:</source>
          <target state="translated">Извлеките три самых верхних коммита из текущей ветки и отформатируйте их как патчи для отправки по электронной почте:</target>
        </trans-unit>
        <trans-unit id="849870ce78e05c63608a62580dff149aaa2767a8" translate="yes" xml:space="preserve">
          <source>Extracted diagnostics</source>
          <target state="translated">Извлеченная диагностика</target>
        </trans-unit>
        <trans-unit id="fd728d82ed551d8e8658407681eee58615e4b172" translate="yes" xml:space="preserve">
          <source>Extracts patch and authorship from a single e-mail message</source>
          <target state="translated">Извлекает патч и авторство из одного сообщения электронной почты.</target>
        </trans-unit>
        <trans-unit id="77dbd3520a3a25fa2f64b3a79e8cdd2c5b438dfc" translate="yes" xml:space="preserve">
          <source>False by default.</source>
          <target state="translated">Ложь по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8f5880afd2dba5ba402b936eb6b908e040c6c17a" translate="yes" xml:space="preserve">
          <source>Fast-forward merge</source>
          <target state="translated">Быстрое слияние</target>
        </trans-unit>
        <trans-unit id="235360a9581b02e6b66f950074d19d23f01883c5" translate="yes" xml:space="preserve">
          <source>Fast-forward merges</source>
          <target state="translated">Быстрые слияния</target>
        </trans-unit>
        <trans-unit id="4b4c24663902945e814f463b99629f081662828a" translate="yes" xml:space="preserve">
          <source>Features in &lt;code&gt;%feature&lt;/code&gt;</source>
          <target state="translated">Функции в &lt;code&gt;%feature&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac7a3c81a6bcc5d5ecdbb8a42e39a3cabf204420" translate="yes" xml:space="preserve">
          <source>Fetch &amp;lt;n&amp;gt; log entries per request when scanning Subversion history. The default is 100. For very large Subversion repositories, larger values may be needed for &lt;code&gt;clone&lt;/code&gt;/&lt;code&gt;fetch&lt;/code&gt; to complete in reasonable time. But overly large values may lead to higher memory usage and request timeouts.</source>
          <target state="translated">Получать &amp;lt;n&amp;gt; записей журнала по запросу при сканировании истории Subversion. Значение по умолчанию - 100. Для очень больших репозиториев Subversion могут потребоваться более &lt;code&gt;fetch&lt;/code&gt; для завершения &lt;code&gt;clone&lt;/code&gt; / выборки за разумное время. Но слишком большие значения могут привести к более высокому использованию памяти и тайм-аутам запросов.</target>
        </trans-unit>
        <trans-unit id="5fa9cbd39c84571e7bd481863d7516ff6663aa26" translate="yes" xml:space="preserve">
          <source>Fetch a &quot;thin&quot; pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic.</source>
          <target state="translated">Получить &quot;тонкий&quot; пакет,который записывает объекты в расслоенном виде на основе объектов,не входящих в пакет,чтобы уменьшить сетевой трафик.</target>
        </trans-unit>
        <trans-unit id="bfa61173eb5ea4c62442430cdd5a0f9a2ccdc304" translate="yes" xml:space="preserve">
          <source>Fetch a branch from a different repository, and give it a new name in your repository:</source>
          <target state="translated">Возьмите ветку из другого репозитория и дайте ей новое имя в вашем репозитории:</target>
        </trans-unit>
        <trans-unit id="5f0a6423762963194f97ca1e3c9e8131a33fa3bd" translate="yes" xml:space="preserve">
          <source>Fetch a branch in a different Git repository, then merge into the current branch:</source>
          <target state="translated">Получите ответвление в другом Git-репозитории,затем слияние в текущее:</target>
        </trans-unit>
        <trans-unit id="4b2c92720b4e036e2e3a513a4ac4888b092fd45b" translate="yes" xml:space="preserve">
          <source>Fetch all remote refs.</source>
          <target state="translated">Приведите всех удаленных рефери.</target>
        </trans-unit>
        <trans-unit id="fc6f62670a87982450c7fd1465c966b498d51b73" translate="yes" xml:space="preserve">
          <source>Fetch all remotes.</source>
          <target state="translated">Принесите все пульты.</target>
        </trans-unit>
        <trans-unit id="7176a82579f2b775ede7e6b5698f625105e5e80d" translate="yes" xml:space="preserve">
          <source>Fetch all tags from the remote (i.e., fetch remote tags &lt;code&gt;refs/tags/*&lt;/code&gt; into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see &lt;code&gt;--prune&lt;/code&gt;).</source>
          <target state="translated">Получение всех тегов с удаленного устройства (т.е. получение удаленных тегов &lt;code&gt;refs/tags/*&lt;/code&gt; в локальные теги с тем же именем) в дополнение к тому, что в противном случае было бы получено. Использование только этой опции не подвергает теги сокращению, даже если используется --prune (хотя теги могут быть сокращены в любом случае, если они также являются адресатом явного refspec; см. &lt;code&gt;--prune&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="24eb114caf72bd86613f02567ef244ced32c67f3" translate="yes" xml:space="preserve">
          <source>Fetch branches and/or tags (collectively, &quot;refs&quot;) from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of &amp;lt;refspec&amp;gt; below for ways to control this behavior).</source>
          <target state="translated">Получение веток и / или тегов (совместно именуемых &amp;laquo;refs&amp;raquo;) из одного или нескольких других репозиториев вместе с объектами, необходимыми для завершения их историй. Обновлены ветви удаленного отслеживания (способы управления этим поведением см. В описании &amp;lt;refspec&amp;gt; ниже).</target>
        </trans-unit>
        <trans-unit id="31082e75ce46d9d1d50a3e2e4d3442657ed8677f" translate="yes" xml:space="preserve">
          <source>Fetch from and integrate with another repository or a local branch</source>
          <target state="translated">Захват и интеграция с другим репозиторием или локальным филиалом.</target>
        </trans-unit>
        <trans-unit id="31bd9486b123aa2097f6934aa8fc09cb0582f241" translate="yes" xml:space="preserve">
          <source>Fetch master, using file descriptor #17 to communicate with git-upload-pack.</source>
          <target state="translated">Fetch master,используя файловый дескриптор #17 для связи с git-upload-pack.</target>
        </trans-unit>
        <trans-unit id="c7b7a55dc86420061c3ee2c8e313312034e265da" translate="yes" xml:space="preserve">
          <source>Fetch only from the SVN parent of the current HEAD.</source>
          <target state="translated">Извлекайте только из SVN-родителя текущего HEAD.</target>
        </trans-unit>
        <trans-unit id="ab869fa62e8a09f8f5c922fc9c36375323cdbbc8" translate="yes" xml:space="preserve">
          <source>Fetch unfetched revisions from the Subversion remote we are tracking. The name of the [svn-remote &quot;&amp;hellip;​&quot;] section in the $GIT_DIR/config file may be specified as an optional command-line argument.</source>
          <target state="translated">Получить невыгруженные ревизии с удаленного устройства Subversion, которое мы отслеживаем. Имя раздела [svn-remote &quot;&amp;hellip;&quot;] в файле $ GIT_DIR / config может быть указано как необязательный аргумент командной строки.</target>
        </trans-unit>
        <trans-unit id="280e77f3e0aa84ca742f26ca190cb5692edeefd2" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by &lt;code&gt;remotes.&amp;lt;group&amp;gt;&lt;/code&gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter &lt;code&gt;remote.&amp;lt;name&amp;gt;.skipDefaultUpdate&lt;/code&gt; set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15a003694d110886a95c99728ccaa08a956586a4" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by remotes.&amp;lt;group&amp;gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter remote.&amp;lt;name&amp;gt;.skipDefaultUpdate set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Получение обновлений для пультов или удаленных групп в репозитории, как определено в remotes. &amp;lt;group&amp;gt;. Если в командной строке не указано ни group, ни remote, будет использоваться параметр конфигурации remotes.default; Если remotes.default не определен, будут обновлены все пульты, для которых параметр конфигурации remote. &amp;lt;name&amp;gt; .skipDefaultUpdate не имеет значения true. (См. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="82e98a6b98be0542f3ca46bd6c66454d11bde6bb" translate="yes" xml:space="preserve">
          <source>Fetches the given object, writing the necessary objects to the database. Fetch commands are sent in a batch, one per line, terminated with a blank line. Outputs a single blank line when all fetch commands in the same batch are complete. Only objects which were reported in the output of &lt;code&gt;list&lt;/code&gt; with a sha1 may be fetched this way.</source>
          <target state="translated">Выбирает данный объект, записывая необходимые объекты в базу данных. Команды выборки отправляются пакетами, по одной в строке, и завершаются пустой строкой. Выводит одну пустую строку, когда все команды выборки в одном пакете завершены. Таким образом могут быть извлечены только те объекты, которые были указаны в выводе &lt;code&gt;list&lt;/code&gt; с помощью sha1.</target>
        </trans-unit>
        <trans-unit id="5e512ef616863b90580db01bc69e67097028beb3" translate="yes" xml:space="preserve">
          <source>Fetching a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to get the branch&amp;rsquo;s &lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt; from a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, to find out which objects are missing from the local &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and to get them, too. See also &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">Получение &lt;a href=&quot;#def_branch&quot;&gt;ветки&lt;/a&gt; означает получение &lt;a href=&quot;#def_head_ref&quot;&gt;ссылки&lt;/a&gt; на заголовок ветки из удаленного &lt;a href=&quot;#def_repository&quot;&gt;репозитория&lt;/a&gt; , чтобы узнать, какие объекты отсутствуют в локальной &lt;a href=&quot;#def_object_database&quot;&gt;базе данных объектов&lt;/a&gt; , а также получить их. См. Также &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca528f4260a5f0ff38dd8302ddb33ede05c8ee7e" translate="yes" xml:space="preserve">
          <source>Fetching branches from other repositories</source>
          <target state="translated">Сбор ветвей из других репозиториев</target>
        </trans-unit>
        <trans-unit id="38fdecc5037849cb76e9ff10175400ab8d8520f4" translate="yes" xml:space="preserve">
          <source>Fetching from a remote repository is done by, unsurprisingly, &lt;code&gt;git fetch&lt;/code&gt;:</source>
          <target state="translated">Неудивительно, что загрузка из удаленного репозитория выполняется с помощью &lt;code&gt;git fetch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="66837c163f00048d36bcb5882cef29f3589ed957" translate="yes" xml:space="preserve">
          <source>Fetching individual branches</source>
          <target state="translated">Приобретение отдельных ветвей</target>
        </trans-unit>
        <trans-unit id="95fb769cdd33ccd5fcde15b12c59c0228df81279" translate="yes" xml:space="preserve">
          <source>Field names</source>
          <target state="translated">Названия полей</target>
        </trans-unit>
        <trans-unit id="7d4e1fd5661dae539542971bb6b2fc728d599c94" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component.</source>
          <target state="translated">Поля , которые имеют имя-почта-дату кортежа в качестве значения ( &lt;code&gt;author&lt;/code&gt; , &lt;code&gt;committer&lt;/code&gt; и &lt;code&gt;tagger&lt;/code&gt; ) может быть суффикс &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; и &lt;code&gt;date&lt;/code&gt; для извлечения имени компоненты.</target>
        </trans-unit>
        <trans-unit id="f890c334357c63fe5c4a4300d447bac89c08dc17" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component. For email fields (&lt;code&gt;authoremail&lt;/code&gt;, &lt;code&gt;committeremail&lt;/code&gt; and &lt;code&gt;taggeremail&lt;/code&gt;), &lt;code&gt;:trim&lt;/code&gt; can be appended to get the email without angle brackets, and &lt;code&gt;:localpart&lt;/code&gt; to get the part before the &lt;code&gt;@&lt;/code&gt; symbol out of the trimmed email.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed2ff2065be5f4efd23916d9b5c024804bb05ec6" translate="yes" xml:space="preserve">
          <source>Fields use modified URI encoding, defined in RFC 3986, section 2.1 (Percent-Encoding), or rather &quot;Query string encoding&quot; (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encoding&lt;/a&gt;), the difference being that SP (&quot; &quot;) can be encoded as &quot;+&quot; (and therefore &quot;+&quot; has to be also percent-encoded).</source>
          <target state="translated">В полях используется измененная кодировка URI, определенная в RFC 3986, раздел 2.1 (Процентное кодирование), или, скорее, &amp;laquo;Кодировка строки запроса&amp;raquo; (см. &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;Https://en.wikipedia.org/wiki/Query_string#URL_encoding&lt;/a&gt; ), разница в том, что SP (&quot;&quot;) можно закодировать как &quot;+&quot; (и, следовательно, &quot;+&quot; также должен быть закодирован в процентах).</target>
        </trans-unit>
        <trans-unit id="ff9cc1a6f5bb5a91d014bd56871d8a7e6dedf925" translate="yes" xml:space="preserve">
          <source>Fighting regressions overview</source>
          <target state="translated">Обзор регрессий в борьбе</target>
        </trans-unit>
        <trans-unit id="dc286ffc3d263eab0659e5254ed6cbdfe1ed4661" translate="yes" xml:space="preserve">
          <source>Figuring out why this works is left as an exercise to the (advanced) student. The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;, and &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object[1]&lt;/a&gt; man pages may prove helpful.</source>
          <target state="translated">Разобраться, почему это работает, оставлено в качестве упражнения для (продвинутого) студента. &lt;a href=&quot;git-log&quot;&gt;ГИТ-журнал [1]&lt;/a&gt; , &lt;a href=&quot;git-diff-tree&quot;&gt;ГИТ-Diff-дерево [1]&lt;/a&gt; , и &lt;a href=&quot;git-hash-object&quot;&gt;ГИТ-хэш-объект [1]&lt;/a&gt; человек страниц может оказаться полезным.</target>
        </trans-unit>
        <trans-unit id="39b2ed94cef5d6961eea0620d66a925578f2f283" translate="yes" xml:space="preserve">
          <source>File containing the SSL certificate when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="translated">Файл, содержащий сертификат SSL при получении или передаче по HTTPS. Может быть переопределено переменной окружения &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3b34071a7a6143f1cfbfe18d8122a378b6725a7" translate="yes" xml:space="preserve">
          <source>File containing the SSL private key when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="translated">Файл, содержащий закрытый ключ SSL при получении или передаче через HTTPS. Может быть переопределено переменной окружения &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a25f7e6a9a15db1a7bb16a1513a308705fbf008c" translate="yes" xml:space="preserve">
          <source>File containing the certificates to verify the peer with when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; environment variable.</source>
          <target state="translated">Файл, содержащий сертификаты для проверки однорангового узла при получении или передаче по HTTPS. Может быть переопределено переменной окружения &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51de61b9fb1649e39093ab80c2a7df2f9e16643a" translate="yes" xml:space="preserve">
          <source>File globbing matches across directory boundaries. Thus, given two directories &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;, there is a difference between using &lt;code&gt;git rm 'd*'&lt;/code&gt; and &lt;code&gt;git rm 'd/*'&lt;/code&gt;, as the former will also remove all of directory &lt;code&gt;d2&lt;/code&gt;.</source>
          <target state="translated">Подстановка файлов соответствует границам каталогов. Таким образом, учитывая два каталога &lt;code&gt;d&lt;/code&gt; и &lt;code&gt;d2&lt;/code&gt; , существует разница между использованием &lt;code&gt;git rm 'd*'&lt;/code&gt; и &lt;code&gt;git rm 'd/*'&lt;/code&gt; , поскольку первый также удалит весь каталог &lt;code&gt;d2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46bdca067f191e47ac236c4a9946147313edeadf" translate="yes" xml:space="preserve">
          <source>File inclusion (&lt;code&gt;:include: /path/name&lt;/code&gt;) is not supported.</source>
          <target state="translated">Включение файла ( &lt;code&gt;:include: /path/name&lt;/code&gt; ) не поддерживается.</target>
        </trans-unit>
        <trans-unit id="0052ebd08e3dda2e68d8ee7b082b7c890d6ddeef" translate="yes" xml:space="preserve">
          <source>File indicating how to order files within a diff. See the &lt;code&gt;-O&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details. If &lt;code&gt;diff.orderFile&lt;/code&gt; is a relative pathname, it is treated as relative to the top of the working tree.</source>
          <target state="translated">Файл, показывающий, как упорядочить файлы в diff. За подробностями &lt;code&gt;-O&lt;/code&gt; параметру -O в &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; . Если &lt;code&gt;diff.orderFile&lt;/code&gt; - относительный путь, он обрабатывается относительно вершины рабочего дерева.</target>
        </trans-unit>
        <trans-unit id="f2b61a4d1705fa3305542b48c5c1ffd38b30200f" translate="yes" xml:space="preserve">
          <source>File modes are printed as 6-digit octal numbers including the file type and file permission bits.</source>
          <target state="translated">Режимы работы с файлами печатаются в виде 6-значных восьмеричных чисел,включающих тип файла и биты разрешения файла.</target>
        </trans-unit>
        <trans-unit id="cd4c7b960aaa326dfff2bf746e515a16b2b5bd4d" translate="yes" xml:space="preserve">
          <source>File system monitor</source>
          <target state="translated">Монитор файловой системы</target>
        </trans-unit>
        <trans-unit id="dab1e8f60ab6cd6f09a76739b1f40f880fb79310" translate="yes" xml:space="preserve">
          <source>File to use for (filename extension based) guessing of MIME types before trying &lt;code&gt;/etc/mime.types&lt;/code&gt;. &lt;strong&gt;NOTE&lt;/strong&gt; that this path, if relative, is taken as relative to the current Git repository, not to CGI script. If unset, only &lt;code&gt;/etc/mime.types&lt;/code&gt; is used (if present on filesystem). If no mimetypes file is found, mimetype guessing based on extension of file is disabled. Unset by default.</source>
          <target state="translated">Файл для использования (на основе расширения имени файла) для угадывания типов MIME перед попыткой &lt;code&gt;/etc/mime.types&lt;/code&gt; . &lt;strong&gt;ОБРАТИТЕ ВНИМАНИЕ,&lt;/strong&gt; что этот путь, если он относительный, принимается относительно текущего репозитория Git, а не для сценария CGI. Если не &lt;code&gt;/etc/mime.types&lt;/code&gt; , используется только /etc/mime.types (если он присутствует в файловой системе). Если файл mimetypes не найден, угадывание mimetype на основе расширения файла отключено. По умолчанию не задано.</target>
        </trans-unit>
        <trans-unit id="f045415cfa170f304a990874fe0966e6d4eacafb" translate="yes" xml:space="preserve">
          <source>File with repository URL (used for clone and fetch), one per line. Displayed in the project summary page. You can use multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt; repository configuration variable for that, but the file takes precedence.</source>
          <target state="translated">Файл с URL-адресом репозитория (используется для клонирования и выборки), по одному в строке. Отображается на странице сводки проекта. Для этого вы можете использовать многозначную &lt;code&gt;gitweb.url&lt;/code&gt; конфигурации репозитория gitweb.url , но файл имеет приоритет.</target>
        </trans-unit>
        <trans-unit id="f73380191ad1f1caa70019147dbb81cb74dd0fbd" translate="yes" xml:space="preserve">
          <source>File/directory structure</source>
          <target state="translated">Структура файла/директории</target>
        </trans-unit>
        <trans-unit id="ee97d026e695edaa3af17191656d312a0a7a2ccb" translate="yes" xml:space="preserve">
          <source>Filenames with spaces are often mishandled by shell snippets since they cause problems for shell pipelines. Not everyone is familiar with find -print0, xargs -0, git-ls-files -z, etc. Even people who are familiar with these may assume such flags are not relevant because someone else renamed any such files in their repo back before the person doing the filtering joined the project. And often, even those familiar with handling arguments with spaces may not do so just because they aren&amp;rsquo;t in the mindset of thinking about everything that could possibly go wrong.</source>
          <target state="translated">Имена файлов с пробелами часто неправильно обрабатываются фрагментами оболочки, поскольку они вызывают проблемы для конвейеров оболочки. Не все знакомы с find -print0, xargs -0, git-ls-files -z и т.д. к проекту присоединился человек, выполняющий фильтрацию. И часто даже те, кто знаком с обработкой аргументов с помощью пробелов, могут этого не делать только потому, что они не настроены думать обо всем, что может пойти не так.</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="669b1abdd74168ff79423d155c9ddb7e43a80b6e" translate="yes" xml:space="preserve">
          <source>Files (and pointers to subtrees) within active trees require 52 or 64 bytes (32/64 bit platforms) per entry. To conserve space, file and tree names are pooled in a common string table, allowing the filename &amp;ldquo;Makefile&amp;rdquo; to use just 16 bytes (after including the string header overhead) no matter how many times it occurs within the project.</source>
          <target state="translated">Файлы (и указатели на поддеревья) в активных деревьях требуют 52 или 64 байта (32/64 битные платформы) на запись. Для экономии места имена файлов и деревьев объединяются в общую таблицу строк, позволяя имени файла &amp;laquo;Makefile&amp;raquo; использовать только 16 байтов (после включения служебных данных заголовка строки) независимо от того, сколько раз это встречается в проекте.</target>
        </trans-unit>
        <trans-unit id="94bbb76c1352043c45a00df324ef04fea70e6730" translate="yes" xml:space="preserve">
          <source>Files and directories in the template directory whose name do not start with a dot will be copied to the &lt;code&gt;$GIT_DIR&lt;/code&gt; after it is created.</source>
          <target state="translated">Файлы и каталоги в каталоге шаблона, имена которых не начинаются с точки, будут скопированы в &lt;code&gt;$GIT_DIR&lt;/code&gt; после его создания.</target>
        </trans-unit>
        <trans-unit id="d1270c9a81ec2853fddc0c884f8ccb1e8a45b97e" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute &lt;code&gt;export-ignore&lt;/code&gt; won&amp;rsquo;t be added to archive files.</source>
          <target state="translated">Файлы и каталоги с атрибутом &lt;code&gt;export-ignore&lt;/code&gt; не будут добавлены в архивные файлы.</target>
        </trans-unit>
        <trans-unit id="e3974c4c3ce398cf177c9471660017bb110038df" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute export-ignore won&amp;rsquo;t be added to archive files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Файлы и каталоги с атрибутом export-ignore не будут добавлены в архивные файлы. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7b0ec5c5be81a4a3b161d0317a98cc9a7a62cb3" translate="yes" xml:space="preserve">
          <source>Files larger than this size are stored deflated, without attempting delta compression. Storing large files without delta compression avoids excessive memory usage, at the slight expense of increased disk usage. Additionally files larger than this size are always treated as binary.</source>
          <target state="translated">Файлы большего размера хранятся в сдутом виде без попыток дельта-сжатия.Хранение больших файлов без дельта-сжатия позволяет избежать чрезмерного использования памяти,за счет незначительных затрат на использование диска.Кроме того,файлы большего размера всегда рассматриваются как двоичные.</target>
        </trans-unit>
        <trans-unit id="b57b0d88e9fd775cd564cc119a3989093d68ff8d" translate="yes" xml:space="preserve">
          <source>Files to act on. Note that files beginning with &lt;code&gt;.&lt;/code&gt; are discarded. This includes &lt;code&gt;./file&lt;/code&gt; and &lt;code&gt;dir/./file&lt;/code&gt;. If you don&amp;rsquo;t want this, then use cleaner names. The same applies to directories ending &lt;code&gt;/&lt;/code&gt; and paths with &lt;code&gt;//&lt;/code&gt;</source>
          <target state="translated">Файлы, над которыми нужно действовать. Обратите внимание, что файлы, начинающиеся с &lt;code&gt;.&lt;/code&gt; отбрасываются. Сюда входят &lt;code&gt;./file&lt;/code&gt; и &lt;code&gt;dir/./file&lt;/code&gt; . Если вы этого не хотите, используйте более чистые имена. То же самое относится к каталогам, заканчивающимся &lt;code&gt;/&lt;/code&gt; , и путям с &lt;code&gt;//&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a229bb6156d5f90b453ca5e0ca33977f1a3e6a8a" translate="yes" xml:space="preserve">
          <source>Files to add content from. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to add all matching files. Also a leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to add &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to update the index to match the current state of the directory as a whole (e.g. specifying &lt;code&gt;dir&lt;/code&gt; will record not just a file &lt;code&gt;dir/file1&lt;/code&gt; modified in the working tree, a file &lt;code&gt;dir/file2&lt;/code&gt; added to the working tree, but also a file &lt;code&gt;dir/file3&lt;/code&gt; removed from the working tree). Note that older versions of Git used to ignore removed files; use &lt;code&gt;--no-all&lt;/code&gt; option if you want to add modified or new files but ignore removed ones.</source>
          <target state="translated">Файлы, из которых нужно добавить контент. Можно указать файловые глобусы (например, &lt;code&gt;*.c&lt;/code&gt; ) для добавления всех совпадающих файлов. Также можно указать &lt;code&gt;dir/file1&lt;/code&gt; имя каталога (например, &lt;code&gt;dir&lt;/code&gt; для добавления dir / file1 и &lt;code&gt;dir/file2&lt;/code&gt; ) для обновления индекса, чтобы он соответствовал текущему состоянию каталога в целом (например, указание &lt;code&gt;dir&lt;/code&gt; будет записывать не только измененный файл &lt;code&gt;dir/file1&lt;/code&gt; в рабочем дереве файл &lt;code&gt;dir/file2&lt;/code&gt; добавлен к рабочему дереву, но также файл &lt;code&gt;dir/file3&lt;/code&gt; удален из рабочего дерева). Обратите внимание, что старые версии Git игнорировали удаленные файлы; используйте параметр &lt;code&gt;--no-all&lt;/code&gt; , если вы хотите добавить измененные или новые файлы, но игнорировать удаленные.</target>
        </trans-unit>
        <trans-unit id="965ffdf35ae99a80180c99419426ec2062c992e9" translate="yes" xml:space="preserve">
          <source>Files to remove. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fcfbd1668d25020111102295bf825ad36cd4ad7" translate="yes" xml:space="preserve">
          <source>Files to remove. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to remove all matching files. If you want Git to expand file glob characters, you may need to shell-escape them. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="translated">Файлы для удаления. Fileglobs (например, &lt;code&gt;*.c&lt;/code&gt; ) могут быть предоставлены для удаления всех совпадающих файлов. Если вы хотите, чтобы Git расширял символы глобуса файла, вам может потребоваться экранирование их оболочки. Начальное имя каталога (например, &lt;code&gt;dir&lt;/code&gt; для удаления &lt;code&gt;dir/file1&lt;/code&gt; и &lt;code&gt;dir/file2&lt;/code&gt; ) может быть дано для удаления всех файлов в каталоге и рекурсивно всех подкаталогов, но для этого необходимо явно &lt;code&gt;-r&lt;/code&gt; параметр -r .</target>
        </trans-unit>
        <trans-unit id="d69266d087a66debaeaa16301b1f83a323ef3a05" translate="yes" xml:space="preserve">
          <source>Files to show. If no files are given all files which match the other specified criteria are shown.</source>
          <target state="translated">Файлы показать.При отсутствии файлов показываются все файлы,которые соответствуют другим указанным критериям.</target>
        </trans-unit>
        <trans-unit id="94b61f142196a44a91e5065c7d0adcb5cad7dae3" translate="yes" xml:space="preserve">
          <source>Files with conflicts are marked specially in the index, so until you resolve the problem and update the index, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; will fail:</source>
          <target state="translated">Файлы с конфликтами специально помечаются в индексе, поэтому, пока вы не решите проблему и не обновите индекс, &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; завершится ошибкой:</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="1cf100e1097311bd9759a52dc063dba54a0c3fc0" translate="yes" xml:space="preserve">
          <source>Finalize an in-progress &lt;code&gt;git notes merge&lt;/code&gt;. Use this option when you have resolved the conflicts that &lt;code&gt;git notes merge&lt;/code&gt; stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by &lt;code&gt;git notes merge&lt;/code&gt; (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit.</source>
          <target state="translated">Завершите &lt;code&gt;git notes merge&lt;/code&gt; . Используйте эту опцию, когда вы разрешили конфликты, возникающие при &lt;code&gt;git notes merge&lt;/code&gt; хранящихся в .git / NOTES_MERGE_WORKTREE. Это изменяет частичную фиксацию слияния, созданную &lt;code&gt;git notes merge&lt;/code&gt; (хранящуюся в .git / NOTES_MERGE_PARTIAL), путем добавления заметок в .git / NOTES_MERGE_WORKTREE. Ссылка на заметки, хранящаяся в символьной ссылке .git / NOTES_MERGE_REF, обновляется до итоговой фиксации.</target>
        </trans-unit>
        <trans-unit id="9eb00b677ea152c9f2f0f234add05ac350dd5a77" translate="yes" xml:space="preserve">
          <source>Finally it examines &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;. This file is used to override the in-tree settings. The first line is a match, and &lt;code&gt;foo&lt;/code&gt; is set, &lt;code&gt;bar&lt;/code&gt; is reverted to unspecified state, and &lt;code&gt;baz&lt;/code&gt; is unset.</source>
          <target state="translated">Наконец, он проверяет &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; . Этот файл используется для переопределения настроек в дереве. Первая строка соответствует совпадению, и &lt;code&gt;foo&lt;/code&gt; установлено, &lt;code&gt;bar&lt;/code&gt; возвращается в неопределенное состояние, а &lt;code&gt;baz&lt;/code&gt; не установлено.</target>
        </trans-unit>
        <trans-unit id="331d183abb3e32c5b94fe163358b0bd60def41df" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;datetime&lt;/code&gt; be the current time. After writing the split commit-graph, delete all unused commit-graph whose modified times are older than &lt;code&gt;datetime&lt;/code&gt;.</source>
          <target state="translated">Наконец, если &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; не указано, пусть &lt;code&gt;datetime&lt;/code&gt; будет текущим временем. После написания разделенного графа фиксации удалите все неиспользуемые графы фиксации, время изменения которых старше &lt;code&gt;datetime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d1a6457be0c846de5bf38ab3298d9d3628832d" translate="yes" xml:space="preserve">
          <source>Finally, it is possible to specify an arbitrary perl subroutine that will be called for each repository to determine if it can be exported. The subroutine receives an absolute path to the project (repository) as its only parameter (i.e. &quot;$projectroot/$project&quot;).</source>
          <target state="translated">Наконец,можно указать произвольную подпрограмму perl,которая будет вызываться для каждого хранилища,чтобы определить,можно ли его экспортировать.В качестве единственного параметра (т.е.&quot;$projectroot/$project&quot;)подпрограмма получает абсолютный путь к проекту (репозиторию).</target>
        </trans-unit>
        <trans-unit id="24d1078763f97a2ccc23634e9fb57ca6945117cd" translate="yes" xml:space="preserve">
          <source>Finally, it&amp;rsquo;s worth looking at the effect of &lt;code&gt;git add&lt;/code&gt; on the index file:</source>
          <target state="translated">Наконец, стоит посмотреть на эффект &lt;code&gt;git add&lt;/code&gt; на индексный файл:</target>
        </trans-unit>
        <trans-unit id="8264955cf61255273040b40a18d8fbbb22fa2f72" translate="yes" xml:space="preserve">
          <source>Finally, most commands that take filenames will optionally allow you to precede any filename by a commit, to specify a particular version of the file:</source>
          <target state="translated">Наконец,большинство команд,которые берут имена файлов,опционально позволяют вам предварять любое имя файла фиксацией,чтобы указать конкретную версию файла:</target>
        </trans-unit>
        <trans-unit id="6c56e02ffa0dc0d04395282d17622dfa271e848b" translate="yes" xml:space="preserve">
          <source>Finally, runs of whitespace are normalized to a single ASCII space character.</source>
          <target state="translated">Наконец,пробеги пробела нормализуются к единому символу пробела ASCII.</target>
        </trans-unit>
        <trans-unit id="f254df0ed5803ab0d672797542ab7bd433761746" translate="yes" xml:space="preserve">
          <source>Finally, see &lt;a href=&quot;#todo&quot;&gt;Notes and todo list for this manual&lt;/a&gt; for ways that you can help make this manual more complete.</source>
          <target state="translated">Наконец, см. &lt;a href=&quot;#todo&quot;&gt;Примечания и список дел для этого руководства&lt;/a&gt; , чтобы узнать, как вы можете помочь сделать это руководство более полным.</target>
        </trans-unit>
        <trans-unit id="0f28877b4b3e20afaa3344b89d8d8e7dd3cc9a77" translate="yes" xml:space="preserve">
          <source>Finally, the list of matching commits is shown in the order of the second commit range, with unmatched commits being inserted just after all of their ancestors have been shown.</source>
          <target state="translated">Наконец,список соответствующих коммитов отображается в порядке второго диапазона коммитов,при этом несопоставимые коммиты вставляются сразу после того,как все их предки были показаны.</target>
        </trans-unit>
        <trans-unit id="9a3fea8b3f0925da6c2b86381c6c149ac6f29683" translate="yes" xml:space="preserve">
          <source>Finally, there are a few odds and ends which are not purely moving from one representation to the other:</source>
          <target state="translated">Наконец,есть несколько шансов и концов,которые не просто переходят от одного представления к другому:</target>
        </trans-unit>
        <trans-unit id="3fe4e962ec8320ef45c1375652f3937a50d04ca2" translate="yes" xml:space="preserve">
          <source>Finally, there is a fifth simplification mode available:</source>
          <target state="translated">Наконец,доступен пятый режим упрощения:</target>
        </trans-unit>
        <trans-unit id="be9a3fea0f82381aa185e3a3e7bc70453cddfef1" translate="yes" xml:space="preserve">
          <source>Finally, these options can be combined with a layout option (defaults to &lt;code&gt;nodense&lt;/code&gt;):</source>
          <target state="translated">Наконец, эти параметры можно комбинировать с параметром макета (по умолчанию - &lt;code&gt;nodense&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="20a1c9ffc616ee01b8dce65bdb93f7148cbfeb85" translate="yes" xml:space="preserve">
          <source>Find a helper.</source>
          <target state="translated">Найди помощника.</target>
        </trans-unit>
        <trans-unit id="30d88faf5655c44ff9e677fe0e00c8e9ca77aa3d" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;experimental&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository (e.g. &lt;code&gt;refs/heads/experimental&lt;/code&gt;), and delete it.</source>
          <target state="translated">Найдите ссылку, которая соответствует &lt;code&gt;experimental&lt;/code&gt; в &lt;code&gt;origin&lt;/code&gt; репозитории (например, &lt;code&gt;refs/heads/experimental&lt;/code&gt; ), и удалите ее.</target>
        </trans-unit>
        <trans-unit id="ef251b247769ae2bcbe4a6086b08e0deff95b9d6" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;master&lt;/code&gt; in the source repository (most likely, it would find &lt;code&gt;refs/heads/master&lt;/code&gt;), and update the same ref (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) in &lt;code&gt;origin&lt;/code&gt; repository with it. If &lt;code&gt;master&lt;/code&gt; did not exist remotely, it would be created.</source>
          <target state="translated">Найдите ссылку, которая соответствует &lt;code&gt;master&lt;/code&gt; в исходном репозитории (скорее всего, она найдет &lt;code&gt;refs/heads/master&lt;/code&gt; ), и обновите с ней ту же ссылку (например, &lt;code&gt;refs/heads/master&lt;/code&gt; ) в &lt;code&gt;origin&lt;/code&gt; репозитории. Если бы &lt;code&gt;master&lt;/code&gt; не существовал удаленно, он был бы создан.</target>
        </trans-unit>
        <trans-unit id="ccef9d1bcc3ad53f8d4e9015291e141315fc185c" translate="yes" xml:space="preserve">
          <source>Find as good common ancestors as possible for a merge</source>
          <target state="translated">Найти как можно более хороших общих предков для слияния</target>
        </trans-unit>
        <trans-unit id="d3f173da3a7dce0bd9994325b78952d16aab8240" translate="yes" xml:space="preserve">
          <source>Find commits yet to be applied to upstream</source>
          <target state="translated">Поиск коммитов,которые еще не применены к восходящей части реки</target>
        </trans-unit>
        <trans-unit id="f766cd71208fbf6c57bd1c63b40f06ddd3b5b9dc" translate="yes" xml:space="preserve">
          <source>Find first tagged version including a given fix</source>
          <target state="translated">Найти первую помеченную версию,включая данное исправление.</target>
        </trans-unit>
        <trans-unit id="df9e9c717faf5fac976a38f227398efdc30aeda9" translate="yes" xml:space="preserve">
          <source>Find redundant pack files</source>
          <target state="translated">Поиск избыточных файлов пакета</target>
        </trans-unit>
        <trans-unit id="44f9539ac1c361035e9a88da329c269fe8a0f4cb" translate="yes" xml:space="preserve">
          <source>Find symbolic names for given revs</source>
          <target state="translated">Найти символические имена для заданных оборотов</target>
        </trans-unit>
        <trans-unit id="f381cb9cf3280c2142361c5998997b7124410055" translate="yes" xml:space="preserve">
          <source>Find the color configured for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff.new&lt;/code&gt;) and output it as the ANSI color escape sequence to the standard output. The optional &lt;code&gt;default&lt;/code&gt; parameter is used instead, if there is no color configured for &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Найдите цвет, настроенный для &lt;code&gt;name&lt;/code&gt; (например, &lt;code&gt;color.diff.new&lt;/code&gt; ), и выведите его как escape-последовательность цвета ANSI на стандартный вывод. Вместо этого используется необязательный параметр по &lt;code&gt;default&lt;/code&gt; , если для &lt;code&gt;name&lt;/code&gt; не настроен цвет .</target>
        </trans-unit>
        <trans-unit id="40d2e7dbd88f8b4a905f40b739ac46054d6c280f" translate="yes" xml:space="preserve">
          <source>Find the color setting for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff&lt;/code&gt;) and output &quot;true&quot; or &quot;false&quot;. &lt;code&gt;stdout-is-tty&lt;/code&gt; should be either &quot;true&quot; or &quot;false&quot;, and is taken into account when configuration says &quot;auto&quot;. If &lt;code&gt;stdout-is-tty&lt;/code&gt; is missing, then checks the standard output of the command itself, and exits with status 0 if color is to be used, or exits with status 1 otherwise. When the color setting for &lt;code&gt;name&lt;/code&gt; is undefined, the command uses &lt;code&gt;color.ui&lt;/code&gt; as fallback.</source>
          <target state="translated">Найдите настройку цвета для &lt;code&gt;name&lt;/code&gt; (например, &lt;code&gt;color.diff&lt;/code&gt; ) и выведите &amp;laquo;true&amp;raquo; или &amp;laquo;false&amp;raquo;. &lt;code&gt;stdout-is-tty&lt;/code&gt; должен иметь значение &amp;laquo;true&amp;raquo; или &amp;laquo;false&amp;raquo; и учитывается, когда в конфигурации указано &amp;laquo;auto&amp;raquo;. Если &lt;code&gt;stdout-is-tty&lt;/code&gt; отсутствует, то проверяет стандартный вывод самой команды и завершает работу со статусом 0, если необходимо использовать цвет, или выходит со статусом 1 в противном случае. Если параметр цвета для &lt;code&gt;name&lt;/code&gt; не определен, команда использует &lt;code&gt;color.ui&lt;/code&gt; в качестве запасного варианта .</target>
        </trans-unit>
        <trans-unit id="df59454620e80f086423090568733ac46b2847e0" translate="yes" xml:space="preserve">
          <source>Find the point at which a branch (or any history that leads to &amp;lt;commit&amp;gt;) forked from another branch (or any reference) &amp;lt;ref&amp;gt;. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of &amp;lt;ref&amp;gt; to see if the history leading to &amp;lt;commit&amp;gt; forked from an earlier incarnation of the branch &amp;lt;ref&amp;gt; (see discussion on this mode below).</source>
          <target state="translated">Найдите точку, в которой ветвь (или любая история, ведущая к &amp;lt;commit&amp;gt;) разветвилась из другой ветки (или любой ссылки) &amp;lt;ref&amp;gt;. Это не просто ищет общего предка двух коммитов, но также принимает во внимание журнал ссылок &amp;lt;ref&amp;gt;, чтобы увидеть, была ли история, ведущая к &amp;lt;commit&amp;gt;, разветвлена ​​из более раннего воплощения ветки &amp;lt;ref&amp;gt; (см. Обсуждение этот режим ниже).</target>
        </trans-unit>
        <trans-unit id="9da189d134fc7190f0c6c1f5c3193ab5948bf13c" translate="yes" xml:space="preserve">
          <source>Finding commits referencing a file with given content</source>
          <target state="translated">Поиск фиксации со ссылкой на файл с заданным содержимым</target>
        </trans-unit>
        <trans-unit id="e333b71e49766be9f1d76f262411fa340daf0c70" translate="yes" xml:space="preserve">
          <source>Finding commits which commit messages matches given search term.</source>
          <target state="translated">Поиск фиксаторов,сообщения которых соответствуют заданному поисковому запросу.</target>
        </trans-unit>
        <trans-unit id="1eaaf96aa600c577b3f3a9747228f1b65b0ceefc" translate="yes" xml:space="preserve">
          <source>Finding files</source>
          <target state="translated">Поиск файлов</target>
        </trans-unit>
        <trans-unit id="2fc00785f4570abeeda498c54f0284462aed8b44" translate="yes" xml:space="preserve">
          <source>Finding performance regressions</source>
          <target state="translated">Поиск регрессов производительности</target>
        </trans-unit>
        <trans-unit id="bc2b131e580f41edfbbcd8f6c9c60a09f1a25b76" translate="yes" xml:space="preserve">
          <source>Finds symbolic names suitable for human digestion for revisions given in any format parsable by &lt;code&gt;git rev-parse&lt;/code&gt;.</source>
          <target state="translated">Находит символические имена, подходящие для человеческого восприятия, для ревизий, представленных в любом формате, который может быть проанализирован с помощью &lt;code&gt;git rev-parse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d4b2472daa261c193507bf4d856ace529dabcc6" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s assume your &lt;code&gt;topic&lt;/code&gt; is based on branch &lt;code&gt;next&lt;/code&gt;. For example, a feature developed in &lt;code&gt;topic&lt;/code&gt; depends on some functionality which is found in &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">Сначала предположим, что ваша &lt;code&gt;topic&lt;/code&gt; основана на &lt;code&gt;next&lt;/code&gt; ветке . Например, функция, разработанная в &lt;code&gt;topic&lt;/code&gt; зависит от некоторых функций, &lt;code&gt;next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8007e4d48fad1e0a696af768b6078f3fa95c0a" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s define &quot;best bisection point&quot;. We will say that a commit X is a best bisection point or a best bisection commit if knowing its state (&quot;good&quot; or &quot;bad&quot;) gives as much information as possible whether the state of the commit happens to be &quot;good&quot; or &quot;bad&quot;.</source>
          <target state="translated">Сначала давайте определим &amp;laquo;лучшую точку деления пополам&amp;raquo;. Мы будем говорить, что фиксация X - это лучшая точка деления пополам или лучшая фиксация деления пополам, если знание его состояния (&amp;laquo;хорошее&amp;raquo; или &amp;laquo;плохое&amp;raquo;) дает как можно больше информации о том, является ли состояние фиксации &amp;laquo;хорошим&amp;raquo; или &amp;laquo;хорошим&amp;raquo;. плохой&quot;.</target>
        </trans-unit>
        <trans-unit id="ee7f8a8fdabeacb4105bb68c4dfba6a20cea041f" translate="yes" xml:space="preserve">
          <source>First merges by themselves can introduce some regressions even when the merge needs no source code conflict resolution. This is because a semantic change can happen in one branch while the other branch is not aware of it.</source>
          <target state="translated">Первые слияния сами по себе могут привнести некоторые регрессии,даже если слияние не требует разрешения конфликтов исходного кода.Это происходит потому,что семантическое изменение может произойти в одной ветке,в то время как другая ветка об этом не знает.</target>
        </trans-unit>
        <trans-unit id="05a55fcafe087cbd44c02228e1ac75a34a01c1f1" translate="yes" xml:space="preserve">
          <source>First, build a history graph in the same way that &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting does (see above).</source>
          <target state="translated">Во-первых, постройте график истории таким же образом, как это &lt;code&gt;--full-history&lt;/code&gt; с родительской перезаписью (см. Выше).</target>
        </trans-unit>
        <trans-unit id="08310df25f406cc10b8d6127f9ec844567b780fb" translate="yes" xml:space="preserve">
          <source>First, if you wish to continue to release maintenance fixes for the feature release made before the recent one, then you must create another branch to track commits for that previous release.</source>
          <target state="translated">Сначала,если вы хотите продолжать выпускать сопровождающие исправления для релиза функции,сделанного до недавнего,то вы должны создать другую ветку,чтобы отслеживать фиксации для этого предыдущего релиза.</target>
        </trans-unit>
        <trans-unit id="3f7b81f4c441b31ef96f877571ae9e6d0b762fd6" translate="yes" xml:space="preserve">
          <source>First, in .gitattributes, you would assign the &lt;code&gt;diff&lt;/code&gt; attribute for paths.</source>
          <target state="translated">Во-первых, в .gitattributes вы должны назначить для путей атрибут &lt;code&gt;diff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3f5f5cacf6c72eb426cf54eb30cee145c3bf1f2" translate="yes" xml:space="preserve">
          <source>First, install version 2.1 or higher of cvsps from &lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt; and make sure it is in your path. Then cd to a checked out CVS working directory of the project you are interested in and run &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt;:</source>
          <target state="translated">Сначала установите cvsps версии 2.1 или выше с &lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt; и убедитесь, что она находится у вас на пути. Затем перейдите в проверенный рабочий каталог CVS интересующего вас проекта и запустите &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="576e890855dbcdc8bc3ac7fde0afbe81b0fdd016" translate="yes" xml:space="preserve">
          <source>First, note that you can get documentation for a command such as &lt;code&gt;git log --graph&lt;/code&gt; with:</source>
          <target state="translated">Во-первых, обратите внимание, что вы можете получить документацию для такой команды, как &lt;code&gt;git log --graph&lt;/code&gt; , с помощью:</target>
        </trans-unit>
        <trans-unit id="9a679f4d1f2379fb3e8b418dd1cdea69390f805f" translate="yes" xml:space="preserve">
          <source>First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with &lt;code&gt;HEAD&lt;/code&gt; are still marked so that &lt;code&gt;git add -p&lt;/code&gt; will find them.</source>
          <target state="translated">Сначала сбросим историю назад на один коммит, чтобы мы удалили исходный коммит, но оставим рабочее дерево со всеми изменениями. -N гарантирует, что любые новые файлы, добавленные с помощью &lt;code&gt;HEAD&lt;/code&gt; , по-прежнему будут отмечены, чтобы &lt;code&gt;git add -p&lt;/code&gt; их обнаружил.</target>
        </trans-unit>
        <trans-unit id="eac258ebc7c4ff84505375d195a1e24d04961706" translate="yes" xml:space="preserve">
          <source>First, use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;; for example:</source>
          <target state="translated">Сначала используйте &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; ; например:</target>
        </trans-unit>
        <trans-unit id="af62e3f15d84326a813952b253791dac4ec57aaa" translate="yes" xml:space="preserve">
          <source>First, you need to create an empty repository on the remote machine that will house your public repository. This empty repository will be populated and be kept up to date by pushing into it later. Obviously, this repository creation needs to be done only once.</source>
          <target state="translated">Во-первых,вам нужно создать пустой репозиторий на удаленной машине,в котором будет храниться ваш общедоступный репозиторий.Этот пустой репозиторий будет наполнен и поддерживаться в актуальном состоянии с помощью нажатия на него позже.Очевидно,что это создание репозитория нужно сделать только один раз.</target>
        </trans-unit>
        <trans-unit id="52835c0708aa62a7396cacc7dfc2df24ce8a002c" translate="yes" xml:space="preserve">
          <source>Fix a &quot;thin&quot; pack produced by &lt;code&gt;git pack-objects --thin&lt;/code&gt; (see &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details) by adding the excluded objects the deltified objects are based on to the pack. This option only makes sense in conjunction with --stdin.</source>
          <target state="translated">Исправьте &quot;тонкий&quot; пакет, созданный &lt;code&gt;git pack-objects --thin&lt;/code&gt; (подробности см. В &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; ), добавив в пакет исключенные объекты, на которых основаны исключенные объекты. Этот параметр имеет смысл только в сочетании с --stdin.</target>
        </trans-unit>
        <trans-unit id="6bef9039e49cd5a1bb992311087de16992b814ac" translate="yes" xml:space="preserve">
          <source>Fix the ignore-paths or SVN permissions problem that caused &quot;r2&quot; to be incomplete in the first place. Then:</source>
          <target state="translated">Исправьте проблему с игнорируемыми путями или SVN-разрешениями,из-за которой &quot;r2&quot; был изначально неполным.Затем:</target>
        </trans-unit>
        <trans-unit id="bf5e51b162922584144bf607debb47b58ed7a8df" translate="yes" xml:space="preserve">
          <source>Fixing a mistake by rewriting history</source>
          <target state="translated">Исправление ошибки путем переписывания истории</target>
        </trans-unit>
        <trans-unit id="afb2d222f3591d3622f9d0c44f698fe7e6dc0a83" translate="yes" xml:space="preserve">
          <source>Fixing a mistake with a new commit</source>
          <target state="translated">Исправление ошибки с помощью нового коммита</target>
        </trans-unit>
        <trans-unit id="c169f9b52cd517560d8a456346335c3aedbfac2b" translate="yes" xml:space="preserve">
          <source>Fixing mistakes</source>
          <target state="translated">Исправление ошибок</target>
        </trans-unit>
        <trans-unit id="de18d069db0d9d56daecfccdb3a27275518bc1f7" translate="yes" xml:space="preserve">
          <source>Flags and parameters to be parsed.</source>
          <target state="translated">Флаги и параметры для анализа.</target>
        </trans-unit>
        <trans-unit id="8a2fcacfdef0a8b1fd083381230b0ac0cbbdea61" translate="yes" xml:space="preserve">
          <source>Follow merge ancestry and attempt to import trees that have been merged from. Specify a depth greater than 1 if patch logs have been pruned.</source>
          <target state="translated">Следуйте за слиянием родословных и попытайтесь импортировать деревья,из которых они были слиты.Укажите глубину больше 1,если были подрезаны патч-журналы.</target>
        </trans-unit>
        <trans-unit id="fc08e4a2c4c96e25ad3223cdd944785cb30a915c" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48973c6479f97ed9cbdd1aa747abb3d724dfc88" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit.</source>
          <target state="translated">Следуйте только за первым родительским коммитом,увидев коммит слияния.Это полезно,когда вы не хотите,чтобы в истории целевого коммита совпадали теги по слитым ветвям.</target>
        </trans-unit>
        <trans-unit id="37deb1921d5628bb8484cd98e5d1812d850199d4" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can be used to determine when a line was introduced to a particular integration branch, rather than when it was introduced to the history overall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592429d37f44072b1083ee8b6715edf266446955" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67b9781a4352de8f66549a8b248fd66aceb7858" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge. Cannot be combined with --bisect.</source>
          <target state="translated">Следуйте только за первым родительским коммитом,увидев коммит слияния.Эта опция может дать лучший обзор при просмотре эволюции определённой тематической ветки,поскольку слияния в тематическую ветку,как правило,связаны только с настройкой на обновление вверх по течению время от времени,и эта опция позволяет вам игнорировать отдельные коммиты,внесённые в вашу историю в результате такого слияния.Невозможно комбинировать с --бизектом.</target>
        </trans-unit>
        <trans-unit id="1b82a1274463e2bfba901905e39b02d331c44520" translate="yes" xml:space="preserve">
          <source>Following general best practices</source>
          <target state="translated">Следуя общей передовой практике</target>
        </trans-unit>
        <trans-unit id="788b60e8a3fa302c96ca5000ec7c36053afb1c38" translate="yes" xml:space="preserve">
          <source>Following the headers, a series of lines are printed for tracked entries. One of three different line formats may be used to describe an entry depending on the type of change. Tracked entries are printed in an undefined order; parsers should allow for a mixture of the 3 line types in any order.</source>
          <target state="translated">После заголовков для записей с отслеживанием печатается серия строк.Один из трех различных форматов строк может использоваться для описания записи в зависимости от типа изменения.Отслеживаемые записи печатаются в неопределенном порядке;парсеры должны позволять смешивать 3 типа строк в любом порядке.</target>
        </trans-unit>
        <trans-unit id="0af351e25b3235e5cb0b144d879a5948cd0b6627" translate="yes" xml:space="preserve">
          <source>Following the tracked entries (and if requested), a series of lines will be printed for untracked and then ignored items found in the worktree.</source>
          <target state="translated">После отслеживаемых записей (и при запросе)будет выведена серия строк для неопознанных,а затем проигнорированных элементов,найденных в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="18388d4087a6542b5572bea29a06b35e2aae5326" translate="yes" xml:space="preserve">
          <source>Following these N lines, one-line log for each commit is displayed, indented N places. If a commit is on the I-th branch, the I-th indentation character shows a &lt;code&gt;+&lt;/code&gt; sign; otherwise it shows a space. Merge commits are denoted by a &lt;code&gt;-&lt;/code&gt; sign. Each commit shows a short name that can be used as an extended SHA-1 to name that commit.</source>
          <target state="translated">После этих N строк отображается однострочный журнал для каждой фиксации с отступом N мест. Если фиксация находится на I-й ветви, для I-го символа отступа отображается знак &lt;code&gt;+&lt;/code&gt; ; в противном случае отображается пробел. Коммиты слияния обозначаются знаком &lt;code&gt;-&lt;/code&gt; . Каждая фиксация показывает короткое имя, которое можно использовать как расширенный SHA-1 для имени этой фиксации.</target>
        </trans-unit>
        <trans-unit id="348633bb6883a2c8b3944ebb9c0c3986369c6bb3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt;, only the destination or final path is shown even if the file was renamed on any side of history. With &lt;code&gt;--combined-all-paths&lt;/code&gt;, the name of the path in each parent is shown followed by the name of the path in the merge commit.</source>
          <target state="translated">Для &lt;code&gt;-c&lt;/code&gt; и &lt;code&gt;--cc&lt;/code&gt; отображается только конечный или конечный путь, даже если файл был переименован на любой стороне истории. С &lt;code&gt;--combined-all-paths&lt;/code&gt; отображается имя пути в каждом родительском элементе , за которым следует имя пути в фиксации слияния.</target>
        </trans-unit>
        <trans-unit id="299f58cbaec7164b54b0f4129532e8b5c1642be3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt;, display the urls that will be used for copying when creating the branch or tag.</source>
          <target state="translated">Для &lt;code&gt;branch&lt;/code&gt; и &lt;code&gt;tag&lt;/code&gt; отобразите URL-адреса, которые будут использоваться для копирования при создании ветки или тега.</target>
        </trans-unit>
        <trans-unit id="007222e8d7dfa1e11f08c139bdea5864653b03fb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;dcommit&lt;/code&gt;, print out the series of Git arguments that would show which diffs would be committed to SVN.</source>
          <target state="translated">Для &lt;code&gt;dcommit&lt;/code&gt; распечатайте ряд аргументов Git, которые покажут, какие различия будут зафиксированы в SVN.</target>
        </trans-unit>
        <trans-unit id="7661574c1331f1ffadb88e65b09fb7bbb3d5b369" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;rebase&lt;/code&gt;, display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from.</source>
          <target state="translated">Для &lt;code&gt;rebase&lt;/code&gt; отобразите локальную ветвь, связанную с вышестоящим репозиторием svn, связанным с текущей веткой, и URL-адрес репозитория svn, из которого будет выполняться выборка.</target>
        </trans-unit>
        <trans-unit id="8054fb75013a9d33733a54185710f048c11e6754" translate="yes" xml:space="preserve">
          <source>For Git developers, &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; goes into detail on the lower-level Git mechanisms involved in, for example, creating a new commit.</source>
          <target state="translated">Для разработчиков Git в &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; подробно рассматриваются механизмы Git нижнего уровня, участвующие, например, в создании нового коммита.</target>
        </trans-unit>
        <trans-unit id="9c7a8b6d1a7a0700f3cd22ce6172861bfe044c11" translate="yes" xml:space="preserve">
          <source>For SSH clients that will make commits, make sure their server-side .ssh/environment files (or .bashrc, etc., according to their specific shell) export appropriate values for GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME, and GIT_COMMITTER_EMAIL. For SSH clients whose login shell is bash, .bashrc may be a reasonable alternative.</source>
          <target state="translated">Для SSH-клиентов,которые будут делать коммиты,убедитесь,что их серверные файлы .ssh/окружения (или .bashrc и т.д.,в соответствии с их конкретной оболочкой)экспортируют соответствующие значения для GIT_AUTHOR_NAME,GIT_AUTHOR_EMAIL,GIT_COMMITTER_NAME и GIT_COMMITTER_EMAIL.Для SSH-клиентов,чьей оболочкой для входа в систему является bash,разумной альтернативой может быть .bashrc.</target>
        </trans-unit>
        <trans-unit id="e127a96a43fc87667b0c86a8698d094b3fabedbe" translate="yes" xml:space="preserve">
          <source>For URLs in &lt;code&gt;https://weak.example.com&lt;/code&gt;, &lt;code&gt;http.sslVerify&lt;/code&gt; is set to false, while it is set to &lt;code&gt;true&lt;/code&gt; for all others:</source>
          <target state="translated">Для URL в &lt;code&gt;https://weak.example.com&lt;/code&gt; , &lt;code&gt;http.sslVerify&lt;/code&gt; устанавливается в ложь, в то время как он установлен &lt;code&gt;true&lt;/code&gt; для всех остальных:</target>
        </trans-unit>
        <trans-unit id="701bbbb19204ae1c36fbfa4b6462dff9d4624e60" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;get&lt;/code&gt; operation, the helper should produce a list of attributes on stdout in the same format (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for common attributes). A helper is free to produce a subset, or even no values at all if it has nothing useful to provide. Any provided attributes will overwrite those already known about by Git&amp;rsquo;s credential subsystem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef97080144d6e0b76f4c32d65bbd8d420f1d9d3f" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;erase&lt;/code&gt; operation, the helper&amp;rsquo;s output is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c95f036bd90f837a4d78c935d1c885601df8ec" translate="yes" xml:space="preserve">
          <source>For a custom merge command, specify whether the exit code of the merge command can be used to determine whether the merge was successful. If this is not set to true then the merge target file timestamp is checked and the merge assumed to have been successful if the file has been updated, otherwise the user is prompted to indicate the success of the merge.</source>
          <target state="translated">Для пользовательской команды слияния укажите,можно ли использовать код выхода команды слияния для определения того,было ли слияние успешным.Если это значение не установлено в true,то проверяется временная метка целевого файла слияния и предполагается,что слияние прошло успешно,если файл был обновлен,в противном случае пользователю предлагается указать успешность слияния.</target>
        </trans-unit>
        <trans-unit id="832a920de5e5a1607e20fda89c6b16105d6a3d66" translate="yes" xml:space="preserve">
          <source>For a description of which objects are considered for pruning, see &lt;code&gt;git fsck&lt;/code&gt;'s --unreachable option.</source>
          <target state="translated">Для описания того, какие объекты рассматриваются для сокращения, см. Параметр &lt;code&gt;git fsck&lt;/code&gt; --unreachable.</target>
        </trans-unit>
        <trans-unit id="7772aa877c345ccdb695091fd19f024126a4a0b8" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">Подробное описание &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; см. Выше в разделе &lt;code&gt;from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97b7c41fd980027cd240574fa45f8b9cf3a30c50" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">Подробное описание &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; см. Выше в &lt;code&gt;commit&lt;/code&gt; и &lt;code&gt;from&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4f4b9fba6569cfb2eebe32e9b505f5e163da8ae" translate="yes" xml:space="preserve">
          <source>For a failed update, more details are given:</source>
          <target state="translated">Для неудачного обновления приведена более подробная информация:</target>
        </trans-unit>
        <trans-unit id="243468740a36ab67df241df82903537b2a102239" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell &amp;lt;commit&amp;gt;, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. However, &quot;diff&quot; is about comparing two &lt;code&gt;endpoints&lt;/code&gt;, not ranges, and the range notations (&quot;&amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt;&quot; and &quot;&amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt;&quot;) do not mean a range as defined in the &quot;SPECIFYING RANGES&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Для более полного списка способов написания &amp;lt;commit&amp;gt; см. Раздел &amp;laquo; &lt;a href=&quot;gitrevisions&quot;&gt;УКАЗАНИЕ ПРАВИЛ&lt;/a&gt; &amp;raquo; в gitrevisions [7] . Однако &quot;diff&quot; предназначен для сравнения двух &lt;code&gt;endpoints&lt;/code&gt; , а не диапазонов, и обозначения диапазона (&quot;&amp;lt;commit&amp;gt; .. &amp;lt;commit&amp;gt;&quot; и &quot;&amp;lt;commit&amp;gt; ... &amp;lt;commit&amp;gt;&quot;) не означают диапазон, как определено в раздел &amp;laquo; &lt;a href=&quot;gitrevisions&quot;&gt;УКАЗАНИЕ ДИАПАЗОНОВ&lt;/a&gt; &amp;raquo; в gitrevisions [7] .</target>
        </trans-unit>
        <trans-unit id="aef391cab8f8e654bd28a4ebab3ff359b2dd758d" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Более полный список способов &lt;a href=&quot;gitrevisions&quot;&gt;написания&lt;/a&gt; имен объектов см. В разделе &amp;laquo;УКАЗАНИЕ ИЗМЕНЕНИЙ&amp;raquo; в gitrevisions [7] .</target>
        </trans-unit>
        <trans-unit id="ffb03e9988d5aab6ca13a5c4410e25c3bc4d2c1f" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion of the procedure and additional tips, see the &quot;INTERACTIVE MODE&quot; section of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">Для более подробного обсуждения процедуры и дополнительных советов см. Раздел &amp;laquo;ИНТЕРАКТИВНЫЙ РЕЖИМ&amp;raquo; в &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21840545ec0ef1fb11dadc3e0bd425ddda71d447" translate="yes" xml:space="preserve">
          <source>For a path that is unmerged, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 1 parameter, &amp;lt;path&amp;gt;.</source>
          <target state="translated">Для пути, который не объединен, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; вызывается с 1 параметром, &amp;lt;path&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="bf84b30d98b0b2aee4084cebd6a510d7735317e2" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; would print</source>
          <target state="translated">Для обычного файла &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; будет печатать</target>
        </trans-unit>
        <trans-unit id="3d0f9234523f6052cd5829e5dd1cdac95a9b09fd" translate="yes" xml:space="preserve">
          <source>For a simple local test, you can use &lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext[1]&lt;/a&gt;:</source>
          <target state="translated">Для простого локального теста вы можете использовать &lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="428bfb3c06af83865df8238da30e9618f9cb0a09" translate="yes" xml:space="preserve">
          <source>For a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">Для успешно выбранной ссылки в сводке показаны старые и новые значения ссылки в форме, подходящей для использования в качестве аргумента для &lt;code&gt;git log&lt;/code&gt; ( в большинстве случаев это &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; , и &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; для принудительных обновлений без перемотки вперед).</target>
        </trans-unit>
        <trans-unit id="95550d69988e7a758b9c94b13942bde9ad57e2ef" translate="yes" xml:space="preserve">
          <source>For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">Для успешно отправленной ссылки в сводке показаны старые и новые значения ссылки в форме, подходящей для использования в качестве аргумента для &lt;code&gt;git log&lt;/code&gt; ( в большинстве случаев это &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; , и &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; для принудительных обновлений без перемотки вперед).</target>
        </trans-unit>
        <trans-unit id="d2bfe73291a6ef412f90bf2eac1210664a9553b3" translate="yes" xml:space="preserve">
          <source>For all objects, the following names can be used:</source>
          <target state="translated">Для всех объектов можно использовать следующие имена:</target>
        </trans-unit>
        <trans-unit id="96992b112d12dd337ecf884c867dcddc44e026cf" translate="yes" xml:space="preserve">
          <source>For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks.</source>
          <target state="translated">Для всех опций,которые выводят значения и/или клавиши,всегда заканчивайте значения нулевым символом (вместо новой строки).Используйте newline вместо него в качестве разделителя между ключом и значением.Это позволяет безопасно разобрать вывод,не путаясь,например,со значениями,которые содержат разрывы строк.</target>
        </trans-unit>
        <trans-unit id="8ac2c111de5df363fa2f5b2b630af5f75a90bcb1" translate="yes" xml:space="preserve">
          <source>For an unmerged path, instead of recording a single mode/SHA-1 pair, the index records up to three such pairs; one from tree O in stage 1, A in stage 2, and B in stage 3. This information can be used by the user (or the porcelain) to see what should eventually be recorded at the path. (see &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt; for more information on state)</source>
          <target state="translated">Для несвязанного пути вместо записи одной пары режим / SHA-1 индекс записывает до трех таких пар; один из дерева O на этапе 1, A на этапе 2 и B на этапе 3. Эта информация может использоваться пользователем (или фарфором), чтобы увидеть, что в конечном итоге должно быть записано на пути. (см. &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt; для получения дополнительной информации о состоянии)</target>
        </trans-unit>
        <trans-unit id="43b2d74a2014d25aa6c53b32650e8baad61de67e" translate="yes" xml:space="preserve">
          <source>For any commit graph, you can see the number associated with each commit using &quot;git rev-list --bisect-all&quot;.</source>
          <target state="translated">Для любого графа коммитов вы можете увидеть номер,связанный с каждым коммитом,используя &quot;git rev-list --bisect-all&quot;.</target>
        </trans-unit>
        <trans-unit id="672441c22b399b226ed91a2cbed5740025f9d076" translate="yes" xml:space="preserve">
          <source>For any remote-tracking branch &lt;code&gt;%(upstream)&lt;/code&gt;, &lt;code&gt;%(upstream:remotename)&lt;/code&gt; and &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; to fetch from &lt;code&gt;%(upstream:remotename)&lt;/code&gt;.</source>
          <target state="translated">Для любой ветви удаленного отслеживания &lt;code&gt;%(upstream)&lt;/code&gt; &lt;code&gt;%(upstream:remotename)&lt;/code&gt; ) , % (восходящий поток: удаленное имя) и &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; относятся к имени удаленного устройства и имени отслеживаемого удаленного ссылки соответственно. Другими словами, ветвь удаленного отслеживания может быть обновлена ​​явно и индивидуально с помощью refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; для выборки из &lt;code&gt;%(upstream:remotename)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="242026e8d7d0593118b4fae738fc0c3f1a90be23" translate="yes" xml:space="preserve">
          <source>For atomicity, &lt;code&gt;git apply&lt;/code&gt; by default fails the whole patch and does not touch the working tree when some of the hunks do not apply. This option makes it apply the parts of the patch that are applicable, and leave the rejected hunks in corresponding *.rej files.</source>
          <target state="translated">Для атомарности &lt;code&gt;git apply&lt;/code&gt; по умолчанию завершает неудачу всего патча и не затрагивает рабочее дерево, когда некоторые из фрагментов не применяются. Эта опция заставляет его применять части патча, которые применимы, и оставлять отклоненные блоки в соответствующих файлах * .rej.</target>
        </trans-unit>
        <trans-unit id="8d098e130baba0ccc99da718229f5fc6bc213a77" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;crlf&lt;/code&gt; attribute is interpreted as follows:</source>
          <target state="translated">Для обратной совместимости атрибут &lt;code&gt;crlf&lt;/code&gt; интерпретируется следующим образом:</target>
        </trans-unit>
        <trans-unit id="816a47e0ab5f0e7c8c410570167eb66d775695ae" translate="yes" xml:space="preserve">
          <source>For best consistency with &lt;code&gt;cvs&lt;/code&gt;, it is probably best to override the defaults by setting &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; to true, and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; to &quot;guess&quot;.</source>
          <target state="translated">Для &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; согласованности с &lt;code&gt;cvs&lt;/code&gt; , вероятно, лучше всего переопределить значения по умолчанию, установив для gitcvs.usecrlfattr значение true, а для &lt;code&gt;gitcvs.allBinary&lt;/code&gt; - значение &quot;guess&quot;.</target>
        </trans-unit>
        <trans-unit id="bad93aa83b2df49f46d609a291da6014ee26a719" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;clean&lt;/code&gt; should not alter its output further if it is run twice (&quot;clean&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;), and multiple &lt;code&gt;smudge&lt;/code&gt; commands should not alter &lt;code&gt;clean&lt;/code&gt;'s output (&quot;smudge&amp;rarr;smudge&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;). See the section on merging below.</source>
          <target state="translated">Для достижения наилучших результатов &lt;code&gt;clean&lt;/code&gt; не должна изменять свой вывод, если она запускается дважды (&amp;laquo;clean &amp;rarr; clean&amp;raquo; должно быть эквивалентно &amp;laquo;clean&amp;raquo;), а несколько команд &lt;code&gt;smudge&lt;/code&gt; не должны изменять вывод &lt;code&gt;clean&lt;/code&gt; (&amp;laquo;smudge &amp;rarr; smudge &amp;rarr; clean&amp;raquo; должен быть эквивалентен &amp;laquo;чистому&amp;raquo;). См. Раздел о слиянии ниже.</target>
        </trans-unit>
        <trans-unit id="8d3928084bacb031775f5d7bad0ceaa321b4778c" translate="yes" xml:space="preserve">
          <source>For blobs and trees, you can&amp;rsquo;t do the same, but you can still examine them. You can just do</source>
          <target state="translated">Для капель и деревьев вы не можете сделать то же самое, но вы все равно можете их изучить. Вы можете просто сделать</target>
        </trans-unit>
        <trans-unit id="d0eec01499f14d036682e7faa93df840595c4ccf" translate="yes" xml:space="preserve">
          <source>For commit and tag objects, the special &lt;code&gt;creatordate&lt;/code&gt; and &lt;code&gt;creator&lt;/code&gt; fields will correspond to the appropriate date or name-email-date tuple from the &lt;code&gt;committer&lt;/code&gt; or &lt;code&gt;tagger&lt;/code&gt; fields depending on the object type. These are intended for working on a mix of annotated and lightweight tags.</source>
          <target state="translated">Для фиксации и тегов объектов, специальные &lt;code&gt;creatordate&lt;/code&gt; и &lt;code&gt;creator&lt;/code&gt; полей будет соответствовать соответствующей дате или имя-адрес электронной почты, дата кортеж из &lt;code&gt;committer&lt;/code&gt; или &lt;code&gt;tagger&lt;/code&gt; полей в зависимости от типа объекта. Они предназначены для работы с аннотированными и облегченными тегами.</target>
        </trans-unit>
        <trans-unit id="f1ce66454707d43159aa08f01addd1a2cbbd5b3f" translate="yes" xml:space="preserve">
          <source>For commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by &lt;code&gt;git diff-tree --cc&lt;/code&gt;.</source>
          <target state="translated">Для коммитов он показывает сообщение журнала и текстовую разницу. Он также представляет фиксацию слияния в специальном формате, созданном &lt;code&gt;git diff-tree --cc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65305ecf02c6387d8a2b51f2d0ea21b43d00656b" translate="yes" xml:space="preserve">
          <source>For commits which do not start empty but become empty after rebasing, see the --empty flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5788d84088826961fe0565ab052c9c41c47117d5" translate="yes" xml:space="preserve">
          <source>For commits, you can just use:</source>
          <target state="translated">Для коммитов ты можешь просто использовать:</target>
        </trans-unit>
        <trans-unit id="600c796c6fdee3517d0340d7c98d0e629e148085" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions, as described in the &quot;TRUE MERGE&quot; section of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. The working tree files will include a description of the conflict bracketed by the usual conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Для конфликтующих путей индексный файл записывает до трех версий, как описано в разделе &amp;laquo;ИСТИННОЕ СЛИЯНИЕ&amp;raquo; в &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; . Файлы рабочего дерева будут включать описание конфликта, заключенное в скобки обычными маркерами конфликта &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35aa73e9eb71becc5a3756c0cf556cc7d0b77d41" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from &lt;code&gt;HEAD&lt;/code&gt;, and stage 3 from &lt;code&gt;MERGE_HEAD&lt;/code&gt; (you can inspect the stages with &lt;code&gt;git ls-files -u&lt;/code&gt;). The working tree files contain the result of the &quot;merge&quot; program; i.e. 3-way merge results with familiar conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Для конфликтующих путей индексный файл записывает до трех версий: на этапе 1 хранится версия от общего предка, на этапе 2 из &lt;code&gt;HEAD&lt;/code&gt; и на этапе 3 из &lt;code&gt;MERGE_HEAD&lt;/code&gt; (вы можете проверить этапы с помощью &lt;code&gt;git ls-files -u&lt;/code&gt; ). Файлы рабочего дерева содержат результат программы &amp;laquo;слияния&amp;raquo;; т.е. результаты трехстороннего слияния со знакомыми маркерами конфликта &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;===&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a860b5275da5a9c9fab93cf772cd75bc2e0f4eb" translate="yes" xml:space="preserve">
          <source>For consistency, we also try such a trick if &lt;code&gt;man.konqueror.path&lt;/code&gt; is set to something like &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt;. That means we will try to launch &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; instead.</source>
          <target state="translated">Для единообразия мы также пробуем такой трюк, если для &lt;code&gt;man.konqueror.path&lt;/code&gt; установлено что-то вроде &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt; . Это означает, что вместо этого мы попытаемся запустить &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="303c07dbeb4d9b201e995967f10cae861d7b985d" translate="yes" xml:space="preserve">
          <source>For convenience, this data is saved to &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; each time the &lt;code&gt;-A&lt;/code&gt; option is provided and read from that same file each time &lt;code&gt;git cvsimport&lt;/code&gt; is run.</source>
          <target state="translated">Для удобства эти данные сохраняются в &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; каждый раз, когда предоставляется опция &lt;code&gt;-A&lt;/code&gt; , и читаются из того же файла каждый раз при &lt;code&gt;git cvsimport&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc9270ed7ea5a3e841c3245ec308c8ddd86f1b91" translate="yes" xml:space="preserve">
          <source>For credential lookups, the files are read in the order given above, with the first matching credential found taking precedence over credentials found in files further down the list.</source>
          <target state="translated">Для поиска учетных записей,файлы читаются в порядке,указанном выше,при этом первая найденная соответствующая учетная запись имеет приоритет над учетными записями,найденными в файлах ниже по списку.</target>
        </trans-unit>
        <trans-unit id="78e4826a9de5d7b3349b3c973d4bc09ea13a37ed" translate="yes" xml:space="preserve">
          <source>For each &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; or &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; from the command-line or standard input (when using &lt;code&gt;--stdin&lt;/code&gt;), look up the person&amp;rsquo;s canonical name and email address (see &quot;Mapping Authors&quot; below). If found, print them; otherwise print the input as-is.</source>
          <target state="translated">Для каждого &amp;laquo;Имя &amp;lt;user @ host&amp;gt;&amp;raquo; или &amp;laquo;&amp;lt;user @ host&amp;gt;&amp;raquo; из командной строки или стандартного ввода (при использовании &lt;code&gt;--stdin&lt;/code&gt; ) найдите каноническое имя и адрес электронной почты человека (см. &amp;laquo;Сопоставление авторов&amp;raquo; ниже ). Если есть, распечатайте их; в противном случае распечатайте ввод как есть.</target>
        </trans-unit>
        <trans-unit id="317daaebd1883bdffebfa8e7b1777b5a4f83c1ca" translate="yes" xml:space="preserve">
          <source>For each &amp;lt;pathspec&amp;gt; given on command line, descend at most &amp;lt;depth&amp;gt; levels of directories. A value of -1 means no limit. This option is ignored if &amp;lt;pathspec&amp;gt; contains active wildcards. In other words if &quot;a*&quot; matches a directory named &quot;a*&quot;, &quot;*&quot; is matched literally so --max-depth is still effective.</source>
          <target state="translated">Для каждого &amp;lt;pathspec&amp;gt;, указанного в командной строке, спускаются не более &amp;lt;depth&amp;gt; уровней каталогов. Значение -1 означает отсутствие ограничений. Эта опция игнорируется, если &amp;lt;pathspec&amp;gt; содержит активные подстановочные знаки. Другими словами, если &amp;laquo;a *&amp;raquo; соответствует каталогу с именем &amp;laquo;a *&amp;raquo;, &amp;laquo;*&amp;raquo; совпадает буквально, поэтому --max-depth все еще действует.</target>
        </trans-unit>
        <trans-unit id="5e28a0aae950ca165e06c71e20e1b405d570f17a" translate="yes" xml:space="preserve">
          <source>For each URI the server sends, it sends a hash of the pack&amp;rsquo;s contents (as output by git index-pack) followed by the URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf7cc0cba8ed8b7ebafa73d62528bdea5d7f903" translate="yes" xml:space="preserve">
          <source>For each commit a separate file is created in the current directory.</source>
          <target state="translated">Для каждого коммита создаётся отдельный файл в текущем каталоге.</target>
        </trans-unit>
        <trans-unit id="6e5eb78674e89f34ddd48ded79bd04ac86b27923" translate="yes" xml:space="preserve">
          <source>For each commit, show a summary of changes using the raw diff format. See the &quot;RAW OUTPUT FORMAT&quot; section of &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This is different from showing the log itself in raw format, which you can achieve with &lt;code&gt;--format=raw&lt;/code&gt;.</source>
          <target state="translated">Для каждой фиксации покажите сводку изменений в формате raw diff. См. Раздел &amp;laquo;ФОРМАТ ВЫВОДА RAW&amp;raquo; в &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; . Это отличается от отображения самого журнала в необработанном формате, чего можно добиться с помощью &lt;code&gt;--format=raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="334d2ef126bc398bc9fdce4f33bf828f0bbaab0d" translate="yes" xml:space="preserve">
          <source>For each commit-ish supplied, &lt;code&gt;git describe&lt;/code&gt; will first look for a tag which tags exactly that commit. Annotated tags will always be preferred over lightweight tags, and tags with newer dates will always be preferred over tags with older dates. If an exact match is found, its name will be output and searching will stop.</source>
          <target state="translated">Для каждой предоставленной фиксации &lt;code&gt;git describe&lt;/code&gt; сначала будет искать тег, который помечает именно эту фиксацию. Аннотированные теги всегда будут предпочтительнее легких тегов, а теги с более новыми датами всегда будут предпочтительнее тегов с более ранними датами. Если будет найдено точное совпадение, будет выведено его имя и поиск остановится.</target>
        </trans-unit>
        <trans-unit id="499cd7809be15aac9ff7cdcafa51d0930d0f78d9" translate="yes" xml:space="preserve">
          <source>For each contact, a single line is output, terminated by a newline. If the name is provided or known to the &lt;code&gt;mailmap&lt;/code&gt;, &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; is printed; otherwise only &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; is printed.</source>
          <target state="translated">Для каждого контакта выводится одна строка, заканчивающаяся новой строкой. Если имя предоставлено или известно &lt;code&gt;mailmap&lt;/code&gt; , печатается &amp;laquo;Имя &amp;lt;user @ host&amp;gt;&amp;raquo;; в противном случае печатается только &amp;laquo;&amp;lt;user @ host&amp;gt;&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0e11740c89977d85e4dd98daa923a91e3f5130da" translate="yes" xml:space="preserve">
          <source>For each patch the code attempts to extract the author from the patch description. If that fails it falls back to the author specified with --author. If the --author flag was not given the patch description is displayed and the user is asked to interactively enter the author of the patch.</source>
          <target state="translated">Для каждого патча код пытается извлечь автора из описания патча.Если это не удается,он возвращается к автору,указанному в --author.Если флаг --author не был задан,то отображается описание патча,и пользователю предлагается интерактивно ввести автора патча.</target>
        </trans-unit>
        <trans-unit id="5681283d451e4fc4fc0ca3089786f576c8a1186d" translate="yes" xml:space="preserve">
          <source>For each path &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called, two environment variables, &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; and &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; are set.</source>
          <target state="translated">Для каждого пути &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; , устанавливаются две переменные среды, &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; и GIT_DIFF_PATH_TOTAL .</target>
        </trans-unit>
        <trans-unit id="17e261e522ccbc792cc7bd181c9a0bd755a56975" translate="yes" xml:space="preserve">
          <source>For each pathname given via the command-line or from a file via &lt;code&gt;--stdin&lt;/code&gt;, check whether the file is excluded by .gitignore (or other input files to the exclude mechanism) and output the path if it is excluded.</source>
          <target state="translated">Для каждого пути, указанного через командную строку или из файла через &lt;code&gt;--stdin&lt;/code&gt; , проверьте, исключен ли файл с помощью .gitignore (или других входных файлов в механизм исключения), и выведите путь, если он исключен.</target>
        </trans-unit>
        <trans-unit id="3b2b4e958456928c896ce5a2236319df3a467837" translate="yes" xml:space="preserve">
          <source>For each reference update that was added to the transaction, the hook receives on standard input a line of the format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b8eb760e478aaaedca171d489f16e4864063c9" translate="yes" xml:space="preserve">
          <source>For each repo that you want accessible from CVS you need to edit config in the repo and add the following section.</source>
          <target state="translated">Для каждого репо,которое вы хотите получить доступ из CVS,вам нужно отредактировать конфигурацию в репо и добавить следующий раздел.</target>
        </trans-unit>
        <trans-unit id="4a6b07eab1d3f6d06954967f77b7754d8ea06736" translate="yes" xml:space="preserve">
          <source>For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Для каждой обновленной или успешно отправленной ветки добавьте ссылку на восходящий поток (отслеживание), используемую &lt;a href=&quot;git-pull&quot;&gt;git-pull [1] без&lt;/a&gt; аргументов и другими командами. Для получения дополнительной информации см &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="288f34b4fe961722eeaf789d738c3abe79ce0128" translate="yes" xml:space="preserve">
          <source>For every pathname, this command will list if each attribute is &lt;code&gt;unspecified&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;unset&lt;/code&gt; as a gitattribute on that pathname.</source>
          <target state="translated">Для каждого имени пути эта команда перечислит, если каждый атрибут &lt;code&gt;unspecified&lt;/code&gt; указан , &lt;code&gt;set&lt;/code&gt; или не &lt;code&gt;unset&lt;/code&gt; как gitattribute для этого имени пути.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">Например</target>
        </trans-unit>
        <trans-unit id="b8684a0f4f3937af285df51bf478195b9b43d0d0" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; by default (unless &lt;code&gt;--export-all&lt;/code&gt; option is used) allows pulling only for those repositories that have &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file. Adding</source>
          <target state="translated">Например, &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; по умолчанию (если не &lt;code&gt;--export-all&lt;/code&gt; параметр --export-all ) позволяет извлекать только те репозитории, в которых есть файл &lt;code&gt;git-daemon-export-ok&lt;/code&gt; . Добавление</target>
        </trans-unit>
        <trans-unit id="46e0aea8ec6e607a64677afaf2a0016d08ab966a" translate="yes" xml:space="preserve">
          <source>For example David Miller wrote &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt;:</source>
          <target state="translated">Например, Дэвид Миллер написал &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0e389491903e64c421beccd08371ba327e60cc0c" translate="yes" xml:space="preserve">
          <source>For example an effect from the submodule&amp;rsquo;s &lt;code&gt;.gitignore&lt;/code&gt; file would be observed when you run &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; in the superproject. This collects information from the submodule&amp;rsquo;s working directory by running &lt;code&gt;status&lt;/code&gt; in the submodule while paying attention to the &lt;code&gt;.gitignore&lt;/code&gt; file of the submodule.</source>
          <target state="translated">Например, эффект от файла &lt;code&gt;.gitignore&lt;/code&gt; подмодуля будет наблюдаться, когда вы запустите &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; в суперпроекте. Это собирает информацию из рабочего каталога подмодуля, выполняя &lt;code&gt;status&lt;/code&gt; в подмодуле, обращая внимание на файл &lt;code&gt;.gitignore&lt;/code&gt; подмодуля.</target>
        </trans-unit>
        <trans-unit id="56e9b1c030d9ba0ed8f301bc4d928b5ec348ecfb" translate="yes" xml:space="preserve">
          <source>For example if commit &lt;code&gt;foo&lt;/code&gt; has been replaced by commit &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">Например, если commit &lt;code&gt;foo&lt;/code&gt; был заменен &lt;code&gt;bar&lt;/code&gt; фиксации :</target>
        </trans-unit>
        <trans-unit id="fc4ffa566856e8487717cc75478e8ddebf738773" translate="yes" xml:space="preserve">
          <source>For example if repositories you are hosting use &quot;phtml&quot; extension for PHP files, and you want to have correct syntax-highlighting for those files, you can add the following to gitweb configuration:</source>
          <target state="translated">Например,если репозитории,которые вы размещаете,используют расширение &quot;phtml&quot; для PHP-файлов,и вы хотите иметь правильный синтаксис для этих файлов,вы можете добавить в конфигурацию gitweb следующее:</target>
        </trans-unit>
        <trans-unit id="5154cf5119ca3a0384ad194cc198ec59c07c7ac1" translate="yes" xml:space="preserve">
          <source>For example if we start with a graph like this:</source>
          <target state="translated">Например,если мы начнем с такого графика:</target>
        </trans-unit>
        <trans-unit id="011e69a8d88e3f2ecd0b2c97750e695437a8b7be" translate="yes" xml:space="preserve">
          <source>For example one branch can change the semantic of a function while the other branch add more calls to the same function.</source>
          <target state="translated">Например,одна ветвь может изменить семантику функции,в то время как другая добавляет новые вызовы к той же самой функции.</target>
        </trans-unit>
        <trans-unit id="948250d1153d7a9c5c187de68da76cbf9fe7a0b6" translate="yes" xml:space="preserve">
          <source>For example since all normal branches are stored under &lt;code&gt;refs/heads/&lt;/code&gt; name the tag fixup branch &lt;code&gt;TAG_FIXUP&lt;/code&gt;. This way it is impossible for the fixup branch used by the importer to have namespace conflicts with real branches imported from the source (the name &lt;code&gt;TAG_FIXUP&lt;/code&gt; is not &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt;).</source>
          <target state="translated">Например, поскольку все нормальные ветки хранятся в каталоге &lt;code&gt;refs/heads/&lt;/code&gt; name, ветвь &lt;code&gt;TAG_FIXUP&lt;/code&gt; тегов TAG_FIXUP . Таким образом, для ветки исправления, используемой импортером, невозможно конфликты пространства имен с реальными ветвями, импортированными из источника (имя &lt;code&gt;TAG_FIXUP&lt;/code&gt; не &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4be01aa529e151bdbbe73a5ece143631e964e4ac" translate="yes" xml:space="preserve">
          <source>For example some test suites could be run automatically at night with some unusual (or even random) configurations. And if a regression is found by a test suite, then &quot;git bisect&quot; can be automatically launched, and its result can be emailed to the author of the first bad commit found by &quot;git bisect&quot;, and perhaps other people too. And a new entry in the bug tracking system could be automatically created too.</source>
          <target state="translated">Например,некоторые наборы тестов могут быть запущены автоматически ночью с некоторыми необычными (или даже случайными)конфигурациями.А если регрессия найдена тестовым набором,то &quot;git-бисект&quot; может быть автоматически запущен,и его результат может быть отправлен по электронной почте автору первого плохого коммита,найденного &quot;git-бисектом&quot;,и,возможно,другим людям тоже.И новая запись в системе отслеживания ошибок тоже может быть создана автоматически.</target>
        </trans-unit>
        <trans-unit id="8bbfe98ebcd584e72bba80caca0bbe3de761fb8b" translate="yes" xml:space="preserve">
          <source>For example using:</source>
          <target state="translated">Например,использование:</target>
        </trans-unit>
        <trans-unit id="b2715e2afcd57211e00aecf4fa8f8efd172203eb" translate="yes" xml:space="preserve">
          <source>For example with the following graph where H is the &quot;bad&quot; commit and A and D are some parents of some &quot;good&quot; commits:</source>
          <target state="translated">Например,на следующем графике H-это &quot;плохой&quot; коммит,а A и D-это родители некоторых &quot;хороших&quot; коммитов:</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">Например,</target>
        </trans-unit>
        <trans-unit id="33f7a1b1f9148ad49a81c77432db9d624e3ed14b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--batch&lt;/code&gt; without a custom format would produce:</source>
          <target state="translated">Например, &lt;code&gt;--batch&lt;/code&gt; без специального формата выдаст:</target>
        </trans-unit>
        <trans-unit id="f103141294055917b49b4ff3b11f28f0e7b09a93" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; omits those commits from &lt;code&gt;B&lt;/code&gt; which are in &lt;code&gt;A&lt;/code&gt; or are patch-equivalent to a commit in &lt;code&gt;A&lt;/code&gt;. In other words, this lists the &lt;code&gt;+&lt;/code&gt; commits from &lt;code&gt;git cherry A B&lt;/code&gt;. More precisely, &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; gives the exact list.</source>
          <target state="translated">Например, &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; опускает те коммиты из &lt;code&gt;B&lt;/code&gt; , которые находятся в &lt;code&gt;A&lt;/code&gt; или являются патч-эквивалентно фиксации в &lt;code&gt;A&lt;/code&gt; . Другими словами, это список &lt;code&gt;+&lt;/code&gt; коммитов из &lt;code&gt;git cherry A B&lt;/code&gt; . Точнее, &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; дает точный список.</target>
        </trans-unit>
        <trans-unit id="f8a58c9ab1aebec2fe76ee8cb4f7dc47b3afba08" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--word-diff-regex=.&lt;/code&gt; will treat each character as a word and, correspondingly, show differences character by character.</source>
          <target state="translated">Например, &lt;code&gt;--word-diff-regex=.&lt;/code&gt; будет рассматривать каждый символ как слово и, соответственно, отображать различия посимвольно.</target>
        </trans-unit>
        <trans-unit id="9497e805114a62dd0cfbb0fd446cb80188b76834" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; will check out the first bad revision, while &lt;code&gt;git bisect reset HEAD&lt;/code&gt; will leave you on the current bisection commit and avoid switching commits at all.</source>
          <target state="translated">Например, &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; проверит первую неверную ревизию, а &lt;code&gt;git bisect reset HEAD&lt;/code&gt; оставит вас на текущем коммите деления пополам и вообще не переключит коммиты.</target>
        </trans-unit>
        <trans-unit id="fe1483bfc3665f725dee6688f5887a817d1f226c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;main-worktree/HEAD&lt;/code&gt; or &lt;code&gt;main-worktree/refs/bisect/good&lt;/code&gt; resolve to the same value as the main working tree&amp;rsquo;s &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;refs/bisect/good&lt;/code&gt; respectively. Similarly, &lt;code&gt;worktrees/foo/HEAD&lt;/code&gt; or &lt;code&gt;worktrees/bar/refs/bisect/bad&lt;/code&gt; are the same as &lt;code&gt;$GIT_COMMON_DIR/worktrees/foo/HEAD&lt;/code&gt; and &lt;code&gt;$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138442d2b65de29c2047a8caafb4d9bebbf214b3" translate="yes" xml:space="preserve">
          <source>For example, Documentation/*.jpg will match all .jpg files in the Documentation subtree, including Documentation/chapter_1/figure_1.jpg.</source>
          <target state="translated">Например,Documentation/*.jpg будет соответствовать всем .jpg файлам в поддереве Documentation,включая Documentation/chapter_1/figure_1.jpg.</target>
        </trans-unit>
        <trans-unit id="0d743ee5b8f526c69043aec1a6e6a8e47be44f66" translate="yes" xml:space="preserve">
          <source>For example, Microsoft Visual Studio resources files (&lt;code&gt;*.rc&lt;/code&gt;) or PowerShell script files (&lt;code&gt;*.ps1&lt;/code&gt;) are sometimes encoded in UTF-16. If you declare &lt;code&gt;*.ps1&lt;/code&gt; as files as UTF-16 and you add &lt;code&gt;foo.ps1&lt;/code&gt; with a &lt;code&gt;working-tree-encoding&lt;/code&gt; enabled Git client, then &lt;code&gt;foo.ps1&lt;/code&gt; will be stored as UTF-8 internally. A client without &lt;code&gt;working-tree-encoding&lt;/code&gt; support will checkout &lt;code&gt;foo.ps1&lt;/code&gt; as UTF-8 encoded file. This will typically cause trouble for the users of this file.</source>
          <target state="translated">Например, файлы ресурсов Microsoft Visual Studio ( &lt;code&gt;*.rc&lt;/code&gt; ) или файлы сценариев PowerShell ( &lt;code&gt;*.ps1&lt;/code&gt; ) иногда кодируются в UTF-16. Если вы объявляете &lt;code&gt;*.ps1&lt;/code&gt; как файлы как UTF-16 и добавляете &lt;code&gt;foo.ps1&lt;/code&gt; с клиентом Git с включенным &lt;code&gt;working-tree-encoding&lt;/code&gt; , то &lt;code&gt;foo.ps1&lt;/code&gt; будет сохранен как UTF-8 внутри. Клиент без поддержки &lt;code&gt;working-tree-encoding&lt;/code&gt; будет &lt;code&gt;foo.ps1&lt;/code&gt; как файл в кодировке UTF-8. Обычно это вызывает проблемы у пользователей этого файла.</target>
        </trans-unit>
        <trans-unit id="1ed869792207741cfe6bed98106c7b8b8a3d4f0d" translate="yes" xml:space="preserve">
          <source>For example, a patch that talks about updating &lt;code&gt;a/git-gui.sh&lt;/code&gt; to &lt;code&gt;b/git-gui.sh&lt;/code&gt; can be applied to the file in the working tree &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; by running &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt;.</source>
          <target state="translated">Например, патч, в котором говорится об обновлении &lt;code&gt;a/git-gui.sh&lt;/code&gt; до &lt;code&gt;b/git-gui.sh&lt;/code&gt; , можно применить к файлу в рабочем дереве &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; , запустив &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce77d8f6da94ff85eab04ae4cdac09d8840be36a" translate="yes" xml:space="preserve">
          <source>For example, a pattern &lt;code&gt;doc/frotz/&lt;/code&gt; matches &lt;code&gt;doc/frotz&lt;/code&gt; directory, but not &lt;code&gt;a/doc/frotz&lt;/code&gt; directory; however &lt;code&gt;frotz/&lt;/code&gt; matches &lt;code&gt;frotz&lt;/code&gt; and &lt;code&gt;a/frotz&lt;/code&gt; that is a directory (all paths are relative from the &lt;code&gt;.gitignore&lt;/code&gt; file).</source>
          <target state="translated">Например, шаблон &lt;code&gt;doc/frotz/&lt;/code&gt; соответствует каталогу &lt;code&gt;doc/frotz&lt;/code&gt; , но не каталогу &lt;code&gt;a/doc/frotz&lt;/code&gt; ; однако &lt;code&gt;frotz/&lt;/code&gt; соответствует &lt;code&gt;frotz&lt;/code&gt; и &lt;code&gt;a/frotz&lt;/code&gt; который является каталогом (все пути являются относительными от файла &lt;code&gt;.gitignore&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="67b1d0bce407e8b4870f6f6a95250837544f5b7b" translate="yes" xml:space="preserve">
          <source>For example, an attempt to rearrange</source>
          <target state="translated">Например,попытка перестроить</target>
        </trans-unit>
        <trans-unit id="5bf319ce2803b376c46250398e2ab2c650bad072" translate="yes" xml:space="preserve">
          <source>For example, at the time this page was written, the &lt;a href=&quot;http://repo.or.cz&quot;&gt;http://repo.or.cz&lt;/a&gt; Git hosting site set it to the following to enable graphical log (using the third party tool &lt;strong&gt;git-browser&lt;/strong&gt;):</source>
          <target state="translated">Например, во время написания этой страницы на сайте хостинга &lt;a href=&quot;http://repo.or.cz&quot;&gt;http://repo.or.cz&lt;/a&gt; Git было установлено следующее, чтобы включить графический журнал (с помощью стороннего инструмента &lt;strong&gt;git-browser&lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="ff9841351106eb72affbaa34cd9000cbe695e6c0" translate="yes" xml:space="preserve">
          <source>For example, consider a git repository containing:</source>
          <target state="translated">Например,рассмотрим git-репозиторий,содержащий:</target>
        </trans-unit>
        <trans-unit id="aa3e19341d33b69e0c7637f09cb4c872d477e052" translate="yes" xml:space="preserve">
          <source>For example, for the above graph, a command like:</source>
          <target state="translated">Например,для вышеприведенного графика,команда типа:</target>
        </trans-unit>
        <trans-unit id="e5fffc70646f6a27f7f67e5894c9b6fc5ccd683b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$projectroot&lt;/code&gt; is set to &quot;/srv/git&quot; by putting the following in gitweb config file:</source>
          <target state="translated">Например, если для &lt;code&gt;$projectroot&lt;/code&gt; установлено значение &quot;/ srv / git&quot;, поместив в файл конфигурации gitweb следующее:</target>
        </trans-unit>
        <trans-unit id="852dc3836c1061d866e063a7498878f33ef3ce12" translate="yes" xml:space="preserve">
          <source>For example, if the P4 repository structure is:</source>
          <target state="translated">Например,если структура репозитория P4:</target>
        </trans-unit>
        <trans-unit id="36dce8b0d031af7904e6cd8255529f9ec8396929" translate="yes" xml:space="preserve">
          <source>For example, if the file you want to change is some sort of config file, the repository can include a sample config file that can then be copied into the ignored name and modified. The repository can even include a script to treat the sample file as a template, modifying and copying it automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4035b3eacf18f396eb5e00ae6815d18cf72feae5" translate="yes" xml:space="preserve">
          <source>For example, if the value for this option is &quot;%=$&quot;, then only lines using the format &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; with &amp;lt;sep&amp;gt; containing &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; and then spaces will be considered trailers. And &lt;code&gt;%&lt;/code&gt; will be the default separator used, so by default trailers will appear like: &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; (one percent sign and one space will appear between the token and the value).</source>
          <target state="translated">Например, если значение этой опции равно &amp;laquo;% = $&amp;raquo;, то только строки, в которых используется формат &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; с &amp;lt;sep&amp;gt;, содержащим &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; или &lt;code&gt;$&lt;/code&gt; , а затем пробелы, будут считаться концевыми. И &lt;code&gt;%&lt;/code&gt; будет используемым разделителем по умолчанию, поэтому по умолчанию трейлеры будут выглядеть так: &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; (между токеном и значением появится один знак процента и один пробел).</target>
        </trans-unit>
        <trans-unit id="534223d4530dd35132999074203db95c4ecee123" translate="yes" xml:space="preserve">
          <source>For example, if this variable is set to &quot;refs/for&quot;, pushing to reference such as &quot;refs/for/master&quot; will not create or update a reference named &quot;refs/for/master&quot;, but may create or update a pull request directly by running the hook &quot;proc-receive&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5103535d9f29750b8c9135f826c57c311f8eeae1" translate="yes" xml:space="preserve">
          <source>For example, if we want a password for &lt;code&gt;https://example.com/foo.git&lt;/code&gt;, we might generate the following credential description (don&amp;rsquo;t forget the blank line at the end; it tells &lt;code&gt;git credential&lt;/code&gt; that the application finished feeding all the information it has):</source>
          <target state="translated">Например, если нам нужен пароль для &lt;code&gt;https://example.com/foo.git&lt;/code&gt; , мы можем сгенерировать следующее описание учетных данных (не забудьте пустую строку в конце; она сообщает &lt;code&gt;git credential&lt;/code&gt; данным git, что приложение завершило загрузку всех имеющуюся информацию):</target>
        </trans-unit>
        <trans-unit id="bb2f882b3f8efdae1333b719a705576641ca3f31" translate="yes" xml:space="preserve">
          <source>For example, if you are looking for a commit that introduced a performance regression, you might use</source>
          <target state="translated">Например,если вы ищете коммит,который ввел регрессию производительности,вы можете использовать</target>
        </trans-unit>
        <trans-unit id="68d306989ac898943c9324c1636692924527fd1d" translate="yes" xml:space="preserve">
          <source>For example, if you have this topology:</source>
          <target state="translated">Например,если у вас такая топология:</target>
        </trans-unit>
        <trans-unit id="a61cdb8cd8334eeef24d9dfefb310bcbd689195c" translate="yes" xml:space="preserve">
          <source>For example, if you have two branches, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, a usual way to list all commits on only one side of them is with &lt;code&gt;--left-right&lt;/code&gt; (see the example below in the description of the &lt;code&gt;--left-right&lt;/code&gt; option). However, it shows the commits that were cherry-picked from the other branch (for example, &amp;ldquo;3rd on b&amp;rdquo; may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.</source>
          <target state="translated">Например, если у вас есть две ветки, &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , обычный способ перечислить все коммиты только с одной из них - с помощью &lt;code&gt;--left-right&lt;/code&gt; (см. Пример ниже в описании параметра &lt;code&gt;--left-right&lt;/code&gt; ) , Однако он показывает коммиты, выбранные из другой ветки (например, &amp;laquo;3rd on b&amp;raquo; может быть выбран из ветки A). С этой опцией такие пары коммитов исключаются из вывода.</target>
        </trans-unit>
        <trans-unit id="fe897c525854ed4ff520e569183f4547ca07cbf6" translate="yes" xml:space="preserve">
          <source>For example, if you use mod_perl to run the script, and have dumb HTTP protocol authentication configured for your repositories, you can use the following hook to allow access only if the user is authorized to read the files:</source>
          <target state="translated">Например,если вы используете mod_perl для запуска скрипта,и для ваших репозиториев настроена дурацкая аутентификация по протоколу HTTP,вы можете использовать следующий крюк,чтобы разрешить доступ только в том случае,если пользователь авторизован на чтение файлов:</target>
        </trans-unit>
        <trans-unit id="86c7872b373de97c557b525ebe5143ba729f1f41" translate="yes" xml:space="preserve">
          <source>For example, if you want to reorder the last 5 commits, such that what was HEAD~4 becomes the new HEAD. To achieve that, you would call &lt;code&gt;git rebase&lt;/code&gt; like this:</source>
          <target state="translated">Например, если вы хотите изменить порядок последних 5 коммитов, чтобы то, что было HEAD ~ 4, стало новым HEAD. Для этого вы должны вызвать &lt;code&gt;git rebase&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="3cb17626983b1627f4a677c41e03478d83711c28" translate="yes" xml:space="preserve">
          <source>For example, imagine you store the refs for each fork in &lt;code&gt;refs/virtual/ID&lt;/code&gt;, where &lt;code&gt;ID&lt;/code&gt; is a numeric identifier. You might then configure:</source>
          <target state="translated">Например, представьте, что вы храните ссылки для каждой вилки в &lt;code&gt;refs/virtual/ID&lt;/code&gt; , где &lt;code&gt;ID&lt;/code&gt; - это числовой идентификатор. Затем вы можете настроить:</target>
        </trans-unit>
        <trans-unit id="30bbf60289c9238f0d33e5175010f4e252c9853c" translate="yes" xml:space="preserve">
          <source>For example, in .gitattributes, you would assign the &lt;code&gt;filter&lt;/code&gt; attribute for paths.</source>
          <target state="translated">Например, в .gitattributes вы должны назначить атрибут &lt;code&gt;filter&lt;/code&gt; для путей.</target>
        </trans-unit>
        <trans-unit id="c7b53804fabf5a8d611f469400f3d23e0cdaf582" translate="yes" xml:space="preserve">
          <source>For example, in a commit history like this:</source>
          <target state="translated">Например,в истории коммитов,как эта:</target>
        </trans-unit>
        <trans-unit id="806ca5f41259915dee6774976f8cdf13ec61deac" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say that you have worked on your working directory, updated some files in the index and are ready to commit. You want to see exactly &lt;strong&gt;what&lt;/strong&gt; you are going to commit, without having to write a new tree object and compare it that way, and to do that, you just do</source>
          <target state="translated">Например, предположим, что вы поработали над своим рабочим каталогом, обновили некоторые файлы в индексе и готовы к фиксации. Вы хотите точно увидеть, &lt;strong&gt;что&lt;/strong&gt; вы собираетесь зафиксировать, без необходимости писать новый объект дерева и сравнивать его таким образом, и для этого вам просто нужно сделать</target>
        </trans-unit>
        <trans-unit id="476c3fc4a50784809d3ca0defbcdf28a5bcb4395" translate="yes" xml:space="preserve">
          <source>For example, main-worktree/HEAD or main-worktree/refs/bisect/good resolve to the same value as the main working tree&amp;rsquo;s HEAD and refs/bisect/good respectively. Similarly, worktrees/foo/HEAD or worktrees/bar/refs/bisect/bad are the same as GIT_COMMON_DIR/worktrees/foo/HEAD and GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad.</source>
          <target state="translated">Например, main-worktree / HEAD или main-worktree / refs / bisect / good разрешаются к тому же значению, что и HEAD и refs / bisect / good основного рабочего дерева соответственно. Точно так же worktrees / foo / HEAD или worktrees / bar / refs / bisect / bad такие же, как GIT_COMMON_DIR / worktrees / foo / HEAD и GIT_COMMON_DIR / worktrees / bar / refs / bisect / bad.</target>
        </trans-unit>
        <trans-unit id="266db89f5ed370855ec231f0d9586be36c8c2a06" translate="yes" xml:space="preserve">
          <source>For example, running &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; generates this tree object from the index, stores it in the object database, and uses it as the tree object associated with the new commit.</source>
          <target state="translated">Например, запуск &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; генерирует этот объект дерева из индекса, сохраняет его в базе данных объектов и использует его как объект дерева, связанный с новой фиксацией.</target>
        </trans-unit>
        <trans-unit id="9241280c5dcf375f9e4ee8c8496a1f68f481ea18" translate="yes" xml:space="preserve">
          <source>For example, starting with this index:</source>
          <target state="translated">Например,начиная с этого индекса:</target>
        </trans-unit>
        <trans-unit id="37236815fc65047678c9d53df59b5a94b9133df3" translate="yes" xml:space="preserve">
          <source>For example, the following fetch command spawned ssh, index-pack, rev-list, and gc. This example also shows that fetch took 5.199 seconds and of that 4.932 was in ssh.</source>
          <target state="translated">Например,следующая команда fetch породила ssh,index-pack,rev-list и gc.Этот пример также показывает,что выборка заняла 5.199 секунд и из них 4.932 была в ssh.</target>
        </trans-unit>
        <trans-unit id="675eb647719ee2ad2bd9af2ee96b8f7029195efd" translate="yes" xml:space="preserve">
          <source>For example, the following setting produces a breadcrumb trail like &quot;home / dev / projects / &amp;hellip;​&quot; where &quot;projects&quot; is the home link.</source>
          <target state="translated">Например, следующий параметр создает цепочку навигации типа &amp;laquo;home / dev / projects /&amp;hellip;&amp;raquo;, где &amp;laquo;projects&amp;raquo; - это домашняя ссылка.</target>
        </trans-unit>
        <trans-unit id="f229d0901b53da5a8037ba5b963ab5e1b0a84fc7" translate="yes" xml:space="preserve">
          <source>For example, the hook can simply run &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; in order to emulate &lt;code&gt;git fetch&lt;/code&gt; that is run in the reverse direction with &lt;code&gt;git push&lt;/code&gt;, as the two-tree form of &lt;code&gt;git read-tree -u -m&lt;/code&gt; is essentially the same as &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that switches branches while keeping the local changes in the working tree that do not interfere with the difference between the branches.</source>
          <target state="translated">Например, ловушка может просто запустить &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; , чтобы имитировать &lt;code&gt;git fetch&lt;/code&gt; , который запускается в обратном направлении с помощью &lt;code&gt;git push&lt;/code&gt; , как двухдеревная форма &lt;code&gt;git read-tree -u -m&lt;/code&gt; по сути то же самое, что &lt;code&gt;git switch&lt;/code&gt; или &lt;code&gt;git checkout&lt;/code&gt; , который переключает ветви, сохраняя при этом локальные изменения в рабочем дереве, которые не влияют на разницу между ветвями.</target>
        </trans-unit>
        <trans-unit id="2232af53268b39393df426da2516589a0d0a00e9" translate="yes" xml:space="preserve">
          <source>For example, the multithreaded preload-index code can be instrumented with a region around the thread pool and then per-thread start and exit events within the threadproc.</source>
          <target state="translated">Например,многопоточный предзагрузочный код может быть инструментирован с регионом вокруг пула потоков,а затем с событиями запуска и выхода из потока внутри threadproc.</target>
        </trans-unit>
        <trans-unit id="c6165309453e90635fafde69fa6a0dbf363059c7" translate="yes" xml:space="preserve">
          <source>For example, there can be a &quot;main&quot; branch, and a &quot;dev&quot; branch that was forked of the main branch at a commit named &quot;D&quot; like this:</source>
          <target state="translated">Например,может быть &quot;главное&quot; ответвление,а также &quot;девственное&quot; ответвление,которое было вилкой главного ответвления при коммите с именем &quot;D&quot;,как это было сделано:</target>
        </trans-unit>
        <trans-unit id="fc0695ddae75754b17aaf6b6d741676357b02fb6" translate="yes" xml:space="preserve">
          <source>For example, this configuration:</source>
          <target state="translated">Например,такая конфигурация:</target>
        </trans-unit>
        <trans-unit id="03526c1b7e3b294cd55189c8a4305129233dcf64" translate="yes" xml:space="preserve">
          <source>For example, this line in &lt;code&gt;.gitattributes&lt;/code&gt; can be used to tell the merge machinery to leave much longer (instead of the usual 7-character-long) conflict markers when merging the file &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; results in a conflict.</source>
          <target state="translated">Например, эту строку в &lt;code&gt;.gitattributes&lt;/code&gt; можно использовать, чтобы сообщить механизму слияния, чтобы он оставлял гораздо более длинные (вместо обычных 7 &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; ) маркеры конфликта, когда слияние файла Documentation / git-merge.txt приводит к конфликту.</target>
        </trans-unit>
        <trans-unit id="0b89cc0f3038d951dcea25e6121459d7deb13668" translate="yes" xml:space="preserve">
          <source>For example, to default to pushing only the current branch to &lt;code&gt;origin&lt;/code&gt; use &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt;. Any valid &amp;lt;refspec&amp;gt; (like the ones in the examples below) can be configured as the default for &lt;code&gt;git push origin&lt;/code&gt;.</source>
          <target state="translated">Например, по умолчанию для отправки только текущей ветки в &lt;code&gt;origin&lt;/code&gt; используйте &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt; . Любой действительный &amp;lt;refspec&amp;gt; (например, в примерах ниже) можно настроить как значение по умолчанию для &lt;code&gt;git push origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="119ea88469245e9be5ce50fb433af7f4a91870c1" translate="yes" xml:space="preserve">
          <source>For example, to show the diff of the exif information of a file instead of the binary information (assuming you have the exif tool installed), add the following section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file):</source>
          <target state="translated">Например, чтобы показать различие информации exif файла вместо двоичной информации (при условии, что у вас установлен инструмент exif), добавьте следующий раздел в свой файл &lt;code&gt;$GIT_DIR/config&lt;/code&gt; (или файл &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0cf3c72a4130dae24f8e93d376c795356d04a806" translate="yes" xml:space="preserve">
          <source>For example, with this topology:</source>
          <target state="translated">Например,с такой топологией:</target>
        </trans-unit>
        <trans-unit id="9026d38d92fad70bfcca633c7e54419876aa74d7" translate="yes" xml:space="preserve">
          <source>For example, with this:</source>
          <target state="translated">Например,с этим:</target>
        </trans-unit>
        <trans-unit id="94a38b75a57da5e0f9eccf5408c94c3056500ecd" translate="yes" xml:space="preserve">
          <source>For example, you can choose a single person to maintain the project&amp;rsquo;s primary public repository. Other developers then clone this repository and each work in their own clone. When they have a series of changes that they&amp;rsquo;re happy with, they ask the maintainer to pull from the branch containing the changes. The maintainer reviews their changes and pulls them into the primary repository, which other developers pull from as necessary to stay coordinated. The Linux kernel and other projects use variants of this model.</source>
          <target state="translated">Например, вы можете выбрать одного человека для ведения основного общедоступного репозитория проекта. Затем другие разработчики клонируют этот репозиторий, и каждый работает в своем собственном клоне. Когда у них есть серия изменений, которыми они довольны, они просят сопровождающего извлечь из ветки, содержащей изменения. Сопровождающий просматривает их изменения и переносит их в основной репозиторий, из которого другие разработчики извлекают по мере необходимости для координации. Ядро Linux и другие проекты используют варианты этой модели.</target>
        </trans-unit>
        <trans-unit id="0740e14a7a7f21956f0379ce28c5b2be003ef53b" translate="yes" xml:space="preserve">
          <source>For example, you&amp;rsquo;d want to do this after doing a &lt;code&gt;git read-tree&lt;/code&gt;, to link up the stat index details with the proper files.</source>
          <target state="translated">Например, вы захотите сделать это после выполнения &lt;code&gt;git read-tree&lt;/code&gt; , чтобы связать детали индекса статистики с соответствующими файлами.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="0af803cded757214a9f60d6e61360566eb8261f1" translate="yes" xml:space="preserve">
          <source>For git&amp;rsquo;s pre-defined color slots, the attributes are meant to be reset at the beginning of each item in the colored output. So setting &lt;code&gt;color.decorate.branch&lt;/code&gt; to &lt;code&gt;black&lt;/code&gt; will paint that branch name in a plain &lt;code&gt;black&lt;/code&gt;, even if the previous thing on the same output line (e.g. opening parenthesis before the list of branch names in &lt;code&gt;log --decorate&lt;/code&gt; output) is set to be painted with &lt;code&gt;bold&lt;/code&gt; or some other attribute. However, custom log formats may do more complicated and layered coloring, and the negated forms may be useful there.</source>
          <target state="translated">Для предопределенных цветовых слотов git атрибуты должны быть сброшены в начале каждого элемента в цветном выводе. Таким образом, установка &lt;code&gt;color.decorate.branch&lt;/code&gt; в &lt;code&gt;black&lt;/code&gt; закрасит это имя ветки простым &lt;code&gt;black&lt;/code&gt; , даже если предыдущая вещь в той же строке вывода (например, открывающая скобка перед списком имен веток в &lt;code&gt;log --decorate&lt;/code&gt; output) установлена ​​как окрашены &lt;code&gt;bold&lt;/code&gt; или другим атрибутом. Однако пользовательские форматы журналов могут иметь более сложную и многоуровневую окраску, и здесь могут быть полезны инвертированные формы.</target>
        </trans-unit>
        <trans-unit id="e39902dddf1a6f048d53b1c87575ee4b12254521" translate="yes" xml:space="preserve">
          <source>For hints on submission using the IMAP interface, see the EXAMPLE section of &lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send[1]&lt;/a&gt;.</source>
          <target state="translated">Подсказки по отправке с использованием интерфейса IMAP см. В разделе ПРИМЕР &lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="30ba9877f29cd2e9b6e46df54ef9603700cf47bd" translate="yes" xml:space="preserve">
          <source>For hints on using &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, see the EXAMPLE section of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">Подсказки по использованию &lt;code&gt;git send-email&lt;/code&gt; для отправки патчей через SMTP-сервер GMail см. В разделе ПРИМЕР в &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98a5ba2755b886f28a6b38a3063fb22b4953fd08" translate="yes" xml:space="preserve">
          <source>For instance, if the command &lt;code&gt;git push origin master:foreign&lt;/code&gt; were run the hook would receive a line like the following:</source>
          <target state="translated">Например, если была запущена команда &lt;code&gt;git push origin master:foreign&lt;/code&gt; , ловушка получит строку, подобную следующей:</target>
        </trans-unit>
        <trans-unit id="b7654d69e08e0a1f9383662a9764223dc833d854" translate="yes" xml:space="preserve">
          <source>For instance, if the main working tree (or bare repository) is moved, linked working trees will be unable to locate it. Running &lt;code&gt;repair&lt;/code&gt; in the main working tree will reestablish the connection from linked working trees back to the main working tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0da88c77b6050a1f8498227b0e9ea61aad1dd42" translate="yes" xml:space="preserve">
          <source>For instance, if you configured the &lt;code&gt;diff.algorithm&lt;/code&gt; variable to a non-default value and want to use the default one, then you have to use &lt;code&gt;--diff-algorithm=default&lt;/code&gt; option.</source>
          <target state="translated">Например, если вы настроили для переменной &lt;code&gt;diff.algorithm&lt;/code&gt; значение, отличное от значения по умолчанию, и хотите использовать значение по умолчанию, тогда вам необходимо использовать параметр &lt;code&gt;--diff-algorithm=default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c03b6c2e674301ea043615909864bcef9fc3a8b4" translate="yes" xml:space="preserve">
          <source>For instance, imagine we are accessing &lt;code&gt;https://example.com/foo.git&lt;/code&gt;. When Git looks into a config file to see if a section matches this context, it will consider the two a match if the context is a more-specific subset of the pattern in the config file. For example, if you have this in your config file:</source>
          <target state="translated">Например, представьте, что мы получаем доступ к &lt;code&gt;https://example.com/foo.git&lt;/code&gt; . Когда Git просматривает файл конфигурации, чтобы увидеть, соответствует ли раздел этому контексту, он будет считать, что оба они совпадают, если контекст является более конкретным подмножеством шаблона в файле конфигурации. Например, если у вас есть это в вашем файле конфигурации:</target>
        </trans-unit>
        <trans-unit id="160dca6e4172cec7a014617ee2140fea1d612055" translate="yes" xml:space="preserve">
          <source>For internal use only. Used in handshaking the wire protocol. Contains a colon &lt;code&gt;:&lt;/code&gt; separated list of keys with optional values &lt;code&gt;key[=value]&lt;/code&gt;. Presence of unknown keys and values must be ignored.</source>
          <target state="translated">Только для внутреннего использования. Используется для подтверждения проводного протокола. Содержит двоеточие &lt;code&gt;:&lt;/code&gt; список разделенных ключей с опциональным значений &lt;code&gt;key[=value]&lt;/code&gt; . Необходимо игнорировать наличие неизвестных ключей и значений.</target>
        </trans-unit>
        <trans-unit id="7c3c8218b8f3420e2d309aa9107b8abd4e99e346" translate="yes" xml:space="preserve">
          <source>For local repositories, also supported by Git natively, the following syntaxes may be used:</source>
          <target state="translated">Для локальных репозиториев,также поддерживаемых Git'ом нативно,можно использовать следующие синтаксисы:</target>
        </trans-unit>
        <trans-unit id="cc185d3a233093301eeacaae1d44792c3563d415" translate="yes" xml:space="preserve">
          <source>For more detailed explanation on these common options, see also &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt;.</source>
          <target state="translated">Для более подробного объяснения этих общих параметров см. Также &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfb518a2bdb468f6a1698c12278a7c2890c2e01b" translate="yes" xml:space="preserve">
          <source>For more details about the &amp;lt;pathspec&amp;gt; syntax, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения о синтаксисе &amp;lt;pathspec&amp;gt; см. &lt;code&gt;pathspec&lt;/code&gt; записи &lt;a href=&quot;gitglossary&quot;&gt;pathspec&lt;/a&gt; в gitglossary [7] .</target>
        </trans-unit>
        <trans-unit id="f0360b14fd2012ea432fadffcf3782c95bbb3d96" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">Для получения более подробной информации см &lt;code&gt;pathspec&lt;/code&gt; запись в &lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dee223e709585f8622ae3db9c408c2275df286e3" translate="yes" xml:space="preserve">
          <source>For more information about submodules, see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительной информации о подмодулях см. &lt;a href=&quot;gitsubmodules&quot;&gt;Gitsubmodules [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf4d0c9e8fd0a561af6eb800b4aa95d1953e08dc" translate="yes" xml:space="preserve">
          <source>For non-linear topology, such as</source>
          <target state="translated">Для нелинейной топологии,такой как</target>
        </trans-unit>
        <trans-unit id="6869cf2d54fdd333756ee082074da9e8aa4cabf1" translate="yes" xml:space="preserve">
          <source>For now, the paranoid need to find some way to emulate the quarantine environment if they&amp;rsquo;d like the same protection as &quot;push&quot;. E.g. in the case of an internal mirror do the mirroring in two steps, one to fetch the untrusted objects, and then do a second &quot;push&quot; (which will use the quarantine) to another internal repo, and have internal clients consume this pushed-to repository, or embargo internal fetches and only allow them once a full &quot;fsck&quot; has run (and no new fetches have happened in the meantime).</source>
          <target state="translated">На данный момент параноикам нужно найти способ имитировать карантинную среду, если они хотят такую ​​же защиту, как &amp;laquo;толчок&amp;raquo;. Например, в случае внутреннего зеркала выполните зеркальное отображение в два этапа: один для выборки ненадежных объектов, а затем второй &amp;laquo;push&amp;raquo; (который будет использовать карантин) в другое внутреннее репо, и внутренние клиенты будут использовать это отправленное - в репозиторий или запретить внутренние выборки и разрешить их только после того, как будет выполнен полный &quot;fsck&quot; (и пока никаких новых загрузок не произошло).</target>
        </trans-unit>
        <trans-unit id="133fa5a74f060c815b7406a1ab993c4e06ad0024" translate="yes" xml:space="preserve">
          <source>For open source projects it can be a good way to get more useful contributions from end users, and to introduce them to QA and development activities.</source>
          <target state="translated">Для проектов с открытым исходным кодом это может быть хорошим способом получить более полезный вклад от конечных пользователей,а также познакомить их с деятельностью по контролю качества и разработке.</target>
        </trans-unit>
        <trans-unit id="dd41930f44da136ca06d3f66916ab11faa591b27" translate="yes" xml:space="preserve">
          <source>For our first example, we&amp;rsquo;re going to start a totally new repository from scratch, with no pre-existing files, and we&amp;rsquo;ll call it &lt;code&gt;git-tutorial&lt;/code&gt;. To start up, create a subdirectory for it, change into that subdirectory, and initialize the Git infrastructure with &lt;code&gt;git init&lt;/code&gt;:</source>
          <target state="translated">В нашем первом примере мы собираемся создать совершенно новый репозиторий с нуля, без ранее существовавших файлов, и назовем его &lt;code&gt;git-tutorial&lt;/code&gt; . Для запуска создайте для него подкаталог, перейдите в этот подкаталог и инициализируйте инфраструктуру Git с помощью &lt;code&gt;git init&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5307fd3985478faa6faac86f16463cb9c367c366" translate="yes" xml:space="preserve">
          <source>For paths with merge conflicts, &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; show the modification states of each side of the merge. For paths that do not have merge conflicts, &lt;code&gt;X&lt;/code&gt; shows the status of the index, and &lt;code&gt;Y&lt;/code&gt; shows the status of the work tree. For untracked paths, &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;??&lt;/code&gt;. Other status codes can be interpreted as follows:</source>
          <target state="translated">Для путей с конфликтами слияния &lt;code&gt;X&lt;/code&gt; и &lt;code&gt;Y&lt;/code&gt; показывают состояния модификации каждой стороны слияния. Для путей, которые не имеют конфликтов слияния, &lt;code&gt;X&lt;/code&gt; показывает состояние индекса, а &lt;code&gt;Y&lt;/code&gt; показывает состояние рабочего дерева. Для неотслеживаемых путей &lt;code&gt;XY&lt;/code&gt; - &lt;code&gt;??&lt;/code&gt; , Другие коды состояния можно интерпретировать следующим образом:</target>
        </trans-unit>
        <trans-unit id="7032989b4e615b54922dcaa29834b5d11069ae03" translate="yes" xml:space="preserve">
          <source>For people who do parsing: to make it more robust, just ignore any lines between the first and last one (&quot;&amp;lt;sha1&amp;gt;&quot; and &quot;filename&quot; lines) where you do not recognize the tag words (or care about that particular one) at the beginning of the &quot;extended information&quot; lines. That way, if there is ever added information (like the commit encoding or extended commit commentary), a blame viewer will not care.</source>
          <target state="translated">Для людей, которые занимаются синтаксическим анализом: чтобы сделать его более надежным, просто игнорируйте любые строки между первой и последней (строки &amp;laquo;&amp;lt;sha1&amp;gt;&amp;raquo; и &amp;laquo;имя файла&amp;raquo;), где вы не узнаете слова тега (или не заботитесь об этом конкретном). в начале строк &amp;laquo;расширенная информация&amp;raquo;. Таким образом, если будет когда-либо добавлена ​​информация (например, кодировка фиксации или расширенный комментарий фиксации), зрителю обвинения будет все равно.</target>
        </trans-unit>
        <trans-unit id="d3a8933e3664a281a0f1007219c1a5fb906f5b9c" translate="yes" xml:space="preserve">
          <source>For performance reasons, by default, &lt;code&gt;-C&lt;/code&gt; option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one &lt;code&gt;-C&lt;/code&gt; option has the same effect.</source>
          <target state="translated">Из соображений производительности по умолчанию опция &lt;code&gt;-C&lt;/code&gt; находит копии только в том случае, если исходный файл копии был изменен в том же наборе изменений. Этот флаг заставляет команду проверять немодифицированные файлы как кандидатов в источник копии. Это очень дорогая операция для крупных проектов, поэтому используйте ее с осторожностью. Тот же эффект дает более одной опции &lt;code&gt;-C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b9345e0345532d160619f268731569cef16617e" translate="yes" xml:space="preserve">
          <source>For plain blobs, it shows the plain contents.</source>
          <target state="translated">Для простых капель он показывает простое содержимое.</target>
        </trans-unit>
        <trans-unit id="9e1c4f262d546f1a8d01796c1dc838262d4af7ed" translate="yes" xml:space="preserve">
          <source>For precedence rules within and between exclude sources, see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e52f5f667fd4d7c4b839fc8977488698f28dddb" translate="yes" xml:space="preserve">
          <source>For projects with few developers, or for synchronizing a few private repositories, this may be all you need.</source>
          <target state="translated">Для проектов с небольшим количеством разработчиков или для синхронизации нескольких частных репозиториев,это может быть все,что вам нужно.</target>
        </trans-unit>
        <trans-unit id="0fbf0a1225d8cd0da43e8dc6b186868e699b6219" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspec elements, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513a986f0bbc369f77d7fc94a6a47375b99e8d89" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspecs, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="translated">Для быстрого создания снимка вы можете опустить &quot;push&quot;. В этом режиме не допускается использование аргументов, не являющихся опциями, чтобы подкоманда с ошибкой не могла создать нежелательную запись в тайнике. Двумя исключениями из этого являются &lt;code&gt;stash -p&lt;/code&gt; , который действует как псевдоним для &lt;code&gt;stash push -p&lt;/code&gt; , и pathspecs, которые разрешены после двойного дефиса &lt;code&gt;--&lt;/code&gt; для устранения неоднозначности.</target>
        </trans-unit>
        <trans-unit id="10b29e2b2e8e16a8f0d937588e990a303d5a39cb" translate="yes" xml:space="preserve">
          <source>For reading options: read only from global &lt;code&gt;~/.gitconfig&lt;/code&gt; and from &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">Для параметров чтения: читать только из глобального &lt;code&gt;~/.gitconfig&lt;/code&gt; и из &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; а не из всех доступных файлов.</target>
        </trans-unit>
        <trans-unit id="f670c3a49f96ee071030446b2338be3d3b61c282" translate="yes" xml:space="preserve">
          <source>For reading options: read only from system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">Для параметров чтения: читать только из общесистемного &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; а не из всех доступных файлов.</target>
        </trans-unit>
        <trans-unit id="1a0b8cd1ef1778fc9e72b8ac1ede20b2c02305dd" translate="yes" xml:space="preserve">
          <source>For reading options: read only from the repository &lt;code&gt;.git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">Для параметров чтения: читать только из репозитория &lt;code&gt;.git/config&lt;/code&gt; , а не из всех доступных файлов.</target>
        </trans-unit>
        <trans-unit id="52ad1818a91b579273748ec3f745c2ea8925da11" translate="yes" xml:space="preserve">
          <source>For remote helpers that implement &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;, this capability allows the refs to be constrained to a private namespace, instead of writing to refs/heads or refs/remotes directly. It is recommended that all importers providing the &lt;code&gt;import&lt;/code&gt; capability use this. It&amp;rsquo;s mandatory for &lt;code&gt;export&lt;/code&gt;.</source>
          <target state="translated">Для удаленных помощников, которые реализуют &lt;code&gt;import&lt;/code&gt; или &lt;code&gt;export&lt;/code&gt; , эта возможность позволяет ограничить ссылки частным пространством имен вместо прямой записи в ссылки / головы или ссылки / удаленные. Рекомендуется, чтобы все импортеры, предоставляющие возможность &lt;code&gt;import&lt;/code&gt; , использовали это. Это обязательно для &lt;code&gt;export&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="443450d98036603164f83ff3df4c2bf679d11741" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the URL to the proxy to use for that remote. Set to the empty string to disable proxying for that remote.</source>
          <target state="translated">Для пультов,требующих curl (http,https и ftp),URL к прокси-серверу,чтобы использовать его для этого пульта.Установите пустую строку,чтобы отключить проксирование для этого удаленного устройства.</target>
        </trans-unit>
        <trans-unit id="8af93420a9afb3e813edb57f9ce58a35a5de2989" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the method to use for authenticating against the proxy in use (probably set in &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt;). See &lt;code&gt;http.proxyAuthMethod&lt;/code&gt;.</source>
          <target state="translated">Для пультов, требующих curl (http, https и ftp), метод, который следует использовать для аутентификации на используемом прокси-сервере (вероятно, установленный в &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt; ). См. &lt;code&gt;http.proxyAuthMethod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff12c5f69e6a4dbe2b8b7bc739ac234198e179f4" translate="yes" xml:space="preserve">
          <source>For scripting, you can ask it to be quiet with the &quot;--quiet&quot; flag, which allows you to do things like</source>
          <target state="translated">Для скриптинга,вы можете попросить его быть тихим с флагом &quot;--quiet&quot;,который позволяет вам делать такие вещи как</target>
        </trans-unit>
        <trans-unit id="6ad68ca568ca7f00dfca41d4efe640136cb611e6" translate="yes" xml:space="preserve">
          <source>For some frontends, though, it is useful to be able to read back data from the current repository as it is being updated (for example when the source material describes objects in terms of patches to be applied to previously imported objects). This can be accomplished by connecting the frontend and fast-import via bidirectional pipes:</source>
          <target state="translated">Для некоторых фронтов,однако,полезно иметь возможность считывать данные из текущего репозитория по мере его обновления (например,когда в исходном материале описаны объекты с точки зрения патчей,которые будут применяться к ранее импортированным объектам).Это можно сделать,соединив фронтенд и быстрый импорт по двунаправленным каналам:</target>
        </trans-unit>
        <trans-unit id="b5ea8ea5b2c1cd3e6d47c32a09c62d3c70b6ee6f" translate="yes" xml:space="preserve">
          <source>For some interesting examples of Git use, see the &lt;a href=&quot;howto-index&quot;&gt;howtos&lt;/a&gt;.</source>
          <target state="translated">Некоторые интересные примеры использования Git можно найти в &lt;a href=&quot;howto-index&quot;&gt;инструкциях&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd917a632df420113bd1fa62c1a75d6d0838fcf8" translate="yes" xml:space="preserve">
          <source>For sorting purposes, fields with numeric values sort in numeric order (&lt;code&gt;objectsize&lt;/code&gt;, &lt;code&gt;authordate&lt;/code&gt;, &lt;code&gt;committerdate&lt;/code&gt;, &lt;code&gt;creatordate&lt;/code&gt;, &lt;code&gt;taggerdate&lt;/code&gt;). All other fields are used to sort in their byte-value order.</source>
          <target state="translated">Для целей сортировки поля с числовыми значениями сортируются в числовом порядке ( &lt;code&gt;objectsize&lt;/code&gt; , &lt;code&gt;authordate&lt;/code&gt; , &lt;code&gt;committerdate&lt;/code&gt; , &lt;code&gt;creatordate&lt;/code&gt; , &lt;code&gt;taggerdate&lt;/code&gt; ). Все остальные поля используются для сортировки в порядке значений байтов.</target>
        </trans-unit>
        <trans-unit id="032b282727ffc0c1c45df3e884598bae17ea6ac4" translate="yes" xml:space="preserve">
          <source>For specifying settings like &lt;code&gt;verbosity&lt;/code&gt; (how much output to write to stderr) and &lt;code&gt;depth&lt;/code&gt; (how much history is wanted in the case of a shallow clone) that affect how other commands are carried out.</source>
          <target state="translated">Для указания таких параметров, как &lt;code&gt;verbosity&lt;/code&gt; (объем вывода для записи в stderr) и &lt;code&gt;depth&lt;/code&gt; (объем истории, который требуется в случае неглубокого клона), которые влияют на выполнение других команд.</target>
        </trans-unit>
        <trans-unit id="c02205be8f69628f646f89a0276ec82187cc890c" translate="yes" xml:space="preserve">
          <source>For submodules, this setting can be overridden using the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; config setting.</source>
          <target state="translated">Для подмодулей, этот параметр может быть переопределен с помощью &lt;code&gt;submodule.fetchJobs&lt;/code&gt; CONFIG настройки.</target>
        </trans-unit>
        <trans-unit id="c4b69b6e908fa58f8bfb0090b464d01ba7afd33a" translate="yes" xml:space="preserve">
          <source>For such a test, you need to merge master and topic somehow. One way to do it is to pull master into the topic branch:</source>
          <target state="translated">Для такого теста нужно как-то соединить мастера и тему.Один из способов сделать это-втянуть мастера в тематическую ветку:</target>
        </trans-unit>
        <trans-unit id="e3a970f50f86b7e372ecc38ba0a4b965f601d385" translate="yes" xml:space="preserve">
          <source>For tags, it shows the tag message and the referenced objects.</source>
          <target state="translated">Для тегов отображается сообщение тега и связанные с ним объекты.</target>
        </trans-unit>
        <trans-unit id="e66e4764a23ddc1ac17a40208b614c40e3d1e8cd" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;squash&lt;/code&gt; and &lt;code&gt;fixup&lt;/code&gt; operation, all commits that were squashed are listed as being rewritten to the squashed commit. This means that there will be several lines sharing the same &lt;code&gt;new-sha1&lt;/code&gt;.</source>
          <target state="translated">Для &lt;code&gt;squash&lt;/code&gt; и &lt;code&gt;fixup&lt;/code&gt; операции, все коммиты , которые были раздавленные перечислены переписывается в сжатую фиксации. Это означает, что будет несколько строк, использующих один и тот же &lt;code&gt;new-sha1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0288085d533925ac75b1f295d9e834640d8fad16" translate="yes" xml:space="preserve">
          <source>For the complete list of paths which Git checks for references, and the order it uses to decide which to choose when there are multiple references with the same shorthand name, see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Полный список путей, которые Git проверяет на наличие ссылок, и порядок, который он использует, чтобы решить, какие из них выбрать при наличии нескольких ссылок с одним и тем же сокращенным именем, см. В разделе &amp;laquo; &lt;a href=&quot;gitrevisions&quot;&gt;УКАЗАНИЕ&lt;/a&gt; ИЗМЕНЕНИЙ&amp;raquo; в gitrevisions [7] .</target>
        </trans-unit>
        <trans-unit id="44d025151b0ff5e996c1070f067a89933eee64e1" translate="yes" xml:space="preserve">
          <source>For the initial import, &lt;code&gt;git archimport&lt;/code&gt; expects to find itself in an empty directory. To follow the development of a project that uses Arch, rerun &lt;code&gt;git archimport&lt;/code&gt; with the same parameters as the initial import to perform incremental imports.</source>
          <target state="translated">При первоначальном импорте &lt;code&gt;git archimport&lt;/code&gt; ожидает найти себя в пустом каталоге. Чтобы следить за развитием проекта, в котором используется Arch, повторно запустите &lt;code&gt;git archimport&lt;/code&gt; с теми же параметрами, что и исходный импорт, для выполнения добавочного импорта.</target>
        </trans-unit>
        <trans-unit id="c91c81358174e9b87a92bafd019b5720cbf2a8d2" translate="yes" xml:space="preserve">
          <source>For the purpose of breaking a filepair, diffcore-break examines the extent of changes between the contents of the files before and after modification (i.e. the contents that have &quot;bcd1234&amp;hellip;​&quot; and &quot;0123456&amp;hellip;​&quot; as their SHA-1 content ID, in the above example). The amount of deletion of original contents and insertion of new material are added together, and if it exceeds the &quot;break score&quot;, the filepair is broken into two. The break score defaults to 50% of the size of the smaller of the original and the result (i.e. if the edit shrinks the file, the size of the result is used; if the edit lengthens the file, the size of the original is used), and can be customized by giving a number after &quot;-B&quot; option (e.g. &quot;-B75&quot; to tell it to use 75%).</source>
          <target state="translated">С целью разрыва пары файлов, diffcore-break проверяет степень изменений между содержимым файлов до и после модификации (т. Е. Содержимое, имеющее &amp;laquo;bcd1234&amp;hellip;&amp;raquo; и &amp;laquo;0123456&amp;hellip;&amp;raquo; в качестве идентификатора содержимого SHA-1. в приведенном выше примере). Сумма удаления исходного содержимого и вставки нового материала суммируется, и, если она превышает &amp;laquo;оценку разрыва&amp;raquo;, файловая пара разбивается на две части. По умолчанию оценка разрыва составляет 50% от размера меньшего из оригинала и результата (то есть, если редактирование сжимает файл, используется размер результата; если редактирование увеличивает длину файла, используется размер оригинала. ), и его можно настроить, задав число после опции &amp;laquo;-B&amp;raquo; (например, &amp;laquo;-B75&amp;raquo;, чтобы указать, что нужно использовать 75%).</target>
        </trans-unit>
        <trans-unit id="62f1a958bc660b7d22544723f673271098befa81" translate="yes" xml:space="preserve">
          <source>For the purpose of merging broken filepairs back, it uses a different &quot;extent of changes&quot; computation from the ones used by diffcore-break and diffcore-rename. It counts only the deletion from the original, and does not count insertion. If you removed only 10 lines from a 100-line document, even if you added 910 new lines to make a new 1000-line document, you did not do a complete rewrite. diffcore-break breaks such a case in order to help diffcore-rename to consider such filepairs as candidate of rename/copy detection, but if filepairs broken that way were not matched with other filepairs to create rename/copy, then this transformation merges them back into the original &quot;modification&quot;.</source>
          <target state="translated">Для объединения нарушенных файловых пар обратно используется вычисление &quot;степени изменений&quot;,отличное от вычислений,используемых для diffcore-break и diffcore-rename.Он учитывает только удаление из оригинала и не учитывает вставку.Если вы удалили только 10 строк из 100-строчного документа,даже если вы добавили 910 новых строк для создания нового 1000-строчного документа,вы не сделали полного перезаписи.diffcore-break разбивает такой случай,чтобы помочь diffcore-rename считать такие пары файлов кандидатами на переименование/обнаружение копии,но если пары файлов,разбитые таким образом,не были сопоставлены с другими парами файлов для создания переименования/копирования,то это преобразование объединяет их обратно в исходное &quot;изменение&quot;.</target>
        </trans-unit>
        <trans-unit id="6ab2225889ebaecccd59bff89db6e9b9331d68f2" translate="yes" xml:space="preserve">
          <source>For the sake of clarity, let&amp;rsquo;s stay with &lt;code&gt;git cat-file&lt;/code&gt;, because it</source>
          <target state="translated">Для ясности оставим &lt;code&gt;git cat-file&lt;/code&gt; , потому что он</target>
        </trans-unit>
        <trans-unit id="3256aa918e5b4c1710b691c8cd23b5d5181ec72c" translate="yes" xml:space="preserve">
          <source>For the sake of simplicity and interoperating with Subversion, it is recommended that all &lt;code&gt;git svn&lt;/code&gt; users clone, fetch and dcommit directly from the SVN server, and avoid all &lt;code&gt;git clone&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt;/&lt;code&gt;merge&lt;/code&gt;/&lt;code&gt;push&lt;/code&gt; operations between Git repositories and branches. The recommended method of exchanging code between Git branches and users is &lt;code&gt;git format-patch&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;, or just 'dcommit&amp;rsquo;ing to the SVN repository.</source>
          <target state="translated">Для простоты и взаимодействия с Subversion рекомендуется, чтобы все пользователи &lt;code&gt;git svn&lt;/code&gt; клонировали, извлекали и dcommit непосредственно с сервера SVN и избегали всех операций &lt;code&gt;git clone&lt;/code&gt; / &lt;code&gt;pull&lt;/code&gt; / &lt;code&gt;merge&lt;/code&gt; / &lt;code&gt;push&lt;/code&gt; между репозиториями Git и ветвями. Рекомендуемый метод обмена кодом между ветвями Git и пользователями - это &lt;code&gt;git format-patch&lt;/code&gt; и &lt;code&gt;git am&lt;/code&gt; , или просто &amp;laquo;dcommit&amp;raquo; в репозиторий SVN.</target>
        </trans-unit>
        <trans-unit id="2279b6e7f152e69847961316b26521ce7eeaaca8" translate="yes" xml:space="preserve">
          <source>For these commands, specifying a single revision, using the notation described in the previous section, means the set of commits &lt;code&gt;reachable&lt;/code&gt; from the given commit.</source>
          <target state="translated">Для этих команд указание одной ревизии с использованием обозначений, описанных в предыдущем разделе, означает набор коммитов, &lt;code&gt;reachable&lt;/code&gt; из данной фиксации.</target>
        </trans-unit>
        <trans-unit id="bd23aa2eb5a5735171ddacb742b9284ac1e13d5d" translate="yes" xml:space="preserve">
          <source>For this example, suppose &lt;code&gt;I&lt;/code&gt; created &lt;code&gt;file.txt&lt;/code&gt; which was modified by &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt; in different ways. The single-parent commits &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; do not change &lt;code&gt;file.txt&lt;/code&gt;. The merge commit &lt;code&gt;M&lt;/code&gt; was created by resolving the merge conflict to include both changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and hence is not TREESAME to either. The merge commit &lt;code&gt;R&lt;/code&gt;, however, was created by ignoring the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;M&lt;/code&gt; and taking only the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;X&lt;/code&gt;. Hence, &lt;code&gt;R&lt;/code&gt; is TREESAME to &lt;code&gt;X&lt;/code&gt; but not &lt;code&gt;M&lt;/code&gt;. Finally, the natural merge resolution to create &lt;code&gt;N&lt;/code&gt; is to take the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;R&lt;/code&gt;, so &lt;code&gt;N&lt;/code&gt; is TREESAME to &lt;code&gt;R&lt;/code&gt; but not &lt;code&gt;C&lt;/code&gt;. The merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; are TREESAME to their first parents, but not to their second parents, &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74da4e1940c3e7e40b0478bfdb6a84a981ccd45c" translate="yes" xml:space="preserve">
          <source>For this reason it is strongly recommended that users repack the repository with &lt;code&gt;git repack -a -d&lt;/code&gt; after fast-import completes, allowing Git to reorganize the packfiles for faster data access. If blob deltas are suboptimal (see above) then also adding the &lt;code&gt;-f&lt;/code&gt; option to force recomputation of all deltas can significantly reduce the final packfile size (30-50% smaller can be quite typical).</source>
          <target state="translated">По этой причине пользователям настоятельно рекомендуется повторно упаковать репозиторий с помощью &lt;code&gt;git repack -a -d&lt;/code&gt; после завершения быстрого импорта, что позволит Git реорганизовать файлы пакетов для более быстрого доступа к данным. Если дельты больших двоичных объектов неоптимальны (см. Выше), то добавление опции &lt;code&gt;-f&lt;/code&gt; для принудительного пересчета всех дельт может значительно уменьшить конечный размер файла пакета (обычно на 30-50% меньше).</target>
        </trans-unit>
        <trans-unit id="0c101be68a53a28136d34207f208a2b09cd96fd2" translate="yes" xml:space="preserve">
          <source>For transports that SVN handles authentication for (http, https, and plain svn), specify the username. For other transports (e.g. &lt;code&gt;svn+ssh://&lt;/code&gt;), you must include the username in the URL, e.g. &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt;</source>
          <target state="translated">Для транспортов, для которых SVN обрабатывает аутентификацию (http, https и простой svn), укажите имя пользователя. Для других транспортов (например, &lt;code&gt;svn+ssh://&lt;/code&gt; ) вы должны включить имя пользователя в URL, например &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="884bf4d941685ae2ac82a222d5a5cd34350cf6bb" translate="yes" xml:space="preserve">
          <source>For trees, it shows the names (equivalent to &lt;code&gt;git ls-tree&lt;/code&gt; with --name-only).</source>
          <target state="translated">Для деревьев отображаются имена (эквивалент &lt;code&gt;git ls-tree&lt;/code&gt; с --name-only).</target>
        </trans-unit>
        <trans-unit id="add825378fcd5c043a391a94c20d1353e2f3f4d7" translate="yes" xml:space="preserve">
          <source>For true distributed development that supports proper merging, published branches should never be rewritten.</source>
          <target state="translated">Для истинно распределенной разработки,поддерживающей правильное слияние,опубликованные ветки никогда не должны переписываться.</target>
        </trans-unit>
        <trans-unit id="3d68fc99046b8e48302665b1b866f7694067fd6a" translate="yes" xml:space="preserve">
          <source>For use with --textconv or --filters, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came.</source>
          <target state="translated">Для использования с --textconv или --filters,чтобы позволить указать имя объекта и путь отдельно,например,когда трудно разобраться в ревизии,из которой пришёл блок.</target>
        </trans-unit>
        <trans-unit id="e72ffb4fac055436e16518cc2f4fb21127e4cb40" translate="yes" xml:space="preserve">
          <source>For writing options: write to global &lt;code&gt;~/.gitconfig&lt;/code&gt; file rather than the repository &lt;code&gt;.git/config&lt;/code&gt;, write to &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; file if this file exists and the &lt;code&gt;~/.gitconfig&lt;/code&gt; file doesn&amp;rsquo;t.</source>
          <target state="translated">Для записи параметров: писать в глобальный файл &lt;code&gt;~/.gitconfig&lt;/code&gt; , а не в репозиторий &lt;code&gt;.git/config&lt;/code&gt; , писать в &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; если этот файл существует, а файл &lt;code&gt;~/.gitconfig&lt;/code&gt; - нет.</target>
        </trans-unit>
        <trans-unit id="1d4f90bdceeed64344a78d1a30eb973c4a695eed" translate="yes" xml:space="preserve">
          <source>For writing options: write to system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than the repository &lt;code&gt;.git/config&lt;/code&gt;.</source>
          <target state="translated">Для записи параметров: пишите в общесистемный &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; а не в репозиторий &lt;code&gt;.git/config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab6a40ba6d951665186720914cfcdda1831523bb" translate="yes" xml:space="preserve">
          <source>For writing options: write to the repository &lt;code&gt;.git/config&lt;/code&gt; file. This is the default behavior.</source>
          <target state="translated">Для вариантов записи: пишите в репозиторий &lt;code&gt;.git/config&lt;/code&gt; файл. Это поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1b61f0964f0c12ab159b1b9cbdaad36acf5d4cd8" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;git gc&lt;/code&gt; to run even if there may be another &lt;code&gt;git gc&lt;/code&gt; instance running on this repository.</source>
          <target state="translated">Принудительно запускать &lt;code&gt;git gc&lt;/code&gt; , даже если в этом репозитории может быть запущен другой экземпляр &lt;code&gt;git gc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2041f78f7b4213165ad0484df1b0863ad820d047" translate="yes" xml:space="preserve">
          <source>Force renaming or moving of a file even if the target exists</source>
          <target state="translated">Принудительное переименование или перемещение файла,даже если цель существует.</target>
        </trans-unit>
        <trans-unit id="ecd78b0e67ad331a13ae4cb8f4e6a9ed04fc189e" translate="yes" xml:space="preserve">
          <source>Force the cloning process from a repository on a local filesystem to copy the files under the &lt;code&gt;.git/objects&lt;/code&gt; directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository.</source>
          <target state="translated">Заставьте процесс клонирования из репозитория в локальной файловой системе копировать файлы в каталог &lt;code&gt;.git/objects&lt;/code&gt; вместо использования жестких ссылок. Это может быть желательно, если вы пытаетесь сделать резервную копию своего репозитория.</target>
        </trans-unit>
        <trans-unit id="5aad6db9c36a2f2837e6ea58135f2a7c135ffcc5" translate="yes" xml:space="preserve">
          <source>Force the merge even if the files are not up to date.</source>
          <target state="translated">Принудите к слиянию,даже если файлы не обновляются.</target>
        </trans-unit>
        <trans-unit id="b35554b966d1f9e773a7eeb185af7c152ef043be" translate="yes" xml:space="preserve">
          <source>Force the parent commit, even if it is not a direct parent.</source>
          <target state="translated">Заставить родителя совершить фиксацию,даже если он не является прямым родителем.</target>
        </trans-unit>
        <trans-unit id="8fd0762700f6c31dd37961618e48e9600a28f63f" translate="yes" xml:space="preserve">
          <source>Force updating modified existing branches, even if doing so would cause commits to be lost (as the new commit does not contain the old commit).</source>
          <target state="translated">Принудительное обновление существующих ветвей,даже если это приведет к потере коммитов (так как новый коммит не содержит старого).</target>
        </trans-unit>
        <trans-unit id="3c16110b137eeeb074b6bb1a45d5cee67e8b8d7d" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, generate its unique SHA-1 checksum and index, and start a new packfile. This command is optional and is not needed to perform an import.</source>
          <target state="translated">Быстрый импорт заставляет закрыть текущий файл пакета,генерировать его уникальную контрольную сумму и индекс SHA-1,а также запускать новый файл пакета.Эта команда является необязательной и не требуется для выполнения импорта.</target>
        </trans-unit>
        <trans-unit id="1a687c2c8da515bb3889e24f9c0c80b813b24084" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, start a new one, and to save out all current branch refs, tags and marks.</source>
          <target state="translated">Функция быстрого импорта позволяет закрыть текущий файл пакета,запустить новый и сохранить все текущие ссылки,теги и метки ветки.</target>
        </trans-unit>
        <trans-unit id="434a9daac438458d6a5542866bf4627ab056ebc0" translate="yes" xml:space="preserve">
          <source>Forcing git fetch to do non-fast-forward updates</source>
          <target state="translated">Принуждение git fetch к выполнению не форвардных обновлений</target>
        </trans-unit>
        <trans-unit id="07c2be944c0e6602c04932a6e3d9ec7d07d27d65" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is.</source>
          <target state="translated">Забудьте о текущем слиянии.Оставьте индекс и рабочее дерево как есть.</target>
        </trans-unit>
        <trans-unit id="b7fac01fb2068412feecd8f7081be42b5f011f68" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is. If &lt;code&gt;MERGE_AUTOSTASH&lt;/code&gt; is present, the stash entry will be saved to the stash list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81bdf759eac78632844fbde02bcf81c1762add7d" translate="yes" xml:space="preserve">
          <source>Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.</source>
          <target state="translated">Забудьте о текущей операции.Может использоваться для очистки состояния секвенсора после неудачной вишневой пикировки или реверсирования.</target>
        </trans-unit>
        <trans-unit id="bc2093ee15e651049bc58aa54bb94be570859e07" translate="yes" xml:space="preserve">
          <source>Format data by columns:</source>
          <target state="translated">Форматировать данные по столбцам:</target>
        </trans-unit>
        <trans-unit id="74cf0d3233deb63a1885a09b7a59d2c4cacb7451" translate="yes" xml:space="preserve">
          <source>Format data by rows:</source>
          <target state="translated">Форматировать данные по строкам:</target>
        </trans-unit>
        <trans-unit id="1490d94054ac9f1a7565287cb4c10caa7d0a3ff1" translate="yes" xml:space="preserve">
          <source>Format of the file(s) specified in sendemail.aliasesFile. Must be one of &lt;code&gt;mutt&lt;/code&gt;, &lt;code&gt;mailrc&lt;/code&gt;, &lt;code&gt;pine&lt;/code&gt;, &lt;code&gt;elm&lt;/code&gt;, or &lt;code&gt;gnus&lt;/code&gt;, or &lt;code&gt;sendmail&lt;/code&gt;.</source>
          <target state="translated">Формат файла (ов), указанного в sendemail.aliasesFile. Должен быть одним из: &lt;code&gt;mutt&lt;/code&gt; , &lt;code&gt;mailrc&lt;/code&gt; , &lt;code&gt;pine&lt;/code&gt; , &lt;code&gt;elm&lt;/code&gt; , &lt;code&gt;gnus&lt;/code&gt; или &lt;code&gt;sendmail&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85b75659b13a3c18419a2059ae24d18f7aec62d9" translate="yes" xml:space="preserve">
          <source>Format of the resulting archive: &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;zip&lt;/code&gt;. If this option is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to &quot;foo.zip&quot; makes the output to be in the zip format). Otherwise the output format is &lt;code&gt;tar&lt;/code&gt;.</source>
          <target state="translated">Формат полученного архива: &lt;code&gt;tar&lt;/code&gt; или &lt;code&gt;zip&lt;/code&gt; . Если эта опция не указана и указан выходной файл, формат выводится из имени файла, если это возможно (например, запись в &amp;laquo;foo.zip&amp;raquo; делает вывод в формате zip). В противном случае выходной формат - &lt;code&gt;tar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2804d9f16a38553f8238529c90d66e7d7426c150" translate="yes" xml:space="preserve">
          <source>Formats</source>
          <target state="translated">Formats</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="97808e16f7b3e0748cf911affe6a2e5f5336bd69" translate="yes" xml:space="preserve">
          <source>Fortunately, Git also keeps a log, called a &quot;reflog&quot;, of all the previous values of each branch. So in this case you can still find the old history using, for example,</source>
          <target state="translated">К счастью,Git также ведёт журнал,называемый &quot;рефлогом&quot;,всех предыдущих значений каждой ветки.Так что в этом случае вы всё ещё можете найти старую историю,используя,например,</target>
        </trans-unit>
        <trans-unit id="52aedb174e481572a146a6eee6e65f3145e19419" translate="yes" xml:space="preserve">
          <source>Fortunately, when you try and merge branches imported from Arch, Git will find a good merge base, and it has a good chance of identifying patches that have been traded out-of-sequence between the branches.</source>
          <target state="translated">К счастью,при попытке слить ветки,импортированные из Arch,Git найдёт хорошую базу для слияния,и у него есть хорошие шансы выявить патчи,которые были проданы вне последовательности между ветками.</target>
        </trans-unit>
        <trans-unit id="f243a4b31e069ad1af1905a7b7ee3c0a6bc4a9d9" translate="yes" xml:space="preserve">
          <source>Freely Skip Around Branches</source>
          <target state="translated">Свободно пропускать ветки</target>
        </trans-unit>
        <trans-unit id="4f5fb89546fa56451bf07260d4420bcc62940bb0" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions (FAQ)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6954599bb4bd53fc74592c122080450ce5ed81db" translate="yes" xml:space="preserve">
          <source>Frequently asked questions about using Git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc2451038a48527dcbeab53ccfe9fbac5f2cad0f" translate="yes" xml:space="preserve">
          <source>From a clean working directory:</source>
          <target state="translated">Из чистого рабочего каталога:</target>
        </trans-unit>
        <trans-unit id="e5d597f5b08d8d486fa4fe348997e77a44c54af8" translate="yes" xml:space="preserve">
          <source>From a remote repository:</source>
          <target state="translated">Из удаленного хранилища:</target>
        </trans-unit>
        <trans-unit id="288bfe5db4a5e76e3e6479e8536caa4995b7e02e" translate="yes" xml:space="preserve">
          <source>From a tarball:</source>
          <target state="translated">От тарбола:</target>
        </trans-unit>
        <trans-unit id="734c2e78c0e94a1be8f8ce3bed6beeb7e74b3905" translate="yes" xml:space="preserve">
          <source>From the Git 1.5.4 series and further, many Git commands (not all of them at the time of the writing though) come with an enhanced option parser.</source>
          <target state="translated">Начиная с версии Git'а 1.5.4 и далее,многие команды Git'а (на момент написания статьи,однако,не все)поставляются с расширенным парсером опций.</target>
        </trans-unit>
        <trans-unit id="a7a0e1c60991430a8700058d7dbaaa429f71c02b" translate="yes" xml:space="preserve">
          <source>From this point, the result of either of the following commands:</source>
          <target state="translated">С этого момента результат выполнения одной из следующих команд:</target>
        </trans-unit>
        <trans-unit id="3e41340cee5d477151048da29744ee1316a7f6cb" translate="yes" xml:space="preserve">
          <source>Frontends may choose to issue checkpoints during extremely large and long running imports, or when they need to allow another Git process access to a branch. However given that a 30 GiB Subversion repository can be loaded into Git through fast-import in about 3 hours, explicit checkpointing may not be necessary.</source>
          <target state="translated">Frontends могут выбирать выдачу контрольно-пропускных пунктов при чрезвычайно большом и длительном импорте,или когда им необходимо разрешить другому Git-процессу доступ к ветке.Однако,учитывая,что 30 гигабайтный репозиторий Subversion может быть загружен в Git через быстрый импорт примерно за 3 часа,явной проверки на контрольно-пропускных пунктах может не потребоваться.</target>
        </trans-unit>
        <trans-unit id="45f585d5b13263a74e89d30321fceb20439bc1e7" translate="yes" xml:space="preserve">
          <source>Frontends should prefer the &lt;code&gt;raw&lt;/code&gt; format if the source material already uses UNIX-epoch format, can be coaxed to give dates in that format, or its format is easily convertible to it, as there is no ambiguity in parsing.</source>
          <target state="translated">Фронтенды должны предпочесть &lt;code&gt;raw&lt;/code&gt; формат, если исходный материал уже использует формат эпохи UNIX, его можно уговорить указать даты в этом формате или его формат легко конвертируется в него, поскольку нет двусмысленности в синтаксическом анализе.</target>
        </trans-unit>
        <trans-unit id="f3cc2873d5f4e3e8be387b77133d15ba005de66f" translate="yes" xml:space="preserve">
          <source>Frontends which have efficient access to all revisions of a single file (for example reading an RCS/CVS ,v file) can choose to supply all revisions of that file as a sequence of consecutive &lt;code&gt;blob&lt;/code&gt; commands. This allows fast-import to deltify the different file revisions against each other, saving space in the final packfile. Marks can be used to later identify individual file revisions during a sequence of &lt;code&gt;commit&lt;/code&gt; commands.</source>
          <target state="translated">Фронтенды, которые имеют эффективный доступ ко всем ревизиям одного файла (например, чтение RCS / CVS, v файла), могут выбрать предоставление всех ревизий этого файла в виде последовательности последовательных команд &lt;code&gt;blob&lt;/code&gt; объектов . Это позволяет быстрому импорту сопоставлять различные версии файлов друг с другом, экономя место в конечном пак-файле. Метки могут использоваться для последующей идентификации отдельных ревизий файла во время последовательности команд &lt;code&gt;commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3519d227e718b16c5b769aae01680cf2cd77dc46" translate="yes" xml:space="preserve">
          <source>Full URL and absolute URL of the gitweb script; in earlier versions of gitweb you might have need to set those variables, but now there should be no need to do it. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to set them still.</source>
          <target state="translated">Полный URL и абсолютный URL скрипта gitweb; в более ранних версиях gitweb вам может потребоваться установить эти переменные, но теперь в этом не должно быть необходимости. См. &lt;code&gt;$per_request_config&lt;/code&gt; если вам нужно еще установить их.</target>
        </trans-unit>
        <trans-unit id="a108e2708a06a554ba0c3dc09504268225bd27f7" translate="yes" xml:space="preserve">
          <source>Full pattern set</source>
          <target state="translated">Полный набор шаблонов</target>
        </trans-unit>
        <trans-unit id="b8fec8cb8e4460222f34da65fd7e0d2a0f5118ab" translate="yes" xml:space="preserve">
          <source>Function used to determine which repositories should be shown. This subroutine should take one parameter, the full path to a project, and if it returns true, that project will be included in the projects list and can be accessed through gitweb as long as it fulfills the other requirements described by $export_ok, $projects_list, and $projects_maxdepth. Example:</source>
          <target state="translated">Функция,используемая для определения того,какие репозитории должны быть показаны.Эта подпрограмма должна принимать один параметр,полный путь к проекту,и если она возвращает true,то этот проект будет включен в список проектов и доступ к нему будет осуществляться через gitweb до тех пор,пока он выполняет другие требования,описанные в $export_ok,$projects_list и $projects_maxdepth.Пример:</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="953f869510869f147aa66935f6f2e4c1b01346f2" translate="yes" xml:space="preserve">
          <source>Fundamental data structures and utilities of Git. Exposes only limited source code management tools.</source>
          <target state="translated">Фундаментальные структуры данных и утилиты Git.Выставляет только ограниченные инструменты управления исходным кодом.</target>
        </trans-unit>
        <trans-unit id="2a68bfcdf45f0d6508d348a650a90dad4898fc87" translate="yes" xml:space="preserve">
          <source>Further chapters cover more specialized topics.</source>
          <target state="translated">Дальнейшие главы охватывают более специализированные темы.</target>
        </trans-unit>
        <trans-unit id="bc4614e5e44f10e9735555c384229ac13d88fcbe" translate="yes" xml:space="preserve">
          <source>Further documentation</source>
          <target state="translated">Дополнительная документация</target>
        </trans-unit>
        <trans-unit id="1a67b11bbb73911c0ea7f808bf383dac0f90b1d2" translate="yes" xml:space="preserve">
          <source>Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X.</source>
          <target state="translated">Далее предположим,что другой человек уже внес изменения,ведущие к A,в исходное хранилище,из которого вы двое получили исходную фиксацию X.</target>
        </trans-unit>
        <trans-unit id="11dea5e071893c59426ef6a8d5f500708e7c087c" translate="yes" xml:space="preserve">
          <source>Further, remember how I said that &lt;code&gt;git write-tree&lt;/code&gt; writes the contents of the &lt;strong&gt;index&lt;/strong&gt; file to the tree, and thus what we just committed was in fact the &lt;strong&gt;original&lt;/strong&gt; contents of the file &lt;code&gt;hello&lt;/code&gt;, not the new ones. We did that on purpose, to show the difference between the index state, and the state in the working tree, and how they don&amp;rsquo;t have to match, even when we commit things.</source>
          <target state="translated">Кроме того, помните, как я сказал, что &lt;code&gt;git write-tree&lt;/code&gt; записывает содержимое &lt;strong&gt;индексного&lt;/strong&gt; файла в дерево, и поэтому то, что мы только что зафиксировали, было фактически &lt;strong&gt;исходным&lt;/strong&gt; содержимым файла &lt;code&gt;hello&lt;/code&gt; , а не новым. Мы сделали это специально, чтобы показать разницу между состоянием индекса и состоянием в рабочем дереве, а также то, что они не должны совпадать, даже когда мы фиксируем что-то.</target>
        </trans-unit>
        <trans-unit id="12a1c3eb3c3466df160e63355f0a70980e5d8a54" translate="yes" xml:space="preserve">
          <source>Further, several additional files are created or updated per commit by git-filter-branch. Some of these are for supporting the convenience functions provided by git-filter-branch (such as map()), while others are for keeping track of internal state (but could have also been accessed by user filters; one of git-filter-branch&amp;rsquo;s regression tests does so). This essentially amounts to using the filesystem as an IPC mechanism between git-filter-branch and the user-provided filters. Disks tend to be a slow IPC mechanism, and writing these files also effectively represents a forced synchronization point between separate processes that we hit with every commit.</source>
          <target state="translated">Кроме того, git-filter-branch создает или обновляет несколько дополнительных файлов для каждой фиксации. Некоторые из них предназначены для поддержки удобных функций, предоставляемых git-filter-branch (например, map ()), а другие предназначены для отслеживания внутреннего состояния (но также могут быть доступны с помощью пользовательских фильтров; один из git-filter- регрессионные тесты ветки делают это). По сути, это сводится к использованию файловой системы в качестве механизма IPC между git-filter-branch и пользовательскими фильтрами. Диски, как правило, являются медленным механизмом IPC, и запись этих файлов также эффективно представляет собой точку принудительной синхронизации между отдельными процессами, с которыми мы сталкиваемся при каждой фиксации.</target>
        </trans-unit>
        <trans-unit id="48717135930571b8087beeed13bb405458558d68" translate="yes" xml:space="preserve">
          <source>Further, the above facts mean that there are multiple reasons that &quot;tracked&quot; files might not be present in the working copy: sparsity pattern application from sparse-checkout, and submodule initialization state. Thus, commands like &lt;code&gt;git grep&lt;/code&gt; that work on tracked files in the working copy may return results that are limited by either or both of these restrictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca2383accb8da62a165b73e8556d1713934adf2" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;git read-tree&lt;/code&gt; has special-case logic that says: if you see a file that matches in all respects in the following states, it &quot;collapses&quot; back to &quot;stage0&quot;:</source>
          <target state="translated">Кроме того, &lt;code&gt;git read-tree&lt;/code&gt; имеет логику особого случая, которая гласит: если вы видите файл, который соответствует во всех отношениях в следующих состояниях, он &amp;laquo;сворачивается&amp;raquo; обратно в &amp;laquo;stage0&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="31a08e0ad75da0260fa91bb8e152e897858a7305" translate="yes" xml:space="preserve">
          <source>Furthermore, passwords need not be specified in configuration files or on the command line. If a username has been specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or a &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), but no password has been specified (with &lt;code&gt;--smtp-pass&lt;/code&gt; or &lt;code&gt;sendemail.smtpPass&lt;/code&gt;), then a password is obtained using &lt;code&gt;git-credential&lt;/code&gt;.</source>
          <target state="translated">Более того, пароли не нужно указывать в файлах конфигурации или в командной строке. Если имя пользователя было указано (с помощью &lt;code&gt;--smtp-user&lt;/code&gt; или &lt;code&gt;sendemail.smtpUser&lt;/code&gt; ), но пароль не был указан (с помощью &lt;code&gt;--smtp-pass&lt;/code&gt; или &lt;code&gt;sendemail.smtpPass&lt;/code&gt; ), то пароль получается с использованием &lt;code&gt;git-credential&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eebdda6fedb5243cc4950de3133a043a2ebece61" translate="yes" xml:space="preserve">
          <source>Furthermore, supplying &lt;code&gt;--aggressive&lt;/code&gt; will tweak the &lt;code&gt;--depth&lt;/code&gt; and &lt;code&gt;--window&lt;/code&gt; options passed to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. See the &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; and &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; settings below. By using a larger window size we&amp;rsquo;re more likely to find more optimal deltas.</source>
          <target state="translated">Кроме того, &lt;code&gt;--aggressive&lt;/code&gt; изменит параметры &lt;code&gt;--depth&lt;/code&gt; и &lt;code&gt;--window&lt;/code&gt; , передаваемые в &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; . См. &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; и &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; ниже. Используя окно большего размера, мы с большей вероятностью найдем более оптимальные дельты.</target>
        </trans-unit>
        <trans-unit id="c04d9fd3f33708a82d676293fc52e5a70fbf49e1" translate="yes" xml:space="preserve">
          <source>Future work</source>
          <target state="translated">Будущая работа</target>
        </trans-unit>
        <trans-unit id="7fa52712e6497fe42aeefb82c610da75e312ec0f" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG</source>
          <target state="translated">GITWEB_CONFIG</target>
        </trans-unit>
        <trans-unit id="9636fb1dbafa2b47af9b2233bf38584401d20651" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_COMMON</source>
          <target state="translated">GITWEB_CONFIG_COMMON</target>
        </trans-unit>
        <trans-unit id="f726c6360c3b65b3b136cb8ed08c06cd6bb3dc13" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_SYSTEM</source>
          <target state="translated">GITWEB_CONFIG_SYSTEM</target>
        </trans-unit>
        <trans-unit id="7280da4640f08695fca3fbf79b196a715d6c95d5" translate="yes" xml:space="preserve">
          <source>GIT_ALTERNATE_OBJECT_DIRECTORIES</source>
          <target state="translated">GIT_ALTERNATE_OBJECT_DIRECTORIES</target>
        </trans-unit>
        <trans-unit id="964a2aa0953b5ffb1cfcd8b66bb3d22332570f05" translate="yes" xml:space="preserve">
          <source>GIT_AUTHOR_IDENT</source>
          <target state="translated">GIT_AUTHOR_IDENT</target>
        </trans-unit>
        <trans-unit id="725c6b7276951cf72d0731356407b6a84b3e59ef" translate="yes" xml:space="preserve">
          <source>GIT_COMMITTER_IDENT</source>
          <target state="translated">GIT_COMMITTER_IDENT</target>
        </trans-unit>
        <trans-unit id="3869ed3f7a51f55040f7a430ffe9ba97f98e246e" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG</source>
          <target state="translated">GIT_CONFIG</target>
        </trans-unit>
        <trans-unit id="a5d490c74fb40af786be750b380476b10d1e4b69" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG_NOSYSTEM</source>
          <target state="translated">GIT_CONFIG_NOSYSTEM</target>
        </trans-unit>
        <trans-unit id="01c412ca4d08642575a66ac381c4483c043b0ee1" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_BASE_PATH takes the place of the argument to --base-path.</source>
          <target state="translated">GIT_CVSSERVER_BASE_PATH заменяет аргумент на --base-path.</target>
        </trans-unit>
        <trans-unit id="4f0780cd85f15ce5f825b343d1c06abf4cfc9741" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_ROOT specifies a single-directory whitelist. The repository must still be configured to allow access through git-cvsserver, as described above.</source>
          <target state="translated">GIT_CVSSERVER_ROOT указывает белый список одной директории.Репозиторий все равно должен быть настроен на разрешение доступа через git-cvsserver,как описано выше.</target>
        </trans-unit>
        <trans-unit id="4ad19a85aef9ab4dcb6f62d95b8acf07e4c4828f" translate="yes" xml:space="preserve">
          <source>GIT_EDITOR</source>
          <target state="translated">GIT_EDITOR</target>
        </trans-unit>
        <trans-unit id="c8b3461d27dba4e8c6ce0c25c772c18d60c891a3" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE</source>
          <target state="translated">GIT_EXT_SERVICE</target>
        </trans-unit>
        <trans-unit id="f4a08871056eea1076c323923e7cd2cd5fd6c0a8" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE_NOPREFIX</source>
          <target state="translated">GIT_EXT_SERVICE_NOPREFIX</target>
        </trans-unit>
        <trans-unit id="08b684f4da6721d3a2c8e7b518324c7c98994b4e" translate="yes" xml:space="preserve">
          <source>GIT_INDEX_FILE</source>
          <target state="translated">GIT_INDEX_FILE</target>
        </trans-unit>
        <trans-unit id="cf57e9b3a04f2696e64705102232bab489ed97a5" translate="yes" xml:space="preserve">
          <source>GIT_OBJECT_DIRECTORY</source>
          <target state="translated">GIT_OBJECT_DIRECTORY</target>
        </trans-unit>
        <trans-unit id="924d60649d04fe751450b8bd3f1fc4a48bf559cb" translate="yes" xml:space="preserve">
          <source>GIT_PAGER</source>
          <target state="translated">GIT_PAGER</target>
        </trans-unit>
        <trans-unit id="ef2d6ed7bd1e2bfa87dc927172ada3fd1bdae6d2" translate="yes" xml:space="preserve">
          <source>GIT_TRANSLOOP_DEBUG</source>
          <target state="translated">GIT_TRANSLOOP_DEBUG</target>
        </trans-unit>
        <trans-unit id="a16f454460c35cd8704027fca6876a6a8646b0f2" translate="yes" xml:space="preserve">
          <source>GMail</source>
          <target state="translated">GMail</target>
        </trans-unit>
        <trans-unit id="cda466cee33ea6d923c0d1a6805da6ace37ac3f0" translate="yes" xml:space="preserve">
          <source>GMail does not have any way to turn off line wrapping in the web interface, so it will mangle any emails that you send. You can however use &quot;git send-email&quot; and send your patches through the GMail SMTP server, or use any IMAP email client to connect to the google IMAP server and forward the emails through that.</source>
          <target state="translated">GMail не имеет никакого способа отключить обертывание линии в веб-интерфейсе,поэтому она будет искажать любые сообщения электронной почты,которые вы отправляете.Однако вы можете использовать &quot;git send-email&quot; и посылать патчи через SMTP-сервер GMail,или использовать любой почтовый клиент IMAP для подключения к IMAP-серверу Google и пересылать через него сообщения электронной почты.</target>
        </trans-unit>
        <trans-unit id="31f314da9a863256952d9852bb7b935e9c829e75" translate="yes" xml:space="preserve">
          <source>GPG sign pushes.</source>
          <target state="translated">Толкает знак GPG.</target>
        </trans-unit>
        <trans-unit id="d2cc3c3070810078ed6b670e4bd5c8639504233f" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">GPG-подписывает коммиты. &lt;code&gt;keyid&lt;/code&gt; аргумент является необязательным и по умолчанию идентичности коммиттеров; если указано, он должен быть прикреплен к опции без пробела.</target>
        </trans-unit>
        <trans-unit id="b1aed1c7977c0e2de26949b45fd71f731a4b1c8b" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand a &lt;code&gt;--gpg-sign&lt;/code&gt; option given earlier on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064f918c2672d1e438a7a65cbdf8c083e0ff21e6" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand both &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable, and earlier &lt;code&gt;--gpg-sign&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280cb8af503fd81af0776da1e5da5b505a515ac5" translate="yes" xml:space="preserve">
          <source>GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;--no-signed&lt;/code&gt;, no signing will be attempted. If &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;--signed&lt;/code&gt;, the push will fail if the server does not support signed pushes. If set to &lt;code&gt;if-asked&lt;/code&gt;, sign if and only if the server supports signed pushes. The push will also fail if the actual call to &lt;code&gt;gpg --sign&lt;/code&gt; fails. See &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; for the details on the receiving end.</source>
          <target state="translated">GPG-подпишите push-запрос для обновления ссылок на принимающей стороне, чтобы разрешить перехватчикам его проверять и / или регистрировать. Если &lt;code&gt;false&lt;/code&gt; или &lt;code&gt;--no-signed&lt;/code&gt; , попытка подписания выполняться не будет. Если &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;--signed&lt;/code&gt; , push завершится ошибкой, если сервер не поддерживает подписанные push. Если задано значение &amp;laquo; &lt;code&gt;if-asked&lt;/code&gt; , подписывать, если и только если сервер поддерживает подписанные push-уведомления. &lt;code&gt;gpg --sign&lt;/code&gt; также не удастся, если фактический вызов gpg --sign завершится неудачно. См. &lt;a href=&quot;git-receive-pack&quot;&gt;Git-receive-pack [1]&lt;/a&gt; для получения подробной информации о принимающей стороне.</target>
        </trans-unit>
        <trans-unit id="359179ddafe5ac57f233ce54be02401d37d2bd8b" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">GPG-подпишите получившийся коммит слияния. &lt;code&gt;keyid&lt;/code&gt; аргумент является необязательным и по умолчанию идентичности коммиттеров; если указано, он должен быть прикреплен к опции без пробела.</target>
        </trans-unit>
        <trans-unit id="701d2f8958de65d8fe7b7eb1b839a88b4e25736c" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand both &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable, and earlier &lt;code&gt;--gpg-sign&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524cceb20916aff43a2680247362fb603a1a49c8" translate="yes" xml:space="preserve">
          <source>Garbage collect all unreferenced objects with &lt;code&gt;git gc --prune=now&lt;/code&gt; (or if your git-gc is not new enough to support arguments to &lt;code&gt;--prune&lt;/code&gt;, use &lt;code&gt;git repack -ad; git prune&lt;/code&gt; instead).</source>
          <target state="translated">Сбор мусора для всех объектов, на которые нет &lt;code&gt;git gc --prune=now&lt;/code&gt; с помощью git gc --prune = now (или если ваш git-gc недостаточно новый для поддержки аргументов для &lt;code&gt;--prune&lt;/code&gt; , используйте вместо этого &lt;code&gt;git repack -ad; git prune&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5bcb5f8aaf1a9e559046fd7b5b3d79bbe4d3f426" translate="yes" xml:space="preserve">
          <source>General options</source>
          <target state="translated">Общие параметры</target>
        </trans-unit>
        <trans-unit id="a5879c5c764017ca2130842dc888dcc88c04c99e" translate="yes" xml:space="preserve">
          <source>General variables</source>
          <target state="translated">Общие переменные</target>
        </trans-unit>
        <trans-unit id="55fd2438a0c551b4e16240eed52ec4917c61134a" translate="yes" xml:space="preserve">
          <source>Generally speaking, rule (3) above is the simplest for users to specify. Authors of credential helpers should make an effort to assist their users by naming their program &quot;git-credential-$NAME&quot;, and putting it in the &lt;code&gt;$PATH&lt;/code&gt; or &lt;code&gt;$GIT_EXEC_PATH&lt;/code&gt; during installation, which will allow a user to enable it with &lt;code&gt;git config credential.helper $NAME&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e6a94549428bad778124c3c140042198abcb13" translate="yes" xml:space="preserve">
          <source>Generally this mode is used as an administrative interface to allow users to list repositories they have access to, create, delete, or rename repositories, or change repository descriptions and permissions.</source>
          <target state="translated">Обычно этот режим используется в качестве административного интерфейса,позволяющего пользователям перечислять репозитории,к которым у них есть доступ,создавать,удалять или переименовывать репозитории,а также изменять описания и права доступа к репозиториям.</target>
        </trans-unit>
        <trans-unit id="5338e8546078668a151a9dabd932d38a31f12f5b" translate="yes" xml:space="preserve">
          <source>Generally, &lt;code&gt;git p4 clone&lt;/code&gt; is used to create a new Git directory from an existing p4 repository:</source>
          <target state="translated">Как правило, &lt;code&gt;git p4 clone&lt;/code&gt; используется для создания нового каталога Git из существующего репозитория p4:</target>
        </trans-unit>
        <trans-unit id="ad37ee86e2b3d890455e76bc1e7e0fc45d3460de" translate="yes" xml:space="preserve">
          <source>Generally, all Git operations work on the index file. Some operations work &lt;strong&gt;purely&lt;/strong&gt; on the index file (showing the current state of the index), but most operations move data between the index file and either the database or the working directory. Thus there are four main combinations:</source>
          <target state="translated">Как правило, все операции Git работают с индексным файлом. Некоторые операции работают &lt;strong&gt;только&lt;/strong&gt; с индексным файлом (показывая текущее состояние индекса), но большинство операций перемещают данные между индексным файлом и базой данных или рабочим каталогом. Таким образом, есть четыре основных комбинации:</target>
        </trans-unit>
        <trans-unit id="c30116e53a947e31daeae056572933416099fbe0" translate="yes" xml:space="preserve">
          <source>Generally, dangling objects aren&amp;rsquo;t anything to worry about. They can even be very useful: if you screw something up, the dangling objects can be how you recover your old tree (say, you did a rebase, and realized that you really didn&amp;rsquo;t want to&amp;mdash;​you can look at what dangling objects you have, and decide to reset your head to some old dangling state).</source>
          <target state="translated">Как правило, о свисающих предметах не стоит беспокоиться. Они могут быть даже очень полезны: если вы что-то напортачите, болтающиеся объекты могут быть тем способом, которым вы восстанавливаете свое старое дерево (скажем, вы выполнили перебазирование и поняли, что на самом деле не хотите - вы можете посмотреть, что болтается). предметы, которые у вас есть, и решили вернуть голову в какое-то старое болтающееся состояние).</target>
        </trans-unit>
        <trans-unit id="aefb0f39d3bd01ba3e438537ce5e3b6f3d075591" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; file containing a mapping from CVS revision numbers to newly-created Git commit IDs. The generated file will contain one line for each (filename, revision) pair imported; each line will look like</source>
          <target state="translated">Создайте &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; содержащий отображение номеров ревизий CVS и вновь созданных идентификаторов фиксации Git. Сгенерированный файл будет содержать по одной строке для каждой импортированной пары (имя файла, версия); каждая строка будет выглядеть</target>
        </trans-unit>
        <trans-unit id="d956a0b3c8358372085439a04d4b2593dd2bec54" translate="yes" xml:space="preserve">
          <source>Generate a credential description based on the context.</source>
          <target state="translated">Сгенерируйте описание учетной записи на основе контекста.</target>
        </trans-unit>
        <trans-unit id="8b4e72c7495787832a335e23db7d41cdc955de4e" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;anchored diff&quot; algorithm.</source>
          <target state="translated">Сгенерируйте дифференциал,используя алгоритм &quot;якорного дифференциала&quot;.</target>
        </trans-unit>
        <trans-unit id="c65b3bd43c187f9009fd8be60c354464048bfb2c" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;histogram diff&quot; algorithm.</source>
          <target state="translated">Сгенерируйте диф,используя алгоритм &quot;гистограмма диф&quot;.</target>
        </trans-unit>
        <trans-unit id="5a810f6cb04f85c060e73d8366053dc83cbde1b6" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;patience diff&quot; algorithm.</source>
          <target state="translated">Сгенерируйте разницу,используя алгоритм &quot;разницы терпения&quot;.</target>
        </trans-unit>
        <trans-unit id="f50a5c7af33db239a645bbb0a36b9c949e7a8bfe" translate="yes" xml:space="preserve">
          <source>Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;. The width of the filename part can be limited by giving another width &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; after a comma. The width of the graph part can be limited by using &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; (affects all commands generating a stat graph) or by setting &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; (does not affect &lt;code&gt;git format-patch&lt;/code&gt;). By giving a third parameter &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;, you can limit the output to the first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; lines, followed by &lt;code&gt;...&lt;/code&gt; if there are more.</source>
          <target state="translated">Создайте diffstat. По умолчанию столько места, сколько необходимо, будет использовано для части имени файла, а остальное - для части графика. По умолчанию максимальная ширина равна ширине терминала или 80 столбцам, если терминал не подключен, и может быть изменен с помощью &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; . Ширину части имени файла можно ограничить, указав другую ширину &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; после запятой. Ширина части графика может быть ограничена с помощью &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; (влияет на все команды, генерирующие график статистики) или путем установки &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; (не влияет на &lt;code&gt;git format-patch&lt;/code&gt; ) , Задав третий параметр &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; , вы можете ограничить вывод до первых строк &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; ,с последующим &lt;code&gt;...&lt;/code&gt; если есть еще.</target>
        </trans-unit>
        <trans-unit id="9a58997012274b692734905439c472fc9bf49724" translate="yes" xml:space="preserve">
          <source>Generate a request asking your upstream project to pull changes into their tree. The request, printed to the standard output, begins with the branch description, summarizes the changes and indicates from where they can be pulled.</source>
          <target state="translated">Сгенерируйте запрос,попросив проект,находящийся выше по течению,вытянуть изменения в свое дерево.Запрос,распечатанный в стандартный вывод,начинается с описания ветки,суммирует изменения и указывает,откуда их можно вытащить.</target>
        </trans-unit>
        <trans-unit id="e43be14252a09239d3a95e69575c334d9dcee155" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the default of 3. This value is overridden by the -U option.</source>
          <target state="translated">Генерировать различия с &amp;lt;n&amp;gt; строками контекста вместо значения по умолчанию 3. Это значение переопределяется параметром -U.</target>
        </trans-unit>
        <trans-unit id="0c3fb6d76074c691f7bc9656642039721293ad30" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">Создавайте различия с &amp;lt;n&amp;gt; строками контекста вместо обычных трех. Подразумевается &lt;code&gt;--patch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5423824f37bf5ebdc5aa787498e564ca92935ec4" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;. Implies &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="translated">Создавайте различия с &amp;lt;n&amp;gt; строками контекста вместо обычных трех. Подразумевается &lt;code&gt;--patch&lt;/code&gt; . Подразумевает &lt;code&gt;-p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ed7cc57b573e7d3d35a890e87a64e8016055b8" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches).</source>
          <target state="translated">Сгенерировать патч (см.раздел о генерации патчей).</target>
        </trans-unit>
        <trans-unit id="468bd18b2fd829a488878e7cd9b8b00c33a3bf5f" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches). This is the default.</source>
          <target state="translated">Сгенерировать патч (см.раздел о генерации патчей).По умолчанию.</target>
        </trans-unit>
        <trans-unit id="0305bd83d4a1ca283e78c45f30f1d98f9bb246bc" translate="yes" xml:space="preserve">
          <source>Generate plain patches without any diffstats.</source>
          <target state="translated">Генерируйте простые заплаты без дифраз.</target>
        </trans-unit>
        <trans-unit id="0cceb279f32e8c4384bb0e8684243cdf862ab779" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format.</source>
          <target state="translated">Сгенерируйте diff в необработанном формате.</target>
        </trans-unit>
        <trans-unit id="c49c41c6395d0de919c07a57d58570e04e74713d" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format. This is the default.</source>
          <target state="translated">Сгенерируйте diff в необработанном формате.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="88ef8fc7ea6872f6140c434b84c60ed4bc477b71" translate="yes" xml:space="preserve">
          <source>Generates a summary of pending changes</source>
          <target state="translated">Генерирует сводку ожидаемых изменений</target>
        </trans-unit>
        <trans-unit id="b812709580c6b66bf19a88239714db45c6f547d3" translate="yes" xml:space="preserve">
          <source>Generates an RSS (or Atom) feed of changes to repository.</source>
          <target state="translated">Генерирует RSS (или Atom)поток изменений в репозиторий.</target>
        </trans-unit>
        <trans-unit id="6d3ce11672e300b3630956d5357a3f156d393821" translate="yes" xml:space="preserve">
          <source>Generating RSS and Atom feeds of commits, for any branch. The feeds are auto-discoverable in modern web browsers.</source>
          <target state="translated">Генерация RSS и Atom-лент коммитов,для любой ветки.Ленты автоматически обнаруживаются в современных веб-браузерах.</target>
        </trans-unit>
        <trans-unit id="39bd3cb8cae2c62c26836b759476b4dce92db62c" translate="yes" xml:space="preserve">
          <source>Generating diff text</source>
          <target state="translated">Генерация различного текста</target>
        </trans-unit>
        <trans-unit id="6e83f1be8cebf28e1aa935d46feefe8c9c9b6bff" translate="yes" xml:space="preserve">
          <source>Generating diffs</source>
          <target state="translated">Генерирующие различия</target>
        </trans-unit>
        <trans-unit id="d70a52c9081d71ce670fc7b47fc3bc012193cc1a" translate="yes" xml:space="preserve">
          <source>Generating patch text with -p</source>
          <target state="translated">Генерирование текста патча с помощью -p</target>
        </trans-unit>
        <trans-unit id="6aeb48d435992fb6dfeaeb57975b9744c65abe0f" translate="yes" xml:space="preserve">
          <source>Generating projects list using gitweb</source>
          <target state="translated">Создание списка проектов с помощью gitweb</target>
        </trans-unit>
        <trans-unit id="77a43161f16023a4081e441eda8d16415635830a" translate="yes" xml:space="preserve">
          <source>Generic &amp;lt;revision range&amp;gt; expression (see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) means the commits in the specified range.</source>
          <target state="translated">Выражение Generic &amp;lt;revision range&amp;gt; (см. Раздел &amp;laquo; &lt;a href=&quot;gitrevisions&quot;&gt;УКАЗАНИЕ РЕДАКЦИЙ&lt;/a&gt; &amp;raquo; в gitrevisions [7] ) означает коммиты в указанном диапазоне.</target>
        </trans-unit>
        <trans-unit id="6a8b0f1bc43a4668545c1d049581bdef7899704d" translate="yes" xml:space="preserve">
          <source>Get and set repository or global options</source>
          <target state="translated">Получить и установить репозиторий или глобальные опции</target>
        </trans-unit>
        <trans-unit id="e36c9f7c3a3791a600900bd999a01e746ced35ba" translate="yes" xml:space="preserve">
          <source>Get the value for a given key (optionally filtered by a regex matching the value). Returns error code 1 if the key was not found and the last value if multiple key values were found.</source>
          <target state="translated">Получить значение для заданного ключа (опционально отфильтрованное по регрессу,совпадающему со значением).Возвращает код ошибки 1,если ключ не был найден,и последнее значение,если было найдено несколько значений ключа.</target>
        </trans-unit>
        <trans-unit id="1ed0d09699cf6099e40ea031af476399c03ae869" translate="yes" xml:space="preserve">
          <source>Gets the Subversion property given as the first argument, for a file. A specific revision can be specified with -r/--revision.</source>
          <target state="translated">Получает в качестве первого аргумента для файла свойство Subversion.Определенная ревизия может быть указана с помощью -r/-проверки.</target>
        </trans-unit>
        <trans-unit id="516c94a58b7d13bbfd33d93293ff07c0a7a0cbf5" translate="yes" xml:space="preserve">
          <source>Getting and Creating Projects</source>
          <target state="translated">Получение и создание проектов</target>
        </trans-unit>
        <trans-unit id="970eb65fbea28c10c8dd662819611907796540db" translate="yes" xml:space="preserve">
          <source>Getting changes out is easy:</source>
          <target state="translated">Переодеться легко:</target>
        </trans-unit>
        <trans-unit id="f3ce20bb7af9a1868b401164829dfe90efbb8e6d" translate="yes" xml:space="preserve">
          <source>Getting conflict-resolution help during a merge</source>
          <target state="translated">Получение помощи в разрешении конфликтов во время слияния</target>
        </trans-unit>
        <trans-unit id="060f712c74598ce01e86d56802d9344d8ed68bb7" translate="yes" xml:space="preserve">
          <source>Getting help</source>
          <target state="translated">Получить помощь</target>
        </trans-unit>
        <trans-unit id="c459e54c0b44554b9b817457994c7c37528258a0" translate="yes" xml:space="preserve">
          <source>Getting updates with git pull</source>
          <target state="translated">Получение обновлений с помощью git тяги</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="d732d81f4de6cbbc7c08999550694240dc675ed1" translate="yes" xml:space="preserve">
          <source>Git Commits</source>
          <target state="translated">Git Commits</target>
        </trans-unit>
        <trans-unit id="d0aaf3f6b8eb7d9c0d9e9cfe8351718f5fff142e" translate="yes" xml:space="preserve">
          <source>Git Diffs</source>
          <target state="translated">Гит Диффс</target>
        </trans-unit>
        <trans-unit id="2f8f97d0e40130f1bd878938daff8ad22d7dc440" translate="yes" xml:space="preserve">
          <source>Git Native</source>
          <target state="translated">уроженец гита</target>
        </trans-unit>
        <trans-unit id="29dd0634894701f7508333c275f98d0f1320daee" translate="yes" xml:space="preserve">
          <source>Git Repository Layout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e98b90bf56079b25bb9356fe9439f3123affff" translate="yes" xml:space="preserve">
          <source>Git Thread Messages</source>
          <target state="translated">Сообщения Git Thread</target>
        </trans-unit>
        <trans-unit id="cae0e86da292416c6a36a0e4ce238566c9d247c3" translate="yes" xml:space="preserve">
          <source>Git Transport</source>
          <target state="translated">Гит-Транспорт</target>
        </trans-unit>
        <trans-unit id="a7c39055264c29496e9ec925896bc3e3ec696cb4" translate="yes" xml:space="preserve">
          <source>Git allows you to specify scripts called &quot;hooks&quot; to be run at certain points. You can use these, for example, to send all commits to the shared repository to a mailing list. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">Git позволяет вам указывать скрипты, называемые &amp;laquo;перехватчиками&amp;raquo;, которые будут запускаться в определенные моменты. Вы можете использовать их, например, для отправки всех коммитов в общий репозиторий в список рассылки. См. &lt;a href=&quot;githooks&quot;&gt;Githooks [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d26d4c60652b93a42ab638ebb72c8ba6beaba72" translate="yes" xml:space="preserve">
          <source>Git also keeps a pristine copy of Alice&amp;rsquo;s master branch under the name &quot;origin/master&quot;:</source>
          <target state="translated">Git также хранит нетронутую копию основной ветки Алисы под именем origin / master:</target>
        </trans-unit>
        <trans-unit id="1738762c7d776a74999cdf10e57649ca4dc7876a" translate="yes" xml:space="preserve">
          <source>Git also provides a tool called &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; (am stands for &quot;apply mailbox&quot;), for importing such an emailed series of patches. Just save all of the patch-containing messages, in order, into a single mailbox file, say &lt;code&gt;patches.mbox&lt;/code&gt;, then run</source>
          <target state="translated">Git также предоставляет инструмент под названием &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; (am означает &amp;laquo;применить почтовый ящик&amp;raquo;) для импорта такой серии исправлений, отправленных по электронной почте. Просто сохраните все сообщения, содержащие патч, по порядку в один файл почтового ящика, скажем, &lt;code&gt;patches.mbox&lt;/code&gt; , затем запустите</target>
        </trans-unit>
        <trans-unit id="1dc53eccf42e15dc7948bd5d68aac36dca57063c" translate="yes" xml:space="preserve">
          <source>Git archive</source>
          <target state="translated">Git-архив</target>
        </trans-unit>
        <trans-unit id="54c5b60d3b067a46392b8d1f7e7e747f00fb6589" translate="yes" xml:space="preserve">
          <source>Git can also be used in a CVS-like mode, with a central repository that various users push changes to; see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Git также можно использовать в режиме, подобном CVS, с центральным репозиторием, куда различные пользователи отправляют изменения; см. &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; и &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12dda0ab622d98c0bb3ecd2dcca2f78143c72090" translate="yes" xml:space="preserve">
          <source>Git can detect errors when it reads an object, by checking that the object&amp;rsquo;s name is still the SHA-1 hash of its contents.</source>
          <target state="translated">Git может обнаруживать ошибки при чтении объекта, проверяя, что имя объекта по-прежнему является хешем SHA-1 его содержимого.</target>
        </trans-unit>
        <trans-unit id="e99355d5c834d0a7e793f2a903c686c73ccc0248" translate="yes" xml:space="preserve">
          <source>Git can help you perform a three-way merge, which can in turn be used for a many-way merge by repeating the merge procedure several times. The usual situation is that you only do one three-way merge (reconciling two lines of history) and commit the result, but if you like to, you can merge several branches in one go.</source>
          <target state="translated">Git может помочь вам выполнить трёхстороннее слияние,которое,в свою очередь,может быть использовано для многостороннего слияния,повторив процедуру слияния несколько раз.Обычная ситуация заключается в том,что вы выполняете только одно трёхходовое слияние (примирение двух строк истории)и фиксируете результат,но при желании вы можете выполнить слияние нескольких веток за один ход.</target>
        </trans-unit>
        <trans-unit id="9711e4cc3e77224217a8eadfcd9bddb77a1a6b3f" translate="yes" xml:space="preserve">
          <source>Git can quickly determine whether two objects are identical or not, just by comparing names.</source>
          <target state="translated">Git может быстро определить,идентичны ли два объекта,просто сравнивая имена.</target>
        </trans-unit>
        <trans-unit id="66761dbf024e7710e093b6a26bb079c9a462b99d" translate="yes" xml:space="preserve">
          <source>Git comes with a &quot;curl&quot; family of remote helpers, that handle various transport protocols, such as &lt;code&gt;git-remote-http&lt;/code&gt;, &lt;code&gt;git-remote-https&lt;/code&gt;, &lt;code&gt;git-remote-ftp&lt;/code&gt; and &lt;code&gt;git-remote-ftps&lt;/code&gt;. They implement the capabilities &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;option&lt;/code&gt;, and &lt;code&gt;push&lt;/code&gt;.</source>
          <target state="translated">Git поставляется с семейством удаленных помощников curl, которые обрабатывают различные транспортные протоколы, такие как &lt;code&gt;git-remote-http&lt;/code&gt; , &lt;code&gt;git-remote-https&lt;/code&gt; , &lt;code&gt;git-remote-ftp&lt;/code&gt; и &lt;code&gt;git-remote-ftps&lt;/code&gt; . Они реализуют возможности &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;option&lt;/code&gt; и &lt;code&gt;push&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91008229119a3ca60fa9a13273e5a206ad3c01e1" translate="yes" xml:space="preserve">
          <source>Git command-line interface and conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="590c7b2e50468cb97c1bacdf4c22b05f53204bcc" translate="yes" xml:space="preserve">
          <source>Git commands</source>
          <target state="translated">Команды Git'а</target>
        </trans-unit>
        <trans-unit id="748a4c7cdb8da160e4137b5f163f8f4f719642f9" translate="yes" xml:space="preserve">
          <source>Git concepts</source>
          <target state="translated">Git-концепции</target>
        </trans-unit>
        <trans-unit id="23daed08ae51790de19c33ed17896e5944bcf442" translate="yes" xml:space="preserve">
          <source>Git considers each credential to have a context defined by a URL. This context is used to look up context-specific configuration, and is passed to any helpers, which may use it as an index into secure storage.</source>
          <target state="translated">Git считает,что каждая учетная запись имеет контекст,определяемый URL.Этот контекст используется для поиска контекстно-зависимой конфигурации и передаётся любым помощникам,которые могут использовать его в качестве индекса в безопасном хранилище.</target>
        </trans-unit>
        <trans-unit id="50d371d1d26e20ed2106ca5d2c77efab159f6b5e" translate="yes" xml:space="preserve">
          <source>Git data exporter</source>
          <target state="translated">Git-экспортёр данных</target>
        </trans-unit>
        <trans-unit id="df14b19afe5ac9b190d2e62a9bb072306d0becda" translate="yes" xml:space="preserve">
          <source>Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.</source>
          <target state="translated">Git вообще не пытался отправить ссылку,как правило,потому что это не быстрая перемотка и вы не форсировали обновление.</target>
        </trans-unit>
        <trans-unit id="2dac5af4573e16931bda9b37c2f40888a8b49b4e" translate="yes" xml:space="preserve">
          <source>Git diff features. By performing only the transformation step yourself, you can still utilize many of Git&amp;rsquo;s diff features, including colorization, word-diff, and combined diffs for merges.</source>
          <target state="translated">Возможности Git diff. Выполняя только этап преобразования самостоятельно, вы по-прежнему можете использовать многие функции Git diff, включая раскрашивание, word-diff и комбинированные различия для слияний.</target>
        </trans-unit>
        <trans-unit id="4e4742213b12ec1297779eac50efdab191f84da4" translate="yes" xml:space="preserve">
          <source>Git differs from CVS in that every working tree contains a repository with a full copy of the project history, and no repository is inherently more important than any other. However, you can emulate the CVS model by designating a single shared repository which people can synchronize with; this document explains how to do that.</source>
          <target state="translated">Git отличается от CVS тем,что каждое рабочее дерево содержит репозиторий с полной копией истории проекта,и ни один репозиторий по своей природе не является более важным,чем любой другой.Тем не менее,вы можете эмулировать CVS-модель,создав единый разделяемый репозиторий,с которым люди могут синхронизироваться;этот документ объясняет,как это сделать.</target>
        </trans-unit>
        <trans-unit id="52ba75f7d53c0098d95000c61cda5fd5ea6917af" translate="yes" xml:space="preserve">
          <source>Git directory name</source>
          <target state="translated">Имя Git-директории</target>
        </trans-unit>
        <trans-unit id="5d9fa4d20745d4b5b2bcfd60f9d543f73fbbd4e6" translate="yes" xml:space="preserve">
          <source>Git directory name, where all characters except for alphanumeric ones, &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are replaced with &lt;code&gt;_&lt;/code&gt; (this should make it easier to use the directory name in a filename if wanted)</source>
          <target state="translated">Git имя каталога, в котором все символы для буквенно - цифровых из них , за исключением, &lt;code&gt;.&lt;/code&gt; , и &lt;code&gt;-&lt;/code&gt; заменяются на &lt;code&gt;_&lt;/code&gt; (это должно упростить использование имени каталога в имени файла, если необходимо)</target>
        </trans-unit>
        <trans-unit id="9cf813a3cd69ecbe5e00c63d983206328e14b759" translate="yes" xml:space="preserve">
          <source>Git does not allow partial checkouts, so duplicating this approach in Git would force developers to keep a local copy of modules they are not interested in touching. Commits in an enormous checkout would be slower than you&amp;rsquo;d expect as Git would have to scan every directory for changes. If modules have a lot of local history, clones would take forever.</source>
          <target state="translated">Git не допускает частичную проверку, поэтому дублирование этого подхода в Git вынудило бы разработчиков хранить локальную копию модулей, которые им неинтересны. Коммиты при огромной проверке будут медленнее, чем вы ожидаете, поскольку Git должен будет сканировать каждый каталог на предмет изменений. Если у модулей много местной истории, клоны потребуются вечно.</target>
        </trans-unit>
        <trans-unit id="8b2d9679cf8575fc6c4cfb84434fb5d8180eb7ab" translate="yes" xml:space="preserve">
          <source>Git explained</source>
          <target state="translated">Гит объяснил</target>
        </trans-unit>
        <trans-unit id="97b68f2c19cbd9c04d7ca8ff88d2678de8cfd1c0" translate="yes" xml:space="preserve">
          <source>Git for CVS users</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db9018815b17c54cf84524352784d68bf492b44" translate="yes" xml:space="preserve">
          <source>Git glossary</source>
          <target state="translated">глоссарий по гитаре</target>
        </trans-unit>
        <trans-unit id="11c6d04869311aae599c74c45ab29a30fd9dc2d3" translate="yes" xml:space="preserve">
          <source>Git has a default disposition of keeping data unless it&amp;rsquo;s explicitly thrown away; this extends to holding onto local references to branches on remotes that have themselves deleted those branches.</source>
          <target state="translated">По умолчанию в Git хранятся данные, если они явно не выброшены; это распространяется на удержание локальных ссылок на ветки на пультах, которые сами удалили эти ветки.</target>
        </trans-unit>
        <trans-unit id="c792c246c2740fcc85816c7742979ab9c07c5067" translate="yes" xml:space="preserve">
          <source>Git has an internal interface for storing and retrieving credentials from system-specific helpers, as well as prompting the user for usernames and passwords. The git-credential command exposes this interface to scripts which may want to retrieve, store, or prompt for credentials in the same manner as Git. The design of this scriptable interface models the internal C API; see credential.h for more background on the concepts.</source>
          <target state="translated">Git имеет внутренний интерфейс для хранения и получения учетных данных от системных помощников,а также для подсказки пользователю имени пользователя и пароля.Команда git-credential открывает этот интерфейс для сценариев,которые могут захотеть получить,сохранить или запросить учетные данные таким же образом,как и Git.Дизайн этого интерфейса сценариев моделирует внутренний C API;смотрите в файле credential.h,чтобы узнать больше о концепциях.</target>
        </trans-unit>
        <trans-unit id="b5c69a965c60312962f3f44179acdc3a60b40e17" translate="yes" xml:space="preserve">
          <source>Git has no way of knowing that the new head is an updated version of the old head; it treats this situation exactly the same as it would if two developers had independently done the work on the old and new heads in parallel. At this point, if someone attempts to merge the new head in to their branch, Git will attempt to merge together the two (old and new) lines of development, instead of trying to replace the old by the new. The results are likely to be unexpected.</source>
          <target state="translated">Git не может знать,что новая голова-это обновленная версия старой головы;он относится к этой ситуации точно так же,как если бы два разработчика независимо друг от друга выполняли работу над старой и новой головами параллельно.На данный момент,если кто-то попытается слить новую голову в свою ветку,Git попытается слить две (старую и новую)линии разработки,вместо того чтобы пытаться заменить старую на новую.Результаты,скорее всего,будут неожиданными.</target>
        </trans-unit>
        <trans-unit id="06c2297147a37b1c482365d9d8f31d8dedf40fc4" translate="yes" xml:space="preserve">
          <source>Git history is represented as a series of interrelated commits. We have already seen that the &lt;code&gt;git log&lt;/code&gt; command can list those commits. Note that first line of each git log entry also gives a name for the commit:</source>
          <target state="translated">История Git представлена ​​как серия взаимосвязанных коммитов. Мы уже видели, что команда &lt;code&gt;git log&lt;/code&gt; может перечислить эти коммиты. Обратите внимание, что первая строка каждой записи журнала git также дает имя фиксации:</target>
        </trans-unit>
        <trans-unit id="3e99ade0692d549a8a950dd96317ceaffb9107bb" translate="yes" xml:space="preserve">
          <source>Git imposes the following rules on how references are named:</source>
          <target state="translated">Git накладывает следующие правила на то,как называются ссылки:</target>
        </trans-unit>
        <trans-unit id="a288f739ab4cf5d9993c702076fe0dc6fc3ee3ba" translate="yes" xml:space="preserve">
          <source>Git internal format</source>
          <target state="translated">Git внутренний формат</target>
        </trans-unit>
        <trans-unit id="64a97e8eaa30379dfa62ee80bea9820c4fe8a22e" translate="yes" xml:space="preserve">
          <source>Git is a Distributed Version Control system (DVCS) created by Linus Torvalds and maintained by Junio Hamano.</source>
          <target state="translated">Git-это распределённая система контроля версий (DVCS),созданная Линусом Торвальдсом (Linus Torvalds)и поддерживаемая Хунио Хамано (Junio Hamano).</target>
        </trans-unit>
        <trans-unit id="f3967c7f5aeb4487a30c2b76c0330d8f45c7d45a" translate="yes" xml:space="preserve">
          <source>Git is a fast distributed revision control system.</source>
          <target state="translated">Git-это быстрая распределенная система контроля ревизий.</target>
        </trans-unit>
        <trans-unit id="39998d13fc7a27f9efbe60a086c013b3bd3030af" translate="yes" xml:space="preserve">
          <source>Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals.</source>
          <target state="translated">Git-это быстрая,масштабируемая,распределённая система контроля ревизий с необычайно богатым набором команд,обеспечивающая как высокоуровневые операции,так и полный доступ к внутренним ресурсам.</target>
        </trans-unit>
        <trans-unit id="9fb5868e31358193ca8585301de5ca9891b34989" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It does this by storing compressed snapshots of the contents of a file hierarchy, together with &quot;commits&quot; which show the relationships between these snapshots.</source>
          <target state="translated">Git лучше всего рассматривать как инструмент для хранения истории коллекции файлов.Он делает это путём хранения сжатых снимков содержимого файловой иерархии вместе с &quot;коммитами&quot;,показывающими взаимосвязь между этими снимками.</target>
        </trans-unit>
        <trans-unit id="35ff36d5accbb4f2dda359fd3229598730d5aa08" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It stores the history as a compressed collection of interrelated snapshots of the project&amp;rsquo;s contents. In Git each such version is called a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">Git лучше всего рассматривать как инструмент для хранения истории коллекции файлов. Он хранит историю как сжатую коллекцию взаимосвязанных снимков содержимого проекта. В Git каждая такая версия называется &lt;a href=&quot;#def_commit&quot;&gt;фиксацией&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a9590b40529c70c530e12c39759365698786125" translate="yes" xml:space="preserve">
          <source>Git is built on a small number of simple but powerful ideas. While it is possible to get things done without understanding them, you will find Git much more intuitive if you do.</source>
          <target state="translated">Git построен на небольшом количестве простых,но мощных идей.Хотя можно делать вещи,не понимая их,Git будет гораздо более интуитивным,если вы это сделаете.</target>
        </trans-unit>
        <trans-unit id="acccb72bd7439cce396900f6956100688cfe6ddd" translate="yes" xml:space="preserve">
          <source>Git is to some extent character encoding agnostic.</source>
          <target state="translated">Git в некоторой степени является кодирующим агностическим символом.</target>
        </trans-unit>
        <trans-unit id="db4366f04a4436ab91b01ad18e3f75e42a556e25" translate="yes" xml:space="preserve">
          <source>Git namespaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a87c04c678f1edcfea18d0a701f5da80659e7540" translate="yes" xml:space="preserve">
          <source>Git neither stops nor restarts the filter process in case the &quot;error&quot;/&quot;abort&quot; status is set. However, Git sets its exit code according to the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag, mimicking the behavior of the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; mechanism.</source>
          <target state="translated">Git не останавливает и не перезапускает процесс фильтрации, если установлен статус &amp;laquo;ошибка&amp;raquo; / &amp;laquo;прерывание&amp;raquo;. Однако Git устанавливает свой код выхода в соответствии с флагом &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; , имитируя поведение &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; механизм.</target>
        </trans-unit>
        <trans-unit id="bcbcedc091eff7502178afecdce9f3afdc72dc05" translate="yes" xml:space="preserve">
          <source>Git provides extremely flexible and fast tools for exploring the history of a project.</source>
          <target state="translated">Git предоставляет чрезвычайно гибкие и быстрые инструменты для изучения истории проекта.</target>
        </trans-unit>
        <trans-unit id="38200bd70c851718b2397208bade5f568860b37a" translate="yes" xml:space="preserve">
          <source>Git recognizes files encoded in ASCII or one of its supersets (e.g. UTF-8, ISO-8859-1, &amp;hellip;​) as text files. Files encoded in certain other encodings (e.g. UTF-16) are interpreted as binary and consequently built-in Git text processing tools (e.g. &lt;code&gt;git diff&lt;/code&gt;) as well as most Git web front ends do not visualize the contents of these files by default.</source>
          <target state="translated">Git распознает файлы, закодированные в ASCII или одном из его расширенных наборов (например, UTF-8, ISO-8859-1,&amp;hellip;), как текстовые файлы. Файлы, закодированные в некоторых других кодировках (например, UTF-16), интерпретируются как двоичные, и, следовательно, встроенные инструменты обработки текста Git (например, &lt;code&gt;git diff&lt;/code&gt; ), а также большинство веб-интерфейсов Git по умолчанию не визуализируют содержимое этих файлов.</target>
        </trans-unit>
        <trans-unit id="db884716c8275e6cfa36ed29dbc5d360bba57d0e" translate="yes" xml:space="preserve">
          <source>Git relies on the proper configuration of this variable for your operating and file system. Modifying this value may result in unexpected behavior.</source>
          <target state="translated">Git полагается на правильную конфигурацию этой переменной для вашей операционной и файловой системы.Изменение этого значения может привести к неожиданному поведению.</target>
        </trans-unit>
        <trans-unit id="a66f7e50154ea192af5f4749135be70398075b72" translate="yes" xml:space="preserve">
          <source>Git repositories are normally totally self-sufficient and relocatable. Unlike CVS, for example, there is no separate notion of &quot;repository&quot; and &quot;working tree&quot;. A Git repository normally &lt;strong&gt;is&lt;/strong&gt; the working tree, with the local Git information hidden in the &lt;code&gt;.git&lt;/code&gt; subdirectory. There is nothing else. What you see is what you got.</source>
          <target state="translated">Репозитории Git обычно полностью автономны и могут быть перемещены. В отличие от CVS, например, здесь нет отдельного понятия &amp;laquo;репозиторий&amp;raquo; и &amp;laquo;рабочее дерево&amp;raquo;. Репозиторий Git обычно &lt;strong&gt;является&lt;/strong&gt; рабочим деревом, а локальная информация Git скрыта в подкаталоге &lt;code&gt;.git&lt;/code&gt; . Больше ничего нет. Вы видите то, что получаете.</target>
        </trans-unit>
        <trans-unit id="cf8c005d3f0e4d9e1ff9d1e8d46ef8fd98f0bbf4" translate="yes" xml:space="preserve">
          <source>Git repository format versions</source>
          <target state="translated">Версии формата Git-репозитория</target>
        </trans-unit>
        <trans-unit id="cd868bd588534f7cc4b6680d57c0627b3503b53c" translate="yes" xml:space="preserve">
          <source>Git sends the remote helper a list of commands on standard input, one per line. The first command is always the &lt;code&gt;capabilities&lt;/code&gt; command, in response to which the remote helper must print a list of the capabilities it supports (see below) followed by a blank line. The response to the capabilities command determines what commands Git uses in the remainder of the command stream.</source>
          <target state="translated">Git отправляет удаленному помощнику список команд на стандартный ввод, по одной в строке. Первая команда всегда является командой &lt;code&gt;capabilities&lt;/code&gt; , в ответ на которую удаленный помощник должен распечатать список поддерживаемых им возможностей (см. Ниже), за которым следует пустая строка. Ответ на команду &amp;laquo;Возможности&amp;raquo; определяет, какие команды Git использует в оставшейся части командного потока.</target>
        </trans-unit>
        <trans-unit id="49f2ae128519616ee7193d5988bcbce620249ed4" translate="yes" xml:space="preserve">
          <source>Git supports dividing the refs of a single repository into multiple namespaces, each of which has its own branches, tags, and HEAD. Git can expose each namespace as an independent repository to pull from and push to, while sharing the object store, and exposing all the refs to operations such as &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">Git поддерживает разделение ссылок одного репозитория на несколько пространств имен, каждое из которых имеет свои собственные ветви, теги и HEAD. Git может предоставить каждое пространство имен как независимый репозиторий, из которого можно извлекать и отправлять данные, при этом совместно используя хранилище объектов и предоставляя все ссылки для таких операций, как &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da0d87f50d864c408fa4b395576786d97bb31ddd" translate="yes" xml:space="preserve">
          <source>Git supports ssh, git, http, and https protocols (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it).</source>
          <target state="translated">Git поддерживает протоколы ssh,git,http и https (кроме того,ftp и ftps могут использоваться для извлечения,но это неэффективно и устарело;не используйте его).</target>
        </trans-unit>
        <trans-unit id="2cde7635ac8cf69f2e210aa19a54d3042440cb25" translate="yes" xml:space="preserve">
          <source>Git tracks content not files</source>
          <target state="translated">Git отслеживает содержимое,а не файлы</target>
        </trans-unit>
        <trans-unit id="d302527fd1d763cfe7e5d18396b3435236371be0" translate="yes" xml:space="preserve">
          <source>Git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname. For example, &quot;Documentation/*.html&quot; matches &quot;Documentation/git.html&quot; but not &quot;Documentation/ppc/ppc.html&quot; or &quot;tools/perf/Documentation/perf.html&quot;.</source>
          <target state="translated">Git рассматривает шаблон как глобус оболочки,пригодный для потребления по fnmatch(3)с флагом FNM_PATHNAME:подстановочные знаки в шаблоне не будут совпадать с символом a/в патнаме.Например,&quot;Documentation/*.html&quot; совпадает с &quot;Documentation/git.html&quot;,но не с &quot;Documentation/ppc/ppc.html&quot; или &quot;tools/perf/Documentation/perf.html&quot;.</target>
        </trans-unit>
        <trans-unit id="f8bad0cd453249cf5d129aec87c3431738399e00" translate="yes" xml:space="preserve">
          <source>Git understands the following attributes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e54cce67cf2641b15706179b6168b5a2d3b1bcd" translate="yes" xml:space="preserve">
          <source>Git urls</source>
          <target state="translated">Мерцательные урны</target>
        </trans-unit>
        <trans-unit id="751190188de5688aa514632f7b1c3310593ad2c7" translate="yes" xml:space="preserve">
          <source>Git users can broadly be grouped into four categories for the purposes of describing here a small set of useful command for everyday Git.</source>
          <target state="translated">Пользователей Git'а в целом можно разделить на четыре категории для описания здесь небольшого набора полезных команд для повседневной работы с Git'ом.</target>
        </trans-unit>
        <trans-unit id="b7ac07d144784e0a8c84df59d7316744b8847546" translate="yes" xml:space="preserve">
          <source>Git uses a simple text format to store customizations that are per repository and are per user. Such a configuration file may look like this:</source>
          <target state="translated">Git использует простой текстовый формат для хранения настроек,которые для каждого репозитория и для каждого пользователя.Такой конфигурационный файл может выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="172b4ceb66bee5a713d5dcc15584b89df5db983d" translate="yes" xml:space="preserve">
          <source>Git usually guesses correctly whether a blob contains text or binary data by examining the beginning of the contents. However, sometimes you may want to override its decision, either because a blob contains binary data later in the file, or because the content, while technically composed of text characters, is opaque to a human reader. For example, many postscript files contain only ASCII characters, but produce noisy and meaningless diffs.</source>
          <target state="translated">Git обычно правильно угадывает,содержит ли блок текст или двоичные данные,изучая начало содержимого.Однако иногда вам может понадобиться отменить его решение,либо потому,что блок содержит двоичные данные позже в файле,либо потому,что содержимое,хотя технически и состоит из текстовых символов,непрозрачно для человека-читателя.Например,многие постскриптовые файлы содержат только ASCII-символы,но создают шумные и бессмысленные различия.</target>
        </trans-unit>
        <trans-unit id="8049931f388e861f0f1d36c522924184358c43ba" translate="yes" xml:space="preserve">
          <source>Git was started by Linus Torvalds, and is currently maintained by Junio C Hamano. Numerous contributions have come from the Git mailing list &amp;lt;&lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt;&amp;gt;. &lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt; gives you a more complete list of contributors.</source>
          <target state="translated">Git был запущен Линусом Торвальдсом и в настоящее время поддерживается Джунио С. Хамано. Многочисленные материалы &lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;поступили из&lt;/a&gt; списка рассылки Git &amp;lt; git@vger.kernel.org &amp;gt;. &lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt; дает вам более полный список участников.</target>
        </trans-unit>
        <trans-unit id="526caa17e283066f503c081c2465980601606a1b" translate="yes" xml:space="preserve">
          <source>Git web interface (web frontend to Git repositories)</source>
          <target state="translated">Веб-интерфейс Git'а (веб-фронтенд к Git-репозиториям)</target>
        </trans-unit>
        <trans-unit id="041fb03988c0360186f3faf7d7f4aee25aff3a46" translate="yes" xml:space="preserve">
          <source>Git will apply each patch in order; if any conflicts are found, it will stop, and you can fix the conflicts as described in &quot;&lt;a href=&quot;#resolving-a-merge&quot;&gt;Resolving a merge&lt;/a&gt;&quot;. (The &lt;code&gt;-3&lt;/code&gt; option tells Git to perform a merge; if you would prefer it just to abort and leave your tree and index untouched, you may omit that option.)</source>
          <target state="translated">Git применяет каждый патч по порядку; если будут обнаружены какие-либо конфликты, он остановится, и вы сможете исправить конфликты, как описано в разделе &amp;laquo; &lt;a href=&quot;#resolving-a-merge&quot;&gt;Разрешение слияния&lt;/a&gt; &amp;raquo;. (Параметр &lt;code&gt;-3&lt;/code&gt; указывает Git выполнить слияние; если вы предпочитаете, чтобы он просто прервался и оставил свое дерево и индекс нетронутыми, вы можете опустить этот параметр.)</target>
        </trans-unit>
        <trans-unit id="5affbc744831be1e58dd602e173c2e8a9635241c" translate="yes" xml:space="preserve">
          <source>Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually.</source>
          <target state="translated">Git выйдет из строя (изящно)в случае,если ему понадобится изменить этот файл в индексе,например,при слиянии в коммите;таким образом,в случае,если предполагается,что файл будет изменён вверх по течению,вам придётся разобраться с ситуацией вручную.</target>
        </trans-unit>
        <trans-unit id="48da4a71e3b0bf95013a3e083375ba4a4f8d9442" translate="yes" xml:space="preserve">
          <source>Git will limit what files it checks for changes as well as which directories are checked for untracked files based on the path names given.</source>
          <target state="translated">Git ограничит,какие файлы он проверяет на наличие изменений,а также какие каталоги проверяются на наличие неотслеживаемых файлов,основываясь на заданных именах путей.</target>
        </trans-unit>
        <trans-unit id="9b6711c26bfff56f55ea4e0cb9cd80ae556f923a" translate="yes" xml:space="preserve">
          <source>Git will reply</source>
          <target state="translated">Git ответит</target>
        </trans-unit>
        <trans-unit id="bca1285083439b77ee97a317766aadc935c0bbdf" translate="yes" xml:space="preserve">
          <source>Git will sometimes need credentials from the user in order to perform operations; for example, it may need to ask for a username and password in order to access a remote repository over HTTP. This manual describes the mechanisms Git uses to request these credentials, as well as some features to avoid inputting these credentials repeatedly.</source>
          <target state="translated">Иногда Gitу требуются учетные данные пользователя для выполнения операций;например,ему может потребоваться ввести имя пользователя и пароль для доступа к удалённому репозиторию по HTTP.Данное руководство описывает механизмы,используемые Git'ом для запроса этих учётных данных,а также некоторые возможности,позволяющие избежать повторного ввода этих данных.</target>
        </trans-unit>
        <trans-unit id="dd4de92d6643474e91f15af2289a2ff1175302eb" translate="yes" xml:space="preserve">
          <source>Git writes temporary &lt;code&gt;BASE&lt;/code&gt;, &lt;code&gt;LOCAL&lt;/code&gt;, and &lt;code&gt;REMOTE&lt;/code&gt; versions of conflicting files in the worktree by default. Git will attempt to use a temporary directory for these files when set &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Git записывает временные &lt;code&gt;BASE&lt;/code&gt; , &lt;code&gt;LOCAL&lt;/code&gt; и &lt;code&gt;REMOTE&lt;/code&gt; версию конфликтующих файлы в worktree по умолчанию. Если установлено значение &lt;code&gt;true&lt;/code&gt; , Git попытается использовать временный каталог для этих файлов . По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24c7b4499addc9a93ccbe263411515a9a891fc27" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s ability to quickly import and merge patches allows a single maintainer to process incoming changes even at very high rates. And when that becomes too much, &lt;code&gt;git pull&lt;/code&gt; provides an easy way for that maintainer to delegate this job to other maintainers while still allowing optional review of incoming changes.</source>
          <target state="translated">Возможность Git быстро импортировать и объединять исправления позволяет одному сопровождающему обрабатывать входящие изменения даже с очень высокой скоростью. И когда этого становится слишком много, &lt;code&gt;git pull&lt;/code&gt; предоставляет обслуживающему персоналу простой способ делегировать эту работу другим сопровождающим, при этом позволяя дополнительно просматривать входящие изменения.</target>
        </trans-unit>
        <trans-unit id="9715a07ab0249fd3ddbc253711eb7248c1c1366b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s i18n setup code for shell scripts</source>
          <target state="translated">Код настройки git i18n для сценариев оболочки</target>
        </trans-unit>
        <trans-unit id="4917cf9f784e37253e2667c9ea0e66247909051b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s submodule support allows a repository to contain, as a subdirectory, a checkout of an external project. Submodules maintain their own identity; the submodule support just stores the submodule repository location and commit ID, so other developers who clone the containing project (&quot;superproject&quot;) can easily clone all the submodules at the same revision. Partial checkouts of the superproject are possible: you can tell Git to clone none, some or all of the submodules.</source>
          <target state="translated">Поддержка подмодулей Git позволяет репозиторию содержать в качестве подкаталога проверку внешнего проекта. Подмодули сохраняют свою индивидуальность; поддержка подмодулей просто сохраняет местоположение репозитория подмодулей и идентификатор фиксации, поэтому другие разработчики, которые клонируют содержащий проект (&amp;laquo;суперпроект&amp;raquo;), могут легко клонировать все подмодули в той же ревизии. Возможны частичные проверки суперпроекта: вы можете указать Git не клонировать ни один, некоторые или все подмодули.</target>
        </trans-unit>
        <trans-unit id="f1ffaf3a57e8861e273a81c5d860f0898c1c6dac" translate="yes" xml:space="preserve">
          <source>Gitk was the first graphical repository browser. It&amp;rsquo;s written in tcl/tk.</source>
          <target state="translated">Gitk был первым графическим браузером репозитория. Написано в tcl / tk.</target>
        </trans-unit>
        <trans-unit id="969a3c97b510dcff0a924faf9dee287a0e5d94ec" translate="yes" xml:space="preserve">
          <source>Gitweb assumes this charset when a line contains non-UTF-8 characters. The fallback decoding is used without error checking, so it can be even &quot;utf-8&quot;. The value must be a valid encoding; see the &lt;strong&gt;Encoding::Supported&lt;/strong&gt;(3pm) man page for a list. The default is &quot;latin1&quot;, aka. &quot;iso-8859-1&quot;.</source>
          <target state="translated">Gitweb использует эту кодировку, когда строка содержит символы, отличные от UTF-8. Резервное декодирование используется без проверки ошибок, поэтому оно может быть даже &amp;laquo;utf-8&amp;raquo;. Значение должно быть действительной кодировкой; см. список на странице руководства &lt;strong&gt;Encoding :: Supported&lt;/strong&gt; (3pm). По умолчанию - &amp;laquo;latin1&amp;raquo;, иначе. &quot;ISO-8859-1&quot;.</target>
        </trans-unit>
        <trans-unit id="23aa8c44f909f60d83eed1c6ecddb35429f0603e" translate="yes" xml:space="preserve">
          <source>Gitweb can show information from one or more Git repositories. These repositories have to be all on local filesystem, and have to share common repository root, i.e. be all under a single parent repository (but see also &quot;Advanced web server setup&quot; section, &quot;Webserver configuration with multiple projects' root&quot; subsection).</source>
          <target state="translated">Gitweb может показывать информацию из одного или нескольких Git-репозиториев.Эти репозитории должны находиться в локальной файловой системе и иметь общий корень репозитория,т.е.все они должны находиться под одним родительским репозиторием (см.также раздел &quot;Расширенная настройка веб-сервера&quot;,подраздел &quot;Конфигурация веб-сервера с корнем нескольких проектов&quot;).</target>
        </trans-unit>
        <trans-unit id="80e6e4e3c32d8a850e194d0e624021eac7612871" translate="yes" xml:space="preserve">
          <source>Gitweb can use path_info (component) based URLs, or it can pass all necessary information via query parameters. The typical gitweb URLs are broken down in to five components:</source>
          <target state="translated">Gitweb может использовать URL,основанные на path_info (компонент),или передавать всю необходимую информацию через параметры запроса.Типичные URL gitweb разбиты на пять компонентов:</target>
        </trans-unit>
        <trans-unit id="c91227cd181327062eb5ac3babb9dcdd0a92cc2a" translate="yes" xml:space="preserve">
          <source>Gitweb provides a web interface to Git repositories. Its features include:</source>
          <target state="translated">Gitweb предоставляет веб-интерфейс к Git-репозиториям.Его возможности включают в себя:</target>
        </trans-unit>
        <trans-unit id="b64851fc263d72157b99e98603012bfc29c4f9ff" translate="yes" xml:space="preserve">
          <source>Gitweb reads configuration data from the following sources in the following order:</source>
          <target state="translated">Gitweb считывает данные конфигурации из следующих источников в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="0b6ae99cd0fc07dd07b98d65f39c6a8d809c4979" translate="yes" xml:space="preserve">
          <source>Gitweb version, set automatically when creating gitweb.cgi from gitweb.perl. You might want to modify it if you are running modified gitweb, for example</source>
          <target state="translated">Версия Gitweb,устанавливаемая автоматически при создании gitweb.cgi из gitweb.perl.Возможно,вы захотите изменить его,если вы используете модифицированную версию gitweb,например</target>
        </trans-unit>
        <trans-unit id="fcc44369541727be05647a1cc4996dbc27b86060" translate="yes" xml:space="preserve">
          <source>Gitweb works with Apache and FastCGI. First you need to rename, copy or symlink gitweb.cgi to gitweb.fcgi. Let&amp;rsquo;s assume that gitweb is installed in &lt;code&gt;/usr/share/gitweb&lt;/code&gt; directory. The following Apache configuration is suitable (UNTESTED!)</source>
          <target state="translated">Gitweb работает с Apache и FastCGI. Сначала вам нужно переименовать, скопировать или создать символическую ссылку с gitweb.cgi на gitweb.fcgi. Предположим, что gitweb установлен в каталоге &lt;code&gt;/usr/share/gitweb&lt;/code&gt; . Подходит следующая конфигурация Apache (НЕПРОВЕРЕНО!)</target>
        </trans-unit>
        <trans-unit id="42543af4180750540520e4da78d3e7076123fd5c" translate="yes" xml:space="preserve">
          <source>Give an object a human readable name based on an available ref</source>
          <target state="translated">Дайте объекту имя,пригодное для чтения человеком,на основе доступного справочного материала.</target>
        </trans-unit>
        <trans-unit id="8a08e691bc874c43f32edff7b28078841082dfd2" translate="yes" xml:space="preserve">
          <source>Give push/pull only access to developers using git-over-ssh.</source>
          <target state="translated">Предоставлять push/pull только разработчикам,использующим git-over-ssh.</target>
        </trans-unit>
        <trans-unit id="098611c3aa4062358e82cce32a6cb2188462a62d" translate="yes" xml:space="preserve">
          <source>Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">Дайте выход в удобном для разбора формате для скриптов.Это похоже на короткий вывод,но останется стабильным для всех версий Git'а и вне зависимости от настроек пользователя.Подробности см.ниже.</target>
        </trans-unit>
        <trans-unit id="4cab29647a0992b826e617662d099d2fa7b8c337" translate="yes" xml:space="preserve">
          <source>Give the output in the long-format. This is the default.</source>
          <target state="translated">Дайте выход в длинном формате.По умолчанию.</target>
        </trans-unit>
        <trans-unit id="7b3a4cfa6cfda1ef4f79bab4a1d749c9c6c5f5f0" translate="yes" xml:space="preserve">
          <source>Give the output in the short-format.</source>
          <target state="translated">Дайте выход в коротком формате.</target>
        </trans-unit>
        <trans-unit id="2dc950b47492cb25f78f25c843f0ed41c631283b" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;--delete&lt;/code&gt; and an additional argument, deletes the given symbolic ref.</source>
          <target state="translated">Учитывая &lt;code&gt;--delete&lt;/code&gt; и дополнительный аргумент, удаляет данную символическую ссылку.</target>
        </trans-unit>
        <trans-unit id="e97e8a091675b0288dfc0175fdb5f7c838cea92d" translate="yes" xml:space="preserve">
          <source>Given N &amp;lt;references&amp;gt;, the first N lines are the one-line description from their commit message. The branch head that is pointed at by $GIT_DIR/HEAD is prefixed with an asterisk &lt;code&gt;*&lt;/code&gt; character while other heads are prefixed with a &lt;code&gt;!&lt;/code&gt; character.</source>
          <target state="translated">Учитывая N &amp;lt;references&amp;gt;, первые N строк представляют собой однострочное описание их сообщения фиксации. Заголовок ветки, на который указывает $ GIT_DIR / HEAD, имеет префикс звездочки &lt;code&gt;*&lt;/code&gt; ,в то время как другие заголовки имеют префикс &lt;code&gt;!&lt;/code&gt; персонаж.</target>
        </trans-unit>
        <trans-unit id="a02a332c45eb3b9cf3b89841e8aa1ca85e593c49" translate="yes" xml:space="preserve">
          <source>Given a .git/config like this:</source>
          <target state="translated">С учетом таких .git/config,как этот:</target>
        </trans-unit>
        <trans-unit id="e65ae867c8cb398abc725e8538eba217d02dbede" translate="yes" xml:space="preserve">
          <source>Given a commit, find out where it is relative to the local refs. Say somebody wrote you about that fantastic commit 33db5f4d9027a10e477ccf054b2c1ab94f74c85a. Of course, you look into the commit, but that only tells you what happened, but not the context.</source>
          <target state="translated">При наличии коммита выясните,где он находится по отношению к местным рефери.Скажем,кто-то написал вам об этом фантастическом коммите 33db5f4d9027a10e477ccf054b2c1ab94f74c85a.Конечно,вы смотрите на коммит,но это говорит только о том,что случилось,но не о контексте.</target>
        </trans-unit>
        <trans-unit id="7ce01790b46379d506c51a1991e3ea26b3a8d244" translate="yes" xml:space="preserve">
          <source>Given one argument, reads which branch head the given symbolic ref refers to and outputs its path, relative to the &lt;code&gt;.git/&lt;/code&gt; directory. Typically you would give &lt;code&gt;HEAD&lt;/code&gt; as the &amp;lt;name&amp;gt; argument to see which branch your working tree is on.</source>
          <target state="translated">При наличии одного аргумента считывает, к какой главе ветки относится данная символическая ссылка, и выводит ее путь относительно каталога &lt;code&gt;.git/&lt;/code&gt; . Обычно вы &lt;code&gt;HEAD&lt;/code&gt; в качестве аргумента &amp;lt;name&amp;gt;, чтобы увидеть, на какой ветви находится ваше рабочее дерево.</target>
        </trans-unit>
        <trans-unit id="ee9f44e6df9f9221a39559d12563d4ded15eb1ae" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, apply the change each one introduces, recording a new commit for each. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">Учитывая один или несколько существующих коммитов,применяйте изменения,вносимые каждым из них,записывая новый коммит для каждого из них.Это требует,чтобы ваше рабочее дерево было чистым (никаких изменений из коммита HEAD).</target>
        </trans-unit>
        <trans-unit id="49cfc78f8193ed0e67ffaf9646d690418c000a33" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">Получив один или несколько существующих коммитов,верните изменения,которые были внесены в соответствующие патчи,и запишите несколько новых коммитов,которые их записывают.Это требует,чтобы ваше рабочее дерево было чистым (никаких изменений из фиксации HEAD).</target>
        </trans-unit>
        <trans-unit id="b90c39be8f3013761513d522c230779e0af0700e" translate="yes" xml:space="preserve">
          <source>Given the following noisy input with &lt;code&gt;$&lt;/code&gt; indicating the end of a line:</source>
          <target state="translated">Учитывая следующий зашумленный ввод с символом &lt;code&gt;$&lt;/code&gt; , указывающим на конец строки:</target>
        </trans-unit>
        <trans-unit id="9ae9c5ba5c0cae940c9ccda71b399bacf0ceae54" translate="yes" xml:space="preserve">
          <source>Given three arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs, after verifying that the current value of the &amp;lt;ref&amp;gt; matches &amp;lt;oldvalue&amp;gt;. E.g. &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; updates the master branch head to &amp;lt;newvalue&amp;gt; only if its current value is &amp;lt;oldvalue&amp;gt;. You can specify 40 &quot;0&quot; or an empty string as &amp;lt;oldvalue&amp;gt; to make sure that the ref you are creating does not exist.</source>
          <target state="translated">Учитывая три аргумента, сохраняет &amp;lt;newvalue&amp;gt; в &amp;lt;ref&amp;gt;, возможно, разыменуя символические ссылки, после проверки того, что текущее значение &amp;lt;ref&amp;gt; соответствует &amp;lt;oldvalue&amp;gt;. Например, &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; обновляет заголовок главной ветки до &amp;lt;newvalue&amp;gt;, только если его текущее значение - &amp;lt;oldvalue&amp;gt;. Вы можете указать 40 &amp;laquo;0&amp;raquo; или пустую строку в качестве &amp;lt;oldvalue&amp;gt;, чтобы убедиться, что создаваемая ссылка не существует.</target>
        </trans-unit>
        <trans-unit id="4d8bb10ba2f3cfa88afc4b8727de27fb3cab8018" translate="yes" xml:space="preserve">
          <source>Given three commits &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;git merge-base A B C&lt;/code&gt; will compute the merge base between &lt;code&gt;A&lt;/code&gt; and a hypothetical commit &lt;code&gt;M&lt;/code&gt;, which is a merge between &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;. For example, with this topology:</source>
          <target state="translated">Даны три фиксаций , &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; , &lt;code&gt;git merge-base A B C&lt;/code&gt; вычислят слияния базы между &lt;code&gt;A&lt;/code&gt; и гипотетическая фиксация &lt;code&gt;M&lt;/code&gt; , которая является слиянием между &lt;code&gt;B&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; . Например, с такой топологией: &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be6c9bc842b0965134f1fb7992b74ba082dffe0f" translate="yes" xml:space="preserve">
          <source>Given two arguments, creates or updates a symbolic ref &amp;lt;name&amp;gt; to point at the given branch &amp;lt;ref&amp;gt;.</source>
          <target state="translated">При наличии двух аргументов создает или обновляет символическую ссылку &amp;lt;name&amp;gt;, указывающую на данную ветвь &amp;lt;ref&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="7cc67b58b4d717f52eb7b590f0c2ac097c83b04a" translate="yes" xml:space="preserve">
          <source>Given two arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs. E.g. &lt;code&gt;git update-ref HEAD
&amp;lt;newvalue&amp;gt;&lt;/code&gt; updates the current branch head to the new object.</source>
          <target state="translated">Учитывая два аргумента, сохраняет &amp;lt;новое значение&amp;gt; в &amp;lt;ref&amp;gt;, возможно, разыменуя символические ссылки. Например, &lt;code&gt;git update-ref HEAD &amp;lt;newvalue&amp;gt;&lt;/code&gt; обновляет заголовок текущей ветки до нового объекта.</target>
        </trans-unit>
        <trans-unit id="931db30a85fe3ea596ac121ca8f065ad449ff885" translate="yes" xml:space="preserve">
          <source>Given two commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;git merge-base A B&lt;/code&gt; will output a commit which is reachable from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; through the parent relationship.</source>
          <target state="translated">Для двух коммитов &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;git merge-base A B&lt;/code&gt; выведет коммит, доступный как для &lt;code&gt;A&lt;/code&gt; ,так и для &lt;code&gt;B&lt;/code&gt; через родительские отношения.</target>
        </trans-unit>
        <trans-unit id="b0c09289dc074c18ca9574b29845f64d7cae5bc3" translate="yes" xml:space="preserve">
          <source>Gives some information about the remote &amp;lt;name&amp;gt;.</source>
          <target state="translated">Предоставляет некоторую информацию об удаленном &amp;lt;имя&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="9466e3cfe4b90da05672816c37e48d04d2b0bacb" translate="yes" xml:space="preserve">
          <source>Giving these options is an error when used with &lt;code&gt;--inetd&lt;/code&gt;; use the facility of inet daemon to achieve the same before spawning &lt;code&gt;git daemon&lt;/code&gt; if needed.</source>
          <target state="translated">Указание этих параметров является ошибкой при использовании с &lt;code&gt;--inetd&lt;/code&gt; ; используйте средство демона inet для достижения того же, прежде чем &lt;code&gt;git daemon&lt;/code&gt; если это необходимо.</target>
        </trans-unit>
        <trans-unit id="d0ec3ae2bdc4ccb842cc8f2251da67f38c6daf5a" translate="yes" xml:space="preserve">
          <source>Glob magic is incompatible with literal magic.</source>
          <target state="translated">Магия Глобуса несовместима с буквальной магией.</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="d8608c60e7a8f9d556f6c1f2aff537e2ce064bab" translate="yes" xml:space="preserve">
          <source>Go under &quot;Options&quot; in the Composer window and be sure that &quot;Word wrap&quot; is not set.</source>
          <target state="translated">Перейдите под &quot;Опции&quot; в окне &quot;Композитор&quot; и убедитесь,что &quot;Word wrap&quot; не установлен.</target>
        </trans-unit>
        <trans-unit id="c16a49b3ce3e17532ce6e118e23e9cba92fcb23b" translate="yes" xml:space="preserve">
          <source>Graduation</source>
          <target state="translated">Graduation</target>
        </trans-unit>
        <trans-unit id="7108295a48fb4030d059842641f3ed2f16dd90ea" translate="yes" xml:space="preserve">
          <source>Grafts enables two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make Git pretend the set of &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; has is different from what was recorded when the commit was created. Configured via the &lt;code&gt;.git/info/grafts&lt;/code&gt; file.</source>
          <target state="translated">Grafts позволяет объединить две разные линии развития, записывая ложную информацию о происхождении для коммитов. Таким образом, вы можете заставить Git делать вид, что набор &lt;a href=&quot;#def_parent&quot;&gt;родителей&lt;/a&gt; у &lt;a href=&quot;#def_commit&quot;&gt;коммита&lt;/a&gt; отличается от того, что было записано при создании коммита. Настраивается через файл &lt;code&gt;.git/info/grafts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43addd483f6785ba3f74ca813174b30e77d7804f" translate="yes" xml:space="preserve">
          <source>Graphical alternative to git-commit</source>
          <target state="translated">Графическая альтернатива git-commit</target>
        </trans-unit>
        <trans-unit id="7e3e6e185a96c1bddac8bacc3e22b2d8c14f25b3" translate="yes" xml:space="preserve">
          <source>Group commits based on &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;. If no &lt;code&gt;--group&lt;/code&gt; option is specified, the default is &lt;code&gt;author&lt;/code&gt;. &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="f53aba93b9409d79b694657717f24476b7680a38" translate="yes" xml:space="preserve">
          <source>HEAD can also record a specific commit directly, instead of being a symref to point at the current branch. Such a state is often called &lt;code&gt;detached HEAD.&lt;/code&gt; See &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">HEAD также может записывать конкретный коммит напрямую, вместо того, чтобы быть символической ссылкой, указывающей на текущую ветвь. Такое состояние часто называют &lt;code&gt;detached HEAD.&lt;/code&gt; См. Подробности в &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adaf1f885f4f48f7b3c5a9a2b8f4883bf35d0a07" translate="yes" xml:space="preserve">
          <source>HEAD: refers to the head of the current branch</source>
          <target state="translated">HEAD:относится к руководителю текущего филиала.</target>
        </trans-unit>
        <trans-unit id="408093a274a45499420aa72e738c6e970f863fed" translate="yes" xml:space="preserve">
          <source>HEADER:</source>
          <target state="translated">HEADER:</target>
        </trans-unit>
        <trans-unit id="bd0cfe599144b530c7c9685825d1a02a5377b64e" translate="yes" xml:space="preserve">
          <source>HTML snippet to be included in the &amp;lt;head&amp;gt; section of each page. Can be set using &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">Фрагмент HTML для включения в раздел &amp;lt;head&amp;gt; каждой страницы. Можно установить с помощью &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; во время сборки. Нет значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cc56a2df9f8b6a66c5d2a6125ab52ed375e5152b" translate="yes" xml:space="preserve">
          <source>HTTP Transport</source>
          <target state="translated">HTTP-Транспорт</target>
        </trans-unit>
        <trans-unit id="d578fb1b4bb161c78cd19e50fcb2b009bf47fe3e" translate="yes" xml:space="preserve">
          <source>HTTP(S)</source>
          <target state="translated">HTTP(S)</target>
        </trans-unit>
        <trans-unit id="1ba3338bd0d397031ae85dc0347d63c94b00e5df" translate="yes" xml:space="preserve">
          <source>HTTP/1.1</source>
          <target state="translated">HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="396826d4135990391d3176f7b40c9091eed2c0d3" translate="yes" xml:space="preserve">
          <source>HTTP/2</source>
          <target state="translated">HTTP/2</target>
        </trans-unit>
        <trans-unit id="80bde80e45cfc7c229d507fff6d534806b07378c" translate="yes" xml:space="preserve">
          <source>Hacking git</source>
          <target state="translated">хакерский хакер</target>
        </trans-unit>
        <trans-unit id="c4b8d31a4ffcd043a96008543e3e1f5d7eaf7692" translate="yes" xml:space="preserve">
          <source>Handling Renames</source>
          <target state="translated">Переименования для обработки</target>
        </trans-unit>
        <trans-unit id="3049c71fe9126eefc3301476201dcd8b12bbbd85" translate="yes" xml:space="preserve">
          <source>Handling of svn branches</source>
          <target state="translated">Обработка svn-веток</target>
        </trans-unit>
        <trans-unit id="b2bb788b2d8872820805621988d07bb34824ee87" translate="yes" xml:space="preserve">
          <source>Hard case: The changes are not the same.</source>
          <target state="translated">Тяжелый случай:Изменения не одно и то же.</target>
        </trans-unit>
        <trans-unit id="d86493cd0a3bd6cc52c39427d91b4f3fb5f1ba0f" translate="yes" xml:space="preserve">
          <source>Has no effect if the ref does not have tracking information associated with it. All the options apart from &lt;code&gt;nobracket&lt;/code&gt; are mutually exclusive, but if used together the last option is selected.</source>
          <target state="translated">Не действует, если ссылка не имеет связанной с ней отслеживающей информации. Все параметры, кроме без &lt;code&gt;nobracket&lt;/code&gt; являются взаимоисключающими, но при совместном использовании выбирается последний вариант.</target>
        </trans-unit>
        <trans-unit id="eee44516ee4e4873c5ecfb5a6805b0f8b1007d35" translate="yes" xml:space="preserve">
          <source>Hash object as it were located at the given path. The location of file does not directly influence on the hash value, but path is used to determine what Git filters should be applied to the object before it can be placed to the object database, and, as result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin.</source>
          <target state="translated">Хэш-объект в том виде,в каком он был расположен на данном пути.Расположение файла напрямую не влияет на значение хэша,но путь используется для определения того,какие Git-фильтры должны быть применены к объекту перед его помещением в объектную базу данных,и,в результате применения фильтров,реальный блок,помещённый в объектную базу данных,может отличаться от данного файла.Эта опция в основном полезна для хэширования временных файлов,расположенных за пределами рабочей директории,или файлов,читаемых из stdin.</target>
        </trans-unit>
        <trans-unit id="100c09777204f7d9c4d9c8cca2b2ca1117efcbe1" translate="yes" xml:space="preserve">
          <source>Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the &lt;code&gt;--path&lt;/code&gt; option is given.</source>
          <target state="translated">Хешируйте содержимое как есть, игнорируя любой входной фильтр, который был бы выбран механизмом атрибутов, включая преобразование конца строки. Если файл считывается со стандартного ввода, это всегда подразумевается, если не &lt;code&gt;--path&lt;/code&gt; опция --path .</target>
        </trans-unit>
        <trans-unit id="f2ae7e4a6dc9825ef1a4868750168492eeaf6380" translate="yes" xml:space="preserve">
          <source>Have the server run as an inetd service. Implies --syslog (may be overridden with &lt;code&gt;--log-destination=&lt;/code&gt;). Incompatible with --detach, --port, --listen, --user and --group options.</source>
          <target state="translated">Запустите сервер как службу inetd. Подразумевается --syslog (может быть переопределено с помощью &lt;code&gt;--log-destination=&lt;/code&gt; ). Несовместимо с параметрами --detach, --port, --listen, --user и --group.</target>
        </trans-unit>
        <trans-unit id="db301d2890ccaa14dc974751b62b359a359b6b5c" translate="yes" xml:space="preserve">
          <source>He also uses a set of temporary branches (&quot;topic branches&quot;), each containing a logical grouping of patches.</source>
          <target state="translated">Он также использует набор временных ветвей (&quot;тематические ветви&quot;),каждая из которых содержит логическую группировку патчей.</target>
        </trans-unit>
        <trans-unit id="c983e9a4d9daf24f5efac3a67c8f6c12bda32744" translate="yes" xml:space="preserve">
          <source>He uses two public branches:</source>
          <target state="translated">Он использует два государственных филиала:</target>
        </trans-unit>
        <trans-unit id="08dac5b0781534f17eedb09bc82379faeed11d4a" translate="yes" xml:space="preserve">
          <source>Header lines start with &quot;#&quot; and are added in response to specific command line arguments. Parsers should ignore headers they don&amp;rsquo;t recognize.</source>
          <target state="translated">Строки заголовка начинаются с символа &amp;laquo;#&amp;raquo; и добавляются в ответ на определенные аргументы командной строки. Парсеры должны игнорировать заголовки, которые они не распознают.</target>
        </trans-unit>
        <trans-unit id="6f7a484a67443c5c4893cfcebc8516ecb7a4f1a2" translate="yes" xml:space="preserve">
          <source>Help parsing or adding &lt;code&gt;trailers&lt;/code&gt; lines, that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message.</source>
          <target state="translated">Помогите разобрать или добавить строки &lt;code&gt;trailers&lt;/code&gt; , которые похожи на заголовки электронной почты RFC 822, в конец части сообщения фиксации в свободной форме.</target>
        </trans-unit>
        <trans-unit id="f07e99c3fb43a6bcfb5e09ad2c991cc9571165ae" translate="yes" xml:space="preserve">
          <source>Helper programs to interact with remote repositories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f00958253572e7e593fd3637f7f812370db1d4" translate="yes" xml:space="preserve">
          <source>Helper to store credentials on disk</source>
          <target state="translated">Помощник для хранения учетных данных на диске</target>
        </trans-unit>
        <trans-unit id="91ab6264d347386bb003d96ff4f148c65df714a3" translate="yes" xml:space="preserve">
          <source>Helper to temporarily store passwords in memory</source>
          <target state="translated">Помощь в временном хранении паролей в памяти</target>
        </trans-unit>
        <trans-unit id="f8801cb816506b471cd751bc46c3d753c8b27a46" translate="yes" xml:space="preserve">
          <source>Hence</source>
          <target state="translated">Hence</target>
        </trans-unit>
        <trans-unit id="8286249a7e764f5f9777c2fc17e5230ccc1ef5fe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">Здесь &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; - любое из выражений спецификации фиксации, также принимаемых &lt;code&gt;from&lt;/code&gt; (см. Выше).</target>
        </trans-unit>
        <trans-unit id="3fb766f6c8298c39110428f8565787238a736366" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the following:</source>
          <target state="translated">Здесь &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; может быть любое из следующего:</target>
        </trans-unit>
        <trans-unit id="85bca9b0f87b55d545a8c945215b23dd3bdbffcb" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object.</source>
          <target state="translated">Здесь &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; может быть либо ссылкой на метку ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ), установленной предыдущей командой &lt;code&gt;blob&lt;/code&gt; , либо полным 40-байтовым SHA-1 существующего объекта blob Git.</target>
        </trans-unit>
        <trans-unit id="3f53683a6742f0030e51cf7120f8e28dba9865c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s display name (for example &amp;ldquo;Com M Itter&amp;rdquo;) and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s email address (&amp;ldquo;cm@example.com&amp;rdquo;). &lt;code&gt;LT&lt;/code&gt; and &lt;code&gt;GT&lt;/code&gt; are the literal less-than (\x3c) and greater-than (\x3e) symbols. These are required to delimit the email address from the other fields in the line. Note that &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; are free-form and may contain any sequence of bytes, except &lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;GT&lt;/code&gt; and &lt;code&gt;LF&lt;/code&gt;. &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is typically UTF-8 encoded.</source>
          <target state="translated">Здесь &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; - отображаемое имя человека (например, &amp;laquo;Com M Itter&amp;raquo;), а &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; - адрес электронной почты человека (&amp;laquo;cm@example.com&amp;raquo;). &lt;code&gt;LT&lt;/code&gt; и &lt;code&gt;GT&lt;/code&gt; - это буквальные символы &amp;laquo;меньше&amp;raquo; (\ x3c) и &amp;laquo;больше&amp;raquo; (\ x3e). Они необходимы для отделения адреса электронной почты от других полей в строке. Обратите внимание, что &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; имеют произвольную форму и могут содержать любую последовательность байтов, кроме &lt;code&gt;LT&lt;/code&gt; , &lt;code&gt;GT&lt;/code&gt; и &lt;code&gt;LF&lt;/code&gt; . &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; обычно имеет кодировку UTF-8.</target>
        </trans-unit>
        <trans-unit id="88e3e34bac3d333854c449d8638faee3f973bc68" translate="yes" xml:space="preserve">
          <source>Here actual project root is passed to gitweb via &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; environment variable from a web server, so you need to put the following line in gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; in above example):</source>
          <target state="translated">Здесь фактический корень проекта передается в gitweb через переменную среды &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; с веб-сервера, поэтому вам нужно поместить следующую строку в файл конфигурации &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ( /etc/gitweb.conf в примере выше):</target>
        </trans-unit>
        <trans-unit id="87d852c017173b91ce004ba4ee55c454ec44074f" translate="yes" xml:space="preserve">
          <source>Here again it is a good point to take a pause.</source>
          <target state="translated">Опять же,это хороший повод сделать паузу.</target>
        </trans-unit>
        <trans-unit id="9d560d4da9e941f0111865584d812ed4b996ba31" translate="yes" xml:space="preserve">
          <source>Here are a handful of examples using the Loeliger illustration above, with each step in the notation&amp;rsquo;s expansion and selection carefully spelt out:</source>
          <target state="translated">Вот несколько примеров, использующих иллюстрацию Лелигера выше, где каждый шаг в расширении нотации и выборе тщательно прописан:</target>
        </trans-unit>
        <trans-unit id="917cc5ec6b02db542b24a5b6455b2e756b18d73b" translate="yes" xml:space="preserve">
          <source>Here are some example specifications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6c1665b5306569c28a748694fd4e1b1e7a55db" translate="yes" xml:space="preserve">
          <source>Here are some hints on how to successfully submit patches inline using various mailers.</source>
          <target state="translated">Вот несколько подсказок о том,как успешно отправлять патчи по почте,используя различные почтовые программы.</target>
        </trans-unit>
        <trans-unit id="1510576755c083f75778b41e3e15db4ef8738ed9" translate="yes" xml:space="preserve">
          <source>Here are some of the scripts that simplify all this even further.</source>
          <target state="translated">Вот некоторые из сценариев,которые еще больше упрощают все это.</target>
        </trans-unit>
        <trans-unit id="e7b17934614eee2f77ca3149426accc7b6e72d44" translate="yes" xml:space="preserve">
          <source>Here are the rules regarding the &quot;flags&quot; that you should follow when you are scripting Git:</source>
          <target state="translated">Вот правила,касающиеся &quot;флагов&quot;,которым следует следовать при написании скриптов Git'а:</target>
        </trans-unit>
        <trans-unit id="04cdec1fa8a31abdd551dc359504457bc39d207b" translate="yes" xml:space="preserve">
          <source>Here is a hypothetical usage of the Trace2 API showing the intended usage (without worrying about the actual Git details).</source>
          <target state="translated">Здесь представлено гипотетическое использование Trace2 API,показывающее предполагаемое использование (не беспокоясь о реальных деталях Git'а).</target>
        </trans-unit>
        <trans-unit id="ffd38e59dd005a380c8a8570731f44b027a45fba" translate="yes" xml:space="preserve">
          <source>Here is a list of the facilities provided by this option parser.</source>
          <target state="translated">Вот список возможностей,предоставляемых парсером этого варианта.</target>
        </trans-unit>
        <trans-unit id="e4035106d997a5f9ffd025f7ed0bd5862edf3733" translate="yes" xml:space="preserve">
          <source>Here is a picture that illustrates how various pieces fit together:</source>
          <target state="translated">Вот картинка,которая иллюстрирует,как различные части подходят друг другу:</target>
        </trans-unit>
        <trans-unit id="303a3029ebdf1756e031ccbacc8dc586c90ed37d" translate="yes" xml:space="preserve">
          <source>Here is an ASCII art by Jon Loeliger that illustrates how various &lt;code&gt;diff-*&lt;/code&gt; commands compare things.</source>
          <target state="translated">Вот рисунок ASCII Джона Лелигера, который иллюстрирует, как различные команды &lt;code&gt;diff-*&lt;/code&gt; сравнивают вещи.</target>
        </trans-unit>
        <trans-unit id="a1af358ae94ab7cd9ed6d1b4e51b99fcacedf212" translate="yes" xml:space="preserve">
          <source>Here is an example of a work-flow used by Andreas Ericsson:</source>
          <target state="translated">Вот пример рабочего процесса,используемого Андреасом Эрикссоном:</target>
        </trans-unit>
        <trans-unit id="186fb29b724fc88890a2b738e2f88d967cca2e57" translate="yes" xml:space="preserve">
          <source>Here is an example script that comes slightly modified from a real world script used by Junio Hamano &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt;.</source>
          <target state="translated">Вот пример сценария, который немного изменен по сравнению с реальным сценарием, используемым Джунио Хамано &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea2d28e72cba49a8087ea617856210e85cc4631a" translate="yes" xml:space="preserve">
          <source>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.</source>
          <target state="translated">Вот иллюстрация Джона Лоэлигера.Оба узла коммита B и C являются родителями узла коммита A.Родительские коммиты заказываются слева направо.</target>
        </trans-unit>
        <trans-unit id="01a0e7181fc0932a87393a13bfb324333ce2de29" translate="yes" xml:space="preserve">
          <source>Here is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic branch from the latter branch, using &lt;code&gt;rebase --onto&lt;/code&gt;.</source>
          <target state="translated">Вот как можно трансплантировать тематическую ветку, основанную на одной ветке, в другую, чтобы сделать вид, что вы разделили тематическую ветку из последней, используя &lt;code&gt;rebase --onto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="213d54b0bbf3a7f7afa040a26967e9f565627a3c" translate="yes" xml:space="preserve">
          <source>Here is what Ingo Molnar says about that &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt;:</source>
          <target state="translated">Вот что об этом говорит Инго Мольнар &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0ace4715fac22315364196a248067a261a46ae73" translate="yes" xml:space="preserve">
          <source>Here usually &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;040000`&lt;/code&gt; then &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be the full 40-byte SHA-1 of an existing Git tree object or a mark reference set with &lt;code&gt;--import-marks&lt;/code&gt;.</source>
          <target state="translated">Здесь обычно &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; должен быть либо ссылкой на метку ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ), установленной предыдущей командой &lt;code&gt;blob&lt;/code&gt; , либо полным 40-байтовым SHA-1 существующего объекта blob Git. Если &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; равно &lt;code&gt;040000`&lt;/code&gt; , то &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; должен быть полным 40-байтовым SHA-1 существующего объекта дерева Git или ссылочной меткой, установленной с помощью &lt;code&gt;--import-marks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2beb401ec57f79ec07666eedc396bc9251ab532b" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;code&gt;test.sh&lt;/code&gt; custom script. In this script, if &lt;code&gt;make&lt;/code&gt; fails, we skip the current commit. &lt;code&gt;check_test_case.sh&lt;/code&gt; should &lt;code&gt;exit 0&lt;/code&gt; if the test case passes, and &lt;code&gt;exit 1&lt;/code&gt; otherwise.</source>
          <target state="translated">Здесь мы используем собственный скрипт &lt;code&gt;test.sh&lt;/code&gt; .В этом скрипте, если &lt;code&gt;make&lt;/code&gt; не работает, мы пропускаем текущую фиксацию. &lt;code&gt;check_test_case.sh&lt;/code&gt; должен &lt;code&gt;exit 0&lt;/code&gt; если тестовый пример пройден , и &lt;code&gt;exit 1&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="4c65aa59e4c90d1dad65ae558dc71a05ca72658c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example to make it more clear:</source>
          <target state="translated">Вот пример, чтобы прояснить ситуацию:</target>
        </trans-unit>
        <trans-unit id="f876057ef41997694291fae2bce19c94e2c8be27" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where things get tricky and more specific. The pruning feature doesn&amp;rsquo;t actually care about branches, instead it&amp;rsquo;ll prune local &amp;lt;&amp;rarr; remote-references as a function of the refspec of the remote (see &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; and &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; above).</source>
          <target state="translated">Здесь все становится сложнее и конкретнее. Функция сокращения на самом деле не заботится о ветвях, вместо этого она удаляет локальные &amp;lt;&amp;rarr; удаленные ссылки как функцию refspec удаленного (см. &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; и НАСТРОЕННЫЕ ВЕТВИЛИ &lt;a href=&quot;#CRTB&quot;&gt;ДИСТАНЦИОННОГО ОТСЛЕЖИВАНИЯ&lt;/a&gt; выше).</target>
        </trans-unit>
        <trans-unit id="6e909debf7e14a75a50a127741701f06b0380ed1" translate="yes" xml:space="preserve">
          <source>Here, order matters, so the negative patterns are overridden by the positive patterns that appear lower in the file.</source>
          <target state="translated">Здесь важен порядок,поэтому отрицательные паттерны перекрываются положительными паттернами,которые появляются ниже в файле.</target>
        </trans-unit>
        <trans-unit id="e1c70b8a098f60c6e63dbb08701031f93ea135ff" translate="yes" xml:space="preserve">
          <source>Here, take a moment to look at the contents of &lt;code&gt;hello&lt;/code&gt;, and notice how they don&amp;rsquo;t contain the work we just did in &lt;code&gt;mybranch&lt;/code&gt; &amp;mdash; because that work hasn&amp;rsquo;t happened in the &lt;code&gt;master&lt;/code&gt; branch at all. Then do</source>
          <target state="translated">Здесь найдите время, чтобы взглянуть на содержимое &lt;code&gt;hello&lt;/code&gt; и обратите внимание, что оно не содержит той работы, которую мы только что проделали в &lt;code&gt;mybranch&lt;/code&gt; , - потому что этой работы вообще не было в &lt;code&gt;master&lt;/code&gt; ветке. Тогда сделай</target>
        </trans-unit>
        <trans-unit id="04fe7010553ef714229d324da3944b7bef8ef4bf" translate="yes" xml:space="preserve">
          <source>Here, the merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; contribute extra noise, as they did not actually contribute a change to &lt;code&gt;file.txt&lt;/code&gt;. They only merged a topic that was based on an older version of &lt;code&gt;file.txt&lt;/code&gt;. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: manu unrelated merges appear in the &lt;code&gt;--full-history&lt;/code&gt; results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3155f9e3fff9d9745dcec6fcafe4ea22b8525d" translate="yes" xml:space="preserve">
          <source>Here, the merge commits &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are included because they pulled the commits &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; into the base branch, respectively. These merges are the reason the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; do not appear in the default history.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77fbd432531fa44ab380c6d115f43ea2fbe9fc8" translate="yes" xml:space="preserve">
          <source>Here, we just added another line to &lt;code&gt;hello&lt;/code&gt;, and we used a shorthand for doing both &lt;code&gt;git update-index hello&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; by just giving the filename directly to &lt;code&gt;git commit&lt;/code&gt;, with an &lt;code&gt;-i&lt;/code&gt; flag (it tells Git to &lt;code&gt;include&lt;/code&gt; that file in addition to what you have done to the index file so far when making the commit). The &lt;code&gt;-m&lt;/code&gt; flag is to give the commit log message from the command line.</source>
          <target state="translated">Здесь мы просто добавили еще одну строку для &lt;code&gt;hello&lt;/code&gt; и использовали сокращение для выполнения как &lt;code&gt;git update-index hello&lt;/code&gt; ,так и &lt;code&gt;git commit&lt;/code&gt; , просто указав имя файла непосредственно в &lt;code&gt;git commit&lt;/code&gt; с флагом &lt;code&gt;-i&lt;/code&gt; (он сообщает Git &lt;code&gt;include&lt;/code&gt; этот файл в в дополнение к тому, что вы сделали с индексным файлом при фиксации). &lt;code&gt;-m&lt;/code&gt; флаг, чтобы дать сообщение фиксации журнала из командной строки.</target>
        </trans-unit>
        <trans-unit id="c1304382231014b423d405b863d67d13d9195107" translate="yes" xml:space="preserve">
          <source>Here, we see that the commits A and C (marked with &lt;code&gt;-&lt;/code&gt;) can be dropped from your &lt;code&gt;topic&lt;/code&gt; branch when you rebase it on top of &lt;code&gt;origin/master&lt;/code&gt;, while the commit B (marked with &lt;code&gt;+&lt;/code&gt;) still needs to be kept so that it will be sent to be applied to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">Здесь мы видим, что коммиты A и C (отмеченные знаком &lt;code&gt;-&lt;/code&gt; ) могут быть удалены из вашей &lt;code&gt;topic&lt;/code&gt; ветки, когда вы перебазируете их поверх &lt;code&gt;origin/master&lt;/code&gt; , в то время как коммит B (отмеченный знаком &lt;code&gt;+&lt;/code&gt; ) по-прежнему необходимо сохранить, чтобы он будут отправлены для применения к &lt;code&gt;origin/master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cd618d5ab553d5bba621718fb5b54666be9377a" translate="yes" xml:space="preserve">
          <source>High-level commands (porcelain)</source>
          <target state="translated">Команды высокого уровня (фарфор)</target>
        </trans-unit>
        <trans-unit id="1ac4e7d9472a79a55ebc3b6988fb3cc4f954a3f4" translate="yes" xml:space="preserve">
          <source>High-level operations such as &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; work by moving data between the working tree, the index, and the object database. Git provides low-level operations which perform each of these steps individually.</source>
          <target state="translated">Операции высокого уровня, такие как &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; и &lt;a href=&quot;git-restore&quot;&gt;git-restore [1],&lt;/a&gt; работают путем перемещения данных между рабочим деревом, индексом и базой данных объектов. Git предоставляет низкоуровневые операции, которые выполняют каждый из этих шагов индивидуально.</target>
        </trans-unit>
        <trans-unit id="c1ce0c926615015cc35af4d00f9f659a79fd9f67" translate="yes" xml:space="preserve">
          <source>Higher level SCMs may provide and manage additional information in the &lt;code&gt;$GIT_DIR&lt;/code&gt;.</source>
          <target state="translated">SCM более высокого уровня могут предоставлять дополнительную информацию и управлять &lt;code&gt;$GIT_DIR&lt;/code&gt; в $ GIT_DIR .</target>
        </trans-unit>
        <trans-unit id="dd055ea7ea783c3a5765e06b74c033615ebf91a1" translate="yes" xml:space="preserve">
          <source>Highest and slowest compression level. You can specify any number from 1 to 9 to adjust compression speed and ratio.</source>
          <target state="translated">Самый высокий и медленный уровень сжатия.Вы можете указать любое число от 1 до 9 для регулировки скорости и степени сжатия.</target>
        </trans-unit>
        <trans-unit id="dca5de829f06af308665d596314f33baa6a08d8b" translate="yes" xml:space="preserve">
          <source>Highlight changed words using only colors. Implies &lt;code&gt;--color&lt;/code&gt;.</source>
          <target state="translated">Выделите измененные слова, используя только цвета. Подразумевает &lt;code&gt;--color&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d265b329d8480dd12ed84fd1552194f9ed45b640" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;. The command line option &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; overrides this setting.</source>
          <target state="translated">Выделите ошибки пробелов в &lt;code&gt;context&lt;/code&gt; , в &lt;code&gt;old&lt;/code&gt; или &lt;code&gt;new&lt;/code&gt; строках разницы. Несколько значений разделяются запятыми, &lt;code&gt;none&lt;/code&gt; сбрасывает предыдущие значения, по &lt;code&gt;default&lt;/code&gt; сбрасывает список на &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;all&lt;/code&gt; это сокращение для &lt;code&gt;old,new,context&lt;/code&gt; . Ошибки с &lt;code&gt;color.diff.whitespace&lt;/code&gt; выделяются цветом color.diff.whitespace . Параметр командной строки &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; отменяет этот параметр.</target>
        </trans-unit>
        <trans-unit id="ad64982f5f47504010208292cc60b059ddb2341b" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. When this option is not given, and the configuration variable &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; is not set, only whitespace errors in &lt;code&gt;new&lt;/code&gt; lines are highlighted. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;.</source>
          <target state="translated">Выделите ошибки пробелов в &lt;code&gt;context&lt;/code&gt; , в &lt;code&gt;old&lt;/code&gt; или &lt;code&gt;new&lt;/code&gt; строках разницы. Несколько значений разделяются запятыми, &lt;code&gt;none&lt;/code&gt; сбрасывает предыдущие значения, по &lt;code&gt;default&lt;/code&gt; сбрасывает список на &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;all&lt;/code&gt; это сокращение для &lt;code&gt;old,new,context&lt;/code&gt; . Если этот параметр не указан и переменная конфигурации &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; не задана, выделяются только ошибки пробелов в &lt;code&gt;new&lt;/code&gt; строках. Ошибки с &lt;code&gt;color.diff.whitespace&lt;/code&gt; выделяются цветом color.diff.whitespace .</target>
        </trans-unit>
        <trans-unit id="dd523af5eca7a4658a007786700bef0bcb653aea" translate="yes" xml:space="preserve">
          <source>Historical options for selecting a type specifier. Prefer instead &lt;code&gt;--type&lt;/code&gt; (see above).</source>
          <target state="translated">Исторические варианты выбора спецификатора типа. Вместо этого &lt;code&gt;--type&lt;/code&gt; (см. Выше).</target>
        </trans-unit>
        <trans-unit id="d2946930a6bea40f3723a867347d5f13a7e8b511" translate="yes" xml:space="preserve">
          <source>Historically we did not allow binary patch applied without an explicit permission from the user, and this flag was the way to do so. Currently we always allow binary patch application, so this is a no-op.</source>
          <target state="translated">Исторически сложилось так,что мы не позволяли применять бинарный патч без явного разрешения пользователя,и этот флаг был способом сделать это.В настоящее время мы всегда разрешаем применение бинарных заплаток,так что это не является обязательным.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="7f2999a0b05d570915b660b4e452265d6ec70628" translate="yes" xml:space="preserve">
          <source>History Simplification</source>
          <target state="translated">Упрощение истории</target>
        </trans-unit>
        <trans-unit id="bcdd29839bed9103f5dae5291b4dd975d75a9cc7" translate="yes" xml:space="preserve">
          <source>History traversing commands such as &lt;code&gt;git log&lt;/code&gt; operate on a set of commits, not just a single commit.</source>
          <target state="translated">Команды просмотра истории, такие как &lt;code&gt;git log&lt;/code&gt; , работают с набором коммитов, а не с одним коммитом.</target>
        </trans-unit>
        <trans-unit id="173bd843bbaf623a85e5a648a6a9c500533027fc" translate="yes" xml:space="preserve">
          <source>Honor textconv filter settings.</source>
          <target state="translated">Настройки фильтра распознавания текста.</target>
        </trans-unit>
        <trans-unit id="be308a87ab32a83ddd6a199c65b0dc7cb4884727" translate="yes" xml:space="preserve">
          <source>Hook for submit</source>
          <target state="translated">Крючок для отправки</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="99dc1a330d0acc7fd52ca441a6ce9f9284dba47c" translate="yes" xml:space="preserve">
          <source>Hooks are customization scripts used by various Git commands. A handful of sample hooks are installed when &lt;code&gt;git init&lt;/code&gt; is run, but all of them are disabled by default. To enable, the &lt;code&gt;.sample&lt;/code&gt; suffix has to be removed from the filename by renaming. Read &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more details about each hook. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/hooks&quot; will be used instead.</source>
          <target state="translated">Хуки - это сценарии настройки, используемые различными командами Git. При запуске &lt;code&gt;git init&lt;/code&gt; устанавливается несколько примеров ловушек , но все они по умолчанию отключены. Для включения суффикс &lt;code&gt;.sample&lt;/code&gt; необходимо удалить из имени файла путем переименования. Прочтите &lt;a href=&quot;githooks&quot;&gt;githooks [5],&lt;/a&gt; чтобы узнать больше о каждом хуке. Этот каталог игнорируется, если установлен $ GIT_COMMON_DIR и вместо него будет использоваться &quot;$ GIT_COMMON_DIR / hooks&quot;.</target>
        </trans-unit>
        <trans-unit id="06a3036cbe5b8e0ded4c91cf35d4acf2e8ad8f53" translate="yes" xml:space="preserve">
          <source>Hooks are programs you can place in a hooks directory to trigger actions at certain points in git&amp;rsquo;s execution. Hooks that don&amp;rsquo;t have the executable bit set are ignored.</source>
          <target state="translated">Хуки - это программы, которые вы можете поместить в каталог хуков для запуска действий в определенные моменты выполнения git. Хуки, для которых не установлен исполняемый бит, игнорируются.</target>
        </trans-unit>
        <trans-unit id="bf9a913e0a40d8bcbb788ae480caabb75549e706" translate="yes" xml:space="preserve">
          <source>Hooks can get their arguments via the environment, command-line arguments, and stdin. See the documentation for each hook below for details.</source>
          <target state="translated">Hooks могут получать свои аргументы через среду,аргументы командной строки и stdin.Подробности смотрите в документации по каждому перехватчику ниже.</target>
        </trans-unit>
        <trans-unit id="ada52d2258e33812dc48261a96d9e1bee90a02e9" translate="yes" xml:space="preserve">
          <source>Hooks for submit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b25ef249acb89a2076c9e4eabf85c1464e0ce20" translate="yes" xml:space="preserve">
          <source>Hooks used by Git</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c7452920ac3fe30578ebea0bb92b7bf8bbfaa1" translate="yes" xml:space="preserve">
          <source>Host specified as an option to all p4 commands, with &lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4HOST&lt;/code&gt; can be used instead.</source>
          <target state="translated">Хост, указанный в качестве опции для всех команд p4, с &lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt; . &lt;code&gt;P4HOST&lt;/code&gt; можно использовать переменную окружения P4HOST .</target>
        </trans-unit>
        <trans-unit id="e3a4f74d3860a1e7164c5016083b909a49e9f48e" translate="yes" xml:space="preserve">
          <source>Host/domain name (e.g., &lt;code&gt;example.com&lt;/code&gt; in &lt;code&gt;https://example.com/&lt;/code&gt;). This field must match between the config key and the URL. It is possible to specify a &lt;code&gt;*&lt;/code&gt; as part of the host name to match all subdomains at this level. &lt;code&gt;https://*.example.com/&lt;/code&gt; for example would match &lt;code&gt;https://foo.example.com/&lt;/code&gt;, but not &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt;.</source>
          <target state="translated">Имя хоста / домена (например, &lt;code&gt;example.com&lt;/code&gt; в &lt;code&gt;https://example.com/&lt;/code&gt; ). Это поле должно совпадать между ключом конфигурации и URL-адресом. Можно указать &lt;code&gt;*&lt;/code&gt; как часть имени хоста, чтобы соответствовать всем поддоменам на этом уровне. Например, &lt;code&gt;https://*.example.com/&lt;/code&gt; будет соответствовать &lt;code&gt;https://foo.example.com/&lt;/code&gt; , но не &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62bb4be23aa04882a53a58830164455da0d43aac" translate="yes" xml:space="preserve">
          <source>How Git stores objects efficiently: pack files</source>
          <target state="translated">Как Git эффективно хранит объекты:упаковывать файлы</target>
        </trans-unit>
        <trans-unit id="fc3082d534384228eeed70dd2356631d4f563e7e" translate="yes" xml:space="preserve">
          <source>How conflicts are presented</source>
          <target state="translated">Как представлены конфликты</target>
        </trans-unit>
        <trans-unit id="632a7344e68629673f46b61122a8d717f4af38d1" translate="yes" xml:space="preserve">
          <source>How does the merge work?</source>
          <target state="translated">Как работает слияние?</target>
        </trans-unit>
        <trans-unit id="ee0a93def9e459d81d86f0f444af48fed200edd7" translate="yes" xml:space="preserve">
          <source>How many HTTP requests to launch in parallel. Can be overridden by the &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; environment variable. Default is 5.</source>
          <target state="translated">Сколько HTTP-запросов запускать параллельно. Может быть переопределено переменной среды &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; . По умолчанию 5.</target>
        </trans-unit>
        <trans-unit id="88ba6c6b51f5b68d7988ac607f3c426807b883bb" translate="yes" xml:space="preserve">
          <source>How to best handle custom GIT_TRACE_&amp;lt;key&amp;gt; messages?</source>
          <target state="translated">Как лучше всего обрабатывать пользовательские сообщения GIT_TRACE_ &amp;lt;key&amp;gt;?</target>
        </trans-unit>
        <trans-unit id="e6e1af910bb5a856e3b4ead0799265f2a1064f75" translate="yes" xml:space="preserve">
          <source>How to check out a different version of a project</source>
          <target state="translated">Как проверить другую версию проекта</target>
        </trans-unit>
        <trans-unit id="d2b9978a0ab6bcc1a292a13931b1286539811f55" translate="yes" xml:space="preserve">
          <source>How to get a Git repository</source>
          <target state="translated">Как получить Git-репозиторий</target>
        </trans-unit>
        <trans-unit id="d7d2ba06f3721900039efaca56489e6a84b511d3" translate="yes" xml:space="preserve">
          <source>How to get a Git repository with minimal history</source>
          <target state="translated">Как получить Git-репозиторий с минимальной историей.</target>
        </trans-unit>
        <trans-unit id="d757cda7bc3ea5053c7cf45f6afca8dbb51305c3" translate="yes" xml:space="preserve">
          <source>How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes). With drop (the default), commits that become empty are dropped. With keep, such commits are kept. With ask (implied by --interactive), the rebase will halt when an empty commit is applied allowing you to choose whether to drop it, edit files more, or just commit the empty changes. Other options, like --exec, will use the default of drop unless -i/--interactive is explicitly specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a7eba29926bb4a386242f44bbf4f12c6f691a0c" translate="yes" xml:space="preserve">
          <source>How to make a commit</source>
          <target state="translated">Как совершить обязательство</target>
        </trans-unit>
        <trans-unit id="a8f8fd0d0e36d30f7fbe331a10b1e8f318a5f903" translate="yes" xml:space="preserve">
          <source>How to merge</source>
          <target state="translated">Как слиться</target>
        </trans-unit>
        <trans-unit id="813e8d48c24190b471043b3ab0d44e357c5f2791" translate="yes" xml:space="preserve">
          <source>How to resolve conflicts</source>
          <target state="translated">Как разрешать конфликты</target>
        </trans-unit>
        <trans-unit id="93e750cda509aa41796eb9d7a6cb3afbf2365356" translate="yes" xml:space="preserve">
          <source>How to use bisect to find a regression</source>
          <target state="translated">Как использовать бисект для поиска регрессии</target>
        </trans-unit>
        <trans-unit id="c54b4ab81b97a7d870be1fb485f52b39766adb14" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; it&amp;rsquo;s such a common thing to &lt;code&gt;fetch&lt;/code&gt; and then immediately &lt;code&gt;merge&lt;/code&gt;, that it&amp;rsquo;s called &lt;code&gt;git pull&lt;/code&gt;, and you can simply do</source>
          <target state="translated">Однако - это такая обычная вещь, чтобы &lt;code&gt;fetch&lt;/code&gt; а затем немедленно &lt;code&gt;merge&lt;/code&gt; , что это называется &lt;code&gt;git pull&lt;/code&gt; , и вы можете просто сделать</target>
        </trans-unit>
        <trans-unit id="d70de578cd37f18e0cd1ccdb7488c789f08117d4" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; normally you&amp;rsquo;d never use &lt;code&gt;git write-tree&lt;/code&gt; on its own, because normally you always commit a tree into a commit object using the &lt;code&gt;git commit-tree&lt;/code&gt; command. In fact, it&amp;rsquo;s easier to not actually use &lt;code&gt;git write-tree&lt;/code&gt; on its own at all, but to just pass its result in as an argument to &lt;code&gt;git commit-tree&lt;/code&gt;.</source>
          <target state="translated">Однако - обычно вы никогда не будете использовать &lt;code&gt;git write-tree&lt;/code&gt; отдельно, потому что обычно вы всегда фиксируете дерево в объект фиксации с помощью команды &lt;code&gt;git commit-tree&lt;/code&gt; . На самом деле, проще вообще не использовать &lt;code&gt;git write-tree&lt;/code&gt; отдельно, а просто передать его результат в качестве аргумента &lt;code&gt;git commit-tree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b251a49d303741aee81dcafea3be641705e5d2d3" translate="yes" xml:space="preserve">
          <source>However repacking the repository is necessary to improve data locality and access performance. It can also take hours on extremely large projects (especially if -f and a large --window parameter is used). Since repacking is safe to run alongside readers and writers, run the repack in the background and let it finish when it finishes. There is no reason to wait to explore your new Git project!</source>
          <target state="translated">Однако переупаковка репозитория необходима для улучшения локализации данных и повышения производительности доступа.Это также может занять несколько часов на очень больших проектах (особенно если используется параметр -f и большое --window).Так как переупаковка безопасна для запуска вместе с читателями и пишущими устройствами,запустите переупаковку в фоновом режиме и дайте ей закончиться по окончании.Не стоит ждать,когда же начнётся работа над новым Git-проектом!</target>
        </trans-unit>
        <trans-unit id="4b948e81d3b66aa74b95ff1de52609dbf8f7d04b" translate="yes" xml:space="preserve">
          <source>However, Git does &lt;strong&gt;not&lt;/strong&gt; (and it should not) change tags behind users back. So if somebody already got the old tag, doing a &lt;code&gt;git pull&lt;/code&gt; on your tree shouldn&amp;rsquo;t just make them overwrite the old one.</source>
          <target state="translated">Однако, Git делает &lt;strong&gt;не&lt;/strong&gt; (и не должны) изменить метки позади пользователей назад. Так что, если кто-то уже получил старый тег, выполнение &lt;code&gt;git pull&lt;/code&gt; на вашем дереве не должно просто заставить его перезаписать старый.</target>
        </trans-unit>
        <trans-unit id="774132ee5dd559ea340879a21fd99f6ff4549c5d" translate="yes" xml:space="preserve">
          <source>However, an understanding of these low-level tools can be helpful if you want to understand Git&amp;rsquo;s internals.</source>
          <target state="translated">Однако понимание этих низкоуровневых инструментов может быть полезно, если вы хотите разобраться во внутреннем устройстве Git.</target>
        </trans-unit>
        <trans-unit id="866f600e87142f901a49d55ea62ea322295c395d" translate="yes" xml:space="preserve">
          <source>However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file you get a N+1 line from-file/to-file header, where N is the number of parents in the merge commit</source>
          <target state="translated">Однако,если предусмотрена опция --combined-all-paths,то вместо двухстрочного From-file/to-file вы получите N+1 строку из заголовка From-file/to-file,где N-число родителей в коммите слияния</target>
        </trans-unit>
        <trans-unit id="24c47b91e42f0b5da2ef1b1de98db109a45643ab" translate="yes" xml:space="preserve">
          <source>However, if the current branch is an ancestor of the other&amp;mdash;​so every commit present in the current branch is already contained in the other branch&amp;mdash;​then Git just performs a &quot;fast-forward&quot;; the head of the current branch is moved forward to point at the head of the merged-in branch, without any new commits being created.</source>
          <target state="translated">Однако, если текущая ветвь является предком другой - так что каждая фиксация, присутствующая в текущей ветке, уже содержится в другой ветке - тогда Git просто выполняет &amp;laquo;быструю перемотку вперед&amp;raquo;; заголовок текущей ветки перемещается вперед, чтобы указать на заголовок объединенной ветки, без создания каких-либо новых коммитов.</target>
        </trans-unit>
        <trans-unit id="38320aec0b4074b6ba1fc6f9446c9d65a3296509" translate="yes" xml:space="preserve">
          <source>However, if the file is absent from the tree of some commit, a simple &lt;code&gt;rm filename&lt;/code&gt; will fail for that tree and commit. Thus you may instead want to use &lt;code&gt;rm -f filename&lt;/code&gt; as the script.</source>
          <target state="translated">Однако, если файл отсутствует в дереве некоторого коммита, простое &lt;code&gt;rm filename&lt;/code&gt; не удастся для этого дерева и выполнит коммит. Таким образом, вы можете вместо этого использовать в качестве сценария &lt;code&gt;rm -f filename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="083d51e29026b4e1a08bfd658353fe31999e3907" translate="yes" xml:space="preserve">
          <source>However, if you decide to jump to a new version, or check out somebody else&amp;rsquo;s version, or just restore a previous tree, you&amp;rsquo;d populate your index file with read-tree, and then you need to check out the result with</source>
          <target state="translated">Однако, если вы решите перейти к новой версии, или проверить чью-то версию, или просто восстановить предыдущее дерево, вы заполните свой индексный файл деревом чтения, а затем вам нужно будет проверить результат с помощью</target>
        </trans-unit>
        <trans-unit id="d73cbcd65f07eabb528955f0d408caeaef9ec132" translate="yes" xml:space="preserve">
          <source>However, if you have local changes in the working tree that would be overwritten by this merge, &lt;code&gt;git read-tree&lt;/code&gt; will refuse to run to prevent your changes from being lost.</source>
          <target state="translated">Однако, если у вас есть локальные изменения в рабочем дереве, которые могут быть перезаписаны этим слиянием, &lt;code&gt;git read-tree&lt;/code&gt; откажется запускаться, чтобы предотвратить потерю ваших изменений.</target>
        </trans-unit>
        <trans-unit id="0f801baa64ce652ffc6d36336f6a234c862e64a0" translate="yes" xml:space="preserve">
          <source>However, if you prefer to keep the history in mywork a simple series of commits without any merges, you may instead choose to use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;:</source>
          <target state="translated">Однако, если вы предпочитаете, чтобы история в моей работе была простой серией коммитов без каких-либо слияний, вы можете вместо этого использовать &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6a9f204773ec4f6bc12691a9ec080236d437d186" translate="yes" xml:space="preserve">
          <source>However, if you really only want to replace the line for the default proxy, i.e. the one without a &quot;for &amp;hellip;​&quot; postfix, do something like this:</source>
          <target state="translated">Однако, если вы действительно хотите заменить строку только для прокси по умолчанию, то есть без постфикса &amp;laquo;for&amp;hellip;&amp;raquo;, сделайте что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="fe54b4a5cce25da95a527e803024815678af4c5c" translate="yes" xml:space="preserve">
          <source>However, if you skip a commit adjacent to the one you are looking for, Git will be unable to tell exactly which of those commits was the first bad one.</source>
          <target state="translated">Однако,если вы пропустите коммит,находящийся рядом с тем,который вы ищете,Git не сможет точно сказать,какой из этих коммитов был первым плохим.</target>
        </trans-unit>
        <trans-unit id="e9adef201cc69834664c04ac9c044e6acc3b8daa" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to create branches in p4 to be able to use them like branches. Because it is difficult to infer branch relationships automatically, a Git configuration setting &lt;code&gt;git-p4.branchList&lt;/code&gt; can be used to explicitly identify branch relationships. It is a list of &quot;source:destination&quot; pairs, like a simple p4 branch specification, where the &quot;source&quot; and &quot;destination&quot; are the path elements in the p4 repository. The example above relied on the presence of the p4 branch. Without p4 branches, the same result will occur with:</source>
          <target state="translated">Однако нет необходимости создавать ветки в p4, чтобы использовать их как ветки. Поскольку сложно определить отношения ветвей автоматически, параметр конфигурации Git &lt;code&gt;git-p4.branchList&lt;/code&gt; можно использовать для явного определения взаимосвязей ветвей. Это список пар &amp;laquo;источник: место назначения&amp;raquo;, как в простой спецификации ветки p4, где &amp;laquo;источник&amp;raquo; и &amp;laquo;место назначения&amp;raquo; являются элементами пути в репозитории p4. В приведенном выше примере используется ветка p4. Без веток p4 тот же результат будет с:</target>
        </trans-unit>
        <trans-unit id="c71bf4b100c16d667a048d4524ffef40edf8598e" translate="yes" xml:space="preserve">
          <source>However, one may also want to specify other diff driver attributes. For example, you might want to use &lt;code&gt;textconv&lt;/code&gt; to convert postscript files to an ASCII representation for human viewing, but otherwise treat them as binary files. You cannot specify both &lt;code&gt;-diff&lt;/code&gt; and &lt;code&gt;diff=ps&lt;/code&gt; attributes. The solution is to use the &lt;code&gt;diff.*.binary&lt;/code&gt; config option:</source>
          <target state="translated">Однако можно также указать другие атрибуты драйвера diff. Например, вы можете захотеть использовать &lt;code&gt;textconv&lt;/code&gt; для преобразования файлов postscript в представление ASCII для просмотра человеком, но в противном случае рассматривать их как двоичные файлы. Нельзя указывать одновременно &lt;code&gt;-diff&lt;/code&gt; и &lt;code&gt;diff=ps&lt;/code&gt; . Решение заключается в использовании опции конфигурации &lt;code&gt;diff.*.binary&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c15b1eea7ada51b9540f36c6d7433749c2518719" translate="yes" xml:space="preserve">
          <source>However, our next step is to commit the &lt;strong&gt;change&lt;/strong&gt; we did, and again, to understand what&amp;rsquo;s going on, keep in mind the difference between &quot;working tree contents&quot;, &quot;index file&quot; and &quot;committed tree&quot;. We have changes in the working tree that we want to commit, and we always have to work through the index file, so the first thing we need to do is to update the index cache:</source>
          <target state="translated">Однако наш следующий шаг - зафиксировать &lt;strong&gt;внесенное&lt;/strong&gt; нами &lt;strong&gt;изменение&lt;/strong&gt; , и снова, чтобы понять, что происходит, помните о разнице между &amp;laquo;содержимым рабочего дерева&amp;raquo;, &amp;laquo;индексным файлом&amp;raquo; и &amp;laquo;зафиксированным деревом&amp;raquo;. У нас есть изменения в рабочем дереве, которые мы хотим зафиксировать, и мы всегда должны работать с индексным файлом, поэтому первое, что нам нужно сделать, это обновить кеш индекса:</target>
        </trans-unit>
        <trans-unit id="066e262ce5d073a40098065a4bfe593a37b357ee" translate="yes" xml:space="preserve">
          <source>However, since Git knows about them, you can now start using some of the most basic Git commands to manipulate the files or look at their status.</source>
          <target state="translated">Однако,поскольку Git знает о них,вы можете начать использовать самые базовые команды Git'а для манипулирования файлами или просмотра их состояния.</target>
        </trans-unit>
        <trans-unit id="2d4b86f86d3381add9d6753c2a6a37207cb69976" translate="yes" xml:space="preserve">
          <source>However, the &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; command provides a way to do this in one step:</source>
          <target state="translated">Однако команда &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; позволяет сделать это за один шаг:</target>
        </trans-unit>
        <trans-unit id="b2062c8611299450fbfa8b88f93e46840eed9772" translate="yes" xml:space="preserve">
          <source>However, the commits do not form a simple list; Git allows lines of development to diverge and then reconverge, and the point where two lines of development reconverge is called a &quot;merge&quot;. The commit representing a merge can therefore have more than one parent, with each parent representing the most recent commit on one of the lines of development leading to that point.</source>
          <target state="translated">Однако коммиты не образуют простого списка;Git позволяет линиям развития расходиться,а затем пересобираться,а точка,в которой две линии развития пересобираются,называется &quot;слиянием&quot;.Таким образом,коммит,представляющий собой слияние,может иметь более одного родителя,причём каждый родитель представляет собой самую последнюю коммиссию на одной из линий разработки,ведущую к этой точке.</target>
        </trans-unit>
        <trans-unit id="dc3c84ebe58db76ac38c1e3a6d7daded7c305410" translate="yes" xml:space="preserve">
          <source>However, the more common way to do this is to maintain a separate public repository (usually on a different host) for others to pull changes from. This is usually more convenient, and allows you to cleanly separate private work in progress from publicly visible work.</source>
          <target state="translated">Однако,более распространенный способ сделать это-поддерживать отдельный публичный репозиторий (обычно на другом хосте),из которого другие могут извлекать изменения.Это обычно более удобно,и позволяет чисто отделить текущую личную работу от общедоступной.</target>
        </trans-unit>
        <trans-unit id="755c039a0c20727e4839caf6deef253d613f16de" translate="yes" xml:space="preserve">
          <source>However, there are cases in which your local changes do conflict with the upstream changes, and &lt;code&gt;git pull&lt;/code&gt; refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:</source>
          <target state="translated">Однако бывают случаи, когда ваши локальные изменения действительно конфликтуют с изменениями восходящего потока, и &lt;code&gt;git pull&lt;/code&gt; отказывается перезаписывать ваши изменения. В таком случае вы можете спрятать свои изменения, выполнить извлечение, а затем разблокировать, например:</target>
        </trans-unit>
        <trans-unit id="e43d419a26518c38e69ee02a5a541b221da6c649" translate="yes" xml:space="preserve">
          <source>However, there are legitimate reasons why a developer may want to recreate merge commits: to keep the branch structure (or &quot;commit topology&quot;) when working on multiple, inter-related branches.</source>
          <target state="translated">Тем не менее,существуют законные причины,по которым разработчик может захотеть воссоздать коммиты слияния:сохранить структуру ветки (или &quot;топологию коммита&quot;)при работе с несколькими,взаимосвязанными ветвями.</target>
        </trans-unit>
        <trans-unit id="89adb927099ba4a8289673a41ab8ec24ea6e4abd" translate="yes" xml:space="preserve">
          <source>However, there is a situation in which it can be useful to violate this assumption.</source>
          <target state="translated">Однако есть ситуация,в которой нарушение этого предположения может быть полезным.</target>
        </trans-unit>
        <trans-unit id="b068287d80433091fc93a07d4af49d57d3676c5d" translate="yes" xml:space="preserve">
          <source>However, there is no particular reason to merge in one branch first and the other next, when what you have are a set of truly independent changes (if the order mattered, then they are not independent by definition). You could instead merge those two branches into the current branch at once. First let&amp;rsquo;s undo what we just did and start over. We would want to get the master branch before these two merges by resetting it to &lt;code&gt;master~2&lt;/code&gt;:</source>
          <target state="translated">Однако нет особой причины для слияния в первую очередь в одной ветке, а в другой - в следующей, когда у вас есть набор действительно независимых изменений (если порядок имеет значение, то они не являются независимыми по определению). Вместо этого вы можете сразу объединить эти две ветки в текущую. Сначала давайте отменим то, что мы только что сделали, и начнем заново. Мы бы хотели получить основную ветку до этих двух слияний, установив ее на &lt;code&gt;master~2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="76dbad7bbd23560fcc8351e42a22aad055901cd6" translate="yes" xml:space="preserve">
          <source>However, these features fall short of a complete solution, so users who run commands concurrently have to live with some risk of corruption (which seems to be low in practice).</source>
          <target state="translated">Однако эти функции не являются полным решением,поэтому пользователям,выполняющим команды одновременно,приходится жить с некоторым риском повреждения (который на практике кажется низким).</target>
        </trans-unit>
        <trans-unit id="f41fcda082e8874086be41192b1abbea2d3295da" translate="yes" xml:space="preserve">
          <source>However, this is &lt;strong&gt;NOT&lt;/strong&gt; allowed for switches with an optional value, where the &lt;code&gt;stuck&lt;/code&gt; form must be used:</source>
          <target state="translated">Однако это &lt;strong&gt;НЕ&lt;/strong&gt; допускается для переключателей с необязательным значением, где должна использоваться &lt;code&gt;stuck&lt;/code&gt; форма:</target>
        </trans-unit>
        <trans-unit id="4da9d9ef7c6a0e88df4192c01891a87d88664b48" translate="yes" xml:space="preserve">
          <source>However, this is only a convention, and you can name your branches anything you want, and don&amp;rsquo;t have to ever even &lt;code&gt;have&lt;/code&gt; a &lt;code&gt;master&lt;/code&gt; branch. A number of the Git tools will assume that &lt;code&gt;.git/HEAD&lt;/code&gt; is valid, though.</source>
          <target state="translated">Однако, это лишь условность, и вы можете назвать ветви все , что вы хотите, и не должны когда - либо даже &lt;code&gt;have&lt;/code&gt; в &lt;code&gt;master&lt;/code&gt; ветку. Однако некоторые инструменты Git предполагают, что &lt;code&gt;.git/HEAD&lt;/code&gt; действителен.</target>
        </trans-unit>
        <trans-unit id="a7abfde622702125ddcfca8f6b53cf2f29202a6d" translate="yes" xml:space="preserve">
          <source>However, this last command can be dangerous in some cases&amp;mdash;​never throw away a commit you have already committed if that commit may itself have been merged into another branch, as doing so may confuse further merges.</source>
          <target state="translated">Однако эта последняя команда может быть опасной в некоторых случаях - никогда не выбрасывайте коммит, который вы уже совершили, если этот коммит сам мог быть объединен с другой веткой, так как это может запутать дальнейшие слияния.</target>
        </trans-unit>
        <trans-unit id="ba574b0c600bcf4947d9fc0b827ea5d5666b3028" translate="yes" xml:space="preserve">
          <source>However, when no confusion will result, we often just use the term &quot;branch&quot; both for branches and for branch heads.</source>
          <target state="translated">Однако,когда путаницы не возникает,мы часто просто используем термин &quot;ветка&quot; как для ветвей,так и для головок ветвей.</target>
        </trans-unit>
        <trans-unit id="2952d19c4dc617ab4a4ae6abe65c729f11b54f82" translate="yes" xml:space="preserve">
          <source>However, when you do &lt;code&gt;git read-tree&lt;/code&gt; with three trees, the &quot;stage&quot; starts out at 1.</source>
          <target state="translated">Однако, когда вы выполняете &lt;code&gt;git read-tree&lt;/code&gt; с тремя деревьями, &amp;laquo;этап&amp;raquo; начинается с 1.</target>
        </trans-unit>
        <trans-unit id="28dd1f9126b301b96d86409d92ae4b0d38938148" translate="yes" xml:space="preserve">
          <source>However, while there is nothing wrong with Git&amp;rsquo;s support for shared repositories, this mode of operation is not generally recommended, simply because the mode of collaboration that Git supports&amp;mdash;​by exchanging patches and pulling from public repositories&amp;mdash;​has so many advantages over the central shared repository:</source>
          <target state="translated">Однако, хотя в поддержке Git общих репозиториев нет ничего плохого, этот режим работы обычно не рекомендуется просто потому, что режим сотрудничества, который поддерживает Git - путем обмена исправлениями и извлечения из общедоступных репозиториев - имеет множество преимуществ перед центральный общий репозиторий:</target>
        </trans-unit>
        <trans-unit id="6ee73f3ad469e31cc982a856f9ec909f123f7a3b" translate="yes" xml:space="preserve">
          <source>However, you already dirtied the index (i.e. your index does not match the &lt;code&gt;HEAD&lt;/code&gt; commit). But you know the pull you are going to make does not affect &lt;code&gt;frotz.c&lt;/code&gt; or &lt;code&gt;filfre.c&lt;/code&gt;, so you revert the index changes for these two files. Your changes in working tree remain there.</source>
          <target state="translated">Однако вы уже испачкали индекс (т.е. ваш индекс не соответствует фиксации &lt;code&gt;HEAD&lt;/code&gt; ). Но вы знаете, что вытягивание, которое вы собираетесь сделать, не влияет на &lt;code&gt;frotz.c&lt;/code&gt; или &lt;code&gt;filfre.c&lt;/code&gt; , поэтому вы отменяете изменения индекса для этих двух файлов. Ваши изменения в рабочем дереве останутся там.</target>
        </trans-unit>
        <trans-unit id="9e2e4a0fcb3942d8a82c6a2331932351c7c8a259" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &quot;mytopic&quot; branch may differ in files that you have modified locally, in which case the above switch would fail like this:</source>
          <target state="translated">Однако,ваша &quot;неправильная&quot; ветка и правильная ветка &quot;митотика&quot; могут отличаться в файлах,которые вы изменили локально,и в этом случае указанный выше переключатель будет работать неправильно:</target>
        </trans-unit>
        <trans-unit id="6a9281c350a487a356b48bdfa67abfef81982489" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &lt;code&gt;mytopic&lt;/code&gt; branch may differ in files that you have modified locally, in which case the above checkout would fail like this:</source>
          <target state="translated">Однако ваша &amp;laquo;неправильная&amp;raquo; ветвь и правильная ветвь &lt;code&gt;mytopic&lt;/code&gt; могут отличаться в файлах, которые вы изменили локально, и в этом случае вышеупомянутая проверка завершится ошибкой следующим образом:</target>
        </trans-unit>
        <trans-unit id="eaf133288702a5baf1a98928a127236dfad5386f" translate="yes" xml:space="preserve">
          <source>I most actively use it during the merge window (when a lot of trees get merged upstream and when the influx of bugs is the highest) - and yes, there have been cases that i used it multiple times a day. My average is roughly once a day.</source>
          <target state="translated">Я наиболее активно использую его во время окна слияния (когда много деревьев сливаются вверх по течению и когда приток багов самый высокий)-и да,бывали случаи,когда я использовал его несколько раз в день.В среднем я использую его примерно раз в день.</target>
        </trans-unit>
        <trans-unit id="27777a39e933776b5c584d121830042fbc955f15" translate="yes" xml:space="preserve">
          <source>I.e. a fast-forward of commits and tags outside &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; is allowed, even in cases where what&amp;rsquo;s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it&amp;rsquo;s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to.</source>
          <target state="translated">Т.е. ускоренная перемотка вперед коммитов и тегов за пределами &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; разрешена, даже в тех случаях, когда то, что пересылается быстро, не является фиксацией, а является объектом тега, который указывает на новую фиксацию, которая является ускоренная перемотка фиксации последнего тега (или фиксации), которую он заменяет. Также допускается замена тега на совершенно другой тег, если он указывает на ту же фиксацию, а также нажатие очищенного тега, то есть нажатие фиксации, на которую указывает существующий объект тега, или нового объекта тега, на который указывает существующая фиксация ,</target>
        </trans-unit>
        <trans-unit id="f6dcea8e2840d6db982f7ea79204e026c88b3ea6" translate="yes" xml:space="preserve">
          <source>I.e. create a &lt;code&gt;base&lt;/code&gt; tag for versions of the upstream code that you&amp;rsquo;ve seen and are willing to overwrite, then rewrite history, and finally force push changes to &lt;code&gt;master&lt;/code&gt; if the remote version is still at &lt;code&gt;base&lt;/code&gt;, regardless of what your local &lt;code&gt;remotes/origin/master&lt;/code&gt; has been updated to in the background.</source>
          <target state="translated">Т.е. создайте &lt;code&gt;base&lt;/code&gt; тег для версий восходящего кода, которые вы видели и хотите перезаписать, затем переписать историю и, наконец, принудительно передать изменения в &lt;code&gt;master&lt;/code&gt; если удаленная версия все еще находится в &lt;code&gt;base&lt;/code&gt; , независимо от того, какие у вас локальные &lt;code&gt;remotes/origin/master&lt;/code&gt; был обновлен в фоновом режиме.</target>
        </trans-unit>
        <trans-unit id="d160035a43dfa655c4a6e47190220d072175392c" translate="yes" xml:space="preserve">
          <source>IOW, you can use this thing to look for likely duplicate commits.</source>
          <target state="translated">IOW,вы можете использовать эту штуку для поиска вероятных дубликатов коммитов.</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="8927163ad4efa8aea54b9b8e320ebffea4053ff8" translate="yes" xml:space="preserve">
          <source>Id of a tree-ish.</source>
          <target state="translated">Идентификация деревьев.</target>
        </trans-unit>
        <trans-unit id="f64266dea77070f77d87b89cb3f30c2d11210170" translate="yes" xml:space="preserve">
          <source>Identifier terminology</source>
          <target state="translated">Идентификационная терминология</target>
        </trans-unit>
        <trans-unit id="2dd468355239de3fa1d047b407c0f3c35e4315ad" translate="yes" xml:space="preserve">
          <source>Identity-specific versions of the &lt;code&gt;sendemail.*&lt;/code&gt; parameters found below, taking precedence over those when this identity is selected, through either the command-line or &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendemail.*&lt;/code&gt; ниже версии параметров sendemail. * Для конкретных идентификаторов имеют приоритет над теми, которые выбраны с помощью командной строки или &lt;code&gt;sendemail.identity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05103278665252bd3225a3f315ada6e006bd41ae" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; is given in place of &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt;, it is a regular expression that denotes the range from the first funcname line that matches &amp;lt;funcname&amp;gt;, up to the next funcname line. &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. &amp;ldquo;^:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the start of file.</source>
          <target state="translated">Если вместо &amp;lt;start&amp;gt; и &amp;lt;end&amp;gt; указано &amp;laquo;: &amp;lt;funcname&amp;gt;&amp;raquo;, это регулярное выражение, обозначающее диапазон от первой строки funcname, которая соответствует &amp;lt;funcname&amp;gt;, до следующей строки funcname. &amp;laquo;: &amp;lt;funcname&amp;gt;&amp;raquo; выполняет поиск с конца предыдущего диапазона &lt;code&gt;-L&lt;/code&gt; , если таковой имеется, в противном случае - с начала файла. &amp;laquo;^: &amp;lt;Имя функции&amp;gt;&amp;raquo; выполняет поиск с начала файла.</target>
        </trans-unit>
        <trans-unit id="a70081d33e7c2f9862444b9de88b6fa456d0c4eb" translate="yes" xml:space="preserve">
          <source>If &amp;lt;branch&amp;gt; is specified, &lt;code&gt;git rebase&lt;/code&gt; will perform an automatic &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; before doing anything else. Otherwise it remains on the current branch.</source>
          <target state="translated">Если указано &amp;lt;branch&amp;gt;, &lt;code&gt;git rebase&lt;/code&gt; выполнит автоматический &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; прежде чем делать что-либо еще. В противном случае он останется в текущей ветке.</target>
        </trans-unit>
        <trans-unit id="441a1b498aa3709837145817fb556c2b9312d349" translate="yes" xml:space="preserve">
          <source>If &amp;lt;commit-ish&amp;gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="translated">Если &amp;lt;commit-ish&amp;gt; является именем ветки (назовите его &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ) и не найден, и не используются ни &lt;code&gt;-b&lt;/code&gt; , ни &lt;code&gt;-B&lt;/code&gt; , ни &lt;code&gt;--detach&lt;/code&gt; , но существует ветвь отслеживания ровно на одном удаленном устройстве (назовите его &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ) с совпадающим именем рассматривать как эквивалент:</target>
        </trans-unit>
        <trans-unit id="a2dfa99d3d5ae08ba34d86a50dd72c99c275182b" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; does not match any remote ref, either</source>
          <target state="translated">Если &amp;lt;dst&amp;gt; не соответствует ни одной удаленной ссылке, либо</target>
        </trans-unit>
        <trans-unit id="a47c4a8533ef20594cec62184911d5ccc54294bc" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; doesn&amp;rsquo;t start with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) we will try to infer where in &lt;code&gt;refs/*&lt;/code&gt; on the destination &amp;lt;repository&amp;gt; it belongs based on the type of &amp;lt;src&amp;gt; being pushed and whether &amp;lt;dst&amp;gt; is ambiguous.</source>
          <target state="translated">Если &amp;lt;dst&amp;gt; не начинается с &lt;code&gt;refs/&lt;/code&gt; (например, &lt;code&gt;refs/heads/master&lt;/code&gt; ), мы попытаемся вывести, где в &lt;code&gt;refs/*&lt;/code&gt; в целевом &amp;lt;репозитории&amp;gt; он принадлежит на основе типа отправляемого &amp;lt;src&amp;gt; и того, является ли &amp;lt; dst&amp;gt; неоднозначно.</target>
        </trans-unit>
        <trans-unit id="055e400548fbd1f8dd3a927bc48c7fba28571578" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; unambiguously refers to a ref on the &amp;lt;repository&amp;gt; remote, then push to that ref.</source>
          <target state="translated">Если &amp;lt;dst&amp;gt; однозначно ссылается на ссылку на удаленном &amp;lt;репозитории&amp;gt;, то нажмите на эту ссылку.</target>
        </trans-unit>
        <trans-unit id="2f8ca0e0f80952529303f3d2318f597064384182" translate="yes" xml:space="preserve">
          <source>If &amp;lt;src&amp;gt; resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to &amp;lt;dst&amp;gt;.</source>
          <target state="translated">Если &amp;lt;src&amp;gt; преобразуется в ссылку, начинающуюся с refs / Heads / или refs / tags /, тогда добавьте это к &amp;lt;dst&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="22f62b9091f5d458969b188b7b4383b4ee480486" translate="yes" xml:space="preserve">
          <source>If &amp;lt;start&amp;gt; or &amp;lt;end&amp;gt; is a number, it specifies an absolute line number (lines count from 1).</source>
          <target state="translated">Если &amp;lt;начало&amp;gt; или &amp;lt;конец&amp;gt; является числом, оно указывает абсолютный номер строки (количество строк начинается с 1).</target>
        </trans-unit>
        <trans-unit id="3dcd00aaff1f71fc43821b3cae7ba5d1996fda2a" translate="yes" xml:space="preserve">
          <source>If &amp;lt;type&amp;gt; is specified, the raw (though uncompressed) contents of the &amp;lt;object&amp;gt; will be returned.</source>
          <target state="translated">Если указан &amp;lt;type&amp;gt;, будет возвращено необработанное (хотя и несжатое) содержимое &amp;lt;object&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="60fbab80da041fac4b578f6b9620a6e042d89ff6" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="099d6bbda7b3ea83e2000830c8cd48d38a505e41" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is not specified, the upstream configured in branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options will be used (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details) and the &lt;code&gt;--fork-point&lt;/code&gt; option is assumed. If you are currently not on any branch or if the current branch does not have a configured upstream, the rebase will abort.</source>
          <target state="translated">Если &amp;lt;вверх&amp;gt; не указан, то вверх по течению сконфигурировано в отрасли. &amp;lt;Имя&amp;gt; .remote и ветви. &amp;lt;Имя&amp;gt; будет использоваться .merge параметры (см &lt;a href=&quot;git-config&quot;&gt;ГИТ-конфигурации [1]&lt;/a&gt; для более подробной информации) и &lt;code&gt;--fork-point&lt;/code&gt; вариант предполагается. Если вы в настоящее время не находитесь ни в одной ветке или если текущая ветка не имеет настроенного восходящего потока, перебазирование будет прервано.</target>
        </trans-unit>
        <trans-unit id="217621e5abfa606810a09d87aaa6c7fa540fc0fa" translate="yes" xml:space="preserve">
          <source>If --base-path is enabled and repo lookup fails, with this option &lt;code&gt;git daemon&lt;/code&gt; will attempt to lookup without prefixing the base path. This is useful for switching to --base-path usage, while still allowing the old paths.</source>
          <target state="translated">Если --base-path включен и поиск репозитория завершился неудачно, с этой опцией &lt;code&gt;git daemon&lt;/code&gt; попытается выполнить поиск без префикса базового пути. Это полезно для переключения на использование --base-path, но при этом позволяет использовать старые пути.</target>
        </trans-unit>
        <trans-unit id="8fc1cea1e55be69663b951a920323d5b77c212cc" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, and a symlink in the repository points outside the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">Если используется --follow-symlinks, а символическая ссылка в репозитории указывает за пределы репозитория, то &lt;code&gt;cat-file&lt;/code&gt; проигнорирует любой пользовательский формат и напечатает:</target>
        </trans-unit>
        <trans-unit id="100e053a72420596d3d8e1af3be6193b59283565" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, the following error messages will be displayed:</source>
          <target state="translated">При использовании --follow-symlinks будут отображены следующие сообщения об ошибках:</target>
        </trans-unit>
        <trans-unit id="5af2f9fd35f6354ba06f2224c3a1950a1f2e9539" translate="yes" xml:space="preserve">
          <source>If --no-deref is given, &amp;lt;ref&amp;gt; itself is overwritten, rather than the result of following the symbolic pointers.</source>
          <target state="translated">Если задано --no-deref, перезаписывается сам &amp;lt;ref&amp;gt;, а не результат следования за символическими указателями.</target>
        </trans-unit>
        <trans-unit id="09e3aecc968d12fb9705beff5237174e03c29bc7" translate="yes" xml:space="preserve">
          <source>If --porcelain is used, then each line of the output is of the form:</source>
          <target state="translated">Если используется --porcelain,то каждая строка вывода имеет форму:</target>
        </trans-unit>
        <trans-unit id="f6d2b768e06f422855acdd627f6c6194c3c0ef9e" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, sometimes empty commits are missed and left around anyway (a somewhat rare bug, but it happens&amp;hellip;​)</source>
          <target state="translated">Если указан --prune-empty, иногда пустые коммиты пропускаются и в любом случае остаются (довольно редкая ошибка, но бывает ...)</target>
        </trans-unit>
        <trans-unit id="e22868793c21cef41b42f4d8e7236df1fabd77b0" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, then intentionally placed empty commits from before the filtering operation are also pruned instead of just pruning commits that became empty due to filtering rules.</source>
          <target state="translated">Если указан параметр --prune-empty,то намеренно помещаемые пустые коммиты перед операцией фильтрации также обрезаются,а не просто обрезаются коммиты,которые стали пустыми из-за правил фильтрации.</target>
        </trans-unit>
        <trans-unit id="a5f91d56ff44d75c2f6264bd8bf6a44ba8095c27" translate="yes" xml:space="preserve">
          <source>If --prune-empty isn&amp;rsquo;t specified, then the filtering process can create hoards of confusing empty commits</source>
          <target state="translated">Если --prune-empty не указан, то процесс фильтрации может создать массу запутанных пустых коммитов.</target>
        </trans-unit>
        <trans-unit id="2d1fd147af59c1bbe70034d2e19205e4683ec22e" translate="yes" xml:space="preserve">
          <source>If --refresh finds unmerged changes in the index, the default behavior is to error out. This option makes &lt;code&gt;git update-index&lt;/code&gt; continue anyway.</source>
          <target state="translated">Если --refresh находит не объединенные изменения в индексе, поведение по умолчанию - ошибка. Этот параметр в любом случае продолжает работу с &lt;code&gt;git update-index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d97a45ebe920517b85d93c5180821e570038df" translate="yes" xml:space="preserve">
          <source>If -b is used the short-format status is preceded by a line</source>
          <target state="translated">Если используется -b,то короткоформатному статусу предшествует строка</target>
        </trans-unit>
        <trans-unit id="a46e8db06d3992e975f7697afc61f277e4b431aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; or &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; is not selecting the key you want it to automatically when creating a signed tag or commit, you can override the default selection with this variable. This option is passed unchanged to gpg&amp;rsquo;s --local-user parameter, so you may specify a key using any method that gpg supports.</source>
          <target state="translated">Если &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; или &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; не выбирает ключ, который вы хотите, автоматически при создании подписанного тега или фиксации, вы можете переопределить выбор по умолчанию с помощью этой переменной. Эта опция без изменений передается в параметр gpg --local-user, поэтому вы можете указать ключ с помощью любого метода, поддерживаемого gpg.</target>
        </trans-unit>
        <trans-unit id="2cf1a7ea3bd0bf42d7200bd0e5a09fa57461a419" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; exists, that is what you mean (this is usually useful only for &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;FETCH_HEAD&lt;/code&gt;, &lt;code&gt;ORIG_HEAD&lt;/code&gt;, &lt;code&gt;MERGE_HEAD&lt;/code&gt; and &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt;);</source>
          <target state="translated">Если существует &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; , вы имеете в виду именно это (обычно это полезно только для &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;FETCH_HEAD&lt;/code&gt; , &lt;code&gt;ORIG_HEAD&lt;/code&gt; , &lt;code&gt;MERGE_HEAD&lt;/code&gt; и &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="393d945c97962e065f70f0c395a4b7cc04c58275" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR&lt;/code&gt; is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status.</source>
          <target state="translated">Если &lt;code&gt;$GIT_DIR&lt;/code&gt; не определен и текущий каталог не определен как лежащий в репозитории Git или рабочем дереве, распечатайте сообщение в stderr и выйдите с ненулевым статусом.</target>
        </trans-unit>
        <trans-unit id="b71bb32cc72ead271cb1dd3ba713d52586ceff1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$per_request_config&lt;/code&gt; is not a code reference, it is interpreted as boolean value. If it is true gitweb will process config files once per request, and if it is false gitweb will process config files only once, each time it is executed. True by default (set to 1).</source>
          <target state="translated">Если &lt;code&gt;$per_request_config&lt;/code&gt; не является ссылкой на код, он интерпретируется как логическое значение. Если это правда, gitweb будет обрабатывать файлы конфигурации один раз за запрос, а если ложь, gitweb будет обрабатывать файлы конфигурации только один раз, каждый раз, когда он выполняется. По умолчанию True (установлено в 1).</target>
        </trans-unit>
        <trans-unit id="2006fc66d73a978df057f23b3e1521f13762b146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$projects_list&lt;/code&gt; variable is unset, gitweb will recursively scan filesystem for Git repositories. The &lt;code&gt;$project_maxdepth&lt;/code&gt; is used to limit traversing depth, relative to &lt;code&gt;$projectroot&lt;/code&gt; (starting point); it means that directories which are further from &lt;code&gt;$projectroot&lt;/code&gt; than &lt;code&gt;$project_maxdepth&lt;/code&gt; will be skipped.</source>
          <target state="translated">Если переменная &lt;code&gt;$projects_list&lt;/code&gt; не задана, gitweb будет рекурсивно сканировать файловую систему на предмет репозиториев Git. &lt;code&gt;$project_maxdepth&lt;/code&gt; используется для глубины ограничения перемещения, по сравнению с &lt;code&gt;$projectroot&lt;/code&gt; (начальная точка); это означает, что каталоги, расположенные дальше от &lt;code&gt;$projectroot&lt;/code&gt; чем &lt;code&gt;$project_maxdepth&lt;/code&gt; будут пропущены.</target>
        </trans-unit>
        <trans-unit id="e1a24fe330082e54d9c17c846d5ecec5993c1e30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name and &lt;code&gt;--no-guess&lt;/code&gt; is not specified, treat as equivalent to</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; не найден, но существует ветвь отслеживания ровно на одном удаленном устройстве (назовите его &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ) с совпадающим именем и &lt;code&gt;--no-guess&lt;/code&gt; не указана, рассматривать как эквивалент</target>
        </trans-unit>
        <trans-unit id="8d6aaf33671aeae0467cc81ab4a876d4297a1c66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; не найден, но существует ветвь отслеживания ровно на одном пульте (назовите его &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ) с совпадающим именем, рассматривать как эквивалент</target>
        </trans-unit>
        <trans-unit id="d5e4daa5549f785c6c9358d5ddb62b147a25d8f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34274f8acc6fb322cd63ad185064de80d714660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new working tree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on &lt;code&gt;HEAD&lt;/code&gt; is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new working tree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the working tree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29cec940deeaa506fbdf23d2fcc19ea5029d5ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new worktree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on HEAD is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new worktree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the worktree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; опущен и не используются ни &lt;code&gt;-b&lt;/code&gt; , ни &lt;code&gt;-B&lt;/code&gt; , ни &lt;code&gt;--detach&lt;/code&gt; , то для удобства новое рабочее дерево связывается с веткой (назовите ее &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ), названной в честь &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt; . Если &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; не существует, новая ветвь на основе HEAD создается автоматически, как если бы был задан &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; . Если &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; существует, то оно будет проверено в новом worktree, если он не проверил в другом месте, в противном случае команда будет отказаться от создания worktree (если &lt;code&gt;--force&lt;/code&gt; не используется).</target>
        </trans-unit>
        <trans-unit id="62b6dbbe2a25a278c760cd92507e0bb77e25690a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt;, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be &lt;code&gt;message&lt;/code&gt;, otherwise &lt;code&gt;subject&lt;/code&gt; will be used.</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; - &lt;code&gt;auto&lt;/code&gt; , если первый абзац описания ветки больше 100 байт, то будет режим &lt;code&gt;message&lt;/code&gt; , иначе будет использоваться &lt;code&gt;subject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="563c89a3c046790f554398f75098f56ae60f56e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;message&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch&amp;rsquo;s description. This is the default mode when no configuration nor command line option is specified.</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; - &lt;code&gt;message&lt;/code&gt; или &lt;code&gt;default&lt;/code&gt; , тема сопроводительного письма будет заполнена текстом-заполнителем. Тело сопроводительного письма будет заполнено описанием ветки. Это режим по умолчанию, когда не указаны ни конфигурация, ни параметр командной строки.</target>
        </trans-unit>
        <trans-unit id="768e82f3c3c3a8afb9417d73246f89dace57fcaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, both the cover letter subject and body will be populated with placeholder text.</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; не &lt;code&gt;none&lt;/code&gt; , как сопроводительное письмо , тема и тело будет заполняться с шаблонным текстом.</target>
        </trans-unit>
        <trans-unit id="3b18877d6ecf14744d4315ad4c41aafa8a39f64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;subject&lt;/code&gt;, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter.</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; является &lt;code&gt;subject&lt;/code&gt; , первый абзац описания ветви будет содержать тему сопроводительного письма. Остальная часть описания заполнит текст сопроводительного письма.</target>
        </trans-unit>
        <trans-unit id="5e29b380beb0930e1e749e4eaa468dd6abb12015" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a4599482148106286830a5bf06a49e73c76aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--autosquash&lt;/code&gt; is used, &quot;exec&quot; lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series.</source>
          <target state="translated">Если используется &lt;code&gt;--autosquash&lt;/code&gt; , строки &amp;laquo;exec&amp;raquo; не будут добавляться для промежуточных коммитов и будут появляться только в конце каждой серии сквоша / исправления.</target>
        </trans-unit>
        <trans-unit id="ab8e2bae185710923964a946f737935700b0fc1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; is specified, the object information is followed by the object contents (consisting of &lt;code&gt;%(objectsize)&lt;/code&gt; bytes), followed by a newline.</source>
          <target state="translated">Если &lt;code&gt;--batch&lt;/code&gt; , за информацией об объекте следует содержимое объекта (состоящее из байтов &lt;code&gt;%(objectsize)&lt;/code&gt; ), за которым следует новая строка .</target>
        </trans-unit>
        <trans-unit id="c868d58aa72d9bce1efba44bdbf844fae93d14ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is given, &lt;code&gt;cat-file&lt;/code&gt; will read objects from stdin, one per line, and print information about them. By default, the whole line is considered as an object, as if it were fed to &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;--batch&lt;/code&gt; или &lt;code&gt;--batch-check&lt;/code&gt; , &lt;code&gt;cat-file&lt;/code&gt; будет читать объекты из стандартного ввода, по одному в строке, и печатать информацию о них. По умолчанию вся строка рассматривается как объект, как если бы она была передана в &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b49579ab9891477a433f3c4a7d881c054bf542d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--branch&lt;/code&gt; is given, a series of header lines are printed with information about the current branch.</source>
          <target state="translated">Если &lt;code&gt;--branch&lt;/code&gt; серия строк заголовка с информацией о текущей ветви.</target>
        </trans-unit>
        <trans-unit id="92890e94239521769988796133cb653b32aed431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, it allows you to ask:</source>
          <target state="translated">Если &lt;code&gt;--cached&lt;/code&gt; , вы можете спросить:</target>
        </trans-unit>
        <trans-unit id="cdc2c32e44cf382458d3759532d549dfd10bb0ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule.</source>
          <target state="translated">Если &lt;code&gt;--cached&lt;/code&gt; , эта команда вместо этого будет печатать SHA-1, записанный в суперпроекте, для каждого подмодуля.</target>
        </trans-unit>
        <trans-unit id="efe0936134ada9314d303de0a6d1675a3e22d7d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule will be checked out (using &lt;code&gt;git checkout --force&lt;/code&gt;), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.</source>
          <target state="translated">Если указано &lt;code&gt;--force&lt;/code&gt; , подмодуль будет извлечен (с использованием &lt;code&gt;git checkout --force&lt;/code&gt; ), даже если фиксация, указанная в индексе содержащего репозитория, уже совпадает с фиксацией, извлеченной в подмодуле.</target>
        </trans-unit>
        <trans-unit id="b5618fac3945aa3c15ec4d6ac940c3fc88cab042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule&amp;rsquo;s working tree will be removed even if it contains local modifications.</source>
          <target state="translated">Если &lt;code&gt;--force&lt;/code&gt; указано, работая дерево подмодуля будет удалено , даже если он содержит локальные изменения.</target>
        </trans-unit>
        <trans-unit id="95d47c3b72d050d56bd3bb3556c38937bb16f1f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--group&lt;/code&gt; is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, &lt;code&gt;git shortlog --group=author --group=trailer:co-authored-by&lt;/code&gt; counts both authors and co-authors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2db79d4530ac333b81dd59fc3c02ca024b34411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is not specified, then the submodule commits in the patch are ignored and only the absence or presence of the corresponding subdirectory is checked and (if possible) updated.</source>
          <target state="translated">Если &lt;code&gt;--index&lt;/code&gt; не указан, то коммиты подмодуля в патче игнорируются, и проверяется и (если возможно) обновляется только отсутствие или наличие соответствующего подкаталога.</target>
        </trans-unit>
        <trans-unit id="ab41ddd9d49ddaff35bf4379642301cf2f1054d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is specified (explicitly or implicitly), then the submodule commits must match the index exactly for the patch to apply. If any of the submodules are checked-out, then these check-outs are completely ignored, i.e., they are not required to be up to date or clean and they are not updated.</source>
          <target state="translated">Если &lt;code&gt;--index&lt;/code&gt; (явно или неявно), то фиксация подмодуля должна точно соответствовать индексу для применения исправления. Если какой-либо из подмодулей извлечен, то эти извлечения полностью игнорируются, т. Е. Они не должны быть актуальными или чистыми, и они не обновляются.</target>
        </trans-unit>
        <trans-unit id="d7cd61ae0dde953250d385a6012605e922398ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--list&lt;/code&gt; is given, or if there are no non-option arguments, existing branches are listed; the current branch will be highlighted in green and marked with an asterisk. Any branches checked out in linked worktrees will be highlighted in cyan and marked with a plus sign. Option &lt;code&gt;-r&lt;/code&gt; causes the remote-tracking branches to be listed, and option &lt;code&gt;-a&lt;/code&gt; shows both local and remote branches.</source>
          <target state="translated">Если &lt;code&gt;--list&lt;/code&gt; или нет аргументов, не являющихся опциями, перечисляются существующие ветви; текущая ветка будет выделена зеленым и отмечена звездочкой. Все ветки, извлеченные в связанных рабочих деревьях, будут выделены голубым цветом и отмечены знаком плюс. Параметр &lt;code&gt;-r&lt;/code&gt; приводит к отображению ветвей удаленного отслеживания, а параметр &lt;code&gt;-a&lt;/code&gt; показывает как локальные, так и удаленные ветки.</target>
        </trans-unit>
        <trans-unit id="45b84e8c64b1db8d6046842947d0384f2fee755b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--log&lt;/code&gt; is specified, a shortlog of the commits being merged will be appended to the specified message.</source>
          <target state="translated">Если указан параметр &lt;code&gt;--log&lt;/code&gt; , к указанному сообщению будет добавлен краткий журнал сливаемых коммитов.</target>
        </trans-unit>
        <trans-unit id="1772a311632ebe173773fb98d78cf3669fc056b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; is specified with &lt;code&gt;M&lt;/code&gt; a positive integer, and the new tip file would have more than &lt;code&gt;M&lt;/code&gt; commits, then instead merge the new tip with the previous tip.</source>
          <target state="translated">Если &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; указан с положительным целым числом &lt;code&gt;M&lt;/code&gt; , и в новом файле подсказки будет больше &lt;code&gt;M&lt;/code&gt; коммитов, тогда вместо этого объедините новую подсказку с предыдущей подсказкой.</target>
        </trans-unit>
        <trans-unit id="f4eab33758877fd85cebec91765014b4b92dc48c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into nested submodules, and show their status as well.</source>
          <target state="translated">Если указан &lt;code&gt;--recursive&lt;/code&gt; , эта команда будет рекурсивно разбиваться на вложенные подмодули, а также показывать их статус.</target>
        </trans-unit>
        <trans-unit id="776298c85f9bd8538095ba7ea6588e9b7e4a25e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and sync any nested submodules within.</source>
          <target state="translated">Если указан &lt;code&gt;--recursive&lt;/code&gt; , эта команда будет рекурсивно перемещаться в зарегистрированные подмодули и синхронизировать любые вложенные подмодули внутри.</target>
        </trans-unit>
        <trans-unit id="1ddca2ea8ce5da739445e37cd4a4048560236396" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and update any nested submodules within.</source>
          <target state="translated">Если указан параметр &lt;code&gt;--recursive&lt;/code&gt; , эта команда вернется в зарегистрированные подмодули и обновит все вложенные подмодули внутри.</target>
        </trans-unit>
        <trans-unit id="ccfd5529f6d32ddb692a0a0edb24e2ebd0aeb784" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;X&lt;/code&gt; equal 2. If the new tip file would have &lt;code&gt;N&lt;/code&gt; commits and the previous tip has &lt;code&gt;M&lt;/code&gt; commits and &lt;code&gt;X&lt;/code&gt; times &lt;code&gt;N&lt;/code&gt; is greater than &lt;code&gt;M&lt;/code&gt;, instead merge the two files into a single file.</source>
          <target state="translated">Если &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; не указан, пусть &lt;code&gt;X&lt;/code&gt; равно 2. Если новый файл подсказки будет иметь &lt;code&gt;N&lt;/code&gt; фиксаций, а предыдущая подсказка имеет &lt;code&gt;M&lt;/code&gt; фиксаций и в &lt;code&gt;X&lt;/code&gt; раз &lt;code&gt;N&lt;/code&gt; больше, чем &lt;code&gt;M&lt;/code&gt; , вместо этого объедините два файла в один файл.</target>
        </trans-unit>
        <trans-unit id="769d8817aa727ff62e14daf04f7de44e2d479abb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--split=no-merge&lt;/code&gt; is specified, a merge is never performed, and the remaining options are ignored. &lt;code&gt;--split=replace&lt;/code&gt; overwrites the existing chain with a new one. A bare &lt;code&gt;--split&lt;/code&gt; defers to the remaining options. (Note that merging a chain of commit graphs replaces the existing chain with a length-1 chain where the first and only incremental holds the entire graph).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75734f6686dc8bf756f12580f08ccb633b88773" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--stateless-rpc&lt;/code&gt; is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet.</source>
          <target state="translated">Если &lt;code&gt;--stateless-rpc&lt;/code&gt; указан вместе с этой опцией, то список ссылок должен быть в формате пакета (pkt-line). Каждая ссылка должна быть в отдельном пакете, а список должен заканчиваться пакетом очистки.</target>
        </trans-unit>
        <trans-unit id="d363c35441978c92ee5ead459023dfd1f9ed35c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--verbose&lt;/code&gt; is specified, the output is a series of lines of the form:</source>
          <target state="translated">Если указан &lt;code&gt;--verbose&lt;/code&gt; , вывод представляет собой серию строк в форме:</target>
        </trans-unit>
        <trans-unit id="b441bd31aac4d2437fef46e0587314ace0da5e13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-B&lt;/code&gt; is given, &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; is created if it doesn&amp;rsquo;t exist; otherwise, it is reset. This is the transactional equivalent of</source>
          <target state="translated">Если задано &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; если она не существует; в противном случае он сбрасывается. Это транзакционный эквивалент</target>
        </trans-unit>
        <trans-unit id="b749f9938784db5272ac47989617994390a95806" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-N&lt;/code&gt; is specified, removed paths are marked as intent-to-add (see &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;).</source>
          <target state="translated">Если указано &lt;code&gt;-N&lt;/code&gt; , удаленные пути помечаются как добавляемые с намерением (см. &lt;a href=&quot;git-add&quot;&gt;Git-add [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d1031ba738c1e4895034c45a671bdfc4feb8ed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-e&lt;/code&gt; is specified, no output, unless the &amp;lt;object&amp;gt; is malformed.</source>
          <target state="translated">Если указан &lt;code&gt;-e&lt;/code&gt; , вывод не будет, если &amp;lt;объект&amp;gt; не имеет неправильного формата.</target>
        </trans-unit>
        <trans-unit id="b39ecbbcbddbe2e5db1df9079f165a4a73917d14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given and &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, and &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; are absent, &lt;code&gt;-a&lt;/code&gt; is implied.</source>
          <target state="translated">Если задано &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; или &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; и отсутствуют &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; и &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; , подразумевается &lt;code&gt;-a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ab965e580c550a049049c227e584f98537d08f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m&lt;/code&gt; is specified, &lt;code&gt;git read-tree&lt;/code&gt; can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided.</source>
          <target state="translated">Если указан &lt;code&gt;-m&lt;/code&gt; , &lt;code&gt;git read-tree&lt;/code&gt; может выполнять 3 вида слияния, слияние одного дерева, если задано только 1 дерево, слияние с ускоренной перемоткой вперед с 2 деревьями или 3-стороннее слияние, если предоставлено 3 или более деревьев ,</target>
        </trans-unit>
        <trans-unit id="1f1322547f9936fb21adaa0927130bdfd594f82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--non-matching&lt;/code&gt; are specified, non-matching pathnames will also be output, in which case all fields in each output record except for &amp;lt;pathname&amp;gt; will be empty. This can be useful when running non-interactively, so that files can be incrementally streamed to STDIN of a long-running check-ignore process, and for each of these files, STDOUT will indicate whether that file matched a pattern or not. (Without this option, it would be impossible to tell whether the absence of output for a given file meant that it didn&amp;rsquo;t match any pattern, or that the output hadn&amp;rsquo;t been generated yet.)</source>
          <target state="translated">Если &lt;code&gt;--non-matching&lt;/code&gt; &lt;code&gt;-n&lt;/code&gt; или --non-matching, несоответствующие имена путей также будут выведены, и в этом случае все поля в каждой выходной записи, кроме &amp;lt;pathname&amp;gt;, будут пустыми. Это может быть полезно при работе в неинтерактивном режиме, чтобы файлы можно было постепенно передавать в STDIN длительного процесса проверки-игнорирования, и для каждого из этих файлов STDOUT будет указывать, соответствует ли этот файл шаблону или нет. (Без этой опции было бы невозможно определить, означает ли отсутствие вывода для данного файла, что он не соответствует какому-либо шаблону, или что вывод еще не был создан.)</target>
        </trans-unit>
        <trans-unit id="bedfa7472b5b880935d5dde5c2d6b7df2dd5534d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-o&lt;/code&gt; is specified, output files are created in &amp;lt;dir&amp;gt;. Otherwise they are created in the current working directory. The default path can be set with the &lt;code&gt;format.outputDirectory&lt;/code&gt; configuration option. The &lt;code&gt;-o&lt;/code&gt; option takes precedence over &lt;code&gt;format.outputDirectory&lt;/code&gt;. To store patches in the current working directory even when &lt;code&gt;format.outputDirectory&lt;/code&gt; points elsewhere, use &lt;code&gt;-o .&lt;/code&gt;. All directory components will be created.</source>
          <target state="translated">Если указан &lt;code&gt;-o&lt;/code&gt; , выходные файлы создаются в &amp;lt;dir&amp;gt;. В противном случае они создаются в текущем рабочем каталоге. Путь по умолчанию можно задать с помощью &lt;code&gt;format.outputDirectory&lt;/code&gt; конфигурации format.outputDirectory . Параметр &lt;code&gt;-o&lt;/code&gt; имеет приоритет над &lt;code&gt;format.outputDirectory&lt;/code&gt; . Чтобы сохранить исправления в текущем рабочем каталоге, даже если &lt;code&gt;format.outputDirectory&lt;/code&gt; указывает на другое место, используйте &lt;code&gt;-o .&lt;/code&gt; , Все компоненты каталога будут созданы.</target>
        </trans-unit>
        <trans-unit id="bbc0034ea645324d7719670d640dccda6b5513e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-p&lt;/code&gt; is specified, the contents of &amp;lt;object&amp;gt; are pretty-printed.</source>
          <target state="translated">Если указан параметр &lt;code&gt;-p&lt;/code&gt; , содержимое &amp;lt;object&amp;gt; печатается красиво.</target>
        </trans-unit>
        <trans-unit id="49cafb1f81b012710180fa1719861bbc315bac4f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-s&lt;/code&gt; is specified, the size of the &amp;lt;object&amp;gt; in bytes.</source>
          <target state="translated">Если указан &lt;code&gt;-s&lt;/code&gt; , размер &amp;lt;объекта&amp;gt; в байтах.</target>
        </trans-unit>
        <trans-unit id="859275c6340e08abbb3b87a577dd1f75bdf60296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-t&lt;/code&gt; is specified, one of the &amp;lt;type&amp;gt;.</source>
          <target state="translated">Если указан &lt;code&gt;-t&lt;/code&gt; , один из &amp;lt;тип&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="77cb52b6f5e5f8b68fe5657e97a4dba5f22808fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-v&lt;/code&gt; is specified, the script reports what it is doing.</source>
          <target state="translated">Если указано &lt;code&gt;-v&lt;/code&gt; , сценарий сообщает, что он делает.</target>
        </trans-unit>
        <trans-unit id="f7c94cac86b7d031a538f6e54d51ce5da54af947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-z&lt;/code&gt; is specified, the pathnames in the output are delimited by the null character; if &lt;code&gt;--verbose&lt;/code&gt; is also specified then null characters are also used instead of colons and hard tabs:</source>
          <target state="translated">Если указан &lt;code&gt;-z&lt;/code&gt; , пути в выводе разделяются нулевым символом; если также указан &lt;code&gt;--verbose&lt;/code&gt; , то вместо двоеточий и жестких вкладок также используются нулевые символы:</target>
        </trans-unit>
        <trans-unit id="54b1b9cb08e8013285c455de408ae4d63672e927" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.normalBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">Если &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; или &lt;code&gt;trace2.normalBrief&lt;/code&gt; - истина, &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;filename&lt;/code&gt; и поля &lt;code&gt;line&lt;/code&gt; опускаются.</target>
        </trans-unit>
        <trans-unit id="2e9a7edfc47ae5456f77e7777204d6f377e2ee4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.eventBrief&lt;/code&gt; is true, the &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; fields are omitted from all events and the &lt;code&gt;time&lt;/code&gt; field is only present on the &quot;start&quot; and &quot;atexit&quot; events.</source>
          <target state="translated">Если &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; или &lt;code&gt;trace2.eventBrief&lt;/code&gt; имеет значение true, поля &lt;code&gt;file&lt;/code&gt; и &lt;code&gt;line&lt;/code&gt; включаются во все события, а поле &lt;code&gt;time&lt;/code&gt; присутствует только в событиях &amp;laquo;start&amp;raquo; и &amp;laquo;atexit&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1f02cbb9b13595b2ae6e45bc6f6b5fd9cfaab0a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.perfBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">Если &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; или &lt;code&gt;trace2.perfBrief&lt;/code&gt; истинно, поля &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; и &lt;code&gt;line&lt;/code&gt; указываются.</target>
        </trans-unit>
        <trans-unit id="ac54e4f3ca84b268e2b102a57942d2590e1ed97e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration for the current branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; exists, that is the name of the branch at the remote site that is merged.</source>
          <target state="translated">Если конфигурация &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; для текущей ветви &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; существует, это имя ветви на удаленном сайте, которая объединяется.</target>
        </trans-unit>
        <trans-unit id="0bbbd298acfcfe77553aeabe5dcce9895508b92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.ignoreCase=true&lt;/code&gt;, then the pattern-matching algorithm will use a case-insensitive check. This corrects for case mismatched filenames in the &lt;code&gt;git sparse-checkout set&lt;/code&gt; command to reflect the expected cone in the working directory.</source>
          <target state="translated">Если &lt;code&gt;core.ignoreCase=true&lt;/code&gt; , тогда алгоритм сопоставления с образцом будет использовать проверку без учета регистра. Это исправляет несоответствие регистра имен файлов в команде &lt;code&gt;git sparse-checkout set&lt;/code&gt; , чтобы отразить ожидаемый конус в рабочем каталоге.</target>
        </trans-unit>
        <trans-unit id="e0b5d0106d1c8675cc37e497ff6608e05f8526d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.safecrlf&lt;/code&gt; is set to &quot;true&quot; or &quot;warn&quot;, Git verifies if the conversion is reversible for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;. For &quot;true&quot;, Git rejects irreversible conversions; for &quot;warn&quot;, Git only prints a warning but accepts an irreversible conversion. The safety triggers to prevent such a conversion done to the files in the work tree, but there are a few exceptions. Even though&amp;hellip;​</source>
          <target state="translated">Если для &lt;code&gt;core.safecrlf&lt;/code&gt; задано значение &amp;laquo;true&amp;raquo; или &amp;laquo;warn&amp;raquo;, Git проверяет, является ли преобразование обратимым для текущего параметра &lt;code&gt;core.autocrlf&lt;/code&gt; . Для &quot;истины&quot; Git отклоняет необратимые преобразования; для предупреждения Git только выводит предупреждение, но принимает необратимое преобразование. Триггеры безопасности, предотвращающие такое преобразование файлов в дереве работ, но есть несколько исключений. Хотя&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a8fd82d7f01c8cd14090b39826adb8859d4c03b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt;, then Git will parse the sparse-checkout file expecting patterns of these types. Git will warn if the patterns do not match. If the patterns do match the expected format, then Git will use faster hash- based algorithms to compute inclusion in the sparse-checkout.</source>
          <target state="translated">Если &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt; , то Git проанализирует файл разреженной проверки, ожидая шаблонов этих типов. Git предупредит, если шаблоны не совпадают. Если шаблоны действительно соответствуют ожидаемому формату, то Git будет использовать более быстрые алгоритмы на основе хешей для вычисления включения в разреженную проверку.</target>
        </trans-unit>
        <trans-unit id="9f2eb1f9e30347412b91990fde6d0d3118015f0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;credential.helper&lt;/code&gt; is configured to the empty string, this resets the helper list to empty (so you may override a helper set by a lower-priority config file by configuring the empty-string helper, followed by whatever set of helpers you would like).</source>
          <target state="translated">Если &lt;code&gt;credential.helper&lt;/code&gt; настроен на пустую строку, это сбрасывает список помощников до пустого (так что вы можете переопределить помощник, установленный файлом конфигурации с более низким приоритетом, настроив помощник с пустой строкой, за которым следует любой набор помощников, который вы хотите ).</target>
        </trans-unit>
        <trans-unit id="6f6bc24ce4d9cb03fd023baafceb347acba1bf38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will not treat the initial commit as a big creation event. Any root commits in &lt;code&gt;git log -p&lt;/code&gt; output would be shown without a diff attached. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; и связанные команды не будут рассматривать начальную фиксацию как большое событие создания. Любые коммиты root в выводе &lt;code&gt;git log -p&lt;/code&gt; будут показаны без прикрепленного diff. По умолчанию это &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="176a2b5b60655848aad57cb4f6f5216b8fca3bab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git merge-index&lt;/code&gt; is called with multiple &amp;lt;file&amp;gt;s (or -a) then it processes them in turn only stopping if merge returns a non-zero exit code.</source>
          <target state="translated">Если &lt;code&gt;git merge-index&lt;/code&gt; вызывается с несколькими &amp;lt;file&amp;gt; (или -a), он обрабатывает их, в свою очередь, останавливаясь, только если слияние возвращает ненулевой код выхода.</target>
        </trans-unit>
        <trans-unit id="806256aa8b91febcc951ef689b4cdbc521c56b19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git svn&lt;/code&gt; is configured to fetch branches (and --follow-branches is in effect), it sometimes creates multiple Git branches for one SVN branch, where the additional branches have names of the form &lt;code&gt;branchname@nnn&lt;/code&gt; (with nnn an SVN revision number). These additional branches are created if &lt;code&gt;git svn&lt;/code&gt; cannot find a parent commit for the first commit in an SVN branch, to connect the branch to the history of the other branches.</source>
          <target state="translated">Если &lt;code&gt;git svn&lt;/code&gt; настроен на выборку ветвей (и действует --follow-branch), он иногда создает несколько веток Git для одной ветки SVN, где дополнительные ветки имеют имена в форме имя &lt;code&gt;branchname@nnn&lt;/code&gt; (где nnn - номер версии SVN. ). Эти дополнительные ветки создаются, если &lt;code&gt;git svn&lt;/code&gt; не может найти родительский коммит для первого коммита в ветке SVN, чтобы связать ветвь с историей других ветвей.</target>
        </trans-unit>
        <trans-unit id="ea83fb8f1cd42b6f4ec377884889f8ee539b7922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;our&lt;/code&gt; version introduces whitespace changes but &lt;code&gt;their&lt;/code&gt; version includes a substantial change, &lt;code&gt;their&lt;/code&gt; version is used;</source>
          <target state="translated">Если &lt;code&gt;our&lt;/code&gt; версия вносит изменения в пробелы, но &lt;code&gt;their&lt;/code&gt; версия включает существенные изменения, используется &lt;code&gt;their&lt;/code&gt; версия;</target>
        </trans-unit>
        <trans-unit id="a540055d45818789fbb8422bbf0d3790f08d9718" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repack.packKeptObjects&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then any pack-files with an associated &lt;code&gt;.keep&lt;/code&gt; file will not be selected for the batch to repack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3c5f8b5c3f8823d3bb0bf75c68202ef91e0068" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled for the long format and a summary of commits for modified submodules will be shown (see --summary-limit option of &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;). Please note that the summary output from the status command will be suppressed for all submodules when &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; is set to &lt;code&gt;all&lt;/code&gt; or only for those submodules where &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt;. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command line option or the &lt;code&gt;git submodule summary&lt;/code&gt; command, which shows a similar output but does not honor these settings.</source>
          <target state="translated">Если для &lt;code&gt;status.submoduleSummary&lt;/code&gt; установлено ненулевое число или значение true (идентично -1 или неограниченному числу), сводка подмодуля будет включена для длинного формата и будет показана сводка коммитов для измененных подмодулей (см. --Summary -limit опция &lt;a href=&quot;git-submodule&quot;&gt;git-&lt;/a&gt; submodule [1] ). Обратите внимание, что итоговый вывод команды status будет подавлен для всех подмодулей, если для &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; установлено значение &lt;code&gt;all&lt;/code&gt; или только для тех подмодулей, где &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt; . Чтобы также просмотреть сводку для проигнорированных подмодулей, вы можете использовать параметр командной строки --ignore-submodules = dirty или &lt;code&gt;git submodule summary&lt;/code&gt; команда, которая показывает аналогичный вывод, но не учитывает эти настройки.</target>
        </trans-unit>
        <trans-unit id="9e9c3270ca55bc57874ba3c8e582e2598d79892a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subsystem&lt;/code&gt; is rebased against &lt;code&gt;master&lt;/code&gt;, the following happens:</source>
          <target state="translated">Если &lt;code&gt;subsystem&lt;/code&gt; переустанавливается на &lt;code&gt;master&lt;/code&gt; , происходит следующее:</target>
        </trans-unit>
        <trans-unit id="601fb7e577607a9227812e9cbf0586e6f099c5c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;their&lt;/code&gt; version only introduces whitespace changes to a line, &lt;code&gt;our&lt;/code&gt; version is used;</source>
          <target state="translated">Если &lt;code&gt;their&lt;/code&gt; версия вводит только изменения пробелов в строке, используется &lt;code&gt;our&lt;/code&gt; версия;</target>
        </trans-unit>
        <trans-unit id="8afd53e5e6b34e88bd67e48774d4e9aa34d681c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will act as if the &lt;code&gt;--show-signature&lt;/code&gt; option was passed to them.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; и связанные команды будут действовать так, как если бы им была передана опция &lt;code&gt;--show-signature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30fb3a857bee5620305914164cd0d4800cd1bf39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; will act as if the &lt;code&gt;--follow&lt;/code&gt; option was used when a single &amp;lt;path&amp;gt; is given. This has the same limitations as &lt;code&gt;--follow&lt;/code&gt;, i.e. it cannot be used to follow multiple files and does not work well on non-linear history.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; будет действовать так, как если бы &lt;code&gt;--follow&lt;/code&gt; опция --follow, когда задан единственный &amp;lt;path&amp;gt;. Он имеет те же ограничения, что и &lt;code&gt;--follow&lt;/code&gt; , то есть он не может использоваться для отслеживания нескольких файлов и плохо работает с нелинейной историей.</target>
        </trans-unit>
        <trans-unit id="1ee512d5daa33e9512f53b0ef8141d045d9eb4b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, indicate that the caller wants hash algorithm information to be passed back from the remote. This mode is used when fetching refs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e427e8f5bde6693ff553f72c72fbaf5c9a84e60f" translate="yes" xml:space="preserve">
          <source>If Alice wants to visualize what Bob did since their histories forked she can issue the following command:</source>
          <target state="translated">Если Элис хочет визуализировать,что Боб делал с момента вилки их истории,она может выдать следующую команду:</target>
        </trans-unit>
        <trans-unit id="38d81a70b720705355c01f2f151a0b608b67e1f5" translate="yes" xml:space="preserve">
          <source>If Bob later decides to work from a different host, he can still perform clones and pulls using the ssh protocol:</source>
          <target state="translated">Если Боб позже решит работать с другого хоста,он все равно может выполнять клоны и тянуть,используя протокол ssh:</target>
        </trans-unit>
        <trans-unit id="906533644a5e321915983ba584ed131ee5f02be3" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;bad&quot;, then we know that its descendants are all &quot;bad&quot;, so we want to say that:</source>
          <target state="translated">Если Х будет признан &quot;плохим&quot;,то мы знаем,что все его потомки &quot;плохие&quot;,поэтому мы хотим это сказать:</target>
        </trans-unit>
        <trans-unit id="585173cb924da5e21521ae8038b0882b2bd9054d" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;good&quot;, then we know that its ancestors are all &quot;good&quot;, so we want to say that:</source>
          <target state="translated">Если Икс окажется &quot;хорошим&quot;,то мы знаем,что его предки все &quot;хорошие&quot;,поэтому мы хотим это сказать:</target>
        </trans-unit>
        <trans-unit id="5b8abb6b4933866023868019ddfccc59a8fddfdf" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, it is used as a shell wildcard to restrict the output to matching branches. If multiple patterns are given, a branch is shown if it matches any of the patterns.</source>
          <target state="translated">Если задан &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; , он используется как подстановочный знак оболочки, чтобы ограничить вывод соответствующими ветвями. Если дано несколько шаблонов, отображается ветвь, если она соответствует любому из шаблонов.</target>
        </trans-unit>
        <trans-unit id="9af8e725fef48828fa7bc334de43f0ec2851ec0b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;merge&lt;/code&gt; command fails for any reason other than merge conflicts (i.e. when the merge operation did not even start), it is rescheduled immediately.</source>
          <target state="translated">Если команда &lt;code&gt;merge&lt;/code&gt; не выполняется по какой-либо причине, кроме конфликтов слияния (т. Е. Когда операция слияния даже не началась), она немедленно переносится.</target>
        </trans-unit>
        <trans-unit id="78142494afa000f59dc94a96d37bd84306c42e5e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;no-interactive-login&lt;/code&gt; command exists, then it is run and the interactive shell is aborted.</source>
          <target state="translated">Если существует команда &lt;code&gt;no-interactive-login&lt;/code&gt; , она запускается, и интерактивная оболочка прерывается.</target>
        </trans-unit>
        <trans-unit id="7f80f5447bc118a0311c9425234560dac2c0a613" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pattern&lt;/code&gt; is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;), it is turned into a prefix match by appending &lt;code&gt;/*&lt;/code&gt;.</source>
          <target state="translated">Если задан &lt;code&gt;pattern&lt;/code&gt; , отображаются только ссылки, соответствующие данному глобу оболочки. Если в шаблоне нет символа подстановки ( &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; Или &lt;code&gt;[&lt;/code&gt; ), он преобразуется в совпадение по префиксу путем добавления &lt;code&gt;/*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="744bace39aac155f24f5426e32b134c34f641c3b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; can also be run interactively (with no arguments). If a &lt;code&gt;help&lt;/code&gt; command is present in the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, it is run to provide the user with an overview of allowed actions. Then a &quot;git&amp;gt; &quot; prompt is presented at which one can enter any of the commands from the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, or &lt;code&gt;exit&lt;/code&gt; to close the connection.</source>
          <target state="translated">Если присутствует каталог &lt;code&gt;~/git-shell-commands&lt;/code&gt; , &lt;code&gt;git shell&lt;/code&gt; также можно запускать в интерактивном режиме (без аргументов). Если в каталоге &lt;code&gt;git-shell-commands&lt;/code&gt; присутствует команда &lt;code&gt;help&lt;/code&gt; , она запускается, чтобы предоставить пользователю обзор разрешенных действий. Затем отображается приглашение &amp;laquo;git&amp;gt;&amp;raquo;, в котором можно ввести любую из команд из каталога &lt;code&gt;git-shell-commands&lt;/code&gt; или &lt;code&gt;exit&lt;/code&gt; чтобы закрыть соединение.</target>
        </trans-unit>
        <trans-unit id="aa403bcc24255cf8941b29ab4148b7eee12a6185" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; will also handle other, custom commands by running &quot;&lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt;&quot; from the user&amp;rsquo;s home directory.</source>
          <target state="translated">Если присутствует каталог &lt;code&gt;~/git-shell-commands&lt;/code&gt; , &lt;code&gt;git shell&lt;/code&gt; также будет обрабатывать другие пользовательские команды, запустив &quot; &lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt; &quot; из домашнего каталога пользователя.</target>
        </trans-unit>
        <trans-unit id="106b7929c0261fff657b2746b76dd80d35492e74" translate="yes" xml:space="preserve">
          <source>If a Git client that does not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute adds a new file &lt;code&gt;bar.ps1&lt;/code&gt;, then &lt;code&gt;bar.ps1&lt;/code&gt; will be stored &quot;as-is&quot; internally (in this example probably as UTF-16). A client with &lt;code&gt;working-tree-encoding&lt;/code&gt; support will interpret the internal contents as UTF-8 and try to convert it to UTF-16 on checkout. That operation will fail and cause an error.</source>
          <target state="translated">Если клиент Git, который не поддерживает атрибут &lt;code&gt;working-tree-encoding&lt;/code&gt; добавляет новый файл &lt;code&gt;bar.ps1&lt;/code&gt; , тогда &lt;code&gt;bar.ps1&lt;/code&gt; будет сохранен внутри &amp;laquo;как есть&amp;raquo; (в этом примере, вероятно, как UTF-16). Клиент с поддержкой &lt;code&gt;working-tree-encoding&lt;/code&gt; будет интерпретировать внутреннее содержимое как UTF-8 и пытаться преобразовать его в UTF-16 при оформлении заказа. Эта операция завершится неудачно и вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="84278502dbc74a9c4cc8dd831a2c5f189f159ac0" translate="yes" xml:space="preserve">
          <source>If a Git repository includes branches &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt;, these will be fetched and consulted first during a &lt;code&gt;git p4 sync&lt;/code&gt;. Since importing directly from p4 is considerably slower than pulling changes from a Git remote, this can be useful in a multi-developer environment.</source>
          <target state="translated">Если репозиторий Git включает ветки &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt; , они будут извлечены и просмотрены в первую очередь во время &lt;code&gt;git p4 sync&lt;/code&gt; . Поскольку импорт напрямую из p4 происходит значительно медленнее, чем извлечение изменений из удаленного Git, это может быть полезно в среде с несколькими разработчиками.</target>
        </trans-unit>
        <trans-unit id="af291be12b7b5a290c76485729b6b8f4918ca983" translate="yes" xml:space="preserve">
          <source>If a command, or a guide, is given, a manual page for that command or guide is brought up. The &lt;code&gt;man&lt;/code&gt; program is used by default for this purpose, but this can be overridden by other options or configuration variables.</source>
          <target state="translated">Если дана команда или руководство, открывается страница руководства для этой команды или руководства. По умолчанию для этой цели используется программа &lt;code&gt;man&lt;/code&gt; , но это может быть отменено другими параметрами или переменными конфигурации.</target>
        </trans-unit>
        <trans-unit id="72743ffe0426b38cdd1755e732e28a11a9ff3a78" translate="yes" xml:space="preserve">
          <source>If a commit being cherry picked duplicates a commit already in the current history, it will become empty. By default these redundant commits cause &lt;code&gt;cherry-pick&lt;/code&gt; to stop so the user can examine the commit. This option overrides that behavior and creates an empty commit object. Implies &lt;code&gt;--allow-empty&lt;/code&gt;.</source>
          <target state="translated">Если выбранный коммит дублирует коммит, уже имеющийся в текущей истории, он станет пустым. По умолчанию эти избыточные коммиты вызывают остановку &lt;code&gt;cherry-pick&lt;/code&gt; чтобы пользователь мог изучить фиксацию. Этот параметр переопределяет такое поведение и создает пустой объект фиксации. Подразумевает &lt;code&gt;--allow-empty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b42bbbaf339d6cf05d45edbdf2ada972df70aa1" translate="yes" xml:space="preserve">
          <source>If a diff tool is not specified, &lt;code&gt;git difftool&lt;/code&gt; will use the configuration variable &lt;code&gt;diff.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;diff.tool&lt;/code&gt; is not set, &lt;code&gt;git difftool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">Если инструмент сравнения не указан, &lt;code&gt;git difftool&lt;/code&gt; будет использовать переменную конфигурации &lt;code&gt;diff.tool&lt;/code&gt; . Если конфигурационная переменная &lt;code&gt;diff.tool&lt;/code&gt; не задана, &lt;code&gt;git difftool&lt;/code&gt; выберет подходящее значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a8ee98dcb134f1a2c8067ffe5665347c4c70f9e4" translate="yes" xml:space="preserve">
          <source>If a fatal error occurs, the program writes the error message to stderr and exits. The caller should expect that a suitable error message has been printed if the child closes the connection without completing a valid response for the current command.</source>
          <target state="translated">При возникновении фатальной ошибки программа записывает сообщение об ошибке в stderr и выходит из программы.Звонящий должен ожидать,что будет напечатано подходящее сообщение об ошибке,если дочерний процессор закроет соединение,не завершив действительный ответ на текущую команду.</target>
        </trans-unit>
        <trans-unit id="571d71cd29e09f41d5c855a2a419d634cc0eecce" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;must&lt;/code&gt; succeed in order to make the stored contents usable, you can declare that the filter is &lt;code&gt;required&lt;/code&gt;, in the configuration:</source>
          <target state="translated">Если фильтр &lt;code&gt;must&lt;/code&gt; успешным, чтобы сохраненное содержимое можно было использовать, вы можете объявить, что фильтр &lt;code&gt;required&lt;/code&gt; , в конфигурации:</target>
        </trans-unit>
        <trans-unit id="22e70bb4ff6d3a3dd5464ffc106fa14107a4c8dc" translate="yes" xml:space="preserve">
          <source>If a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; path and then connect the git directory and its working directory by setting the &lt;code&gt;core.worktree&lt;/code&gt; and adding a .git file pointing to the git directory embedded in the superprojects git directory.</source>
          <target state="translated">Если каталог git подмодуля находится внутри подмодуля, переместите каталог git подмодуля в путь &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; его суперпроекта, а затем подключите каталог git и его рабочий каталог, установив &lt;code&gt;core.worktree&lt;/code&gt; и добавив указатель на файл .git в каталог git, встроенный в каталог git суперпроектов.</target>
        </trans-unit>
        <trans-unit id="7b7f1fa74f78e5b674bbee244bef979691bc168d" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;, Git prefers &lt;code&gt;fetch&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">Если помощник объявляет &lt;code&gt;connect&lt;/code&gt; , Git будет использовать его, если это возможно, и вернется к другой возможности, если помощник запросит это при подключении (см. Команду &lt;code&gt;connect&lt;/code&gt; разделе КОМАНДЫ). При выборе между &lt;code&gt;fetch&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; Git предпочитает &lt;code&gt;fetch&lt;/code&gt; . Другие интерфейсы могут иметь другой порядок предпочтений.</target>
        </trans-unit>
        <trans-unit id="148562d25b0603b8eee662bc94ef7dd269783449" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;, Git prefers &lt;code&gt;push&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">Если помощник объявляет &lt;code&gt;connect&lt;/code&gt; , Git будет использовать его, если это возможно, и вернется к другой возможности, если помощник запросит это при подключении (см. Команду &lt;code&gt;connect&lt;/code&gt; разделе КОМАНДЫ). При выборе между &lt;code&gt;push&lt;/code&gt; и &lt;code&gt;export&lt;/code&gt; Git предпочитает &lt;code&gt;push&lt;/code&gt; . Другие интерфейсы могут иметь другой порядок предпочтений.</target>
        </trans-unit>
        <trans-unit id="fa7f2d8c2e0ee7753a285dedc0954f30b43daa88" translate="yes" xml:space="preserve">
          <source>If a helper fails to perform the requested operation or needs to notify the user of a potential issue, it may write to stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2388ab5f8918a49ad2647c3d1835f78b1fd11f78" translate="yes" xml:space="preserve">
          <source>If a helper outputs a &lt;code&gt;quit&lt;/code&gt; attribute with a value of &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, no further helpers will be consulted, nor will the user be prompted (if no credential has been provided, the operation will then fail).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79eaf960175c04b54e3507607c968b768d5dc83c" translate="yes" xml:space="preserve">
          <source>If a helper receives any other operation, it should silently ignore the request. This leaves room for future operations to be added (older helpers will just ignore the new requests).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8d1c4561ad329297670b7c11b5cea0c040fa93" translate="yes" xml:space="preserve">
          <source>If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the &quot;patience diff&quot; algorithm internally.</source>
          <target state="translated">Если строка существует как в источнике,так и в пункте назначения,существует только один раз,и начинается с этого текста,данный алгоритм пытается предотвратить ее появление в виде удаления или добавления в выходных данных.Внутри он использует алгоритм &quot;терпения diff&quot;.</target>
        </trans-unit>
        <trans-unit id="03800f18f812afe9c365f3cd10e3618c12ca274e" translate="yes" xml:space="preserve">
          <source>If a linked working tree is stored on a portable device or network share which is not always mounted, you can prevent its administrative files from being pruned by issuing the &lt;code&gt;git worktree lock&lt;/code&gt; command, optionally specifying &lt;code&gt;--reason&lt;/code&gt; to explain why the working tree is locked.</source>
          <target state="translated">Если связанное рабочее дерево хранится на переносном устройстве или сетевом ресурсе, который не всегда подключен, вы можете предотвратить &lt;code&gt;git worktree lock&lt;/code&gt; его административных файлов, выполнив команду git worktree lock , необязательно указав &lt;code&gt;--reason&lt;/code&gt; , чтобы объяснить, почему рабочее дерево заблокировано ,</target>
        </trans-unit>
        <trans-unit id="055300f804a90741eca19d86c43f3b133b4438b5" translate="yes" xml:space="preserve">
          <source>If a merge resolution program is not specified, &lt;code&gt;git mergetool&lt;/code&gt; will use the configuration variable &lt;code&gt;merge.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;merge.tool&lt;/code&gt; is not set, &lt;code&gt;git mergetool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">Если программа разрешения слияния не указана, &lt;code&gt;git mergetool&lt;/code&gt; будет использовать конфигурационную переменную &lt;code&gt;merge.tool&lt;/code&gt; . Если переменная конфигурации &lt;code&gt;merge.tool&lt;/code&gt; не установлена, &lt;code&gt;git mergetool&lt;/code&gt; выберет подходящее значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1ea5bcda19ff920edc6797065824126354674b5b" translate="yes" xml:space="preserve">
          <source>If a name is specified on stdin that cannot be resolved to an object in the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">Если в stdin указано имя, которое не может быть преобразовано в объект в репозитории, то &lt;code&gt;cat-file&lt;/code&gt; проигнорирует любой пользовательский формат и напечатает:</target>
        </trans-unit>
        <trans-unit id="b64d6e7bd6f81b6c41d97bf3465e33dac59a1923" translate="yes" xml:space="preserve">
          <source>If a name is specified that might refer to more than one object (an ambiguous short sha), then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">Если указано имя, которое может относиться к более чем одному объекту (неоднозначное короткое sha), то &lt;code&gt;cat-file&lt;/code&gt; проигнорирует любой настраиваемый формат и напечатает:</target>
        </trans-unit>
        <trans-unit id="6e4b893bbe0d833def4e5b2195c3efca0abfc652" translate="yes" xml:space="preserve">
          <source>If a namespace is in use, the namespace prefix is stripped from each reference before it is matched against &lt;code&gt;transfer.hiderefs&lt;/code&gt; patterns. For example, if &lt;code&gt;refs/heads/master&lt;/code&gt; is specified in &lt;code&gt;transfer.hideRefs&lt;/code&gt; and the current namespace is &lt;code&gt;foo&lt;/code&gt;, then &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; is omitted from the advertisements but &lt;code&gt;refs/heads/master&lt;/code&gt; and &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; are still advertised as so-called &quot;have&quot; lines. In order to match refs before stripping, add a &lt;code&gt;^&lt;/code&gt; in front of the ref name. If you combine &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt; must be specified first.</source>
          <target state="translated">Если используется пространство имен, префикс пространства имен удаляется из каждой ссылки, прежде чем он будет сопоставлен с шаблонами &lt;code&gt;transfer.hiderefs&lt;/code&gt; . Например, если &lt;code&gt;refs/heads/master&lt;/code&gt; указан в &lt;code&gt;transfer.hideRefs&lt;/code&gt; , а текущее пространство имен - &lt;code&gt;foo&lt;/code&gt; , то &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; не указывается в рекламе, но &lt;code&gt;refs/heads/master&lt;/code&gt; и &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; по-прежнему рекламируются как так называемые строки &quot;иметь&quot;. Чтобы сопоставить ссылки перед удалением, добавьте &lt;code&gt;^&lt;/code&gt; перед именем ссылки. Если совместить &lt;code&gt;!&lt;/code&gt; и &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; должен быть указан первым.</target>
        </trans-unit>
        <trans-unit id="01a3979b0db1ea5ddb68d8d2296f1a14d4a19443" translate="yes" xml:space="preserve">
          <source>If a positive depth is requested, the server will compute the set of commits which are no deeper than the desired depth.</source>
          <target state="translated">Если запрашивается положительная глубина,то сервер вычисляет набор коммитов,которые не глубже желаемой глубины.</target>
        </trans-unit>
        <trans-unit id="1af76a23a450746535be3f72c4b4bca12a2092d2" translate="yes" xml:space="preserve">
          <source>If a push would not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt; of the remote branch, then it will fail with an error like:</source>
          <target state="translated">Если push не приведет к &lt;a href=&quot;#fast-forwards&quot;&gt;быстрой перемотке&lt;/a&gt; удаленной ветки вперед , то он завершится с ошибкой, например:</target>
        </trans-unit>
        <trans-unit id="74746f4cd8d12a2fd7c6b3eb595d0f3e0b5c16c7" translate="yes" xml:space="preserve">
          <source>If a reflog entry&amp;rsquo;s predecessor is pruned, adjust its &quot;old&quot; SHA-1 to be equal to the &quot;new&quot; SHA-1 field of the entry that now precedes it.</source>
          <target state="translated">Если предшественник записи рефлога удаляется, настройте его &amp;laquo;старый&amp;raquo; SHA-1, чтобы он был равен полю &amp;laquo;нового&amp;raquo; SHA-1 записи, которая теперь предшествует ему.</target>
        </trans-unit>
        <trans-unit id="335f210edb83cade21599987ff0ffeaab940885d" translate="yes" xml:space="preserve">
          <source>If a refspec is prefixed by &lt;code&gt;^&lt;/code&gt;, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a &amp;lt;src&amp;gt; and do not specify a &amp;lt;dst&amp;gt;. Fully spelled out hex object names are also not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6545e25a03004b7b80ff7680d7d52c75ae528db2" translate="yes" xml:space="preserve">
          <source>If a specified file is in the index but is missing then it&amp;rsquo;s removed. Default behavior is to ignore removed file.</source>
          <target state="translated">Если указанный файл есть в индексе, но отсутствует, он удаляется. По умолчанию удаленный файл игнорируется.</target>
        </trans-unit>
        <trans-unit id="0b6d50904501e60c5730f3fc1689dbda57685832" translate="yes" xml:space="preserve">
          <source>If a specified file isn&amp;rsquo;t in the index already then it&amp;rsquo;s added. Default behaviour is to ignore new files.</source>
          <target state="translated">Если указанного файла еще нет в индексе, он добавляется. По умолчанию новые файлы игнорируются.</target>
        </trans-unit>
        <trans-unit id="a14dea6ce44fe61b94cf6eca48f584619dca6981" translate="yes" xml:space="preserve">
          <source>If a subject is not found in the patch description the patch name is preserved as the 1 line subject in the Git description.</source>
          <target state="translated">Если объект не найден в описании патча,имя патча сохраняется как 1-строчный объект в описании Git'а.</target>
        </trans-unit>
        <trans-unit id="511834d1553ad3d02aefac42a3d932c821a68c9a" translate="yes" xml:space="preserve">
          <source>If a version-1 repository specifies any &lt;code&gt;extensions.*&lt;/code&gt; keys that the running git has not implemented, the operation MUST NOT proceed. Similarly, if the value of any known key is not understood by the implementation, the operation MUST NOT proceed.</source>
          <target state="translated">Если в репозитории версии 1 указаны какие-либо ключи &lt;code&gt;extensions.*&lt;/code&gt; , Которые запущенный git не реализовал, операция НЕ ДОЛЖНА продолжаться. Точно так же, если значение какого-либо известного ключа не понимается реализацией, операция НЕ ДОЛЖНА продолжаться.</target>
        </trans-unit>
        <trans-unit id="7fc57bcdf92fac8f6a715a452b985f9026a5a582" translate="yes" xml:space="preserve">
          <source>If a whole directory is classified as &quot;other&quot;, show just its name (with a trailing slash) and not its whole contents.</source>
          <target state="translated">Если весь каталог классифицируется как &quot;другой&quot;,показывайте только его имя (с трейлинговой косой чертой),а не все его содержимое.</target>
        </trans-unit>
        <trans-unit id="9069929e0dad6127e4d7686101bafb1ad2a53dfd" translate="yes" xml:space="preserve">
          <source>If a working tree is deleted without using &lt;code&gt;git worktree remove&lt;/code&gt;, then its associated administrative files, which reside in the repository (see &quot;DETAILS&quot; below), will eventually be removed automatically (see &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;), or you can run &lt;code&gt;git worktree prune&lt;/code&gt; in the main or any linked working tree to clean up any stale administrative files.</source>
          <target state="translated">Если рабочее дерево удаляется без использования &lt;code&gt;git worktree remove&lt;/code&gt; , то связанные с ним административные файлы, которые находятся в репозитории (см. &amp;laquo;ДЕТАЛИ&amp;raquo; ниже), в конечном итоге будут удалены автоматически (см. &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; ), или вы можете запустить &lt;code&gt;git worktree prune&lt;/code&gt; в основном или любом связанном рабочем дереве, чтобы очистить все устаревшие административные файлы.</target>
        </trans-unit>
        <trans-unit id="601f99371e1781bbcc6e4fbcb70987193e9cb892" translate="yes" xml:space="preserve">
          <source>If a working tree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted. Optionally, specify a reason for the lock with &lt;code&gt;--reason&lt;/code&gt;.</source>
          <target state="translated">Если рабочее дерево находится на переносном устройстве или сетевом ресурсе, который не всегда подключен, заблокируйте его, чтобы предотвратить автоматическое удаление административных файлов. Это также предотвращает его перемещение или удаление. При желании укажите причину блокировки с помощью &lt;code&gt;--reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c89355d42dbc93622cf0025bcf122df76b472f1" translate="yes" xml:space="preserve">
          <source>If advertised, indicates that any number of server specific options can be included in a request. This is done by sending each option as a &quot;server-option=&amp;lt;option&amp;gt;&quot; capability line in the capability-list section of a request.</source>
          <target state="translated">Если объявлено, означает, что в запрос может быть включено любое количество специфических для сервера опций. Это делается путем отправки каждой опции в виде строки возможности &quot;server-option = &amp;lt;option&amp;gt;&quot; в разделе списка возможностей запроса.</target>
        </trans-unit>
        <trans-unit id="c768073bebd10b960d1a77545805ba6684f69c55" translate="yes" xml:space="preserve">
          <source>If after this parent rewriting, &lt;code&gt;C'&lt;/code&gt; is a root or merge commit (has zero or &amp;gt;1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.</source>
          <target state="translated">Если после этой родительской перезаписи &lt;code&gt;C'&lt;/code&gt; является корневой фиксацией или фиксацией слияния (имеет ноль или&amp;gt; 1 родителей), пограничной фиксацией или! TREESAME, она остается. В противном случае он заменяется единственным родительским элементом.</target>
        </trans-unit>
        <trans-unit id="331241d5d1136bad0fab6978a8eab7a815b255e9" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;ref&amp;gt;s can be locked with matching &amp;lt;oldvalue&amp;gt;s simultaneously, all modifications are performed. Otherwise, no modifications are performed. Note that while each individual &amp;lt;ref&amp;gt; is updated or deleted atomically, a concurrent reader may still see a subset of the modifications.</source>
          <target state="translated">Если все &amp;lt;ref&amp;gt; s могут быть заблокированы совпадающими &amp;lt;oldvalue&amp;gt; s одновременно, все модификации выполняются. В противном случае никаких изменений не производится. Обратите внимание, что хотя каждый отдельный &amp;lt;ref&amp;gt; обновляется или удаляется атомарно, одновременный читатель может все еще видеть подмножество изменений.</target>
        </trans-unit>
        <trans-unit id="f2745e08ed788856c12f02ca7a5befc54f3c9443" translate="yes" xml:space="preserve">
          <source>If all named commits are already ancestors of &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; will exit early with the message &quot;Already up to date.&quot;</source>
          <target state="translated">Если все названные коммиты уже являются предками &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;git merge&lt;/code&gt; выйдет раньше с сообщением &amp;laquo;Уже обновлено&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="cf6cb5a66ab4b3c3c33160d1bdddf3e27a51bd6e" translate="yes" xml:space="preserve">
          <source>If all you really want to do is to remove from the index the files that are no longer present in the working tree (perhaps because your working tree is dirty so that you cannot use &lt;code&gt;git commit -a&lt;/code&gt;), use the following command:</source>
          <target state="translated">Если все, что вы действительно хотите сделать, это удалить из индекса файлы, которых больше нет в рабочем дереве (возможно, из-за того, что ваше рабочее дерево грязное и вы не можете использовать &lt;code&gt;git commit -a&lt;/code&gt; ), используйте следующую команду:</target>
        </trans-unit>
        <trans-unit id="232e0a33b39a8eedbea0de34207896fce9d5da1b" translate="yes" xml:space="preserve">
          <source>If an SVN revision has a property, &quot;svm:headrev&quot;, it is likely that the revision was created by SVN::Mirror (also used by SVK). The property contains a repository UUID and a revision. We want to make it look like we are mirroring the original URL, so introduce a helper function that returns the original identity URL and UUID, and use it when generating metadata in commit messages.</source>
          <target state="translated">Если ревизия SVN имеет свойство &quot;svm:headrev&quot;,вероятно,что ревизия была создана SVN::Mirror (также используется SVK).Свойство содержит UUID репозитория и ревизию.Мы хотим,чтобы оно выглядело так,как будто мы зеркалируем исходный URL,так что введите функцию помощника,которая возвращает исходный идентификационный URL и UUID,и используйте его при генерации метаданных в сообщениях о фиксации.</target>
        </trans-unit>
        <trans-unit id="8ec6058ea575ab09ff2743fac6f67664b17c975f" translate="yes" xml:space="preserve">
          <source>If an alias is given, git shows the definition of the alias on standard output. To get the manual page for the aliased command, use &lt;code&gt;git COMMAND --help&lt;/code&gt;.</source>
          <target state="translated">Если указан псевдоним, git показывает определение псевдонима в стандартном выводе. Чтобы получить страницу руководства для команды с псевдонимом, используйте &lt;code&gt;git COMMAND --help&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06b64f77884080bf4b8a1b3580804b4fc90c62bc" translate="yes" xml:space="preserve">
          <source>If an exact match was not found, &lt;code&gt;git describe&lt;/code&gt; will walk back through the commit history to locate an ancestor commit which has been tagged. The ancestor&amp;rsquo;s tag will be output along with an abbreviation of the input commit-ish&amp;rsquo;s SHA-1. If &lt;code&gt;--first-parent&lt;/code&gt; was specified then the walk will only consider the first parent of each commit.</source>
          <target state="translated">Если точное совпадение не найдено, &lt;code&gt;git describe&lt;/code&gt; description вернется к истории коммитов, чтобы найти пометку предка. Тег предка будет выводиться вместе с аббревиатурой SHA-1 входного коммита. Если был указан &lt;code&gt;--first-parent&lt;/code&gt; , тогда обход будет рассматривать только первого родителя каждой фиксации.</target>
        </trans-unit>
        <trans-unit id="98c6f5f40e2b8ae0667cb14d2e8af19ba85f9e07" translate="yes" xml:space="preserve">
          <source>If an existing replace ref for the same object exists, it will be overwritten (instead of failing).</source>
          <target state="translated">Если существующая ссылка на замену для того же самого объекта существует,то она будет перезаписана (вместо неудачной).</target>
        </trans-unit>
        <trans-unit id="046c10da2487af8c5911472dad4ec66653003b0a" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;file&amp;gt; does not appear in the index, treat this as an error (return 1).</source>
          <target state="translated">Если какой-либо &amp;lt;файл&amp;gt; не появляется в индексе, это считается ошибкой (возврат 1).</target>
        </trans-unit>
        <trans-unit id="d5c329c54100c9f229f2bd1af9a36354df219a33" translate="yes" xml:space="preserve">
          <source>If any evaluation of &amp;lt;command&amp;gt; returns a non-zero exit status, the whole operation will be aborted.</source>
          <target state="translated">Если какая-либо оценка &amp;lt;command&amp;gt; возвращает ненулевой статус выхода, вся операция будет прервана.</target>
        </trans-unit>
        <trans-unit id="939ada40ab0c594838b538aaf9b14ce39d17200d" translate="yes" xml:space="preserve">
          <source>If any file doesn&amp;rsquo;t begin with a From line, assume it is a single mail message instead of signaling error.</source>
          <target state="translated">Если какой-либо файл не начинается со строки &amp;laquo;От&amp;raquo;, предположите, что это одно почтовое сообщение, а не сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="824867a2502f9c0cf53ed6a13fd4b286bb82c4ed" translate="yes" xml:space="preserve">
          <source>If any files that should not be normalized show up in &lt;code&gt;git status&lt;/code&gt;, unset their &lt;code&gt;text&lt;/code&gt; attribute before running &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">Если какие-либо файлы, которые не следует нормализовать, отображаются в &lt;code&gt;git status&lt;/code&gt; , отключите их &lt;code&gt;text&lt;/code&gt; атрибут перед запуском &lt;code&gt;git add -u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c34b6095a9c49861d2acc43610b57c3a4a36934" translate="yes" xml:space="preserve">
          <source>If any files were ever &quot;cvs import&quot;ed more than once (e.g., import of more than one vendor release) the HEAD contains the wrong content.</source>
          <target state="translated">Если какие-либо файлы когда-либо &quot;импортировались&quot; cvs более одного раза (например,импорт более чем одной версии производителя),HEAD содержит неверное содержимое.</target>
        </trans-unit>
        <trans-unit id="8a184d41ad4c8629ad4f2bce24803b0c9fa2c0bb" translate="yes" xml:space="preserve">
          <source>If any of the remote changes overlap with local uncommitted changes, the merge will be automatically canceled and the work tree untouched. It is generally best to get any local changes in working order before pulling or stash them away with &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">Если какое-либо из удаленных изменений перекрывается с локальными незафиксированными изменениями, слияние будет автоматически отменено, а дерево работы останется без изменений. Как правило, лучше всего получить какие-либо локальные изменения в рабочем состоянии, прежде чем извлекать или спрятать их с помощью &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27aabdb37af0432fadcd5ffecc44449505cac9be" translate="yes" xml:space="preserve">
          <source>If any optional &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; arguments are given, only those paths are affected.</source>
          <target state="translated">Если заданы необязательные аргументы &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; , затрагиваются только эти пути.</target>
        </trans-unit>
        <trans-unit id="d20da8878e924b8ea99ba5928199985d6eb45c5b" translate="yes" xml:space="preserve">
          <source>If at least one of the specified mechanisms matches the ones advertised by the SMTP server and if it is supported by the utilized SASL library, the mechanism is used for authentication. If neither &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; nor &lt;code&gt;--smtp-auth&lt;/code&gt; is specified, all mechanisms supported by the SASL library can be used. The special value &lt;code&gt;none&lt;/code&gt; maybe specified to completely disable authentication independently of &lt;code&gt;--smtp-user&lt;/code&gt;</source>
          <target state="translated">Если хотя бы один из указанных механизмов совпадает с механизмами, объявленными сервером SMTP, и если он поддерживается используемой библиотекой SASL, этот механизм используется для аутентификации. Если ни &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; , ни &lt;code&gt;--smtp-auth&lt;/code&gt; не указаны, можно использовать все механизмы, поддерживаемые библиотекой SASL. Специальное значение &lt;code&gt;none&lt;/code&gt; может быть указано для полного отключения аутентификации независимо от &lt;code&gt;--smtp-user&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48ca5fe331a67872cf3424cd090943cee3b1214a" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or a pseudoref like HEAD or ORIG_HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66be204c5192d97175dc2e5a6cea91a845a9494" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or the symbolic ref HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="translated">Если параметр конфигурации &amp;laquo;core.logAllRefUpdates&amp;raquo; имеет значение &amp;laquo;истина&amp;raquo; и ссылка находится под &amp;laquo;refs / heads /&amp;raquo;, &amp;laquo;refs / remotes /&amp;raquo;, &amp;laquo;refs / notes /&amp;raquo; или символической ref HEAD; или существует файл &amp;laquo;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&amp;raquo;, тогда &lt;code&gt;git update-ref&lt;/code&gt; добавит строку в файл журнала &amp;laquo;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&amp;raquo; (разыменование всех символических ссылок перед созданием имени журнала), описывающую изменение значения реф. Строки журнала имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="bb79d7b0840991ebe429aab3a3410932b975f32c" translate="yes" xml:space="preserve">
          <source>If conflicts arise and a strategy for automatically resolving conflicting notes (see the &quot;NOTES MERGE STRATEGIES&quot; section) is not given, the &quot;manual&quot; resolver is used. This resolver checks out the conflicting notes in a special worktree (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to manually resolve the conflicts there. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">Если возникают конфликты и не указана стратегия автоматического разрешения конфликтующих примечаний (см. Раздел &amp;laquo;СТРАТЕГИИ ОБЪЕДИНЕНИЯ ЗАПИСЕЙ&amp;raquo;), используется &amp;laquo;ручной&amp;raquo; преобразователь. Этот преобразователь проверяет конфликтующие заметки в специальном рабочем дереве ( &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ) и инструктирует пользователя вручную разрешить конфликты там. Когда это будет сделано, пользователь может либо завершить слияние с помощью &lt;code&gt;git notes merge --commit&lt;/code&gt; , либо прервать слияние с помощью &lt;code&gt;git notes merge --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02a69db3092fb7486e9bff9ff76c98958fe4d57" translate="yes" xml:space="preserve">
          <source>If core.commitGraph is true, the commit-graph file will also be inspected using &lt;code&gt;git commit-graph verify&lt;/code&gt;. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;.</source>
          <target state="translated">Если core.commitGraph имеет значение true, файл commit-graph также будет проверяться с помощью &lt;code&gt;git commit-graph verify&lt;/code&gt; . См. &lt;a href=&quot;git-commit-graph&quot;&gt;Git-commit-graph [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8280fdd5ec3fb25317b497d70f747c3177f7ef0e" translate="yes" xml:space="preserve">
          <source>If disabled with &quot;--no-thread&quot;, those headers will not be added (unless specified with --in-reply-to). Default is the value of the &lt;code&gt;sendemail.thread&lt;/code&gt; configuration value; if that is unspecified, default to --thread.</source>
          <target state="translated">Если отключено с помощью &amp;laquo;--no-thread&amp;raquo;, эти заголовки не будут добавлены (если не указано с помощью --in-reply-to). По умолчанию это значение конфигурации &lt;code&gt;sendemail.thread&lt;/code&gt; ; если это не указано, по умолчанию --thread.</target>
        </trans-unit>
        <trans-unit id="f00c2d7bc0317e9cad287fad199ae73edff4a848" translate="yes" xml:space="preserve">
          <source>If either &amp;lt;upstream&amp;gt; or --root is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="translated">Если в командной строке задано либо &amp;lt;upstream&amp;gt;, либо --root, то по умолчанию используется &lt;code&gt;--no-fork-point&lt;/code&gt; , иначе &lt;code&gt;--fork-point&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4729a11522c55d49b0e7c329a8805975c4198d9" translate="yes" xml:space="preserve">
          <source>If either of these environment variables is set then &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command-line parameters passed to the configured command are determined by the ssh variant. See &lt;code&gt;ssh.variant&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">Если установлена ​​одна из этих переменных среды, тогда &lt;code&gt;git fetch&lt;/code&gt; и &lt;code&gt;git push&lt;/code&gt; будут использовать указанную команду вместо &lt;code&gt;ssh&lt;/code&gt; , когда им нужно подключиться к удаленной системе. Параметры командной строки, передаваемые настроенной команде, определяются вариантом ssh. См. &lt;code&gt;ssh.variant&lt;/code&gt; параметре ssh.variant в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3669ee4e6fd1ff3473f59b85f73b98bc8093a5f0" translate="yes" xml:space="preserve">
          <source>If enabled the helper should automatically fetch annotated tag objects if the object the tag points at was transferred during the fetch command. If the tag is not fetched by the helper a second fetch command will usually be sent to ask for the tag specifically. Some helpers may be able to use this option to avoid a second network connection.</source>
          <target state="translated">Если включено,то помощник должен автоматически получать аннотированные объекты тегов,если объект,на который указывает тег,был передан при выполнении команды Fetch.Если тэг не был получен помощником,то обычно посылается вторая команда fetch,которая запрашивает именно этот тэг.Некоторые помощники могут использовать эту опцию,чтобы избежать второго сетевого соединения.</target>
        </trans-unit>
        <trans-unit id="27acfa87cdb69a824b9bae48206b42168ffde848" translate="yes" xml:space="preserve">
          <source>If enabled, &lt;code&gt;git p4 submit&lt;/code&gt; will attempt to cleanup RCS keywords ($Header$, etc). These would otherwise cause merge conflicts and prevent the submit going ahead. This option should be considered experimental at present.</source>
          <target state="translated">Если этот параметр включен, &lt;code&gt;git p4 submit&lt;/code&gt; попытается очистить ключевые слова RCS ($ Header $ и т. Д.). В противном случае это могло бы вызвать конфликты слияния и помешать выполнению отправки. В настоящее время этот вариант следует считать экспериментальным.</target>
        </trans-unit>
        <trans-unit id="551059a87916480f640c4e8b1f0ae5467d5d2b16" translate="yes" xml:space="preserve">
          <source>If everything fails, or if no viewer is configured, the viewer specified in the &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; environment variable will be tried. If that fails too, the &lt;code&gt;man&lt;/code&gt; program will be tried anyway.</source>
          <target state="translated">Если что-то не удается или если программа просмотра не настроена, будет использована программа просмотра, указанная в &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; среды GIT_MAN_VIEWER . Если и это не удастся, программа &lt;code&gt;man&lt;/code&gt; все равно будет проверена.</target>
        </trans-unit>
        <trans-unit id="dc951917b8a4344a8f095e91594828b8eb0d132d" translate="yes" xml:space="preserve">
          <source>If explicit refspecs were given on the command line of &lt;code&gt;git pull&lt;/code&gt;, they are all merged.</source>
          <target state="translated">Если в командной строке &lt;code&gt;git pull&lt;/code&gt; были указаны явные refspecs , они все объединяются.</target>
        </trans-unit>
        <trans-unit id="9f9421c37df0f080e8411a466937f35ec8c1d1a5" translate="yes" xml:space="preserve">
          <source>If false, symbolic links are checked out as small plain files that contain the link text. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; will not change the recorded type to regular file. Useful on filesystems like FAT that do not support symbolic links.</source>
          <target state="translated">Если false, символические ссылки извлекаются как небольшие простые файлы, содержащие текст ссылки. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; и &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; не изменят записанный тип на обычный файл. Полезно для файловых систем, таких как FAT, которые не поддерживают символические ссылки.</target>
        </trans-unit>
        <trans-unit id="8463a48927d35802080dff1be147345270adfa9a" translate="yes" xml:space="preserve">
          <source>If false, the ctime differences between the index and the working tree are ignored; useful when the inode change time is regularly modified by something outside Git (file system crawlers and some backup systems). See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. True by default.</source>
          <target state="translated">Если false, различия ctime между индексом и рабочим деревом игнорируются; полезно, когда время изменения inode регулярно изменяется чем-то вне Git (поисковыми роботами файловой системы и некоторыми системами резервного копирования). См. &lt;a href=&quot;git-update-index&quot;&gt;Git-update-index [1]&lt;/a&gt; . По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="c3b2c82ffccecb89175e5c1911567eb5a6cff2f5" translate="yes" xml:space="preserve">
          <source>If fast-import is supplied invalid input it will terminate with a non-zero exit status and create a crash report in the top level of the Git repository it was importing into. Crash reports contain a snapshot of the internal fast-import state as well as the most recent commands that lead up to the crash.</source>
          <target state="translated">Если быстренький импорт поступил с неверными данными,он завершится со статусом ненулевого выхода и создаст отчёт о сбое на верхнем уровне Git-репозитория,в который он импортировал.Отчёты о сбоях содержат снимки внутреннего состояния быстрого импорта,а также самые последние команды,которые привели к сбою.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
