<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">Прерывистый рабочий процесс</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">Введение в &quot;гит-бисект&quot;</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">Интуитивность здесь не цель.Повторяемость-это цель.Причина поведения &quot;отсутствие аргументов означает отсутствие работы&quot; заключается в том,что из сценариев вы должны уметь делать:</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">Вызовите текстовый редактор (см. GIT_EDITOR в &lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt; ), чтобы отредактировать вводное сообщение для серии патчей.</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">Вызов редактора перед совершением успешного механического слияния для дальнейшего редактирования автоматически созданного сообщения слияния, чтобы пользователь мог объяснить и обосновать слияние. Параметр &lt;code&gt;--no-edit&lt;/code&gt; может использоваться для принятия автоматически сгенерированного сообщения (обычно это не рекомендуется).</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">Вызов редактора перед совершением успешного механического слияния для дальнейшего редактирования автоматически созданного сообщения слияния, чтобы пользователь мог объяснить и обосновать слияние. Параметр &lt;code&gt;--no-edit&lt;/code&gt; может использоваться для принятия автоматически сгенерированного сообщения (обычно это не рекомендуется). Параметр &lt;code&gt;--edit&lt;/code&gt; (или &lt;code&gt;-e&lt;/code&gt; ) по-прежнему полезен, если вы даете черновик сообщения с параметром &lt;code&gt;-m&lt;/code&gt; из командной строки и хотите отредактировать его в редакторе.</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">Вызвать перехватчик sendemail-validate, если он присутствует (см. &lt;a href=&quot;githooks&quot;&gt;Githooks [5]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">Вызывается &lt;code&gt;git archive --remote&lt;/code&gt; и отправляет сгенерированный архив на другой конец по протоколу Git.</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">Вызывается &lt;code&gt;git fetch-pack&lt;/code&gt; , узнает, какие объекты отсутствуют на другой стороне, и отправляет их после упаковки.</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">Вызывается &lt;code&gt;git send-pack&lt;/code&gt; и обновляет репозиторий информацией, полученной с удаленного конца.</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">Вызывает &lt;code&gt;git-receive-pack&lt;/code&gt; в возможно удаленном репозитории и обновляет его из текущего репозитория, отправляя именованные ссылки.</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">Вызывает &lt;code&gt;git-upload-pack&lt;/code&gt; в возможно удаленном репозитории и просит его отправить объекты, отсутствующие в этом репозитории, для обновления названных заголовков. Список доступных локально коммитов определяется путем сканирования локальных ссылок / иерархии и отправляется в &lt;code&gt;git-upload-pack&lt;/code&gt; , запущенный на другом конце.</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">Вызов &lt;code&gt;git add -e&lt;/code&gt; или выбор &lt;code&gt;e&lt;/code&gt; в интерактивном селекторе фрагментов откроет патч в вашем редакторе; после выхода из редактора результат применяется к индексу. Вы можете вносить произвольные изменения в патч, но учтите, что некоторые изменения могут привести к запутанным результатам или даже привести к тому, что патч не может быть применен. Если вы хотите полностью прервать операцию (т.е. не добавлять в индекс ничего нового), просто удалите все строки патча. В списке ниже описаны некоторые общие вещи, которые вы можете увидеть в патче, и какие операции редактирования имеют для них смысл.</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">Привлечение специалистов по контролю качества и,по возможности,конечных пользователей.</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">Это синоним &lt;code&gt;zebra&lt;/code&gt; . В будущем это может измениться на более разумный режим.</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">Используется как предлагаемое имя при создании новых веток с помощью &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">Острова настраиваются с помощью параметра &lt;code&gt;pack.island&lt;/code&gt; , который можно указывать несколько раз. Каждое значение - это регулярные выражения с привязкой к левой стороне, соответствующие ссылочным именам. Например:</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">О проблемах, связанных с безопасностью, следует сообщать в частном порядке в список рассылки Git Security &amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">Выдача &lt;code&gt;filedeleteall&lt;/code&gt; с последующей необходимым &lt;code&gt;filemodify&lt;/code&gt; команд , чтобы установить правильное содержание будет производить те же результаты, посылая только необходимое &lt;code&gt;filemodify&lt;/code&gt; и &lt;code&gt;filedelete&lt;/code&gt; команды. &lt;code&gt;filedeleteall&lt;/code&gt; подход , однако , может потребоваться быстро импортировать , чтобы использовать немного больше памяти на активной ветви (менее 1 МиБ даже самых крупных проектов); поэтому интерфейсы, которые могут легко получить только затронутые пути для фиксации, рекомендуется делать это.</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">Он добавляет путь клонирования подмодуля в файл &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; и добавляет этот файл в индекс, готовый к фиксации .</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">Он добавляет текущий идентификатор фиксации подмодуля в индекс, готовый к фиксации.</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">Это влияет на то, как изменение, которое сводится к полной перезаписи файла, не как серия удалений и вставок, смешанных вместе с очень несколькими строками, которые совпадают текстуально как контекст, а как однократное удаление всего старого, за которым следует однократная вставка всего нового, и число &lt;code&gt;m&lt;/code&gt; управляет этим аспектом опции -B (по умолчанию 60%). &lt;code&gt;-B/70%&lt;/code&gt; указывает, что в результате должно оставаться менее 30% оригинала, чтобы Git считал его полной перезаписью (т.е. в противном случае полученный патч будет серией удалений и вставок, смешанных с контекстными строками).</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">Это также позволяет файлу &quot;ref&quot; быть символическим указателем на другой файл ref,начиная с четырехбайтовой последовательности заголовков &quot;ref:&quot;.</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">Он также может быть полезен в скриптах,переданных в &quot;git-бисект run&quot; на &quot;exit 255&quot;,если обнаружена какая-то очень аномальная ситуация.</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">Ввод одних и тех же учетных данных может быть обременительным.Git предоставляет два способа уменьшить это раздражение:</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">Он может быть использован для проверки текущего рабочего дерева и отказа от коммита,если не пройдёт определённого теста.</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">Он может эффективно представлять информацию о конфликтах слияний между различными объектами деревьев,позволяя ассоциировать каждое имя пути с достаточной информацией о задействованных деревьях,чтобы вы могли создать трехстороннее слияние между ними.</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">Он не может показывать более 29 ветвей и коммитов одновременно.</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">Он клонирует подмодуль из &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; в заданный &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; в текущем каталоге и по умолчанию проверяет главную ветвь.</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">Его также можно использовать для регистрации старого ... нового статуса. Однако он не знает всего набора ветвей, поэтому при наивном использовании он в конечном итоге будет запускать одно электронное письмо на ссылку. &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;После приема&lt;/em&gt;&lt;/a&gt; крюка больше подходит для этого.</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">По умолчанию это &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; , который окрашивает все, что старше одного года, синим, последние изменения между месяцем и годом сохраняются белым, а линии, введенные в течение последнего месяца, окрашены в красный цвет.</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">Он делает все возможное,чтобы сделать безопасную вещь,он будет проверять,что файлы остаются неизменными и актуальными в CVS checkout,и он не будет автокомммитироваться по умолчанию.</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">Он делает это,сохраняя некоторые дополнительные данные для каждой записи (например,последнее измененное время).Эти данные не отображаются выше и не хранятся в созданном объекте дерева,но могут быть использованы для быстрого определения того,какие файлы в рабочей директории отличаются от тех,что хранились в индексе,и,таким образом,избавляют Git'а от необходимости считывать все данные из таких файлов для поиска изменений.</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">Это позволяет git работать вместе с монитором файловой системы (см. Раздел &amp;laquo;fsmonitor-watchman&amp;raquo; в &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; ), который может сообщить ему, какие файлы были изменены. Это позволяет git избегать использования lstat () каждого файла для поиска измененных файлов.</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">Ожидается, что он будет иметь дело только с одним проектом. Если он увидит ветви с разными корнями, он откажется бежать. В этом случае отредактируйте параметры &amp;lt;archive / branch&amp;gt;, чтобы четко определить объем импорта.</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">Это помогает разделить эти функции на группы для целей обсуждения.</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">Это &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; , где &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; - это количество секунд с начала эпохи UNIX. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; - положительное или отрицательное смещение от UTC. Например, CET (который на 1 час опережает UTC) составляет &lt;code&gt;+0100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">Можно включать файлы,которые на самом деле не изменились.Все изменения,включая вновь созданные и удаленные файлы,должны быть включены.При переименовании файлов следует включать как старое,так и новое имя.</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">Хорошо бы представиться Git'у с вашим именем и публичным адресом электронной почты перед тем,как делать какие-либо операции.Самый простой способ это сделать:</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">Это приблизительный эквивалент:</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">Также это хорошая идея при использовании любой ВКС,чтобы иметь только одно небольшое логическое изменение в каждом коммите.</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Также разрешено, чтобы ссылка на заметку указывала непосредственно на объект дерева, и в этом случае историю заметок можно прочитать с помощью &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df38f390855a08aaa74243c50bf2cb099b03fbb3" translate="yes" xml:space="preserve">
          <source>It is also possible for perpetually modified files to occur on any platform if a smudge or clean filter is in use on your system but a file was previously committed without running the smudge or clean filter. To fix this, run the following on an otherwise clean working tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">Также можно получить подмножество веток или тегов,используя разделенный запятыми список имен внутри фигурных скобок.Например:</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">Также возможно ввести совершенно новые коммиты слияния с нуля, добавив команду вида &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; . Эта форма будет генерировать предварительное сообщение о фиксации и всегда открывать редактор, позволяющий пользователю редактировать его. Это может быть полезно, например, когда выясняется, что тематическая ветка касается более чем одной проблемы и хочет быть разделена на две или даже более тематических веток. Рассмотрим этот список дел:</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">Также возможно предоставить настоящий CVS-доступ к репозиторию Git, чтобы разработчики по-прежнему могли использовать CVS; подробнее см. &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">Также можно заменить коммиты на более ранний этап истории, но это более сложная тема, которую следует оставить для &lt;a href=&quot;#cleaning-up-history&quot;&gt;другой главы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">Он также запускается после &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; , если не используется параметр &lt;code&gt;--no-checkout&lt;/code&gt; ( &lt;code&gt;-n&lt;/code&gt; ). Первым параметром, передаваемым ловушке, является null-ref, вторым - ref нового HEAD, а флаг всегда равен 1. Аналогично для &lt;code&gt;git worktree add&lt;/code&gt; , если не используется &lt;code&gt;--no-checkout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">Это ошибка, если &amp;lt;dst&amp;gt; соответствует более чем одной удаленной ссылке.</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">Это ошибка, если &amp;lt;src&amp;gt; не соответствует точно одному из локальных ссылок.</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">Ошибкой является указание ссылки,которая не проходит проверку &quot;git check-reformat&quot;.Дублированные значения фильтруются.</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">Предполагается,что любые процедуры рукопожатия уже были завершены (например,отправка служебного запроса на git://)до того,как был запущен этот помощник.</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">В настоящее время возможно воссоздать коммиты слияния только с использованием стратегии &lt;code&gt;recursive&lt;/code&gt; слияния; Различные стратегии слияния можно использовать только с помощью явных команд &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">Предполагается,что содержимое объекта коммита,который вы создали,следуя приведённому выше примеру,генерирует SHA-1 хэш,отличный от приведённого выше,так как объект коммита записывает время,когда он был создан,и имя человека,выполняющего коммит.</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">За ним следуют одна или несколько расширенных строк заголовка (в этом примере показано слияние с двумя родителями):</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">За ней следуют одна или несколько расширенных строк заголовка:</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">За ним следует двухстрочный заголовок из файла/в файл.</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">Он очень функциональный.Однако,не все методы реализованы,а для тех методов,которые реализованы,реализованы не все коммутаторы.</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">Важно понимать, что на данный момент ничто не относится к фиксации &lt;code&gt;f&lt;/code&gt; . В конечном итоге фиксация &lt;code&gt;f&lt;/code&gt; (и по расширению фиксация &lt;code&gt;e&lt;/code&gt; ) будет удалена стандартным процессом сборки мусора Git, если мы не создадим ссылку до того, как это произойдет. Если мы еще не отошли от коммита &lt;code&gt;f&lt;/code&gt; , любой из них создаст ссылку на него:</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">Вполне вероятно, что время от времени вы будете получать данные из одного и того же удаленного репозитория. Вкратце, вы можете сохранить URL удаленного репозитория в файле конфигурации локального репозитория следующим образом:</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">Скорее всего,вы будете работать над несколькими вещами одновременно.С Git'ом легко управлять этими более или менее независимыми задачами,используя ветки.</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">Новым разработчикам не всегда легко разобраться в исходном коде Git. Этот раздел дает вам небольшое руководство, чтобы показать, с чего начать.</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">Не рекомендуется использовать эту функцию, если вы собираетесь позже снова экспортировать изменения обратно в CVS с помощью &lt;code&gt;git cvsexportcommit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">Очевидно,что не стоит делать коммиты с изменениями,которые сознательно ломают вещи,даже если некоторые другие коммиты позже исправят поломку.</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">Возможно, что ошибка слияния помешает этому процессу стать полностью автоматическим. Вам нужно будет устранить любой такой сбой слияния и запустить &lt;code&gt;git rebase --continue&lt;/code&gt; . Другой вариант - обойти фиксацию, вызвавшую сбой слияния, с помощью &lt;code&gt;git rebase --skip&lt;/code&gt; . Чтобы проверить исходный &amp;lt;branch&amp;gt; и удалить рабочие файлы .git / rebase-apply, используйте вместо этого команду &lt;code&gt;git rebase --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">Эти старые репозитории форм можно построить вручную.</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">Можно отключить использование заменяющих ссылок для любой команды с помощью параметра &lt;code&gt;--no-replace-objects&lt;/code&gt; сразу после &lt;code&gt;git&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">Ему предшествует заголовок &quot;git diff&quot;,который выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">Ему предшествует заголовок &quot;git diff&quot;, который выглядит следующим образом (при использовании параметра &lt;code&gt;-c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">Это чисто оптимизация производительности,изначально предназначенная для MacOS X,где рекурсивный обход каталогов происходит медленно.Gitweb следует по символическим ссылкам,но обнаруживает циклы,игнорируя любые дубликаты файлов и каталогов.</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">Рекомендуется всегда кодировать &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; с использованием UTF-8.</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">Безопаснее, если оба &lt;code&gt;test.sh&lt;/code&gt; и &lt;code&gt;check_test_case.sh&lt;/code&gt; находятся вне репозитория, чтобы предотвратить взаимодействие между процессами bisect, make и test и скриптами.</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">Иногда бывает полезно иметь возможность проверить фиксацию, которая не находится на вершине какой-либо именованной ветки, или даже создать новую фиксацию, на которую не ссылается именованная ветвь. Давайте посмотрим, что происходит, когда мы проверяем фиксацию &lt;code&gt;b&lt;/code&gt; (здесь мы показываем два способа сделать это):</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">Вы по-прежнему обязаны убедиться, что электронное сообщение, отправленное вашей почтовой программой, соответствует стандартам вашего проекта. Многие проекты не любят прикреплять патчи. Некоторые почтовые агенты будут преобразовывать исправления (например, переносить строки, отправлять их как format = flowed) таким образом, чтобы они не работали. Вы получите сердитое пламя, высмеивающее вас, если вы не отметите это.</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">Маловероятно, что здесь возникнут какие-либо конфликты ... но они могут быть, если вы потратите некоторое время на этот шаг и также загрузите новые версии из апстрима.</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">Пользователь должен убедиться, что заголовок In-Reply-To уже не существует, когда &lt;code&gt;git send-email&lt;/code&gt; просит добавить его (особенно обратите внимание, что &lt;code&gt;git format-patch&lt;/code&gt; может быть настроен для выполнения самой потоковой передачи). Невыполнение этого требования может не привести к ожидаемому результату в MUA получателя.</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">Это полезно, когда вы ищете точный блок кода (например, структуру) и хотите узнать историю этого блока с момента его появления: используйте эту функцию итеративно, чтобы передать интересный блок в прообразе обратно в &lt;code&gt;-S&lt;/code&gt; , и продолжайте, пока не получите самую первую версию блока.</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">Очень важно,чтобы используемая база находилась в месте назначения.Нормально ошибиться на стороне предостережения,вызывая файл пакета для того чтобы содержать объекты уже в месте назначения,так как они игнорируются при распаковке на месте назначения.</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">Вполне возможно, что люди, работающие в сети, могут захотеть обмениваться тегами внутри своей группы, но в этом рабочем процессе они, скорее всего, отслеживают прогресс друг друга, имея ветки удаленного отслеживания. Опять же, эвристика автоматического отслеживания таких тегов - это хорошо.</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">Он должен быть читабельным для того,чтобы,от начала и до конца,кто-то умный,обладающий базовыми знаниями о командной строке UNIX,но не обладающий какими-либо специальными знаниями о Git'е.При необходимости следует особо упомянуть любые другие предпосылки по мере их возникновения.</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">Следует подчеркнуть, что эта иерархия носит чисто &lt;strong&gt;неформальный характер&lt;/strong&gt; . В Git нет ничего фундаментального, что навязывало бы &amp;laquo;цепочку потока исправлений&amp;raquo;, которую подразумевает эта иерархия. Вам не нужно использовать только один удаленный репозиторий.</target>
        </trans-unit>
        <trans-unit id="7beffad8901e95a09a82e88d22525a3cad3065d8" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add--interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">Он показывает, что foo.png имеет отличия от HEAD (но он является двоичным, поэтому количество строк не может быть показано), и нет разницы между индексированной копией и версией рабочего дерева (если бы версия рабочего дерева также была другой, &lt;code&gt;binary&lt;/code&gt; был бы показан вместо &lt;code&gt;nothing&lt;/code&gt; ). В другой файл, git-add {litdd} interactive.perl, добавлено 403 строки и удалено 35 строк, если вы фиксируете то, что находится в индексе, но рабочий файл дерева имеет дальнейшие изменения (одно добавление и одно удаление).</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">Потребуется переменное количество параметров,каждый из которых является именем ссылки,которая была фактически обновлена.</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">Он принимает на стандартный ввод спецификацию параметров для синтаксического анализа и понимания и выводит на стандартный вывод строку, подходящую для &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; , чтобы заменить аргументы нормализованными. В случае ошибки он выводит использование в стандартном потоке ошибок и завершает работу с кодом 129.</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">Требуется от одного до трех параметров. Первый - это имя файла, содержащего сообщение журнала фиксации. Второй является источником сообщения фиксации и может быть: &lt;code&gt;message&lt;/code&gt; (если была указана опция &lt;code&gt;-m&lt;/code&gt; или &lt;code&gt;-F&lt;/code&gt; ); &lt;code&gt;template&lt;/code&gt; (если была указана опция &lt;code&gt;-t&lt;/code&gt; или задана опция конфигурации &lt;code&gt;commit.template&lt;/code&gt; ); &lt;code&gt;merge&lt;/code&gt; (если фиксация является слиянием или существует файл &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; ); &lt;code&gt;squash&lt;/code&gt; (если существует файл &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; ); или &lt;code&gt;commit&lt;/code&gt; , за которой следует фиксация SHA-1 (если &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; или &lt;code&gt;--amend&lt;/code&gt; был дан вариант).</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">Он сообщает вам, что было выполнено &amp;laquo;автоматическое объединение&amp;raquo;, которое не удалось из-за конфликтов в &lt;code&gt;hello&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">Раньше считалось, что команда по умолчанию выполняла &lt;code&gt;-x&lt;/code&gt; ,как описано выше, а &lt;code&gt;-r&lt;/code&gt; должна была отключить ее. Теперь по умолчанию не используется &lt;code&gt;-x&lt;/code&gt; , поэтому эта опция не работает.</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">Он использует многозначные элементы конфигурации &lt;code&gt;showbranch.default&lt;/code&gt; , если в командной строке не заданы &amp;lt;rev&amp;gt; или &amp;lt;glob&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">Он проверяет, что в каталоге есть волшебный файл &quot;git-daemon-export-ok&quot;, и откажется экспортировать любой каталог Git, который не был явно отмечен для экспорта таким образом (если не &lt;code&gt;--export-all&lt;/code&gt; параметр --export-all ). Если вы передаете некоторые пути к каталогам в качестве аргументов &lt;code&gt;git daemon&lt;/code&gt; , вы можете дополнительно ограничить предложения до белого списка, состоящего из них.</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">Он проверяет, что в каталоге есть волшебный файл &quot;git-daemon-export-ok&quot;, и откажется экспортировать любой каталог Git, который не был явно отмечен для экспорта таким образом (если не &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; переменная среды GIT_HTTP_EXPORT_ALL ).</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">Это был крайний инструмент. Я бы лучше потратил дни на просмотр вывода printk, чем на ручное деление заплаток &lt;code&gt;patch bisection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">Будет полезно иметь Git-репозиторий для экспериментов,пока вы читаете это руководство.</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">Также возможен сбой принудительной отправки, когда другие люди имеют право на отправку в тот же репозиторий. В этом случае правильное решение - повторить отправку после первого обновления вашей работы: либо путем вытягивания, либо путем выборки с последующей перебазированием; см. &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;следующий раздел&lt;/a&gt; и &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="fb4f6e12e9b3bc515593c3c6f58a010f2584b187" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to remove one of the files such that you only have one file. You can do this with commands like the following (assuming two files &lt;code&gt;AFile.txt&lt;/code&gt; and &lt;code&gt;afile.txt&lt;/code&gt;) on an otherwise clean working tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ec6258a88fcfa8b2ee5adddb372d62ea174c2e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to try to use &lt;code&gt;pre-commit&lt;/code&gt; hooks (or, for commit messages, &lt;code&gt;commit-msg&lt;/code&gt; hooks) to check these things, which is great if you&amp;rsquo;re working as a solo developer and want the tooling to help you. However, using hooks on a developer machine is not effective as a policy control because a user can bypass these hooks with &lt;code&gt;--no-verify&lt;/code&gt; without being noticed (among various other ways). Git assumes that the user is in control of their local repositories and doesn&amp;rsquo;t try to prevent this or tattle on the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">Особенно поучительно смотреть на объекты &quot;фиксации&quot;, поскольку они, как правило, маленькие и не требуют пояснений. В частности, если вы следуете соглашению о том, что имя верхнего коммита в &lt;code&gt;.git/HEAD&lt;/code&gt; , вы можете сделать</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">Слишком легко случайно перепутать старую и новую историю. Это все еще возможно с любым инструментом, но git-filter-branch почти приглашает его. Если повезет, единственным недостатком будет разочарование пользователей из-за того, что они не знают, как уменьшить размер своего репо и удалить старые вещи. Если не повезло, они объединяют старую и новую историю и в итоге получают несколько &amp;laquo;копий&amp;raquo; каждой фиксации, некоторые из которых содержат нежелательные или конфиденциальные файлы, а другие - нет. Это происходит несколькими способами:</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; небезопасно, если вы внесли и зафиксировали изменения в подмодуле, не проверив сначала ветку. Они будут тихо перезаписаны:</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">Можно поместить любой тип объекта в любое пространство имен за пределами &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; . В случае тегов и коммитов они будут обрабатываться, как если бы они были коммитами внутри &lt;code&gt;refs/heads/*&lt;/code&gt; , чтобы определить, разрешено ли обновление.</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">Вероятно, не стоит использовать эту опцию в данном репозитории, не выполняя для него специальные тесты производительности. Это занимает гораздо больше времени, и итоговая оптимизация пространства / дельты может того стоить, а может и не стоить. Не использовать это вообще - верный компромисс для большинства пользователей и их репозиториев.</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">Разумно, например, настроить &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; в &lt;code&gt;~/.gitconfig&lt;/code&gt; , чтобы теги удалялись каждый раз при &lt;code&gt;git fetch --prune&lt;/code&gt; , не выполняя каждый вызов &lt;code&gt;git fetch&lt;/code&gt; без &lt;code&gt;--prune&lt;/code&gt; с ошибкой.</target>
        </trans-unit>
        <trans-unit id="bb5eba09f5b7ed44896e1f2e304b6636d8012774" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s tempting to try to use certain features of &lt;code&gt;git update-index&lt;/code&gt;, namely the assume-unchanged and skip-worktree bits, but these don&amp;rsquo;t work properly for this purpose and shouldn&amp;rsquo;t be used this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">Обычно гораздо чаще происходит слияние с кем-то другим, чем слияние со своими собственными ветвями, поэтому стоит отметить, что Git также делает это очень простым, и на самом деле это не так уж отличается от &lt;code&gt;git merge&lt;/code&gt; . Фактически, удаленное слияние заканчивается не чем иным, как &amp;laquo;извлечением работы из удаленного репозитория во временный тег&amp;raquo; с последующим &lt;code&gt;git merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">Перебрать все ссылки, соответствующие &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; , и показать их в соответствии с заданным &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; после сортировки в соответствии с заданным набором &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; . Если задано &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; , остановитесь после показа такого количества ссылок. Интерполированные значения в &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; могут быть дополнительно заключены в кавычки как строковые литералы на указанном главном языке, что позволяет их прямую оценку на этом языке.</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">Присоедините вместе две или более истории развития</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">Так же, как файловая система &lt;code&gt;.&lt;/code&gt; (точка) относится к текущему каталогу с использованием &lt;code&gt;.&lt;/code&gt; поскольку имя репозитория в Git (точечный репозиторий) является относительным путем и означает ваш текущий репозиторий.</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">Просто выполнение &lt;code&gt;git checkout-index&lt;/code&gt; ничего не делает. Вы, наверное, имели в виду &lt;code&gt;git checkout-index -a&lt;/code&gt; . И если вы хотите заставить его, вам нужно &lt;code&gt;git checkout-index -f -a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af0df6a1820c3268e00c2212c3d633096817d6ad" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the &lt;code&gt;--merge-base&lt;/code&gt; case and in the last two forms that use &lt;code&gt;..&lt;/code&gt; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">На всякий случай, если вы делаете что-то экзотическое, следует отметить, что все &amp;lt;commit&amp;gt; в приведенном выше описании, за исключением двух последних форм, в которых используются обозначения &amp;laquo;..&amp;raquo;, могут быть любыми &amp;lt;tree&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">Так же, как и &lt;code&gt;push&lt;/code&gt; , пакетная последовательность из одного или нескольких &lt;code&gt;import&lt;/code&gt; заканчивается пустой строкой. Для каждого пакета &lt;code&gt;import&lt;/code&gt; удаленный помощник должен создавать поток быстрого импорта, завершаемый командой &lt;code&gt;done&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">Просто не забудьте отключить перенос строк в почтовом клиенте (веб-интерфейс GMail будет переносить строки независимо от того, что, поэтому вам нужно использовать настоящий клиент IMAP).</target>
        </trans-unit>
        <trans-unit id="40ff32435dadcaf90c9ed938f5946c67e774e649" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (Gmail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">Ведите список репозиториев,с которыми вы регулярно работаете:</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">Сохранять изменения в рабочем дереве во время отбрасывания некоторых предыдущих коммитов</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">Продолжайте скачивать пакет.</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">Имейте в виду , что &lt;code&gt;*&lt;/code&gt; (звездочка) подстановочные местного исх (справа из &lt;code&gt;:&lt;/code&gt; ) &lt;strong&gt;должен&lt;/strong&gt; быть самый дальний правый компонент пути; однако удаленный подстановочный знак может быть где угодно, если он является независимым компонентом пути (окруженным &lt;code&gt;/&lt;/code&gt; или EOL). Этот тип конфигурации не создается автоматически программой &lt;code&gt;init&lt;/code&gt; и должен вводиться вручную с помощью текстового редактора или с помощью &lt;code&gt;git config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">Продолжайте повторять процесс: скомпилируйте дерево, протестируйте его и, в зависимости от того, хорошее оно или плохое, запустите &lt;code&gt;git bisect good&lt;/code&gt; или &lt;code&gt;git bisect bad&lt;/code&gt; , чтобы запросить следующую фиксацию, требующую тестирования.</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">Хранить коммиты,которые ничего не меняют от своих родителей в результате.</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">Сохраните текущее содержимое индекса и прочитайте содержимое именованного дерева в каталоге &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; . Команда откажется перезаписывать записи, которые уже существовали в исходном индексном файле.</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">Держите версию из вашей ветки в рабочем дереве,но оставьте путь в конфликтном состоянии,чтобы пользователь мог его разобрать.</target>
        </trans-unit>
        <trans-unit id="f9e507eaf43dc998f773c565be5cccbd49c418b4" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without a race condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">После создания оставьте рабочее дерево заблокированным. Это эквивалент &lt;code&gt;git worktree lock&lt;/code&gt; после &lt;code&gt;git worktree add&lt;/code&gt; , но без состояния гонки.</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">Храните недоступные предметы в свободной форме. Это означает &lt;code&gt;--revs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">Продолжайте работать в вашем первичном репозитории.Ваши изменения включают в себя изменения в вашем собственном репозитории,исправления,которые вы получаете по электронной почте,и слияния,возникающие в результате переноса &quot;публичных&quot; репозиториев вашего &quot;ведущего проекта&quot; и,возможно,ваших &quot;мейнтейнеров подсистемы&quot;.</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">Продолжайте работать в вашем первичном репозитории.Ваши изменения включают в себя изменения в вашем собственном репозитории,исправления,которые вы получаете по электронной почте,и слияния,возникающие в результате переноса &quot;публичных&quot; репозиториев ваших &quot;мейнтейнеров подсистемы&quot;.</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">Поддержание серии патчей в актуальном состоянии с использованием git-ребейза.</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">Kill ключевые слова: будет извлекать файлы с &lt;code&gt;-kk&lt;/code&gt; из архива CVS, чтобы избежать шумных наборов изменений. Настоятельно рекомендуется, но по умолчанию отключено, чтобы сохранить совместимость с ранее импортированными деревьями.</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">Ярлык для &amp;laquo;домашней ссылки&amp;raquo; вверху всех страниц, ведущий к &lt;code&gt;$home_link&lt;/code&gt; (обычно это главная страница gitweb, которая содержит список проектов). Он используется в качестве первого компонента &amp;laquo;цепочки навигации&amp;raquo; gitweb: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; . Может быть установлено во время сборки с &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; переменной GITWEB_HOME_LINK_STR . По умолчанию это &amp;laquo;проекты&amp;raquo;, так как эта ссылка ведет к списку проектов. Другой популярный вариант - установить его по имени сайта. Обратите внимание, что он обрабатывается как необработанный HTML, поэтому его не следует устанавливать из ненадежных источников.</target>
        </trans-unit>
        <trans-unit id="f135ec40c7a65e232b6284c7eadaae14bc4ec8e7" translate="yes" xml:space="preserve">
          <source>Labelling of conflicts markers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b52717c24503e82535f1da97544e03ef42f759" translate="yes" xml:space="preserve">
          <source>Large projects are often composed of smaller, self-contained modules. For example, an embedded Linux distribution&amp;rsquo;s source tree would include every piece of software in the distribution with some local modifications; a movie player might need to build against a specific, known-working version of a decompression library; several independent programs might all share the same build scripts.</source>
          <target state="translated">Большие проекты часто состоят из небольших автономных модулей. Например, дерево исходных кодов встроенного дистрибутива Linux будет включать все программы в дистрибутиве с некоторыми локальными модификациями; проигрывателю фильмов может потребоваться сборка на основе конкретной, заведомо работающей версии библиотеки декомпрессии; несколько независимых программ могут использовать одни и те же сценарии сборки.</target>
        </trans-unit>
        <trans-unit id="eebf4c31734b36e391dbec8f9bdc861cf73858fc" translate="yes" xml:space="preserve">
          <source>Later, Bob can update his repo with Alice&amp;rsquo;s latest changes using</source>
          <target state="translated">Позже Боб может обновить свое репо последними изменениями Алисы, используя</target>
        </trans-unit>
        <trans-unit id="b67e320eff785b446a82207f60f64bae4d9398b2" translate="yes" xml:space="preserve">
          <source>Later, you can see whether your changes have been applied by saying (still on &lt;code&gt;topic&lt;/code&gt;):</source>
          <target state="translated">Позже вы сможете увидеть, были ли применены ваши изменения, сказав (все еще по &lt;code&gt;topic&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0c480c6f24e2582817904a3ca717bfe059eaf9ba" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;Re:&lt;/code&gt;, &lt;code&gt;re:&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Ведущий &lt;code&gt;Re:&lt;/code&gt; , &lt;code&gt;re:&lt;/code&gt; и &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cba31f4e857a58fc5d56324b4f5b7ba501d5431" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace are ignored.</source>
          <target state="translated">Ведущие и отстающие пробелы игнорируются.</target>
        </trans-unit>
        <trans-unit id="9400d93a0e4bf560ae2ff2a8521028a1c12485de" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace.</source>
          <target state="translated">Ведущий и отстающий белый пробел.</target>
        </trans-unit>
        <trans-unit id="b0ca289dea1d9e545043917d0313a90afe03b7b2" translate="yes" xml:space="preserve">
          <source>Leading bracketed strings (between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, usually &lt;code&gt;[PATCH]&lt;/code&gt;).</source>
          <target state="translated">Ведущие строки в квадратных скобках (между &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; , обычно &lt;code&gt;[PATCH]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f2cfa3cf0fb13a4db7434c1da2b8c70142683de" translate="yes" xml:space="preserve">
          <source>Leaving this value at the default size is fine unless you know that either the remote server or a proxy in the middle doesn&amp;rsquo;t support HTTP/1.1 (which introduced the chunked transfer encoding) or is known to be broken with chunked data. This is often (erroneously) suggested as a solution for generic push problems, but since almost every server and proxy supports at least HTTP/1.1, raising this value usually doesn&amp;rsquo;t solve most push problems. A server or proxy that didn&amp;rsquo;t correctly support HTTP/1.1 and chunked transfer encoding wouldn&amp;rsquo;t be that useful on the Internet today, since it would break lots of traffic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5fae931542a3559bb8c0d5b861a24e60a1ac67c" translate="yes" xml:space="preserve">
          <source>Left-, middle-, or right-align the content between %(align:&amp;hellip;​) and %(end). The &quot;align:&quot; is followed by &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; and &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; in any order separated by a comma, where the &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; is either left, right or middle, default being left and &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; is the total length of the content with alignment. For brevity, the &quot;width=&quot; and/or &quot;position=&quot; prefixes may be omitted, and bare &amp;lt;width&amp;gt; and &amp;lt;position&amp;gt; used instead. For instance, &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt;. If the contents length is more than the width then no alignment is performed. If used with &lt;code&gt;--quote&lt;/code&gt; everything in between %(align:&amp;hellip;​) and %(end) is quoted, but if nested then only the topmost level performs quoting.</source>
          <target state="translated">Выровняйте содержимое по левому, среднему или правому краю между% (align:&amp;hellip;) и% (end). За &quot;align:&quot; следуют &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; и &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; в любом порядке, разделенные запятой, где &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; - левый, правый или средний, по умолчанию - left, а &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; - общее длина содержимого с выравниванием. Для краткости префиксы &amp;laquo;width =&amp;raquo; и / или &amp;laquo;position =&amp;raquo; могут быть опущены, и вместо них используются пустые &amp;lt;width&amp;gt; и &amp;lt;position&amp;gt;. Например, &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt; . Если длина содержимого больше ширины, выравнивание не выполняется. При использовании с &lt;code&gt;--quote&lt;/code&gt; все между% (align:&amp;hellip;) и% (end) цитируется,но если они вложены, то цитирование выполняется только на самом верхнем уровне.</target>
        </trans-unit>
        <trans-unit id="4913da5c2a93f28cfca5df10654d75686a764062" translate="yes" xml:space="preserve">
          <source>Legacy alias for &lt;code&gt;--smtp-encryption ssl&lt;/code&gt;.</source>
          <target state="translated">Устаревший псевдоним для &lt;code&gt;--smtp-encryption ssl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c79d7d578b1dfedd061424fe06d7bbd7bf7860a" translate="yes" xml:space="preserve">
          <source>Legacy monitoring operations are not supported (edit, watch and related). Exports and tagging (tags and branches) are not supported at this stage.</source>
          <target state="translated">Операции мониторинга наследия не поддерживаются (редактирование,просмотр и связанные с ними).Экспорт и маркировка (теги и ветки)на данном этапе не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="efdb524a0ef0e2256e12ca50686b4d8bc222c208" translate="yes" xml:space="preserve">
          <source>Lesson three is: study the code. Really, it is the best way to learn about the organization of Git (after you know the basic concepts).</source>
          <target state="translated">Урок третий:изучить код.Действительно,это лучший способ узнать об организации Git'а (после того,как вы познакомитесь с основными понятиями).</target>
        </trans-unit>
        <trans-unit id="893b35eb2ef36c307a5615060033f2510cf02d9b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also suppose that we have a cleaned up graph like one after step 1) in the bisection algorithm above. This means that we can measure the information we get in terms of number of commit we can remove from the graph..</source>
          <target state="translated">Давайте также предположим, что у нас есть очищенный граф, подобный тому, что был после шага 1) в приведенном выше алгоритме деления пополам. Это означает, что мы можем измерить информацию, которую мы получаем, с точки зрения количества коммитов, которые мы можем удалить с графика.</target>
        </trans-unit>
        <trans-unit id="c8d0e17bfd7a63329a6082665d278b7fb499b0b6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s skip over the obvious details; the only really interesting part here is the call to &lt;code&gt;get_sha1()&lt;/code&gt;. It tries to interpret &lt;code&gt;argv[2]&lt;/code&gt; as an object name, and if it refers to an object which is present in the current repository, it writes the resulting SHA-1 into the variable &lt;code&gt;sha1&lt;/code&gt;.</source>
          <target state="translated">Давайте пропустим очевидные детали; единственная действительно интересная часть здесь - это вызов &lt;code&gt;get_sha1()&lt;/code&gt; . Он пытается интерпретировать &lt;code&gt;argv[2]&lt;/code&gt; как имя объекта, и если он ссылается на объект, который присутствует в текущем репозитории, он записывает полученный SHA-1 в переменную &lt;code&gt;sha1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9abf37f1be76cb29eb48ded27f1fe2938a8b22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project and create a small amount of history:</source>
          <target state="translated">Давайте начнем новый проект и создадим небольшую историю:</target>
        </trans-unit>
        <trans-unit id="f0d62f9783a955198cc607ca11b36e935a346c02" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the following graph as an example:</source>
          <target state="translated">Возьмем для примера следующий график:</target>
        </trans-unit>
        <trans-unit id="1c0b60e2ec5a47fbbf8d5055a8c4fd552a20bdbd" translate="yes" xml:space="preserve">
          <source>Lets you rewrite Git revision history by rewriting the branches mentioned in the &amp;lt;rev-list options&amp;gt;, applying custom filters on each revision. Those filters can modify each tree (e.g. removing a file or running a perl rewrite on all files) or information about each commit. Otherwise, all information (including original commit times or merge information) will be preserved.</source>
          <target state="translated">Позволяет вам переписать историю ревизий Git, переписав ветви, упомянутые в &amp;lt;rev-list options&amp;gt;, применяя настраиваемые фильтры к каждой ревизии. Эти фильтры могут изменять каждое дерево (например, удалять файл или выполнять перезапись Perl для всех файлов) или информацию о каждой фиксации. В противном случае вся информация (включая исходное время фиксации или информацию о слиянии) будет сохранена.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="c20b9e30add4d8fcb9e944c3a79357b0eb58faf9" translate="yes" xml:space="preserve">
          <source>Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;.</source>
          <target state="translated">Как и --allow-empty, эта команда в первую очередь предназначена для использования скриптами внешнего интерфейса SCM. Он позволяет вам создать фиксацию с пустым сообщением фиксации без использования команд, таких как &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f6f49e5a6f1778648e9730643fd43474f2dbc13" translate="yes" xml:space="preserve">
          <source>Like --get-all, but interprets the name as a regular expression and writes out the key names. Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not.</source>
          <target state="translated">Подобно --get-all,но интерпретирует имя как регулярное выражение и записывает ключевые имена.Подгонка регулярных выражений в настоящее время чувствительна к регистру и осуществляется против канонизированной версии ключа,в которой имена секций и переменных выражены в нижнем регистре,а имена подразделов-нет.</target>
        </trans-unit>
        <trans-unit id="f93e6625e77c19d6664d2e45faf25a33780dbe37" translate="yes" xml:space="preserve">
          <source>Like --import-marks but instead of erroring out, silently skips the file if it does not exist.</source>
          <target state="translated">Как и --import-mark,но вместо того,чтобы выдать ошибку,молча пропускает файл,если он не существует.</target>
        </trans-unit>
        <trans-unit id="0eda32196b28e34b5200ae38915b28d72ba0802b" translate="yes" xml:space="preserve">
          <source>Like --import-marks except in two respects: first, only one &quot;feature import-marks&quot; or &quot;feature import-marks-if-exists&quot; command is allowed per stream; second, an --import-marks= or --import-marks-if-exists command-line option overrides any of these &quot;feature&quot; commands in the stream; third, &quot;feature import-marks-if-exists&quot; like a corresponding command-line option silently skips a nonexistent file.</source>
          <target state="translated">Подобно --import-marks,за исключением двух аспектов:во-первых,в потоке разрешена только одна команда &quot;import-mark&quot; или &quot;feature import-mark-if-exists&quot;;во-вторых,опция командной строки --import-marks=или --import-mark-if-exists переопределяет любую из этих команд &quot;feature&quot; в потоке;в-третьих,опция &quot;feature import-marks-if-exists&quot;,подобно соответствующей опции командной строки,беззвучно пропускает несуществующий файл.</target>
        </trans-unit>
        <trans-unit id="ea166a12e166b75ad46458f975797a03647dc62d" translate="yes" xml:space="preserve">
          <source>Like --keep create a .keep file before moving the index into its final destination, but rather than creating an empty file place &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; followed by an LF into the .keep file. The &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; message can later be searched for within all .keep files to locate any which have outlived their usefulness.</source>
          <target state="translated">Подобно --keep создать файл .keep перед перемещением индекса в его конечное место назначения, но вместо того, чтобы создавать пустое место файла &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; , за которым следует LF в файле .keep. Сообщение &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; позже можно будет найти во всех файлах .keep, чтобы найти те, которые утратили свою полезность.</target>
        </trans-unit>
        <trans-unit id="da58772c0d323657b31dd0d6c68daa01b72022dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--cherry-pick&lt;/code&gt; (see below) but mark equivalent commits with &lt;code&gt;=&lt;/code&gt; rather than omitting them, and inequivalent ones with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;--cherry-pick&lt;/code&gt; (см. Ниже), но эквивалентные коммиты помечаются знаком &lt;code&gt;=&lt;/code&gt; , а не опускаются, а неэквивалентные - знаком &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b014ee75198b1ce501d5b1546fe06cd49ddd23" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--git-dir&lt;/code&gt;, but its output is always the canonicalized absolute path.</source>
          <target state="translated">Подобно &lt;code&gt;--git-dir&lt;/code&gt; , но его вывод всегда является канонизированным абсолютным путем.</target>
        </trans-unit>
        <trans-unit id="af1d4315bb510027eb7e61b588f2b477e26e55d4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--refresh&lt;/code&gt;, but checks stat information unconditionally, without regard to the &quot;assume unchanged&quot; setting.</source>
          <target state="translated">&lt;code&gt;--refresh&lt;/code&gt; , что и --refresh , но проверяет статистическую информацию безоговорочно, без учета настройки &amp;laquo;предполагать неизменность&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="649d7b810a2269259a3e3571033e0da598ccd04e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the commit message.</source>
          <target state="translated">Как &lt;code&gt;-C&lt;/code&gt; , но с &lt;code&gt;-c&lt;/code&gt; вызывается редактор, чтобы пользователь мог дальше редактировать сообщение фиксации.</target>
        </trans-unit>
        <trans-unit id="72f500fc1c4bd05ad014fbedf9cd9b9fb51f168b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the note message.</source>
          <target state="translated">Подобно &lt;code&gt;-C&lt;/code&gt; , но с &lt;code&gt;-c&lt;/code&gt; вызывается редактор, чтобы пользователь мог дальше редактировать сообщение заметки.</target>
        </trans-unit>
        <trans-unit id="f749f3d3ddfe6600b3752ee19e4bd9b6731f362f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;email&lt;/code&gt;, but lines in the commit message starting with &quot;From &quot; (preceded by zero or more &quot;&amp;gt;&quot;) are quoted with &quot;&amp;gt;&quot; so they aren&amp;rsquo;t confused as starting a new commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2734a31de3aa99c55dc536f672e3afeacd6e67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; this variable has corresponding &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variants.</source>
          <target state="translated">Как и &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ,у этой переменной есть соответствующие &lt;code&gt;receive.fsck.skipList&lt;/code&gt; и &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f4973bf138d30d1fbff518822c72869393d6ab3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, imports handled by fast-import are safe to run alongside parallel &lt;code&gt;git repack -a -d&lt;/code&gt; or &lt;code&gt;git gc&lt;/code&gt; invocations, or any other Git operation (including &lt;code&gt;git prune&lt;/code&gt;, as loose objects are never used by fast-import).</source>
          <target state="translated">Подобно &lt;code&gt;git push&lt;/code&gt; или &lt;code&gt;git fetch&lt;/code&gt; , импорт, обрабатываемый fast-import, можно безопасно запускать вместе с параллельными &lt;code&gt;git repack -a -d&lt;/code&gt; или &lt;code&gt;git gc&lt;/code&gt; , или любой другой операцией Git (включая &lt;code&gt;git prune&lt;/code&gt; , поскольку свободные объекты никогда не используются быстрым импортом ).</target>
        </trans-unit>
        <trans-unit id="c7a0caab42cb430b8f7eb62e2b9ee91196438e5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git rebase&lt;/code&gt;; this requires that the working tree be clean and have no uncommitted changes.</source>
          <target state="translated">Как &lt;code&gt;git rebase&lt;/code&gt; ; для этого необходимо, чтобы рабочее дерево было чистым и не содержало незафиксированных изменений.</target>
        </trans-unit>
        <trans-unit id="94b902a35ff412729993e3558dc74f40d9a138f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;mailmap.file&lt;/code&gt;, but consider the value as a reference to a blob in the repository. If both &lt;code&gt;mailmap.file&lt;/code&gt; and &lt;code&gt;mailmap.blob&lt;/code&gt; are given, both are parsed, with entries from &lt;code&gt;mailmap.file&lt;/code&gt; taking precedence. In a bare repository, this defaults to &lt;code&gt;HEAD:.mailmap&lt;/code&gt;. In a non-bare repository, it defaults to empty.</source>
          <target state="translated">Как &lt;code&gt;mailmap.file&lt;/code&gt; , но рассматривайте значение как ссылку на большой двоичный объект в репозитории. Если &lt;code&gt;mailmap.file&lt;/code&gt; и mailmap.file, и &lt;code&gt;mailmap.blob&lt;/code&gt; , анализируются оба, причем записи из &lt;code&gt;mailmap.file&lt;/code&gt; имеют приоритет. В &lt;code&gt;HEAD:.mailmap&lt;/code&gt; репозитории по умолчанию используется HEAD: .mailmap . В репозитории, отличном от чистого, по умолчанию он пуст.</target>
        </trans-unit>
        <trans-unit id="e5b79d6b46ed0bad865e7c66642f5df5197bbc3e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pop&lt;/code&gt;, but do not remove the state from the stash list. Unlike &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; may be any commit that looks like a commit created by &lt;code&gt;stash push&lt;/code&gt; or &lt;code&gt;stash create&lt;/code&gt;.</source>
          <target state="translated">Как &lt;code&gt;pop&lt;/code&gt; , но не удаляйте состояние из списка тайников. В отличие от &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; может быть любой фиксацией, которая выглядит как фиксация, созданная с помощью &lt;code&gt;stash push&lt;/code&gt; или &lt;code&gt;stash create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b42cf6e877b403442b6c5e230e0a3121abfa79f2" translate="yes" xml:space="preserve">
          <source>Like get, but returns all values for a multi-valued key.</source>
          <target state="translated">Например,get,но возвращает все значения для многозначного ключа.</target>
        </trans-unit>
        <trans-unit id="73701f369b01fba26e9d0bb68ef652b62a8e8ce1" translate="yes" xml:space="preserve">
          <source>Like host.example:foo/repo, but use /home/foo/.ssh/somekey as keypair and user as user on remote side. This avoids needing to edit .ssh/config.</source>
          <target state="translated">Как и host.example:foo/repo,но используйте /home/foo/.ssh/somekey в качестве пары ключей и пользователя в качестве пользователя на удаленной стороне.Это позволяет избежать необходимости редактирования .ssh/config.</target>
        </trans-unit>
        <trans-unit id="6a22ef6226883a7823ee7468ab3e5221cd1b0fcc" translate="yes" xml:space="preserve">
          <source>Like many programs that switch user id, the daemon does not reset environment variables such as &lt;code&gt;$HOME&lt;/code&gt; when it runs git programs, e.g. &lt;code&gt;upload-pack&lt;/code&gt; and &lt;code&gt;receive-pack&lt;/code&gt;. When using this option, you may also want to set and export &lt;code&gt;HOME&lt;/code&gt; to point at the home directory of &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; before starting the daemon, and make sure any Git configuration files in that directory are readable by &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Как и многие программы, которые переключают идентификатор пользователя, демон не сбрасывает переменные среды, такие как &lt;code&gt;$HOME&lt;/code&gt; при запуске программ git, например, &lt;code&gt;upload-pack&lt;/code&gt; и &lt;code&gt;receive-pack&lt;/code&gt; . При использовании этой опции вы также можете настроить и экспортировать &lt;code&gt;HOME&lt;/code&gt; , чтобы он указывал на домашний каталог &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; перед запуском демона, и убедитесь, что все файлы конфигурации Git в этом каталоге доступны для чтения &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="955d6409ae367c03bad138119c6bf959eda46b3c" translate="yes" xml:space="preserve">
          <source>Likewise, when the &lt;code&gt;LV&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;-c&lt;/code&gt;. You can override this setting by exporting &lt;code&gt;LV&lt;/code&gt; with another value or setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;lv +c&lt;/code&gt;.</source>
          <target state="translated">Точно так же, когда переменная среды &lt;code&gt;LV&lt;/code&gt; не установлена, Git устанавливает для нее значение &lt;code&gt;-c&lt;/code&gt; . Вы можете переопределить этот параметр, экспортировав &lt;code&gt;LV&lt;/code&gt; с другим значением или установив для &lt;code&gt;core.pager&lt;/code&gt; значение &lt;code&gt;lv +c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da647d41a556bd9f858a9fb821a95fe4fa6d0849" translate="yes" xml:space="preserve">
          <source>Limit commits to the ones touching files in the given paths. Note, to avoid ambiguity with respect to revision names use &quot;--&quot; to separate the paths from any preceding options.</source>
          <target state="translated">Ограничить фиксации теми,кто касается файлов в заданных путях.Обратите внимание,чтобы избежать двусмысленности в отношении имен ревизий,используйте &quot;--&quot;,чтобы отделить пути от любых предыдущих опций.</target>
        </trans-unit>
        <trans-unit id="a8f6287e3aa57458fad3449d202e28c228d6d460" translate="yes" xml:space="preserve">
          <source>Limit diff output to named subtrees.</source>
          <target state="translated">Предельный вывод дифференциальных значений для именованных поддеревьев.</target>
        </trans-unit>
        <trans-unit id="73ea1d1481ae126a39e8d8a25424a40b0120067c" translate="yes" xml:space="preserve">
          <source>Limit fetching to ancestor-chains not longer than n. &lt;code&gt;git-upload-pack&lt;/code&gt; treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long.</source>
          <target state="translated">Ограничьте выборку цепочек предков не длиннее n. &lt;code&gt;git-upload-pack&lt;/code&gt; рассматривает специальную глубину 2147483647 как бесконечную, даже если существует такая длинная цепочка предков.</target>
        </trans-unit>
        <trans-unit id="3548328e70b776f579a206b5e26f3a2cdd3bf54c" translate="yes" xml:space="preserve">
          <source>Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a &lt;code&gt;shallow&lt;/code&gt; repository created by &lt;code&gt;git clone&lt;/code&gt; with &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; option (see &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.</source>
          <target state="translated">Ограничьте выборку указанным количеством коммитов из конца истории каждой удаленной ветки. При загрузке в &lt;code&gt;shallow&lt;/code&gt; репозиторий, созданный &lt;code&gt;git clone&lt;/code&gt; с параметром &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; (см. &lt;a href=&quot;git-clone&quot;&gt;Git-clone [1]&lt;/a&gt; ), углубите или сократите историю до указанного числа коммитов. Теги для углубленных коммитов не извлекаются.</target>
        </trans-unit>
        <trans-unit id="406e704b5fa6637d1092aef900d6bea100f59424" translate="yes" xml:space="preserve">
          <source>Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; is added to the included commits (if it exists) and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; are added to the excluded commits (if they exist). Thus, supposing there are no refs in &lt;code&gt;refs/bisect/&lt;/code&gt;, if</source>
          <target state="translated">Ограничьте вывод одним объектом фиксации, который находится примерно на полпути между включенными и исключенными фиксациями. Обратите внимание, что плохие ссылки &lt;code&gt;refs/bisect/bad&lt;/code&gt; добавляются к включенным коммитам (если они существуют), а хорошие ссылки пополам &lt;code&gt;refs/bisect/good-*&lt;/code&gt; добавляются к исключенным коммитам (если они существуют). Таким образом, предположим, что в &lt;code&gt;refs/bisect/&lt;/code&gt; нет ссылок , если</target>
        </trans-unit>
        <trans-unit id="2b149769f0e9e62c7755e40f7d9c9b100ff198f3" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones that match all given &lt;code&gt;--grep&lt;/code&gt;, instead of ones that match at least one.</source>
          <target state="translated">Ограничьте вывод &lt;code&gt;--grep&lt;/code&gt; теми, которые соответствуют всем заданным --grep , вместо тех, которые соответствуют хотя бы одному.</target>
        </trans-unit>
        <trans-unit id="119c553a83e823fd710ae4f2da2e455c4cb090b7" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression). With more than one &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose author matches any of the given patterns are chosen (similarly for multiple &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Ограничьте вывод коммитов теми, у которых строки заголовка автора / коммиттера соответствуют указанному шаблону (регулярному выражению). С более чем одним &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt; выбираются коммиты, автор которых соответствует любому из заданных шаблонов (аналогично для нескольких &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd1c85bc38b39ba5aff2bee57d4deea0c60fd712" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that do not match the pattern specified with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Ограничьте вывод &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; сообщениями с сообщениями журнала, которые не соответствуют шаблону, указанному с помощью --grep = &amp;lt;pattern&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="bd9eadb3ad8dfb9ffb371dc1589fe6576ab540f4" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that matches the specified pattern (regular expression). With more than one &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose message matches any of the given patterns are chosen (but see &lt;code&gt;--all-match&lt;/code&gt;).</source>
          <target state="translated">Ограничьте вывод коммитов теми, в которых сообщение журнала соответствует указанному шаблону (регулярному выражению). С более чем одним &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; выбираются коммиты, сообщение которых соответствует любому из заданных шаблонов (но см. &lt;code&gt;--all-match&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1b86714045e4612b85a2fa8cf22123bd3513cb6" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one &lt;code&gt;--grep-reflog&lt;/code&gt;, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless &lt;code&gt;--walk-reflogs&lt;/code&gt; is in use.</source>
          <target state="translated">Ограничьте вывод коммитов теми, у которых есть записи журнала ссылок, соответствующие указанному шаблону (регулярному выражению). С более чем одним &lt;code&gt;--grep-reflog&lt;/code&gt; выбираются коммиты, сообщение reflog которых соответствует любому из заданных шаблонов. Использование этой опции будет &lt;code&gt;--walk-reflogs&lt;/code&gt; если не используется --walk-reflogs .</target>
        </trans-unit>
        <trans-unit id="2b5d877818bdb0956a66e366504390cf3fe65b29" translate="yes" xml:space="preserve">
          <source>Limit the commits output to specified time range.</source>
          <target state="translated">Ограничить вывод фиксации заданным промежутком времени.</target>
        </trans-unit>
        <trans-unit id="d8dbf5f629bd3296e9ab1177de95e69729e1d54b" translate="yes" xml:space="preserve">
          <source>Limit the displayed commits to those directly on the ancestry chain between the &amp;ldquo;from&amp;rdquo; and &amp;ldquo;to&amp;rdquo; commits in the given commit range. I.e. only display commits that are ancestor of the &amp;ldquo;to&amp;rdquo; commit and descendants of the &amp;ldquo;from&amp;rdquo; commit.</source>
          <target state="translated">Ограничьте отображаемые коммиты теми, которые находятся непосредственно в цепочке предков между коммитами &amp;laquo;от&amp;raquo; и &amp;laquo;до&amp;raquo; в заданном диапазоне фиксации. Т.е. отображать только те коммиты, которые являются предком коммита &amp;laquo;до&amp;raquo; и потомками коммита &amp;laquo;от&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ed8c2d4ed1408e7d7da83719bcf77ad7b5896ff9" translate="yes" xml:space="preserve">
          <source>Limit the number of commits imported. Workaround for cases where cvsimport leaks memory.</source>
          <target state="translated">Ограничить количество импортируемых коммитов.Обходной путь для случаев,когда cvsimport утечка памяти.</target>
        </trans-unit>
        <trans-unit id="1adada65b7a03da88bf0748c36055d961c64b07a" translate="yes" xml:space="preserve">
          <source>Limit the number of commits to output.</source>
          <target state="translated">Ограничить количество коммитов для вывода.</target>
        </trans-unit>
        <trans-unit id="38e02fe4379a543b3e47180cba4d6468bec3e601" translate="yes" xml:space="preserve">
          <source>Limit the revisions to show. This can be either a single revision meaning show from the given revision and back, or it can be a range in the form &quot;&lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;&quot; to show all revisions between &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; and back to &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;. Note, more advanced revision selection can be applied. For a more complete list of ways to spell object names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Ограничьте количество отображаемых ревизий. Это может быть либо одна ревизия, означающая показ от данной ревизии и обратно, либо это может быть диапазон в форме &amp;laquo; &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; &amp;raquo;, чтобы показать все ревизии между &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; и обратно до &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; . Обратите внимание, что можно применить более расширенный выбор редакции. Более полный список способов &lt;a href=&quot;gitrevisions&quot;&gt;написания&lt;/a&gt; имен объектов см. В gitrevisions [7] .</target>
        </trans-unit>
        <trans-unit id="674ff0df4160db3404d979762630ae612e98f156" translate="yes" xml:space="preserve">
          <source>Limit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch.</source>
          <target state="translated">Ограничить ширину части графика в выводе --stat.Если установлено,применяется ко всем командам,генерирующим вывод --stat,кроме формата-patch.</target>
        </trans-unit>
        <trans-unit id="29e45322508b52ceb051971d532eab460b3dc7d7" translate="yes" xml:space="preserve">
          <source>Limit to &quot;refs/heads&quot; and &quot;refs/tags&quot;, respectively. These options are not mutually exclusive; when given both, references stored in &quot;refs/heads&quot; and &quot;refs/tags&quot; are displayed.</source>
          <target state="translated">Ограничение на &quot;ссылки/заголовки&quot; и &quot;ссылки/метки&quot; соответственно.Эти опции не являются взаимоисключающими;при указании обоих вариантов отображаются ссылки,хранящиеся в &quot;ссылках/заголовках&quot; и &quot;ссылках/метках&quot; соответственно.</target>
        </trans-unit>
        <trans-unit id="66b9fb961da3804ca95085a20ace37a86529e6f7" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.</source>
          <target state="translated">Ограничение только ссылками / заголовками и ссылками / тегами соответственно. Эти варианты &lt;code&gt;not&lt;/code&gt; исключают друг друга; если заданы оба параметра, отображаются ссылки, хранящиеся в refs / Heads и refs / tags.</target>
        </trans-unit>
        <trans-unit id="cce06ee642a7b80587fe58f4572571b699424f46" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed. Note that &lt;code&gt;git ls-remote -h&lt;/code&gt; used without anything else on the command line gives help, consistent with other git subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="e8bb22d887f5d59400be2b36a39e61d714bda7bc" translate="yes" xml:space="preserve">
          <source>Limiting the diff output</source>
          <target state="translated">Ограничение диффузионного выхода</target>
        </trans-unit>
        <trans-unit id="b7748eb338af2086cdad1f6af364c3481df64676" translate="yes" xml:space="preserve">
          <source>Limits the number of commits to show to 3.</source>
          <target state="translated">Ограничивает количество показываемых коммитов до 3.</target>
        </trans-unit>
        <trans-unit id="efd756293dbb86969a7022bf4157b3145d6076f3" translate="yes" xml:space="preserve">
          <source>Limits the paths affected by the operation.</source>
          <target state="translated">Ограничивает пути,на которые влияет работа.</target>
        </trans-unit>
        <trans-unit id="8375cb461aa1ace8d2ffdda18edb87b333f2f4d1" translate="yes" xml:space="preserve">
          <source>Line numbers count from 1.</source>
          <target state="translated">Номер строки отсчитывается от 1.</target>
        </trans-unit>
        <trans-unit id="3d9326a0fc6538daba3b0f3096cf5c416812b52b" translate="yes" xml:space="preserve">
          <source>Lines starting with a hash (&quot;&lt;code&gt;#&lt;/code&gt;&quot;) are ignored, so they can be used for comments. Add a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) to the beginning of the pattern if it starts with a hash.</source>
          <target state="translated">Строки, начинающиеся с решетки (&quot; &lt;code&gt;#&lt;/code&gt; &quot;), игнорируются, поэтому их можно использовать для комментариев. Добавьте обратную косую черту (&quot; &lt;code&gt;\&lt;/code&gt; &quot;) в начало шаблона, если он начинается с хеша.</target>
        </trans-unit>
        <trans-unit id="8e28fd820953d60830c4b1106307e2e0b6872452" translate="yes" xml:space="preserve">
          <source>Linewrap the output by wrapping each line at &lt;code&gt;width&lt;/code&gt;. The first line of each entry is indented by &lt;code&gt;indent1&lt;/code&gt; spaces, and the second and subsequent lines are indented by &lt;code&gt;indent2&lt;/code&gt; spaces. &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;indent1&lt;/code&gt;, and &lt;code&gt;indent2&lt;/code&gt; default to 76, 6 and 9 respectively.</source>
          <target state="translated">Оберните вывод строкой, обернув каждую строку по &lt;code&gt;width&lt;/code&gt; . Первая строка каждой записи имеет отступ пробелов &lt;code&gt;indent1&lt;/code&gt; , а вторая и последующие строки - пробелами &lt;code&gt;indent2&lt;/code&gt; . &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;indent1&lt;/code&gt; и &lt;code&gt;indent2&lt;/code&gt; по умолчанию равны 76, 6 и 9 соответственно.</target>
        </trans-unit>
        <trans-unit id="1d1f6a47e210ac264339f2e30472d9fdf4025a54" translate="yes" xml:space="preserve">
          <source>Links and their targets</source>
          <target state="translated">Связи и их цели</target>
        </trans-unit>
        <trans-unit id="7177342122325630102d4a83723d13417535ac19" translate="yes" xml:space="preserve">
          <source>Linus Torvalds originally designed Git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of Git.</source>
          <target state="translated">Линус Торвальдс изначально проектировал Git как файловую систему пользовательского пространства,т.е.инфраструктуру для хранения файлов и каталогов.Это обеспечило эффективность и скорость работы Git'а.</target>
        </trans-unit>
        <trans-unit id="9f9879c2ed0b6b8dfd5d9b1ecb4faa0c5584d26d" translate="yes" xml:space="preserve">
          <source>Linus Torvalds, for example, makes new kernel releases by tagging them, then running:</source>
          <target state="translated">Линус Торвальдс (Linus Torvalds),например,делает новые релизы ядра,пометив их метками,а затем запустив:</target>
        </trans-unit>
        <trans-unit id="c215fd74e10e91e4728dc7ef559cf830d21a3457" translate="yes" xml:space="preserve">
          <source>Linus&amp;rsquo;s tree will be stored in the remote-tracking branch named origin/master, and can be updated using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;; you can track other public trees using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; to set up a &quot;remote&quot; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; to keep them up to date; see &lt;a href=&quot;#repositories-and-branches&quot;&gt;Repositories and Branches&lt;/a&gt;.</source>
          <target state="translated">Дерево Линуса будет храниться в ветке удаленного отслеживания с именем origin / master и может быть обновлено с помощью &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; ; вы можете отслеживать другие общедоступные деревья, используя &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; для настройки &amp;laquo;удаленного&amp;raquo; и &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1],&lt;/a&gt; чтобы поддерживать их в актуальном состоянии; см. &lt;a href=&quot;#repositories-and-branches&quot;&gt;Репозитории и Филиалы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a79bad3bb798b3bdc01c2a7bbb2df04a2b261bb" translate="yes" xml:space="preserve">
          <source>List (array reference) of feature parameters (if there are any), used also to toggle (enable or disable) given feature.</source>
          <target state="translated">Список (ссылка на массив)параметров объекта (если таковой имеется),используемый также для переключения (включения или выключения)данного объекта.</target>
        </trans-unit>
        <trans-unit id="7ee03188f58cdb7509c4f88e1a300f564da6d9fa" translate="yes" xml:space="preserve">
          <source>List all attributes that are associated with the specified paths. If this option is used, then &lt;code&gt;unspecified&lt;/code&gt; attributes will not be included in the output.</source>
          <target state="translated">Список всех атрибутов, связанных с указанными путями. Если используется эта опция, то &lt;code&gt;unspecified&lt;/code&gt; атрибуты не будут включены в вывод.</target>
        </trans-unit>
        <trans-unit id="250839942391006b259bdb87bdef885727a6f6a9" translate="yes" xml:space="preserve">
          <source>List all available configuration variables. This is a short summary of the list in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Перечислите все доступные переменные конфигурации. Это краткое изложение списка в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12ac07106316dd6381b9d3b75b7cd7d028c9fa93" translate="yes" xml:space="preserve">
          <source>List all commits reachable from all refs</source>
          <target state="translated">Перечислить все коммиты,до которых можно добраться из всех рефери</target>
        </trans-unit>
        <trans-unit id="dca598d76b2fd502e68ee09810f65324e1da32ae" translate="yes" xml:space="preserve">
          <source>List all tags (lightweight and annotated) in given repository.</source>
          <target state="translated">Перечислите все теги (легкие и аннотированные)в данном репозитории.</target>
        </trans-unit>
        <trans-unit id="df1447e22cac81b01f2aee49d9517212423de9a9" translate="yes" xml:space="preserve">
          <source>List all variables set in config file, along with their values.</source>
          <target state="translated">Перечислите все переменные,установленные в конфигурационном файле,вместе с их значениями.</target>
        </trans-unit>
        <trans-unit id="aa1b92c795a51cb41c1ee54087151d51eda95116" translate="yes" xml:space="preserve">
          <source>List both remote-tracking branches and local branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match optional pattern(s).</source>
          <target state="translated">Перечислите как ветки удаленного отслеживания, так и локальные ветки. Комбинируйте с &lt;code&gt;--list&lt;/code&gt; для сопоставления необязательных шаблонов.</target>
        </trans-unit>
        <trans-unit id="670ea777adabe92ea2a21ddec9e8062878d9ce68" translate="yes" xml:space="preserve">
          <source>List branches. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git
branch --list 'maint-*'&lt;/code&gt;, list only the branches that match the pattern(s).</source>
          <target state="translated">Список веток. С необязательным &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; , например, &lt;code&gt;git branch --list 'maint-*'&lt;/code&gt; , вывести список только тех ветвей, которые соответствуют шаблону (ам).</target>
        </trans-unit>
        <trans-unit id="ecd6ee4f3b1cdf8c4e62426b401b6921926e6641" translate="yes" xml:space="preserve">
          <source>List commands by group. This is an internal/experimental option and may change or be removed in the future. Supported groups are: builtins, parseopt (builtin commands that use parse-options), main (all commands in libexec directory), others (all other commands in &lt;code&gt;$PATH&lt;/code&gt; that have git- prefix), list-&amp;lt;category&amp;gt; (see categories in command-list.txt), nohelpers (exclude helper commands), alias and config (retrieve command list from config variable completion.commands)</source>
          <target state="translated">Список команд по группам. Это внутренний / экспериментальный вариант, который может быть изменен или удален в будущем. Поддерживаемые группы: builtins, parseopt (встроенные команды, использующие параметры синтаксического анализа), main (все команды в каталоге libexec), другие (все другие команды в &lt;code&gt;$PATH&lt;/code&gt; с префиксом git-), list- &amp;lt;category&amp;gt; (см. Категории в command-list.txt), nohelpers (исключить вспомогательные команды), псевдоним и конфигурация (получить список команд из переменной конфигурации completed.commands)</target>
        </trans-unit>
        <trans-unit id="238ed7681a7fd585fe1d585aba4d3e4521202ffa" translate="yes" xml:space="preserve">
          <source>List commits that are reachable by following the &lt;code&gt;parent&lt;/code&gt; links from the given commit(s), but exclude commits that are reachable from the one(s) given with a &lt;code&gt;^&lt;/code&gt; in front of them. The output is given in reverse chronological order by default.</source>
          <target state="translated">Перечислить коммиты, которые доступны по &lt;code&gt;parent&lt;/code&gt; ссылкам из данного коммита (й), но исключить коммиты, доступные из коммитов, указанных с символом &lt;code&gt;^&lt;/code&gt; перед ними. По умолчанию выходные данные отображаются в обратном хронологическом порядке.</target>
        </trans-unit>
        <trans-unit id="4360f3a3310a6afc913d6c5b075b5763b91121d3" translate="yes" xml:space="preserve">
          <source>List details of each working tree. The main working tree is listed first, followed by each of the linked working trees. The output details include whether the working tree is bare, the revision currently checked out, and the branch currently checked out (or &quot;detached HEAD&quot; if none).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8cd82f860b84646c498bf5c68b11bdf176a80b7" translate="yes" xml:space="preserve">
          <source>List details of each working tree. The main working tree is listed first, followed by each of the linked working trees. The output details include whether the working tree is bare, the revision currently checked out, the branch currently checked out (or &quot;detached HEAD&quot; if none), and &quot;locked&quot; if the worktree is locked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfacb775267bd93896cdbdf525c103ac26c16d4" translate="yes" xml:space="preserve">
          <source>List details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include if the worktree is bare, the revision currently checked out, and the branch currently checked out (or &lt;code&gt;detached HEAD&lt;/code&gt; if none).</source>
          <target state="translated">Перечислите детали каждого рабочего дерева. Сначала указывается главное рабочее дерево, за ним следует каждое из связанных рабочих деревьев. Детали вывода включают в себя, является ли рабочее дерево пустым, текущая проверенная ревизия и ветвь, которая в настоящее время проверена (или &lt;code&gt;detached HEAD&lt;/code&gt; если ее нет).</target>
        </trans-unit>
        <trans-unit id="1481dab663abae987b5437270fc0152b6258984f" translate="yes" xml:space="preserve">
          <source>List of Git base URLs. These URLs are used to generate URLs describing from where to fetch a project, which are shown on project summary page. The full fetch URL is &quot;&lt;code&gt;$git_base_url/$project&lt;/code&gt;&quot;, for each element of this list. You can set up multiple base URLs (for example one for &lt;code&gt;git://&lt;/code&gt; protocol, and one for &lt;code&gt;http://&lt;/code&gt; protocol).</source>
          <target state="translated">Список базовых URL-адресов Git. Эти URL-адреса используются для генерации URL-адресов, описывающих, откуда можно получить проект, которые отображаются на странице сводки проекта. Полный URL-адрес выборки - &amp;laquo; &lt;code&gt;$git_base_url/$project&lt;/code&gt; &amp;raquo; для каждого элемента этого списка. Вы можете настроить несколько базовых URL-адресов (например, один для протокола &lt;code&gt;git://&lt;/code&gt; и один для протокола &lt;code&gt;http://&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9453e698a4a15232ec2c038afd4c298aede850c" translate="yes" xml:space="preserve">
          <source>List of URIs of stylesheets (relative to the base URI of a page). You might specify more than one stylesheet, for example to use &quot;gitweb.css&quot; as base with site specific modifications in a separate stylesheet to make it easier to upgrade gitweb. For example, you can add a &lt;code&gt;site&lt;/code&gt; stylesheet by putting</source>
          <target state="translated">Список URI таблиц стилей (относительно базового URI страницы). Вы можете указать более одной таблицы стилей, например, использовать &amp;laquo;gitweb.css&amp;raquo; в качестве основы с изменениями для конкретного сайта в отдельной таблице стилей, чтобы упростить обновление gitweb. Например, вы можете добавить таблицу стилей &lt;code&gt;site&lt;/code&gt; , поместив</target>
        </trans-unit>
        <trans-unit id="d9ab3387c39e123d7aac2edb253dcdba7080f753" translate="yes" xml:space="preserve">
          <source>List of additional directories under &quot;refs&quot; which are going to be used as branch refs. For example if you have a gerrit setup where all branches under refs/heads/ are official, push-after-review ones and branches under refs/sandbox/, refs/wip and refs/other are user ones where permissions are much wider, then you might want to set this variable as follows:</source>
          <target state="translated">Список дополнительных каталогов под &quot;ссылками&quot;,которые будут использоваться в качестве ссылок на ветки.Например,если у вас есть настройка gerrit,в которой все ветки под refs/heads/являются официальными,push-после просмотра-официальными,а ветки под refs/sandbox/,refs/wip и refs/другие-пользовательскими,где права гораздо шире,то вы можете захотеть установить эту переменную следующим образом:</target>
        </trans-unit>
        <trans-unit id="c919f43c88ec5761218ece7f29ac150fc5c1298f" translate="yes" xml:space="preserve">
          <source>List of branches to be imported when branch detection is enabled. Each entry should be a pair of branch names separated by a colon (:). This example declares that both branchA and branchB were created from main:</source>
          <target state="translated">Список веток,которые необходимо импортировать при включенном обнаружении веток.Каждая запись должна быть парой имён ветвей,разделенных двоеточием (:).В этом примере декларируется,что и branchA и branchB были созданы из основного:</target>
        </trans-unit>
        <trans-unit id="3d6057539fc43b4e5580b21aa940b705e61341be" translate="yes" xml:space="preserve">
          <source>List of p4 labels to ignore. This is built automatically as unimportable labels are discovered.</source>
          <target state="translated">Список лейблов p4,которые нужно игнорировать.Он строится автоматически по мере обнаружения неимоверных меток.</target>
        </trans-unit>
        <trans-unit id="ed979d0137e2b09484f09056901ac3efce874117" translate="yes" xml:space="preserve">
          <source>List only commits on the respective side of a symmetric difference, i.e. only those which would be marked &lt;code&gt;&amp;lt;&lt;/code&gt; resp. &lt;code&gt;&amp;gt;&lt;/code&gt; by &lt;code&gt;--left-right&lt;/code&gt;.</source>
          <target state="translated">List фиксируется только на соответствующей стороне симметричной разницы, т.е. только те, которые были бы помечены &lt;code&gt;&amp;lt;&lt;/code&gt; соответственно. &lt;code&gt;&amp;gt;&lt;/code&gt; По &lt;code&gt;--left-right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db38d2130aa4774e0a5e01e813cbe87b286b5c58" translate="yes" xml:space="preserve">
          <source>List only filenames (instead of the &quot;long&quot; output), one per line.</source>
          <target state="translated">Прослушивайте только имена файлов (вместо &quot;длинного&quot; вывода),по одному на строку.</target>
        </trans-unit>
        <trans-unit id="ca0ba00456e1892ce61ce3c77aa65cb5194d4e6c" translate="yes" xml:space="preserve">
          <source>List or delete (if used with -d) the remote-tracking branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match the optional pattern(s).</source>
          <target state="translated">Перечислить или удалить (если используется с -d) ветки удаленного отслеживания. Комбинируйте с &lt;code&gt;--list&lt;/code&gt; для соответствия необязательному шаблону (ам).</target>
        </trans-unit>
        <trans-unit id="22eb51b821276ed4742fd46da8d914f3eb506ca1" translate="yes" xml:space="preserve">
          <source>List output format</source>
          <target state="translated">Формат вывода списка</target>
        </trans-unit>
        <trans-unit id="961866b18d2006e9e2f1c57af615530c0dcb0176" translate="yes" xml:space="preserve">
          <source>List references in a local repository</source>
          <target state="translated">Перечислить ссылки в локальном репозитории</target>
        </trans-unit>
        <trans-unit id="7a309b311eeb5429dbbc4c270383e0c9240ea7dd" translate="yes" xml:space="preserve">
          <source>List references in a remote repository</source>
          <target state="translated">Перечислить ссылки в удаленном репозитории</target>
        </trans-unit>
        <trans-unit id="c3c4b04779710ca49a121ec3b626bb207fe0cc86" translate="yes" xml:space="preserve">
          <source>List replace refs for objects that match the given pattern (or all if no pattern is given). Typing &quot;git replace&quot; without arguments, also lists all replace refs.</source>
          <target state="translated">Список заменяет ссылки на объекты,которые соответствуют заданному шаблону (или все,если шаблон не указан).При вводе &quot;git replace&quot; без аргументов,также перечисляются все заменяющие ссылки.</target>
        </trans-unit>
        <trans-unit id="dd864736379915e26071e39557a37c9a699c5cd9" translate="yes" xml:space="preserve">
          <source>List some tags in a table with unequal column widths:</source>
          <target state="translated">Перечислите некоторые теги в таблице с неравной шириной столбцов:</target>
        </trans-unit>
        <trans-unit id="c3a7e0023c585da8fc00add926f4e7fe3e4bed2d" translate="yes" xml:space="preserve">
          <source>List tags. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git tag --list
'v-*'&lt;/code&gt;, list only the tags that match the pattern(s).</source>
          <target state="translated">Список тегов. С необязательным &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; , например, &lt;code&gt;git tag --list 'v-*'&lt;/code&gt; , перечислить только теги, соответствующие шаблону (ам).</target>
        </trans-unit>
        <trans-unit id="42f93b25d56793afc3463e924a37b81b3e45f73d" translate="yes" xml:space="preserve">
          <source>List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.</source>
          <target state="translated">Перечислите переменные окружения GIT_*,которые являются локальными для репозитория (например,GIT_DIR или GIT_WORK_TREE,но не GIT_EDITOR).Перечисляются только имена переменных,а не их значения,даже если они установлены.</target>
        </trans-unit>
        <trans-unit id="dc410162c15e0c2fc959648b2d515436ff66231c" translate="yes" xml:space="preserve">
          <source>List the contents of a tree object</source>
          <target state="translated">Перечислить содержимое объекта дерева</target>
        </trans-unit>
        <trans-unit id="c77a61ab930b102983b7633429f2e1c89c8a648a" translate="yes" xml:space="preserve">
          <source>List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format &quot;&amp;lt;note object&amp;gt; &amp;lt;annotated object&amp;gt;&quot;). This is the default subcommand if no subcommand is given.</source>
          <target state="translated">Перечислите объект заметок для данного объекта. Если объект не указан, покажите список всех объектов примечания и объектов, которые они аннотируют (в формате &amp;laquo;&amp;lt;объект примечания&amp;gt; &amp;lt;аннотированный объект&amp;gt;&amp;raquo;). Это подкоманда по умолчанию, если подкоманда не задана.</target>
        </trans-unit>
        <trans-unit id="160440cac4234691b237108179766c8ac388a3dd" translate="yes" xml:space="preserve">
          <source>List the stash entries that you currently have. Each &lt;code&gt;stash entry&lt;/code&gt; is listed with its name (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the latest entry, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on.</source>
          <target state="translated">Перечислите записи в тайнике, которые у вас есть. Каждая &lt;code&gt;stash entry&lt;/code&gt; указывается с ее именем (например, &lt;code&gt;stash@{0}&lt;/code&gt; - это последняя запись, &lt;code&gt;stash@{1}&lt;/code&gt; - предыдущая и т. Д.), Именем ветки, которая была текущей на момент создания записи, и краткое описание фиксации, на которой была основана запись.</target>
        </trans-unit>
        <trans-unit id="0928a18c981cee8dd1bbd962ad11b79b09b49f73" translate="yes" xml:space="preserve">
          <source>List, create, or delete branches</source>
          <target state="translated">Составить список,создать или удалить ветки</target>
        </trans-unit>
        <trans-unit id="7d888e358c6ef40ec2a0a8a674979b45cd6d1cf4" translate="yes" xml:space="preserve">
          <source>Listed below are options that control the formatting of diff output. Some of them are specific to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, however other diff options may be given. See &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for more options.</source>
          <target state="translated">Ниже перечислены параметры, управляющие форматированием вывода diff. Некоторые из них относятся к &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; , однако могут быть указаны другие параметры сравнения. Дополнительные параметры см. В &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3248fa00aea630b8bbaf0b4709f9f26882639bdc" translate="yes" xml:space="preserve">
          <source>Listen on a specific IP address or hostname. IP addresses can be either an IPv4 address or an IPv6 address if supported. If IPv6 is not supported, then --listen=hostname is also not supported and --listen must be given an IPv4 address. Can be given more than once. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">Слушайте определенный IP-адрес или имя хоста. IP-адреса могут быть либо адресом IPv4, либо адресом IPv6, если он поддерживается. Если IPv6 не поддерживается, то --listen = hostname также не поддерживается, и --listen должен иметь адрес IPv4. Можно давать более одного раза. Несовместимо с параметром &lt;code&gt;--inetd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f53ff7586b49256325ec58801bfe143f18e21e3" translate="yes" xml:space="preserve">
          <source>Listen on an alternative port. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">Слушайте альтернативный порт. Несовместимо с параметром &lt;code&gt;--inetd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e35805a9773260286dfbc09d02caaf5994dc0ce" translate="yes" xml:space="preserve">
          <source>Listing a single attribute:</source>
          <target state="translated">Перечисляет один атрибут:</target>
        </trans-unit>
        <trans-unit id="69751d90f1fec1736a7673316bf3b759c5271c7d" translate="yes" xml:space="preserve">
          <source>Listing all attributes for a file:</source>
          <target state="translated">Перечисление всех атрибутов для файла:</target>
        </trans-unit>
        <trans-unit id="e231fe1cc3d8844bfddb76169e22179c8767ce9e" translate="yes" xml:space="preserve">
          <source>Listing an attribute for multiple files:</source>
          <target state="translated">Перечисление атрибута для нескольких файлов:</target>
        </trans-unit>
        <trans-unit id="d1d9eec0e1bd38bd76cb67feb04b08b5d78c11bd" translate="yes" xml:space="preserve">
          <source>Listing branches from a specific remote</source>
          <target state="translated">Включение филиалов в список с определенного пульта дистанционного управления</target>
        </trans-unit>
        <trans-unit id="14162152c45d26fb9527c9f0660bef886294e5bf" translate="yes" xml:space="preserve">
          <source>Listing multiple attributes for a file:</source>
          <target state="translated">Перечисление нескольких атрибутов для файла:</target>
        </trans-unit>
        <trans-unit id="540f872616da666be00fd2f7f78a7ae984c11b9a" translate="yes" xml:space="preserve">
          <source>Lists all local or all remote-tracking branches in given repository.</source>
          <target state="translated">Списки всех локальных или всех удаленных отслеживаемых ветвей в данном репозитории.</target>
        </trans-unit>
        <trans-unit id="b5500d120a9a13cb3af42448653e0cde10752de4" translate="yes" xml:space="preserve">
          <source>Lists commit objects in reverse chronological order</source>
          <target state="translated">Списки фиксируют объекты в обратном хронологическом порядке</target>
        </trans-unit>
        <trans-unit id="6385084e9b2c3e78376900259ba28376e3a28618" translate="yes" xml:space="preserve">
          <source>Lists the available Git repositories. This is the default command if no repository is specified in the URL.</source>
          <target state="translated">Перечисляет доступные Git-репозитории.Это команда по умолчанию,если в URL не указан ни один репозиторий.</target>
        </trans-unit>
        <trans-unit id="9438685d87876d6c82356bf9b864c1c6136c1266" translate="yes" xml:space="preserve">
          <source>Lists the capabilities of the helper, one per line, ending with a blank line. Each capability may be preceded with &lt;code&gt;*&lt;/code&gt;, which marks them mandatory for Git versions using the remote helper to understand. Any unknown mandatory capability is a fatal error.</source>
          <target state="translated">Перечисляет возможности помощника, по одной в строке, заканчивая пустой строкой. Каждой возможности может предшествовать символ &lt;code&gt;*&lt;/code&gt; , который отмечает их обязательность для версий Git, использующих удаленный помощник для понимания. Любая неизвестная обязательная возможность является фатальной ошибкой.</target>
        </trans-unit>
        <trans-unit id="8c594a1bf48edecf6065890a7f89cc7fa404495f" translate="yes" xml:space="preserve">
          <source>Lists the contents of a given tree object, like what &quot;/bin/ls -a&quot; does in the current working directory. Note that:</source>
          <target state="translated">Перечисляет содержимое заданного объекта дерева,например,что делает &quot;/bin/ls -a&quot; в текущей рабочей директории.Обратите внимание на это:</target>
        </trans-unit>
        <trans-unit id="9cc5eb61d77cd46774cb42ac22301b7d413d58c5" translate="yes" xml:space="preserve">
          <source>Lists the properties stored in the Subversion repository about a given file or directory. Use -r/--revision to refer to a specific Subversion revision.</source>
          <target state="translated">Перечисляет свойства,хранящиеся в репозитории Subversion о данном файле или каталоге.Используйте -r/-ревизию для ссылки на конкретную ревизию Subversion.</target>
        </trans-unit>
        <trans-unit id="11c5aa2ca7f7c3e091142bb69f047bf1ca338d7f" translate="yes" xml:space="preserve">
          <source>Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out.</source>
          <target state="translated">Перечисляет ссылки,определенные в связке.Если за списком следует список ссылок,то распечатываются только те ссылки,которые соответствуют приведенным.</target>
        </trans-unit>
        <trans-unit id="ce5afcadd9730c2206b4e08d09ffc836dddfab54" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, &quot;:&amp;lt;keyword&amp;gt; &amp;lt;value&amp;gt;&quot; for a key-value pair, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb27642bee7df675e576f1467eabd36ebf236a0c" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="translated">Перечисляет ссылки, по одной в строке, в формате &amp;laquo;&amp;lt;значение&amp;gt; &amp;lt;имя&amp;gt; [&amp;lt;атрибут&amp;gt;&amp;hellip;]&amp;raquo;. Значение может быть шестнадцатеричным хешем sha1, &quot;@ &amp;lt;dest&amp;gt;&quot; для символьной ссылки или &quot;?&quot; чтобы указать, что помощник не может получить значение ref. После имени следует список атрибутов, разделенных пробелами; нераспознанные атрибуты игнорируются. Список заканчивается пустой строкой.</target>
        </trans-unit>
        <trans-unit id="8cf165480241df10f979b6b7157595e5407c755f" translate="yes" xml:space="preserve">
          <source>Literal percent sign.</source>
          <target state="translated">Буквальный знак процента.</target>
        </trans-unit>
        <trans-unit id="c9b025ce8a30fb92786ef26cc44501e09df585de" translate="yes" xml:space="preserve">
          <source>Literal space in command or argument.</source>
          <target state="translated">Буквальное пространство в команде или аргументе.</target>
        </trans-unit>
        <trans-unit id="3e47004eca06847317d03882ea01098236feca24" translate="yes" xml:space="preserve">
          <source>Loads annotations as described above and automatically scrolls the view to center on line &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">Загружает аннотации, как описано выше, и автоматически прокручивает вид до центра строки &lt;code&gt;100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f638d2718f9a7fa3228a4c22ea27ab0cb7ce0ed8" translate="yes" xml:space="preserve">
          <source>Local directory</source>
          <target state="translated">локальная директория</target>
        </trans-unit>
        <trans-unit id="83cd95e5e26d810cf34fa10fd02190221225a995" translate="yes" xml:space="preserve">
          <source>Locate a good region of the object graph in a damaged repository</source>
          <target state="translated">Найти хорошую область объектного графика в поврежденном репозитории.</target>
        </trans-unit>
        <trans-unit id="c6b89ef8cfe5b4e0d5f71a9018f7c23272508e1d" translate="yes" xml:space="preserve">
          <source>Location of repositories</source>
          <target state="translated">Расположение репозиториев</target>
        </trans-unit>
        <trans-unit id="a8464429b3dd8a54d4c3a8d0aaf7809c3b93d077" translate="yes" xml:space="preserve">
          <source>Locations of Marks Files</source>
          <target state="translated">Места расположения маркерных файлов</target>
        </trans-unit>
        <trans-unit id="747742f75a08750185466d70d49a66f609262970" translate="yes" xml:space="preserve">
          <source>Locations of the common system-wide configuration file, the fallback system-wide configuration file and the per-instance configuration file are defined at compile time using build-time Makefile configuration variables, respectively &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt;.</source>
          <target state="translated">Расположение общего общесистемного файла конфигурации, резервного общесистемного файла конфигурации и файла конфигурации для каждого экземпляра определяется во время компиляции с использованием переменных конфигурации Makefile времени сборки, соответственно &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; и &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8e7c6671e74ff8d9e440b7a275b6b3047a92bf" translate="yes" xml:space="preserve">
          <source>Log details about the incoming connections and requested files.</source>
          <target state="translated">Подробная информация о входящих соединениях и запрошенных файлах.</target>
        </trans-unit>
        <trans-unit id="c1bbca864796e717c6563546ee8bb0273fbae9ac" translate="yes" xml:space="preserve">
          <source>Logging updates</source>
          <target state="translated">Обновления журнала</target>
        </trans-unit>
        <trans-unit id="e76f4d6fb1700b21a7cf7fc7a62d7a34c7014ae2" translate="yes" xml:space="preserve">
          <source>Long Running Filter Process</source>
          <target state="translated">Длительно работающий процесс фильтрации</target>
        </trans-unit>
        <trans-unit id="555712d9829e6328a9b7d5ec70facbda745fb9b3" translate="yes" xml:space="preserve">
          <source>Look at the diffs from each branch. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; will show diffs first for the &lt;code&gt;HEAD&lt;/code&gt; version and then the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">Посмотрите различия в каждой ветке. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; сначала покажет различия для версии &lt;code&gt;HEAD&lt;/code&gt; , а затем для версии &lt;code&gt;MERGE_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a326ab540e0d9536d53dbc94d57cb0c25e24d9a1" translate="yes" xml:space="preserve">
          <source>Look at the diffs. &lt;code&gt;git diff&lt;/code&gt; will show a three-way diff, highlighting changes from both the &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;MERGE_HEAD&lt;/code&gt; versions.</source>
          <target state="translated">Посмотрите на различия. &lt;code&gt;git diff&lt;/code&gt; покажет трехстороннее различие, выделив изменения в версиях &lt;code&gt;HEAD&lt;/code&gt; и &lt;code&gt;MERGE_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8c63749f2ae2fa24fa7ef48c360ef59f66a1f48" translate="yes" xml:space="preserve">
          <source>Look at the originals. &lt;code&gt;git show :1:filename&lt;/code&gt; shows the common ancestor, &lt;code&gt;git show :2:filename&lt;/code&gt; shows the &lt;code&gt;HEAD&lt;/code&gt; version, and &lt;code&gt;git show :3:filename&lt;/code&gt; shows the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">Посмотрите на оригиналы. &lt;code&gt;git show :1:filename&lt;/code&gt; показывает общего предка, &lt;code&gt;git show :2:filename&lt;/code&gt; показывает версию &lt;code&gt;HEAD&lt;/code&gt; , а &lt;code&gt;git show :3:filename&lt;/code&gt; показывает версию &lt;code&gt;MERGE_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a423d84e076a3272fdc685127299ea63ea761ac" translate="yes" xml:space="preserve">
          <source>Look for a fix instead of a regression in the code</source>
          <target state="translated">Ищите исправление вместо регрессии в коде.</target>
        </trans-unit>
        <trans-unit id="4ab23275475ac09a44d78ac861e7af3c95082023" translate="yes" xml:space="preserve">
          <source>Look for attributes in .gitattributes files in the working tree as well (see &lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt;).</source>
          <target state="translated">Также ищите атрибуты в файлах .gitattributes в рабочем дереве (см. &lt;a href=&quot;#ATTRIBUTES&quot;&gt;АТРИБУТЫ&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e41023ffb67a9b868c13a5cdc624ea0d794092d" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified object. Similar to &lt;code&gt;-S&lt;/code&gt;, just the argument is different in that it doesn&amp;rsquo;t search for a specific string but for a specific object id.</source>
          <target state="translated">Ищите различия, которые изменяют количество вхождений указанного объекта. Подобно &lt;code&gt;-S&lt;/code&gt; , только аргумент отличается тем, что он ищет не конкретную строку, а конкретный идентификатор объекта.</target>
        </trans-unit>
        <trans-unit id="a838d092d782360d96378f1e4ff8a0b5fffd060f" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">Ищите различия, которые изменяют количество вхождений указанной строки (т. Е. Добавления / удаления) в файле. Предназначен для использования скриптером.</target>
        </trans-unit>
        <trans-unit id="b8df136f2384d637ef409fc2baddd2b9dce73992" translate="yes" xml:space="preserve">
          <source>Look for differences whose patch text contains added/removed lines that match &amp;lt;regex&amp;gt;.</source>
          <target state="translated">Ищите отличия, текст патча которых содержит добавленные / удаленные строки, соответствующие &amp;lt;regex&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="4cef9adbc5be0f5f01b5c2739071b69091cb4a32" translate="yes" xml:space="preserve">
          <source>Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines.</source>
          <target state="translated">Ищите заданные шаблоны в отслеживаемых файлах в рабочем дереве,капли,зарегистрированные в индексном файле,или капли в заданных объектах дерева.Шаблоны-это списки одного или нескольких поисковых выражений,разделенных символами новой строки.Пустая строка в качестве поискового выражения соответствует всем строкам.</target>
        </trans-unit>
        <trans-unit id="07448c29252081320f670b2265de0e9cba50a292" translate="yes" xml:space="preserve">
          <source>Look up layout mode using configuration variable column.&amp;lt;name&amp;gt; and column.ui.</source>
          <target state="translated">Найдите режим макета, используя переменную конфигурации column. &amp;lt;name&amp;gt; и column.ui.</target>
        </trans-unit>
        <trans-unit id="b62eefc27e1aeffa75b2d4761547bc2b8bc497bd" translate="yes" xml:space="preserve">
          <source>Looks at the current index and checks to see if merges or updates are needed by checking stat() information.</source>
          <target state="translated">Смотрит на текущий индекс и проверяет,нужны ли слияния или обновления,проверяя информацию stat().</target>
        </trans-unit>
        <trans-unit id="4b7876b6a8ad520457ce71bfe745148e3c567edb" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;solution&lt;/code&gt;, excluding files in &lt;code&gt;Documentation&lt;/code&gt;.</source>
          <target state="translated">Ищет &lt;code&gt;solution&lt;/code&gt; , исключая файлы в &lt;code&gt;Documentation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f3233017974f60253fdf12d744b51a535433787" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;time_t&lt;/code&gt; in all tracked .c and .h files in the working directory and its subdirectories.</source>
          <target state="translated">Ищет &lt;code&gt;time_t&lt;/code&gt; во всех отслеживаемых файлах .c и .h в рабочем каталоге и его подкаталогах.</target>
        </trans-unit>
        <trans-unit id="558837c842e106c2ed3e4e9a131c3a7442c122b9" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;#define&lt;/code&gt; and either &lt;code&gt;MAX_PATH&lt;/code&gt; or &lt;code&gt;PATH_MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MAX_PATH&lt;/code&gt; строку с &lt;code&gt;#define&lt;/code&gt; и MAX_PATH или &lt;code&gt;PATH_MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="432adcaf916374b14ccc5f4491d7cd8a1e3d3e44" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;NODE&lt;/code&gt; or &lt;code&gt;Unexpected&lt;/code&gt; in files that have lines that match both.</source>
          <target state="translated">Ищет строку с &lt;code&gt;NODE&lt;/code&gt; или &lt;code&gt;Unexpected&lt;/code&gt; в файлах, в которых есть строки, соответствующие обоим.</target>
        </trans-unit>
        <trans-unit id="b11d66d44e8db145700e0edb6375620b652f740a" translate="yes" xml:space="preserve">
          <source>Low-level commands (plumbing)</source>
          <target state="translated">Команды низкого уровня (водопровод)</target>
        </trans-unit>
        <trans-unit id="0ffc3dae4e51a700bf1ca804b93845e0102810f8" translate="yes" xml:space="preserve">
          <source>Low-level git operations</source>
          <target state="translated">Низкоуровневые операции с гитами</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="5d487fc78e43a0306fd5f718aec828744ee6e786" translate="yes" xml:space="preserve">
          <source>M: modification of the contents or mode of a file</source>
          <target state="translated">М:изменение содержимого или режима файла</target>
        </trans-unit>
        <trans-unit id="0f48f030cf13414eeafe91359c3c62bf97314f35" translate="yes" xml:space="preserve">
          <source>Magic Options</source>
          <target state="translated">Волшебные варианты</target>
        </trans-unit>
        <trans-unit id="7d828d176880cf3ec5ec8010d93f54010eebda7b" translate="yes" xml:space="preserve">
          <source>Maildir splitting relies upon filenames being sorted to output patches in the correct order.</source>
          <target state="translated">Разделение Мейлдир основывается на сортировке имен файлов для вывода патчей в правильном порядке.</target>
        </trans-unit>
        <trans-unit id="57a6217babf3a984d54a72505b0f2a4f3e1be542" translate="yes" xml:space="preserve">
          <source>Main porcelain commands</source>
          <target state="translated">Главные фарфоровые команды</target>
        </trans-unit>
        <trans-unit id="46b62a0f964fab2f018eee342e7b4db44adbc685" translate="yes" xml:space="preserve">
          <source>Maintaining topic branches for a Linux subsystem maintainer</source>
          <target state="translated">Ведение тематических ветвей для сопровождающего подсистемы Linux</target>
        </trans-unit>
        <trans-unit id="52f0f393e457cb924c234a7254a4daec3a0cbf32" translate="yes" xml:space="preserve">
          <source>Maintenance branch management after a feature release</source>
          <target state="translated">Управление филиалами обслуживания после выпуска функции</target>
        </trans-unit>
        <trans-unit id="319909b05c9210e6ff8b8a19f69dc9189ee2cca4" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git gc --auto&lt;/code&gt; return immediately and run in background if the system supports it. Default is true.</source>
          <target state="translated">Сделайте так, чтобы &lt;code&gt;git gc --auto&lt;/code&gt; возвращался немедленно и запускался в фоновом режиме, если система это поддерживает. По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="77c42361d50b9bdea29b692160b9eae95cceb52e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git show-ref&lt;/code&gt; act as a filter that reads refs from stdin of the form &quot;&lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt;&quot; and performs the following actions on each: (1) strip &quot;^{}&quot; at the end of line if any; (2) ignore if pattern is provided and does not head-match refname; (3) warn if refname is not a well-formed refname and skip; (4) ignore if refname is a ref that exists in the local repository; (5) otherwise output the line.</source>
          <target state="translated">Сделайте &lt;code&gt;git show-ref&lt;/code&gt; фильтром, который считывает ссылки со стандартного ввода в форме &quot; &lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt; &quot; И выполняет следующие действия с каждым : (1) убрать &quot;^ {}&quot; в конце строки, если есть; (2) игнорировать, если указан шаблон и не соответствует заголовку refname; (3) предупреждать, если имя ссылки не является правильно сформированным именем ссылки, и пропускать; (4) игнорировать, если refname является ссылкой, которая существует в локальном репозитории; (5) в противном случае выведите строку.</target>
        </trans-unit>
        <trans-unit id="51befbcaeb5eba297db1a634b8802a7f0078cead" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git svn&lt;/code&gt; less verbose. Specify a second time to make it even less verbose.</source>
          <target state="translated">Сделайте &lt;code&gt;git svn&lt;/code&gt; менее подробным. Укажите второй раз, чтобы сделать его еще менее подробным.</target>
        </trans-unit>
        <trans-unit id="2da3bd3f8069e8e437af583aecc3a384c81edd34" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;bare&lt;/code&gt; Git repository. That is, instead of creating &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; and placing the administrative files in &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt;, make the &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; itself the &lt;code&gt;$GIT_DIR&lt;/code&gt;. This obviously implies the &lt;code&gt;--no-checkout&lt;/code&gt; because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to &lt;code&gt;refs/remotes/origin/&lt;/code&gt;. When this option is used, neither remote-tracking branches nor the related configuration variables are created.</source>
          <target state="translated">Сделать &lt;code&gt;bare&lt;/code&gt; репозиторий. То есть, вместо того чтобы создавать &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; и размещения административных файлов в &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt; , сделать &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; сам по &lt;code&gt;$GIT_DIR&lt;/code&gt; . Это, очевидно, подразумевает &lt;code&gt;--no-checkout&lt;/code&gt; , потому что некуда проверить рабочее дерево. Кроме того, главы веток на удаленном компьютере копируются непосредственно в соответствующие локальные главы веток, не отображая их в &lt;code&gt;refs/remotes/origin/&lt;/code&gt; . При использовании этой опции не создаются ни ветви удаленного отслеживания, ни соответствующие переменные конфигурации.</target>
        </trans-unit>
        <trans-unit id="6ca024f41825508ff37398849dd7bbbd184e78e6" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the default e-mail address&amp;rsquo;s key. The default behavior of tag GPG-signing is controlled by &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable if it exists, or disabled otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Сделайте тег, подписанный GPG, используя ключ адреса электронной почты по умолчанию. Поведение по умолчанию для подписи тега GPG контролируется &lt;code&gt;tag.gpgSign&lt;/code&gt; конфигурации tag.gpgSign, если она существует, или отключена в противном случае. См. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a6f6bd2dfbdab5f143e86ea9155fad4e43a30c" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the given key.</source>
          <target state="translated">Сделайте тег,подписанный GPG,используя данный ключ.</target>
        </trans-unit>
        <trans-unit id="99f2296af5452e1eec1986dbc7a0151a5ba6b1fc" translate="yes" xml:space="preserve">
          <source>Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of &lt;code&gt;git commit&lt;/code&gt; if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with &lt;code&gt;--amend&lt;/code&gt;, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with &lt;code&gt;--allow-empty&lt;/code&gt; paths are also not required, and an empty commit will be created.</source>
          <target state="translated">Сделайте фиксацию, взяв обновленное содержимое рабочего дерева из путей, указанных в командной строке, игнорируя любое содержимое, которое было размещено для других путей. Это режим работы &lt;code&gt;git commit&lt;/code&gt; по умолчанию, если в командной строке указаны какие-либо пути, и в этом случае этот параметр можно опустить. Если этот параметр указан вместе с параметром &lt;code&gt;--amend&lt;/code&gt; , то пути указывать не нужно, которые можно использовать для внесения поправок в последнюю фиксацию без фиксации уже внесенных изменений. При использовании вместе с &lt;code&gt;--allow-empty&lt;/code&gt; пути также не требуются, и будет создана пустая фиксация.</target>
        </trans-unit>
        <trans-unit id="2e9bf6a1a9ac175346438fe9d4c19601601a0ebd" translate="yes" xml:space="preserve">
          <source>Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below).</source>
          <target state="translated">Составьте список коммитов,которые скоро будут возвращены.Позвольте пользователю отредактировать этот список перед перебазированием.Этот режим также может быть использован для разделения коммитов (см.ниже SPLITTING COMMITS).</target>
        </trans-unit>
        <trans-unit id="f382849103310ffba0e3d31128dfababfd915957" translate="yes" xml:space="preserve">
          <source>Make a local clone that borrows from the current directory, without checking things out:</source>
          <target state="translated">Сделайте локальный клон,который заимствует из текущего каталога,не проверяя вещи:</target>
        </trans-unit>
        <trans-unit id="d7a3e91b3667d18f363db6d6cc32c0afec1ed1d5" translate="yes" xml:space="preserve">
          <source>Make a side branch for every topic (feature, bugfix, &amp;hellip;​). Fork it off at the oldest integration branch that you will eventually want to merge it into.</source>
          <target state="translated">Сделайте боковую ветку для каждой темы (функция, исправление,&amp;hellip;). Разветвите его в самой старой ветке интеграции, с которой вы в конечном итоге захотите объединить ее.</target>
        </trans-unit>
        <trans-unit id="89db797c5d89c53349b8d88ec549bb720f48d1f7" translate="yes" xml:space="preserve">
          <source>Make an unsigned, annotated tag object</source>
          <target state="translated">Сделать неподписанный,аннотированный тег объекта</target>
        </trans-unit>
        <trans-unit id="f88ecf2f4eb0c5509c792cd2c61ea44a524baf96" translate="yes" xml:space="preserve">
          <source>Make corrections to working tree files.</source>
          <target state="translated">Внести исправления в рабочие файлы дерева.</target>
        </trans-unit>
        <trans-unit id="79ee7beb56d7493ce335c85dd0a8333674bff17b" translate="yes" xml:space="preserve">
          <source>Make git-send-email less verbose. One line per email should be all that is output.</source>
          <target state="translated">Сделать гит-сенд-эмейл менее многословным.Одна строка на электронную почту должна быть всем,что выводится.</target>
        </trans-unit>
        <trans-unit id="ff429cc18c1dac972928cb3da6e4d06bbfe2d8ec" translate="yes" xml:space="preserve">
          <source>Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.</source>
          <target state="translated">Сделайте один коммит и вернитесь в оболочку,когда она будет завершена.Эта команда возвращает ненулевой код выхода,если окно было закрыто каким-либо другим способом,кроме как с помощью коммита.</target>
        </trans-unit>
        <trans-unit id="31ca9c9bf3eab94aff99250728fe74f77977b844" translate="yes" xml:space="preserve">
          <source>Make sure Git knows who to blame:</source>
          <target state="translated">Убедись,что Гит знает,кого винить:</target>
        </trans-unit>
        <trans-unit id="cf12b54cc8063982ae2c9b96588de4f236c9e743" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;.</source>
          <target state="translated">Убедитесь, что все коммиты подмодулей, используемые отправляемыми ревизиями, доступны в ветви удаленного отслеживания. Если установлено значение &lt;code&gt;check&lt;/code&gt; , Git проверит, что все коммиты подмодуля, измененные в отправляемых ревизиях, доступны по крайней мере на одном удаленном подмодуле. Если какие-либо коммиты отсутствуют, push будет прерван и завершится с ненулевым статусом. Если значение задано &lt;code&gt;on-demand&lt;/code&gt; то все подмодули, которые изменились в ревизиях, которые нужно отправить, будут отправлены. Если по запросу не удалось отправить все необходимые изменения, он также будет прерван и выйдет с ненулевым статусом. Если значение равно &amp;laquo; &lt;code&gt;no&lt;/code&gt; то поведение по умолчанию - игнорирование подмодулей при нажатии - сохраняется. Вы можете переопределить эту конфигурацию во время отправки, указав &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e58089d4f2b4b0ca2024cc65ec03ed1d72bcb40" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;. If not set, &lt;code&gt;no&lt;/code&gt; is used by default, unless &lt;code&gt;submodule.recurse&lt;/code&gt; is set (in which case a &lt;code&gt;true&lt;/code&gt; value means &lt;code&gt;on-demand&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b6629c434b51e7d9186d1fc6fe97c1a3725440" translate="yes" xml:space="preserve">
          <source>Make sure committers have a umask of at most 027, so that the directories they create are writable and searchable by other group members.</source>
          <target state="translated">Убедитесь,что у коммиттеров есть маска не более 027,чтобы создаваемые ими каталоги были доступны для записи и поиска другими членами группы.</target>
        </trans-unit>
        <trans-unit id="4b35196a3d616941ad0c8a125c3a9f25e1bdc376" translate="yes" xml:space="preserve">
          <source>Make sure this directory is available for others you want your changes to be pulled via the transport of your choice. Also you need to make sure that you have the &lt;code&gt;git-receive-pack&lt;/code&gt; program on the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">Убедитесь, что этот каталог доступен для других, вы хотите, чтобы ваши изменения были извлечены с помощью выбранного вами транспорта. Также вам нужно убедиться, что у вас есть программа &lt;code&gt;git-receive-pack&lt;/code&gt; в &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6631b9ca24ae751d7ee25163002526a066325c25" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given &amp;lt;message id&amp;gt;, which avoids breaking threads to provide a new patch series.</source>
          <target state="translated">Сделайте так, чтобы первое письмо (или все сообщения с &lt;code&gt;--no-thread&lt;/code&gt; ) отображалось как ответ на заданный &amp;lt;идентификатор сообщения&amp;gt;, что позволяет избежать прерывания потоков для предоставления новой серии исправлений.</target>
        </trans-unit>
        <trans-unit id="5a1ce0ecb5c94a2505e8bfd1950281f48170d98f" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given Message-Id, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; setting.</source>
          <target state="translated">Сделать так, чтобы первое сообщение (или все сообщения с &lt;code&gt;--no-thread&lt;/code&gt; ) отображалось как ответ на заданный идентификатор сообщения, что позволяет избежать прерывания потоков для предоставления новой серии исправлений. Второе и последующие электронные письма будут отправлены как ответы в соответствии &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; настройкой - [no-] chain-reply-to .</target>
        </trans-unit>
        <trans-unit id="b064d6e8766baf86355fa160624701d28d48e0eb" translate="yes" xml:space="preserve">
          <source>Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.</source>
          <target state="translated">Выход из программы с кодами,аналогичными diff(1).То есть она выходит с 1,если были различия,а 0 означает отсутствие различий.</target>
        </trans-unit>
        <trans-unit id="033698ff1d93839c9dc26bb7039e879974408d51" translate="yes" xml:space="preserve">
          <source>Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is &lt;code&gt;0022&lt;/code&gt;, using &lt;code&gt;group&lt;/code&gt; will not remove read privileges from other (non-group) users). See &lt;code&gt;0xxx&lt;/code&gt; for how to exactly specify the repository permissions.</source>
          <target state="translated">Сделайте группу репозитория доступной для записи (и g + sx, поскольку группа git может не быть основной группой для всех пользователей). Это используется для ослабления разрешений в противном случае безопасного значения umask (2). Обратите внимание, что umask по-прежнему применяется к другим битам разрешений (например, если umask равен &lt;code&gt;0022&lt;/code&gt; , использование &lt;code&gt;group&lt;/code&gt; не приведет к удалению привилегий чтения у других (не входящих в группу) пользователей). См. &lt;code&gt;0xxx&lt;/code&gt; , чтобы узнать, как точно указать разрешения для репозитория.</target>
        </trans-unit>
        <trans-unit id="daa563a54f59f3d95749377d0e4af4c611fecd18" translate="yes" xml:space="preserve">
          <source>Making a change</source>
          <target state="translated">Изменение</target>
        </trans-unit>
        <trans-unit id="9aef7fbf27451a8c36fe7bf7a109aea9540e01ca" translate="yes" xml:space="preserve">
          <source>Making changes</source>
          <target state="translated">Внесение изменений</target>
        </trans-unit>
        <trans-unit id="992a7beb5615876037da9b0e5b4a3e7c21af51d8" translate="yes" xml:space="preserve">
          <source>Making some changes to the working directory using your favorite editor.</source>
          <target state="translated">Внесение некоторых изменений в рабочий каталог с помощью любимого редактора.</target>
        </trans-unit>
        <trans-unit id="bf4919466a0f70dfd02acc3627e75ad16a05f620" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees</source>
          <target state="translated">Управление несколькими рабочими деревьями</target>
        </trans-unit>
        <trans-unit id="6ec4a25401fa228522c7be97da233480069758e8" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees attached to the same repository.</source>
          <target state="translated">Управлять несколькими рабочими деревьями,прикрепленными к одному и тому же репозиторию.</target>
        </trans-unit>
        <trans-unit id="5f089a6eb7f251a9a2fe0a3f833141f8db37c3ff" translate="yes" xml:space="preserve">
          <source>Manage reflog information</source>
          <target state="translated">Управление информацией рефлога</target>
        </trans-unit>
        <trans-unit id="021ab6f7ef8793b1b816ea4bdd5e727ce06994e0" translate="yes" xml:space="preserve">
          <source>Manage set of tracked repositories</source>
          <target state="translated">Управление набором отслеживаемых репозиториев</target>
        </trans-unit>
        <trans-unit id="65f908ba554d3d8c75571c008e2b6e59e8585d63" translate="yes" xml:space="preserve">
          <source>Manage the serialized commit-graph file.</source>
          <target state="translated">Управление сериализованным файлом коммит-графика.</target>
        </trans-unit>
        <trans-unit id="4a3e0eed31d02104159aa0bed6d5acb0e05768b8" translate="yes" xml:space="preserve">
          <source>Manage the set of repositories (&quot;remotes&quot;) whose branches you track.</source>
          <target state="translated">Управляйте набором репозиториев (&quot;пультов&quot;),ветки которых вы отслеживаете.</target>
        </trans-unit>
        <trans-unit id="3507e0027b822825db37aad1b6a1e0779dcd0d96" translate="yes" xml:space="preserve">
          <source>Managing branches</source>
          <target state="translated">Управляющие филиалы</target>
        </trans-unit>
        <trans-unit id="279735249dbe3dcc024592a529bd9cb39b1b8496" translate="yes" xml:space="preserve">
          <source>Manipulate the notes tree in &amp;lt;ref&amp;gt;. This overrides &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; and the &quot;core.notesRef&quot; configuration. The ref specifies the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">Управляйте деревом заметок в &amp;lt;ref&amp;gt;. Это отменяет &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; и конфигурацию core.notesRef. Ссылка указывает полное имя ссылки, когда она начинается с &lt;code&gt;refs/notes/&lt;/code&gt; ; когда он начинается с &lt;code&gt;notes/&lt;/code&gt; , &lt;code&gt;refs/&lt;/code&gt; и в противном случае &lt;code&gt;refs/notes/&lt;/code&gt; имеет префикс, чтобы сформировать полное имя ссылки.</target>
        </trans-unit>
        <trans-unit id="ad0e6ab545d99b4fca1e842f2d64e34b5bf6ca91" translate="yes" xml:space="preserve">
          <source>Manipulating branches</source>
          <target state="translated">Манипулирующие ветви</target>
        </trans-unit>
        <trans-unit id="e163593ceb018ccfe91e5474069f8880c01bf32f" translate="yes" xml:space="preserve">
          <source>Manipulation commands</source>
          <target state="translated">Команды манипулирования</target>
        </trans-unit>
        <trans-unit id="a4c79f29e9d9d5fa1534359d2910523c3bd41716" translate="yes" xml:space="preserve">
          <source>Manipulators:</source>
          <target state="translated">Manipulators:</target>
        </trans-unit>
        <trans-unit id="2d6fc489721f7990b3e0a46d8dbd0fae7613420d" translate="yes" xml:space="preserve">
          <source>Many (most?) public remote repositories will not contain any of the checked out files or even an index file, and will &lt;strong&gt;only&lt;/strong&gt; contain the actual core Git files. Such a repository usually doesn&amp;rsquo;t even have the &lt;code&gt;.git&lt;/code&gt; subdirectory, but has all the Git files directly in the repository.</source>
          <target state="translated">Многие (большинство?) Общедоступных удаленных репозиториев не будут содержать никаких извлеченных файлов или даже индексного файла, а будут содержать &lt;strong&gt;только&lt;/strong&gt; фактические файлы ядра Git. В таком репозитории обычно даже нет подкаталога &lt;code&gt;.git&lt;/code&gt; , но все файлы Git находятся непосредственно в репозитории.</target>
        </trans-unit>
        <trans-unit id="23a4d8d6b8951ee492fd478361a461e34445c192" translate="yes" xml:space="preserve">
          <source>Many Git commands also take sets of commits, which can be specified in a number of ways. Here are some examples with &lt;code&gt;git log&lt;/code&gt;:</source>
          <target state="translated">Многие команды Git также принимают наборы коммитов, которые можно указать разными способами. Вот несколько примеров с &lt;code&gt;git log&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb5f624f4f524730b1dad471a4cc62df1265c105" translate="yes" xml:space="preserve">
          <source>Many Git commands take revision parameters as arguments. Depending on the command, they denote a specific commit or, for commands which walk the revision graph (such as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;), all commits which are reachable from that commit. For commands that walk the revision graph one can also specify a range of revisions explicitly.</source>
          <target state="translated">Многие команды Git принимают параметры редакции в качестве аргументов. В зависимости от команды они обозначают конкретную фиксацию или, для команд, которые проходят по графу ревизий (например, &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; ), все коммиты, доступные из этой фиксации. Для команд, которые проходят по графу ревизий, можно также явно указать диапазон ревизий.</target>
        </trans-unit>
        <trans-unit id="8eadff7d5c23284bf3e40779cca1324c9880e38b" translate="yes" xml:space="preserve">
          <source>Many Git porcelainish commands take mixture of flags (i.e. parameters that begin with a dash &lt;code&gt;-&lt;/code&gt;) and parameters meant for the underlying &lt;code&gt;git rev-list&lt;/code&gt; command they use internally and flags and parameters for the other commands they use downstream of &lt;code&gt;git rev-list&lt;/code&gt;. This command is used to distinguish between them.</source>
          <target state="translated">Многие фарфоровые команды Git принимают сочетание флагов (т.е. параметров, начинающихся с тире &lt;code&gt;-&lt;/code&gt; ) и параметров, предназначенных для базовой команды &lt;code&gt;git rev-list&lt;/code&gt; ,которую они используют внутри, а также флагов и параметров для других команд, которые они используют ниже по течению от &lt;code&gt;git rev-list&lt;/code&gt; . Эта команда используется, чтобы различать их.</target>
        </trans-unit>
        <trans-unit id="07f9a7fabb84ff55c93b5220c84bc1016373588c" translate="yes" xml:space="preserve">
          <source>Many command-line options can be provided as part of the fast-import stream itself by using the &lt;code&gt;feature&lt;/code&gt; or &lt;code&gt;option&lt;/code&gt; commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line. This currently impacts only the &lt;code&gt;export-marks&lt;/code&gt;, &lt;code&gt;import-marks&lt;/code&gt;, and &lt;code&gt;import-marks-if-exists&lt;/code&gt; feature commands.</source>
          <target state="translated">Многие параметры командной строки могут быть предоставлены как часть самого потока быстрого импорта с помощью команд &lt;code&gt;feature&lt;/code&gt; или &lt;code&gt;option&lt;/code&gt; . Однако некоторые из этих параметров небезопасны (например, разрешение быстрого импорта для доступа к файловой системе за пределами репозитория). По умолчанию эти параметры отключены, но их можно разрешить, указав этот параметр в командной строке. В настоящее время это влияет только на команды функций &lt;code&gt;export-marks&lt;/code&gt; , &lt;code&gt;import-marks&lt;/code&gt; и &lt;code&gt;import-marks-if-exists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b810424b3fea997d54a1c6f50a7ffa7b2bdf31cc" translate="yes" xml:space="preserve">
          <source>Many commands allow wildcards in paths, but you need to protect them from getting globbed by the shell. These two mean different things:</source>
          <target state="translated">Многие команды позволяют использовать подстановочные знаки на дорожках,но необходимо защитить их от засорения оболочкой.Эти две вещи означают разные вещи:</target>
        </trans-unit>
        <trans-unit id="f769735173b4b17536b3bddf331e35fc94c1f6c2" translate="yes" xml:space="preserve">
          <source>Many commands take revisions (most often &quot;commits&quot;, but sometimes &quot;tree-ish&quot;, depending on the context and command) and paths as their arguments. Here are the rules:</source>
          <target state="translated">Многие команды принимают в качестве аргументов ревизии (чаще всего &quot;коммиты&quot;,но иногда &quot;древовидные&quot;,в зависимости от контекста и команды)и пути.Вот правила:</target>
        </trans-unit>
        <trans-unit id="51a04d163df59d3e4e585f46784dd69c625e4feb" translate="yes" xml:space="preserve">
          <source>Many commands that can work on files in the working tree and/or in the index can take &lt;code&gt;--cached&lt;/code&gt; and/or &lt;code&gt;--index&lt;/code&gt; options. Sometimes people incorrectly think that, because the index was originally called cache, these two are synonyms. They are &lt;strong&gt;not&lt;/strong&gt; &amp;mdash; these two options mean very different things.</source>
          <target state="translated">Многие команды, которые могут работать с файлами в рабочем дереве и / или в индексе, могут принимать параметры &lt;code&gt;--cached&lt;/code&gt; и / или &lt;code&gt;--index&lt;/code&gt; . Иногда люди ошибочно думают, что, поскольку индекс изначально назывался кешем, эти два слова являются синонимами. Это &lt;strong&gt;не так&lt;/strong&gt; - эти два варианта означают очень разные вещи.</target>
        </trans-unit>
        <trans-unit id="41a419d79cd72b9d54b27ecee9672655c35e91cc" translate="yes" xml:space="preserve">
          <source>Many gitweb features can be enabled (or disabled) and configured using the &lt;code&gt;%feature&lt;/code&gt; hash. Names of gitweb features are keys of this hash.</source>
          <target state="translated">Многие функции gitweb можно включить (или отключить) и настроить с помощью хэша &lt;code&gt;%feature&lt;/code&gt; . Имена функций gitweb являются ключами этого хэша.</target>
        </trans-unit>
        <trans-unit id="919a2ac82af6ff1bc82b2171d1abca264db10f6e" translate="yes" xml:space="preserve">
          <source>Many installations of sshd do not invoke your shell as the login shell when you directly run programs; what this means is that if your login shell is &lt;em&gt;bash&lt;/em&gt;, only &lt;code&gt;.bashrc&lt;/code&gt; is read and not &lt;code&gt;.bash_profile&lt;/code&gt;. As a workaround, make sure &lt;code&gt;.bashrc&lt;/code&gt; sets up &lt;code&gt;$PATH&lt;/code&gt; so that you can run &lt;em&gt;git-receive-pack&lt;/em&gt; program.</source>
          <target state="translated">Многие установки sshd не вызывают вашу оболочку как оболочку входа в систему, когда вы напрямую запускаете программы; это означает, что если ваша оболочка входа - &lt;em&gt;bash&lt;/em&gt; , читается только &lt;code&gt;.bashrc&lt;/code&gt; , а не &lt;code&gt;.bash_profile&lt;/code&gt; . В качестве обходного пути убедитесь, что &lt;code&gt;.bashrc&lt;/code&gt; устанавливает &lt;code&gt;$PATH&lt;/code&gt; чтобы вы могли запустить программу &lt;em&gt;git-receive-pack&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b683891958210e2ee979b3e8c7ad10f12997dda2" translate="yes" xml:space="preserve">
          <source>Many mailers if not set up properly will corrupt whitespace. Here are two common types of corruption:</source>
          <target state="translated">Многие почтовые программы при неправильной настройке повреждают пробельные символы.Вот два распространённых типа коррупции:</target>
        </trans-unit>
        <trans-unit id="193dde6b7f3a20700543ed6450f24935f7b33dfa" translate="yes" xml:space="preserve">
          <source>Many of the higher-level commands were originally implemented as shell scripts using a smaller core of low-level Git commands. These can still be useful when doing unusual things with Git, or just as a way to understand its inner workings.</source>
          <target state="translated">Многие команды более высокого уровня были изначально реализованы в виде скриптов оболочки,использующих меньшее ядро низкоуровневых команд Git'а.Они всё ещё могут быть полезны при работе с Git'ом,или просто как способ понять его внутреннюю работу.</target>
        </trans-unit>
        <trans-unit id="3d6c28c55f8170d273c49f3e427a981c665cf6ea" translate="yes" xml:space="preserve">
          <source>Many operations in Git depend on your filesystem to have an efficient &lt;code&gt;lstat(2)&lt;/code&gt; implementation, so that &lt;code&gt;st_mtime&lt;/code&gt; information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file. Unfortunately, some filesystems have inefficient &lt;code&gt;lstat(2)&lt;/code&gt;. If your filesystem is one of them, you can set &quot;assume unchanged&quot; bit to paths you have not changed to cause Git not to do this check. Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed &amp;mdash; it makes Git to omit any checking and assume it has &lt;strong&gt;not&lt;/strong&gt; changed. When you make changes to working tree files, you have to explicitly tell Git about it by dropping &quot;assume unchanged&quot; bit, either before or after you modify them.</source>
          <target state="translated">Многие операции в Git зависят от вашей файловой системы, чтобы иметь эффективную реализацию &lt;code&gt;lstat(2)&lt;/code&gt; , поэтому информацию &lt;code&gt;st_mtime&lt;/code&gt; для рабочих файлов дерева можно дешево проверить, чтобы увидеть, изменилось ли содержимое файла по сравнению с версией, записанной в индексном файле. К сожалению, в некоторых файловых системах &lt;code&gt;lstat(2)&lt;/code&gt; неэффективен . Если ваша файловая система является одной из них, вы можете установить бит &amp;laquo;считать неизменным&amp;raquo; для путей, которые вы не изменили, чтобы Git не выполнял эту проверку. Обратите внимание, что установка этого бита в пути не означает, что Git проверит содержимое файла, чтобы узнать, не изменилось ли оно - это заставляет Git пропускать любую проверку и предполагать, что это &lt;strong&gt;не так.&lt;/strong&gt;изменилось. Когда вы вносите изменения в файлы рабочего дерева, вы должны явно сообщить об этом Git, отбросив бит &amp;laquo;считать неизменным&amp;raquo; до или после их изменения.</target>
        </trans-unit>
        <trans-unit id="a799d1cceae5d3b6566df7c502b0ed31229cf195" translate="yes" xml:space="preserve">
          <source>Many revision control systems provide an &lt;code&gt;add&lt;/code&gt; command that tells the system to start tracking changes to a new file. Git&amp;rsquo;s &lt;code&gt;add&lt;/code&gt; command does something simpler and more powerful: &lt;code&gt;git add&lt;/code&gt; is used both for new and newly modified files, and in both cases it takes a snapshot of the given files and stages that content in the index, ready for inclusion in the next commit.</source>
          <target state="translated">Многие системы контроля версий предоставляют команду &lt;code&gt;add&lt;/code&gt; которая сообщает системе, что нужно начать отслеживание изменений в новом файле. Команда Git &lt;code&gt;add&lt;/code&gt; делает что-то более простое и мощное: &lt;code&gt;git add&lt;/code&gt; используется как для новых, так и для вновь измененных файлов, и в обоих случаях он делает снимок данных файлов и помещает это содержимое в индекс, готовое для включения в следующую фиксацию.</target>
        </trans-unit>
        <trans-unit id="f4ad3aa56684a237b2a48778413d62e45b68868b" translate="yes" xml:space="preserve">
          <source>Many tags. Will create a tag for every commit, reflecting the commit name in the Arch repository.</source>
          <target state="translated">Много меток.Создает метку для каждого коммита,отражающую имя коммита в репозитории Архива.</target>
        </trans-unit>
        <trans-unit id="6b4939f173ca46ae5e70f2a578215c85acafb3ce" translate="yes" xml:space="preserve">
          <source>Many thanks to Ingo Molnar for giving me very useful information that appears in this paper, for commenting on this paper, for his suggestions to improve &quot;git bisect&quot; and for evangelizing &quot;git bisect&quot; on the linux kernel mailing lists.</source>
          <target state="translated">Большое спасибо Инго Молнару за то,что дал мне очень полезную информацию,которая появилась в этой статье,за комментарии к этой статье,за его предложения по улучшению &quot;git-бисекта&quot; и за евангелизацию &quot;git-бисекта&quot; в списках рассылки ядра linux.</target>
        </trans-unit>
        <trans-unit id="5bd4feea472ac1f81e9eed337015c1647da376b9" translate="yes" xml:space="preserve">
          <source>Many thanks to Junio Hamano for his help in reviewing this paper, for reviewing the patches I sent to the Git mailing list, for discussing some ideas and helping me improve them, for improving &quot;git bisect&quot; a lot and for his awesome work in maintaining and developing Git.</source>
          <target state="translated">Большое спасибо Хунио Хамано за его помощь в рецензировании этой статьи,за рецензию на патчи,которые я отправил в список рассылки Git'а,за обсуждение некоторых идей и помощь в их улучшении,за то,что он много улучшил &quot;git-бисект&quot; и за его потрясающую работу по поддержке и развитию Git'а.</target>
        </trans-unit>
        <trans-unit id="a308e878405ccac0452dc3a943e6c4f471d0d0f3" translate="yes" xml:space="preserve">
          <source>Many thanks to Linus Torvalds for inventing, developing and evangelizing &quot;git bisect&quot;, Git and Linux.</source>
          <target state="translated">Большое спасибо Линусу Торвальдсу за изобретение,разработку и евангелизацию &quot;git-бисекта&quot;,Git и Linux.</target>
        </trans-unit>
        <trans-unit id="64e052904657c30a32be467111b38e2db70890d3" translate="yes" xml:space="preserve">
          <source>Many thanks to the Linux-Kongress program committee for choosing the author to given a talk and for publishing this paper.</source>
          <target state="translated">Большое спасибо программному комитету Linux-Kongress за выбор автора для выступления и за публикацию этой статьи.</target>
        </trans-unit>
        <trans-unit id="a813e2d801820a3507d225cfe410c73c1e3814a5" translate="yes" xml:space="preserve">
          <source>Many thanks to the many other great people who helped one way or another when I worked on Git, especially to Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour.</source>
          <target state="translated">Большое спасибо многим другим великим людям,которые так или иначе помогали мне,когда я работал над Git,особенно Андреасу Эрикссону,Иоганнесу Шинделину,Х.Питеру Анвину,Дэниэлу Баркалоу,Биллу Лиру,Джону Хоули,Шону О.Пирсу,Джеффу Кингу,Сэму Вилайну,Джону Сеймуру.</target>
        </trans-unit>
        <trans-unit id="970bd5edbccf4926f346f36ced29b782ff134b0f" translate="yes" xml:space="preserve">
          <source>Many things can then be done very naturally:</source>
          <target state="translated">Тогда многие вещи можно делать очень естественно:</target>
        </trans-unit>
        <trans-unit id="08ed471839ae0d35cbf114cdc8b4fb025451ea78" translate="yes" xml:space="preserve">
          <source>Map a P4 user to a name and email address in Git. Use a string with the following format to create a mapping:</source>
          <target state="translated">Свяжите пользователя P4 с именем и адресом электронной почты в Git'е.Для создания карты используйте строку следующего формата:</target>
        </trans-unit>
        <trans-unit id="84e3b6902de1ae94c28d951dff280df12bc818fa" translate="yes" xml:space="preserve">
          <source>Mapping authors</source>
          <target state="translated">Авторы карт</target>
        </trans-unit>
        <trans-unit id="ecca08ad6644372b493b29196801e0262451ee0a" translate="yes" xml:space="preserve">
          <source>Mapping between Subversion revision numbers and Git commit names. In a repository where the noMetadata option is not set, this can be rebuilt from the git-svn-id: lines that are at the end of every commit (see the &lt;code&gt;svn.noMetadata&lt;/code&gt; section above for details).</source>
          <target state="translated">Сопоставление номеров ревизий Subversion и имен коммитов Git. В репозитории, где параметр noMetadata не установлен, его можно перестроить из строк git-svn-id: в конце каждой фиксации (подробности см. &lt;code&gt;svn.noMetadata&lt;/code&gt; разделе svn.noMetadata выше).</target>
        </trans-unit>
        <trans-unit id="f80c6e32aadbd525747e2562fb58002684c64ae1" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we attributed to another commit with a &lt;code&gt;?&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">Отметьте строки, которые были изменены проигнорированной ревизией, которую мы приписали другой фиксации, знаком &lt;code&gt;?&lt;/code&gt; в выводе &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a93a83bc77d4e299bb423ede0b0e7523360c05" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we could not attribute to another commit with a &lt;code&gt;*&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">Отметьте строки, которые были изменены проигнорированной ревизией, которую мы не могли отнести к другой фиксации, знаком &lt;code&gt;*&lt;/code&gt; в выводе &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffa04a5e9e510ce8e8a9af22652c96cb5f2a2455" translate="yes" xml:space="preserve">
          <source>Mark the commit you want to split with the action &quot;edit&quot;.</source>
          <target state="translated">Отметьте коммит,который вы хотите разделить,действием &quot;редактировать&quot;.</target>
        </trans-unit>
        <trans-unit id="9ad05336158823a7d5e9d2740631e3ed3e7b77cc" translate="yes" xml:space="preserve">
          <source>Mark the series as the &amp;lt;n&amp;gt;-th iteration of the topic. The output filenames have &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; prepended to them, and the subject prefix (&quot;PATCH&quot; by default, but configurable via the &lt;code&gt;--subject-prefix&lt;/code&gt; option) has ` v&amp;lt;n&amp;gt;` appended to it. E.g. &lt;code&gt;--reroll-count=4&lt;/code&gt; may produce &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; file that has &quot;Subject: [PATCH v4 1/20] Add makefile&quot; in it.</source>
          <target state="translated">Отметьте серию как &amp;lt;n&amp;gt; -ю итерацию темы. К выходным именам файлов добавляется &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; , а к префиксу темы (по умолчанию &quot;PATCH&quot;, но можно настроить с помощью параметра &lt;code&gt;--subject-prefix&lt;/code&gt; ) добавлено `v &amp;lt;n&amp;gt;`. Например, &lt;code&gt;--reroll-count=4&lt;/code&gt; может создать &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; , содержащий &amp;laquo;Тема: [PATCH v4 1/20] Добавить makefile&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="eb02cc756d5e31341021dd6b9e08120c18cfff12" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with &lt;code&gt;&amp;lt;&lt;/code&gt; and those from the right with &lt;code&gt;&amp;gt;&lt;/code&gt;. If combined with &lt;code&gt;--boundary&lt;/code&gt;, those commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">Отметьте, с какой стороны симметричной разницы доступна фиксация. Коммиты с левой стороны имеют префикс &lt;code&gt;&amp;lt;&lt;/code&gt; , а коммиты справа - &lt;code&gt;&amp;gt;&lt;/code&gt; . В сочетании с &lt;code&gt;--boundary&lt;/code&gt; эти коммиты имеют префикс &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf65e398a783b020004a05bc4b12965bd321675" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with a &lt;code&gt;&amp;lt;&lt;/code&gt; symbol and those from the right with a &lt;code&gt;&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">Отметьте, с какой стороны симметричной разницы доступна фиксация. Коммиты с левой стороны имеют префикс &lt;code&gt;&amp;lt;&lt;/code&gt; символа, а коммиты справа - с символом &lt;code&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d120d1dcfa9af04a37a29923ad102f9ac75edbe0" translate="yes" xml:space="preserve">
          <source>Marking files as binary</source>
          <target state="translated">Файлы с маркировкой как двоичные</target>
        </trans-unit>
        <trans-unit id="3549e52dba075c1ca63de7856965a26fd121848f" translate="yes" xml:space="preserve">
          <source>Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes, depending on pointer size) per mark. Although the array is sparse, frontends are still strongly encouraged to use marks between 1 and n, where n is the total number of marks required for this import.</source>
          <target state="translated">Марки хранятся в разреженном массиве,используя 1 указатель (4 байта или 8 байт,в зависимости от размера указателя)на марку.Несмотря на то,что массив разрежен,на фронтах все же настоятельно рекомендуется использовать метки от 1 до n,где n-это общее количество меток,требуемое для данного импорта.</target>
        </trans-unit>
        <trans-unit id="c020b534de76a3110681e8b3a1131c198a04e4dd" translate="yes" xml:space="preserve">
          <source>Marks must be declared (via &lt;code&gt;mark&lt;/code&gt;) before they can be used.</source>
          <target state="translated">Знаки должны быть заявлены (через &lt;code&gt;mark&lt;/code&gt; ), прежде чем они могут быть использованы.</target>
        </trans-unit>
        <trans-unit id="e23875af098ed58ac7ddbf626ebbfd55b3530c2d" translate="yes" xml:space="preserve">
          <source>Marks the end of the stream. This command is optional unless the &lt;code&gt;done&lt;/code&gt; feature was requested using the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command.</source>
          <target state="translated">Обозначает конец потока. Эта команда является необязательной, если только функция &lt;code&gt;done&lt;/code&gt; не была запрошена с помощью &lt;code&gt;--done&lt;/code&gt; командной строки --done или команды &lt;code&gt;feature done&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd5e3d7525f7c72ed149669f4682e8cf2613e2e" translate="yes" xml:space="preserve">
          <source>Match paths exactly (i.e. don&amp;rsquo;t allow &quot;/foo/repo&quot; when the real path is &quot;/foo/repo.git&quot; or &quot;/foo/repo/.git&quot;) and don&amp;rsquo;t do user-relative paths. &lt;code&gt;git daemon&lt;/code&gt; will refuse to start when this option is enabled and no whitelist is specified.</source>
          <target state="translated">Точное соответствие путей (т.е. не разрешать &quot;/ foo / repo&quot;, когда реальный путь - &quot;/foo/repo.git&quot; или &quot;/foo/repo/.git&quot;) и не использовать пути, относящиеся к пользователю. &lt;code&gt;git daemon&lt;/code&gt; откажется запускаться, если этот параметр включен и белый список не указан.</target>
        </trans-unit>
        <trans-unit id="1c5cb990d5ea569aee72e359a127ac5dd4a253ea" translate="yes" xml:space="preserve">
          <source>Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character).</source>
          <target state="translated">Подходит образец только на границе слова (либо начинается в начале строки,либо перед ним стоит несловной символ;заканчивается в конце строки или за ним следует несловной символ).</target>
        </trans-unit>
        <trans-unit id="ca182a2e7bbbd5ec9c62eec976529a0aa078540e" translate="yes" xml:space="preserve">
          <source>Match the regular expression limiting patterns without regard to letter case.</source>
          <target state="translated">Выберите регулярное выражение,ограничивающее шаблон,безотносительно регистра букв.</target>
        </trans-unit>
        <trans-unit id="1452c4b1c4eed7c80174fb8c82a8ed6f95d98c4d" translate="yes" xml:space="preserve">
          <source>Maximum delta depth, for blob and tree deltification. Default is 50.</source>
          <target state="translated">Максимальная глубина дельты,для отслоения капель и деревьев.По умолчанию 50.</target>
        </trans-unit>
        <trans-unit id="384f40abc20254795ab29a564353f53402412c1e" translate="yes" xml:space="preserve">
          <source>Maximum number of branches to maintain active at once. See &amp;ldquo;Memory Utilization&amp;rdquo; below for details. Default is 5.</source>
          <target state="translated">Максимальное количество ветвей, которые нужно поддерживать активными одновременно. Подробнее см. &amp;laquo;Использование памяти&amp;raquo; ниже. По умолчанию 5.</target>
        </trans-unit>
        <trans-unit id="0a8681cfb7605cda2b80805ca7e930924afc3f52" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes per thread to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba691ad2489c6a98bfddfb725c399a5433235ec" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to map simultaneously into memory from pack files. If Git needs to access more than this many bytes at once to complete an operation it will unmap existing regions to reclaim virtual address space within the process.</source>
          <target state="translated">Максимальное количество байт для одновременного отображения в память из пакетных файлов.Если для выполнения операции Git'у потребуется доступ к более чем этому количеству байт одновременно,то он распаковывает существующие регионы для восстановления виртуального адресного пространства в процессе работы.</target>
        </trans-unit>
        <trans-unit id="015780ae5eaf5a16460a6c6f6a47f9fd68665f6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="translated">Максимальное количество байтов,которое может быть зарезервировано для кэширования базовых объектов,на которые могут ссылаться несколько расслоенных объектов.Храня все распакованные базовые объекты в кэше,Git может избежать распаковки и распаковки часто используемых базовых объектов несколько раз.</target>
        </trans-unit>
        <trans-unit id="9639a9871e3fa301072f34b62bd6d8d1df5dfde8" translate="yes" xml:space="preserve">
          <source>Maximum number of concurrent clients, defaults to 32. Set it to zero for no limit.</source>
          <target state="translated">Максимальное количество одновременных клиентов,по умолчанию 32.Установите ноль без ограничения.</target>
        </trans-unit>
        <trans-unit id="3fca64028c3b9d66663fb33bbabf381bdeaeb020" translate="yes" xml:space="preserve">
          <source>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB, which is sufficient for most requests.</source>
          <target state="translated">Максимальный размер в байтах буфера,используемого умными HTTP-транспортами при POSTing данных в удаленную систему.Для запросов размером больше этого буфера,HTTP/1.1 и Transfer-Encoding:используется chunked,чтобы избежать локального создания массивного пакетного файла.По умолчанию 1 Мб,что достаточно для большинства запросов.</target>
        </trans-unit>
        <trans-unit id="d63005f2c2b8f8c3239933e10d80e78d75fee39e" translate="yes" xml:space="preserve">
          <source>Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes. The default is 512m (512 MiB). Some importers may wish to lower this on systems with constrained memory.</source>
          <target state="translated">Максимальный размер блока,который быстро импортируется,будет пытаться создать дельту для,выраженную в байтах.По умолчанию 512 м (512 Мб).Некоторые импортеры могут захотеть снизить его на системах с ограниченной памятью.</target>
        </trans-unit>
        <trans-unit id="d3dd84835c1a4e2de21619e12a6eaaff0c2d1fd8" translate="yes" xml:space="preserve">
          <source>Maximum size of each output pack file. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">Максимальный размер каждого файла выходного пакета. Размер может быть дополнен суффиксами &amp;laquo;k&amp;raquo;, &amp;laquo;m&amp;raquo; или &amp;laquo;g&amp;raquo;. Минимальный допустимый размер ограничен 1 МиБ. Если указано, может быть создано несколько файлов пакетов, что также предотвращает создание индекса битовой карты. По умолчанию не ограничено, если не установлена ​​переменная конфигурации &lt;code&gt;pack.packSizeLimit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8685db9c67d15fcb99750ad6a0c6f6dc3e27c92" translate="yes" xml:space="preserve">
          <source>Maximum size of each output packfile. The default is unlimited.</source>
          <target state="translated">Максимальный размер каждого выходного файла пакета.По умолчанию неограничен.</target>
        </trans-unit>
        <trans-unit id="ecff084a0c01e319db62c5b088c7a98c5cc26a2a" translate="yes" xml:space="preserve">
          <source>May be an unabbreviated ref name or a glob and may be specified multiple times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">Может быть сокращенным именем ссылки или глобусом и может быть указано несколько раз.Предупреждение будет выдано для тех ссылок,которые не существуют,но глобус,не совпадающий ни с одним из ссылок,будет молча игнорироваться.</target>
        </trans-unit>
        <trans-unit id="706c83c32d28c2f1cb1aaafc37be7356f71e7631" translate="yes" xml:space="preserve">
          <source>May be set to a boolean value, or the string &lt;code&gt;if-asked&lt;/code&gt;. A true value causes all pushes to be GPG signed, as if &lt;code&gt;--signed&lt;/code&gt; is passed to &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. The string &lt;code&gt;if-asked&lt;/code&gt; causes pushes to be signed if the server supports it, as if &lt;code&gt;--signed=if-asked&lt;/code&gt; is passed to &lt;code&gt;git push&lt;/code&gt;. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option.</source>
          <target state="translated">Может быть задано логическое значение или строка, &lt;code&gt;if-asked&lt;/code&gt; потребуется . Истинное значение приводит к тому, что все &lt;code&gt;--signed&lt;/code&gt; подписываются GPG, как если бы --signed передается в &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; . Строка &lt;code&gt;if-asked&lt;/code&gt; вызывает подписание &lt;code&gt;--signed=if-asked&lt;/code&gt; сервер поддерживает это, как если бы --signed = if-ask передано в &lt;code&gt;git push&lt;/code&gt; . Ложное значение может переопределить значение из конфигурационного файла с более низким приоритетом. Явный флаг командной строки всегда отменяет этот параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="8555af2d5095b661ce8d37e9e0375fb4c8ea77d6" translate="yes" xml:space="preserve">
          <source>May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If &lt;code&gt;check&lt;/code&gt; is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If &lt;code&gt;on-demand&lt;/code&gt; is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If &lt;code&gt;only&lt;/code&gt; is used all submodules will be recursively pushed while the superproject is left unpushed. A value of &lt;code&gt;no&lt;/code&gt; or using &lt;code&gt;--no-recurse-submodules&lt;/code&gt; can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.</source>
          <target state="translated">Может использоваться, чтобы убедиться, что все коммиты подмодулей, используемые отправляемыми ревизиями, доступны в ветке удаленного отслеживания. Если используется &lt;code&gt;check&lt;/code&gt; Git проверит, что все коммиты подмодуля, которые были изменены в отправляемых ревизиях, доступны по крайней мере на одном удаленном из подмодуля. Если какие-либо коммиты отсутствуют, push будет прерван и завершится с ненулевым статусом. Если используется &lt;code&gt;on-demand&lt;/code&gt; все подмодули, которые были изменены в отправляемых ревизиях, будут отправлены. Если по запросу не удалось отправить все необходимые изменения, он также будет прерван и выйдет с ненулевым статусом. Если используется &lt;code&gt;only&lt;/code&gt; все подмодули будут рекурсивно проталкиваться, в то время как суперпроект не будет выталкиваться. Значение &lt;code&gt;no&lt;/code&gt; или using &lt;code&gt;--no-recurse-submodules&lt;/code&gt; может использоваться для переопределения переменной конфигурации push.recurseSubmodules, когда рекурсия подмодуля не требуется.</target>
        </trans-unit>
        <trans-unit id="8be2a61b9ad007dcdaebc339c9660a293e37ceee" translate="yes" xml:space="preserve">
          <source>Mbox file to split. If not given, the mbox is read from the standard input.</source>
          <target state="translated">Файл из коробки разделить.Если он не задан,то mbox считывается со стандартного входа.</target>
        </trans-unit>
        <trans-unit id="1ce7743133ea15a3c11834ae295610d6b0aca98e" translate="yes" xml:space="preserve">
          <source>Memory utilization</source>
          <target state="translated">Использование памяти</target>
        </trans-unit>
        <trans-unit id="94804378bc64156caa1411beabf938d0cc1f334a" translate="yes" xml:space="preserve">
          <source>Merge a topic branch into the current branch, which resulted in a fast-forward.</source>
          <target state="translated">Объединить тематическую ветку в текущую,что привело к быстрой перемотке вперёд.</target>
        </trans-unit>
        <trans-unit id="aa4cb5d8e33b071846e0985dfd9e8a73b7ff3b77" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;maint&lt;/code&gt; into the current branch, but do not make a new commit automatically:</source>
          <target state="translated">Объединить &lt;code&gt;maint&lt;/code&gt; ветки с текущей веткой, но не делать новую фиксацию автоматически:</target>
        </trans-unit>
        <trans-unit id="36c2108053218bb1c9bd1daf5d80ef9e2b56153b" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;obsolete&lt;/code&gt; into the current branch, using &lt;code&gt;ours&lt;/code&gt; merge strategy:</source>
          <target state="translated">Слить &lt;code&gt;obsolete&lt;/code&gt; ветку с текущей веткой, используя &lt;code&gt;ours&lt;/code&gt; стратегию слияния:</target>
        </trans-unit>
        <trans-unit id="2340cae4ab971b09adab3732a6eccbc0f94439af" translate="yes" xml:space="preserve">
          <source>Merge branches &lt;code&gt;fixes&lt;/code&gt; and &lt;code&gt;enhancements&lt;/code&gt; on top of the current branch, making an octopus merge:</source>
          <target state="translated">&lt;code&gt;fixes&lt;/code&gt; и &lt;code&gt;enhancements&lt;/code&gt; слияния ветвей поверх текущей ветки, в результате чего слияние осьминога:</target>
        </trans-unit>
        <trans-unit id="3b3fe151c69070e113efe45497e8fbe34f98eda0" translate="yes" xml:space="preserve">
          <source>Merge into the current branch the remote branch &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">Слить с текущей веткой удаленную ветку &lt;code&gt;next&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c5d9976d41384cd800a73252d5887846f7995334" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS</source>
          <target state="translated">Объединить один патч в CVS</target>
        </trans-unit>
        <trans-unit id="ebf628d17763f2d1db5244a9d541825468f6e3f2" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo</source>
          <target state="translated">Объедините один патч в CVS (опции -c и -w).Рабочий каталог находится внутри Git Repo</target>
        </trans-unit>
        <trans-unit id="374bc1e6ce1c863c36094e824049bd53454731f0" translate="yes" xml:space="preserve">
          <source>Merge pending patches into CVS automatically &amp;mdash; only if you really know what you are doing</source>
          <target state="translated">Автоматически объединять ожидающие исправления в CVS - только если вы действительно знаете, что делаете</target>
        </trans-unit>
        <trans-unit id="1ecf516cb34751fcee31d345dc521d62850b1084" translate="yes" xml:space="preserve">
          <source>Merge strategies</source>
          <target state="translated">Слияние стратегий</target>
        </trans-unit>
        <trans-unit id="6455bb1c3dd50961d850d4ec4f8b22adf354885c" translate="yes" xml:space="preserve">
          <source>Merge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called &quot;remote&quot;) since the merge-base (if any) into the current notes ref (called &quot;local&quot;).</source>
          <target state="translated">Соедините данные сноски с текущими сносками.При этом будет сделана попытка объединить изменения,внесенные указанным номером ссылки (называемым &quot;удаленным&quot;)с момента объединения базы (если таковая имеется)в текущий номер ссылки (называемый &quot;локальный&quot;).</target>
        </trans-unit>
        <trans-unit id="06a4a977ae422fbb370e91879e13703bae28bf9d" translate="yes" xml:space="preserve">
          <source>Merge tracking</source>
          <target state="translated">Отслеживание слияния</target>
        </trans-unit>
        <trans-unit id="af8c9dbb2cf6a08b436fada56eb16ee91017d8ce" translate="yes" xml:space="preserve">
          <source>Merge workflow</source>
          <target state="translated">Объединить рабочий процесс</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="c4dada76f0f6e7dcbd827c4ba6bada46b3c6714c" translate="yes" xml:space="preserve">
          <source>Merges (to be discussed later), as well as operations such as &lt;code&gt;git reset&lt;/code&gt;, which change the currently checked-out commit, generally set ORIG_HEAD to the value HEAD had before the current operation.</source>
          <target state="translated">Слияния (будут обсуждены позже), а также такие операции, как &lt;code&gt;git reset&lt;/code&gt; , которые изменяют текущий извлеченный коммит, обычно устанавливают ORIG_HEAD в значение, которое HEAD имело перед текущей операцией.</target>
        </trans-unit>
        <trans-unit id="376269fe69e269c1639bc7c223893145d88653cf" translate="yes" xml:space="preserve">
          <source>Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in</source>
          <target state="translated">Слияния всегда включены.Однако их родительский список переписывается:Вдоль каждого родителя убираются коммиты,которые не включены сами по себе.Это приводит к тому,что</target>
        </trans-unit>
        <trans-unit id="6da92828bff93237c525d505f61963005fa8aa9b" translate="yes" xml:space="preserve">
          <source>Merges can be also made simpler by using smaller branches or by using many topic branches instead of only long version related branches.</source>
          <target state="translated">Слияния также можно упростить,используя более мелкие ветки или используя множество тематических ветвей вместо длинных ветвей,связанных с версиями.</target>
        </trans-unit>
        <trans-unit id="18462046f484e3565df5821cdce8eadab95f1224" translate="yes" xml:space="preserve">
          <source>Merges have many advantages, so we try to solve as many problems as possible with merges alone. Cherry-picking is still occasionally useful; see &quot;Merging upwards&quot; below for an example.</source>
          <target state="translated">Слияния имеют много преимуществ,поэтому мы стараемся решить как можно больше проблем только слияниями.Время от времени полезно выбирать вишню;см.ниже пример &quot;Слияние вверх&quot;.</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="31c92682cbfd6598c97a2306d8a83a0e953592eb" translate="yes" xml:space="preserve">
          <source>Merging and rebasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2204607f23628214b6d42add29d21c7f2e29b95" translate="yes" xml:space="preserve">
          <source>Merging branches with differing checkin/checkout attributes</source>
          <target state="translated">Слияние ветвей с различными атрибутами проверки/отправки</target>
        </trans-unit>
        <trans-unit id="c535f2db054f922c7b696495f8b89a913e2a11c4" translate="yes" xml:space="preserve">
          <source>Merging external work</source>
          <target state="translated">Слияние внешней работы</target>
        </trans-unit>
        <trans-unit id="603157d894d36cb77fbe21d75b0d20a12dc01779" translate="yes" xml:space="preserve">
          <source>Merging inside a &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; will work as long as a merge base is in the recent history. Otherwise, it will be like merging unrelated histories and may have to result in huge conflicts. This limitation may make such a repository unsuitable to be used in merge based workflows.</source>
          <target state="translated">Слияние внутри &lt;a href=&quot;#def_shallow_clone&quot;&gt;мелкого клона&lt;/a&gt; будет работать, пока база слияния находится в недавней истории. В противном случае это будет похоже на слияние несвязанных историй и может привести к огромным конфликтам. Это ограничение может сделать такой репозиторий непригодным для использования в рабочих процессах на основе слияния.</target>
        </trans-unit>
        <trans-unit id="ab26fbd41a8ed9c39ebd7d129433578a03343e81" translate="yes" xml:space="preserve">
          <source>Merging multiple trees</source>
          <target state="translated">Слияние нескольких деревьев</target>
        </trans-unit>
        <trans-unit id="f73ac93115d3cdadc50aebe7fa9b08f89899740b" translate="yes" xml:space="preserve">
          <source>Merging multiple trees, continued</source>
          <target state="translated">Слияние нескольких деревьев,продолжение</target>
        </trans-unit>
        <trans-unit id="98b404243306169adb88696dc4ad2165a137c1ac" translate="yes" xml:space="preserve">
          <source>Merging tag</source>
          <target state="translated">Соединительная бирка</target>
        </trans-unit>
        <trans-unit id="1af53d3a2af732fec14191525698059a5e40b8d4" translate="yes" xml:space="preserve">
          <source>Merging two branches</source>
          <target state="translated">Слияние двух филиалов</target>
        </trans-unit>
        <trans-unit id="6153c9c2afc2b444427af54ff710f1f84e9dda45" translate="yes" xml:space="preserve">
          <source>Merging upwards</source>
          <target state="translated">Слияние вверх</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="ede02150d3611f561b342e50cd978f7d1c7b1d2a" translate="yes" xml:space="preserve">
          <source>Miscellaneous capabilities</source>
          <target state="translated">Различный потенциал</target>
        </trans-unit>
        <trans-unit id="5b0739f48e82ea34788c95cbd8a03adab72795db" translate="yes" xml:space="preserve">
          <source>Miscellaneous differences</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e2e957e53389b060cb16e85d086c46b6c88151" translate="yes" xml:space="preserve">
          <source>Missing From or In-Reply-To headers will be prompted for.</source>
          <target state="translated">Будут запрошены заголовки &quot;Пропущено из&quot; или &quot;В ответ&quot;.</target>
        </trans-unit>
        <trans-unit id="00b61542d0211972bc61982931e3e8c50577c383" translate="yes" xml:space="preserve">
          <source>Modified content is represented by &quot;-&quot; lines (removing the old content) followed by &quot;+&quot; lines (adding the replacement content). You can prevent staging the modification by converting &quot;-&quot; lines to &quot; &quot;, and removing &quot;+&quot; lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index.</source>
          <target state="translated">Модифицированное содержимое представлено строками &quot;-&quot; (удаление старого содержимого),за которыми следуют строки &quot;+&quot; (добавление заменяющего содержимого).Вы можете предотвратить инсценировку изменения,конвертировав строки &quot;-&quot; в &quot; &quot;,а также удалив строки с символом &quot;+&quot;.Остерегайтесь,что модификация только половины пары,скорее всего,приведет к путанице в индексе.</target>
        </trans-unit>
        <trans-unit id="6e5a153f7d9724480c99f8d43544411a606a03ba" translate="yes" xml:space="preserve">
          <source>Modifies the index or directory cache. Each file mentioned is updated into the index and any &lt;code&gt;unmerged&lt;/code&gt; or &lt;code&gt;needs updating&lt;/code&gt; state is cleared.</source>
          <target state="translated">Изменяет кеш индекса или каталога. Каждый упомянутый файл обновляется в индексе, и все не &lt;code&gt;unmerged&lt;/code&gt; или &lt;code&gt;needs updating&lt;/code&gt; состояния очищаются.</target>
        </trans-unit>
        <trans-unit id="f87d4010c94238df04ebfd441b3a0111f33d7a25" translate="yes" xml:space="preserve">
          <source>Modify behavior of the next command naming a &amp;lt;ref&amp;gt;. The only valid option is &lt;code&gt;no-deref&lt;/code&gt; to avoid dereferencing a symbolic ref.</source>
          <target state="translated">Измените поведение следующей команды, назвав &amp;lt;ref&amp;gt;. Единственная допустимая опция - &lt;code&gt;no-deref&lt;/code&gt; , чтобы избежать разыменования символической ссылки.</target>
        </trans-unit>
        <trans-unit id="eeb79095663bd56bf370bd2096cd4a5ecc99b3a1" translate="yes" xml:space="preserve">
          <source>Modify some files, then add their updated contents to the index:</source>
          <target state="translated">Измените некоторые файлы,затем добавьте их обновленное содержимое в индекс:</target>
        </trans-unit>
        <trans-unit id="19db1a3cc38a1c275e20ba3eb14f5761050f2bac" translate="yes" xml:space="preserve">
          <source>Modifying the index is easy:</source>
          <target state="translated">Изменить индекс легко:</target>
        </trans-unit>
        <trans-unit id="3d6095a82dcd262f6e6b119640e8d9b20bcf7da2" translate="yes" xml:space="preserve">
          <source>More detail on the following is available from the &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt;.</source>
          <target state="translated">Более подробная информация о следующем доступна в &lt;a href=&quot;user-manual#git-concepts&quot;&gt;главе о концепциях Git руководства пользователя&lt;/a&gt; и в руководстве по &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06099ebf3c1fb2d228710b5b862871e1eab3c063" translate="yes" xml:space="preserve">
          <source>More generally, a branch that is created from a remote-tracking branch will pull by default from that branch. See the descriptions of the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;, and the discussion of the &lt;code&gt;--track&lt;/code&gt; option in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, to learn how to control these defaults.</source>
          <target state="translated">В более общем смысле ветка, созданная из ветки удаленного отслеживания, по умолчанию будет извлекать из этой ветки. Смотрите описание в &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; и &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; опции в &lt;a href=&quot;git-config&quot;&gt;GIT-конфигурации [1]&lt;/a&gt; , а также при обсуждении &lt;code&gt;--track&lt;/code&gt; опции в &lt;a href=&quot;git-checkout&quot;&gt;GIT-кассе [1]&lt;/a&gt; , чтобы узнать , как контролировать эти значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="415ceff2cb011b2c5375c0d469dab2cba200eaed" translate="yes" xml:space="preserve">
          <source>More generally, among the two commits to compute the merge base from, one is specified by the first commit argument on the command line; the other commit is a (possibly hypothetical) commit that is a merge across all the remaining commits on the command line.</source>
          <target state="translated">В более общем плане,среди двух коммитов для вычисления базы слияния,один указан первым аргументом коммита в командной строке;другой-(возможно,гипотетический)коммит,который представляет собой слияние всех оставшихся коммитов в командной строке.</target>
        </trans-unit>
        <trans-unit id="816cda5b46035bd1542e1775969151ec4a09cada" translate="yes" xml:space="preserve">
          <source>More importantly, it allows the update of a ref file to follow these symbolic pointers, whether they are symlinks or these &quot;regular file symbolic refs&quot;. It follows &lt;strong&gt;real&lt;/strong&gt; symlinks only if they start with &quot;refs/&quot;: otherwise it will just try to read them and update them as a regular file (i.e. it will allow the filesystem to follow them, but will overwrite such a symlink to somewhere else with a regular filename).</source>
          <target state="translated">Что еще более важно, он позволяет обновлению файла ссылок следовать этим символическим указателям, независимо от того, являются ли они символическими ссылками или этими &amp;laquo;символическими ссылками на обычные файлы&amp;raquo;. Он следует за &lt;strong&gt;настоящими&lt;/strong&gt; символическими ссылками, только если они начинаются с &quot;refs /&quot;: в противном случае он просто попытается прочитать их и обновить как обычный файл (т.е. он позволит файловой системе следовать за ними, но перезапишет такую ​​символическую ссылку на другое место с помощью обычное имя файла).</target>
        </trans-unit>
        <trans-unit id="2be26ffe68463b96abc5601cef9bdbafbf2f631d" translate="yes" xml:space="preserve">
          <source>More interestingly, you can also give &lt;code&gt;git diff-tree&lt;/code&gt; the &lt;code&gt;--pretty&lt;/code&gt; flag, which tells it to also show the commit message and author and date of the commit, and you can tell it to show a whole series of diffs. Alternatively, you can tell it to be &quot;silent&quot;, and not show the diffs at all, but just show the actual commit message.</source>
          <target state="translated">Более интересно, вы также можете дать &lt;code&gt;git diff-tree&lt;/code&gt; &lt;code&gt;--pretty&lt;/code&gt; флаг, который говорит , что это также показывает сообщение фиксации и автора и дату фиксации, и вы можете сказать ему , чтобы показать целый ряд файлов изменений. В качестве альтернативы вы можете указать ему, чтобы он был &quot;тихим&quot; и вообще не показывал различия, а просто отображал фактическое сообщение фиксации.</target>
        </trans-unit>
        <trans-unit id="854ef0fd2eba012b7c2e6ecb33388db153e60f9a" translate="yes" xml:space="preserve">
          <source>More on recovery from repository corruption. See: &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&lt;/a&gt;&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&lt;/a&gt;</source>
          <target state="translated">Подробнее о восстановлении после повреждения репозитория. См .: &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/ &lt;/a&gt;&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@ woody.linux-foundation.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1784c94f3b7a373b03c0ae45229574de43eee20" translate="yes" xml:space="preserve">
          <source>More precisely, &lt;code&gt;git pull&lt;/code&gt; runs &lt;code&gt;git fetch&lt;/code&gt; with the given parameters and calls &lt;code&gt;git merge&lt;/code&gt; to merge the retrieved branch heads into the current branch. With &lt;code&gt;--rebase&lt;/code&gt;, it runs &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">Точнее, &lt;code&gt;git pull&lt;/code&gt; запускает &lt;code&gt;git fetch&lt;/code&gt; с заданными параметрами и вызывает &lt;code&gt;git merge&lt;/code&gt; , чтобы объединить полученные заголовки веток в текущую ветку. С &lt;code&gt;--rebase&lt;/code&gt; запускается &lt;code&gt;git rebase&lt;/code&gt; вместо &lt;code&gt;git merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17f51f170751975b2cc4764665c6e712fb67447f" translate="yes" xml:space="preserve">
          <source>Most CVS command arguments that read CVS tags or revision numbers (typically -r) work, and also support any git refspec (tag, branch, commit ID, etc). However, CVS revision numbers for non-default branches are not well emulated, and cvs log does not show tags or branches at all. (Non-main-branch CVS revision numbers superficially resemble CVS revision numbers, but they actually encode a git commit ID directly, rather than represent the number of revisions since the branch point.)</source>
          <target state="translated">Большинство аргументов команд CVS,которые читают CVS тэги или номера ревизий (обычно -r),работают,а также поддерживают любой git refspec (тэг,ветка,идентификатор коммита и т.д.).Однако,номера ревизий CVS для ветвей не по умолчанию эмулируются плохо,и журнал cvs не показывает теги или ветки вообще.(Неосновные номера ревизий CVS поверхностно напоминают номера ревизий CVS,но на самом деле они непосредственно кодируют идентификатор фиксации git'а,а не представляют количество ревизий с точки ответвления).</target>
        </trans-unit>
        <trans-unit id="880f481ef12ec663b5ff4186eb50766022add75f" translate="yes" xml:space="preserve">
          <source>Most bottlenecks appear to be in foreign source data access (the source just cannot extract revisions fast enough) or disk IO (fast-import writes as fast as the disk will take the data). Imports will run faster if the source data is stored on a different drive than the destination Git repository (due to less IO contention).</source>
          <target state="translated">Большинство узких мест,по-видимому,связано с доступом к данным иностранного источника (источник просто не может извлечь ревизии достаточно быстро)или с дисковым вводом данных (быстрый импорт записывается так же быстро,как диск заберет данные).Импорт выполняется быстрее,если исходные данные хранятся на диске,отличном от целевого Git-репозитория (из-за меньшего количества запросов ввода-вывода).</target>
        </trans-unit>
        <trans-unit id="b1a743b45e6efbd5b49b8c3c8d73ad9b477276e1" translate="yes" xml:space="preserve">
          <source>Most commits have only one parent, but it is also common for a commit to have multiple parents. In that case the commit represents a merge, with the parent references pointing to the heads of the merged branches.</source>
          <target state="translated">Большинство коммитов имеют только одного родителя,но для коммитов с несколькими родителями это также обычное явление.В этом случае коммит представляет собой слияние,при котором родительские ссылки указывают на головы объединённых ветвей.</target>
        </trans-unit>
        <trans-unit id="6e0466db6c595523512aab889a71c0ecc693c19a" translate="yes" xml:space="preserve">
          <source>Most hosting providers use a single SSH account for pushing; that is, all users push to the &lt;code&gt;git&lt;/code&gt; account (e.g., &lt;code&gt;git@git.example.org&lt;/code&gt;). If that&amp;rsquo;s the case for your provider, you can set up multiple aliases in SSH to make it clear which key pair to use. For example, you could write something like the following in &lt;code&gt;~/.ssh/config&lt;/code&gt;, substituting the proper private key file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d50eced4caaa6d0cca3ee6a1e2e2e07d0d5849b" translate="yes" xml:space="preserve">
          <source>Most importantly, merging works at the branch level, while cherry-picking works at the commit level. This means that a merge can carry over the changes from 1, 10, or 1000 commits with equal ease, which in turn means the workflow scales much better to a large number of contributors (and contributions). Merges are also easier to understand because a merge commit is a &quot;promise&quot; that all changes from all its parents are now included.</source>
          <target state="translated">Самое главное,слияние работает на уровне ветки,в то время как сбор вишни работает на уровне коммита.Это означает,что слияние может с такой же лёгкостью перенести изменения из 1,10 или 1000 коммитов,что,в свою очередь,означает,что рабочий процесс масштабируется гораздо лучше для большого количества вкладчиков (и вкладов).Слияния также проще понять,потому что коммит слияния-это &quot;обещание&quot;,что все изменения от всех его родителей теперь включены.</target>
        </trans-unit>
        <trans-unit id="2e130c2e2dd2a16594642aa625e1fc3c4df26608" translate="yes" xml:space="preserve">
          <source>Most of features are configured via &lt;code&gt;%feature&lt;/code&gt; hash; however some of extra gitweb features can be turned on and configured using variables described below. This list beside configuration variables that control how gitweb looks does contain variables configuring administrative side of gitweb (e.g. cross-site scripting prevention; admittedly this as side effect affects how &quot;summary&quot; pages look like, or load limiting).</source>
          <target state="translated">Большинство функций настраивается через &lt;code&gt;%feature&lt;/code&gt; hash; однако некоторые из дополнительных функций gitweb можно включить и настроить с помощью переменных, описанных ниже. Этот список, помимо переменных конфигурации, которые контролируют внешний вид gitweb, действительно содержит переменные, настраивающие административную часть gitweb (например, предотвращение межсайтового скриптинга; по общему признанию, это как побочный эффект влияет на то, как выглядят &amp;laquo;сводные&amp;raquo; страницы, или ограничение нагрузки).</target>
        </trans-unit>
        <trans-unit id="12c479c9b5f1b05779ca1427f8469c4d0c8e41b4" translate="yes" xml:space="preserve">
          <source>Most of what &lt;code&gt;git rev-list&lt;/code&gt; did is contained in &lt;code&gt;revision.c&lt;/code&gt; and &lt;code&gt;revision.h&lt;/code&gt;. It wraps the options in a struct named &lt;code&gt;rev_info&lt;/code&gt;, which controls how and what revisions are walked, and more.</source>
          <target state="translated">Большая часть того, что сделал &lt;code&gt;git rev-list&lt;/code&gt; , содержится в &lt;code&gt;revision.c&lt;/code&gt; и &lt;code&gt;revision.h&lt;/code&gt; . Он оборачивает параметры в структуру с именем &lt;code&gt;rev_info&lt;/code&gt; , которая контролирует, как и какие ревизии проходят, и многое другое.</target>
        </trans-unit>
        <trans-unit id="9ceb817bd0e340cfd6e3a665612ec974c7873cd6" translate="yes" xml:space="preserve">
          <source>Most operations that add an object to the database update the modification time of the object if it is already present so that #1 applies.</source>
          <target state="translated">Большинство операций,которые добавляют объект в базу данных,обновляют время модификации объекта,если он уже присутствует,так что #1 применяется.</target>
        </trans-unit>
        <trans-unit id="ed4a3f36c4746567049b5d83d49f91438e7cd1fa" translate="yes" xml:space="preserve">
          <source>Most projects also use &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt;. Tags, like heads, are references into the project&amp;rsquo;s history, and can be listed using the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; command:</source>
          <target state="translated">В большинстве проектов также используются &lt;a href=&quot;#def_tag&quot;&gt;теги&lt;/a&gt; . Теги, как и заголовки, являются ссылками на историю проекта и могут быть перечислены с помощью команды &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="6e9a1bc6364ad2c889e7f09c69628c8251c67662" translate="yes" xml:space="preserve">
          <source>Most projects with multiple contributors (such as the Linux kernel, or Git itself) have frequent merges, and &lt;code&gt;gitk&lt;/code&gt; does a better job of visualizing their history. For example,</source>
          <target state="translated">Большинство проектов с несколькими участниками (такими как ядро ​​Linux или сам Git) часто сливаются, и &lt;code&gt;gitk&lt;/code&gt; лучше справляется с визуализацией их истории. Например,</target>
        </trans-unit>
        <trans-unit id="b110af03cd46bd74e1684a2cb53fb12fe52de561" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; command.</source>
          <target state="translated">В основном синоним &lt;a href=&quot;#def_shallow_repository&quot;&gt;хранилища неглубокого&lt;/a&gt; , но фраза делает его более явным , что он был создан, запустив &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; команду.</target>
        </trans-unit>
        <trans-unit id="0a0252ca3dca0dd6561eccb6a1ba0495bf433801" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=...&lt;/code&gt; command.</source>
          <target state="translated">В основном синоним &lt;a href=&quot;#def_shallow_repository&quot;&gt;хранилища неглубокого&lt;/a&gt; , но фраза делает его более явным , что он был создан, запустив &lt;code&gt;git clone --depth=...&lt;/code&gt; команду.</target>
        </trans-unit>
        <trans-unit id="3a5117e8beb61f9ec394ef9854333d01751bcf99" translate="yes" xml:space="preserve">
          <source>Mounting one repository inside another</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfd3ade6b1a6694324bf4f4adc30f26dd2cc430" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved with this command. (The &lt;code&gt;git worktree repair&lt;/code&gt; command, however, can reestablish the connection with linked working trees if you move the main working tree manually.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437db9b7f03fcf9c59c19e8599b81a4181786550" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved.</source>
          <target state="translated">Переместите рабочее дерево на новое место.Обратите внимание,что основное рабочее дерево или связанные рабочие деревья,содержащие субмодули,не могут быть перемещены.</target>
        </trans-unit>
        <trans-unit id="00451deb449902283a1a1b09ee616f563047050b" translate="yes" xml:space="preserve">
          <source>Move objects and refs by archive</source>
          <target state="translated">Перемещение объектов и ссылок по архиву</target>
        </trans-unit>
        <trans-unit id="0a2aa584391bc2ed097c1ace071233493faa0978" translate="yes" xml:space="preserve">
          <source>Move or rename a file, a directory, or a symlink</source>
          <target state="translated">Переместить или переименовать файл,каталог или сим-ссылку</target>
        </trans-unit>
        <trans-unit id="4bc0abe3ae87a3007e76abb67d150957939b61b8" translate="yes" xml:space="preserve">
          <source>Move or rename a file, directory or symlink.</source>
          <target state="translated">Переместить или переименовать файл,каталог или сим-ссылку.</target>
        </trans-unit>
        <trans-unit id="24cb8f062e449dc4167b50460e2e7341fe4e0aa6" translate="yes" xml:space="preserve">
          <source>Move/rename a branch and the corresponding reflog.</source>
          <target state="translated">Переместить/переименовать ветку и соответствующий рефлог.</target>
        </trans-unit>
        <trans-unit id="86a2fcc8fa8d4ad8c3c46b9d3e5182feb14f1b60" translate="yes" xml:space="preserve">
          <source>Moved lines are not highlighted.</source>
          <target state="translated">Перемещенные строки не выделяются.</target>
        </trans-unit>
        <trans-unit id="e5cbd47a10df638d21a9258d79ed6bd371f01027" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. It can be changed by the &lt;code&gt;diff.colorMoved&lt;/code&gt; configuration setting. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">Перемещенные строки кода окрашены по-разному. Его можно изменить с помощью &lt;code&gt;diff.colorMoved&lt;/code&gt; конфигурации diff.colorMoved . Для &amp;lt;режим&amp;gt; по умолчанию установлено значение &amp;laquo; &lt;code&gt;no&lt;/code&gt; если параметр не задан, и &amp;laquo; &lt;code&gt;zebra&lt;/code&gt; если задан параметр без режима. Режим должен быть одним из:</target>
        </trans-unit>
        <trans-unit id="b99084289befcccb3b6f25bb5a902159aaa2283b" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">Перемещенные строки кода окрашены по-разному. Для &amp;lt;режим&amp;gt; по умолчанию установлено значение &amp;laquo; &lt;code&gt;no&lt;/code&gt; если параметр не задан, и &amp;laquo; &lt;code&gt;zebra&lt;/code&gt; если задан параметр без режима. Режим должен быть одним из:</target>
        </trans-unit>
        <trans-unit id="b9c1e9c13eb039f68657e5a15bbd12085ba143c2" translate="yes" xml:space="preserve">
          <source>Moving a submodule using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will update the gitfile and core.worktree setting to make the submodule work in the new location. It also will attempt to update the submodule.&amp;lt;name&amp;gt;.path setting in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and stage that file (unless -n is used).</source>
          <target state="translated">Перемещение подмодуля с использованием gitfile (что означает, что они были клонированы с Git версии 1.7.8 или новее) обновит настройки gitfile и core.worktree, чтобы подмодуль работал в новом месте. Он также попытается обновить параметр submodule. &amp;lt;name&amp;gt; .path в &lt;a href=&quot;gitmodules&quot;&gt;файле gitmodules [5]&lt;/a&gt; и обработать этот файл (если не используется -n).</target>
        </trans-unit>
        <trans-unit id="64f4589d8b3cd6346365a117e7caa3c7d877c770" translate="yes" xml:space="preserve">
          <source>Mua-specific hints</source>
          <target state="translated">специфические намёки Муа</target>
        </trans-unit>
        <trans-unit id="c811c6583f834ffbc46d39586b81b1cb3e49b3e5" translate="yes" xml:space="preserve">
          <source>Multi-pack-index (midx) files have the following format:</source>
          <target state="translated">Мульти-пакет-индекс (midx)файлы имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="53148ea4bd03c54715064a8f67e0cc8cc140f85c" translate="yes" xml:space="preserve">
          <source>Multiple --notes options can be combined to control which notes are being displayed. Examples: &quot;--notes=foo&quot; will show only notes from &quot;refs/notes/foo&quot;; &quot;--notes=foo --notes&quot; will show both notes from &quot;refs/notes/foo&quot; and from the default notes ref(s).</source>
          <target state="translated">Для управления отображением заметок можно комбинировать несколько опций -notes.Примеры:&quot;--notes=foo&quot; будет показывать только ноты из &quot;refs/notes/foo&quot;;&quot;--notes=foo --notes&quot; будет показывать как ноты из &quot;refs/notes/foo&quot;,так и ноты из &quot;refs/notes/foo&quot; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="63667e9cd419f9751274dd2f16bda1512b373262" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;--filter=&lt;/code&gt; flags can be specified to combine filters. Only objects which are accepted by every filter are included.</source>
          <target state="translated">&lt;code&gt;--filter=&lt;/code&gt; несколько флагов --filter = для объединения фильтров. Включены только объекты, которые принимаются каждым фильтром.</target>
        </trans-unit>
        <trans-unit id="dc96f8ef1ccc109ff4dae28503fa1d96c62fb1de" translate="yes" xml:space="preserve">
          <source>Multiple checkout in general is still experimental, and the support for submodules is incomplete. It is NOT recommended to make multiple checkouts of a superproject.</source>
          <target state="translated">Многократная проверка в целом все еще экспериментальная,а поддержка субмодулей неполная.НЕ рекомендуется производить многократные проверки суперпроекта.</target>
        </trans-unit>
        <trans-unit id="5a07b93df04fb253e2e899a192e36f3454a882cd" translate="yes" xml:space="preserve">
          <source>Multiple fetch, branches, and tags keys are supported:</source>
          <target state="translated">Поддерживаются несколько клавиш извлечения,веток и тегов:</target>
        </trans-unit>
        <trans-unit id="279d7da4653c2486ef148e9e285812a9ab391b1e" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a &lt;code&gt;value-pattern&lt;/code&gt; (which is an extended regular expression, unless the &lt;code&gt;--fixed-value&lt;/code&gt; option is given) needs to be given. Only the existing values that match the pattern are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the pattern, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;), but note that this only works when the &lt;code&gt;--fixed-value&lt;/code&gt; option is not in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46275ca6ba0af124488d22d1e877279bfe2e6c0" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; needs to be given. Only the existing values that match the regexp are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the regex, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;).</source>
          <target state="translated">К параметру можно добавить несколько строк с помощью параметра &lt;code&gt;--add&lt;/code&gt; . Если вы хотите обновить или отменить параметр, который может встречаться в нескольких строках, необходимо &lt;code&gt;value_regex&lt;/code&gt; POSIX regexp value_regex . Только существующие значения, соответствующие регулярному выражению, обновляются или сбрасываются. Если вы хотите обработать строки, которые &lt;strong&gt;не&lt;/strong&gt; соответствуют регулярному выражению, просто поставьте перед ним один восклицательный знак (см. Также &lt;a href=&quot;#EXAMPLES&quot;&gt;ПРИМЕРЫ&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="77c43675935243a813626f8da7cb046544167112" translate="yes" xml:space="preserve">
          <source>Multiple tags on the same revision are not imported.</source>
          <target state="translated">Несколько тегов в одной и той же ревизии не импортируются.</target>
        </trans-unit>
        <trans-unit id="f2beb5df6d3d8f2a372e3411ba76c2a81700ed4b" translate="yes" xml:space="preserve">
          <source>Multiple values may be given to the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable. Their corresponding programs will be tried in the order listed in the configuration file.</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; конфигурации man.viewer можно задать несколько значений . Соответствующие программы будут проверены в порядке, указанном в файле конфигурации.</target>
        </trans-unit>
        <trans-unit id="ee6ae3f9558f190018d900b972ec0dd86c3ef0ee" translate="yes" xml:space="preserve">
          <source>Munging the diff output</source>
          <target state="translated">Мюнжирование диффузионного выхода</target>
        </trans-unit>
        <trans-unit id="31284f7dc1d9489b6ba33462518d05bce29455ee" translate="yes" xml:space="preserve">
          <source>Must be a blob id</source>
          <target state="translated">Должно быть,капля в руке</target>
        </trans-unit>
        <trans-unit id="bab4c6d734b3b13c2268e7fc81c79c9b99eef1dd" translate="yes" xml:space="preserve">
          <source>NORMAL Format</source>
          <target state="translated">НОРМАЛЬНЫЙ Формат</target>
        </trans-unit>
        <trans-unit id="4b5d099fcd6efcc01a4251de7ab2ddb7c47dd96b" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag ('before' the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to 'force' the checkout.</source>
          <target state="translated">НОТА! &lt;code&gt;git checkout-index&lt;/code&gt; обычно отказывается перезаписывать старые файлы, поэтому, если у вас есть старая версия дерева, уже извлеченная, вам нужно будет использовать флаг &lt;code&gt;-f&lt;/code&gt; ('перед' флагом &lt;code&gt;-a&lt;/code&gt; или именем файла) для 'принудительного' кассу.</target>
        </trans-unit>
        <trans-unit id="85ffa1dd083241144d9fbe2b1d63ba53159cc3e5" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag (&lt;code&gt;before&lt;/code&gt; the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to &lt;code&gt;force&lt;/code&gt; the checkout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1264e842b1d5e884b1bcd9c56e546555c80966fe" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does 'not' mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="translated">НОТА! &lt;code&gt;--remove&lt;/code&gt; флаг означает &amp;laquo;не&amp;raquo; означает , что последующие имена файлов обязательно будут удалены: если файлы по- прежнему существуют в вашей структуре каталогов, индекс будет обновляться с их новым статусом, не удаляются. Единственное, что означает &lt;code&gt;--remove&lt;/code&gt; , это то, что update-index будет рассматривать удаленный файл как допустимый, и если файл действительно больше не существует, он соответственно обновит индекс.</target>
        </trans-unit>
        <trans-unit id="14b973ba3566912be86ce74a38691b683bb1cd64" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does &lt;code&gt;not&lt;/code&gt; mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="cab1b18ac6c645752b07db74b58a821d43db7033" translate="yes" xml:space="preserve">
          <source>Name for the new branch.</source>
          <target state="translated">Название для нового филиала.</target>
        </trans-unit>
        <trans-unit id="ae3aefe579fe0e7749a842bc31610ab7a07dfe4c" translate="yes" xml:space="preserve">
          <source>Name of a HTML file which, if it exists, is included on the gitweb projects overview page (&quot;projects_list&quot; view). Relative to the directory containing the gitweb.cgi script. Default value can be adjusted during build time using &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; variable. By default set to &lt;code&gt;indextext.html&lt;/code&gt;.</source>
          <target state="translated">Имя HTML-файла, который, если он существует, включен на страницу обзора проектов gitweb (представление &amp;laquo;список_проектов&amp;raquo;). Относительно каталога, содержащего скрипт gitweb.cgi. Значение по умолчанию можно изменить во время сборки с &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; переменной GITWEB_HOMETEXT . По умолчанию установлен &lt;code&gt;indextext.html&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b26ce2bab88403572eb261078ddb7db93d3d704e" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the bottom of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">Имя файла с HTML, которое будет включено внизу каждой страницы. Относительно каталога, содержащего скрипт &lt;code&gt;gitweb.cgi&lt;/code&gt; . Можно установить с помощью &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; во время сборки. Нет значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cb37057e9d095a173db9c241ef8419b86a202d02" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the top of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">Имя файла с HTML, которое будет отображаться вверху каждой страницы. Относительно каталога, содержащего скрипт &lt;code&gt;gitweb.cgi&lt;/code&gt; . Можно установить с помощью &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; во время сборки. Нет значения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="389075bf1328d95e30f257d38d278dd3a0c94121" translate="yes" xml:space="preserve">
          <source>Name of a plain text file listing projects, or a name of directory to be scanned for projects.</source>
          <target state="translated">Имя простого текстового файла,содержащего список проектов,или имя каталога,который будет сканироваться для проектов.</target>
        </trans-unit>
        <trans-unit id="c0afa4635407444ed041e335278cc30cd2a11b14" translate="yes" xml:space="preserve">
          <source>Name of the SSL backend to use (e.g. &quot;openssl&quot; or &quot;schannel&quot;). This option is ignored if cURL lacks support for choosing the SSL backend at runtime.</source>
          <target state="translated">Имя используемого бэкэнда SSL (например,&quot;openssl&quot; или &quot;schannel&quot;).Эта опция игнорируется,если cURL не поддерживает выбор бэкэнда SSL во время выполнения.</target>
        </trans-unit>
        <trans-unit id="4d338fcbbcef71a5bde9a77e37abcbca835f1d4a" translate="yes" xml:space="preserve">
          <source>Name of the user running &lt;code&gt;git-cvsserver&lt;/code&gt;. If no name can be determined, the numeric uid is used.</source>
          <target state="translated">Имя пользователя, запустившего &lt;code&gt;git-cvsserver&lt;/code&gt; . Если имя не может быть определено, используется числовой uid.</target>
        </trans-unit>
        <trans-unit id="33a3a9f4baab999f10555d77c61fc17ad7a2e690" translate="yes" xml:space="preserve">
          <source>Name of your site or organization, to appear in page titles. Set it to something descriptive for clearer bookmarks etc. If this variable is not set or is, then gitweb uses the value of the &lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;code&gt;CGI&lt;/code&gt; environment variable, setting site name to &quot;$SERVER_NAME Git&quot;, or &quot;Untitled Git&quot; if this variable is not set (e.g. if running gitweb as standalone script).</source>
          <target state="translated">Название вашего сайта или организации, которое будет отображаться в заголовках страниц. Установите для него что-то описательное для более четких закладок и т. Д. Если эта переменная не установлена ​​или не установлена, то gitweb использует значение переменной среды &lt;code&gt;CGI&lt;/code&gt; &lt;code&gt;SERVER_NAME&lt;/code&gt; , задав для имени сайта значение &quot;$ SERVER_NAME Git&quot; или &quot;Untitled Git&quot;, если эта переменная не установлен (например, если gitweb запущен как автономный скрипт).</target>
        </trans-unit>
        <trans-unit id="ac84f0f88b7824faf06c4b53397972bcd09b01be" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH n/m]&lt;/code&gt; format, even with a single patch.</source>
          <target state="translated">Вывод имени в формате &lt;code&gt;[PATCH n/m]&lt;/code&gt; , даже с одним патчем.</target>
        </trans-unit>
        <trans-unit id="ffd008dca3705155e76303827e2a4d3059068c9a" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH]&lt;/code&gt; format.</source>
          <target state="translated">Вывод имени в формате &lt;code&gt;[PATCH]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe45d9f50e3991235a5aaf79d20ba4e50638c193" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;</source>
          <target state="translated">Именованный файл в &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e694d096f60594b306ed977a1cb3bf7e40731642" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;</source>
          <target state="translated">Именованный файл в &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d0059ee6bf7ca65460797daae6395c800b562c5" translate="yes" xml:space="preserve">
          <source>Named pointers called refs mark interesting points in history. A ref may contain the SHA-1 name of an object or the name of another ref. Refs with names beginning &lt;code&gt;ref/head/&lt;/code&gt; contain the SHA-1 name of the most recent commit (or &quot;head&quot;) of a branch under development. SHA-1 names of tags of interest are stored under &lt;code&gt;ref/tags/&lt;/code&gt;. A special ref named &lt;code&gt;HEAD&lt;/code&gt; contains the name of the currently checked-out branch.</source>
          <target state="translated">Именованные указатели, называемые refs, отмечают интересные моменты в истории. Ссылка может содержать имя SHA-1 объекта или имя другой ссылки. Ссылки с именами, начинающимися с &lt;code&gt;ref/head/&lt;/code&gt; содержат имя SHA-1 самого последнего коммита (или &amp;laquo;голову&amp;raquo;) разрабатываемой ветки. Имена SHA-1 интересующих тегов хранятся в &lt;code&gt;ref/tags/&lt;/code&gt; . Специальная ссылка с именем &lt;code&gt;HEAD&lt;/code&gt; содержит имя текущей извлеченной ветки.</target>
        </trans-unit>
        <trans-unit id="afc8b12ea961269025f67734b3112ac3163fa044" translate="yes" xml:space="preserve">
          <source>Named remote in configuration file</source>
          <target state="translated">Имя удалённого в файле конфигурации</target>
        </trans-unit>
        <trans-unit id="60da66dd4d339a94ae12e8c7a620ab333cdfa554" translate="yes" xml:space="preserve">
          <source>Names a low-level merge driver to be used when performing an internal merge between common ancestors. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Называет низкоуровневый драйвер слияния, который будет использоваться при выполнении внутреннего слияния между общими предками. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7238264e2238da432cea4cee3e4e4ec456281760" translate="yes" xml:space="preserve">
          <source>Naming branches, tags, and other references</source>
          <target state="translated">Наименование ветвей,тегов и других ссылок</target>
        </trans-unit>
        <trans-unit id="a8a795a40591e9038f52c089f34245ee06ab71bc" translate="yes" xml:space="preserve">
          <source>Naming commits</source>
          <target state="translated">Обязательства по наименованию</target>
        </trans-unit>
        <trans-unit id="7b635b48de06412b114cd8e91f1912aac5470b03" translate="yes" xml:space="preserve">
          <source>Nearly proper rewriting of tag objects is supported. If the tag has a message attached, a new tag object will be created with the same message, author, and timestamp. If the tag has a signature attached, the signature will be stripped. It is by definition impossible to preserve signatures. The reason this is &quot;nearly&quot; proper, is because ideally if the tag did not change (points to the same object, has the same name, etc.) it should retain any signature. That is not the case, signatures will always be removed, buyer beware. There is also no support for changing the author or timestamp (or the tag message for that matter). Tags which point to other tags will be rewritten to point to the underlying commit.</source>
          <target state="translated">Поддерживается практически корректное переписывание объектов тегов.Если к тегу прикреплено сообщение,то будет создан новый объект тега с тем же сообщением,автором и меткой времени.Если тег имеет вложенную подпись,то подпись будет удалена.Сохранение подписей по определению невозможно.Причина,по которой это &quot;почти&quot; верно,заключается в том,что в идеале,если тег не изменился (указывает на один и тот же объект,имеет одно и то же имя и т.д.),он должен сохранить любую подпись.Это не так,подписи всегда будут удалены,остерегайтесь покупателя.Также отсутствует поддержка смены автора или метки времени (или сообщения тега по этому поводу).Тэги,указывающие на другие теги,будут переписаны,чтобы указать на базовый коммит.</target>
        </trans-unit>
        <trans-unit id="ec8ce921b28e9d3cf6cf20eaf08287c17f378d35" translate="yes" xml:space="preserve">
          <source>Negating options</source>
          <target state="translated">Отрицательные варианты</target>
        </trans-unit>
        <trans-unit id="781db1e57c260d141571a81cbcc3db723749ad7f" translate="yes" xml:space="preserve">
          <source>Nevertheless, the code at C is broken, because the callers added on the lower line of development have not been converted to the new semantics introduced on the upper line of development. So if all you know is that D is bad, that Z is good, and that &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; identifies C as the culprit, how will you figure out that the problem is due to this change in semantics?</source>
          <target state="translated">Тем не менее, код на C не работает, потому что вызывающие объекты, добавленные на нижней строке разработки, не были преобразованы в новую семантику, введенную на верхней строке разработки. Итак, если все, что вы знаете, это то, что D - это плохо, что Z - хорошо, и что &lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]&lt;/a&gt; идентифицирует C как виновника, как вы поймете, что проблема связана с этим изменением семантики?</target>
        </trans-unit>
        <trans-unit id="a6160e254f396c410b853d5ee2bc722e35ccb61c" translate="yes" xml:space="preserve">
          <source>Nevertheless, this is a common practice for people that need a simple way to publish a work-in-progress patch series, and it is an acceptable compromise as long as you warn other developers that this is how you intend to manage the branch.</source>
          <target state="translated">Тем не менее,это обычная практика для людей,которым нужен простой способ опубликовать серию исправлений,и это приемлемый компромисс до тех пор,пока вы предупреждаете других разработчиков о том,что именно так вы собираетесь управлять веткой.</target>
        </trans-unit>
        <trans-unit id="208a508aabbf19798034826f77ed481ec28e90cc" translate="yes" xml:space="preserve">
          <source>New features:</source>
          <target state="translated">Новые возможности:</target>
        </trans-unit>
        <trans-unit id="c191eda851b2a021b1ece3943d51bb10c7c6e4eb" translate="yes" xml:space="preserve">
          <source>New marks are created automatically. Existing marks can be moved to another object simply by reusing the same &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; in another &lt;code&gt;mark&lt;/code&gt; command.</source>
          <target state="translated">Новые отметки создаются автоматически. Существующие метки можно переместить в другой объект, просто повторно используя тот же &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; в другой команде &lt;code&gt;mark&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34f293962e034aa3adab30d6ce7bb006c129576e" translate="yes" xml:space="preserve">
          <source>New objects written by fast-import are not available immediately. Most fast-import commands have no visible effect until the next checkpoint (or completion). The frontend can send commands to fill fast-import&amp;rsquo;s input pipe without worrying about how quickly they will take effect, which improves performance by simplifying scheduling.</source>
          <target state="translated">Новые объекты, написанные с помощью быстрого импорта, доступны не сразу. Большинство команд быстрого импорта не имеют видимого эффекта до следующей контрольной точки (или завершения). Интерфейс может отправлять команды для заполнения входного канала быстрого импорта, не беспокоясь о том, как быстро они вступят в силу, что повышает производительность за счет упрощения планирования.</target>
        </trans-unit>
        <trans-unit id="bd5d84635e8045ac3e97cdc31b8e7c57fb2006ba" translate="yes" xml:space="preserve">
          <source>New remote-tracking branches will be stored under the shorthand name that you gave &lt;code&gt;git remote add&lt;/code&gt;, in this case &lt;code&gt;staging&lt;/code&gt;:</source>
          <target state="translated">Новые ветки удаленного отслеживания будут храниться под сокращенным именем, которое вы дали &lt;code&gt;git remote add&lt;/code&gt; , в данном случае &lt;code&gt;staging&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="408210d4e2e7bc9a95a98e6b1bf8a3bd1ff14459" translate="yes" xml:space="preserve">
          <source>New users are encouraged to use &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; instead. The &lt;code&gt;whatchanged&lt;/code&gt; command is essentially the same as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; but defaults to show the raw format diff output and to skip merges.</source>
          <target state="translated">Новым пользователям рекомендуется использовать вместо этого &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; . Команда &lt;code&gt;whatchanged&lt;/code&gt; по сути такая же, как &lt;a href=&quot;git-log&quot;&gt;git-log [1],&lt;/a&gt; но по умолчанию показывает вывод различий в исходном формате и пропускает слияния.</target>
        </trans-unit>
        <trans-unit id="04e09d741912def77b41c31c7fd7bada0af8f8f2" translate="yes" xml:space="preserve">
          <source>Newer &lt;code&gt;git diff&lt;/code&gt; output has embedded &lt;code&gt;index information&lt;/code&gt; for each blob to help identify the original version that the patch applies to. When this flag is given, and if the original versions of the blobs are available locally, builds a temporary index containing those blobs.</source>
          <target state="translated">Более &lt;code&gt;git diff&lt;/code&gt; вывод git diff содержит встроенную &lt;code&gt;index information&lt;/code&gt; для каждого большого двоичного объекта, чтобы помочь определить исходную версию, к которой применяется исправление. Если установлен этот флаг, и если исходные версии больших двоичных объектов доступны локально, создается временный индекс, содержащий эти большие двоичные объекты.</target>
        </trans-unit>
        <trans-unit id="7f94af506f4cd517718453425d685ea35e84d4c7" translate="yes" xml:space="preserve">
          <source>Newly created objects are initially created in a file named after the object&amp;rsquo;s SHA-1 hash (stored in &lt;code&gt;.git/objects&lt;/code&gt;).</source>
          <target state="translated">Вновь созданные объекты изначально создаются в файле, названном в честь хэша SHA-1 объекта (хранящегося в &lt;code&gt;.git/objects&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5efdf7f0d1fca004c74269609acfa25723d86160" translate="yes" xml:space="preserve">
          <source>Next step: get familiar with the object naming. Read &lt;a href=&quot;#naming-commits&quot;&gt;Naming commits&lt;/a&gt;. There are quite a few ways to name an object (and not only revisions!). All of these are handled in &lt;code&gt;sha1_name.c&lt;/code&gt;. Just have a quick look at the function &lt;code&gt;get_sha1()&lt;/code&gt;. A lot of the special handling is done by functions like &lt;code&gt;get_sha1_basic()&lt;/code&gt; or the likes.</source>
          <target state="translated">Следующий шаг: познакомимся с именованием объекта. Прочтите &lt;a href=&quot;#naming-commits&quot;&gt;коммиты по именованию&lt;/a&gt; . Существует довольно много способов дать объекту имя (и не только ревизии!). Все это обрабатывается в &lt;code&gt;sha1_name.c&lt;/code&gt; . Взгляните на функцию &lt;code&gt;get_sha1()&lt;/code&gt; . Большая часть специальной обработки выполняется такими функциями, как &lt;code&gt;get_sha1_basic()&lt;/code&gt; или подобными.</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">Следующие шаги</target>
        </trans-unit>
        <trans-unit id="817a91571b93a177740989ad9e63a1941cffb303" translate="yes" xml:space="preserve">
          <source>Next time, after seeing the same conflicted automerge, running &lt;code&gt;git rerere&lt;/code&gt; will perform a three-way merge between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted automerge. If this three-way merge resolves cleanly, the result is written out to your working tree file, so you do not have to manually resolve it. Note that &lt;code&gt;git rerere&lt;/code&gt; leaves the index file alone, so you still need to do the final sanity checks with &lt;code&gt;git diff&lt;/code&gt; (or &lt;code&gt;git diff -c&lt;/code&gt;) and &lt;code&gt;git add&lt;/code&gt; when you are satisfied.</source>
          <target state="translated">В следующий раз, увидев такое же конфликтующее автоматическое объединение, запуск &lt;code&gt;git rerere&lt;/code&gt; выполнит трехстороннее слияние между ранее конфликтующим автоматическим объединением, более ранним ручным разрешением и текущим конфликтующим автоматическим объединением. Если это трехстороннее слияние разрешается чисто, результат записывается в ваш рабочий файл дерева, поэтому вам не нужно вручную разрешать его. Обратите внимание, что &lt;code&gt;git rerere&lt;/code&gt; оставляет индексный файл в покое, поэтому вам все равно нужно выполнить окончательную проверку &lt;code&gt;git diff&lt;/code&gt; с помощью git diff (или &lt;code&gt;git diff -c&lt;/code&gt; ) и &lt;code&gt;git add&lt;/code&gt; , когда вы будете удовлетворены.</target>
        </trans-unit>
        <trans-unit id="74ccc5b41472ca3ff8486dd211ddfe0cae9246c3" translate="yes" xml:space="preserve">
          <source>Next, commit the changes stored in the index. The &lt;code&gt;-c&lt;/code&gt; option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The &lt;code&gt;HEAD@{1}&lt;/code&gt; is a special notation for the commit that &lt;code&gt;HEAD&lt;/code&gt; used to be at prior to the original reset commit (1 change ago). See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for more details. You may also use any other valid commit reference.</source>
          <target state="translated">Затем зафиксируйте изменения, хранящиеся в индексе. Параметр &lt;code&gt;-c&lt;/code&gt; указывает предварительное заполнение сообщения фиксации из исходного сообщения, с которого вы начали в первой фиксации. Это поможет избежать его повторного ввода. &lt;code&gt;HEAD@{1}&lt;/code&gt; является специальным обозначением для фиксации , что &lt;code&gt;HEAD&lt;/code&gt; используется для быть до первоначального сброса фиксации (1 изменить назад). См. &lt;a href=&quot;git-reflog&quot;&gt;Git-reflog [1]&lt;/a&gt; для получения более подробной информации. Вы также можете использовать любую другую действительную ссылку на фиксацию.</target>
        </trans-unit>
        <trans-unit id="d481150e66b12915d203137377672c89781fe045" translate="yes" xml:space="preserve">
          <source>Next, copy &lt;code&gt;proj.git&lt;/code&gt; to the server where you plan to host the public repository. You can use scp, rsync, or whatever is most convenient.</source>
          <target state="translated">Затем скопируйте &lt;code&gt;proj.git&lt;/code&gt; на сервер, на котором вы планируете разместить публичный репозиторий. Вы можете использовать scp, rsync или что угодно, что вам удобнее.</target>
        </trans-unit>
        <trans-unit id="04e0b9feb1c4a494995ed09ad261d2d4e9ce11c5" translate="yes" xml:space="preserve">
          <source>Next, give every team member read/write access to this repository. One easy way to do this is to give all the team members ssh access to the machine where the repository is hosted. If you don&amp;rsquo;t want to give them a full shell on the machine, there is a restricted shell which only allows users to do Git pushes and pulls; see &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt;.</source>
          <target state="translated">Затем предоставьте каждому члену команды доступ для чтения / записи в этот репозиторий. Один из простых способов сделать это - предоставить всем участникам команды ssh-доступ к машине, на которой размещен репозиторий. Если вы не хотите предоставлять им полную оболочку на машине, существует ограниченная оболочка, которая позволяет пользователям выполнять только нажатия и извлечения Git; см. &lt;a href=&quot;git-shell&quot;&gt;git-shell [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28d55d870524553fca2220c18e5b9bb0de3dcbdb" translate="yes" xml:space="preserve">
          <source>Next, tell Git to take a snapshot of the contents of all files under the current directory (note the &lt;code&gt;.&lt;/code&gt;), with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="translated">Затем скажите Git сделать снимок содержимого всех файлов в текущем каталоге (обратите внимание на &lt;code&gt;.&lt;/code&gt; ) С помощью &lt;code&gt;git add&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="596419ac8ea3393898cb55dbbde5c3613a819bd1" translate="yes" xml:space="preserve">
          <source>Next, we interactively select diff hunks to add using the &lt;code&gt;git add -p&lt;/code&gt; facility. This will ask you about each diff hunk in sequence and you can use simple commands such as &quot;yes, include this&quot;, &quot;No don&amp;rsquo;t include this&quot; or even the very powerful &quot;edit&quot; facility.</source>
          <target state="translated">Затем мы интерактивно выбираем блоки diff для добавления с помощью средства &lt;code&gt;git add -p&lt;/code&gt; . Вам будет задан вопрос о каждом блоке различий по порядку, и вы сможете использовать простые команды, такие как &amp;laquo;да, включить это&amp;raquo;, &amp;laquo;Нет, не включать это&amp;raquo; или даже очень мощное средство &amp;laquo;редактирования&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="8951da293ad0f99492d7f4956f721a58ac3b7ff1" translate="yes" xml:space="preserve">
          <source>No checkout of HEAD is performed after the clone is complete.</source>
          <target state="translated">После завершения клона проверка ГОЛОВА не проводится.</target>
        </trans-unit>
        <trans-unit id="cfeba19b6e040607769791cbfbefd83c894b180c" translate="yes" xml:space="preserve">
          <source>No modifications to submodules are ignored, all of committed differences, and modifications to tracked and untracked files are shown. This is the default option.</source>
          <target state="translated">Никакие модификации подмодулей не игнорируются,отображаются все зафиксированные различия,а также модификации отслеживаемых и неотслеживаемых файлов.Это опция по умолчанию.</target>
        </trans-unit>
        <trans-unit id="e2a67085604f2eb59fb72fa11fe30ca6d6e00a34" translate="yes" xml:space="preserve">
          <source>No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Никаких других изменений не вносится. В частности, локальные изменения, которые вы сделали до начала слияния, останутся такими же, а записи индекса для них останутся такими, какими они были, то есть совпадающими с &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de8a6fbc5b9c2db6f89c1e3ad733992686a5d62a" translate="yes" xml:space="preserve">
          <source>No other kinds of lines (e.g. empty lines or comment lines) are allowed in the file, even though some may be silently ignored. Do not view or edit the file with editors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c967d0b967e1e36091e8958a5454d9ea9951dded" translate="yes" xml:space="preserve">
          <source>No other modifications are made.</source>
          <target state="translated">Никаких других изменений не производится.</target>
        </trans-unit>
        <trans-unit id="57658df76cf3f4fecaffea0a60cae0068e21e278" translate="yes" xml:space="preserve">
          <source>No patch introduces a regression: after applying any initial part of the series, the resulting project still compiles and works, and has no bugs that it didn&amp;rsquo;t have before.</source>
          <target state="translated">Никакой патч не приводит к регрессу: после применения любой начальной части серии результирующий проект по-прежнему компилируется и работает, и в нем нет ошибок, которых не было раньше.</target>
        </trans-unit>
        <trans-unit id="0d39633312554b0ea8cb734d680c4698c57a7afd" translate="yes" xml:space="preserve">
          <source>No pattern matches the path, and nothing says if the path has or does not have the attribute, the attribute for the path is said to be Unspecified.</source>
          <target state="translated">Ни один шаблон не совпадает с путём,и ничто не говорит,что если путь имеет или не имеет атрибут,то атрибут для пути считается Уточнённым.</target>
        </trans-unit>
        <trans-unit id="772b72b88edec66167df810a58edde895140fe67" translate="yes" xml:space="preserve">
          <source>No promises are made about the interface, or that this program won&amp;rsquo;t disappear without warning in the next version of Git. Don&amp;rsquo;t use it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c90ed1cbdf989952fffa921b682ee1beb354558a" translate="yes" xml:space="preserve">
          <source>No special setup is needed for SSH access, other than having Git tools in the PATH. If you have clients that do not accept the CVS_SERVER environment variable, you can rename &lt;code&gt;git-cvsserver&lt;/code&gt; to &lt;code&gt;cvs&lt;/code&gt;.</source>
          <target state="translated">Для доступа по SSH не требуется никаких специальных настроек, кроме наличия инструментов Git в PATH. Если у вас есть клиенты, которые не принимают переменную среды CVS_SERVER, вы можете переименовать &lt;code&gt;git-cvsserver&lt;/code&gt; в &lt;code&gt;cvs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8302d8fa548b77adf094708d453bfd512d86a1e" translate="yes" xml:space="preserve">
          <source>No-op. Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased. Now commits with an empty message do not cause rebasing to halt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5febeaff9fb6579d7fb9744e50b3994bde6d8e3" translate="yes" xml:space="preserve">
          <source>Non-ascii filenames can be silently removed despite being in a desired directory. Keeping only wanted paths is often done using pipelines like &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt;. ls-files will only quote filenames if needed, so folks may not notice that one of the files didn&amp;rsquo;t match the regex (at least not until it&amp;rsquo;s much too late). Yes, someone who knows about core.quotePath can avoid this (unless they have other special characters like \t, \n, or &quot;), and people who use ls-files -z with something other than grep can avoid this, but that doesn&amp;rsquo;t mean they will.</source>
          <target state="translated">Имена файлов в формате, отличном от ascii, могут быть удалены без уведомления, несмотря на то, что они находятся в желаемом каталоге. Сохранение только желаемых путей часто выполняется с помощью конвейеров, таких как &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt; . ls-files будут указывать имена файлов только при необходимости, поэтому люди могут не заметить, что один из файлов не соответствует регулярному выражению (по крайней мере, пока не станет слишком поздно). Да, тот, кто знает о core.quotePath, может этого избежать (если у него нет других специальных символов, таких как \ t, \ n или &quot;), и люди, которые используют ls-files -z с чем-то другим, кроме grep, могут этого избежать, но не значит, что они будут.</target>
        </trans-unit>
        <trans-unit id="e2858812ab58a3c85b7437528709a46037dcfba6" translate="yes" xml:space="preserve">
          <source>Non-cached mode</source>
          <target state="translated">Не кэшированный режим</target>
        </trans-unit>
        <trans-unit id="28592521357265f4a182551c4308e7cea911b93e" translate="yes" xml:space="preserve">
          <source>Non-empty context lines that have one extra whitespace at the beginning.</source>
          <target state="translated">Непустые строки контекста с одним дополнительным белым пробелом в начале.</target>
        </trans-unit>
        <trans-unit id="54b4652d3bd254c89ec712af1b81619180dc7f11" translate="yes" xml:space="preserve">
          <source>None of the provided paths are ignored.</source>
          <target state="translated">Ни один из предложенных путей не игнорируется.</target>
        </trans-unit>
        <trans-unit id="53d641d85a09ede95cefeac02aadaca1a7fcd396" translate="yes" xml:space="preserve">
          <source>Normalize &lt;code&gt;refname&lt;/code&gt; by removing any leading slash (&lt;code&gt;/&lt;/code&gt;) characters and collapsing runs of adjacent slashes between name components into a single slash. If the normalized refname is valid then print it to standard output and exit with a status of 0, otherwise exit with a non-zero status. (&lt;code&gt;--print&lt;/code&gt; is a deprecated way to spell &lt;code&gt;--normalize&lt;/code&gt;.)</source>
          <target state="translated">Нормализуйте &lt;code&gt;refname&lt;/code&gt; , удалив все начальные символы косой черты ( &lt;code&gt;/&lt;/code&gt; ) и свернув ряды соседних косых черт между компонентами имени в одну косую черту. Если нормализованное имя ссылки является допустимым, выведите его на стандартный вывод и выйдите со статусом 0, в противном случае выйдите с ненулевым статусом. ( &lt;code&gt;--print&lt;/code&gt; - устаревший способ &lt;code&gt;--normalize&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="cd7a46a34b030b4fa7a1f4c298bb470454f5bdc6" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;git write-tree&lt;/code&gt; ensures that the objects referenced by the directory exist in the object database. This option disables this check.</source>
          <target state="translated">Обычно &lt;code&gt;git write-tree&lt;/code&gt; гарантирует, что объекты, на которые ссылается каталог, существуют в базе данных объектов. Эта опция отключает эту проверку.</target>
        </trans-unit>
        <trans-unit id="88fcf17b3fc3a47614adb1a8f9a3b0161d3a2185" translate="yes" xml:space="preserve">
          <source>Normally a &quot;commit&quot; has one parent: the previous state of the tree before a certain change was made. However, sometimes it can have two or more parent commits, in which case we call it a &quot;merge&quot;, due to the fact that such a commit brings together (&quot;merges&quot;) two or more previous states represented by other commits.</source>
          <target state="translated">Обычно &quot;коммит&quot; имеет одного родителя:предыдущее состояние дерева до того,как было сделано определенное изменение.Однако,иногда у него может быть два или более родительских коммита,в этом случае мы называем его &quot;слиянием&quot;,из-за того,что такой коммит объединяет (&quot;слияние&quot;)два или более предыдущих состояния,представленных другими коммитами.</target>
        </trans-unit>
        <trans-unit id="a69474e938cf33a616aeca615fe9997480c7c945" translate="yes" xml:space="preserve">
          <source>Normally a commit would identify a new &quot;HEAD&quot; state, and while Git doesn&amp;rsquo;t care where you save the note about that state, in practice we tend to just write the result to the file that is pointed at by &lt;code&gt;.git/HEAD&lt;/code&gt;, so that we can always see what the last committed state was.</source>
          <target state="translated">Обычно фиксация определяет новое состояние &amp;laquo;HEAD&amp;raquo;, и хотя Git не заботится о том, где вы сохраняете заметку об этом состоянии, на практике мы просто записываем результат в файл, на который указывает &lt;code&gt;.git/HEAD&lt;/code&gt; , так что мы всегда можем видеть, каким было последнее зафиксированное состояние.</target>
        </trans-unit>
        <trans-unit id="de60fcb388acbd1518bd224ad2216b3a990124fa" translate="yes" xml:space="preserve">
          <source>Normally batch output is flushed after each object is output, so that a process can interactively read and write from &lt;code&gt;cat-file&lt;/code&gt;. With this option, the output uses normal stdio buffering; this is much more efficient when invoking &lt;code&gt;--batch-check&lt;/code&gt; on a large number of objects.</source>
          <target state="translated">Обычно пакетный вывод сбрасывается после вывода каждого объекта, так что процесс может интерактивно читать и писать из &lt;code&gt;cat-file&lt;/code&gt; . С этой опцией вывод использует обычную буферизацию stdio; это намного эффективнее при вызове &lt;code&gt;--batch-check&lt;/code&gt; для большого количества объектов.</target>
        </trans-unit>
        <trans-unit id="38e091b35be2fc0762233a3d599b506f3b643fb1" translate="yes" xml:space="preserve">
          <source>Normally commits are only added to a project, never taken away or replaced. Git is designed with this assumption, and violating it will cause Git&amp;rsquo;s merge machinery (for example) to do the wrong thing.</source>
          <target state="translated">Обычно коммиты только добавляются в проект, никогда не удаляются и не заменяются. Git разработан с учетом этого предположения, и его нарушение приведет к тому, что механизм слияния Git (например) будет делать неправильные вещи.</target>
        </trans-unit>
        <trans-unit id="9122c3565585fe79768943dc25f1cf167ffbd58d" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; stores the name of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at. However, Git also allows you to &lt;a href=&quot;#def_checkout&quot;&gt;check out&lt;/a&gt; an arbitrary &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; that isn&amp;rsquo;t necessarily the tip of any particular branch. The HEAD in such a state is called &quot;detached&quot;.</source>
          <target state="translated">Обычно &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; хранит имя &lt;a href=&quot;#def_branch&quot;&gt;ветки&lt;/a&gt; , а команды, которые работают с историей, которую представляет HEAD, работают с историей, ведущей к вершине ветки, на которую указывает HEAD. Однако Git также позволяет вам &lt;a href=&quot;#def_checkout&quot;&gt;проверить&lt;/a&gt; произвольную &lt;a href=&quot;#def_commit&quot;&gt;фиксацию,&lt;/a&gt; которая не обязательно является вершиной какой-либо конкретной ветки. ГОЛОВА в таком состоянии называется &amp;laquo;отсоединенной&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="cc5f74671cf296af564ff0627cbd1c153eed7819" translate="yes" xml:space="preserve">
          <source>Normally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options; see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">Обычно объединенная ветка является HEAD удаленного репозитория, но выбор определяется параметрами branch. &amp;lt;name&amp;gt; .remote и branch. &amp;lt;name&amp;gt; .merge; подробнее см. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f22467859cfedb6f904df5424dcd9afb82c226b1" translate="yes" xml:space="preserve">
          <source>Normally whenever a branch head in a public repository is modified, it is modified to point to a descendant of the commit that it pointed to before. By forcing a push in this situation, you break that convention. (See &lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;Problems with rewriting history&lt;/a&gt;.)</source>
          <target state="translated">Обычно всякий раз, когда изменяется заголовок ветки в общедоступном репозитории, он изменяется так, чтобы указывать на потомка коммита, на который он указывал ранее. Форсируя толчок в этой ситуации, вы нарушаете это соглашение. (См. &lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;Проблемы с перезаписью истории&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="43244e83cbae6a59cf653d315de1a56015589247" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;git rerere&lt;/code&gt; is run without arguments or user-intervention. However, it has several commands that allow it to interact with its working state.</source>
          <target state="translated">Обычно &lt;code&gt;git rerere&lt;/code&gt; запускается без аргументов или вмешательства пользователя. Однако у него есть несколько команд, которые позволяют ему взаимодействовать с его рабочим состоянием.</target>
        </trans-unit>
        <trans-unit id="d7d70adae9e248dcbf5927b7eeba22fdf79a73fb" translate="yes" xml:space="preserve">
          <source>Normally, only files unknown to Git are removed, but if the &lt;code&gt;-x&lt;/code&gt; option is specified, ignored files are also removed. This can, for example, be useful to remove all build products.</source>
          <target state="translated">Обычно удаляются только файлы, неизвестные Git, но если указана опция &lt;code&gt;-x&lt;/code&gt; , игнорируемые файлы также удаляются. Это может быть полезно, например, для удаления всех продуктов сборки.</target>
        </trans-unit>
        <trans-unit id="ea1a90319260338e8b5ddefd985427f3690ce910" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;git svn clone&quot; and &quot;git svn rebase&quot; commands attempt to recreate empty directories that are in the Subversion repository. If this option is set to &quot;false&quot;, then empty directories will only be created if the &quot;git svn mkdirs&quot; command is run explicitly. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">Обычно команды &amp;laquo;git svn clone&amp;raquo; и &amp;laquo;git svn rebase&amp;raquo; пытаются воссоздать пустые каталоги, которые находятся в репозитории Subversion. Если для этого параметра установлено значение &amp;laquo;false&amp;raquo;, тогда пустые каталоги будут созданы только в том случае, если команда &amp;laquo;git svn mkdirs&amp;raquo; запускается явно. Если не задано, &lt;code&gt;git svn&lt;/code&gt; предполагает, что этот параметр установлен как &quot;true&quot;.</target>
        </trans-unit>
        <trans-unit id="cbab35b86acdc7c387af4e06856d3dc90a27828f" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;name&quot; field contains the canonical name of the command. When a canonical name is not available, one of these special values are used:</source>
          <target state="translated">Обычно поле &quot;имя&quot; содержит каноническое название команды.При отсутствии канонического имени используется одно из этих специальных значений:</target>
        </trans-unit>
        <trans-unit id="a72159c3df537e6c1eeaac201666cb67a55dea2c" translate="yes" xml:space="preserve">
          <source>Normally, the first commit in an SVN branch consists of a copy operation. &lt;code&gt;git svn&lt;/code&gt; will read this commit to get the SVN revision the branch was created from. It will then try to find the Git commit that corresponds to this SVN revision, and use that as the parent of the branch. However, it is possible that there is no suitable Git commit to serve as parent. This will happen, among other reasons, if the SVN branch is a copy of a revision that was not fetched by &lt;code&gt;git svn&lt;/code&gt; (e.g. because it is an old revision that was skipped with &lt;code&gt;--revision&lt;/code&gt;), or if in SVN a directory was copied that is not tracked by &lt;code&gt;git svn&lt;/code&gt; (such as a branch that is not tracked at all, or a subdirectory of a tracked branch). In these cases, &lt;code&gt;git svn&lt;/code&gt; will still create a Git branch, but instead of using an existing Git commit as the parent of the branch, it will read the SVN history of the directory the branch was copied from and create appropriate Git commits. This is indicated by the message &quot;Initializing parent: &amp;lt;branchname&amp;gt;&quot;.</source>
          <target state="translated">Обычно первая фиксация в ветке SVN состоит из операции копирования. &lt;code&gt;git svn&lt;/code&gt; прочитает этот коммит, чтобы получить версию SVN, из которой была создана ветка. Затем он попытается найти коммит Git, соответствующий этой версии SVN, и использовать его в качестве родителя ветки. Однако возможно, что нет подходящего коммита Git, который мог бы служить родительским. Это произойдет, среди прочего, если ветвь SVN является копией ревизии, которая не была получена с помощью &lt;code&gt;git svn&lt;/code&gt; (например, потому что это старая ревизия, которая была пропущена с помощью &lt;code&gt;--revision&lt;/code&gt; ), или если в SVN был скопирован каталог который не отслеживается &lt;code&gt;git svn&lt;/code&gt; (например, ветвь, которая не отслеживается вообще, или подкаталог отслеживаемой ветки). В этих случаях &lt;code&gt;git svn&lt;/code&gt; по-прежнему будет создавать ветку Git, но вместо использования существующей фиксации Git в качестве родительской для ветки он будет читать историю SVN каталога, из которого была скопирована ветка, и создавать соответствующие фиксации Git. На это указывает сообщение &amp;laquo;Инициализация родителя: &amp;lt;имя-ветки&amp;gt;&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4d54b3aadfbad6c493d83bcb2428d0cb9e46992e" translate="yes" xml:space="preserve">
          <source>Normally, when no &amp;lt;path&amp;gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under &lt;code&gt;--force&lt;/code&gt;) will be removed.</source>
          <target state="translated">Обычно, когда &amp;lt;path&amp;gt; не указан, git clean не будет рекурсивно переходить в неотслеживаемые каталоги, чтобы избежать слишком большого удаления. Укажите -d, чтобы он также рекурсивно перемещался в такие каталоги. Если указаны какие-либо пути, -d не имеет значения; все неотслеживаемые файлы, соответствующие указанным путям (за исключением вложенных каталогов git, указанных в параметре &lt;code&gt;--force&lt;/code&gt; ), будут удалены.</target>
        </trans-unit>
        <trans-unit id="429c7c6d611a6b06377c7694b2f456c87ba75047" translate="yes" xml:space="preserve">
          <source>Not all pattern types support patterns containing \0. Git will error out if a given pattern type can&amp;rsquo;t support such a pattern. The &lt;code&gt;--perl-regexp&lt;/code&gt; pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns.</source>
          <target state="translated">Не все типы шаблонов поддерживают шаблоны, содержащие \ 0. Git выдаст ошибку, если данный тип шаблона не может поддерживать такой шаблон. Тип &lt;code&gt;--perl-regexp&lt;/code&gt; при компиляции с серверной частью PCRE v2 имеет самую широкую поддержку для этих типов шаблонов.</target>
        </trans-unit>
        <trans-unit id="fc85aa9ed9f2a57ce72e656178cf6fe66c794d02" translate="yes" xml:space="preserve">
          <source>Not all values are equally unambiguous:</source>
          <target state="translated">Не все значения одинаково однозначны:</target>
        </trans-unit>
        <trans-unit id="8394b0fb9c23c1116919b0832addc200fe1387df" translate="yes" xml:space="preserve">
          <source>Not to worry. It left the (trivial) conflict in &lt;code&gt;hello&lt;/code&gt; in the same form you should already be well used to if you&amp;rsquo;ve ever used CVS, so let&amp;rsquo;s just open &lt;code&gt;hello&lt;/code&gt; in our editor (whatever that may be), and fix it up somehow. I&amp;rsquo;d suggest just making it so that &lt;code&gt;hello&lt;/code&gt; contains all four lines:</source>
          <target state="translated">Не беспокоиться. Он оставил (тривиальный) конфликт в &lt;code&gt;hello&lt;/code&gt; в той же форме, к которой вы уже должны были хорошо привыкнуть, если когда-либо использовали CVS, поэтому давайте просто откроем &lt;code&gt;hello&lt;/code&gt; в нашем редакторе (что бы это ни было) и как-нибудь исправим его. Я предлагаю просто сделать так, чтобы &lt;code&gt;hello&lt;/code&gt; содержал все четыре строки:</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b7ed8e5f5bf09b0c843d3af582307ddfb588c4c6" translate="yes" xml:space="preserve">
          <source>Note about fast-forwards</source>
          <target state="translated">Обратите внимание на перемотки вперед</target>
        </trans-unit>
        <trans-unit id="318ccd302e94c5b26153ff4314826ba81af60a67" translate="yes" xml:space="preserve">
          <source>Note about git config --global</source>
          <target state="translated">Обратите внимание на git-конфигурацию --global</target>
        </trans-unit>
        <trans-unit id="7da8f06b5e46e2bca162125caa0438ca1631ce6d" translate="yes" xml:space="preserve">
          <source>Note about git-config --global</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a858b9b8c7722185661603839f0881f8c7f88318" translate="yes" xml:space="preserve">
          <source>Note about konqueror</source>
          <target state="translated">Заметка о завоевателе</target>
        </trans-unit>
        <trans-unit id="01b5dd07775875ee6aa9a8a3da76365c637f9b1a" translate="yes" xml:space="preserve">
          <source>Note also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy&amp;rsquo;s size or delta base will be reported.</source>
          <target state="translated">Также обратите внимание, что в базе данных объектов может быть несколько копий объекта; в этом случае не определено, какой размер копии или дельта-база будет сообщаться.</target>
        </trans-unit>
        <trans-unit id="e92cbc9ca374ec932eab116752367c5739918c53" translate="yes" xml:space="preserve">
          <source>Note for Git users, that it is equivalent as keeping only the commit given by:</source>
          <target state="translated">Обратите внимание пользователей Git'а,что это эквивалентно сохранению только заданного коммита:</target>
        </trans-unit>
        <trans-unit id="9cd066f98a94620416bd40171030f2cd3deb4780" translate="yes" xml:space="preserve">
          <source>Note how the rule to only follow the TREESAME parent, if one is available, removed &lt;code&gt;B&lt;/code&gt; from consideration entirely. &lt;code&gt;C&lt;/code&gt; was considered via &lt;code&gt;N&lt;/code&gt;, but is TREESAME. Root commits are compared to an empty tree, so &lt;code&gt;I&lt;/code&gt; is !TREESAME.</source>
          <target state="translated">Обратите внимание, как правило следовать только родительскому элементу TREESAME, если таковой имеется, полностью исключило &lt;code&gt;B&lt;/code&gt; из рассмотрения. &lt;code&gt;C&lt;/code&gt; рассматривался через &lt;code&gt;N&lt;/code&gt; , но это TREESAME. Корневые коммиты сравниваются с пустым деревом, поэтому &lt;code&gt;I&lt;/code&gt; ! TREESAME.</target>
        </trans-unit>
        <trans-unit id="8bfd2da46a110f046c6975fde1a8b82933cacdc7" translate="yes" xml:space="preserve">
          <source>Note how there is no need for an entry for &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt;, because the real name of that author is already correct.</source>
          <target state="translated">Обратите внимание, что запись для &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt; не требуется , потому что настоящее имя этого автора уже верно.</target>
        </trans-unit>
        <trans-unit id="a357a7dbcbc2a41b2d3445e7cfb8ae38a48bfe09" translate="yes" xml:space="preserve">
          <source>Note in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, &lt;code&gt;@{push}&lt;/code&gt; is the same as &lt;code&gt;@{upstream}&lt;/code&gt;, and there is no need for it.</source>
          <target state="translated">Обратите внимание, что в этом примере мы настраиваем треугольный рабочий процесс, в котором мы тянем из одного места и отправляем в другое. В нетреугольном рабочем процессе &lt;code&gt;@{push}&lt;/code&gt; совпадает с &lt;code&gt;@{upstream}&lt;/code&gt; , и в этом нет необходимости.</target>
        </trans-unit>
        <trans-unit id="01660f89f7c458ce6428d6e0df0b322692b74596" translate="yes" xml:space="preserve">
          <source>Note that &quot;%f&quot; is the name of the path that is being worked on. Depending on the version that is being filtered, the corresponding file on disk may not exist, or may have different contents. So, smudge and clean commands should not try to access the file on disk, but only act as filters on the content provided to them on standard input.</source>
          <target state="translated">Обратите внимание,что &quot;%f&quot;-это имя пути,над которым ведется работа.В зависимости от версии,которая фильтруется,соответствующий файл на диске может не существовать или иметь разное содержимое.Поэтому команды &quot;размазывания&quot; и &quot;очистки&quot; не должны пытаться получить доступ к файлу на диске,а только действовать в качестве фильтров по содержимому,предоставляемому им на стандартном входе.</target>
        </trans-unit>
        <trans-unit id="014f6a8d43d7b297d024fa501c939621bed28154" translate="yes" xml:space="preserve">
          <source>Note that &quot;../&quot; is not special and will match literally, which is unlikely what you want.</source>
          <target state="translated">Обратите внимание,что &quot;.../&quot; не является особенным и будет соответствовать буквально,что вряд ли то,что вы хотите.</target>
        </trans-unit>
        <trans-unit id="8b91ded5c4fad4671b25fb8bfeab09bc89a0acef" translate="yes" xml:space="preserve">
          <source>Note that (3) is a historical artefact and will be ignored if the (1) and (2) specify that the submodule is not active. In other words, if we have a &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; or if the submodule&amp;rsquo;s path is excluded in the pathspec in &lt;code&gt;submodule.active&lt;/code&gt;, the url doesn&amp;rsquo;t matter whether it is present or not. This is illustrated in the example that follows.</source>
          <target state="translated">Обратите внимание, что (3) является историческим артефактом и будет проигнорирован, если (1) и (2) указывают, что подмодуль не активен. Другими словами, если у нас есть &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; набор в &lt;code&gt;false&lt;/code&gt; или если путь Подмодуль исключен в в pathspec в &lt;code&gt;submodule.active&lt;/code&gt; , URL - адрес не имеет значения , является ли он присутствует или нет. Это проиллюстрировано в следующем примере.</target>
        </trans-unit>
        <trans-unit id="6fec9940a0e0728d1bf92151624eb87584d6019f" translate="yes" xml:space="preserve">
          <source>Note that --more, --list, --independent and --merge-base options are mutually exclusive.</source>
          <target state="translated">Обратите внимание,что опции --more,--list,--ependent и --merge-base являются взаимоисключающими.</target>
        </trans-unit>
        <trans-unit id="9b9a74f48dd77c7cda36904d8ae57495c22af6f7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--force&lt;/code&gt; applies to all the refs that are pushed, hence using it with &lt;code&gt;push.default&lt;/code&gt; set to &lt;code&gt;matching&lt;/code&gt; or with multiple push destinations configured with &lt;code&gt;remote.*.push&lt;/code&gt; may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a &lt;code&gt;+&lt;/code&gt; in front of the refspec to push (e.g &lt;code&gt;git push
origin +master&lt;/code&gt; to force a push to the &lt;code&gt;master&lt;/code&gt; branch). See the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section above for details.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;--force&lt;/code&gt; применяется ко всем &lt;code&gt;push.default&lt;/code&gt; , следовательно, используя его с push.default, установленным на &lt;code&gt;matching&lt;/code&gt; или с несколькими назначениями push, настроенными с помощью &lt;code&gt;remote.*.push&lt;/code&gt; может перезаписать ссылки, отличные от текущей ветки (включая локальные ссылки, которые строго за своим удаленным аналогом). Чтобы принудительно отправить только одну ветку, используйте &lt;code&gt;+&lt;/code&gt; перед refspec для push (например, &lt;code&gt;git push origin +master&lt;/code&gt; для принудительной отправки в &lt;code&gt;master&lt;/code&gt; ветку). Подробнее см. Раздел &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="f71426a1d6dfa55d8e5b4bb3bb7ddab1eba41559" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--patch&lt;/code&gt; can accept no pathspec and will prompt to restore all modified paths.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;--patch&lt;/code&gt; не может принимать никакие пути и предложит восстановить все измененные пути.</target>
        </trans-unit>
        <trans-unit id="788dab85e40bdd496cc4b3d8bdc2f5695fd79580" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combined diff&lt;/code&gt; lists only files which were modified from all parents.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;combined diff&lt;/code&gt; список различий перечисляет только файлы, которые были изменены всеми родительскими файлами.</target>
        </trans-unit>
        <trans-unit id="e64bae554ef50a53010f144d204d2601ed2388af" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git --help ...&lt;/code&gt; is identical to &lt;code&gt;git help ...&lt;/code&gt; because the former is internally converted into the latter.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;git --help ...&lt;/code&gt; идентичен &lt;code&gt;git help ...&lt;/code&gt; потому что первое внутренне преобразовано во второе.</target>
        </trans-unit>
        <trans-unit id="0f050e4f28b585b64021f162ba65306d71b16a1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git add&lt;/code&gt; always adds just the current contents of a file to the index; further changes to the same file will be ignored unless you run &lt;code&gt;git add&lt;/code&gt; on the file again.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;git add&lt;/code&gt; всегда добавляет в индекс только текущее содержимое файла; дальнейшие изменения в том же файле будут проигнорированы, если вы снова не запустите &lt;code&gt;git add&lt;/code&gt; для файла.</target>
        </trans-unit>
        <trans-unit id="a75d3b6c972faf4b238fb20e64f0ae5ba4c5e6f0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git diff-tree&lt;/code&gt; can use the tree encapsulated in a commit object.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;git diff-tree&lt;/code&gt; может использовать дерево, инкапсулированное в объект фиксации.</target>
        </trans-unit>
        <trans-unit id="c22023840a6edf8cbd10c5905bf1fe0b2598253c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;trailers&lt;/code&gt; do not follow and are not intended to follow many rules for RFC 822 headers. For example they do not follow the encoding rules and probably many other rules.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;trailers&lt;/code&gt; не следуют и не предназначены для выполнения многих правил для заголовков RFC 822. Например, они не соблюдают правила кодирования и, вероятно, многие другие правила.</target>
        </trans-unit>
        <trans-unit id="99d4b644b5be625d6423f4cb1035eccb3ada0dfe" translate="yes" xml:space="preserve">
          <source>Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.</source>
          <target state="translated">Обратите внимание,что Git на уровне ядра воспринимает имена путей просто как последовательности не нулевых байт,конвертации кодировок имен путей не происходит (за исключением Mac и Windows).Поэтому использование не-ASCII имен путей в основном будет работать даже на платформах и файловых системах,которые используют старые расширенные кодировки ASCII.Однако,репозитории,созданные на таких системах,не будут корректно работать на системах на базе UTF-8 (например,Linux,Mac,Windows)и наоборот.Кроме того,многие инструменты,основанные на Git'е,просто предполагают имена путей в UTF-8 и не будут корректно отображать другие кодировки.</target>
        </trans-unit>
        <trans-unit id="9883f1d7503e774a80aca1b5641976f5b274bd93" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;filerename&lt;/code&gt; is the same as a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt; of the source location. There is a slight performance advantage to using &lt;code&gt;filerename&lt;/code&gt;, but the advantage is so small that it is never worth trying to convert a delete/add pair in source material into a rename for fast-import. This &lt;code&gt;filerename&lt;/code&gt; command is provided just to simplify frontends that already have rename information and don&amp;rsquo;t want bother with decomposing it into a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;filerename&lt;/code&gt; совпадает с &lt;code&gt;filecopy&lt;/code&gt; за которой следует &lt;code&gt;filedelete&lt;/code&gt; исходного местоположения. Использование &lt;code&gt;filerename&lt;/code&gt; дает небольшое преимущество в производительности , но это преимущество настолько мало, что никогда не стоит пытаться преобразовать пару удаления / добавления в исходном материале в переименование для быстрого импорта. Эта команда &lt;code&gt;filerename&lt;/code&gt; предназначена только для упрощения внешних интерфейсов, которые уже имеют информацию о переименовании, и не хотят беспокоиться о ее разложении на &lt;code&gt;filecopy&lt;/code&gt; последующим &lt;code&gt;filedelete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f7296e0d288c1c6e4ca2a5e972f6c90872dfac0" translate="yes" xml:space="preserve">
          <source>Note that a commit does not itself contain any information about what actually changed; all changes are calculated by comparing the contents of the tree referred to by this commit with the trees associated with its parents. In particular, Git does not attempt to record file renames explicitly, though it can identify cases where the existence of the same file data at changing paths suggests a rename. (See, for example, the &lt;code&gt;-M&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;).</source>
          <target state="translated">Обратите внимание, что фиксация сама по себе не содержит никакой информации о том, что на самом деле изменилось; все изменения рассчитываются путем сравнения содержимого дерева, на которое ссылается этот коммит, с деревьями, связанными с его родителями. В частности, Git не пытается явно записывать переименования файлов, хотя может выявить случаи, когда наличие одних и тех же данных файла при изменении путей предполагает переименование. (См., Например, параметр &lt;code&gt;-M&lt;/code&gt; в &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="54977b94f7c8617e07e8f365a31b9faa2fc062c5" translate="yes" xml:space="preserve">
          <source>Note that a more compact instruction does not change offset and size encoding. For example, if only offset2 is omitted like below, offset3 still contains bits 16-23. It does not become offset2 and contains bits 8-15 even if it&amp;rsquo;s right next to offset1.</source>
          <target state="translated">Обратите внимание, что более компактная инструкция не меняет кодировку смещения и размера. Например, если опущено только смещение 2, как показано ниже, смещение 3 все еще содержит биты 16-23. Он не становится смещением2 и содержит биты 8-15, даже если он находится рядом с смещением1.</target>
        </trans-unit>
        <trans-unit id="2599b1548726c0979f146506e9008608bae9db4a" translate="yes" xml:space="preserve">
          <source>Note that a rebase merge works by replaying each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch. Because of this, when a merge conflict happens, the side reported as &lt;code&gt;ours&lt;/code&gt; is the so-far rebased series, starting with &amp;lt;upstream&amp;gt;, and &lt;code&gt;theirs&lt;/code&gt; is the working branch. In other words, the sides are swapped.</source>
          <target state="translated">Обратите внимание, что слияние с перебазированием работает путем воспроизведения каждой фиксации из рабочей ветки поверх ветки &amp;lt;upstream&amp;gt;. Из-за этого, когда происходит конфликт слияния, сторона, о которой сообщается, как &lt;code&gt;ours&lt;/code&gt; является перебазированной на данный момент серией, начиная с &amp;lt;upstream&amp;gt;, а &lt;code&gt;theirs&lt;/code&gt; сторона является рабочей веткой. Другими словами, стороны меняются местами.</target>
        </trans-unit>
        <trans-unit id="8523c23f527cd324df8d4075c34f666be6f6f3b7" translate="yes" xml:space="preserve">
          <source>Note that all forms other than &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.</source>
          <target state="translated">Обратите внимание, что все формы, кроме &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; , которые явно указывают ожидаемое текущее значение ссылки, все еще являются экспериментальными, и их семантика может измениться по мере того, как мы приобретаем опыт работы с этой функцией.</target>
        </trans-unit>
        <trans-unit id="4c01852cae3ff7462ff1404dd165465e299075b3" translate="yes" xml:space="preserve">
          <source>Note that all these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="translated">Обратите внимание, что все эти переменные конфигурации, вероятно, должны быть установлены с &lt;code&gt;--global&lt;/code&gt; флага --global , например, следующим образом:</target>
        </trans-unit>
        <trans-unit id="11bfa085b8a4e40f2da0245c59f1751f600a1ada" translate="yes" xml:space="preserve">
          <source>Note that any of the &lt;code&gt;refs/*&lt;/code&gt; cases above may come either from the &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory or from the &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8.</source>
          <target state="translated">Обратите внимание, что любой из приведенных выше случаев &lt;code&gt;refs/*&lt;/code&gt; может поступать либо из &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; либо из &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; . Хотя кодировка имени ссылки не указана, предпочтительнее UTF-8, поскольку некоторая обработка вывода может принимать имена ссылок в UTF-8.</target>
        </trans-unit>
        <trans-unit id="508d8a380e829238fc278b6ce7f900eddc6afba3" translate="yes" xml:space="preserve">
          <source>Note that any protocol restrictions will be applied to the rewritten URL. If the rewrite changes the URL to use a custom protocol or remote helper, you may need to adjust the &lt;code&gt;protocol.*.allow&lt;/code&gt; config to permit the request. In particular, protocols you expect to use for submodules must be set to &lt;code&gt;always&lt;/code&gt; rather than the default of &lt;code&gt;user&lt;/code&gt;. See the description of &lt;code&gt;protocol.allow&lt;/code&gt; above.</source>
          <target state="translated">Обратите внимание, что любые ограничения протокола будут применены к перезаписанному URL-адресу. Если при переписывании URL-адрес изменяется на использование настраиваемого протокола или удаленного помощника, вам может потребоваться настроить &lt;code&gt;protocol.*.allow&lt;/code&gt; config, чтобы разрешить запрос. В частности, протоколы, которые вы планируете использовать для подмодулей, должны быть установлены &lt;code&gt;always&lt;/code&gt; а не по умолчанию для &lt;code&gt;user&lt;/code&gt; . См. Описание &lt;code&gt;protocol.allow&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="85755e8e95f86917d98f865efeaea006efa16988" translate="yes" xml:space="preserve">
          <source>Note that any tree or blob object can be examined using &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; with the &amp;lt;revision&amp;gt;:&amp;lt;path&amp;gt; syntax. This can sometimes be useful for browsing the contents of a tree that is not currently checked out.</source>
          <target state="translated">Обратите внимание, что любое дерево или большой двоичный объект можно исследовать с помощью &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; с синтаксисом &amp;lt;revision&amp;gt;: &amp;lt;path&amp;gt;. Иногда это может быть полезно для просмотра содержимого дерева, которое в настоящее время не извлечено.</target>
        </trans-unit>
        <trans-unit id="fbb379f0a0fd79434d80db46f9a2b53054c72c7c" translate="yes" xml:space="preserve">
          <source>Note that attributes are by default taken from the &lt;code&gt;.gitattributes&lt;/code&gt; files in the tree that is being archived. If you want to tweak the way the output is generated after the fact (e.g. you committed without adding an appropriate export-ignore in its &lt;code&gt;.gitattributes&lt;/code&gt;), adjust the checked out &lt;code&gt;.gitattributes&lt;/code&gt; file as necessary and use &lt;code&gt;--worktree-attributes&lt;/code&gt; option. Alternatively you can keep necessary attributes that should apply while archiving any tree in your &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file.</source>
          <target state="translated">Обратите внимание, что атрибуты по умолчанию берутся из файлов &lt;code&gt;.gitattributes&lt;/code&gt; в архивируемом дереве. Если вы хотите настроить способ создания вывода постфактум (например, вы совершили &lt;code&gt;.gitattributes&lt;/code&gt; без добавления соответствующего игнорирования экспорта в его .gitattributes ), при необходимости измените &lt;code&gt;.gitattributes&lt;/code&gt; файл .gitattributes и используйте параметр &lt;code&gt;--worktree-attributes&lt;/code&gt; . В качестве альтернативы вы можете сохранить необходимые атрибуты, которые должны применяться при архивировании любого дерева в вашем &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cff58353f0553493321de729107a5ed939f5819e" translate="yes" xml:space="preserve">
          <source>Note that changing the compression level will not automatically recompress all existing objects. You can force recompression by passing the -F option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что изменение уровня сжатия не приведет к автоматическому повторному сжатию всех существующих объектов. Вы можете принудительно выполнить повторное сжатие, передав параметр -F команде &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64e3311b0fc4c31b0c8a5b69594b7b0fffce6672" translate="yes" xml:space="preserve">
          <source>Note that commands that operate on the history of the current branch (e.g. &lt;code&gt;git commit&lt;/code&gt; to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch. Commands that update or inquire information &lt;code&gt;about&lt;/code&gt; the current branch (e.g. &lt;code&gt;git
branch --set-upstream-to&lt;/code&gt; that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state.</source>
          <target state="translated">Обратите внимание, что команды, которые работают с историей текущей ветки (например, &lt;code&gt;git commit&lt;/code&gt; для создания новой истории поверх нее), все еще работают, пока HEAD отключен. Они обновляют HEAD, чтобы указать на верхушку обновленной истории, не затрагивая ни одну ветку. Команды, которые обновляют или запрашивают информацию &lt;code&gt;about&lt;/code&gt; текущей ветке (например, &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; которая устанавливает, с какой веткой удаленного отслеживания интегрируется текущая ветка), очевидно, не работают, поскольку нет (реальной) текущей ветки, которую можно было бы запросить примерно в этом состоянии.</target>
        </trans-unit>
        <trans-unit id="ca37287a6d2fcb3a044758adb2f9a6569545f92f" translate="yes" xml:space="preserve">
          <source>Note that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021097bf28be68716f4d1858bb9538ff20243dc2" translate="yes" xml:space="preserve">
          <source>Note that commits which start empty are kept (unless --no-keep-empty is specified), and commits which are clean cherry-picks (as determined by &lt;code&gt;git log --cherry-mark ...&lt;/code&gt;) are detected and dropped as a preliminary step (unless --reapply-cherry-picks is passed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16e502657efa32285522830eee76fe68f8a2daa" translate="yes" xml:space="preserve">
          <source>Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.</source>
          <target state="translated">Обратите внимание,что,несмотря на название первого режима,цвет используется для подсветки измененных деталей во всех режимах,если он включен.</target>
        </trans-unit>
        <trans-unit id="53b666711e62d15ce074196074eb30f8dac41460" translate="yes" xml:space="preserve">
          <source>Note that diff options passed to the command affect how the primary product of &lt;code&gt;format-patch&lt;/code&gt; is generated, and they are not passed to the underlying &lt;code&gt;range-diff&lt;/code&gt; machinery used to generate the cover-letter material (this may change in the future).</source>
          <target state="translated">Обратите внимание, что параметры diff, передаваемые команде, влияют на то, как генерируется основной продукт &lt;code&gt;format-patch&lt;/code&gt; , и они не передаются в базовый механизм &lt;code&gt;range-diff&lt;/code&gt; , используемый для генерации материала сопроводительного письма (это может измениться в будущем).</target>
        </trans-unit>
        <trans-unit id="e0e05126bbcc50063c2790c39405469ee70a21a8" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped. See the explanation of the same options in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">Обратите внимание , что во время &lt;code&gt;git rebase&lt;/code&gt; и &lt;code&gt;git pull --rebase&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; и &lt;code&gt;theirs&lt;/code&gt; могут появиться местами. Подробнее см. Объяснение тех же параметров в &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1af7aa20d72debc79fb9171e27e72669f87bd742" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped; &lt;code&gt;--ours&lt;/code&gt; gives the version from the branch the changes are rebased onto, while &lt;code&gt;--theirs&lt;/code&gt; gives the version from the branch that holds your work that is being rebased.</source>
          <target state="translated">Обратите внимание , что во время &lt;code&gt;git rebase&lt;/code&gt; и &lt;code&gt;git pull --rebase&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; и &lt;code&gt;theirs&lt;/code&gt; может показаться местами; &lt;code&gt;--ours&lt;/code&gt; дает версию из ветки, на которую выполняется перебазирование изменений, а &lt;code&gt;--theirs&lt;/code&gt; дает версию из ветки, в которой хранится ваша работа, которая перебазируется.</target>
        </trans-unit>
        <trans-unit id="c0c3e4b221eecb8ab2fd8007bde41fbeccbc289b" translate="yes" xml:space="preserve">
          <source>Note that earlier implementation left a broken pair as a separate creation and deletion patches. This was an unnecessary hack and the latest implementation always merges all the broken pairs back into modifications, but the resulting patch output is formatted differently for easier review in case of such a complete rewrite by showing the entire contents of old version prefixed with &lt;code&gt;-&lt;/code&gt;, followed by the entire contents of new version prefixed with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что более ранняя реализация оставляла неработающую пару как отдельные патчи создания и удаления. Это был ненужный взлом, и последняя реализация всегда объединяет все сломанные пары обратно в модификации, но результирующий вывод патча отформатирован по-другому для облегчения просмотра в случае такой полной перезаписи, показывая все содержимое старой версии с префиксом &lt;code&gt;-&lt;/code&gt; , за которым следует всем содержимым новой версии с префиксом &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e94eb3093be7f837a0c2027288d60b6c3b52e2c" translate="yes" xml:space="preserve">
          <source>Note that earlier versions of this command did not complain and produced incorrect results if you gave these options.</source>
          <target state="translated">Обратите внимание,что более ранние версии этой команды не жаловались и давали неверные результаты,если вы давали такие опции.</target>
        </trans-unit>
        <trans-unit id="5d58dd5b84f29e01b510ca03eab20796ad3c7cbe" translate="yes" xml:space="preserve">
          <source>Note that extra commits can be shown to give a meaningful history.</source>
          <target state="translated">Обратите внимание,что дополнительные коммиты могут быть показаны,чтобы дать осмысленную историю.</target>
        </trans-unit>
        <trans-unit id="5d8bcfac8a1a61a9e4be4013c3b0af7c68e4f7e1" translate="yes" xml:space="preserve">
          <source>Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.</source>
          <target state="translated">Обратите внимание,что быстрая переадресация обновлений не создает фиксации слияния и,следовательно,нет способа остановить слияние с помощью --no-commit.Таким образом,если вы хотите гарантировать,что ваше ответвление не будет изменено или обновлено командой слияния,используйте --no-o-ff с помощью команды --no-commit.</target>
        </trans-unit>
        <trans-unit id="f0d1c52e1eb6b4521a19e733ce553d5995206cf5" translate="yes" xml:space="preserve">
          <source>Note that fast-import automatically switches packfiles when the current packfile reaches --max-pack-size, or 4 GiB, whichever limit is smaller. During an automatic packfile switch fast-import does not update the branch refs, tags or marks.</source>
          <target state="translated">Обратите внимание,что быстрый импорт автоматически переключает пакетные файлы,когда текущий пакетный файл достигает размера --max-пакета,или 4 Гб,в зависимости от того,какой из лимитов меньше.Во время автоматического переключения пакетов fast-import не обновляет ссылки на ветки,теги или метки.</target>
        </trans-unit>
        <trans-unit id="6615d1d4a8cbe8f9f5da36594407e26f3b365d70" translate="yes" xml:space="preserve">
          <source>Note that git log starts with the most recent commit and works backwards through the parents; however, since Git history can contain multiple independent lines of development, the particular order that commits are listed in may be somewhat arbitrary.</source>
          <target state="translated">Обратите внимание,что git'овский журнал начинается с самого последнего коммита и работает в обратном порядке через родителей;однако,поскольку история Git'а может содержать несколько независимых строк разработки,то конкретный порядок перечисления коммитов может быть несколько произвольным.</target>
        </trans-unit>
        <trans-unit id="b6e44338fe1bf08aabf78cd81639eb77b1309fea" translate="yes" xml:space="preserve">
          <source>Note that git pull always merges into the current branch, regardless of what else is given on the command line.</source>
          <target state="translated">Обратите внимание,что git pull всегда сливается с текущей веткой,независимо от того,что ещё указано в командной строке.</target>
        </trans-unit>
        <trans-unit id="bcdb8efaa60d12b40472e9e7be3ed7ef20fcfd01" translate="yes" xml:space="preserve">
          <source>Note that git-svn keeps track of the highest revision in which a branch or tag has appeared. If the subset of branches or tags is changed after fetching, then $GIT_DIR/svn/.metadata must be manually edited to remove (or reset) branches-maxRev and/or tags-maxRev as appropriate.</source>
          <target state="translated">Обратите внимание,что git-svn отслеживает наивысшую ревизию,в которой появилось ответвление или метка.Если подмножество веток или тегов изменяется после извлечения,то $GIT_DIR/svn/.metadata должны быть вручную отредактированы,чтобы удалить (или сбросить)ветви-maxRev и/или теги-maxRev соответственно.</target>
        </trans-unit>
        <trans-unit id="9d6b14c8954c11ebf9dc491ca128004d883ac7cd" translate="yes" xml:space="preserve">
          <source>Note that he doesn&amp;rsquo;t need to give the path to Alice&amp;rsquo;s repository; when Bob cloned Alice&amp;rsquo;s repository, Git stored the location of her repository in the repository configuration, and that location is used for pulls:</source>
          <target state="translated">Обратите внимание, что ему не нужно указывать путь к репозиторию Алисы; когда Боб клонировал репозиторий Алисы, Git сохранил местоположение ее репозитория в конфигурации репозитория, и это местоположение используется для извлечения:</target>
        </trans-unit>
        <trans-unit id="d033887586c63461935e98a544790f02b6895719" translate="yes" xml:space="preserve">
          <source>Note that if no extensions are specified in the config file, then &lt;code&gt;core.repositoryformatversion&lt;/code&gt; SHOULD be set to &lt;code&gt;0&lt;/code&gt; (setting it to &lt;code&gt;1&lt;/code&gt; provides no benefit, and makes the repository incompatible with older implementations of git).</source>
          <target state="translated">Обратите внимание: если в конфигурационном файле не указаны расширения, то для &lt;code&gt;core.repositoryformatversion&lt;/code&gt; СЛЕДУЕТ установить значение &lt;code&gt;0&lt;/code&gt; (установка значения &lt;code&gt;1&lt;/code&gt; не дает никаких преимуществ и делает репозиторий несовместимым со старыми реализациями git).</target>
        </trans-unit>
        <trans-unit id="855e515073658cd86a49dd1065464c65266acbcf" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;bidi-import&lt;/code&gt; capability is used the complete batch sequence has to be buffered before starting to send data to fast-import to prevent mixing of commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">Обратите внимание, что если используется возможность &lt;code&gt;bidi-import&lt;/code&gt; перед отправкой данных в быстрый импорт необходимо буферизовать полную последовательность пакетов, чтобы предотвратить смешивание команд и ответов быстрого импорта на вспомогательном вводе.</target>
        </trans-unit>
        <trans-unit id="b689c65aa31e82a2dbc37c89c0ac3187b41716e6" translate="yes" xml:space="preserve">
          <source>Note that if the current branch head was your only reference to a particular point in history, then resetting that branch may leave you with no way to find the history it used to point to; so use this command carefully.</source>
          <target state="translated">Обратите внимание,что если текущий заголовок ответвления был вашей единственной ссылкой на определённую точку в истории,то сброс этого заголовка может не оставить вам возможности найти историю,на которую он указывал;поэтому используйте эту команду внимательно.</target>
        </trans-unit>
        <trans-unit id="e6c226fbc041b7aed3f8d988d110ae660c99fecc" translate="yes" xml:space="preserve">
          <source>Note that if the number of kept packs is more than gc.autoPackLimit, this configuration variable is ignored, all packs except the base pack will be repacked. After this the number of packs should go below gc.autoPackLimit and gc.bigPackThreshold should be respected again.</source>
          <target state="translated">Обратите внимание,что если количество хранимых пакетов больше,чем gc.autoPackLimit,эта конфигурационная переменная игнорируется,все пакеты,кроме базового,будут переупаковываться.После этого количество пакетов должно опуститься ниже gc.autoPackLimit,а gc.bigPackThreshold снова должен соблюдаться.</target>
        </trans-unit>
        <trans-unit id="876a2eaaf30082c69c38a89b274fd268226ca0ba" translate="yes" xml:space="preserve">
          <source>Note that if you also want to skip the first commit of the range you would issue the command:</source>
          <target state="translated">Обратите внимание,что если вы также хотите пропустить первый коммит диапазона,вы должны выпустить команду:</target>
        </trans-unit>
        <trans-unit id="56435425656273c2a6900d84ec2f6b2bfe4a637a" translate="yes" xml:space="preserve">
          <source>Note that if you are verifying a name from an untrusted source, it is wise to use &lt;code&gt;--end-of-options&lt;/code&gt; so that the name argument is not mistaken for another option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24a094d13c9af525346a8eec9bbd2cdea3f73c32" translate="yes" xml:space="preserve">
          <source>Note that in all cases, the editor value will be passed to the shell, so any arguments containing spaces should be appropriately quoted. Additionally, if your editor normally detaches from the terminal when invoked, you should specify it with an argument that makes it not do that, or else Git will not see any changes. An example of a configuration addressing both of these issues on Windows would be the configuration &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt;, which quotes the filename with spaces and specifies the &lt;code&gt;--nofork&lt;/code&gt; option to avoid backgrounding the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102fd7adeeb68915f128c7eebf4ae04f1c363d22" translate="yes" xml:space="preserve">
          <source>Note that in general, Alice would want her local changes committed before initiating this &quot;pull&quot;. If Bob&amp;rsquo;s work conflicts with what Alice did since their histories forked, Alice will use her working tree and the index to resolve conflicts, and existing local changes will interfere with the conflict resolution process (Git will still perform the fetch but will refuse to merge --- Alice will have to get rid of her local changes in some way and pull again when this happens).</source>
          <target state="translated">Обратите внимание, что в целом Алиса хотела бы, чтобы ее локальные изменения были зафиксированы до начала этого &amp;laquo;извлечения&amp;raquo;. Если работа Боба противоречит тому, что делала Алиса с момента разветвления их историй, Алиса будет использовать свое рабочее дерево и индекс для разрешения конфликтов, а существующие локальные изменения будут мешать процессу разрешения конфликтов (Git по-прежнему будет выполнять выборку, но откажется от слияния - - Алисе придется как-то избавиться от своих локальных изменений и вытащить снова, когда это произойдет).</target>
        </trans-unit>
        <trans-unit id="51fccf4fe2d201a349cf25a2b82190079f387e94" translate="yes" xml:space="preserve">
          <source>Note that in older documentation you may see the index called the &quot;current directory cache&quot; or just the &quot;cache&quot;. It has three important properties:</source>
          <target state="translated">Обратите внимание,что в старой документации вы можете увидеть индекс,называемый &quot;кэш текущего каталога&quot; или просто &quot;кэш&quot;.Он имеет три важных свойства:</target>
        </trans-unit>
        <trans-unit id="86ef833f0b802486b88e99a2562a2a2a3eec1f68" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If they exist in &lt;code&gt;$GIT_DIR/config&lt;/code&gt;, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bb6a06b88e89af07ea98fc22445ba64a91b75d" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If you have them in $GIT_DIR/config before, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="translated">Обратите внимание, что в этом файле &lt;code&gt;core.bare&lt;/code&gt; исключение для core.bare и &lt;code&gt;core.worktree&lt;/code&gt; . Если они у вас есть в $ GIT_DIR / config раньше, вы должны переместить их в &lt;code&gt;config.worktree&lt;/code&gt; основного рабочего дерева. Вы также можете воспользоваться этой возможностью, чтобы просмотреть и переместить другую конфигурацию, которую вы не хотите передавать всем рабочим деревьям:</target>
        </trans-unit>
        <trans-unit id="22d9723cd6f0838bff4c15676f064d8d67f92e00" translate="yes" xml:space="preserve">
          <source>Note that increasing this value will increase the memory used on every relevant push that Git does over HTTP or HTTPS, since the entire buffer is allocated regardless of whether or not it is all used. Thus, it&amp;rsquo;s best to leave it at the default unless you are sure you need a different value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62684e2b0c86eaa1fac93a58127ba986d09144a" translate="yes" xml:space="preserve">
          <source>Note that it is currently &lt;strong&gt;always&lt;/strong&gt; an array reference, even if feature doesn&amp;rsquo;t accept any configuration parameters, and 'default' is used only to turn it on or off. In such case you turn feature on by setting this element to &lt;code&gt;[1]&lt;/code&gt;, and torn it off by setting it to &lt;code&gt;[0]&lt;/code&gt;. See also the passage about the &quot;blame&quot; feature in the &quot;Examples&quot; section.</source>
          <target state="translated">Обратите внимание, что в настоящее время это &lt;strong&gt;всегда&lt;/strong&gt; ссылка на массив, даже если функция не принимает никаких параметров конфигурации, а &amp;laquo;по умолчанию&amp;raquo; используется только для ее включения или выключения. В таком случае вы включаете функцию, задав для этого элемента значение &lt;code&gt;[1]&lt;/code&gt; , и отключаете его, задав для него значение &lt;code&gt;[0]&lt;/code&gt; . См. Также отрывок о функции &amp;laquo;обвинения&amp;raquo; в разделе &amp;laquo;Примеры&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c6d71837c5b2acf93d8b7a746fdb13a8f313316a" translate="yes" xml:space="preserve">
          <source>Note that it is possible for refname to not have sha1-new when this hook runs. This can easily occur if another user modifies the ref after it was updated by &lt;code&gt;git-receive-pack&lt;/code&gt;, but before the hook was able to evaluate it. It is recommended that hooks rely on sha1-new rather than the current value of refname.</source>
          <target state="translated">Обратите внимание, что для refname может не быть sha1-new при запуске этой ловушки. Это может легко произойти, если другой пользователь изменит ссылку после ее обновления с помощью &lt;code&gt;git-receive-pack&lt;/code&gt; , но до того, как ловушка сможет ее оценить. Рекомендуется, чтобы хуки полагались на sha1-new, а не на текущее значение refname.</target>
        </trans-unit>
        <trans-unit id="288f25c901caafda3b52f9e96d7bc31178f41bbc" translate="yes" xml:space="preserve">
          <source>Note that merge commits may have more than one parent:</source>
          <target state="translated">Обратите внимание,что коммиты слияния могут иметь более одного родителя:</target>
        </trans-unit>
        <trans-unit id="f7a71f0bea03e654472a727d94dd31231e4320a4" translate="yes" xml:space="preserve">
          <source>Note that multiple helpers may be defined. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details and examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4bd4c01bcc139c9e086b4c697c46e8ed5645dbb" translate="yes" xml:space="preserve">
          <source>Note that namespaces which include a &lt;code&gt;/&lt;/code&gt; will expand to a hierarchy of namespaces; for example, &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt;. This makes paths in &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; behave hierarchically, so that cloning with &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; produces the same result as cloning with &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; and cloning from that repo with &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt;. It also avoids ambiguity with strange namespace paths such as &lt;code&gt;foo/refs/heads/&lt;/code&gt;, which could otherwise generate directory/file conflicts within the &lt;code&gt;refs&lt;/code&gt; directory.</source>
          <target state="translated">Обратите внимание, что пространства имен, которые включают &lt;code&gt;/&lt;/code&gt; , будут расширяться до иерархии пространств имен; например, &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; будет хранить ссылки в &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt; . Это заставляет пути в &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; вести себя иерархически, так что клонирование с &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; дает тот же результат, что и клонирование с &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; и клонирование из этого репо с &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt; . Это также позволяет избежать двусмысленности со странными путями пространства имен, такими как &lt;code&gt;foo/refs/heads/&lt;/code&gt; , которые в противном случае могли бы вызвать конфликты каталогов / файлов в каталоге &lt;code&gt;refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5960cd2f6a18c56540790aa3e8525ad5bfd7623b" translate="yes" xml:space="preserve">
          <source>Note that no attempts whatsoever are made to validate the encoding.</source>
          <target state="translated">Обратите внимание,что для проверки кодировки не предпринимается никаких попыток.</target>
        </trans-unit>
        <trans-unit id="a90bb6c9021795be1cb1c05d155b4badc4462ac4" translate="yes" xml:space="preserve">
          <source>Note that not all diffs can feature all types. For instance, diffs from the index to the working tree can never have Added entries (because the set of paths included in the diff is limited by what is in the index). Similarly, copied and renamed entries cannot appear if detection for those types is disabled.</source>
          <target state="translated">Обратите внимание,что не все различия могут иметь все типы.Например,для отличий от индекса к рабочему дереву никогда не могут быть добавлены записи (так как набор путей,включенных в отличительный признак,ограничен тем,что находится в индексе).Аналогично,скопированные и переименованные записи не могут появиться,если для этих типов отключено обнаружение.</target>
        </trans-unit>
        <trans-unit id="b214bd38041e6a3ecd59f0a8d74547fecd3e66a2" translate="yes" xml:space="preserve">
          <source>Note that omitting the &lt;code&gt;=&lt;/code&gt; in &lt;code&gt;git -c foo.bar ...&lt;/code&gt; is allowed and sets &lt;code&gt;foo.bar&lt;/code&gt; to the boolean true value (just like &lt;code&gt;[foo]bar&lt;/code&gt; would in a config file). Including the equals but with an empty value (like &lt;code&gt;git -c
foo.bar= ...&lt;/code&gt;) sets &lt;code&gt;foo.bar&lt;/code&gt; to the empty string which &lt;code&gt;git config
--type=bool&lt;/code&gt; will convert to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что опускание &lt;code&gt;=&lt;/code&gt; в &lt;code&gt;git -c foo.bar ...&lt;/code&gt; разрешено и устанавливает для &lt;code&gt;foo.bar&lt;/code&gt; логическое истинное значение (точно так же, как &lt;code&gt;[foo]bar&lt;/code&gt; в файле конфигурации). Включение равенства, но с пустым значением (например, &lt;code&gt;git -c foo.bar= ...&lt;/code&gt; ) устанавливает &lt;code&gt;foo.bar&lt;/code&gt; в пустую строку, которую &lt;code&gt;git config --type=bool&lt;/code&gt; преобразует в &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1650f0c21da45bf27c2f0a10dc06aba9ed69b7fe" translate="yes" xml:space="preserve">
          <source>Note that paths and refnames are split into tokens at slash boundaries. The command above would anonymize &lt;code&gt;subdir/secret.c&lt;/code&gt; as something like &lt;code&gt;path123/bar.c&lt;/code&gt;; you could then search for &lt;code&gt;bar.c&lt;/code&gt; in the anonymized repository to determine the final pathname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d893e89ed900e1f0840df95a39350717d32e84c" translate="yes" xml:space="preserve">
          <source>Note that per repository configuration can be set in &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; file, or as values of multi-value &lt;code&gt;gitweb.url&lt;/code&gt; configuration variable in project config. Per-repository configuration takes precedence over value composed from &lt;code&gt;@git_base_url_list&lt;/code&gt; elements and project name.</source>
          <target state="translated">Обратите внимание, что конфигурация репозитория может быть установлена ​​в &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; или как значения &lt;code&gt;gitweb.url&lt;/code&gt; переменной конфигурации gitweb.url в конфигурации проекта. Конфигурация для &lt;code&gt;@git_base_url_list&lt;/code&gt; репозитория имеет приоритет над значением, составленным из элементов @git_base_url_list и имени проекта.</target>
        </trans-unit>
        <trans-unit id="882882a5ca6dfe25f69ac7554d444a260301cac9" translate="yes" xml:space="preserve">
          <source>Note that raising this limit is only effective for disabling chunked transfer encoding and therefore should be used only where the remote server or a proxy only supports HTTP/1.0 or is noncompliant with the HTTP standard. Raising this is not, in general, an effective solution for most push problems, but can increase memory consumption significantly since the entire buffer is allocated even for small pushes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fccadef8ff02c3c7b5e8091c077ff771f4d090ed" translate="yes" xml:space="preserve">
          <source>Note that rule 3 disallows many cases that do not have any privacy implications. These rules are subject to change in future versions of git, and the server accessed by &lt;code&gt;git archive --remote&lt;/code&gt; may or may not follow these exact rules.</source>
          <target state="translated">Обратите внимание, что правило 3 запрещает многие случаи, которые не влияют на конфиденциальность. Эти правила могут быть изменены в будущих версиях git, и сервер, к которому обращается &lt;code&gt;git archive --remote&lt;/code&gt; , может или не может следовать этим точным правилам.</target>
        </trans-unit>
        <trans-unit id="6b2cd45b5672bcfb50850c37a2d3873eae0b00dc" translate="yes" xml:space="preserve">
          <source>Note that running &lt;code&gt;git repack&lt;/code&gt; without the &lt;code&gt;--local&lt;/code&gt; option in a repository cloned with &lt;code&gt;--shared&lt;/code&gt; will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of &lt;code&gt;clone --shared&lt;/code&gt;. It is safe, however, to run &lt;code&gt;git gc&lt;/code&gt;, which uses the &lt;code&gt;--local&lt;/code&gt; option by default.</source>
          <target state="translated">Обратите внимание, что запуск &lt;code&gt;git repack&lt;/code&gt; без параметра &lt;code&gt;--local&lt;/code&gt; в репозитории, клонированном с помощью &lt;code&gt;--shared&lt;/code&gt; , будет копировать объекты из исходного репозитория в пакет в клонированном репозитории, удаляя экономию дискового пространства при использовании &lt;code&gt;clone --shared&lt;/code&gt; . Однако безопасно запускать &lt;code&gt;git gc&lt;/code&gt; , который по умолчанию использует параметр &lt;code&gt;--local&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="140dadc93eb0ab3b9abb37d56f2b3ec8284a753b" translate="yes" xml:space="preserve">
          <source>Note that since this operation is very I/O expensive, it might be a good idea to redirect the temporary directory off-disk with the &lt;code&gt;-d&lt;/code&gt; option, e.g. on tmpfs. Reportedly the speedup is very noticeable.</source>
          <target state="translated">Обратите внимание: поскольку эта операция требует больших затрат на ввод-вывод, было бы неплохо перенаправить временный каталог за пределы диска с помощью опции &lt;code&gt;-d&lt;/code&gt; , например, в tmpfs. Как сообщается, ускорение очень заметно.</target>
        </trans-unit>
        <trans-unit id="406b2d499d377ca290ed5b4924c72cd2cd51a43f" translate="yes" xml:space="preserve">
          <source>Note that some configuration can be controlled on per-repository rather than gitweb-wide basis: see &quot;Per-repository gitweb configuration&quot; subsection on &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; manpage.</source>
          <target state="translated">Обратите внимание, что некоторая конфигурация может контролироваться для каждого репозитория, а не для всего gitweb: см. Подраздел &amp;laquo;Конфигурация gitweb для каждого репозитория&amp;raquo; на &lt;a href=&quot;gitweb&quot;&gt;странице руководства gitweb [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdc2effe725ce03b669fc182e42bedc757b01ae" translate="yes" xml:space="preserve">
          <source>Note that some subcommand (e.g. &lt;code&gt;git grep&lt;/code&gt;) may behave differently when there are things on the command line other than &lt;code&gt;-h&lt;/code&gt;, but &lt;code&gt;git
subcmd -h&lt;/code&gt; without anything else on the command line is meant to consistently give the usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6bdc1118aa11562877a299d06f5353533bbf79" translate="yes" xml:space="preserve">
          <source>Note that specifying a protocol is mandatory and if the URL doesn&amp;rsquo;t specify a hostname (e.g., &quot;cert:///path/to/file&quot;) the credential will contain a hostname attribute whose value is an empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8f5c59efaf04f91fb17771a5f9956f75377d81" translate="yes" xml:space="preserve">
          <source>Note that terminology has changed since that revision. For example, the README in that revision uses the word &quot;changeset&quot; to describe what we now call a &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что после этой редакции терминология изменилась. Например, README в этой версии использует слово &amp;laquo;набор изменений&amp;raquo; для описания того, что мы теперь называем &lt;a href=&quot;#def_commit_object&quot;&gt;фиксацией&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9142b2dfed27b980836bfa3cd8737a30cbbd1e38" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;name&lt;/code&gt; forms of these variables conventionally refer to some form of a personal name. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and the environment variables section of &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for more information on these settings and the &lt;code&gt;credential.username&lt;/code&gt; option if you&amp;rsquo;re looking for authentication credentials instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1162a2144d0b881d5670bbd9b0805334b2b73beb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;t_rel&lt;/code&gt; field contains the observed run time in seconds for the child process (starting before the fork/exec/spawn and stopping after the waitpid() and includes OS process creation overhead). So this time will be slightly larger than the atexit time reported by the child process itself.</source>
          <target state="translated">Обратите внимание, что поле &lt;code&gt;t_rel&lt;/code&gt; содержит наблюдаемое время выполнения в секундах для дочернего процесса (запускается перед fork / exec / spawn и останавливается после waitpid () и включает накладные расходы на создание процесса ОС). Таким образом, это время будет немного больше, чем время atexit, сообщаемое самим дочерним процессом.</target>
        </trans-unit>
        <trans-unit id="b7757b33b688da6e41f6e15271bd961d7647767a" translate="yes" xml:space="preserve">
          <source>Note that the SVN URL of the commiturl config key includes the SVN branch. If you rather want to set the commit URL for an entire SVN repository use svn-remote.&amp;lt;name&amp;gt;.pushurl instead.</source>
          <target state="translated">Обратите внимание, что URL-адрес SVN ключа конфигурации commiturl включает ветвь SVN. Если вы предпочитаете установить URL-адрес фиксации для всего репозитория SVN, используйте вместо этого svn-remote. &amp;lt;name&amp;gt; .pushurl.</target>
        </trans-unit>
        <trans-unit id="cb5d63c2ce1d70a7eb8e0b6357957166a5a229f7" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">Обратите внимание, что в этом примере звездочка &lt;code&gt;*&lt;/code&gt; цитируется в оболочке; это позволяет Git, а не оболочке, расширять пути к файлам и подкаталогам в каталоге &lt;code&gt;Documentation/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce32bdb056375627c69f9422ed26926b9107752d" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets the command include the files from subdirectories of &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">Обратите внимание, что в этом примере звездочка &lt;code&gt;*&lt;/code&gt; цитируется в оболочке; это позволяет команде включать файлы из подкаталогов каталога &lt;code&gt;Documentation/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8938c6c44864ae040ef79f140140b8a3da4caab5" translate="yes" xml:space="preserve">
          <source>Note that the commit message will already be filled in for you with some information about the merge. Normally you can just use this default message unchanged, but you may add additional commentary of your own if desired.</source>
          <target state="translated">Обратите внимание,что сообщение о фиксации уже будет заполнено для вас некоторой информацией о слиянии.Обычно вы можете просто использовать это сообщение по умолчанию без изменений,но при желании вы можете добавить дополнительные комментарии.</target>
        </trans-unit>
        <trans-unit id="131272668a67eaa5ac9294087a9ff4488c82c210" translate="yes" xml:space="preserve">
          <source>Note that the example that we will use is really a toy example, we will be looking for the first commit that has a version like &quot;2.6.26-something&quot;, that is the commit that has a &quot;SUBLEVEL = 26&quot; line in the top level Makefile. This is a toy example because there are better ways to find this commit with Git than using &quot;git bisect&quot; (for example &quot;git blame&quot; or &quot;git log -S&amp;lt;string&amp;gt;&quot;).</source>
          <target state="translated">Обратите внимание, что пример, который мы будем использовать, на самом деле является игрушечным. Мы будем искать первую фиксацию, имеющую версию вроде &amp;laquo;2.6.26-something&amp;raquo;, то есть фиксацию со строкой &amp;laquo;SUBLEVEL = 26&amp;raquo; в Makefile верхнего уровня. Это игрушечный пример, потому что есть более эффективные способы найти эту фиксацию с помощью Git, чем использование &amp;laquo;git bisect&amp;raquo; (например, &amp;laquo;git blame&amp;raquo; или &amp;laquo;git log -S &amp;lt;string&amp;gt;&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="5e386156a3e0996458a30d74f4a22474e7420343" translate="yes" xml:space="preserve">
          <source>Note that the files all have mode 644 or 755: Git actually only pays attention to the executable bit.</source>
          <target state="translated">Обратите внимание,что все файлы имеют режим 644 или 755:Git фактически обращает внимание только на исполняемый бит.</target>
        </trans-unit>
        <trans-unit id="d2e57a867612d1ae307185458bab810ae89e20a5" translate="yes" xml:space="preserve">
          <source>Note that the first word of an alias does not necessarily have to be a command. It can be a command-line option that will be passed into the invocation of &lt;code&gt;git&lt;/code&gt;. In particular, this is useful when used with &lt;code&gt;-c&lt;/code&gt; to pass in one-time configurations or &lt;code&gt;-p&lt;/code&gt; to force pagination. For example, &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; can be defined such that running &lt;code&gt;git loud-rebase&lt;/code&gt; would be equivalent to &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt;. Also, &lt;code&gt;ps = -p status&lt;/code&gt; would be a helpful alias since &lt;code&gt;git ps&lt;/code&gt; would paginate the output of &lt;code&gt;git status&lt;/code&gt; where the original command does not.</source>
          <target state="translated">Обратите внимание, что первое слово псевдонима не обязательно должно быть командой. Это может быть параметр командной строки, который будет передан при вызове &lt;code&gt;git&lt;/code&gt; . В частности, это полезно при использовании с &lt;code&gt;-c&lt;/code&gt; для передачи одноразовых конфигураций или &lt;code&gt;-p&lt;/code&gt; для принудительной разбивки на страницы. Например, &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; может быть определена таким образом, что запуск &lt;code&gt;git loud-rebase&lt;/code&gt; было бы эквивалентно &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt; . Кроме того, &lt;code&gt;ps = -p status&lt;/code&gt; может быть полезным псевдонимом, поскольку &lt;code&gt;git ps&lt;/code&gt; будет разбивать на страницы вывод &lt;code&gt;git status&lt;/code&gt; , где исходная команда этого не делает.</target>
        </trans-unit>
        <trans-unit id="650b87912cfe39dc5747fbba67473a3822f86ab9" translate="yes" xml:space="preserve">
          <source>Note that the form &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; that wants to read from an arbitrary path on the filesystem has been dropped for security reasons.</source>
          <target state="translated">Обратите внимание, что форма &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; , которая хочет читать с произвольного пути в файловой системе, была удалена из соображений безопасности.</target>
        </trans-unit>
        <trans-unit id="d8075e043d9a3ca9826ff1989c66c1905d9648ca" translate="yes" xml:space="preserve">
          <source>Note that the grafts mechanism is outdated and can lead to problems transferring objects between repositories; see &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for a more flexible and robust system to do the same thing.</source>
          <target state="translated">Обратите внимание, что механизм пересадки устарел и может привести к проблемам при переносе объектов между репозиториями; см. &lt;a href=&quot;git-replace&quot;&gt;git-replace [1],&lt;/a&gt; чтобы узнать о более гибкой и надежной системе, делающей то же самое.</target>
        </trans-unit>
        <trans-unit id="0b0bdd8828d416a94597b15ce8aefc2c0b976fde" translate="yes" xml:space="preserve">
          <source>Note that the last point clashes with the other two: a topic that has been merged elsewhere should not be rebased. See the section on RECOVERING FROM UPSTREAM REBASE in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что последний пункт конфликтует с двумя другими: тема, которая была объединена в другом месте, не должна быть перебазирована. См. Раздел ВОССТАНОВЛЕНИЕ ИЗ UPSTREAM REBASE в &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd4901c4d1f08f37f3106399dbc26a76568f48fe" translate="yes" xml:space="preserve">
          <source>Note that the leading character does not have to be a dot; for example, you can use &lt;code&gt;--suffix=-patch&lt;/code&gt; to get &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что ведущий символ не обязательно должен быть точкой; например, вы можете использовать &lt;code&gt;--suffix=-patch&lt;/code&gt; , чтобы получить &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="833f1e85ef857dfcde43c87fdacaaa1075b0d6b3" translate="yes" xml:space="preserve">
          <source>Note that the maintainer(s) may impose restrictions, such as &quot;Signed-off-by&quot; requirements, that all commits/patches submitted for inclusion must adhere to. Consult your project&amp;rsquo;s documentation for more information.</source>
          <target state="translated">Обратите внимание, что сопровождающий может наложить ограничения, такие как требования &amp;laquo;Подписано&amp;raquo;, которым должны соответствовать все коммиты / исправления, представленные для включения. Обратитесь к документации вашего проекта для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="50f092ab1e91fa0de2c9ed05785c4a967888dc6a" translate="yes" xml:space="preserve">
          <source>Note that the name &quot;origin&quot; is just the name that Git uses by default to refer to the repository that you cloned from.</source>
          <target state="translated">Обратите внимание,что имя &quot;origin&quot; (происхождение)-это просто имя,которое Git использует по умолчанию для ссылки на репозиторий,из которого вы клонировали.</target>
        </trans-unit>
        <trans-unit id="22728656f144a546aef50a70cd21a26fce3a8c1d" translate="yes" xml:space="preserve">
          <source>Note that the patch is always used as-is without charset conversion, even with this flag.</source>
          <target state="translated">Обратите внимание,что патч всегда используется as-is без преобразования кодовых таблиц,даже с этим флагом.</target>
        </trans-unit>
        <trans-unit id="9bea9d7e3f1393135579965b1439ff9a7baaf238" translate="yes" xml:space="preserve">
          <source>Note that the push URL and the fetch URL, even though they can be set differently, must still refer to the same place. What you pushed to the push URL should be what you would see if you immediately fetched from the fetch URL. If you are trying to fetch from one place (e.g. your upstream) and push to another (e.g. your publishing repository), use two separate remotes.</source>
          <target state="translated">Обратите внимание,что URL-адрес нажатия и URL-адрес извлечения,даже если они могут быть установлены по-другому,все равно должны относиться к одному и тому же месту.То,что вы нажимаете на URL,должно быть тем,что вы увидите,если сразу же получите URL.Если вы пытаетесь получить URL из одного места (например,из вашего восходящего потока)и переместить его в другое (например,из репозитория вашей публикации),используйте два отдельных пульта дистанционного управления.</target>
        </trans-unit>
        <trans-unit id="f8efe69c6940942131795b6ce6c48d7e64d9560b" translate="yes" xml:space="preserve">
          <source>Note that the reflog history is very different from normal Git history. While normal history is shared by every repository that works on the same project, the reflog history is not shared: it tells you only about how the branches in your local repository have changed over time.</source>
          <target state="translated">Обратите внимание,что история рефлогов сильно отличается от обычной истории Git'а.В то время как обычная история разделяется каждым репозиторием,который работает над одним и тем же проектом,история рефлога не разделяется:она рассказывает только о том,как изменялись ветки в локальном репозитории с течением времени.</target>
        </trans-unit>
        <trans-unit id="9a9c3b4049e20efd5a28033d7014008a8c2ac264" translate="yes" xml:space="preserve">
          <source>Note that the script (&lt;code&gt;my_script&lt;/code&gt; in the above example) should exit with code 0 if the current source code is good/old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad/new.</source>
          <target state="translated">Обратите внимание, что сценарий ( &lt;code&gt;my_script&lt;/code&gt; в приведенном выше примере) должен завершиться с кодом 0, если текущий исходный код хороший / старый, и выйти с кодом от 1 до 127 (включительно), кроме 125, если текущий исходный код плохой / новый.</target>
        </trans-unit>
        <trans-unit id="5586aefc0f8bd69c9dcf3cf3294d72d0db17f0fc" translate="yes" xml:space="preserve">
          <source>Note that the second point is true even across machines. You can duplicate a remote Git repository with &lt;strong&gt;any&lt;/strong&gt; regular copy mechanism, be it &lt;code&gt;scp&lt;/code&gt;, &lt;code&gt;rsync&lt;/code&gt; or &lt;code&gt;wget&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что второй пункт верен даже для компьютеров. Вы можете дублировать удаленный репозиторий Git с помощью &lt;strong&gt;любого&lt;/strong&gt; обычного механизма копирования, будь то &lt;code&gt;scp&lt;/code&gt; , &lt;code&gt;rsync&lt;/code&gt; или &lt;code&gt;wget&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9e6bb5468c99a3a334f80fab3dbb52fc16223c6" translate="yes" xml:space="preserve">
          <source>Note that the session-id of the child process is not available to the current/spawning process, so the child&amp;rsquo;s PID is reported here as a hint for post-processing. (But it is only a hint because the child process may be a shell script which doesn&amp;rsquo;t have a session-id.)</source>
          <target state="translated">Обратите внимание, что идентификатор сеанса дочернего процесса недоступен для текущего / порождающего процесса, поэтому PID дочернего процесса указывается здесь как подсказка для постобработки. (Но это только подсказка, потому что дочерний процесс может быть сценарием оболочки, у которого нет идентификатора сеанса.)</target>
        </trans-unit>
        <trans-unit id="e98f559f39ce7645bbbb14c50cc4f9c4dc239749" translate="yes" xml:space="preserve">
          <source>Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack.</source>
          <target state="translated">Обратите внимание,что размеры объектов на диске сообщаются точно,но следует позаботиться о том,чтобы сделать выводы о том,какие ссылки или объекты отвечают за использование диска.Размер упакованного не дельта-объекта может быть значительно больше,чем размер объектов,дельта которых против него,но выбор того,какой объект является базовым,а какой-дельтой,является произвольным и может изменяться при переупаковке.</target>
        </trans-unit>
        <trans-unit id="47fc7cad6a527b522ab5e266e3e278a07a579735" translate="yes" xml:space="preserve">
          <source>Note that the suffix you get if you type these commands today may be longer than what Linus saw above when he ran these commands, as your Git repository may have new commits whose object names begin with 975b that did not exist back then, and &quot;-g975b&quot; suffix alone may not be sufficient to disambiguate these commits.</source>
          <target state="translated">Обратите внимание,что суффикс,который вы получите,если наберете эти команды сегодня,может быть длиннее,чем Линус видел выше,когда запускал эти команды,поскольку в вашем Git-репозитории могут быть новые коммиты,имена объектов которых начинаются с 975b,не существовавших в то время,а одного суффикса &quot;-g975b&quot; может быть недостаточно для дезактивирования этих коммитов.</target>
        </trans-unit>
        <trans-unit id="7eeba5803dc504042af48f9504a175baa6f39016" translate="yes" xml:space="preserve">
          <source>Note that the target of a &lt;code&gt;push&lt;/code&gt; is normally a &lt;a href=&quot;#def_bare_repository&quot;&gt;bare&lt;/a&gt; repository. You can also push to a repository that has a checked-out working tree, but a push to update the currently checked-out branch is denied by default to prevent confusion. See the description of the receive.denyCurrentBranch option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">Обратите внимание, что целью &lt;code&gt;push&lt;/code&gt; обычно является &lt;a href=&quot;#def_bare_repository&quot;&gt;пустой&lt;/a&gt; репозиторий. Вы также можете отправить в репозиторий, в котором есть извлеченное рабочее дерево, но принудительное обновление текущей извлеченной ветви запрещено по умолчанию, чтобы избежать путаницы. Подробнее см. Описание параметра receive.denyCurrentBranch в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="110e365a18d2e41e53b11ff50c7bbd9d01eae2f0" translate="yes" xml:space="preserve">
          <source>Note that the two techniques outlined above (exporting via &lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt; or &lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt;) allow other maintainers to fetch your latest changes, but they do not allow write access, which you will need to update the public repository with the latest changes created in your private repository.</source>
          <target state="translated">Обратите внимание, что два описанных выше метода (экспорт через &lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt; или &lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt; ) позволяют другим разработчикам получать ваши последние изменения, но они не разрешают доступ на запись, что вам необходимо для обновления общедоступного репозитория с последними изменениями, созданными в вашем частном репозитории.</target>
        </trans-unit>
        <trans-unit id="ae8ea7d3546a16ede3faa6039563fb0d737e4467" translate="yes" xml:space="preserve">
          <source>Note that the version which &lt;code&gt;git bisect&lt;/code&gt; checks out for you at each point is just a suggestion, and you&amp;rsquo;re free to try a different version if you think it would be a good idea. For example, occasionally you may land on a commit that broke something unrelated; run</source>
          <target state="translated">Обратите внимание, что версия, которую &lt;code&gt;git bisect&lt;/code&gt; проверяет для вас на каждом этапе, является просто предложением, и вы можете попробовать другую версию, если считаете, что это будет хорошей идеей. Например, иногда вы можете попасть в коммит, который сломал что-то несвязанное; бегать</target>
        </trans-unit>
        <trans-unit id="1000c60b0f402f5d9e4c69088fd79818a06e5e98" translate="yes" xml:space="preserve">
          <source>Note that there are two ways to checkout a particular branch. As described elsewhere on this page, the &quot;module&quot; parameter of cvs checkout is interpreted as a branch name, and it becomes the main branch. It remains the main branch for a given sandbox even if you temporarily make another branch sticky with cvs update -r. Alternatively, the -r argument can indicate some other branch to actually checkout, even though the module is still the &quot;main&quot; branch. Tradeoffs (as currently implemented): Each new &quot;module&quot; creates a new database on disk with a history for the given module, and after the database is created, operations against that main branch are fast. Or alternatively, -r doesn&amp;rsquo;t take any extra disk space, but may be significantly slower for many operations, like cvs update.</source>
          <target state="translated">Обратите внимание, что есть два способа проверить конкретную ветку. Как описано в другом месте на этой странице, параметр &quot;модуль&quot; cvs checkout интерпретируется как имя ветки, и он становится главной ветвью. Она остается основной веткой для данной песочницы, даже если вы временно закрепите другую ветку с помощью cvs update -r. В качестве альтернативы аргумент -r может указывать на какую-то другую ветвь для фактической проверки, даже если модуль все еще является &amp;laquo;основной&amp;raquo; ветвью. Компромиссы (как сейчас реализовано): каждый новый &amp;laquo;модуль&amp;raquo; создает новую базу данных на диске с историей для данного модуля, и после создания базы данных операции с этой основной ветвью выполняются быстро. Или же -r не занимает лишнего дискового пространства, но может быть значительно медленнее для многих операций, таких как обновление cvs.</target>
        </trans-unit>
        <trans-unit id="4fe39a3f8a6c98b987fad41f0865478fee4d146d" translate="yes" xml:space="preserve">
          <source>Note that these are applied before commit ordering and formatting options, such as &lt;code&gt;--reverse&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что они применяются перед параметрами упорядочивания и форматирования фиксации, такими как &lt;code&gt;--reverse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33723cad0621665104eb7762cf8f60a246a13517" translate="yes" xml:space="preserve">
          <source>Note that these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb8cdc33c08512e4436bbf3b8db5bc9921ae58d" translate="yes" xml:space="preserve">
          <source>Note that this affects all diff-based output types, e.g. those produced by &lt;code&gt;--stat&lt;/code&gt;, etc.</source>
          <target state="translated">Обратите внимание, что это влияет на все типы вывода, основанные на &lt;code&gt;--stat&lt;/code&gt; , например, созданные с помощью --stat и т. Д.</target>
        </trans-unit>
        <trans-unit id="0691624d8498eccd40578875388b7f8bab2a7b6c" translate="yes" xml:space="preserve">
          <source>Note that this applies only to accessing the repository&amp;rsquo;s disk contents directly. An older client which understands only format &lt;code&gt;0&lt;/code&gt; may still connect via &lt;code&gt;git://&lt;/code&gt; to a repository using format &lt;code&gt;1&lt;/code&gt;, as long as the server process understands format &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что это относится только к прямому доступу к содержимому диска репозитория. Более старый клиент, который понимает только формат &lt;code&gt;0&lt;/code&gt; , может по-прежнему подключаться через &lt;code&gt;git://&lt;/code&gt; к репозиторию с использованием формата &lt;code&gt;1&lt;/code&gt; , если серверный процесс понимает формат &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3528bf60e5e55bcec2b34b4efbb66a2e2ad0ca9" translate="yes" xml:space="preserve">
          <source>Note that this assumes that none of the blobs and commit messages referenced by that revision range contains the string &lt;code&gt;refs/heads/master&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что это предполагает, что ни один из BLOB-объектов и сообщений фиксации, на которые ссылается этот диапазон ревизий, не содержит строку &lt;code&gt;refs/heads/master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2c1b09dd03782a35574f4220ce1860b1a59abed" translate="yes" xml:space="preserve">
          <source>Note that this configuration variable is ignored if it is seen in the repository-level config (this is a safety measure against fetching from untrusted repositories).</source>
          <target state="translated">Обратите внимание,что данная конфигурационная переменная игнорируется,если она видна в конфигурации на уровне репозитория (это мера предосторожности от извлечения из недоверенных репозиториев).</target>
        </trans-unit>
        <trans-unit id="8243e24ce26ee48638bea5b267bba5916eee07a8" translate="yes" xml:space="preserve">
          <source>Note that this is currently only implemented for the client side of clones and fetches.</source>
          <target state="translated">Обратите внимание,что в настоящее время это реализовано только для клиентской стороны клонов и фетчеров.</target>
        </trans-unit>
        <trans-unit id="7278e2ca069b871494710e49f702957a299741e8" translate="yes" xml:space="preserve">
          <source>Note that this is the old file data; so the object that Git named in its response to the initial tree was a tree with a snapshot of the directory state that was recorded by the first commit.</source>
          <target state="translated">Обратите внимание,что это данные старого файла;таким образом,объект,названный Git'ом в своём ответе на исходное дерево,представлял собой дерево со снимком состояния каталога,который был записан первым коммитом.</target>
        </trans-unit>
        <trans-unit id="8524e2a4579b70a19e36821a3f8f1b43bac12c4a" translate="yes" xml:space="preserve">
          <source>Note that this list is non-comprehensive and not necessarily complete. For command-specific variables, you will find a more detailed description in the appropriate manual page.</source>
          <target state="translated">Обратите внимание,что этот список не является исчерпывающим и не обязательно полным.Более подробное описание переменных,специфичных для команд,вы найдете на соответствующей странице руководства.</target>
        </trans-unit>
        <trans-unit id="a06dd344c0e0f4252ac8d0d18c1815e7f413d617" translate="yes" xml:space="preserve">
          <source>Note that this may contain embedded LF or CRLF characters that are not escaped, so the event may spill across multiple lines.</source>
          <target state="translated">Обратите внимание,что он может содержать встроенные символы LF или CRLF,которые не экранируются,поэтому событие может пролиться на несколько строк.</target>
        </trans-unit>
        <trans-unit id="954610f540e4dda45ac67b28e742adb370b9dd1c" translate="yes" xml:space="preserve">
          <source>Note that this may mean that multiple Git commits are created for a single SVN revision.</source>
          <target state="translated">Обратите внимание,что это может означать,что для одной ревизии SVN создаётся несколько фиксаций в Git'е.</target>
        </trans-unit>
        <trans-unit id="69a24fcf6b082a94d6b3e16af2197fed496268e4" translate="yes" xml:space="preserve">
          <source>Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and &lt;code&gt;git am&lt;/code&gt; will correctly pick up the in-body header). Note also that &lt;code&gt;git send-email&lt;/code&gt; already handles this transformation for you, and this option should not be used if you are feeding the result to &lt;code&gt;git send-email&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что этот параметр полезен только в том случае, если вы действительно отправляете электронные письма и хотите идентифицировать себя как отправителя, но сохраняете исходного автора (и &lt;code&gt;git am&lt;/code&gt; правильно подберет заголовок в теле). Также обратите внимание, что &lt;code&gt;git send-email&lt;/code&gt; уже выполняет это преобразование за вас, и этот параметр не следует использовать, если вы отправляете результат в &lt;code&gt;git send-email&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0a34c500aa8e9fdf22f16d59ae03a1a8711ff64" translate="yes" xml:space="preserve">
          <source>Note that this option uses the no overlay mode by default (see also &lt;code&gt;--overlay&lt;/code&gt;), and currently doesn&amp;rsquo;t support overlay mode.</source>
          <target state="translated">Обратите внимание, что этот параметр по умолчанию использует режим без наложения (см. Также &lt;code&gt;--overlay&lt;/code&gt; ) и в настоящее время не поддерживает режим наложения.</target>
        </trans-unit>
        <trans-unit id="c4360f69bfd218e96ff125f09b08b60281e46fca" translate="yes" xml:space="preserve">
          <source>Note that this setting should only be set by &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; or &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. Trying to change it after initialization will not work and will produce hard-to-diagnose issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa2cd05420cf442d246cf6450d49e1768c842c" translate="yes" xml:space="preserve">
          <source>Note that this variable is honored even when set in a configuration file in a &quot;.git&quot; subdirectory of a directory and its value differs from the latter directory (e.g. &quot;/path/to/.git/config&quot; has core.worktree set to &quot;/different/path&quot;), which is most likely a misconfiguration. Running Git commands in the &quot;/path/to&quot; directory will still use &quot;/different/path&quot; as the root of the work tree and can cause confusion unless you know what you are doing (e.g. you are creating a read-only snapshot of the same index to a location different from the repository&amp;rsquo;s usual working tree).</source>
          <target state="translated">Обратите внимание, что эта переменная учитывается, даже если она установлена ​​в файле конфигурации в подкаталоге &amp;laquo;.git&amp;raquo; каталога, и ее значение отличается от последнего каталога (например, для &amp;laquo;/path/to/.git/config&amp;raquo; установлено значение core.worktree &quot;/ другой / путь&quot;), что, скорее всего, является неправильной конфигурацией. Запуск команд Git в каталоге &amp;laquo;/ path / to&amp;raquo; по-прежнему будет использовать &amp;laquo;/ different / path&amp;raquo; в качестве корня рабочего дерева и может вызвать путаницу, если вы не знаете, что делаете (например, вы создаете снимок состояния только для чтения тот же индекс в месте, отличном от обычного рабочего дерева репозитория).</target>
        </trans-unit>
        <trans-unit id="f66853802a66e4aff14a38d5843516f4164ff5ba" translate="yes" xml:space="preserve">
          <source>Note that this will create the new branch, but it will not switch the working tree to it; use &quot;git switch &amp;lt;newbranch&amp;gt;&quot; to switch to the new branch.</source>
          <target state="translated">Обратите внимание, что это создаст новую ветвь, но не переключит на нее рабочее дерево; используйте &quot;git switch &amp;lt;newbranch&amp;gt;&quot;, чтобы переключиться на новую ветку.</target>
        </trans-unit>
        <trans-unit id="f6e42ae8cab92e791d65bf753cdda97ba478a01b" translate="yes" xml:space="preserve">
          <source>Note that unless one of &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, or &lt;code&gt;-m&lt;/code&gt; is given, merge commits will never show a diff, even if a diff format like &lt;code&gt;--patch&lt;/code&gt; is selected, nor will they match search options like &lt;code&gt;-S&lt;/code&gt;. The exception is when &lt;code&gt;--first-parent&lt;/code&gt; is in use, in which merges are treated like normal single-parent commits (this can be overridden by providing a combined-diff option or with &lt;code&gt;--no-diff-merges&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c8adea213e6ac01f80c59a6b72ca8bc5d0c4be" translate="yes" xml:space="preserve">
          <source>Note that unreachable, packed objects will remain. If this is not desired, see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что недоступные упакованные объекты останутся. Если это нежелательно, см. &lt;a href=&quot;git-repack&quot;&gt;Git-repack [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c873a19166627d45cbe06c1e92f0fc64675a0f" translate="yes" xml:space="preserve">
          <source>Note that users fetching over dumb protocols will have to fetch the whole new pack in order to get any contained object, no matter how many other objects in that pack they already have locally.</source>
          <target state="translated">Обратите внимание,что пользователи,получающие немые протоколы,должны будут получить весь новый пакет,чтобы получить любой содержащийся в нем объект,независимо от того,сколько других объектов в этом пакете у них уже есть локально.</target>
        </trans-unit>
        <trans-unit id="511b177ad0f4f309a1f22f8d5a0729bb57a27072" translate="yes" xml:space="preserve">
          <source>Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.</source>
          <target state="translated">Обратите внимание,что мы сознательно решили не перекодировать сообщение журнала коммитов при коммите,чтобы заставить UTF-8 на уровне объекта коммита,потому что перекодирование в UTF-8 не обязательно является обратимой операцией.</target>
        </trans-unit>
        <trans-unit id="352feed71993cca2768c0de80ab4efdfef627645" translate="yes" xml:space="preserve">
          <source>Note that we pick a single island for each regex to go into, using &quot;last one wins&quot; ordering (which allows repo-specific config to take precedence over user-wide config, and so forth).</source>
          <target state="translated">Обратите внимание,что мы выбираем один остров для каждого регекса,используя порядок &quot;последний выигрывает&quot; (который позволяет репо-конфигурации иметь приоритет над конфигурацией в масштабе всего пользователя,и т.д.).</target>
        </trans-unit>
        <trans-unit id="0f413678af329d8b352f68927252d8a326f2b212" translate="yes" xml:space="preserve">
          <source>Note that when matching against a tree object, attributes are still obtained from working tree, not from the given tree object.</source>
          <target state="translated">Обратите внимание,что при совпадении с объектом дерева,атрибуты все равно получаются из рабочего дерева,а не из данного объекта дерева.</target>
        </trans-unit>
        <trans-unit id="6f16ff14e66ecdeaed0888755a04ec80e3903de7" translate="yes" xml:space="preserve">
          <source>Note that when providing a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;, you must use &lt;code&gt;--list&lt;/code&gt;; otherwise the command may be interpreted as branch creation.</source>
          <target state="translated">Обратите внимание, что при предоставлении &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; вы должны использовать &lt;code&gt;--list&lt;/code&gt; ; в противном случае команду можно интерпретировать как создание ветки.</target>
        </trans-unit>
        <trans-unit id="2e31fbecbd095ab339f753f545ee8ad3cdcfd7be" translate="yes" xml:space="preserve">
          <source>Note that when you&amp;rsquo;ve moved or copied a Git repository, your Git index file (which caches various information, notably some of the &quot;stat&quot; information for the files involved) will likely need to be refreshed. So after you do a &lt;code&gt;cp -a&lt;/code&gt; to create a new copy, you&amp;rsquo;ll want to do</source>
          <target state="translated">Обратите внимание, что когда вы переместили или скопировали репозиторий Git, ваш индексный файл Git (который кэширует различную информацию, в частности, некоторую &amp;laquo;статистическую&amp;raquo; информацию для задействованных файлов), вероятно, потребуется обновить. Итак, после того, как вы выполните &lt;code&gt;cp -a&lt;/code&gt; для создания новой копии, вы захотите сделать</target>
        </trans-unit>
        <trans-unit id="b6e7add23d70ae9c79a92003e95b0646493f7240" translate="yes" xml:space="preserve">
          <source>Note that without &lt;code&gt;--full-history&lt;/code&gt;, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.</source>
          <target state="translated">Обратите внимание, что без &lt;code&gt;--full-history&lt;/code&gt; это все еще упрощает слияние: если один из родителей - TREESAME, мы следуем только за ним, поэтому другие стороны слияния никогда не проходят.</target>
        </trans-unit>
        <trans-unit id="26c6b6e45f05961054f9762544f517daa6e3a44f" translate="yes" xml:space="preserve">
          <source>Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.</source>
          <target state="translated">Обратите внимание,что без переписывания родителя невозможно говорить об отношениях родитель/ребенок между коммитами,поэтому мы показываем их отключёнными.</target>
        </trans-unit>
        <trans-unit id="40996350a13d178ee15ae3215e9ae292d6702c1c" translate="yes" xml:space="preserve">
          <source>Note that you can get more information on a packfile by calling &lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack[1]&lt;/a&gt;. However, as this command considers only the index file itself, it&amp;rsquo;s both faster and more flexible.</source>
          <target state="translated">Обратите внимание, что вы можете получить больше информации о пак-файле, вызвав &lt;a href=&quot;git-verify-pack&quot;&gt;git-&lt;/a&gt; verify -pack [1] . Однако, поскольку эта команда учитывает только сам индексный файл, она быстрее и гибче.</target>
        </trans-unit>
        <trans-unit id="191247c1388c3f45dfe82bf6b2f0384fea86edc8" translate="yes" xml:space="preserve">
          <source>Note that you cannot generally put &lt;code&gt;git for-each-ref&lt;/code&gt; directly into the config value, as it does not take a repository path as an argument (but you can wrap the command above in a shell script).</source>
          <target state="translated">Обратите внимание, что вы не можете обычно помещать &lt;code&gt;git for-each-ref&lt;/code&gt; непосредственно в значение конфигурации, поскольку он не принимает в качестве аргумента путь к репозиторию (но вы можете заключить приведенную выше команду в сценарий оболочки).</target>
        </trans-unit>
        <trans-unit id="0fb44a035d4df6f6306133b267ae1546e220d2ba" translate="yes" xml:space="preserve">
          <source>Note that you should not do Octopus just because you can. An octopus is a valid thing to do and often makes it easier to view the commit history if you are merging more than two independent changes at the same time. However, if you have merge conflicts with any of the branches you are merging in and need to hand resolve, that is an indication that the development happened in those branches were not independent after all, and you should merge two at a time, documenting how you resolved the conflicts, and the reason why you preferred changes made in one side over the other. Otherwise it would make the project history harder to follow, not easier.</source>
          <target state="translated">Обратите внимание,что вы не должны делать Octopus только потому,что вы можете.Осьминог-это правильная вещь,которая часто облегчает просмотр истории коммитов,если вы объединяете более двух независимых изменений одновременно.Однако,если у вас есть конфликты слияния с любой из ветвей,в которую вы сливаетесь,и вам нужно разрешить их вручную,это говорит о том,что разработка,произошедшая в этих ветвях,все-таки не была независимой,и вы должны сливать по две за раз,документируя то,как вы разрешили конфликты,и причину,по которой вы предпочли,чтобы изменения,сделанные в одной из сторон,были разрешены в другой.Иначе история проекта будет сложнее прослеживаться,а не легче.</target>
        </trans-unit>
        <trans-unit id="482be6a864fbdcc5f9a936e9708b6d9c3eb14ff5" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force the remote update, as in:</source>
          <target state="translated">Обратите внимание на добавление знака &lt;code&gt;+&lt;/code&gt; . В качестве альтернативы вы можете использовать флаг &lt;code&gt;-f&lt;/code&gt; для принудительного удаленного обновления, как в:</target>
        </trans-unit>
        <trans-unit id="c14d9654c43dfc38c5ce0e390578cf211f8eb175" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force updates of all the fetched branches, as in:</source>
          <target state="translated">Обратите внимание на добавление знака &lt;code&gt;+&lt;/code&gt; . В качестве альтернативы вы можете использовать флаг &lt;code&gt;-f&lt;/code&gt; для принудительного обновления всех выбранных веток, как в:</target>
        </trans-unit>
        <trans-unit id="2261964ad436001973909975a060cb501a98c780" translate="yes" xml:space="preserve">
          <source>Note the last point. Do &lt;code&gt;not&lt;/code&gt; use &lt;code&gt;git pull&lt;/code&gt; unless you actually want to merge the remote branch.</source>
          <target state="translated">Обратите внимание на последний момент. Как &lt;code&gt;not&lt;/code&gt; использовать &lt;code&gt;git pull&lt;/code&gt; , если вы на самом деле хотите , чтобы объединить удаленный филиал.</target>
        </trans-unit>
        <trans-unit id="b5d534f9876445dbbed162e13c3b9e1bade912b4" translate="yes" xml:space="preserve">
          <source>Note the major differences in &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, and &lt;code&gt;Q&lt;/code&gt; over &lt;code&gt;--full-history&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание на основные различия в &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; и &lt;code&gt;Q&lt;/code&gt; в &lt;code&gt;--full-history&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="592ed4ba86d62c504859114fd8d03df0827a06fa" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be checked out, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">Обратите внимание на кавычки вокруг &lt;code&gt;*.c&lt;/code&gt; . Файл &lt;code&gt;hello.c&lt;/code&gt; также будет извлечен, даже если его больше нет в рабочем дереве, потому что подстановка файлов используется для сопоставления записей в индексе (а не в рабочем дереве оболочки).</target>
        </trans-unit>
        <trans-unit id="d840183324e7e2c4b1d9b149ae89bf837a67da9c" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be restored, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">Обратите внимание на кавычки вокруг &lt;code&gt;*.c&lt;/code&gt; . Файл &lt;code&gt;hello.c&lt;/code&gt; также будет восстановлен, даже если его больше нет в рабочем дереве, потому что подстановка файлов используется для сопоставления записей в индексе (а не в рабочем дереве оболочки).</target>
        </trans-unit>
        <trans-unit id="86811ec658abf1645177c2f89c78cd1610e7ea04" translate="yes" xml:space="preserve">
          <source>Note what happens to the different &lt;code&gt;git diff-*&lt;/code&gt; versions here. After we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, &lt;code&gt;git diff-files -p&lt;/code&gt; now shows no differences, but &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; still &lt;strong&gt;does&lt;/strong&gt; show that the current state is different from the state we committed. In fact, now &lt;code&gt;git diff-index&lt;/code&gt; shows the same difference whether we use the &lt;code&gt;--cached&lt;/code&gt; flag or not, since now the index is coherent with the working tree.</source>
          <target state="translated">Обратите внимание, что здесь происходит с различными &lt;code&gt;git diff-*&lt;/code&gt; . После того, как мы обновили &lt;code&gt;hello&lt;/code&gt; в индексе, &lt;code&gt;git diff-files -p&lt;/code&gt; Теперь не показывают какие - либо различий, но &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; еще &lt;strong&gt;делает&lt;/strong&gt; показывает , что текущее состояние отличается от состояния мы совершили. Фактически, теперь &lt;code&gt;git diff-index&lt;/code&gt; показывает ту же разницу, используем ли мы флаг &lt;code&gt;--cached&lt;/code&gt; или нет, поскольку теперь индекс согласован с рабочим деревом.</target>
        </trans-unit>
        <trans-unit id="c96f5bf9205aae211cb148d5f8bcf4fb9ebed15b" translate="yes" xml:space="preserve">
          <source>Note, by the way, that lots of commands take a tree as an argument. But as we can see above, a tree can be referred to in many different ways&amp;mdash;​by the SHA-1 name for that tree, by the name of a commit that refers to the tree, by the name of a branch whose head refers to that tree, etc.--and most such commands can accept any of these names.</source>
          <target state="translated">Обратите внимание, кстати, что многие команды принимают в качестве аргумента дерево. Но, как мы видим выше, на дерево можно ссылаться по-разному - по имени SHA-1 для этого дерева, по имени коммита, который ссылается на дерево, по имени ветви, чья голова относится к к этому дереву и т. д. - и большинство таких команд могут принимать любое из этих имен.</target>
        </trans-unit>
        <trans-unit id="ba28d9bd22f696c9f9b774765c5cbeba6fcd1342" translate="yes" xml:space="preserve">
          <source>Note, for the reasons stated above usage of context-free patches is discouraged.</source>
          <target state="translated">Обратите внимание,что по указанным выше причинам использование бесконтекстных патчей не поощряется.</target>
        </trans-unit>
        <trans-unit id="22eddd855ac86c24360d06b5276ff8c7e192d879" translate="yes" xml:space="preserve">
          <source>Note, this safety check does not mean that a checkout will generate a file identical to the original file for a different setting of &lt;code&gt;core.eol&lt;/code&gt; and &lt;code&gt;core.autocrlf&lt;/code&gt;, but only for the current one. For example, a text file with &lt;code&gt;LF&lt;/code&gt; would be accepted with &lt;code&gt;core.eol=lf&lt;/code&gt; and could later be checked out with &lt;code&gt;core.eol=crlf&lt;/code&gt;, in which case the resulting file would contain &lt;code&gt;CRLF&lt;/code&gt;, although the original file contained &lt;code&gt;LF&lt;/code&gt;. However, in both work trees the line endings would be consistent, that is either all &lt;code&gt;LF&lt;/code&gt; or all &lt;code&gt;CRLF&lt;/code&gt;, but never mixed. A file with mixed line endings would be reported by the &lt;code&gt;core.safecrlf&lt;/code&gt; mechanism.</source>
          <target state="translated">Обратите внимание, что эта проверка безопасности не означает, что при оформлении заказа будет создан файл, идентичный исходному, для других настроек &lt;code&gt;core.eol&lt;/code&gt; и &lt;code&gt;core.autocrlf&lt;/code&gt; , но только для текущего. Например, текстовый файл с &lt;code&gt;LF&lt;/code&gt; будет принят с &lt;code&gt;core.eol=lf&lt;/code&gt; и позже может быть извлечен с помощью &lt;code&gt;core.eol=crlf&lt;/code&gt; , и в этом случае результирующий файл будет содержать &lt;code&gt;CRLF&lt;/code&gt; , хотя исходный файл содержал &lt;code&gt;LF&lt;/code&gt; . Однако в обоих рабочих деревьях окончания строк будут согласованными, то есть либо все &lt;code&gt;LF&lt;/code&gt; , либо все &lt;code&gt;CRLF&lt;/code&gt; , но никогда не смешиваются. Файл со смешанными окончаниями строк будет сообщаться &lt;code&gt;core.safecrlf&lt;/code&gt; механизм.</target>
        </trans-unit>
        <trans-unit id="955b317bd13857ee21eddce08c9664927a950a2e" translate="yes" xml:space="preserve">
          <source>Note. A single level of backslashes are eaten by the configuration file parser, so you would need to double the backslashes; the pattern above picks a line that begins with a backslash, and zero or more occurrences of &lt;code&gt;sub&lt;/code&gt; followed by &lt;code&gt;section&lt;/code&gt; followed by open brace, to the end of line.</source>
          <target state="translated">Заметка. Синтаксический анализатор файла конфигурации съедает один уровень обратной косой черты, поэтому вам придется удвоить обратную косую черту; шаблон выше выбирает строку, которая начинается с обратной косой черты, и ноль или более вхождений &lt;code&gt;sub&lt;/code&gt; , за которыми следует &lt;code&gt;section&lt;/code&gt; за которым следует открытая фигурная скобка, до конца строки.</target>
        </trans-unit>
        <trans-unit id="c3a8d5b6840faaf677f5d3f6a79125e45b041b0b" translate="yes" xml:space="preserve">
          <source>Note. When the &quot;-C&quot; option is used with &lt;code&gt;--find-copies-harder&lt;/code&gt; option, &lt;code&gt;git diff-*&lt;/code&gt; commands feed unmodified filepairs to diffcore mechanism as well as modified ones. This lets the copy detector consider unmodified files as copy source candidates at the expense of making it slower. Without &lt;code&gt;--find-copies-harder&lt;/code&gt;, &lt;code&gt;git diff-*&lt;/code&gt; commands can detect copies only if the file that was copied happened to have been modified in the same changeset.</source>
          <target state="translated">Заметка. Когда параметр &quot;-C&quot; используется с параметром &lt;code&gt;--find-copies-harder&lt;/code&gt; , команды &lt;code&gt;git diff-*&lt;/code&gt; передают как неизмененные пары файлов механизму diffcore, так и модифицированные. Это позволяет детектору копирования рассматривать немодифицированные файлы как кандидаты в источники копирования за счет замедления его работы. Без &lt;code&gt;--find-copies-harder&lt;/code&gt; , &lt;code&gt;git diff-*&lt;/code&gt; команды могут обнаружить копии , только если файл , который был скопирован случайно была изменены в том же ревизии.</target>
        </trans-unit>
        <trans-unit id="9ed1ac27dff5378ed96f590f4322050a04cabf6d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;git revert&lt;/code&gt; is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, particularly the &lt;code&gt;--hard&lt;/code&gt; option. If you want to extract specific files as they were in another commit, you should see &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, specifically the &lt;code&gt;--source&lt;/code&gt; option. Take care with these alternatives as both will discard uncommitted changes in your working directory.</source>
          <target state="translated">Примечание: &lt;code&gt;git revert&lt;/code&gt; используется для записи некоторых новых коммитов, чтобы отменить эффект некоторых более ранних коммитов (часто только ошибочных). Если вы хотите отбросить все незафиксированные изменения в вашем рабочем каталоге, вы должны увидеть &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; , особенно параметр &lt;code&gt;--hard&lt;/code&gt; . Если вы хотите извлечь определенные файлы, как они были в другом коммите, вы должны увидеть &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; , особенно параметр &lt;code&gt;--source&lt;/code&gt; . Будьте осторожны с этими альтернативами, так как оба будут отменять незафиксированные изменения в вашем рабочем каталоге.</target>
        </trans-unit>
        <trans-unit id="6007883f602581f1393822506c41cbfbfd02c805" translate="yes" xml:space="preserve">
          <source>Note: A thin pack violates the packed archive format by omitting required objects and is thus unusable by Git without making it self-contained. Use &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; (see &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt;) to restore the self-contained property.</source>
          <target state="translated">Примечание. Тонкий пакет нарушает формат упакованного архива, опуская требуемые объекты, и поэтому Git не может использовать его, не делая его самодостаточным. Используйте &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; (см. &lt;a href=&quot;git-index-pack&quot;&gt;Git-index-pack [1]&lt;/a&gt; ), чтобы восстановить автономное свойство.</target>
        </trans-unit>
        <trans-unit id="1f8f5701942fbb7ebefa9dee3f4f37f4528c7cfd" translate="yes" xml:space="preserve">
          <source>Note: Make sure you quote the result when passing it to &lt;code&gt;eval&lt;/code&gt;. See below for an example.</source>
          <target state="translated">Примечание. Убедитесь, что вы цитируете результат при передаче его в &lt;code&gt;eval&lt;/code&gt; . См. Пример ниже.</target>
        </trans-unit>
        <trans-unit id="b0f0e4e61a2bb004cf3ec68d5169e8ba972a47ee" translate="yes" xml:space="preserve">
          <source>Note: Newer CVS versions (&amp;gt;= 1.12.11) also support specifying CVS_SERVER directly in CVSROOT like</source>
          <target state="translated">Примечание: более новые версии CVS (&amp;gt; = 1.12.11) также поддерживают указание CVS_SERVER непосредственно в CVSROOT, например</target>
        </trans-unit>
        <trans-unit id="b833243d544e1089f2767ea8843cab2eed5526b2" translate="yes" xml:space="preserve">
          <source>Note: Porcelain commands such as &lt;code&gt;git gc&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;), &lt;code&gt;git repack&lt;/code&gt; (see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;) pass this option by default in modern Git when they put objects in your repository into pack files. So does &lt;code&gt;git bundle&lt;/code&gt; (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;) when it creates a bundle.</source>
          <target state="translated">Примечание. Команды Porcelain, такие как &lt;code&gt;git gc&lt;/code&gt; (см. &lt;a href=&quot;git-gc&quot;&gt;Git-gc [1]&lt;/a&gt; ), &lt;code&gt;git repack&lt;/code&gt; (см. &lt;a href=&quot;git-repack&quot;&gt;Git-repack [1]&lt;/a&gt; ), передают этот параметр по умолчанию в современном Git, когда они помещают объекты из вашего репозитория в файлы пакетов. То же &lt;code&gt;git bundle&lt;/code&gt; делает git bundle (см. &lt;a href=&quot;git-bundle&quot;&gt;Git-bundle [1]&lt;/a&gt; ), когда он создает пакет.</target>
        </trans-unit>
        <trans-unit id="7a04bc9af081bc88d648e6675a2308737bd31c23" translate="yes" xml:space="preserve">
          <source>Note: Some inetd servers let you specify the name of the executable independently of the value of argv[0] (i.e. the name the program assumes it was executed with). In this case the correct line in /etc/inetd.conf looks like</source>
          <target state="translated">Замечание:некоторые inetd-серверы позволяют указать имя исполняемого файла независимо от значения параметра argv[0](т.е.имя,с которым программа предполагает,что он был выполнен).В этом случае правильная строка в файле /etc/inetd.conf имеет вид</target>
        </trans-unit>
        <trans-unit id="722ccad077353010f3a3bf5b634c417679782a2c" translate="yes" xml:space="preserve">
          <source>Note: Whenever the clean filter is changed, the repo should be renormalized: $ git add --renormalize .</source>
          <target state="translated">Примечание:Всякий раз,когда изменяется чистый фильтр,репо должно быть перенормировано:$ git добавляет --renormalize .</target>
        </trans-unit>
        <trans-unit id="e979029bca285fbda95b190d7e0a6ad42b034f7b" translate="yes" xml:space="preserve">
          <source>Note: the first command (&lt;code&gt;label onto&lt;/code&gt;) labels the revision onto which the commits are rebased; The name &lt;code&gt;onto&lt;/code&gt; is just a convention, as a nod to the &lt;code&gt;--onto&lt;/code&gt; option.</source>
          <target state="translated">Примечание: первая команда ( &lt;code&gt;label onto&lt;/code&gt; ) помечает ревизию, на которую перебазируются коммиты; Имя &lt;code&gt;onto&lt;/code&gt; - это просто соглашение, как &lt;code&gt;--onto&lt;/code&gt; параметру --onto .</target>
        </trans-unit>
        <trans-unit id="c1bc321618eb470344ec0a0359d287ae90474ae5" translate="yes" xml:space="preserve">
          <source>Note: the following core Perl modules that may be installed with your distribution of Perl are required: MIME::Base64, MIME::QuotedPrint, Net::Domain and Net::SMTP. These additional Perl modules are also required: Authen::SASL and Mail::Address.</source>
          <target state="translated">Примечание:необходимы следующие основные модули Perl,которые могут быть установлены вместе с вашим дистрибутивом Perl:MIME::Base64,MIME::QuotedPrint,Net::Domain и Net::SMTP.Эти дополнительные модули на Perl также необходимы:Authen::SASL и Mail::Address.</target>
        </trans-unit>
        <trans-unit id="9ca0395056bb808a73d2de7297fac7a555e73c25" translate="yes" xml:space="preserve">
          <source>Note: you can specify the default pretty format in the repository configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Примечание: вы можете указать красивый формат по умолчанию в конфигурации репозитория (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="399df4ce8f932f9b96c0fdefbfc88e37bceafef0" translate="yes" xml:space="preserve">
          <source>Note: you need to ensure each user that is going to invoke &lt;code&gt;git-cvsserver&lt;/code&gt; has write access to the log file and to the database (see &lt;a href=&quot;#dbbackend&quot;&gt;Database Backend&lt;/a&gt;. If you want to offer write access over SSH, the users of course also need write access to the Git repository itself.</source>
          <target state="translated">Примечание: вам необходимо убедиться, что каждый пользователь, который собирается вызвать &lt;code&gt;git-cvsserver&lt;/code&gt; , имеет доступ на запись в файл журнала и в базу данных (см. &lt;a href=&quot;#dbbackend&quot;&gt;База данных Backend&lt;/a&gt; . Если вы хотите предложить доступ для записи через SSH, пользователям, конечно, также потребуется доступ для записи. в сам репозиторий Git.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="803fb7d2ab5d83b44291b7856ec7ac09a4ad4990" translate="yes" xml:space="preserve">
          <source>Notes can also be added to patches prepared with &lt;code&gt;git format-patch&lt;/code&gt; by using the &lt;code&gt;--notes&lt;/code&gt; option. Such notes are added as a patch commentary after a three dash separator line.</source>
          <target state="translated">Примечания также могут быть добавлены к исправлениям, подготовленным с помощью &lt;code&gt;git format-patch&lt;/code&gt; , с помощью параметра &lt;code&gt;--notes&lt;/code&gt; . Такие примечания добавляются как комментарий к патчу после разделительной линии из трех тире.</target>
        </trans-unit>
        <trans-unit id="680f18d9848c14869bd7dca451d5f596480f4677" translate="yes" xml:space="preserve">
          <source>Notes merge strategies</source>
          <target state="translated">Стратегии слияния нот</target>
        </trans-unit>
        <trans-unit id="abd4e292c73314f22de94f0e2806350a1ebe4452" translate="yes" xml:space="preserve">
          <source>Notes on frequently confused options</source>
          <target state="translated">Примечания к часто путаным опциям</target>
        </trans-unit>
        <trans-unit id="2ae531e195e6eb05828dc645d74752ea4fda83e4" translate="yes" xml:space="preserve">
          <source>Notes on threads</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aa58376045f00b2abde3758c9ee9232861fade" translate="yes" xml:space="preserve">
          <source>Notes ref to read and manipulate instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. Must be an unabbreviated ref name. This setting can be overridden through the environment and command line.</source>
          <target state="translated">Примечания ссылаются на чтение и манипулирование, а не на &lt;code&gt;refs/notes/commits&lt;/code&gt; . Имя должно быть несокращенным. Этот параметр можно изменить через среду и командную строку.</target>
        </trans-unit>
        <trans-unit id="27c7345a105341e9d7ed2a9f6b06c674d31c0796" translate="yes" xml:space="preserve">
          <source>Notice all types of potential whitespace errors known to Git. The tab width is taken from the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable.</source>
          <target state="translated">Обратите внимание на все типы потенциальных ошибок пробелов, известные Git. Ширина табуляции берется из значения переменной конфигурации &lt;code&gt;core.whitespace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1fa74b0ca5d38d82ab602be416ab241bc186864" translate="yes" xml:space="preserve">
          <source>Notice that regardless of which checkout command we use, &lt;code&gt;HEAD&lt;/code&gt; now refers directly to commit &lt;code&gt;b&lt;/code&gt;. This is known as being in detached &lt;code&gt;HEAD&lt;/code&gt; state. It means simply that &lt;code&gt;HEAD&lt;/code&gt; refers to a specific commit, as opposed to referring to a named branch. Let&amp;rsquo;s see what happens when we create a commit:</source>
          <target state="translated">Обратите внимание, что независимо от того, какую команду checkout мы используем, &lt;code&gt;HEAD&lt;/code&gt; теперь напрямую ссылается на фиксацию &lt;code&gt;b&lt;/code&gt; . Это называется отключенным состоянием &lt;code&gt;HEAD&lt;/code&gt; . Это просто означает, что &lt;code&gt;HEAD&lt;/code&gt; ссылается на конкретный коммит, а не на указанную ветку. Посмотрим, что произойдет, когда мы создадим коммит:</target>
        </trans-unit>
        <trans-unit id="394d5767b4ce0798e4d7b91dc89c97c41a6b7f18" translate="yes" xml:space="preserve">
          <source>Notice that since &lt;code&gt;M&lt;/code&gt; is reachable from &lt;code&gt;R&lt;/code&gt;, the edge from &lt;code&gt;N&lt;/code&gt; to &lt;code&gt;M&lt;/code&gt; was simplified away. However, &lt;code&gt;N&lt;/code&gt; still appears in the history as an important commit because it &quot;pulled&quot; the change &lt;code&gt;R&lt;/code&gt; into the main branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223ae08c12689ce4cda40425ac912a2b7bc15955" translate="yes" xml:space="preserve">
          <source>Notify the helper this is a clone request (i.e. the current repository is guaranteed empty).</source>
          <target state="translated">Сообщите помощнику,что это запрос на клон (т.е.текущий репозиторий гарантированно пуст).</target>
        </trans-unit>
        <trans-unit id="4abfc187ad76ac88063d3dc9dd98a5854ac68fcf" translate="yes" xml:space="preserve">
          <source>Now add the changes to the index that you want to have in the first commit. You can use &lt;code&gt;git add&lt;/code&gt; (possibly interactively) or &lt;code&gt;git gui&lt;/code&gt; (or both) to do that.</source>
          <target state="translated">Теперь добавьте изменения в индекс, которые вы хотите иметь при первом коммите. Для этого вы можете использовать &lt;code&gt;git add&lt;/code&gt; (возможно, в интерактивном режиме) или &lt;code&gt;git gui&lt;/code&gt; (или оба).</target>
        </trans-unit>
        <trans-unit id="f89d262ba51a934099d56714cbb679d531203dd2" translate="yes" xml:space="preserve">
          <source>Now clone the superproject:</source>
          <target state="translated">Теперь клонируй суперпроект:</target>
        </trans-unit>
        <trans-unit id="ba793c9ae00cb4d237b36de220bcaff0d64b7a28" translate="yes" xml:space="preserve">
          <source>Now create the branches in which you are going to work; these start out at the current tip of origin/master branch, and should be set up (using the &lt;code&gt;--track&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;) to merge changes in from Linus by default.</source>
          <target state="translated">Теперь создайте ветки, в которых вы собираетесь работать; они начинаются с текущего конца ветки origin / master и должны быть настроены (с помощью параметра &lt;code&gt;--track&lt;/code&gt; в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; ) для слияния изменений из Linus по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b3aa6a5493fd6ad1a98101f846b1686abf42b2c1" translate="yes" xml:space="preserve">
          <source>Now create the superproject and add all the submodules:</source>
          <target state="translated">Теперь создайте суперпроект и добавьте все субмодули:</target>
        </trans-unit>
        <trans-unit id="aec2ee2ebf7f0a1017c29bcb872a25ae6bf7b23d" translate="yes" xml:space="preserve">
          <source>Now is a good point to take a break to let this information sink in.</source>
          <target state="translated">Хорошее замечание-сделать перерыв,чтобы позволить этой информации погрузиться внутрь.</target>
        </trans-unit>
        <trans-unit id="8125d3bd8f5c390de8746d2ef58ce50b7de72c0b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s suppose that commit J is bad and commit G is good and that we apply the bisection algorithm like it has been previously described.</source>
          <target state="translated">Теперь предположим, что фиксация J - это плохо, а фиксация G - хорошая, и что мы применяем алгоритм деления пополам, как это было описано ранее.</target>
        </trans-unit>
        <trans-unit id="880aeec71bcb81a6f397f1be442543fc2e21cab4" translate="yes" xml:space="preserve">
          <source>Now suppose that Joe wants his middle name initial used, and Jane prefers her family name fully spelled out. A proper &lt;code&gt;.mailmap&lt;/code&gt; file would look like:</source>
          <target state="translated">Теперь предположим, что Джо хочет использовать инициалы своего второго имени, а Джейн предпочитает, чтобы ее фамилия была полностью записана. Правильный файл &lt;code&gt;.mailmap&lt;/code&gt; будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="3e7c06961fbf7a9468c5f87e472b9bdf95e1fa5a" translate="yes" xml:space="preserve">
          <source>Now to apply some patches from the community. Think of a short snappy name for a branch to hold this patch (or related group of patches), and create a new branch from a recent stable tag of Linus&amp;rsquo;s branch. Picking a stable base for your branch will: 1) help you: by avoiding inclusion of unrelated and perhaps lightly tested changes 2) help future bug hunters that use &lt;code&gt;git bisect&lt;/code&gt; to find problems</source>
          <target state="translated">Теперь применим патчи от сообщества. Подумайте о коротком и быстром названии ветки, которая будет содержать этот патч (или связанную группу патчей), и создайте новую ветку из недавнего стабильного тега ветки Линуса. Выбор стабильной базы для вашей ветки: 1) поможет вам: избегая включения несвязанных и, возможно, слегка протестированных изменений 2) поможет будущим охотникам за ошибками, которые используют &lt;code&gt;git bisect&lt;/code&gt; для поиска проблем</target>
        </trans-unit>
        <trans-unit id="31a13e21421ef92e8ef4a0a89bea77231f7d36fb" translate="yes" xml:space="preserve">
          <source>Now use &lt;code&gt;git submodule update&lt;/code&gt; to clone the repositories and check out the commits specified in the superproject:</source>
          <target state="translated">Теперь используйте &lt;code&gt;git submodule update&lt;/code&gt; , чтобы клонировать репозитории и проверить коммиты, указанные в суперпроекте:</target>
        </trans-unit>
        <trans-unit id="93f7a0302cd464e3e88673ccf5b8a8b034507a50" translate="yes" xml:space="preserve">
          <source>Now we are ready to experiment with the merge by hand.</source>
          <target state="translated">Теперь мы готовы экспериментировать со слиянием вручную.</target>
        </trans-unit>
        <trans-unit id="0479e792f6adb8abb7cacffe33ca0f7a5b48ab2f" translate="yes" xml:space="preserve">
          <source>Now we will suppose that there is only one &quot;first bad commit&quot;. This means that all its descendants are &quot;bad&quot; and all the other commits are &quot;good&quot;. And we will suppose that all commits have an equal probability of being good or bad, or of being the first bad commit, so knowing the state of c commits gives always the same amount of information wherever these c commits are on the graph and whatever c is. (So we suppose that these commits being for example on a branch or near a good or a bad commit does not give more or less information).</source>
          <target state="translated">Теперь мы предположим,что есть только один &quot;первый плохой коммит&quot;.Это означает,что все его потомки-&quot;плохие&quot;,а все остальные-&quot;хорошие&quot;.И мы предположим,что все коммиты имеют равную вероятность быть хорошими или плохими,или быть первым плохим коммитом,так что знание состояния коммитов на c дает всегда одинаковое количество информации,где бы эти коммиты на c не находились на графике и что бы там ни было на c.(Таким образом,мы предполагаем,что эти коммиты,например,находятся в ветке или рядом с хорошим или плохим коммитом,не дают больше или меньше информации).</target>
        </trans-unit>
        <trans-unit id="16cb16561e679da512d88420e76326b5c722ec8f" translate="yes" xml:space="preserve">
          <source>Now when the background process runs &lt;code&gt;git fetch origin&lt;/code&gt; the references on &lt;code&gt;origin-push&lt;/code&gt; won&amp;rsquo;t be updated, and thus commands like:</source>
          <target state="translated">Теперь, когда фоновый процесс запускает &lt;code&gt;git fetch origin&lt;/code&gt; , ссылки на &lt;code&gt;origin-push&lt;/code&gt; не будут обновляться, и, следовательно, такие команды, как:</target>
        </trans-unit>
        <trans-unit id="3ecf9739a1d0abf420c43be7ddca1b7fc46c48f7" translate="yes" xml:space="preserve">
          <source>Now you apply the patch(es), run some tests, and commit the change(s). If the patch is a multi-part series, then you should apply each as a separate commit to this branch.</source>
          <target state="translated">Теперь вы применяете патч(ы),выполняете некоторые тесты и фиксируете изменения.Если патч состоит из нескольких частей,то вы должны применить каждую из них как отдельный коммит к этой ветке.</target>
        </trans-unit>
        <trans-unit id="ac8b110d69f8df7d9503ad0a18549a8731f4daf9" translate="yes" xml:space="preserve">
          <source>Now you are wiser, because you know that it happened 940 revisions before v0.99.</source>
          <target state="translated">Теперь ты мудрее,потому что знаешь,что это случилось с 940 ревизиями до v0.99.</target>
        </trans-unit>
        <trans-unit id="54796c29834d872153c55921bf00540d7c6165a5" translate="yes" xml:space="preserve">
          <source>Now you can proceed with the creation of the feature release. Apply a tag to the tip of &lt;code&gt;master&lt;/code&gt; indicating the release version:</source>
          <target state="translated">Теперь вы можете приступить к созданию выпуска функции. Прикрепите к наконечнику &lt;code&gt;master&lt;/code&gt; тег с указанием версии выпуска:</target>
        </trans-unit>
        <trans-unit id="d60447094204d4dec9840c772eacade572f28205" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="translated">Теперь вы знаете, что blob 4b9458b3 отсутствует, и что дерево 2d9263c6 указывает на него. Если бы вы могли найти только один экземпляр этого недостающего объекта BLOB, возможно , в каком - то другом хранилище, вы можете переместить его в &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; и будет сделано. Предположим, вы не можете. Вы все еще можете изучить дерево, которое указывало на него, с помощью &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt; , который может вывести что-то вроде:</target>
        </trans-unit>
        <trans-unit id="27bdc85bfa21b19b41e38ad33e104e7c138a6d4d" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3...&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93b9bdc902ddf8466cfefc51dc1f28429545152" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ve split out many of the changes into their own commits, and might no longer use the patch mode of &lt;code&gt;git add&lt;/code&gt;, in order to select all remaining uncommitted changes.</source>
          <target state="translated">Теперь вы разделили многие изменения на отдельные коммиты и, возможно, больше не можете использовать режим исправления &lt;code&gt;git add&lt;/code&gt; , чтобы выбрать все оставшиеся незафиксированные изменения.</target>
        </trans-unit>
        <trans-unit id="69b6ae43249b3d4c8e61d7b20084413cd49e5e3e" translate="yes" xml:space="preserve">
          <source>Now, for the meat:</source>
          <target state="translated">А теперь,за мясо:</target>
        </trans-unit>
        <trans-unit id="4449e60d3fdd6703a4970ef116187e4c17d80dc4" translate="yes" xml:space="preserve">
          <source>Now, in this case we&amp;rsquo;ve intentionally created a situation where the merge will need to be fixed up by hand, though, so Git will do as much of it as it can automatically (which in this case is just merge the &lt;code&gt;example&lt;/code&gt; file, which had no differences in the &lt;code&gt;mybranch&lt;/code&gt; branch), and say:</source>
          <target state="translated">Теперь, в этом случае мы намеренно создали ситуацию, когда слияние нужно будет исправить вручную, поэтому Git будет делать столько, сколько может автоматически (что в данном случае просто слияние файла &lt;code&gt;example&lt;/code&gt; , который не имел различий в ветви &lt;code&gt;mybranch&lt;/code&gt; ), и скажем:</target>
        </trans-unit>
        <trans-unit id="93036e7630aadf8fab80b9b1079ffb3d1ea1e18f" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s pretend you are the one who did all the work in &lt;code&gt;mybranch&lt;/code&gt;, and the fruit of your hard work has finally been merged to the &lt;code&gt;master&lt;/code&gt; branch. Let&amp;rsquo;s go back to &lt;code&gt;mybranch&lt;/code&gt;, and run &lt;code&gt;git merge&lt;/code&gt; to get the &quot;upstream changes&quot; back to your branch.</source>
          <target state="translated">А теперь давайте представим, что вы - тот, кто проделал всю работу в &lt;code&gt;mybranch&lt;/code&gt; , и плод вашей тяжелой работы, наконец, был объединен с &lt;code&gt;master&lt;/code&gt; веткой. Вернемся к &lt;code&gt;mybranch&lt;/code&gt; и запустим &lt;code&gt;git merge&lt;/code&gt; , чтобы вернуть &amp;laquo; исходящие изменения&amp;raquo; в вашу ветку.</target>
        </trans-unit>
        <trans-unit id="7c23965b9cba90dec960d959f0eea85b60ea2b28" translate="yes" xml:space="preserve">
          <source>Now, since we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, we can commit the new version. We could do it by writing the tree by hand again, and committing the tree (this time we&amp;rsquo;d have to use the &lt;code&gt;-p HEAD&lt;/code&gt; flag to tell commit that the HEAD was the &lt;strong&gt;parent&lt;/strong&gt; of the new commit, and that this wasn&amp;rsquo;t an initial commit any more), but you&amp;rsquo;ve done that once already, so let&amp;rsquo;s just use the helpful script this time:</source>
          <target state="translated">Теперь, когда мы обновили &lt;code&gt;hello&lt;/code&gt; в индексе, мы можем зафиксировать новую версию. Мы могли бы сделать это, снова написав дерево вручную и зафиксировав дерево (на этот раз нам нужно было бы использовать флаг &lt;code&gt;-p HEAD&lt;/code&gt; , чтобы сообщить коммиту, что HEAD был &lt;strong&gt;родительским&lt;/strong&gt; для нового коммита, а это не начальная фиксация больше), но вы уже сделали это один раз, поэтому на этот раз давайте просто воспользуемся полезным скриптом:</target>
        </trans-unit>
        <trans-unit id="dfab069f398c1bff7a8b8aa3dadd95d2ce84088a" translate="yes" xml:space="preserve">
          <source>Now, to make it a bit more interesting, let&amp;rsquo;s assume that somebody else does some work in the original branch, and simulate that by going back to the master branch, and editing the same file differently there:</source>
          <target state="translated">Теперь, чтобы сделать его немного интереснее, давайте предположим, что кто-то другой выполняет некоторую работу в исходной ветке, и смоделируем это, вернувшись в главную ветку и отредактировав тот же файл по-другому:</target>
        </trans-unit>
        <trans-unit id="83bf1df5f5028baeb9804ff8b012e2bfb43363e7" translate="yes" xml:space="preserve">
          <source>Now, we want to go to the next stage in Git, which is to take the files that Git knows about in the index, and commit them as a real tree. We do that in two phases: creating a &lt;code&gt;tree&lt;/code&gt; object, and committing that &lt;code&gt;tree&lt;/code&gt; object as a &lt;code&gt;commit&lt;/code&gt; object together with an explanation of what the tree was all about, along with information of how we came to that state.</source>
          <target state="translated">Теперь мы хотим перейти к следующему этапу в Git, который должен взять файлы, о которых знает Git, в индекс и зафиксировать их как реальное дерево. Мы делаем это в два этапа: создаем объект- &lt;code&gt;tree&lt;/code&gt; и фиксируем этот объект- &lt;code&gt;tree&lt;/code&gt; как объект &lt;code&gt;commit&lt;/code&gt; вместе с объяснением того, что такое дерево, вместе с информацией о том, как мы пришли к этому состоянию.</target>
        </trans-unit>
        <trans-unit id="4b50314ab323fb71cb3292dbd2b0326c17673414" translate="yes" xml:space="preserve">
          <source>Now, you will get the rewritten history saved in HEAD.</source>
          <target state="translated">Теперь вы получите переписанную историю,сохраненную в HEAD.</target>
        </trans-unit>
        <trans-unit id="575836ebc8e262c11aa86a9dd4e0c52f7d072bcd" translate="yes" xml:space="preserve">
          <source>Now, you&amp;rsquo;ve got two branches, and you decide that you want to merge the work done. Before we do that, let&amp;rsquo;s introduce a cool graphical tool that helps you view what&amp;rsquo;s going on:</source>
          <target state="translated">Теперь у вас есть две ветки, и вы решаете объединить проделанную работу. Прежде чем мы это сделаем, давайте представим отличный графический инструмент, который поможет вам увидеть, что происходит:</target>
        </trans-unit>
        <trans-unit id="910f1e558e60364937a941e26d7def6b701f836e" translate="yes" xml:space="preserve">
          <source>Nowadays though gitweb should create HTML base tag when needed (to set base URI for relative links), so it should work automatically.</source>
          <target state="translated">В настоящее время,хотя gitweb при необходимости должен создавать базовый тег HTML (для установки базового URI для относительных ссылок),он должен работать автоматически.</target>
        </trans-unit>
        <trans-unit id="9a11d4479b92e7b2c9a9fc979b41f6f7eb2a1edf" translate="yes" xml:space="preserve">
          <source>Nowadays, &lt;code&gt;git log&lt;/code&gt; is a builtin, which means that it is &lt;code&gt;contained&lt;/code&gt; in the command &lt;code&gt;git&lt;/code&gt;. The source side of a builtin is</source>
          <target state="translated">В настоящее время &lt;code&gt;git log&lt;/code&gt; является встроенным, что означает, что он &lt;code&gt;contained&lt;/code&gt; в команде &lt;code&gt;git&lt;/code&gt; . Исходная сторона встроенной функции</target>
        </trans-unit>
        <trans-unit id="33e31083ab9551e7141ee8a3ee7a0a4d045c20a2" translate="yes" xml:space="preserve">
          <source>Number of bytes of a pack file to map into memory in a single mapping operation. Larger window sizes may allow your system to process a smaller number of large pack files more quickly. Smaller window sizes will negatively affect performance due to increased calls to the operating system&amp;rsquo;s memory manager, but may improve performance when accessing a large number of large pack files.</source>
          <target state="translated">Количество байтов файла пакета, отображаемого в память за одну операцию отображения. Большие размеры окна могут позволить вашей системе быстрее обрабатывать меньшее количество больших файлов пакетов. Меньшие размеры окна будут отрицательно влиять на производительность из-за увеличения количества обращений к диспетчеру памяти операционной системы, но могут улучшить производительность при доступе к большому количеству файлов больших пакетов.</target>
        </trans-unit>
        <trans-unit id="782270330831f0728fbf1b39424dcd7ac04c3bcf" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), 8 threads are used by default (for now).</source>
          <target state="translated">Количество рабочих резьбовых прокладок для смазки.При неустановке (или установке в 0)по умолчанию (на данный момент)используется 8 потоков.</target>
        </trans-unit>
        <trans-unit id="07386a7e3f4686f698d276d122f56af1a564e2f6" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), Git will use as many threads as the number of logical cores available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f7cd4c72eff1cd06e6ea960c75592f7883408d" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt; for more information.</source>
          <target state="translated">Количество используемых рабочих потоков grep. См. &lt;code&gt;grep.threads&lt;/code&gt; в &lt;a href=&quot;git-grep&quot;&gt;git-grep [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="340883bf973e4a0a0a15928c3b44200ef6d0edac" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;code&gt;CONFIGURATION&lt;/code&gt; for more information.</source>
          <target state="translated">Количество используемых рабочих потоков grep. См. &lt;code&gt;grep.threads&lt;/code&gt; в &lt;code&gt;CONFIGURATION&lt;/code&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="4a06461d5cac364fcad71d6e428b30d7321d874b" translate="yes" xml:space="preserve">
          <source>Number of messages to be sent per connection, after that a relogin will happen. If the value is 0 or undefined, send all messages in one connection. See also the &lt;code&gt;--batch-size&lt;/code&gt; option of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">Количество сообщений, отправляемых за одно соединение, после чего произойдет повторный вход. Если значение равно 0 или не определено, отправляйте все сообщения в одном соединении. См. Также параметр &lt;code&gt;--batch-size&lt;/code&gt; в &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="263d5a12c4d7938e6b1945ed2d424a531e8ffd37" translate="yes" xml:space="preserve">
          <source>Number of parallel children to be used for all forms of fetching.</source>
          <target state="translated">Количество параллельных детей,которые будут использоваться для всех форм забора.</target>
        </trans-unit>
        <trans-unit id="5f124a70076360d6cdb202a3452dac6608d9c87a" translate="yes" xml:space="preserve">
          <source>Number of seconds to cache credentials (default: 900).</source>
          <target state="translated">Количество секунд для кэширования учетных данных (по умолчанию:900).</target>
        </trans-unit>
        <trans-unit id="0600a433ee142590b5ed0795ec15517899403cc1" translate="yes" xml:space="preserve">
          <source>OBJ_BLOB (3)</source>
          <target state="translated">OBJ_BLOB (3)</target>
        </trans-unit>
        <trans-unit id="20a9deedd57091e656a9ceb8afe723fea4c8ae28" translate="yes" xml:space="preserve">
          <source>OBJ_COMMIT (1)</source>
          <target state="translated">OBJ_COMMIT (1)</target>
        </trans-unit>
        <trans-unit id="33b36795cfe9033fd325f2c4f57ccf4bbcdb1c8c" translate="yes" xml:space="preserve">
          <source>OBJ_OFS_DELTA (6)</source>
          <target state="translated">OBJ_OFS_DELTA (6)</target>
        </trans-unit>
        <trans-unit id="ad63d6a2f7a5f774df4b60dc52ffc40dc66ab330" translate="yes" xml:space="preserve">
          <source>OBJ_REF_DELTA (7)</source>
          <target state="translated">OBJ_REF_DELTA (7)</target>
        </trans-unit>
        <trans-unit id="bf0dce0da3b6ff387e755df6e790a1cac5898dd7" translate="yes" xml:space="preserve">
          <source>OBJ_TAG (4)</source>
          <target state="translated">OBJ_TAG (4)</target>
        </trans-unit>
        <trans-unit id="2f77abc6705f39815a181a261b98c26e748660a6" translate="yes" xml:space="preserve">
          <source>OBJ_TREE (2)</source>
          <target state="translated">OBJ_TREE (2)</target>
        </trans-unit>
        <trans-unit id="bcb75e6bd3e418ec921606a22f47e84ce889c09d" translate="yes" xml:space="preserve">
          <source>OK, still with me? To give us an example to look at, let&amp;rsquo;s go back to the earlier repository with &quot;hello&quot; and &quot;example&quot; file, and bring ourselves back to the pre-merge state:</source>
          <target state="translated">Хорошо, все еще со мной? Чтобы дать нам пример для рассмотрения, давайте вернемся в предыдущий репозиторий с файлом &amp;laquo;hello&amp;raquo; и &amp;laquo;example&amp;raquo; и вернемся в состояние до слияния:</target>
        </trans-unit>
        <trans-unit id="6477da6d91ea639e6e30c40f69d7500177d55603" translate="yes" xml:space="preserve">
          <source>OK, this all sounds like a collection of totally nonsensical rules, but it&amp;rsquo;s actually exactly what you want in order to do a fast merge. The different stages represent the &quot;result tree&quot; (stage 0, aka &quot;merged&quot;), the original tree (stage 1, aka &quot;orig&quot;), and the two trees you are trying to merge (stage 2 and 3 respectively).</source>
          <target state="translated">Хорошо, все это звучит как набор совершенно бессмысленных правил, но на самом деле это именно то, что вам нужно для быстрого слияния. Различные этапы представляют собой &amp;laquo;результирующее дерево&amp;raquo; (этап 0, также известное как &amp;laquo;объединенное&amp;raquo;), исходное дерево (этап 1, также известное как &amp;laquo;ориг&amp;raquo;) и два дерева, которые вы пытаетесь объединить (этап 2 и 3 соответственно).</target>
        </trans-unit>
        <trans-unit id="30c34ea4528b5e99d721b2ada273c08402f70a1d" translate="yes" xml:space="preserve">
          <source>Object Traversal</source>
          <target state="translated">Обход объекта</target>
        </trans-unit>
        <trans-unit id="e07348665c9e3f452362a58c36e1f55665279269" translate="yes" xml:space="preserve">
          <source>Object access and manipulation</source>
          <target state="translated">Доступ к объекту и манипуляции с ним</target>
        </trans-unit>
        <trans-unit id="d963c54afefdbe29bbc1f0380d42869afd8a753b" translate="yes" xml:space="preserve">
          <source>Object size identified by &amp;lt;object&amp;gt; is given in bytes, and right-justified with minimum width of 7 characters. Object size is given only for blobs (file) entries; for other entries &lt;code&gt;-&lt;/code&gt; character is used in place of size.</source>
          <target state="translated">Размер объекта, определяемый &amp;lt;object&amp;gt;, указывается в байтах и ​​выравнивается по правому краю с минимальной шириной 7 символов. Размер объекта указан только для записей blobs (file); для других записей &lt;code&gt;-&lt;/code&gt; вместо размера используется символ.</target>
        </trans-unit>
        <trans-unit id="5a755e02f9fddc8d9863cff303858fc5c0963f4b" translate="yes" xml:space="preserve">
          <source>Object storage format</source>
          <target state="translated">Формат хранения объекта</target>
        </trans-unit>
        <trans-unit id="4410a56144704dcadb0adeabc1f66b086332a778" translate="yes" xml:space="preserve">
          <source>Object store associated with this repository. Usually an object store is self sufficient (i.e. all the objects that are referred to by an object found in it are also found in it), but there are a few ways to violate it.</source>
          <target state="translated">Хранилище объектов,связанное с этим хранилищем.Обычно хранилище объектов является самодостаточным (т.е.все объекты,на которые ссылается найденный в нем объект,также находятся в нем),но есть несколько способов его нарушить.</target>
        </trans-unit>
        <trans-unit id="66c888d10ab6a46198fcec7325df97ad7688050e" translate="yes" xml:space="preserve">
          <source>Object types</source>
          <target state="translated">Типы объектов</target>
        </trans-unit>
        <trans-unit id="397880af9235fafbc028a684c78f613458679a72" translate="yes" xml:space="preserve">
          <source>Objects that already exist in the repository will &lt;strong&gt;not&lt;/strong&gt; be unpacked from the packfile. Therefore, nothing will be unpacked if you use this command on a packfile that exists within the target repository.</source>
          <target state="translated">Объекты, которые уже существуют в репозитории, &lt;strong&gt;не&lt;/strong&gt; будут распакованы из файла пакета. Следовательно, ничего не будет распаковано, если вы воспользуетесь этой командой для файла пакета, который существует в целевом репозитории.</target>
        </trans-unit>
        <trans-unit id="f90e1faea66f4ee07afc15b9cfbe6b37aebe1076" translate="yes" xml:space="preserve">
          <source>Objects unreachable from the refs in packs named with --unpacked= option are added to the resulting pack, in addition to the reachable objects that are not in packs marked with *.keep files. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">Объекты, недоступные из ссылок в пакетах, названных с параметром --unpacked =, добавляются в результирующий пакет в дополнение к достижимым объектам, которые не находятся в пакетах, помеченных * .keep файлами. Это означает &lt;code&gt;--revs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b47085e458e48bb4b0605ca6d2f6a3cc7755c2" translate="yes" xml:space="preserve">
          <source>Obsolete for: &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Устарело для: &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d42a49317326d6b79f20beebf76935d065ccac7f" translate="yes" xml:space="preserve">
          <source>Obviously, endless variations are possible; for example, to see all commits reachable from some head but not from any tag in the repository:</source>
          <target state="translated">Очевидно,что возможны бесконечные вариации;например,видеть все коммиты,доступные из какой-то головы,но не из любой метки в репозитории:</target>
        </trans-unit>
        <trans-unit id="80e98962116f1f595b28a3f430e4b1f9c4dbde82" translate="yes" xml:space="preserve">
          <source>Occasionally, the maintainer may get merge conflicts when they try to pull changes from downstream. In this case, they can ask downstream to do the merge and resolve the conflicts themselves (perhaps they will know better how to resolve them). It is one of the rare cases where downstream &lt;code&gt;should&lt;/code&gt; merge from upstream.</source>
          <target state="translated">Иногда у сопровождающего могут возникать конфликты слияния, когда он пытается получить изменения из нижестоящего потока. В этом случае они могут попросить нижестоящую часть выполнить слияние и разрешить конфликты самостоятельно (возможно, они лучше знают, как их разрешать). Это один из редких случаев, когда нисходящий поток &lt;code&gt;should&lt;/code&gt; объединяться с восходящим.</target>
        </trans-unit>
        <trans-unit id="7c4df738049a7589e8637595f08e890f6ad9d98e" translate="yes" xml:space="preserve">
          <source>Of course some kind of software is developed, then used during some time without being improved on much, and then finally thrown away. In this case, of course, regressions may not be a big problem. But on the other hand, there is a lot of big software that is continually developed and maintained during years or even tens of years by a lot of people. And as there are often many people who depend (sometimes critically) on such software, regressions are a really big problem.</source>
          <target state="translated">Конечно,какое-то программное обеспечение разрабатывается,затем используется в течение некоторого времени без особых улучшений,а затем окончательно выбрасывается.В этом случае,конечно,регрессии могут не представлять большой проблемы.Но с другой стороны,есть много большого программного обеспечения,которое постоянно разрабатывается и поддерживается в течение многих лет или даже десятков лет многими людьми.И так как часто многие люди зависят (иногда критически)от такого программного обеспечения,регрессии-это действительно большая проблема.</target>
        </trans-unit>
        <trans-unit id="19fce424b8331b64c65b8a6acafb03304b015bfc" translate="yes" xml:space="preserve">
          <source>Of course the &quot;bad&quot; commit cannot be an ancestor of a &quot;good&quot; commit, because the ancestors of the good commits are supposed to be &quot;good&quot;. And all the &quot;good&quot; commits must be related to the bad commit. They cannot be on a branch that has no link with the branch of the &quot;bad&quot; commit. But it is possible for a good commit to be related to a bad commit and yet not be neither one of its ancestor nor one of its descendants.</source>
          <target state="translated">Конечно,&quot;плохой&quot; коммит не может быть предком &quot;хорошего&quot; коммита,потому что предки хороших коммитов должны быть &quot;хорошими&quot;.И все &quot;хорошие&quot; коммиты должны быть связаны с плохим коммитом.Они не могут находиться на ветке,не имеющей связи с веткой &quot;плохого&quot; коммита.Однако хороший коммит может быть связан с плохим коммитом и при этом не быть ни одним из его предков,ни одним из его потомков.</target>
        </trans-unit>
        <trans-unit id="7c78c10d5c75907a546f96553e9802bb23f4c982" translate="yes" xml:space="preserve">
          <source>Of course, there may be more than one answer&amp;mdash;​if the history branched after commit e05db0fd, then there could be multiple &quot;earliest&quot; tagged releases.</source>
          <target state="translated">Конечно, ответов может быть несколько - если история разветвляется после коммита e05db0fd, то может быть несколько &amp;laquo;самых ранних&amp;raquo; помеченных релизов.</target>
        </trans-unit>
        <trans-unit id="bc73231ef0df798acd7604c5e90f5ea460992bab" translate="yes" xml:space="preserve">
          <source>Often people use &lt;code&gt;git pull&lt;/code&gt; without giving any parameter. Traditionally, this has been equivalent to saying &lt;code&gt;git pull
origin&lt;/code&gt;. However, when configuration &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; is present while on branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, that value is used instead of &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">Часто люди используют &lt;code&gt;git pull&lt;/code&gt; без указания каких-либо параметров. Традиционно это было эквивалентно запросу &lt;code&gt;git pull origin&lt;/code&gt; . Однако, когда конфигурация &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; присутствует в ветке &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; , это значение используется вместо &lt;code&gt;origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="813c6a487fc92be3bf23c6677bbfade25d37be89" translate="yes" xml:space="preserve">
          <source>Often the current branch head is an ancestor of the named commit. This is the most common case especially when invoked from &lt;code&gt;git pull&lt;/code&gt;: you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision. In this case, a new commit is not needed to store the combined history; instead, the &lt;code&gt;HEAD&lt;/code&gt; (along with the index) is updated to point at the named commit, without creating an extra merge commit.</source>
          <target state="translated">Часто текущая глава ветки является предком указанного коммита. Это наиболее распространенный случай, особенно при вызове из &lt;code&gt;git pull&lt;/code&gt; : вы отслеживаете вышестоящий репозиторий, вы не вносили никаких локальных изменений, и теперь вы хотите выполнить обновление до более новой исходной ревизии. В этом случае новая фиксация не требуется для хранения объединенной истории; вместо этого &lt;code&gt;HEAD&lt;/code&gt; (вместе с индексом) обновляется, чтобы указывать на названный коммит, без создания дополнительной фиксации слияния.</target>
        </trans-unit>
        <trans-unit id="bc22c639538c04ca7d5608268e4dc9b34f324581" translate="yes" xml:space="preserve">
          <source>Often the overview of the change is useful to get a feel of each step</source>
          <target state="translated">Часто обзор изменений полезен для того,чтобы получить представление о каждом шаге.</target>
        </trans-unit>
        <trans-unit id="a0ef5be0d5f74372c2549cc7906cdb110a910654" translate="yes" xml:space="preserve">
          <source>Often, &quot;please pull&quot; messages on the mailing list just provide two pieces of information: a repo URL and a branch name; this is designed to be easily cut&amp;amp;pasted at the end of a &lt;code&gt;git fetch&lt;/code&gt; command line:</source>
          <target state="translated">Часто сообщения &amp;laquo;пожалуйста, потяните&amp;raquo; в списке рассылки просто предоставляют две части информации: URL-адрес репо и имя ветки; его можно легко вырезать и вставить в конец командной строки &lt;code&gt;git fetch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b90f5f996d698883902ffd1dba32d6eea369ef9a" translate="yes" xml:space="preserve">
          <source>Older documentation written before the packed-refs mechanism was introduced may still say things like &quot;.git/refs/heads/&amp;lt;branch&amp;gt; file exists&quot; when it means &quot;branch &amp;lt;branch&amp;gt; exists&quot;.</source>
          <target state="translated">В более старой документации, написанной до того, как был введен механизм упакованных ссылок, все еще может быть сказано что-то вроде &amp;laquo;.git / refs / Heads / &amp;lt;branch&amp;gt; file exists&amp;raquo;, когда это означает &amp;laquo;ветка &amp;lt;branch&amp;gt; существует&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="a148aab8f38b980de65dd5f412fc336ae5d855f6" translate="yes" xml:space="preserve">
          <source>Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run &lt;code&gt;git merge&lt;/code&gt;. To make it easier to adjust such scripts to the updated behaviour, the environment variable &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; can be set to &lt;code&gt;no&lt;/code&gt; at the beginning of them.</source>
          <target state="translated">Старые сценарии могут зависеть от исторического поведения, не позволяющего пользователю редактировать сообщение журнала слияния. Когда они запустят &lt;code&gt;git merge&lt;/code&gt; , они увидят открытый редактор . Чтобы упростить адаптацию таких сценариев к обновленному поведению, для переменной среды &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; можно установить значение &lt;code&gt;no&lt;/code&gt; в начале сценария .</target>
        </trans-unit>
        <trans-unit id="3a027c8ab6aede7960dbe3d141d016ee3e6589ef" translate="yes" xml:space="preserve">
          <source>Older versions of &lt;code&gt;meld&lt;/code&gt; do not support the &lt;code&gt;--output&lt;/code&gt; option. Git will attempt to detect whether &lt;code&gt;meld&lt;/code&gt; supports &lt;code&gt;--output&lt;/code&gt; by inspecting the output of &lt;code&gt;meld --help&lt;/code&gt;. Configuring &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; will make Git skip these checks and use the configured value instead. Setting &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--output&lt;/code&gt; option, and &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--output&lt;/code&gt;.</source>
          <target state="translated">Старые версии &lt;code&gt;meld&lt;/code&gt; не поддерживают параметр &lt;code&gt;--output&lt;/code&gt; . Git попытается определить, поддерживает ли &lt;code&gt;meld&lt;/code&gt; &lt;code&gt;--output&lt;/code&gt; ,проверив вывод &lt;code&gt;meld --help&lt;/code&gt; . Настройка &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; заставит Git пропустить эти проверки и вместо этого использовать настроенное значение. Установка &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; в &lt;code&gt;true&lt;/code&gt; говорит Git безоговорочно использовать &lt;code&gt;--output&lt;/code&gt; вариант, и &lt;code&gt;false&lt;/code&gt; избегает использования &lt;code&gt;--output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8511fe9d48b84ff3883d162d35ccd3dcba224454" translate="yes" xml:space="preserve">
          <source>Older versions of Git (before 2.20) documented that the object names list should be sorted. This was never a requirement, the object names could appear in any order, but when reading the list we tracked whether the list was sorted for the purposes of an internal binary search implementation, which could save itself some work with an already sorted list. Unless you had a humongous list there was no reason to go out of your way to pre-sort the list. After Git version 2.20 a hash implementation is used instead, so there&amp;rsquo;s now no reason to pre-sort the list.</source>
          <target state="translated">В более старых версиях Git (до 2.20) указывалось, что список имен объектов должен быть отсортирован. Это никогда не было обязательным требованием, имена объектов могли появляться в любом порядке, но при чтении списка мы отслеживали, был ли список отсортирован для целей реализации внутреннего двоичного поиска, что могло сэкономить некоторую работу с уже отсортированным списком. Если у вас не было огромного списка, не было причин стараться изо всех сил, чтобы предварительно отсортировать список. После Git версии 2.20 вместо него используется хеш-реализация, поэтому теперь нет причин для предварительной сортировки списка.</target>
        </trans-unit>
        <trans-unit id="c51aaa3680fede028efcceee261b4919c277f552" translate="yes" xml:space="preserve">
          <source>Omit any commit that introduces the same change as another commit on the &amp;ldquo;other side&amp;rdquo; when the set of commits are limited with symmetric difference.</source>
          <target state="translated">Пропустите любую фиксацию, которая вводит те же изменения, что и другая фиксация на &amp;laquo;другой стороне&amp;raquo;, когда набор коммитов ограничен симметричной разницей.</target>
        </trans-unit>
        <trans-unit id="e35d3ce0c9ea9ff6d661fcb1cbc8e08ffef97df6" translate="yes" xml:space="preserve">
          <source>Omit diff output for unmerged entries and just show &quot;Unmerged&quot;. Can be used only when comparing the working tree with the index.</source>
          <target state="translated">Опустите выход diff для неупорядоченных записей и просто покажите &quot;Неупорядоченные&quot;.Может использоваться только при сравнении рабочего дерева с индексом.</target>
        </trans-unit>
        <trans-unit id="3138b0b10501de06a44e08d0de4b10a83646644b" translate="yes" xml:space="preserve">
          <source>Omit objects that are known to be in the promisor remote. (This option has the purpose of operating only on locally created objects, so that when we repack, we still maintain a distinction between locally created objects [without .promisor] and objects from the promisor remote [with .promisor].) This is used with partial clone.</source>
          <target state="translated">Опустите объекты,которые,как известно,находятся в удаленном промусоре.(Эта опция предназначена для работы только с объектами,созданными локально,так что когда мы переупаковываем,мы все равно сохраняем различие между объектами,созданными локально [без .promisor]и объектами,созданными удаленным [с .promisor]Promisor).Это используется при частичном клонировании.</target>
        </trans-unit>
        <trans-unit id="fcfe3e3e988e33991f3ebb33b70ee9c58a79e5d0" translate="yes" xml:space="preserve">
          <source>Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and &lt;code&gt;/dev/null&lt;/code&gt;. The resulting patch is not meant to be applied with &lt;code&gt;patch&lt;/code&gt; or &lt;code&gt;git apply&lt;/code&gt;; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.</source>
          <target state="translated">Пропускайте прообраз при удалении, т.е. печатайте только заголовок, но не разницу между прообразом и &lt;code&gt;/dev/null&lt;/code&gt; . Полученный патч не предназначен для применения с помощью &lt;code&gt;patch&lt;/code&gt; или &lt;code&gt;git apply&lt;/code&gt; ; это предназначено исключительно для людей, которые хотят просто сосредоточиться на просмотре текста после изменения. Кроме того, в выходных данных явно не хватает информации, чтобы применить такой патч в обратном порядке, даже вручную, отсюда и название опции.</target>
        </trans-unit>
        <trans-unit id="2c239b325c52048ed0e0df682e63161da794c522" translate="yes" xml:space="preserve">
          <source>Omitting &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; detaches &lt;code&gt;HEAD&lt;/code&gt; at the tip of the current branch.</source>
          <target state="translated">Отсутствие &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; отделяет &lt;code&gt;HEAD&lt;/code&gt; от конца текущей ветви.</target>
        </trans-unit>
        <trans-unit id="6f08ea1a85b441d7cdb4b9da4840e51d4a63074c" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;from&lt;/code&gt; command in the first commit of a new branch will cause fast-import to create that commit with no ancestor. This tends to be desired only for the initial commit of a project. If the frontend creates all files from scratch when making a new branch, a &lt;code&gt;merge&lt;/code&gt; command may be used instead of &lt;code&gt;from&lt;/code&gt; to start the commit with an empty tree. Omitting the &lt;code&gt;from&lt;/code&gt; command on existing branches is usually desired, as the current commit on that branch is automatically assumed to be the first ancestor of the new commit.</source>
          <target state="translated">Пропуск команды &lt;code&gt;from&lt;/code&gt; в первом коммите новой ветки приведет к тому, что быстрый импорт создаст этот коммит без предка. Обычно это желательно только для первоначальной фиксации проекта. Если интерфейс создает все файлы с нуля при создании новой ветки, вместо команды &lt;code&gt;from&lt;/code&gt; можно использовать команду &lt;code&gt;merge&lt;/code&gt; чтобы начать фиксацию с пустым деревом. Опуская &lt;code&gt;from&lt;/code&gt; команды на существующих ветвей, как правило , желательно, так как ток фиксации на этой ветви автоматически считается первым предком новой фиксации.</target>
        </trans-unit>
        <trans-unit id="2e6ae0a1101e66bbdd1aff8c2583b81c23208b83" translate="yes" xml:space="preserve">
          <source>On Automatic following</source>
          <target state="translated">На Автоматическом слежении</target>
        </trans-unit>
        <trans-unit id="82b4aa90bf6690a7ed8e3558248667b070567fb7" translate="yes" xml:space="preserve">
          <source>On Backdating Tags</source>
          <target state="translated">На бэкдайтинговых метках</target>
        </trans-unit>
        <trans-unit id="52c1ff7f8dbe6e1f6639547a437fb78c51994ab9" translate="yes" xml:space="preserve">
          <source>On Re-tagging</source>
          <target state="translated">На перемаркировке</target>
        </trans-unit>
        <trans-unit id="a3e5a575b7ca5dced5a48ec2289cb57e77edaa64" translate="yes" xml:space="preserve">
          <source>On an inefficient filesystem with &lt;code&gt;core.ignorestat&lt;/code&gt; set</source>
          <target state="translated">На неэффективной файловой системе с установленным &lt;code&gt;core.ignorestat&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fc5d80f58915bdd0c5c8219fc8fa34ba2d1e212" translate="yes" xml:space="preserve">
          <source>On any other error, the exit status may be any other non-zero value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf984a0700972bcd62e51c87e569c1158e56007" translate="yes" xml:space="preserve">
          <source>On large repositories, Git depends on compression to keep the history information from taking up too much space on disk or in memory. Some Git commands may automatically run &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;, so you don&amp;rsquo;t have to worry about running it manually. However, compressing a large repository may take a while, so you may want to call &lt;code&gt;gc&lt;/code&gt; explicitly to avoid automatic compression kicking in when it is not convenient.</source>
          <target state="translated">В больших репозиториях Git зависит от сжатия, чтобы информация истории не занимала слишком много места на диске или в памяти. Некоторые команды Git могут автоматически запускать &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; , поэтому вам не нужно беспокоиться о его запуске вручную. Однако сжатие большого репозитория может занять некоторое время, поэтому вы можете явно вызвать &lt;code&gt;gc&lt;/code&gt; , чтобы избежать автоматического сжатия, когда это неудобно.</target>
        </trans-unit>
        <trans-unit id="d4d8aed3bf55796608219c0adac254008695a3f9" translate="yes" xml:space="preserve">
          <source>On some file system/operating system combinations, this is unreliable. Set this config setting to &lt;code&gt;rename&lt;/code&gt; there; However, This will remove the check that makes sure that existing object files will not get overwritten.</source>
          <target state="translated">В некоторых комбинациях файловая система / операционная система это ненадежно. Установите этот параметр конфигурации, чтобы &lt;code&gt;rename&lt;/code&gt; его; Однако при этом будет снята проверка, гарантирующая, что существующие объектные файлы не будут перезаписаны.</target>
        </trans-unit>
        <trans-unit id="5895edccc183158d9e3740d2cebb6ada4fc33444" translate="yes" xml:space="preserve">
          <source>On submit, re-author changes to reflect the Git author, regardless of who invokes &lt;code&gt;git p4 submit&lt;/code&gt;.</source>
          <target state="translated">При отправке повторно отредактируйте изменения, чтобы отразить автора Git, независимо от того, кто вызывает &lt;code&gt;git p4 submit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="625dc8e72565a5aa6c893e4054fd5a7bd4cd4c77" translate="yes" xml:space="preserve">
          <source>On success, the command returns the exit code 0.</source>
          <target state="translated">При успешном выполнении команда возвращает код выхода 0.</target>
        </trans-unit>
        <trans-unit id="55bf26a2244670497728b53622880350724b3943" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990e4d4ec388fa2b56426ae37da6b01c179599b8" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;. If the filter can&amp;rsquo;t find any commits to rewrite, the exit status is &lt;code&gt;2&lt;/code&gt;. On any other error, the exit status may be any other non-zero value.</source>
          <target state="translated">В случае успеха статус выхода равен &lt;code&gt;0&lt;/code&gt; . Если фильтр не может найти никаких коммитов для перезаписи, статус выхода равен &lt;code&gt;2&lt;/code&gt; . При любой другой ошибке статус выхода может быть любым другим ненулевым значением.</target>
        </trans-unit>
        <trans-unit id="9b26f7834b511fe2fcda898a4f6a6ea24bf02deb" translate="yes" xml:space="preserve">
          <source>On the filesystem, a submodule usually (but not always - see FORMS below) consists of (i) a Git directory located under the &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; directory of its superproject, (ii) a working directory inside the superproject&amp;rsquo;s working directory, and a &lt;code&gt;.git&lt;/code&gt; file at the root of the submodule&amp;rsquo;s working directory pointing to (i).</source>
          <target state="translated">В файловой системе подмодуль обычно (но не всегда - см. ФОРМЫ ниже) состоит из (i) каталога Git, расположенного в &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; его суперпроекта, (ii) рабочего каталога внутри рабочего каталога суперпроекта и &lt;code&gt;.git&lt;/code&gt; файл в корневом каталоге рабочего каталога , указывающий подмодуль , чтобы (я).</target>
        </trans-unit>
        <trans-unit id="4db9025909f7f5bf5e13acbeaf805aa54cd01729" translate="yes" xml:space="preserve">
          <source>On the other hand if you do this often, then it can be worth having scripts to avoid too much typing.</source>
          <target state="translated">С другой стороны,если вы делаете это часто,то,возможно,стоит иметь скрипты,чтобы избежать слишком большого набора текста.</target>
        </trans-unit>
        <trans-unit id="683649c177c2041eda8a2d9bcca87e40a04a531c" translate="yes" xml:space="preserve">
          <source>On the other hand, if instead of merging at C you had rebased the history between Z to B on top of A, you would have gotten this linear history:</source>
          <target state="translated">С другой стороны,если бы вместо слияния в C вы перестроили историю между Z и B на вершине A,вы бы получили эту линейную историю:</target>
        </trans-unit>
        <trans-unit id="0322f18dd0193743bffa03c418d12c6fe0b24261" translate="yes" xml:space="preserve">
          <source>On the other hand, if you are fetching because you would want a one-shot merge from somebody else, you typically do not want to get tags from there. This happens more often for people near the toplevel but not limited to them. Mere mortals when pulling from each other do not necessarily want to automatically get private anchor point tags from the other person.</source>
          <target state="translated">С другой стороны,если вы хотите получить тэги от кого-то еще,то,как правило,не хотите получать их оттуда.Это случается чаще для людей,находящихся рядом с верхним уровнем,но не только для них.Простые смертные,вытягивая друг у друга,не обязательно хотят автоматически получать частные теги точки привязки от другого человека.</target>
        </trans-unit>
        <trans-unit id="ff26b6c1b15a595913b474bb862db9261a722064" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process, there is a risk of it deleting an object that the other process is using but hasn&amp;rsquo;t created a reference to. This may just cause the other process to fail or may corrupt the repository if the other process later adds a reference to the deleted object. Git has two features that significantly mitigate this problem:</source>
          <target state="translated">С другой стороны, когда &lt;code&gt;git gc&lt;/code&gt; выполняется одновременно с другим процессом, существует риск того, что он удалит объект, который другой процесс использует, но не создал ссылку. Это может просто вызвать сбой другого процесса или может повредить репозиторий, если другой процесс позже добавит ссылку на удаленный объект. В Git есть две функции, которые значительно смягчают эту проблему:</target>
        </trans-unit>
        <trans-unit id="9cc6a0108c9ca30d35fc16f0e158699698e2687d" translate="yes" xml:space="preserve">
          <source>On the plus side, distributed revision control systems can much better integrate with external sources. In a centralized model, a single arbitrary snapshot of the external project is exported from its own revision control and then imported into the local revision control on a vendor branch. All the history is hidden. With distributed revision control you can clone the entire external history and much more easily follow development and re-merge local changes.</source>
          <target state="translated">С другой стороны,распределенные системы контроля ревизий могут гораздо лучше интегрироваться с внешними источниками.В централизованной модели один произвольный снэпшот внешнего проекта экспортируется из собственного управления ревизиями,а затем импортируется в локальное управление ревизиями на ветке поставщика.Вся история скрыта.С помощью распределённого управления ревизиями вы можете клонировать всю внешнюю историю и гораздо проще следить за разработкой и перемерять локальные изменения.</target>
        </trans-unit>
        <trans-unit id="90597c320571938c2a30a9ec587f181632e3da9c" translate="yes" xml:space="preserve">
          <source>On the receiving side, failing fsckObjects will make those objects unreachable, see &quot;QUARANTINE ENVIRONMENT&quot; in &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. On the fetch side, malformed objects will instead be left unreferenced in the repository.</source>
          <target state="translated">На принимающей стороне сбой fsckObjects сделает эти объекты недоступными, см. &quot;КАРАНТИННАЯ СРЕДА&quot; в &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; . На стороне выборки искаженные объекты вместо этого останутся без ссылок в репозитории.</target>
        </trans-unit>
        <trans-unit id="0cb32cbc06583a961d1463cba3f54ceac091ac9b" translate="yes" xml:space="preserve">
          <source>Once a patch completes the great cycle (moving from test to release, then pulled by Linus, and finally coming back into your local &lt;code&gt;origin/master&lt;/code&gt; branch), the branch for this change is no longer needed. You detect this when the output from:</source>
          <target state="translated">После того, как патч завершает большой цикл (переход от теста к выпуску, затем вытаскивается Линусом и, наконец, возвращается в вашу локальную &lt;code&gt;origin/master&lt;/code&gt; ветку), ветка для этого изменения больше не нужна. Вы обнаружите это, когда вывод:</target>
        </trans-unit>
        <trans-unit id="b9ebb68ceda33b5f55394a76815abe93f554d5a0" translate="yes" xml:space="preserve">
          <source>Once again, check to verify that you&amp;rsquo;ve included what you want to. You may also wish to verify that git diff doesn&amp;rsquo;t show any remaining changes to be committed later.</source>
          <target state="translated">Еще раз проверьте, что вы включили то, что хотите. Вы также можете убедиться, что git diff не показывает никаких оставшихся изменений, которые нужно зафиксировать позже.</target>
        </trans-unit>
        <trans-unit id="90e05562a65001025b0b72d96c6a4e4b947387b5" translate="yes" xml:space="preserve">
          <source>Once housekeeping is triggered by exceeding the limits of configuration options such as &lt;code&gt;gc.auto&lt;/code&gt; and &lt;code&gt;gc.autoPackLimit&lt;/code&gt;, all other housekeeping tasks (e.g. rerere, working trees, reflog&amp;hellip;​) will be performed as well.</source>
          <target state="translated">Как только обслуживание запускается путем превышения пределов параметров конфигурации, таких как &lt;code&gt;gc.auto&lt;/code&gt; и &lt;code&gt;gc.autoPackLimit&lt;/code&gt; , все другие служебные задачи (например, повторное повторение, рабочие деревья, reflog&amp;hellip;) также будут выполнены.</target>
        </trans-unit>
        <trans-unit id="e4fac50f608beca9583acae6e66b5b839bc7af82" translate="yes" xml:space="preserve">
          <source>Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using &lt;code&gt;git diff --cached&lt;/code&gt;. This shows all the changes that have been moved into the index and are about to be committed.</source>
          <target state="translated">Когда вы будете удовлетворены фрагментами, которые хотите включить, вам следует проверить, что было подготовлено для первого коммита, используя &lt;code&gt;git diff --cached&lt;/code&gt; . Это показывает все изменения, которые были перемещены в индекс и собираются зафиксировать.</target>
        </trans-unit>
        <trans-unit id="3dd9fb6970c316fd22de16c64bf93a0699f63f8d" translate="yes" xml:space="preserve">
          <source>Once the commits are ready to be sent, run the following command:</source>
          <target state="translated">Как только коммиты будут готовы к отправке,выполните следующую команду:</target>
        </trans-unit>
        <trans-unit id="40868be271f12676d4171e28016f98d26c82d485" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the hash that goes into the name of the pack/idx file is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0e79bf062114aed97a847d2dbf78bde74bcedc" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the list of object names is sorted and the SHA-1 hash of that list is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="translated">После создания индекса список имен объектов сортируется, и хэш SHA-1 этого списка выводится на стандартный вывод. Если также использовалась опция --stdin, то перед ней стоит префикс &amp;laquo;pack \ t&amp;raquo; или &amp;laquo;keep \ t&amp;raquo;, если новый файл .keep был успешно создан. Это полезно для удаления файла .keep, который используется в качестве блокировки для предотвращения гонки с упомянутым выше &lt;code&gt;git repack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="267c8839170c35911e5505454167dce43ef8461e" translate="yes" xml:space="preserve">
          <source>Once the index is updated with the results of the conflict resolution, instead of creating a new commit, just run</source>
          <target state="translated">Как только индекс обновляется с результатами разрешения конфликта,вместо создания нового коммита,просто запускайте</target>
        </trans-unit>
        <trans-unit id="dce83a819a58902526be63ab88beb478ade1a830" translate="yes" xml:space="preserve">
          <source>Once tracking a Subversion repository (with any of the above methods), the Git repository can be updated from Subversion by the &lt;code&gt;fetch&lt;/code&gt; command and Subversion updated from Git by the &lt;code&gt;dcommit&lt;/code&gt; command.</source>
          <target state="translated">После отслеживания репозитория Subversion (любым из вышеперечисленных методов) репозиторий Git может быть обновлен из Subversion с помощью команды &lt;code&gt;fetch&lt;/code&gt; , а Subversion обновлен из Git с помощью команды &lt;code&gt;dcommit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7c323cf6aca82334469eb4ac31bb75f493bfcb2" translate="yes" xml:space="preserve">
          <source>Once you fetch from the remote repository, you &lt;code&gt;merge&lt;/code&gt; that with your current branch.</source>
          <target state="translated">После извлечения из удаленного репозитория вы &lt;code&gt;merge&lt;/code&gt; с текущей веткой.</target>
        </trans-unit>
        <trans-unit id="196d7a30344d61fce15a29277d1febbefab63366" translate="yes" xml:space="preserve">
          <source>Once you have packed objects, you do not need to leave the unpacked objects that are contained in the pack file anymore.</source>
          <target state="translated">После того,как вы упаковали объекты,вам больше не нужно оставлять распакованные объекты,которые содержатся в пакетном файле.</target>
        </trans-unit>
        <trans-unit id="19419c3fb2ffef21b9b034f5ca5d579751e9cffb" translate="yes" xml:space="preserve">
          <source>Once you have specified at least one bad and one good commit, &lt;code&gt;git
bisect&lt;/code&gt; selects a commit in the middle of that range of history, checks it out, and outputs something similar to the following:</source>
          <target state="translated">После того как вы указали хотя бы одну плохую и одну хорошую фиксацию, &lt;code&gt;git bisect&lt;/code&gt; выбирает фиксацию в середине этого диапазона истории, проверяет ее и выводит что-то похожее на следующее:</target>
        </trans-unit>
        <trans-unit id="a222e7e00ea22df97bc019f6fbda7d4a739d08f0" translate="yes" xml:space="preserve">
          <source>Once you know the three trees you are going to merge (the one &quot;original&quot; tree, aka the common tree, and the two &quot;result&quot; trees, aka the branches you want to merge), you do a &quot;merge&quot; read into the index. This will complain if it has to throw away your old index contents, so you should make sure that you&amp;rsquo;ve committed those&amp;mdash;​in fact you would normally always do a merge against your last commit (which should thus match what you have in your current index anyway).</source>
          <target state="translated">Как только вы узнаете три дерева, которые собираетесь объединить (одно &amp;laquo;исходное&amp;raquo; дерево, также известное как общее дерево, и два &amp;laquo;результирующих&amp;raquo; дерева, также называемые ветвями, которые вы хотите объединить), вы выполняете &amp;laquo;объединение&amp;raquo;, считывая индекс. Он будет жаловаться, если ему придется выбросить ваше старое содержимое индекса, поэтому вы должны убедиться, что вы их зафиксировали - на самом деле вы обычно всегда выполняете слияние с вашим последним коммитом (что, таким образом, должно соответствовать тому, что у вас есть в вашем в любом случае текущий индекс).</target>
        </trans-unit>
        <trans-unit id="2f6bdbc854c9f4a06850e81f40a40893a853f873" translate="yes" xml:space="preserve">
          <source>Once your commits are ready to be sent to the mailing list, run the following commands:</source>
          <target state="translated">Как только ваши коммиты будут готовы к отправке в список рассылки,выполните следующие команды:</target>
        </trans-unit>
        <trans-unit id="1e3411b288c5ece442ec5affcc9ccff7867288ff" translate="yes" xml:space="preserve">
          <source>One can also modify context lines by staging them for removal (by converting &quot; &quot; to &quot;-&quot;) and adding a &quot;+&quot; line with the new content. Similarly, one can modify &quot;+&quot; lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree.</source>
          <target state="translated">Можно также модифицировать строки контекста,помещая их для удаления (конвертируя &quot; &quot; в &quot;-&quot;)и добавляя строку &quot;+&quot; к новому содержанию.Аналогичным образом,можно изменить строки с символом &quot;+&quot; для существующих дополнений или изменений.Во всех случаях новая модификация будет отображаться в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="cefda8701820e17ff3e5c1f9d74674c9ba3ca4b0" translate="yes" xml:space="preserve">
          <source>One feature worth pointing out is the three-way merge, which can help if you get conflicts: &lt;code&gt;git am -3&lt;/code&gt; will use index information contained in patches to figure out the merge base. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; for other options.</source>
          <target state="translated">Одна особенность, на которую стоит обратить внимание, - это трехстороннее слияние, которое может помочь в случае возникновения конфликтов: &lt;code&gt;git am -3&lt;/code&gt; будет использовать информацию индекса, содержащуюся в патчах, для определения базы слияния. Другие варианты см. В &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91b115a828fd51fba09fc11d7213ae15c1c47544" translate="yes" xml:space="preserve">
          <source>One important aspect of Git is its distributed nature, which largely means there is no inherent &quot;upstream&quot; or &quot;downstream&quot; in the system. On the face of it, the above example might seem to indicate that the tag namespace is owned by the upper echelon of people and that tags only flow downwards, but that is not the case. It only shows that the usage pattern determines who are interested in whose tags.</source>
          <target state="translated">Одним из важных аспектов Git'а является его распределённая природа,что в значительной степени означает отсутствие в системе врождённого &quot;восходящего&quot; или &quot;нисходящего&quot; потока.На первый взгляд может показаться,что приведённый выше пример указывает на то,что пространство имён тегов принадлежит верхнему эшелону людей и что теги стекают только вниз,но это не так.Он только показывает,что шаблон использования определяет,кому чьи теги интересны.</target>
        </trans-unit>
        <trans-unit id="04ced8b13491984476dfed877ea62bd96c9df7a6" translate="yes" xml:space="preserve">
          <source>One major difference between &lt;code&gt;git submodule update&lt;/code&gt; and &lt;code&gt;git submodule add&lt;/code&gt; is that &lt;code&gt;git submodule update&lt;/code&gt; checks out a specific commit, rather than the tip of a branch. It&amp;rsquo;s like checking out a tag: the head is detached, so you&amp;rsquo;re not working on a branch.</source>
          <target state="translated">Одно из основных различий между &lt;code&gt;git submodule update&lt;/code&gt; и &lt;code&gt;git submodule add&lt;/code&gt; состоит в том, что &lt;code&gt;git submodule update&lt;/code&gt; проверяет конкретную фиксацию, а не вершину ветки. Это как проверка тега: голова отделена, значит, вы не работаете над веткой.</target>
        </trans-unit>
        <trans-unit id="8d6438f7bb62b577ed24501432d3010343f7c06f" translate="yes" xml:space="preserve">
          <source>One nice about &quot;git bisect&quot; is that it is not only a developer tool. It can effectively be used by QA people or even end users (if they have access to the source code or if they can get access to all the builds).</source>
          <target state="translated">Один из приятных моментов в &quot;git-бисекте&quot; заключается в том,что это не только инструмент для разработчиков.Он может эффективно использоваться людьми,отвечающими за контроль качества,или даже конечными пользователями (если у них есть доступ к исходным текстам или если они могут получить доступ ко всем сборкам).</target>
        </trans-unit>
        <trans-unit id="142f19dfe765b1c5ce574050578fa3bc8f7c4c07" translate="yes" xml:space="preserve">
          <source>One note: the special &lt;code&gt;master&lt;/code&gt; head is the default branch, which is why the &lt;code&gt;.git/HEAD&lt;/code&gt; file was created points to it even if it doesn&amp;rsquo;t yet exist. Basically, the &lt;code&gt;HEAD&lt;/code&gt; link is supposed to always point to the branch you are working on right now, and you always start out expecting to work on the &lt;code&gt;master&lt;/code&gt; branch.</source>
          <target state="translated">Одно замечание: специальная &lt;code&gt;master&lt;/code&gt; голова является ветвью по умолчанию, поэтому был создан файл &lt;code&gt;.git/HEAD&lt;/code&gt; , указывающий на нее, даже если он еще не существует. По сути, ссылка &lt;code&gt;HEAD&lt;/code&gt; должна всегда указывать на ветку, над которой вы работаете прямо сейчас, и вы всегда начинаете с ожидания работы над &lt;code&gt;master&lt;/code&gt; веткой.</target>
        </trans-unit>
        <trans-unit id="29a0c8f350324f991b248dd3aa593e11f5862130" translate="yes" xml:space="preserve">
          <source>One obvious improvement to this algorithm would be to look for a commit that has an associated value near the one of the best bisection commit, and that is on another branch, before using the PRNG. Because if such a commit exists, then it is not very likely to be untestable too, so it will probably give more information than a nearly randomly chosen one.</source>
          <target state="translated">Очевидным улучшением этого алгоритма является поиск коммита,который имеет ассоциированное значение рядом с одним из лучших биссектрисных коммитов,и который находится в другой ветке,перед использованием ГПСЧ.Потому что если такой коммит существует,то,скорее всего,он также не будет неоспорим,так что он,вероятно,даст больше информации,чем почти случайно выбранный коммит.</target>
        </trans-unit>
        <trans-unit id="e1159b72c8727d654a00df87bb5a62e68448d486" translate="yes" xml:space="preserve">
          <source>One of the following transports can be used to name the repository to download from:</source>
          <target state="translated">Один из следующих транспортов может быть использован для названия репозитория для загрузки:</target>
        </trans-unit>
        <trans-unit id="f2e9320213d36179f9f718d529b707eca70ac72d" translate="yes" xml:space="preserve">
          <source>One of the ideas of having a branch is that you do some (possibly experimental) work in it, and eventually merge it back to the main branch. So assuming you created the above &lt;code&gt;mybranch&lt;/code&gt; that started out being the same as the original &lt;code&gt;master&lt;/code&gt; branch, let&amp;rsquo;s make sure we&amp;rsquo;re in that branch, and do some work there.</source>
          <target state="translated">Одна из идей создания ветки заключается в том, что вы выполняете в ней некоторую (возможно, экспериментальную) работу и в конечном итоге объединяете ее с основной веткой. Таким образом , предполагается , что вы создали выше &lt;code&gt;mybranch&lt;/code&gt; , начавшаяся быть таким же , как оригинальный &lt;code&gt;master&lt;/code&gt; - ветви, давайте удостоверимся , что мы в этой отрасли, и там делать какую - то работу.</target>
        </trans-unit>
        <trans-unit id="07b5c446feb269c31391e3ec2cd0376191f84e84" translate="yes" xml:space="preserve">
          <source>One of the identifiers &quot;&lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tree_object&quot;&gt;tree&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt;&quot; describing the type of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;.</source>
          <target state="translated">Один из идентификаторов &amp;laquo; &lt;a href=&quot;#def_commit_object&quot;&gt;фиксация&lt;/a&gt; &amp;raquo;, &amp;laquo; &lt;a href=&quot;#def_tree_object&quot;&gt;дерево&lt;/a&gt; &amp;raquo;, &amp;laquo; &lt;a href=&quot;#def_tag_object&quot;&gt;тег&lt;/a&gt; &amp;raquo; или &amp;laquo; &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; &amp;raquo;, описывающий тип &lt;a href=&quot;#def_object&quot;&gt;объекта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4cfd499f1faa2bf47281b08252a27709dbf65c31" translate="yes" xml:space="preserve">
          <source>One or more of the options below may be used to determine the files shown:</source>
          <target state="translated">Для определения показанных файлов может быть использована одна или несколько из приведенных ниже опций:</target>
        </trans-unit>
        <trans-unit id="5fdc57e5472e4e105b70357796e6b6c7c9687799" translate="yes" xml:space="preserve">
          <source>One or more of the provided paths is ignored.</source>
          <target state="translated">Один или несколько из предоставленных путей игнорируются.</target>
        </trans-unit>
        <trans-unit id="fa8d672b6bbfcb201a67403df350a9a5a712d006" translate="yes" xml:space="preserve">
          <source>One phase in branch detection involves looking at p4 branches to find new ones to import. By default, all branches are inspected. This option limits the search to just those owned by the single user named in the variable.</source>
          <target state="translated">Один из этапов обнаружения ветки заключается в просмотре ветки p4 для поиска новых ветвей для импорта.По умолчанию проверяются все ветки.Эта опция ограничивает поиск только теми,которые принадлежат одному пользователю,указанному в переменной.</target>
        </trans-unit>
        <trans-unit id="11468bd4c23009003db390c522332f7c3d2a8eae" translate="yes" xml:space="preserve">
          <source>One problem with &quot;git replace&quot; is that currently it stores all the replacements refs in &quot;refs/replace/&quot;, but it would be perhaps better if the replacement refs that are useful only for bisecting would be in &quot;refs/replace/bisect/&quot;. This way the replacement refs could be used only for bisecting, while other refs directly in &quot;refs/replace/&quot; would be used nearly all the time.</source>
          <target state="translated">Одна из проблем с &quot;git-замещением&quot; заключается в том,что в настоящее время все заменяемые ссылки хранятся в &quot;refs/replace/&quot;,но,возможно,было бы лучше,если бы замена ссылок,полезная только для биссектрисы,была бы в &quot;refs/replace/bisect/&quot;.Таким образом,заменяющие ссылки могут использоваться только для биссектрисы,в то время как другие ссылки непосредственно в &quot;refs/replace/&quot; будут использоваться почти постоянно.</target>
        </trans-unit>
        <trans-unit id="d1e2a86cedb580a377c28acdbf81410bf88bf79b" translate="yes" xml:space="preserve">
          <source>One record (for project / repository) per line; does not support line continuation (newline escaping).</source>
          <target state="translated">Одна запись (для проекта/репозитория)на линию;не поддерживает продолжение линии (экранирование новой линии).</target>
        </trans-unit>
        <trans-unit id="8e018f50410d5f4a4feb43d8b0ec18d17af4444c" translate="yes" xml:space="preserve">
          <source>One such software is the Linux kernel. And if we look at the Linux kernel, we can see that a lot of time and effort is spent to fight regressions. The release cycle start with a 2 weeks long merge window. Then the first release candidate (rc) version is tagged. And after that about 7 or 8 more rc versions will appear with around one week between each of them, before the final release.</source>
          <target state="translated">Одним из таких программ является ядро Linux.И если мы посмотрим на ядро Linux,то увидим,что много времени и усилий тратится на борьбу с регрессиями.Цикл выпуска начинается с 2-х недельного окна слияния.Затем помечается первая версия кандидата на выпуск (rc).А после этого появится еще около 7 или 8 rc-версий,с промежутком примерно в одну неделю между каждой из них,до окончательного релиза.</target>
        </trans-unit>
        <trans-unit id="bdac2081c61d66c365f2d2f97739c2e3f666a74e" translate="yes" xml:space="preserve">
          <source>One usage scenario is to run unit tests in the hook.</source>
          <target state="translated">Один сценарий использования-запуск модульных тестов на крючке.</target>
        </trans-unit>
        <trans-unit id="f9e9013eccf2a70e5a5f30b1ea62b3495fc5c835" translate="yes" xml:space="preserve">
          <source>One use of the content filtering is to massage the content into a shape that is more convenient for the platform, filesystem, and the user to use. For this mode of operation, the key phrase here is &quot;more convenient&quot; and not &quot;turning something unusable into usable&quot;. In other words, the intent is that if someone unsets the filter driver definition, or does not have the appropriate filter program, the project should still be usable.</source>
          <target state="translated">Одним из видов использования контентной фильтрации является массаж контента в форму,более удобную для платформы,файловой системы и пользователя.Для такого режима работы ключевым словосочетанием здесь является &quot;удобнее&quot;,а не &quot;превратить что-то непригодное в полезное&quot;.Другими словами,цель состоит в том,что если кто-то снимет определение фильтрующего драйвера,или у него не будет соответствующей фильтрующей программы,то проект все равно должен быть пригоден для использования.</target>
        </trans-unit>
        <trans-unit id="bf346c4d1c8b72f5f128424640398ae0ca4f5b99" translate="yes" xml:space="preserve">
          <source>One way to test if your MUA is set up correctly is:</source>
          <target state="translated">Один из способов проверить,правильно ли настроен ваш MUA:</target>
        </trans-unit>
        <trans-unit id="2d149b07bfc5760abe904c522d47cdc6ed806f7c" translate="yes" xml:space="preserve">
          <source>Only allow &lt;code&gt;--filter=tree:&amp;lt;n&amp;gt;&lt;/code&gt; when &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; is no more than the value of &lt;code&gt;uploadpackfilter.tree.maxDepth&lt;/code&gt;. If set, this also implies &lt;code&gt;uploadpackfilter.tree.allow=true&lt;/code&gt;, unless this configuration variable had already been set. Has no effect if unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7da7d48889d5c708679796bf76623241882d879" translate="yes" xml:space="preserve">
          <source>Only allow viewing of repositories also shown on the overview page. This for example makes &lt;code&gt;$export_ok&lt;/code&gt; file decide if repository is available and not only if it is shown. If &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of project, only those repositories listed would be available for gitweb. Can be set during building gitweb via &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt;. By default this variable is not set, which means that you can directly access those repositories that are hidden from projects list page (e.g. the are not listed in the $projects_list file).</source>
          <target state="translated">Разрешить просмотр только репозиториев, которые также отображаются на странице обзора. Это, например, заставляет файл &lt;code&gt;$export_ok&lt;/code&gt; решать, доступен ли репозиторий, а не только если он отображается. Если &lt;code&gt;$projects_list&lt;/code&gt; указывает на файл со списком проектов, только перечисленные репозитории будут доступны для gitweb. Можно установить во время сборки gitweb через &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt; . По умолчанию эта переменная не установлена, что означает, что вы можете получить прямой доступ к тем репозиториям, которые скрыты на странице списка проектов (например, не указаны в файле $ projects_list).</target>
        </trans-unit>
        <trans-unit id="a9db6957ecdccb26c443588b379fe63817da234e" translate="yes" xml:space="preserve">
          <source>Only anonymous access is provided by pserve by default. To commit you will have to create pserver accounts, simply add a gitcvs.authdb setting in the config file of the repositories you want the cvsserver to allow writes to, for example:</source>
          <target state="translated">По умолчанию pserve предоставляет только анонимный доступ.Для фиксации вам нужно будет создать учётные записи на pserver,просто добавьте настройку gitcvs.authdb в конфигурационный файл репозиториев,в которые вы хотите,чтобы cvsserver разрешил запись,например:</target>
        </trans-unit>
        <trans-unit id="f8de1f9ddde9f99ee756c31ae048d708dda7832c" translate="yes" xml:space="preserve">
          <source>Only bind the web server to the local IP (127.0.0.1).</source>
          <target state="translated">Привязывайте веб-сервер только к локальному IP (127.0.0.1).</target>
        </trans-unit>
        <trans-unit id="914060d4007bba68d0e5b57a08eb8520cbc0281b" translate="yes" xml:space="preserve">
          <source>Only consider tags matching the given &lt;code&gt;glob(7)&lt;/code&gt; pattern, excluding the &quot;refs/tags/&quot; prefix. If used with &lt;code&gt;--all&lt;/code&gt;, it also considers local branches and remote-tracking references matching the pattern, excluding respectively &quot;refs/heads/&quot; and &quot;refs/remotes/&quot; prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered. Use &lt;code&gt;--no-match&lt;/code&gt; to clear and reset the list of patterns.</source>
          <target state="translated">Учитывайте только теги, соответствующие заданному шаблону &lt;code&gt;glob(7)&lt;/code&gt; , за исключением префикса &quot;refs / tags /&quot;. Если используется с &lt;code&gt;--all&lt;/code&gt; , он также учитывает локальные ветки и ссылки удаленного отслеживания, соответствующие шаблону, за исключением соответственно префикса &amp;laquo;refs / heads /&amp;raquo; и &amp;laquo;refs / remotes /&amp;raquo;; ссылки других типов никогда не рассматриваются. Если задано несколько раз, будет накапливаться список шаблонов, и будут учитываться теги, соответствующие любому из шаблонов. Используйте &lt;code&gt;--no-match&lt;/code&gt; , чтобы очистить и сбросить список шаблонов.</target>
        </trans-unit>
        <trans-unit id="941066ff4f5ea2a1056ac361a36573c125ff04f2" translate="yes" xml:space="preserve">
          <source>Only create a packed archive if it would contain at least one object.</source>
          <target state="translated">Создавайте упакованный архив только в том случае,если он будет содержать хотя бы один объект.</target>
        </trans-unit>
        <trans-unit id="83ca14f8cd2c9566aaa74ad9a438e0a15bc783b9" translate="yes" xml:space="preserve">
          <source>Only expire loose objects older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">Только устаревшие объекты старше &amp;lt;time&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="d50becec82fb156672fd24c1ecb55cefe6d9b0c0" translate="yes" xml:space="preserve">
          <source>Only list branches of the given object.</source>
          <target state="translated">Перечислять только ветви данного объекта.</target>
        </trans-unit>
        <trans-unit id="ae8314faed018be3007d334a54cd4f7b3bde067a" translate="yes" xml:space="preserve">
          <source>Only list branches which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">Только те ветви списка, которые содержат указанный коммит (HEAD, если не указан). Подразумевает &lt;code&gt;--list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b39fcb7ccfd206d2a11b5cac77f876ebbcdc59a6" translate="yes" xml:space="preserve">
          <source>Only list branches which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">Список только ветвей, которые не содержат указанный коммит (HEAD, если не указан). Подразумевает &lt;code&gt;--list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d91bc93b24e96b92cd74b3016507c8892f02d8e" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">Перечислить только ветки, концы которых недоступны из указанного коммита (HEAD, если не указан). Подразумевает &lt;code&gt;--list&lt;/code&gt; , несовместимо с &lt;code&gt;--merged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f18c194fbea0e6a25127dd2c0242348888bebb8" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368e1f5311ab357c6579dd2598d3554e5f69ab7b" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">Перечислить только ветки, советы которых доступны из указанного коммита (HEAD, если не указан). Подразумевает &lt;code&gt;--list&lt;/code&gt; , несовместимый с &lt;code&gt;--no-merged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8c13c3ac0a7b1c9d8836463a5f79c31b1444a5" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc004fe98c7c853edcd721c4a4743bbe17dc0ceb" translate="yes" xml:space="preserve">
          <source>Only list refs which contain the specified commit (HEAD if not specified).</source>
          <target state="translated">Только список ссылок,которые содержат указанный коммит (HEAD,если не указано).</target>
        </trans-unit>
        <trans-unit id="53301ab6d13e8c23069a84dba2acf3daf5a67784" translate="yes" xml:space="preserve">
          <source>Only list refs which don&amp;rsquo;t contain the specified commit (HEAD if not specified).</source>
          <target state="translated">Список только тех ссылок, которые не содержат указанный коммит (HEAD, если не указан).</target>
        </trans-unit>
        <trans-unit id="13917fddfb76486aac0b6b32382a8222d7ef7129" translate="yes" xml:space="preserve">
          <source>Only list refs which points at the given object.</source>
          <target state="translated">Перечисляет только ссылки,которые указывают на данный объект.</target>
        </trans-unit>
        <trans-unit id="d63446ed3ed439dd64fa48118858d7dc8f885568" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">Список только тех ссылок, чьи советы недоступны из указанного коммита (HEAD, если не указан), несовместимо с &lt;code&gt;--merged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3045719971c55f87c34a7fd746215fdcca5bdb6" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d24af2a09941026de883e7412997a62ab6d500" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">Список только тех ссылок, советы которых доступны из указанного коммита (HEAD, если не указан), несовместимых с &lt;code&gt;--no-merged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba8f796a110a2bce3b3362030f4149e3e571d92d" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817a4e30ee524e4266621c0a4648ab3909ffeed4" translate="yes" xml:space="preserve">
          <source>Only list tags of the given object (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">Только перечислить теги данного объекта (HEAD, если не указан). Подразумевает &lt;code&gt;--list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83f1d08e3476b4b0f43eedc9885a23e56ff396f3" translate="yes" xml:space="preserve">
          <source>Only list tags which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">Список только тегов, которые содержат указанную фиксацию (HEAD, если не указан). Подразумевает &lt;code&gt;--list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bae480f98a8915919a61381cb993558ff75823a" translate="yes" xml:space="preserve">
          <source>Only list tags which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">Список только тегов, которые не содержат указанную фиксацию (HEAD, если не указан). Подразумевает &lt;code&gt;--list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db9714bdab86b2c5263129a27ca40bb06f5dcdf2" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">Список только тегов, коммиты которых недоступны из указанного коммита ( &lt;code&gt;HEAD&lt;/code&gt; , если не указан), несовместимо с &lt;code&gt;--merged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0941b6737a5c9cc5d8d6c699e027514c86f27e53" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c62aa2054943bc2c5749c5693c2757ab8e53449" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">Список только тегов, коммиты которых достижимы из указанного коммита ( &lt;code&gt;HEAD&lt;/code&gt; , если не указан), несовместимых с &lt;code&gt;--no-merged&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc01884094a83344ad50773c56388f9731a753fa" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0cdb0cde0c40de0beaaced5d658f2a7018630fe" translate="yes" xml:space="preserve">
          <source>Only look at the history which touches the given subdirectory. The result will contain that directory (and only that) as its project root. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="translated">Посмотрите только на историю, которая касается данного подкаталога. Результат будет содержать этот каталог (и только он) в качестве корня проекта. Подразумевает &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;переназначение на предка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2bbdf47a64eee45ee95696813788d11863c01152" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; смысл только в режиме --parseopt . Позволяет синтаксическому анализатору параметров останавливаться на первом аргументе, не являющемся параметром. Это можно использовать для анализа подкоманд, которые сами принимают параметры.</target>
        </trans-unit>
        <trans-unit id="d8057f98f6fd66c86adb34f091c531e316f7ca42" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Output the options in their long form if available, and with their arguments stuck.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; смысл только в режиме --parseopt . Выведите варианты в их развернутой форме, если они доступны, и с закрепленными аргументами.</target>
        </trans-unit>
        <trans-unit id="6000fe90599266e72e627572d6cdbc969916ee02" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Tells the option parser to echo out the first &lt;code&gt;--&lt;/code&gt; met instead of skipping it.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; смысл только в режиме --parseopt . Сообщает параметр анализатор эхо из первого &lt;code&gt;--&lt;/code&gt; встретился вместо того , чтобы пропускать его.</target>
        </trans-unit>
        <trans-unit id="fd3f5d99fba63ca8e5d281298074650f7e9548b0" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--verify&lt;/code&gt; mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success.</source>
          <target state="translated">Имеет смысл только в режиме &lt;code&gt;--verify&lt;/code&gt; . Не выводите сообщение об ошибке, если первый аргумент не является допустимым именем объекта; вместо этого выйдите с ненулевым статусом молча. SHA-1 для допустимых имен объектов выводятся на стандартный вывод в случае успеха.</target>
        </trans-unit>
        <trans-unit id="94590902338d0f64df58223a7c9238b6579f4aae" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--pathspec-from-file&lt;/code&gt;. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).</source>
          <target state="translated">&lt;code&gt;--pathspec-from-file&lt;/code&gt; смысл только с --pathspec-from-file . Элементы Pathspec разделяются символом NUL, а все остальные символы воспринимаются буквально (включая символы новой строки и кавычки).</target>
        </trans-unit>
        <trans-unit id="0ecebefb0a1162c42954005e600970eacea40ab1" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt; or &lt;code&gt;--index-info&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; смысл только с --stdin или &lt;code&gt;--index-info&lt;/code&gt; ; пути разделяются символом NUL вместо LF.</target>
        </trans-unit>
        <trans-unit id="6ad4315a7f6c11660aa6c643c4b95eaab7a8d728" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; смысл только с --stdin ; пути разделяются символом NUL вместо LF.</target>
        </trans-unit>
        <trans-unit id="2ebb91d27792ee23446f1d49f12e2e8cf850fef7" translate="yes" xml:space="preserve">
          <source>Only necessary if --compose is also set. If --compose is not set, this will be prompted for.</source>
          <target state="translated">Это необходимо только в том случае,если также настроен -состав.Если параметр -состав не установлен,будет выдан запрос.</target>
        </trans-unit>
        <trans-unit id="3a2cfa8e4dfa7576e427c217c4a335798a141827" translate="yes" xml:space="preserve">
          <source>Only one parameter should be set to &quot;1&quot; when the hook runs. The hook running passing &quot;1&quot;, &quot;1&quot; should not be possible.</source>
          <target state="translated">Только один параметр должен быть установлен на &quot;1&quot;,когда крючок работает.Прохождение крюка через &quot;1&quot;,&quot;1&quot; не должно быть возможным.</target>
        </trans-unit>
        <trans-unit id="bf7e12b67481a70907ee19a1cd34bdb9c2cfbcbb" translate="yes" xml:space="preserve">
          <source>Only output exact matches (a tag directly references the supplied commit). This is a synonym for --candidates=0.</source>
          <target state="translated">Выводить только точные совпадения (тэг напрямую ссылается на поставляемый коммит).Это синоним для --candidates=0.</target>
        </trans-unit>
        <trans-unit id="16dbfb260245eaec3998212f13b1a52e2d286e0a" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be exported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">Будут экспортированы только метки p4, соответствующие этому регулярному выражению. Значение по умолчанию - &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eeb8bb30ea7ba21536e78e1ff49007a02268174b" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be imported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">Будут импортированы только метки p4, соответствующие этому регулярному выражению. Значение по умолчанию - &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2fdb861f4cc24f6e2448e8ab0d3c248ec24997f" translate="yes" xml:space="preserve">
          <source>Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using &lt;code&gt;--untracked-cache&lt;/code&gt; or &lt;code&gt;--force-untracked-cache&lt;/code&gt; or the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed.</source>
          <target state="translated">Выполняйте тесты только в рабочем каталоге, чтобы убедиться, что можно использовать неотслеживаемый кеш. Вам необходимо вручную включить неотслеживаемый кеш, используя &lt;code&gt;--untracked-cache&lt;/code&gt; или &lt;code&gt;--force-untracked-cache&lt;/code&gt; или &lt;code&gt;core.untrackedCache&lt;/code&gt; конфигурации core.untrackedCache, если вы действительно хотите ее использовать. Если тест не проходит, код выхода равен 1, а сообщение объясняет, что не работает должным образом, в противном случае код выхода равен 0 и печатается ОК.</target>
        </trans-unit>
        <trans-unit id="9b88e48a96d98ad3b76de8b5d274db692fc6b29c" translate="yes" xml:space="preserve">
          <source>Only print error and warning messages; all other output will be suppressed.</source>
          <target state="translated">Печатайте только сообщения об ошибках и предупреждения;все остальные выходные данные будут подавлены.</target>
        </trans-unit>
        <trans-unit id="3791d8648f923430d0795b4e9f5031ac211bf7f1" translate="yes" xml:space="preserve">
          <source>Only print error messages.</source>
          <target state="translated">Печатайте только сообщения об ошибках.</target>
        </trans-unit>
        <trans-unit id="affbeb73b1dd267a08167d9ea74afe477ad3529f" translate="yes" xml:space="preserve">
          <source>Only show the SHA-1 hash, not the reference name. When combined with --dereference the dereferenced tag will still be shown after the SHA-1.</source>
          <target state="translated">Покажите только SHA-1 хэш,а не ссылочное имя.При объединении с --dereference разыменованная метка все равно будет показана после SHA-1.</target>
        </trans-unit>
        <trans-unit id="74a12c610ac9d71beb7074574ccb847224f9f712" translate="yes" xml:space="preserve">
          <source>Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument &lt;code&gt;unsorted&lt;/code&gt; is given, the commits are shown in the order they were given on the command line. Otherwise (if &lt;code&gt;sorted&lt;/code&gt; or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with &lt;code&gt;--graph&lt;/code&gt;.</source>
          <target state="translated">Показывать только данные коммиты, но не пересекать их предков. Это не действует, если указан диапазон. Если указан аргумент без &lt;code&gt;unsorted&lt;/code&gt; , коммиты отображаются в том порядке, в котором они были указаны в командной строке. В противном случае (если &lt;code&gt;sorted&lt;/code&gt; или аргумент не задан), фиксации отображаются в обратном хронологическом порядке по времени фиксации. Не может сочетаться с &lt;code&gt;--graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ed956e65db38a49fac1dac50248e7edb1c43fb7" translate="yes" xml:space="preserve">
          <source>Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be removed from the work tree, as their repository lives inside the .git directory of the superproject. If a submodule (or one of those nested inside it) still uses a .git directory, &lt;code&gt;git rm&lt;/code&gt; will move the submodules git directory into the superprojects git directory to protect the submodule&amp;rsquo;s history. If it exists the submodule.&amp;lt;name&amp;gt; section in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file will also be removed and that file will be staged (unless --cached or -n are used).</source>
          <target state="translated">Только подмодули, использующие gitfile (что означает, что они были клонированы с версией Git 1.7.8 или новее), будут удалены из рабочего дерева, поскольку их репозиторий находится внутри каталога .git суперпроекта. Если подмодуль (или один из вложенных в него) по-прежнему использует каталог .git, &lt;code&gt;git rm&lt;/code&gt; переместит каталог git подмодулей в каталог git суперпроектов для защиты истории подмодуля. Если он существует, раздел &lt;a href=&quot;gitmodules&quot;&gt;submodule&lt;/a&gt; . &amp;lt;name&amp;gt; в файле gitmodules [5] также будет удален, и этот файл будет поставлен (если не используются --cached или -n).</target>
        </trans-unit>
        <trans-unit id="f3b6918bb732fd2722633a305233dd0ec34bff15" translate="yes" xml:space="preserve">
          <source>Only takes effect for dates shown in human-readable format, such as when using &lt;code&gt;--pretty&lt;/code&gt;. &lt;code&gt;log.date&lt;/code&gt; config variable sets a default value for the log command&amp;rsquo;s &lt;code&gt;--date&lt;/code&gt; option. By default, dates are shown in the original time zone (either committer&amp;rsquo;s or author&amp;rsquo;s). If &lt;code&gt;-local&lt;/code&gt; is appended to the format (e.g., &lt;code&gt;iso-local&lt;/code&gt;), the user&amp;rsquo;s local time zone is used instead.</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; только для дат, отображаемых в удобочитаемом формате, например, при использовании --pretty . &lt;code&gt;log.date&lt;/code&gt; конфигурации log.date устанавливает значение по умолчанию для параметра &lt;code&gt;--date&lt;/code&gt; команды журнала . По умолчанию даты отображаются в исходном часовом поясе (либо коммиттера, либо автора). Если к формату добавлено &lt;code&gt;-local&lt;/code&gt; (например, &lt;code&gt;iso-local&lt;/code&gt; ), вместо этого используется местный часовой пояс пользователя.</target>
        </trans-unit>
        <trans-unit id="28227446e42814d459bad1017137f194a3d411bf" translate="yes" xml:space="preserve">
          <source>Only the initial ref advertisement is output, and the program exits immediately. This fits with the HTTP GET request model, where no request content is received but a response must be produced.</source>
          <target state="translated">Выводится только первоначальная реклама рефлексии,и программа немедленно выходит из программы.Это соответствует модели HTTP GET запроса,где не получается содержимое запроса,но должен быть получен ответ.</target>
        </trans-unit>
        <trans-unit id="d70e32ee66c9f176a2ec41ee4464e248b98de054" translate="yes" xml:space="preserve">
          <source>Only the rev_map and refs/remotes/git-svn are changed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details). Follow &lt;code&gt;reset&lt;/code&gt; with a &lt;code&gt;fetch&lt;/code&gt; and then &lt;code&gt;git reset&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; to move local branches onto the new tree.</source>
          <target state="translated">Изменяются только rev_map и refs / remotes / git-svn (подробности см. В &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; В разделе ФАЙЛЫ ниже). Выполните &lt;code&gt;reset&lt;/code&gt; с помощью &lt;code&gt;fetch&lt;/code&gt; а затем &lt;code&gt;git reset&lt;/code&gt; или &lt;code&gt;git rebase&lt;/code&gt; , чтобы переместить локальные ветви в новое дерево.</target>
        </trans-unit>
        <trans-unit id="32e7b8a674c1b57420afbf6e783864cc587eae94" translate="yes" xml:space="preserve">
          <source>Only the selected commits are shown, plus some to have a meaningful history.</source>
          <target state="translated">Показываются только выбранные коммиты,плюс некоторые для того,чтобы иметь осмысленную историю.</target>
        </trans-unit>
        <trans-unit id="5988bcb17bfff8bdefbf4f11c653c30a84ac354c" translate="yes" xml:space="preserve">
          <source>Only untracked files in submodules will be ignored. Committed differences and modifications to tracked files will show up.</source>
          <target state="translated">Только неотслеживаемые файлы в подмодулях будут проигнорированы.Появятся зафиксированные различия и модификации отслеживаемых файлов.</target>
        </trans-unit>
        <trans-unit id="a35d5f8b7ffccc1327ae3b4b170fadaf17be62a8" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how 'cp -R' would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to 'rsync --delete'.</source>
          <target state="translated">Обновляйте и добавляйте файлы только в рабочий каталог, но не удаляйте их, подобно тому, как 'cp -R' обновляет содержимое в целевом каталоге. Это режим по умолчанию при &lt;a href=&quot;#def_checkout&quot;&gt;извлечении&lt;/a&gt; файлов из &lt;a href=&quot;#def_index&quot;&gt;индекса&lt;/a&gt; или &lt;a href=&quot;#def_tree-ish&quot;&gt;дерева&lt;/a&gt; . В отличие от этого, режим без наложения также удаляет отслеживаемые файлы, отсутствующие в источнике, аналогично rsync --delete.</target>
        </trans-unit>
        <trans-unit id="a09a6feef23c1bf8bf8489c07fa754b0e3467e64" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how &lt;code&gt;cp -R&lt;/code&gt; would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to &lt;code&gt;rsync --delete&lt;/code&gt;.</source>
          <target state="translated">Обновляйте и добавляйте файлы только в рабочий каталог, но не удаляйте их, подобно тому, как &lt;code&gt;cp -R&lt;/code&gt; обновит содержимое в целевом каталоге. Это режим по умолчанию при &lt;a href=&quot;#def_checkout&quot;&gt;извлечении&lt;/a&gt; файлов из &lt;a href=&quot;#def_index&quot;&gt;индекса&lt;/a&gt; или &lt;a href=&quot;#def_tree-ish&quot;&gt;дерева&lt;/a&gt; . В отличие от этого режим без наложения также удаляет отслеживаемые файлы, отсутствующие в источнике, аналогично &lt;code&gt;rsync --delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd6ac5160ec46e3d1df2371d183d50a5e06ffdbe" translate="yes" xml:space="preserve">
          <source>Only use refs whose names match a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, use refs whose names match any of the given shell patterns. Use &lt;code&gt;--no-refs&lt;/code&gt; to clear any previous ref patterns given.</source>
          <target state="translated">Используйте только те ссылки, имена которых соответствуют заданному шаблону оболочки. Шаблон может быть одним из имени ветки, имени тега или полного имени ссылки. Если указано несколько раз, используйте ссылки, имена которых соответствуют любому из заданных шаблонов оболочки. Используйте &lt;code&gt;--no-refs&lt;/code&gt; , чтобы очистить все предыдущие заданные шаблоны ссылок.</target>
        </trans-unit>
        <trans-unit id="2d533153e7612cafa4bc7b83b50dd3abb697af0e" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;set-tree&lt;/code&gt; and &lt;code&gt;commit-diff&lt;/code&gt; commands.</source>
          <target state="translated">Используется только с &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;set-tree&lt;/code&gt; и &lt;code&gt;commit-diff&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="901e1e4a237282bb48e582bb5bf0599881cd0084" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;init&lt;/code&gt; command. These are passed directly to &lt;code&gt;git init&lt;/code&gt;.</source>
          <target state="translated">Используется только с командой &lt;code&gt;init&lt;/code&gt; . Они передаются непосредственно в &lt;code&gt;git init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5e61001de0ada8f2eb5dc9bbc0a16644112482b" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;set-tree&lt;/code&gt; command.</source>
          <target state="translated">Используется только с командой &lt;code&gt;set-tree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e227b5617ca7c2b377054ab1d12644a8cc591504" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--filter=&lt;/code&gt;; prints a list of the objects omitted by the filter. Object IDs are prefixed with a &amp;ldquo;~&amp;rdquo; character.</source>
          <target state="translated">Полезно только с &lt;code&gt;--filter=&lt;/code&gt; ; печатает список объектов, пропущенных фильтром. Идентификаторы объектов начинаются с символа &amp;laquo;~&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c898c5ecedbff05a6572c10f50d4d5872a590271" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; does not print the names of the object IDs that are found. This inverts &lt;code&gt;--object-names&lt;/code&gt;. This flag allows the output to be more easily parsed by commands such as &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;.</source>
          <target state="translated">Полезно только с &lt;code&gt;--objects&lt;/code&gt; ; не печатает имена найденных идентификаторов объектов. Это инвертирует &lt;code&gt;--object-names&lt;/code&gt; . Этот флаг позволяет более легко анализировать вывод такими командами, как &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbbf115261d96b04c5005e948b7d150b4779f83e" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the names of the object IDs that are found. This is the default behavior.</source>
          <target state="translated">Полезно только с &lt;code&gt;--objects&lt;/code&gt; ; вывести имена найденных идентификаторов объектов. Это поведение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="96aa4c0ed29b4ff25b67f82110d672c478c9f0a4" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the object IDs that are not in packs.</source>
          <target state="translated">Полезно только с &lt;code&gt;--objects&lt;/code&gt; ; распечатать идентификаторы объектов, которых нет в пачках.</target>
        </trans-unit>
        <trans-unit id="395c9938b3e2e6eaf4d1417f6499451782d5fa84" translate="yes" xml:space="preserve">
          <source>Only useful with one of the &lt;code&gt;--objects*&lt;/code&gt;; omits objects (usually blobs) from the list of printed objects. The &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; may be one of the following:</source>
          <target state="translated">Полезно только с одним из &lt;code&gt;--objects*&lt;/code&gt; ; исключает объекты (обычно капли) из списка печатаемых объектов. &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; может быть одним из следующих:</target>
        </trans-unit>
        <trans-unit id="c55263ee2e693cf4a68e8c688a3aeedef8c016f1" translate="yes" xml:space="preserve">
          <source>Only valid setting is &quot;--unified=??&quot; or &quot;-u??&quot; to set the number of context lines shown when a unified diff is created. This takes precedence over any &quot;-U&quot; or &quot;--unified&quot; option value passed on the Git diff command line.</source>
          <target state="translated">Действительна только настройка &quot;--unified=??&quot; или &quot;-u??&quot; для установки количества контекстных строк,отображаемых при создании унифицированного различия.Это имеет приоритет над любым значением опции &quot;-U&quot; или &quot;--unified&quot;,переданным в командной строке Git'а diff.</target>
        </trans-unit>
        <trans-unit id="77fb8a535dafe4973135cbd89eaf06e8f07b4529" translate="yes" xml:space="preserve">
          <source>Only works if the changes (patch IDs based on the diff contents) on &lt;code&gt;subsystem&lt;/code&gt; are literally the same before and after the rebase &lt;code&gt;subsystem&lt;/code&gt; did.</source>
          <target state="translated">Работает только в том случае, если изменения (идентификаторы патчей на основе содержимого diff) в &lt;code&gt;subsystem&lt;/code&gt; буквально одинаковы до и после того, как &lt;code&gt;subsystem&lt;/code&gt; rebase сделала.</target>
        </trans-unit>
        <trans-unit id="5a64b44f8d7042d0b4832141c36a7e5d8d6c4434" translate="yes" xml:space="preserve">
          <source>Oops. That wasn&amp;rsquo;t very readable. It just spit out its own internal version of a &lt;code&gt;diff&lt;/code&gt;, but that internal version really just tells you that it has noticed that &quot;hello&quot; has been modified, and that the old object contents it had have been replaced with something else.</source>
          <target state="translated">К сожалению. Это было не очень удобно для чтения. Он просто выплевывает свою собственную внутреннюю версию &lt;code&gt;diff&lt;/code&gt; , но эта внутренняя версия на самом деле просто говорит вам, что она заметила, что &quot;hello&quot; было изменено, и что старое содержимое объекта было заменено чем-то другим.</target>
        </trans-unit>
        <trans-unit id="0e55d62611877e337f8aa065fb0b3d20e9fe0e5a" translate="yes" xml:space="preserve">
          <source>Open a compose window and click the external editor icon.</source>
          <target state="translated">Откройте окно компоновки и нажмите на иконку внешнего редактора.</target>
        </trans-unit>
        <trans-unit id="db4ff8c108e7b94773be0de613a7b629cb1df8fa" translate="yes" xml:space="preserve">
          <source>Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. &lt;code&gt;format-patch&lt;/code&gt;, &lt;code&gt;request-pull&lt;/code&gt;, and &lt;code&gt;merge&lt;/code&gt; (if enabled)). Multi-line explanations may be used.</source>
          <target state="translated">Откройте редактор и отредактируйте текст, чтобы объяснить, для чего предназначена ветвь, которая будет использоваться различными другими командами (например, &lt;code&gt;format-patch&lt;/code&gt; , &lt;code&gt;request-pull&lt;/code&gt; и &lt;code&gt;merge&lt;/code&gt; (если включено)). Могут использоваться многострочные пояснения.</target>
        </trans-unit>
        <trans-unit id="577c09c011d74bfddaa145d1c3817d3d9900cb19" translate="yes" xml:space="preserve">
          <source>Open the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index.</source>
          <target state="translated">Откройте diff vs.the index в редакторе и дайте пользователю возможность его отредактировать.После закрытия редактора отрегулируйте заголовки взлома и наложите заплатку на индекс.</target>
        </trans-unit>
        <trans-unit id="1e40bc8b6fc685aae183dd5f07e4256cd3e46abe" translate="yes" xml:space="preserve">
          <source>Open the matching files in the pager (not the output of &lt;code&gt;grep&lt;/code&gt;). If the pager happens to be &quot;less&quot; or &quot;vi&quot;, and the user specified only one pattern, the first file is positioned at the first match automatically. The &lt;code&gt;pager&lt;/code&gt; argument is optional; if specified, it must be stuck to the option without a space. If &lt;code&gt;pager&lt;/code&gt; is unspecified, the default pager will be used (see &lt;code&gt;core.pager&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Откройте соответствующие файлы в пейджере (не в выводе &lt;code&gt;grep&lt;/code&gt; ). Если пейджер оказался &amp;laquo;меньше&amp;raquo; или &amp;laquo;vi&amp;raquo;, и пользователь указал только один шаблон, первый файл автоматически помещается в первое совпадение. &lt;code&gt;pager&lt;/code&gt; аргумент является необязательным; если указано, он должен быть прикреплен к опции без пробела. Если &lt;code&gt;pager&lt;/code&gt; не &lt;code&gt;core.pager&lt;/code&gt; будет использоваться пейджер по умолчанию (см. Core.pager в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8ab75f225f79420c5b860ca24bd40f7491c784f1" translate="yes" xml:space="preserve">
          <source>Opens an editor to modify the specified config file; either &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, or repository (default).</source>
          <target state="translated">Открывает редактор для изменения указанного файла конфигурации; либо &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , либо репозиторий (по умолчанию).</target>
        </trans-unit>
        <trans-unit id="869e0439c9b6be4fa4547f64fcc46a677445443d" translate="yes" xml:space="preserve">
          <source>Operate quietly. Implies --no-progress.</source>
          <target state="translated">Работайте тихо.Подразумевает...непрогресс.</target>
        </trans-unit>
        <trans-unit id="976297b1ff380abe9b067b3a1569ff64fe97ece7" translate="yes" xml:space="preserve">
          <source>Operate quietly. Progress is not reported to the standard error stream.</source>
          <target state="translated">Работайте тихо.Прогресс не сообщается в стандартном потоке ошибок.</target>
        </trans-unit>
        <trans-unit id="09f22e6b29a644f35840ab8527beed58937c2452" translate="yes" xml:space="preserve">
          <source>Operating modes</source>
          <target state="translated">Режимы работы</target>
        </trans-unit>
        <trans-unit id="b5ddf3c63568d76ebc23d453be7fdb731eb8db1b" translate="yes" xml:space="preserve">
          <source>Operation Modes</source>
          <target state="translated">Режимы работы</target>
        </trans-unit>
        <trans-unit id="7196d0b4f156df0cb7286af7737967727f46300d" translate="yes" xml:space="preserve">
          <source>Operation modes</source>
          <target state="translated">Режимы работы</target>
        </trans-unit>
        <trans-unit id="1bc69d57cbb59ff5bdbc63f455c23bce178e5e54" translate="yes" xml:space="preserve">
          <source>Operations supported</source>
          <target state="translated">Поддерживаемые операции</target>
        </trans-unit>
        <trans-unit id="573db325843d7fd90adea414c1ffec090ab48249" translate="yes" xml:space="preserve">
          <source>Optimize a pack that will be provided to a client with a shallow repository. This option, combined with --thin, can result in a smaller pack at the cost of speed.</source>
          <target state="translated">Оптимизация пакета,который будет предоставляться клиенту с неглубоким репозиторием.Эта опция,в сочетании с --thin,может привести к меньшему по скорости пакету.</target>
        </trans-unit>
        <trans-unit id="4679da9817f2d593d1926870257534b31ee86cfa" translate="yes" xml:space="preserve">
          <source>Option commands must be the first commands on the input (not counting feature commands), to give an option command after any non-option command is an error.</source>
          <target state="translated">Команды опции должны быть первыми командами на входе (не считая команд функции),чтобы дать команду опции после того,как любая команда без опции является ошибкой.</target>
        </trans-unit>
        <trans-unit id="da44303dd559700c5ce39d2667eb27c2885407ef" translate="yes" xml:space="preserve">
          <source>Optional &amp;lt;path&amp;gt; arguments limit which submodules will be initialized. If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized.</source>
          <target state="translated">Необязательные аргументы &amp;lt;path&amp;gt; ограничивают то, какие подмодули будут инициализированы. Если не указан путь и настроен submodule.active, будут инициализированы подмодули, настроенные как активные, в противном случае инициализируются все подмодули.</target>
        </trans-unit>
        <trans-unit id="e95e402b64c3c594a37117914c5cb87d814b2b44" translate="yes" xml:space="preserve">
          <source>Optional modifiers can be provided in the beginning of the value to filter commands for specific actions: create (a), modify (m), delete (d). A &lt;code&gt;!&lt;/code&gt; can be included in the modifiers to negate the reference prefix entry. E.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be215efb6b35fec1e17ea79655a45bba1595ca40" translate="yes" xml:space="preserve">
          <source>Optionally a new branch could be created with either &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, automatically from a remote branch of same name (see &lt;code&gt;--guess&lt;/code&gt;), or detach the working tree from any branch with &lt;code&gt;--detach&lt;/code&gt;, along with switching.</source>
          <target state="translated">При желании новую ветвь можно создать с помощью &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , автоматически из удаленной ветки с тем же именем (см. &lt;code&gt;--guess&lt;/code&gt; ), или отсоединить рабочее дерево от любой ветки с помощью &lt;code&gt;--detach&lt;/code&gt; вместе с переключением.</target>
        </trans-unit>
        <trans-unit id="d773dc6382eb3328de30b1c7224e0be840082992" translate="yes" xml:space="preserve">
          <source>Optionally may output a &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; line indicating the full path of a file under &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; which is keeping a pack until refs can be suitably updated. The path must end with &lt;code&gt;.keep&lt;/code&gt;. This is a mechanism to name a &amp;lt;pack,idx,keep&amp;gt; tuple by giving only the keep component. The kept pack will not be deleted by a concurrent repack, even though its objects may not be referenced until the fetch completes. The &lt;code&gt;.keep&lt;/code&gt; file will be deleted at the conclusion of the fetch.</source>
          <target state="translated">При желании можно вывести строку &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; указывающую полный путь к файлу в &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; который хранит пакет до тех пор, пока ссылки не будут обновлены соответствующим образом. Путь должен заканчиваться на &lt;code&gt;.keep&lt;/code&gt; . Это механизм для присвоения имени кортежу &amp;lt;pack, idx, keep&amp;gt; путем предоставления только компонента keep. Сохраненный пакет не будет удален параллельной переупаковкой, даже если на его объекты нельзя ссылаться до завершения выборки. По &lt;code&gt;.keep&lt;/code&gt; файл .keep будет удален.</target>
        </trans-unit>
        <trans-unit id="66770b44a484bf62b3beb74f057263164da82747" translate="yes" xml:space="preserve">
          <source>Optionally with -m:</source>
          <target state="translated">Опционально с -м:</target>
        </trans-unit>
        <trans-unit id="3e5a4f0fcbf7c88862ec022584d8faedebb202bf" translate="yes" xml:space="preserve">
          <source>Optionally, a &amp;lt;ref&amp;gt; parameter can be prefixed with a plus &lt;code&gt;+&lt;/code&gt; sign to disable the fast-forward check only on that ref.</source>
          <target state="translated">По желанию, параметр &amp;lt;ref&amp;gt; может иметь префикс со знаком плюс &lt;code&gt;+&lt;/code&gt; , чтобы отключить проверку перемотки вперед только для этого ref.</target>
        </trans-unit>
        <trans-unit id="5ad18880dec3737f40f1be35d71296de89bc6175" translate="yes" xml:space="preserve">
          <source>Optionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the &lt;code&gt;-m&lt;/code&gt; flag. When used with &lt;code&gt;-m&lt;/code&gt;, the &lt;code&gt;-u&lt;/code&gt; flag causes it to also update the files in the work tree with the result of the merge.</source>
          <target state="translated">По желанию, он может объединить дерево в индекс, выполнить быстрое (т.е. двухстороннее) объединение или трехстороннее объединение с флагом &lt;code&gt;-m&lt;/code&gt; . При использовании с &lt;code&gt;-m&lt;/code&gt; , то &lt;code&gt;-u&lt;/code&gt; флаг заставляет его также обновлять файлы в рабочем дереве с результатом слияния.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="c844411e7897e1475e2bbc7e1cd47d6ca3b70b75" translate="yes" xml:space="preserve">
          <source>Options for --parseopt</source>
          <target state="translated">Опции для -партнёрства</target>
        </trans-unit>
        <trans-unit id="9c25d7f1531501faea711b1933ac2734dd8f1324" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">Варианты &lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7eec6c07b2d8ff28d282e8d3918c0430dfd638ff" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;expire&lt;/code&gt;</source>
          <target state="translated">Варианты &lt;code&gt;expire&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e73b9df34672d383e318c543fe1ed5467baa2316" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;show&lt;/code&gt;</source>
          <target state="translated">Варианты для &lt;code&gt;show&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcc02e852676cd8c1162b2b42e5759f86fcae990" translate="yes" xml:space="preserve">
          <source>Options for Files</source>
          <target state="translated">Опции для файлов</target>
        </trans-unit>
        <trans-unit id="fd6ce8b428a235dff74127968e45c8e950a3e68b" translate="yes" xml:space="preserve">
          <source>Options for Filtering</source>
          <target state="translated">Опции для фильтрации</target>
        </trans-unit>
        <trans-unit id="f0e43560a9524e814096613f5d3adbb780ab9547" translate="yes" xml:space="preserve">
          <source>Options for Frontends</source>
          <target state="translated">Опции для Frontends</target>
        </trans-unit>
        <trans-unit id="6de07b5e7d3355f1ee784587e4e9b9310ce89167" translate="yes" xml:space="preserve">
          <source>Options for Objects</source>
          <target state="translated">Опции для объектов</target>
        </trans-unit>
        <trans-unit id="7bba8ce1354b61b02f672f2468b0b0f0c600077c" translate="yes" xml:space="preserve">
          <source>Options for Output</source>
          <target state="translated">Опции для выхода</target>
        </trans-unit>
        <trans-unit id="b8bceb2d83c081f4f5d71559b2d0f07edc9ee034" translate="yes" xml:space="preserve">
          <source>Options for a credential context can be configured either in &lt;code&gt;credential.*&lt;/code&gt; (which applies to all credentials), or &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt;, where &amp;lt;url&amp;gt; matches the context as described above.</source>
          <target state="translated">Параметры для контекста учетных данных могут быть настроены либо в &lt;code&gt;credential.*&lt;/code&gt; (Что применяется ко всем учетным данным), либо в &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt; , Где &amp;lt;url&amp;gt; соответствует контексту, как описано выше.</target>
        </trans-unit>
        <trans-unit id="99e5139a65bfab6cb84777a431cb5c7403976793" translate="yes" xml:space="preserve">
          <source>Options related to fetching</source>
          <target state="translated">Опции,связанные с заборкой</target>
        </trans-unit>
        <trans-unit id="d96532d12a36cc4bb8cc0dcd0b87def47cb21823" translate="yes" xml:space="preserve">
          <source>Options related to merging</source>
          <target state="translated">Варианты,связанные с объединением</target>
        </trans-unit>
        <trans-unit id="d2ce95980d5d4dcb8790725834688357cc504679" translate="yes" xml:space="preserve">
          <source>Options with long option names can be negated by prefixing &lt;code&gt;--no-&lt;/code&gt;. For example, &lt;code&gt;git branch&lt;/code&gt; has the option &lt;code&gt;--track&lt;/code&gt; which is &lt;code&gt;on&lt;/code&gt; by default. You can use &lt;code&gt;--no-track&lt;/code&gt; to override that behaviour. The same goes for &lt;code&gt;--color&lt;/code&gt; and &lt;code&gt;--no-color&lt;/code&gt;.</source>
          <target state="translated">Опции с длинными именами могут быть &lt;code&gt;--no-&lt;/code&gt; помощью префикса --no- . Например, &lt;code&gt;git branch&lt;/code&gt; имеет опцию &lt;code&gt;--track&lt;/code&gt; , которая &lt;code&gt;on&lt;/code&gt; умолчанию. Вы можете использовать &lt;code&gt;--no-track&lt;/code&gt; , чтобы переопределить это поведение. То же самое касается &lt;code&gt;--color&lt;/code&gt; и &lt;code&gt;--no-color&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28e5f716aa8e690cf7323a0d5515626aac785807" translate="yes" xml:space="preserve">
          <source>Or if you are looking for the commit that fixed a bug, you might use</source>
          <target state="translated">Или если вы ищете коммит,который исправил ошибку,вы можете использовать</target>
        </trans-unit>
        <trans-unit id="9bcee5b07c3eb51996fe06466cb572259d48e74e" translate="yes" xml:space="preserve">
          <source>Or if you want more control, you can inspect the current state using for example &quot;git bisect visualize&quot;. It will launch gitk (or &quot;git log&quot; if the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set) to help you find a better bisection point.</source>
          <target state="translated">Или, если вам нужен больший контроль, вы можете проверить текущее состояние, используя, например, &amp;laquo;git bisect visualize&amp;raquo;. Он запустит gitk (или &quot;git log&quot;, если переменная среды &lt;code&gt;DISPLAY&lt;/code&gt; не установлена), чтобы помочь вам найти лучшую точку деления пополам.</target>
        </trans-unit>
        <trans-unit id="ee046ba1657a42f0c8096ff30555d679415a486a" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;&amp;hellip;​&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="translated">Или вы могли бы вспомнить , что &lt;code&gt;&amp;hellip;​&lt;/code&gt; оператор выбирает все коммиты достижимые из любой одной ссылки или другой , но не оба; так</target>
        </trans-unit>
        <trans-unit id="9af1a9bbcb80d3a49080e3a67d92d5ab7f0cace1" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;...&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85642c3d553b535f4731e23589126805881407c" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve already committed the merge that you want to throw away,</source>
          <target state="translated">Или, если вы уже совершили слияние, которое хотите выбросить,</target>
        </trans-unit>
        <trans-unit id="7ec7c556c34b1673fc7046a255bf7eb40c6a1622" translate="yes" xml:space="preserve">
          <source>Or, prepare and create the commit in one step:</source>
          <target state="translated">Или,подготовьте и создайте коммит за один шаг:</target>
        </trans-unit>
        <trans-unit id="6d9770079506b18bb9154a95e976f54ab47a2b44" translate="yes" xml:space="preserve">
          <source>Ordinary changed entries have the following format:</source>
          <target state="translated">Обычно изменяемые записи имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="789d55cf79d409acbcc0305ff19dbfa36d82a93d" translate="yes" xml:space="preserve">
          <source>Ordinary commits are only included if they are !TREESAME (though this can be changed, see &lt;code&gt;--sparse&lt;/code&gt; below).</source>
          <target state="translated">Обычные коммиты включаются, только если они есть! TREESAME (хотя это можно изменить, см. &lt;code&gt;--sparse&lt;/code&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="3b945495727bab8a02c63542fdf26a485a2839f4" translate="yes" xml:space="preserve">
          <source>Original (version 1) pack-*.idx files have the following format:</source>
          <target state="translated">Оригинальные (версия 1)файлы pack-*.idx имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="cd07568ac3f8fe8b9f1ca323e6aea33ce69f4d0c" translate="yes" xml:space="preserve">
          <source>Originally, &lt;code&gt;git svn&lt;/code&gt; recommended that developers pulled or merged from the &lt;code&gt;git svn&lt;/code&gt; branch. This was because the author favored &lt;code&gt;git svn set-tree B&lt;/code&gt; to commit a single head rather than the &lt;code&gt;git svn set-tree A..B&lt;/code&gt; notation to commit multiple commits. Use of &lt;code&gt;git pull&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; with &lt;code&gt;git svn set-tree A..B&lt;/code&gt; will cause non-linear history to be flattened when committing into SVN and this can lead to merge commits unexpectedly reversing previous commits in SVN.</source>
          <target state="translated">Первоначально &lt;code&gt;git svn&lt;/code&gt; рекомендовал разработчикам извлечь или слить из ветки &lt;code&gt;git svn&lt;/code&gt; . Это произошло потому, что автор предпочел &lt;code&gt;git svn set-tree B&lt;/code&gt; для фиксации одной &lt;code&gt;git svn set-tree A..B&lt;/code&gt; нотацию git svn set-tree A..B для фиксации нескольких коммитов. Использование &lt;code&gt;git pull&lt;/code&gt; или &lt;code&gt;git merge&lt;/code&gt; с &lt;code&gt;git svn set-tree A..B&lt;/code&gt; приведет к сглаживанию нелинейной истории при фиксации в SVN, и это может привести к фиксации слияния, неожиданно отменяющей предыдущие фиксации в SVN.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="14bc34cb5d8d9f5a1986c4b4ced74a089ed31e83" translate="yes" xml:space="preserve">
          <source>Other &amp;lt;rev&amp;gt;^ Parent Shorthand Notations</source>
          <target state="translated">Другие &amp;lt;rev&amp;gt; ^ Родительские сокращенные обозначения</target>
        </trans-unit>
        <trans-unit id="a3c040aeed88ddd482d5dec178bd5bb0b940738f" translate="yes" xml:space="preserve">
          <source>Other Items</source>
          <target state="translated">Прочие предметы</target>
        </trans-unit>
        <trans-unit id="9cb6f2fb01dfa81e12bc1e11f0e7b676e54669fd" translate="yes" xml:space="preserve">
          <source>Other Options</source>
          <target state="translated">Другие опции</target>
        </trans-unit>
        <trans-unit id="b66b145fc26fc91268f852efc133debcedca1335" translate="yes" xml:space="preserve">
          <source>Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) suggest what refs/ namespace you may have wanted to push to.</source>
          <target state="translated">В будущем могут быть добавлены другие решения неоднозначности, но на данный момент в любых других случаях будет &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; ошибка с указанием того, что мы пробовали, и в зависимости от конфигурации advice.pushUnqualifiedRefname (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ) предлагает, какие ссылки / пространство имен вы возможно, хотел подтолкнуть.</target>
        </trans-unit>
        <trans-unit id="0d7c9916d5a97cfdd8b058afc3d1bac1c0a81b1f" translate="yes" xml:space="preserve">
          <source>Other arbitrary characters can also be encoded. For instance, &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; and &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; are equivalent.</source>
          <target state="translated">Также можно кодировать другие произвольные символы. Например, &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; и &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; эквивалентны.</target>
        </trans-unit>
        <trans-unit id="fca088ce123c6c3692799642c2a4b46b5050ca1e" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered invalid.</source>
          <target state="translated">Другие последовательные звездочки считаются недействительными.</target>
        </trans-unit>
        <trans-unit id="060f4f2bc2ee9b99f69af6360a0055db64443a39" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered regular asterisks and will match according to the previous rules.</source>
          <target state="translated">Другие последовательные звездочки считаются обычными звездочками и будут соответствовать предыдущим правилам.</target>
        </trans-unit>
        <trans-unit id="3c7b99f717eee9f16429ca9a79551f060c8f8236" translate="yes" xml:space="preserve">
          <source>Other diff formats</source>
          <target state="translated">Другие различные форматы</target>
        </trans-unit>
        <trans-unit id="81458045196e38ce4846b13cecf95d14abe58433" translate="yes" xml:space="preserve">
          <source>Other git-related tools may and do use their own variables. When inventing new variables for use in your own tool, make sure their names do not conflict with those that are used by Git itself and other popular tools, and describe them in your documentation.</source>
          <target state="translated">Другие инструменты,связанные с git'ом,могут использовать и используют свои собственные переменные.При изобретении новых переменных для использования в вашем собственном инструменте убедитесь,что их имена не конфликтуют с именами,используемыми самим Git'ом и другими популярными инструментами,и опишите их в вашей документации.</target>
        </trans-unit>
        <trans-unit id="97855915001e4fe7ef5deb1c023c4697931e633c" translate="yes" xml:space="preserve">
          <source>Other options are available to control how the manual page is displayed. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information, because &lt;code&gt;git --help ...&lt;/code&gt; is converted internally into &lt;code&gt;git
help ...&lt;/code&gt;.</source>
          <target state="translated">Доступны и другие параметры для управления отображением страницы руководства. См &lt;a href=&quot;git-help&quot;&gt;ГИТ-помощь [1]&lt;/a&gt; для получения дополнительной информации, потому что &lt;code&gt;git --help ...&lt;/code&gt; внутренне преобразуется в &lt;code&gt;git help ...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9c8373137a028157f66c53c01b431d29c570146" translate="yes" xml:space="preserve">
          <source>Other tools</source>
          <target state="translated">Другие инструменты</target>
        </trans-unit>
        <trans-unit id="89cbbb5c1b80969d7050a561dcd36c87c0241792" translate="yes" xml:space="preserve">
          <source>Other tools to fight regressions</source>
          <target state="translated">Другие инструменты для борьбы с регрессиями</target>
        </trans-unit>
        <trans-unit id="15219db000aadb43433107a930098d54a12a2bf5" translate="yes" xml:space="preserve">
          <source>Other types of dangling objects (blobs and trees) are also possible, and dangling objects can arise in other situations.</source>
          <target state="translated">Возможны и другие типы свисающих объектов (капли и деревья),а свисающие объекты могут возникать и в других ситуациях.</target>
        </trans-unit>
        <trans-unit id="a8ad1c87f168347a129392343ff35eecf4e32d0a" translate="yes" xml:space="preserve">
          <source>Other variables</source>
          <target state="translated">Другие переменные</target>
        </trans-unit>
        <trans-unit id="dd705eff4c453915d022538452adca45ea549424" translate="yes" xml:space="preserve">
          <source>Other ways</source>
          <target state="translated">Другие способы</target>
        </trans-unit>
        <trans-unit id="cf96d288cbee7ebb53d0ff80a9f63e5beaf8b0b4" translate="yes" xml:space="preserve">
          <source>Otherwise the remote branch of the first refspec is merged.</source>
          <target state="translated">В противном случае удаленная ветка первого refspec будет слита.</target>
        </trans-unit>
        <trans-unit id="32a9647b920b895ad400011726c72473bb775600" translate="yes" xml:space="preserve">
          <source>Otherwise, a tag reference that points directly at the given object (i.e., a lightweight tag) is created.</source>
          <target state="translated">В противном случае создается ссылка на метку,которая указывает непосредственно на данный объект (т.е.на легковесную метку).</target>
        </trans-unit>
        <trans-unit id="4b4eb603a71c26301f006805965a2bb224fe1a8d" translate="yes" xml:space="preserve">
          <source>Otherwise, all you need to do is start &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt;; it will listen on port 9418. By default, it will allow access to any directory that looks like a Git directory and contains the magic file git-daemon-export-ok. Passing some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments will further restrict the exports to those paths.</source>
          <target state="translated">В противном случае все, что вам нужно сделать, это запустить &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; ; он будет прослушивать порт 9418. По умолчанию он разрешает доступ к любому каталогу, который выглядит как каталог Git и содержит волшебный файл git-daemon-export-ok. Передача некоторых путей к каталогам в качестве аргументов &lt;code&gt;git daemon&lt;/code&gt; еще больше ограничит экспорт этими путями.</target>
        </trans-unit>
        <trans-unit id="83933e66c19657c277855328b7212d55be330b69" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;SSH_ASKPASS&lt;/code&gt; environment variable is set, its value is used as above.</source>
          <target state="translated">В противном случае, если &lt;code&gt;SSH_ASKPASS&lt;/code&gt; переменная среды SSH_ASKPASS , ее значение используется, как указано выше.</target>
        </trans-unit>
        <trans-unit id="06aca3f538987dd4baec5bd30c2c8ddce8b7736e" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;core.askPass&lt;/code&gt; configuration variable is set, its value is used as above.</source>
          <target state="translated">В противном случае, если установлена ​​переменная конфигурации &lt;code&gt;core.askPass&lt;/code&gt; , ее значение используется, как указано выше.</target>
        </trans-unit>
        <trans-unit id="3a26962584221262caf565e9653ff026d1f2d21a" translate="yes" xml:space="preserve">
          <source>Otherwise, if the helper string begins with an absolute path, the verbatim helper string becomes the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4215362e197715214628992e14b639b7a98dbd7a" translate="yes" xml:space="preserve">
          <source>Otherwise, show the index format.</source>
          <target state="translated">В противном случае,покажите формат индекса.</target>
        </trans-unit>
        <trans-unit id="1bddd3a0b4a752779f115c3518d3c2b277475b51" translate="yes" xml:space="preserve">
          <source>Otherwise, success is indicated the Unix way, i.e. by simply exiting with a zero exit status.</source>
          <target state="translated">В противном случае,успех указывается Unix-путем,т.е.простым выходом с нулевым статусом выхода.</target>
        </trans-unit>
        <trans-unit id="adf9fb3bc458cf17571d90a6a9fffeaa1b715a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the merge proceeds in the usual way.</source>
          <target state="translated">В противном случае слияние проходит обычным образом.</target>
        </trans-unit>
        <trans-unit id="682c927c4310cf70e63b7011c8ec332cb5444742" translate="yes" xml:space="preserve">
          <source>Otherwise, the string &quot;git credential-&quot; is prepended to the helper string, and the result becomes the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d438a86f2545e54eff98d96612fdf5bccb833ed" translate="yes" xml:space="preserve">
          <source>Otherwise, the topic that was merged to suddenly contains more than a single (well-separated) change. The many resulting small merges will greatly clutter up history. Anyone who later investigates the history of a file will have to find out whether that merge affected the topic in development. An upstream might even inadvertently be merged into a &quot;more stable&quot; branch. And so on.</source>
          <target state="translated">В противном случае,тема,которая была объединена,внезапно содержит более одного (хорошо разделенного)изменения.Множество мелких слияний,в результате которых они происходят,сильно загромождают историю.Любой,кто впоследствии исследует историю файла,должен будет выяснить,повлияло ли это слияние на разрабатываемую тему.Верхнее течение может даже случайно быть слито в &quot;более стабильную&quot; ветку.И так далее.</target>
        </trans-unit>
        <trans-unit id="9aea25a9a0905a830a51359c1723b329df787dff" translate="yes" xml:space="preserve">
          <source>Otherwise, the user is prompted on the terminal.</source>
          <target state="translated">В противном случае пользователь получает запрос на терминале.</target>
        </trans-unit>
        <trans-unit id="38c6fc8779b3b84c1e5bc6184edd3674dd536e89" translate="yes" xml:space="preserve">
          <source>Otherwise, this command applies the arguments passed using the &lt;code&gt;--trailer&lt;/code&gt; option, if any, to the commit message part of each input file. The result is emitted on the standard output.</source>
          <target state="translated">В противном случае эта команда применяет аргументы, переданные с помощью параметра &lt;code&gt;--trailer&lt;/code&gt; , если таковой имеется, к части сообщения фиксации каждого входного файла. Результат выводится на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="7befa93bf7555efa6c53836dd2ebb58604474c19" translate="yes" xml:space="preserve">
          <source>Otherwise, you need more information. How do you tell which version of the file has been lost?</source>
          <target state="translated">В противном случае,вам нужно больше информации.Как узнать,какая версия файла была утеряна?</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="bfba9983f4010a4e13ddf1f4da6c4d9462a74630" translate="yes" xml:space="preserve">
          <source>Output &quot;connectivity-ok&quot; if the received pack is self-contained and connected.</source>
          <target state="translated">Выход &quot;connectectivity-ok&quot;,если полученный пакет является автономным и подключенным.</target>
        </trans-unit>
        <trans-unit id="14d787baf83270b720015688dc1b0d825f139765" translate="yes" xml:space="preserve">
          <source>Output \0 instead of the character that normally follows a file name.</source>
          <target state="translated">Выведите \0 вместо символа,который обычно следует за именем файла.</target>
        </trans-unit>
        <trans-unit id="02b83bf95635a4c88bd0634054e0b05541ae55d4" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as creations, renames and mode changes.</source>
          <target state="translated">Выведите сжатую сводку расширенной информации о заголовке,такой как творения,переименования и изменения режима.</target>
        </trans-unit>
        <trans-unit id="6dbea2796f7c2da05dc872fbc20cb3b286f106fd" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as file creations or deletions (&quot;new&quot; or &quot;gone&quot;, optionally &quot;+l&quot; if it&amp;rsquo;s a symlink) and mode changes (&quot;+x&quot; or &quot;-x&quot; for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">Вывести сжатую сводку расширенной информации заголовка, такой как создание или удаление файлов (&amp;laquo;новый&amp;raquo; или &amp;laquo;ушел&amp;raquo;, необязательно &amp;laquo;+ l&amp;raquo;, если это символическая ссылка) и изменения режима (&amp;laquo;+ x&amp;raquo; или &amp;laquo;-x&amp;raquo; для добавления или удаления исполняемый бит соответственно) в diffstat. Информация помещается между частью имени файла и частью графика. Подразумевает &lt;code&gt;--stat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86b8e4f6e5044ecf1fc221aacfd89b826aa45a4b" translate="yes" xml:space="preserve">
          <source>Output all merge bases for the commits, instead of just one.</source>
          <target state="translated">Выведите все базы для слияния для коммитов,а не только одну.</target>
        </trans-unit>
        <trans-unit id="c4fd496863f1ea4adcfb9e1e5209189d8bcbae5b" translate="yes" xml:space="preserve">
          <source>Output an all-zero hash in each patch&amp;rsquo;s From header instead of the hash of the commit.</source>
          <target state="translated">Выведите нулевой хеш в заголовке From каждого патча вместо хеша фиксации.</target>
        </trans-unit>
        <trans-unit id="646a42919af7ad3c76023f798af12df793449561" translate="yes" xml:space="preserve">
          <source>Output diff in reverse.</source>
          <target state="translated">Выходные данные отличаются в обратном направлении.</target>
        </trans-unit>
        <trans-unit id="973b33dc2cc053fd8a3739d3b278f90232b34e64" translate="yes" xml:space="preserve">
          <source>Output excluded boundary commits. Boundary commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">Вывод исключенных границ фиксируется. Перед граничными коммитами ставится префикс &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3872ebaf63738dccf26222059fb06a34ea9a53d" translate="yes" xml:space="preserve">
          <source>Output file names will be a simple number sequence without the default first line of the commit appended.</source>
          <target state="translated">Имена выходных файлов будут представлять собой простую последовательность чисел без добавления первой строки коммита по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">Выходной формат</target>
        </trans-unit>
        <trans-unit id="d018168db6adc860beb206930bf9272bcf4432cb" translate="yes" xml:space="preserve">
          <source>Output from &lt;code&gt;git describe&lt;/code&gt;; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a &lt;code&gt;g&lt;/code&gt;, and an abbreviated object name.</source>
          <target state="translated">Вывод из &lt;code&gt;git describe&lt;/code&gt; ; т. е. ближайший тег, за которым необязательно следует тире и количество коммитов, за которым следует тире, &lt;code&gt;g&lt;/code&gt; и сокращенное имя объекта.</target>
        </trans-unit>
        <trans-unit id="57be6fd315ed7958a6a11b416634cb9af54c1202" translate="yes" xml:space="preserve">
          <source>Output information on each ref</source>
          <target state="translated">Выводить информацию по каждому запросу</target>
        </trans-unit>
        <trans-unit id="a471d58e2fcbf4f373e5dd800df97d7ecddc4b2a" translate="yes" xml:space="preserve">
          <source>Output only the last line of the &lt;code&gt;--stat&lt;/code&gt; format containing total number of modified files, as well as number of added and deleted lines.</source>
          <target state="translated">Выведите только последнюю строку формата &lt;code&gt;--stat&lt;/code&gt; , содержащую общее количество измененных файлов, а также количество добавленных и удаленных строк.</target>
        </trans-unit>
        <trans-unit id="09afa8b7712ce7db5d67e850045b13df59d4e1ae" translate="yes" xml:space="preserve">
          <source>Output only the names of config variables for &lt;code&gt;--list&lt;/code&gt; or &lt;code&gt;--get-regexp&lt;/code&gt;.</source>
          <target state="translated">Вывести только имена переменных конфигурации для &lt;code&gt;--list&lt;/code&gt; или --get &lt;code&gt;--get-regexp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86aa1f4dbf3c69df52c4dcdcb3513ddaac888349" translate="yes" xml:space="preserve">
          <source>Output only the trailers, not any other parts of the input.</source>
          <target state="translated">Выдавать только прицепы,а не другие части входа.</target>
        </trans-unit>
        <trans-unit id="db37f07e7f23e51cc792b3b6ff625f7fbb6a099c" translate="yes" xml:space="preserve">
          <source>Output only trailers that exist in the input; do not add any from the command-line or by following configured &lt;code&gt;trailer.*&lt;/code&gt; rules.</source>
          <target state="translated">Выводить только те трейлеры, которые есть на входе; не добавляйте ничего из командной строки или следуя настроенным правилам &lt;code&gt;trailer.*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f94a54620a30e7ce03e12a657369e604dddd0ea" translate="yes" xml:space="preserve">
          <source>Output stability</source>
          <target state="translated">Стабильность выхода</target>
        </trans-unit>
        <trans-unit id="eec068e91917644b4f85137aa6730536687188c8" translate="yes" xml:space="preserve">
          <source>Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">Выведите коммиты, выбранные для отображения (см. Раздел &amp;laquo;Ограничение коммитов&amp;raquo; выше) в обратном порядке. Нельзя сочетать с &lt;code&gt;--walk-reflogs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f16fa854dad4b03b2649c62b3407ce506ca41f" translate="yes" xml:space="preserve">
          <source>Output the distribution of relative amount of changes for each sub-directory. The behavior of &lt;code&gt;--dirstat&lt;/code&gt; can be customized by passing it a comma separated list of parameters. The defaults are controlled by the &lt;code&gt;diff.dirstat&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The following parameters are available:</source>
          <target state="translated">Выведите распределение относительного количества изменений для каждого подкаталога. Поведение &lt;code&gt;--dirstat&lt;/code&gt; можно настроить, передав ему список параметров, разделенных запятыми. Значения по умолчанию контролируются переменной конфигурации &lt;code&gt;diff.dirstat&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ). Доступны следующие параметры:</target>
        </trans-unit>
        <trans-unit id="f44ba9d91e7de35dadf965ce7b9f83b740777703" translate="yes" xml:space="preserve">
          <source>Output to a specific file instead of stdout.</source>
          <target state="translated">Выводить в определенный файл вместо stdout.</target>
        </trans-unit>
        <trans-unit id="1374322e99ee5a882a272ee284ec9ea86e209683" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git cat-file --batch&lt;/code&gt;:</source>
          <target state="translated">Для вывода используется тот же формат, что и для &lt;code&gt;git cat-file --batch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="50880c18d623e2367f83a87791b3da910b72fa81" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Вывод использует тот же формат, что и &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="12aec147318e848c7d54969418eb1ab7603e65c0" translate="yes" xml:space="preserve">
          <source>Outputs some statistics to stderr. Has a small performance penalty.</source>
          <target state="translated">Выводит некоторую статистику в stderr.Имеет небольшой штраф за выступление.</target>
        </trans-unit>
        <trans-unit id="bb044abda9deb6fdc3e0634ed0f85ce258bcc5dc" translate="yes" xml:space="preserve">
          <source>Outputs the SHA1 of every commit in &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt;, prefixed with &lt;code&gt;-&lt;/code&gt; for commits that have an equivalent in &amp;lt;upstream&amp;gt;, and &lt;code&gt;+&lt;/code&gt; for commits that do not.</source>
          <target state="translated">Выводит SHA1 каждого коммита в &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt; с префиксом &lt;code&gt;-&lt;/code&gt; для коммитов, у которых есть эквивалент в &amp;lt;upstream&amp;gt;, и &lt;code&gt;+&lt;/code&gt; для коммитов, у которых его нет.</target>
        </trans-unit>
        <trans-unit id="27115802f1c296a1dfb4ce768084e3e086e70c8c" translate="yes" xml:space="preserve">
          <source>Override &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable that is set to force each and every tag to be signed.</source>
          <target state="translated">Переопределить переменную конфигурации &lt;code&gt;tag.gpgSign&lt;/code&gt; , которая установлена ​​для принудительной подписи каждого тега.</target>
        </trans-unit>
        <trans-unit id="f98c38feba04de33a87daf02cddb4bc0af45f925" translate="yes" xml:space="preserve">
          <source>Override earlier --rebase.</source>
          <target state="translated">Отменить ранее-перезагрузка.</target>
        </trans-unit>
        <trans-unit id="bf7cdfd38925dba890e8c6c44d76b710ca912a26" translate="yes" xml:space="preserve">
          <source>Override the HTTP proxy, normally configured using the &lt;code&gt;http_proxy&lt;/code&gt;, &lt;code&gt;https_proxy&lt;/code&gt;, and &lt;code&gt;all_proxy&lt;/code&gt; environment variables (see &lt;code&gt;curl(1)&lt;/code&gt;). In addition to the syntax understood by curl, it is possible to specify a proxy string with a user name but no password, in which case git will attempt to acquire one in the same way it does for other credentials. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information. The syntax thus is &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt;. This can be overridden on a per-remote basis; see remote.&amp;lt;name&amp;gt;.proxy</source>
          <target state="translated">Переопределите HTTP-прокси, обычно настраиваемый с использованием &lt;code&gt;http_proxy&lt;/code&gt; &lt;code&gt;https_proxy&lt;/code&gt; http_proxy , https_proxy и &lt;code&gt;all_proxy&lt;/code&gt; (см. Curl &lt;code&gt;curl(1)&lt;/code&gt; ). В дополнение к синтаксису, понимаемому curl, можно указать строку прокси с именем пользователя, но без пароля, и в этом случае git попытается получить его так же, как и для других учетных данных. См. &lt;a href=&quot;gitcredentials&quot;&gt;Gitcredentials [7]&lt;/a&gt; для получения дополнительной информации. Таким образом, синтаксис следующий: &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt; . Это может быть отменено на удаленной основе; см. remote. &amp;lt;имя&amp;gt; .proxy</target>
        </trans-unit>
        <trans-unit id="ca2a7d0ade908f47d0a242141742817435033d82" translate="yes" xml:space="preserve">
          <source>Override the author date used in the commit.</source>
          <target state="translated">Отменить дату автора,использованную в фиксации.</target>
        </trans-unit>
        <trans-unit id="afbb46ef37a88110fa3c814b4440b9bab3c588ca" translate="yes" xml:space="preserve">
          <source>Override the commit author. Specify an explicit author using the standard &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; format. Otherwise &amp;lt;author&amp;gt; is assumed to be a pattern and is used to search for an existing commit by that author (i.e. rev-list --all -i --author=&amp;lt;author&amp;gt;); the commit author is then copied from the first such commit found.</source>
          <target state="translated">Заменить автора фиксации. Укажите явного автора, используя стандартный формат &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; . В противном случае предполагается, что &amp;lt;author&amp;gt; является шаблоном и используется для поиска существующей фиксации этого автора (например, rev-list --all -i --author = &amp;lt;author&amp;gt;); затем автор фиксации копируется из первой найденной такой фиксации.</target>
        </trans-unit>
        <trans-unit id="e3aa6564c96bc2c1fa2d64bc52314ce125c2e1b2" translate="yes" xml:space="preserve">
          <source>Override the default help format used by &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;. Values &lt;code&gt;man&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are supported. &lt;code&gt;man&lt;/code&gt; is the default. &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are the same.</source>
          <target state="translated">Отменить формат справки по умолчанию, используемый &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; . Поддерживаются значения &lt;code&gt;man&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;web&lt;/code&gt; и &lt;code&gt;html&lt;/code&gt; . &lt;code&gt;man&lt;/code&gt; по умолчанию. &lt;code&gt;web&lt;/code&gt; и &lt;code&gt;html&lt;/code&gt; одинаковы.</target>
        </trans-unit>
        <trans-unit id="90af133b98db5fc195076e23392ec3cd67c3e89c" translate="yes" xml:space="preserve">
          <source>Override the default tempdir.</source>
          <target state="translated">Отменить темпир по умолчанию.</target>
        </trans-unit>
        <trans-unit id="5b51681506c224a8c47f1343a9ecd64433151e38" translate="yes" xml:space="preserve">
          <source>Override the executable bit of the added files. The executable bit is only changed in the index, the files on disk are left unchanged.</source>
          <target state="translated">Переопределить исполняемый бит добавленных файлов.Исполняемый бит изменяется только в индексе,файлы на диске остаются без изменений.</target>
        </trans-unit>
        <trans-unit id="2478241e90c06d40d8344e2c734cc9e34ffd0d73" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to browse HTML help (see &lt;code&gt;-w&lt;/code&gt; option in &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;) or a working repository in gitweb (see &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;).</source>
          <target state="translated">Переопределите путь для данного инструмента, который можно использовать для просмотра справки HTML (см. &lt;code&gt;-w&lt;/code&gt; в &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; ) или рабочего репозитория в gitweb (см. &lt;a href=&quot;git-instaweb&quot;&gt;Git-instaweb [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eeb1b59c781a411c8a2ade9041a0a224d6888a83" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to display help in the &lt;code&gt;man&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">Переопределить путь для данного инструмента, который может использоваться для отображения справки в формате &lt;code&gt;man&lt;/code&gt; . См. &lt;a href=&quot;git-help&quot;&gt;Git-help [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adf75a51b2ad5d1ae80303fa7c85676af23cae71" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool. This is useful in case your tool is not in the PATH.</source>
          <target state="translated">Переопределите путь для данного инструмента.Это полезно в том случае,если ваш инструмент не находится в PATH.</target>
        </trans-unit>
        <trans-unit id="d7b3947bcc6a75423b4dad1a16da833c821be77f" translate="yes" xml:space="preserve">
          <source>Override the up-to-date check.</source>
          <target state="translated">Отмените актуальный чек.</target>
        </trans-unit>
        <trans-unit id="4f22a960f4dfa712696d5fbbb0afb1a8a1360ea3" translate="yes" xml:space="preserve">
          <source>Overrides a previous &lt;code&gt;--no-walk&lt;/code&gt;.</source>
          <target state="translated">Отменяет предыдущий &lt;code&gt;--no-walk&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcd0bd07179d4dab7adf6735a6d8e2d1ef6bb9e3" translate="yes" xml:space="preserve">
          <source>Overwrite the contents of the files that match the pathspec. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (most often a commit) is not given, overwrite working tree with the contents in the index. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; is given, overwrite both the index and the working tree with the contents at the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Замените содержимое файлов, соответствующих указанному пути. Когда &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (чаще всего фиксация) не задан, перезапишите рабочее дерево содержимым индекса. Когда задан &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; , перезапишите как индекс, так и рабочее дерево содержимым в &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd66a641be22e4e3d7b30653f72f1e5443e834b" translate="yes" xml:space="preserve">
          <source>P4 does not have the same concept of a branch as Git. Instead, p4 organizes its content as a directory tree, where by convention different logical branches are in different locations in the tree. The &lt;code&gt;p4 branch&lt;/code&gt; command is used to maintain mappings between different areas in the tree, and indicate related content. &lt;code&gt;git p4&lt;/code&gt; can use these mappings to determine branch relationships.</source>
          <target state="translated">P4 не имеет той же концепции ветки, что и Git. Вместо этого p4 организует свое содержимое в виде дерева каталогов, где по соглашению разные логические ветви находятся в разных местах дерева. Команда &lt;code&gt;p4 branch&lt;/code&gt; используется для поддержки сопоставлений между различными областями в дереве и указания связанного содержимого. &lt;code&gt;git p4&lt;/code&gt; может использовать эти сопоставления для определения отношений ветвей.</target>
        </trans-unit>
        <trans-unit id="c377e9687b993a1d0b2786f798f75e99668d5825" translate="yes" xml:space="preserve">
          <source>P4 repositories can be added to an existing Git repository using &lt;code&gt;git p4 sync&lt;/code&gt; too:</source>
          <target state="translated">Репозитории P4 можно добавить в существующий репозиторий Git с помощью &lt;code&gt;git p4 sync&lt;/code&gt; :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
