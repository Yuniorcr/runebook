<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">При обновлении ссылки создаются записи журнала ссылок, чтобы отслеживать причину обновления ссылки (обычно это имя высокоуровневой команды, обновившей ссылку), в дополнение к старому и новому значениям ссылки. , Запрограммированная команда Porcelain может использовать вспомогательную функцию set_reflog_action в &lt;code&gt;git-sh-setup&lt;/code&gt; , чтобы задать имя этой переменной, когда она вызывается конечным пользователем как команда верхнего уровня, для записи в теле журнала reflog.</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">Когда репозиторий синхронизируется с помощью &lt;code&gt;git push&lt;/code&gt; и &lt;code&gt;git pull&lt;/code&gt; , объекты, упакованные в исходный репозиторий, обычно хранятся в распакованном виде в месте назначения. Хотя это позволяет вам использовать разные стратегии упаковки на обоих концах, это также означает, что вам может потребоваться время от времени переупаковывать оба репозитория.</target>
        </trans-unit>
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">Когда в скриптовом языке действует специальная котировка,все,что находится между атомом открытия верхнего уровня и его соответствием %(end),оценивается в соответствии с семантикой атома открытия,и цитируется только его результат от атома открытия верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">Когда говорят, что переменная принимает логическое значение, многие синонимы принимаются для &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; ; все они нечувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">При принятии нового кода для ветки поставщика вы,вероятно,захотите записать как удаление путей,так и добавление новых,а также изменение существующих путей.</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">При принятии подписанного push-уведомления (см. &lt;a href=&quot;git-push&quot;&gt;Git-push [1]&lt;/a&gt; ) подписанный push-сертификат сохраняется в &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; объекте, и имя объекта можно узнать в переменной среды GIT_PUSH_CERT . См. Пример в описании обработчика &lt;code&gt;post-receive&lt;/code&gt; . Кроме того, сертификат проверяется с помощью GPG, и результат экспортируется со следующими переменными среды:</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">При получении учетных данных важно учитывать компонент &amp;laquo;путь&amp;raquo; URL-адреса http или https. По умолчанию - false. См. &lt;a href=&quot;gitcredentials&quot;&gt;Gitcredentials [7]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">При добавлении заметок к объекту,в котором уже есть заметки,перезапишите существующие заметки (вместо прерывания).</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">При рекламе подсказок доступной истории от альтернативы используйте оболочку для выполнения указанной команды вместо &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; . Первый аргумент - это абсолютный путь альтернативы. Вывод должен содержать по одному шестнадцатеричному идентификатору объекта в каждой строке (то есть такой же, как полученный &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">Когда аргумент может быть неправильно истолкован как пересмотр или как путь, они могут быть устранены путем помещения &lt;code&gt;--&lt;/code&gt; между ними. Например, &lt;code&gt;git diff -- HEAD&lt;/code&gt; : &amp;laquo;У меня есть файл с именем HEAD в моем рабочем дереве. Пожалуйста, покажите изменения между версией, которую я разместил в индексе, и тем, что у меня есть в рабочем дереве для этого файла&amp;raquo;, а не &amp;laquo;покажите разницу между HEAD коммит и дерево работы в целом &quot;. Вы можете сказать &lt;code&gt;git diff HEAD --&lt;/code&gt; чтобы запросить последнее.</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">Если аргумент может пониматься либо как ссылка, либо как имя файла, выберите его понимание как аргумент патча формата ( &lt;code&gt;--format-patch&lt;/code&gt; ) или как имя файла ( &lt;code&gt;--no-format-patch&lt;/code&gt; ). По умолчанию, когда возникает такой конфликт, git send-email не работает.</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">Когда интерактивная команда (например, &lt;code&gt;git add --patch&lt;/code&gt; ) показывает раскрашенное различие, git передает различие через команду оболочки, определенную этой переменной конфигурации. Команда может дополнительно разметить разницу для использования человеком при условии, что она сохраняет взаимно однозначное соответствие со строками в исходной разнице. По умолчанию отключено (без фильтрации).</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">Когда в качестве аргумента указывается необязательное имя Git-ветки (или имя объекта Git-комита),подкоманда работает на указанной ветке,а не на текущей.</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">Когда обновление изменяет ответвление (или,в общем случае,ссылку),которое раньше указывало на фиксацию А,чтобы указать на другую фиксацию Б,оно называется быстрым перемотным обновлением,если и только если Б является потомком А.</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">При применении патча обнаруживайте новую или измененную строку с ошибками в виде пробелов. То, что считается &lt;code&gt;core.whitespace&lt;/code&gt; пробелов, контролируется конфигурацией core.whitespace . По умолчанию завершающие пробелы (включая строки, состоящие исключительно из пробелов) и символ пробела, за которым сразу следует символ табуляции внутри начального отступа строки, считаются ошибками пробелов.</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">При применении патча игнорируйте дополнения, сделанные патчем. Это можно использовать для извлечения общей части между двумя файлами, сначала запустив для них &lt;code&gt;diff&lt;/code&gt; и применив результат с этой опцией, которая применила бы часть удаления, но не часть добавления.</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">При применении патча при необходимости игнорируйте изменения пробелов в контекстных строках. Строки контекста сохранят свои пробелы, и они не будут подвергаться исправлению пробелов независимо от значения параметра &lt;code&gt;--whitespace&lt;/code&gt; . Однако новые строки все равно будут исправлены.</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">При применении патча только к рабочему дереву, отметьте новые файлы, которые будут добавлены в индекс позже (см. &lt;code&gt;--intent-to-add&lt;/code&gt; в &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; ). Этот параметр игнорируется, если он не запущен в репозитории Git и не указан &lt;code&gt;--index&lt;/code&gt; . Обратите внимание, что &lt;code&gt;--index&lt;/code&gt; может подразумеваться другими параметрами, такими как &lt;code&gt;--cached&lt;/code&gt; или &lt;code&gt;--3way&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">При запросе на &lt;code&gt;abort&lt;/code&gt; (по умолчанию) эта программа умирает при обнаружении подписанного тега. С &lt;code&gt;strip&lt;/code&gt; теги будут автоматически сделаны без подписи, с &lt;code&gt;warn-strip&lt;/code&gt; они будут сделаны без подписи, но будет отображаться предупреждение, &lt;code&gt;verbatim&lt;/code&gt; они будут экспортированы без &lt;code&gt;warn&lt;/code&gt; , а с warn они будут экспортированы, но вы увидите предупреждение ,</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">При запросе на &lt;code&gt;abort&lt;/code&gt; (по умолчанию) эта программа умрет при обнаружении такого тега. С &lt;code&gt;drop&lt;/code&gt; такие теги будут исключены из вывода. При &lt;code&gt;rewrite&lt;/code&gt; , если помеченный объект является фиксацией, он перезапишет тег, чтобы пометить фиксацию предка (посредством родительской перезаписи; см. &lt;a href=&quot;git-rev-list&quot;&gt;Git-rev-list [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">При вызове с параметром &lt;code&gt;--incremental&lt;/code&gt; команда выводит результат в том виде, в каком он был построен. Вывод обычно будет говорить о строках, затронутых более поздними коммитами (т.е. строки будут аннотированы не по порядку) и предназначен для использования интерактивными программами просмотра.</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">При проверке путей из индекса проверьте этап № 2 ( &lt;code&gt;ours&lt;/code&gt; ) или № 3 ( &lt;code&gt;theirs&lt;/code&gt; ) для несвязанных путей.</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">При извлечении путей из индекса не обманывайте неупорядоченные записи;вместо этого неупорядоченные записи игнорируются.</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">При выделении путей из индекса эта опция позволяет воссоздать объединенное слияние в указанных путях.</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">При клонировании репозитория SVN, если не используется ни один из вариантов описания макета репозитория (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; создаст репозиторий Git с полностью линейной историей, где ветки и теги отображаются в рабочей копии как отдельные каталоги. Хотя это самый простой способ получить копию полного репозитория, для проектов с большим количеством ветвей рабочая копия будет во много раз больше, чем просто основная часть. Таким образом, для проектов, использующих стандартную структуру каталогов (ствол / ветки / теги), рекомендуется клонировать с опцией &lt;code&gt;--stdlayout&lt;/code&gt; , Если в проекте используется нестандартная структура и / или если ветки и теги не требуются, проще всего клонировать только один каталог (обычно магистральный), не задавая никаких параметров макета репозитория. Если требуется полная история с ветками и тегами, необходимо использовать параметры &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">При клонировании или извлечении репозитория, содержащего подмодули, подмодули не будут извлечены по умолчанию; Вы можете указать &lt;code&gt;clone&lt;/code&gt; на рекурсию в подмодули. В &lt;code&gt;init&lt;/code&gt; и &lt;code&gt;update&lt;/code&gt; подкоманды &lt;code&gt;git submodule&lt;/code&gt; будет поддерживать подмодулях проверили и на соответствующем пересмотре в вашем рабочем дереве. В качестве альтернативы вы можете установить &lt;code&gt;submodule.recurse&lt;/code&gt; иметь &lt;code&gt;checkout&lt;/code&gt; рекурсии в подмодули.</target>
        </trans-unit>
        <trans-unit id="2bdda0ba49ff183f8b76fb42fb3146b89e404d42" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; you can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules (note that &lt;code&gt;submodule.recurse&lt;/code&gt; also affects other Git commands, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a complete list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d739b21b6194611c8a45df16bb823ac3b01a4bd" translate="yes" xml:space="preserve">
          <source>When combined with the &lt;code&gt;run&lt;/code&gt; subcommand, run maintenance tasks only if certain thresholds are met. For example, the &lt;code&gt;gc&lt;/code&gt; task runs when the number of loose objects exceeds the number stored in the &lt;code&gt;gc.auto&lt;/code&gt; config setting, or when the number of pack-files exceeds the &lt;code&gt;gc.autoPackLimit&lt;/code&gt; config setting. Not compatible with the &lt;code&gt;--schedule&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61eed3296a596b65de979964c073754bc8210abb" translate="yes" xml:space="preserve">
          <source>When combined with the &lt;code&gt;run&lt;/code&gt; subcommand, run maintenance tasks only if certain time conditions are met, as specified by the &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt; config value for each &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt;. This config value specifies a number of seconds since the last time that task ran, according to the &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.lastRun&lt;/code&gt; config value. The tasks that are tested are those provided by the &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; option(s) or those with &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.enabled&lt;/code&gt; set to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96f700dec6ecf67635f001fe97af20a3a1af7ba" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--contains&lt;/code&gt; and &lt;code&gt;--no-contains&lt;/code&gt; filters, only references that contain at least one of the &lt;code&gt;--contains&lt;/code&gt; commits and contain none of the &lt;code&gt;--no-contains&lt;/code&gt; commits are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3693ecef45adf0e594fc21eeb7dc1180a98b303e" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; filters, only references that are reachable from at least one of the &lt;code&gt;--merged&lt;/code&gt; commits and from none of the &lt;code&gt;--no-merged&lt;/code&gt; commits are shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">При фиксации исправлений рассмотрите возможность использования &lt;code&gt;merge&lt;/code&gt; для подключения фиксации (ов), которые предоставляют версии файлов в ветку исправлений. Это позволит таким инструментам, как &lt;code&gt;git blame&lt;/code&gt; , отслеживать реальную историю коммитов и правильно аннотировать исходные файлы.</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">При фиксации в svn из Git (как часть операций &lt;code&gt;set-tree&lt;/code&gt; или &lt;code&gt;dcommit&lt;/code&gt; ), если в существующем сообщении журнала еще нет строки &lt;code&gt;From:&lt;/code&gt; или &lt;code&gt;Signed-off-by:&lt;/code&gt; , добавьте строку &lt;code&gt;From:&lt;/code&gt; на основе коммита Git авторская строка. Если вы используете это, то &lt;code&gt;--use-log-author&lt;/code&gt; будет получать действительную строку автора для всех коммитов.</target>
        </trans-unit>
        <trans-unit id="93d9f9b7d88e7e5ba3d52728cd609bd56e74440d" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by&lt;/code&gt; trailer, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">Когда выполняются обычные операции по созданию объектов, они проверяют, существенно ли увеличился репозиторий с момента последнего обслуживания, и если да, то запускают &lt;code&gt;git gc&lt;/code&gt; автоматически. См. &lt;code&gt;gc.auto&lt;/code&gt; ниже, чтобы узнать, как отключить это поведение.</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">При сравнении двух деревьев,перед разницей выводится идентификатор обоих деревьев (разделенных пробелом и завершенных новой строкой).При сравнении коммитов выводится идентификатор первой (или единственной)коммиты,за которой следует новая строка.</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">При преобразовании значения в его каноническую форму с использованием &lt;code&gt;--type=bool&lt;/code&gt; типа --type = bool , &lt;code&gt;git config&lt;/code&gt; гарантирует, что вывод будет &amp;laquo;истинным&amp;raquo; или &amp;laquo;ложным&amp;raquo; (написанным строчными буквами).</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">При копировании удаленного репозитория вы захотите как минимум обновить кеш индекса, когда вы это сделаете, и особенно с репозиториями других людей вы часто хотите убедиться, что кеш индекса находится в каком-то известном состоянии (вы не знаю , &lt;strong&gt;что&lt;/strong&gt; они сделали , и еще не зарегистрировались), поэтому , как правило , вы будете предшествовать &lt;code&gt;git update-index&lt;/code&gt; с а</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">При копировании заметок во время перезаписи (см. Параметр &amp;laquo;notes.rewrite. &amp;lt;command&amp;gt;&amp;raquo;) определяет, что делать, если у целевого коммита уже есть заметка. Должен быть одним из вариантов &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; . По умолчанию &lt;code&gt;concatenate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">При копировании заметок во время перезаписи укажите (полностью квалифицированный)номер ссылки,чьи заметки должны быть скопированы.Это может быть глобус,в этом случае будут скопированы заметки во всех совпадающих ссылках.Вы также можете указать эту конфигурацию несколько раз.</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">При копировании заметок во время перезаписи укажите (полностью квалифицированный)номер ссылки,чьи заметки следует скопировать.Ссылка может быть глобусом,в этом случае будут скопированы заметки во всех совпадающих ссылках.Вы также можете указать эту конфигурацию несколько раз.</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">Что делать при копировании заметок во время перезаписи, если в целевом коммите уже есть заметка. Должен быть одним из вариантов &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; . По умолчанию &lt;code&gt;concatenate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">Что делать при копировании заметок во время перезаписи, если в целевом коммите уже есть заметка. Должен быть одним из вариантов &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; . Это отменяет настройку &lt;code&gt;core.rewriteMode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">При создании новой ветки, если &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; является ветвью, пометьте ее как &amp;laquo;восходящую&amp;raquo; от новой ветки. Это значение по умолчанию, если &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; является ветвью удаленного отслеживания. См. &quot;--Track&quot; в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="4e04dc75cba18b40521f918d2128a9cc7f50298f" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">При создании новой ветки настройте конфигурацию &amp;laquo;восходящего потока&amp;raquo;. &lt;code&gt;-c&lt;/code&gt; подразумевается. См. &lt;code&gt;--track&lt;/code&gt; в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">При создании новой ветки настройте конфигурацию &amp;laquo;восходящего потока&amp;raquo;. См. &quot;--Track&quot; в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">При создании новой ветви настройте записи конфигурации &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; и &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; , чтобы отметить ветвь начальной точки как &amp;laquo;восходящую&amp;raquo; от новой ветки. Эта конфигурация скажет git показать взаимосвязь между двумя ветвями в &lt;code&gt;git status&lt;/code&gt; и &lt;code&gt;git branch -v&lt;/code&gt; . Кроме того, он предписывает &lt;code&gt;git pull&lt;/code&gt; без аргументов извлекать из восходящего потока, когда новая ветка проверяется.</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">При создании упакованного архива в репозитории,содержащем существующие пакеты,команда повторно использует существующие дельты.В результате иногда получается несколько неоптимальный пакет.Этот флаг говорит команде не использовать существующие дельты повторно,а вычислять их с нуля.</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">При создании файлов добавьте &amp;lt;string&amp;gt; (обычно это каталог, содержащий завершающий /)</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">При работе с выводом &lt;code&gt;git diff-tree&lt;/code&gt; он использует тот факт, что патч имеет префикс с именем объекта фиксации и выводит две 40-байтовые шестнадцатеричные строки. Первая строка - это идентификатор патча, а вторая строка - это идентификатор фиксации. Это можно использовать для сопоставления идентификатора патча с идентификатором фиксации.</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">При принятии решения, какие атрибуты назначены пути, Git &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; (который имеет наивысший приоритет), файлу &lt;code&gt;.gitattributes&lt;/code&gt; в том же каталоге, что и рассматриваемый путь, и его родительским каталогам до верхнего уровня дерево работы (чем дальше каталог, содержащий &lt;code&gt;.gitattributes&lt;/code&gt; , от рассматриваемого пути, тем ниже его приоритет). Наконец, рассматриваются глобальные и общесистемные файлы (они имеют самый низкий приоритет).</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">При деинициализации или удалении (см. Ниже) каталог Git подмодуля автоматически перемещается в &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; суперпроекта.</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">При отображении имен доступных объектов в дополнение к SHA-1 также отображается имя, описывающее, &lt;strong&gt;как&lt;/strong&gt; они достижимы, совместимые с &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; , например &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">При выполнении пробного прогона дайте результат в формате, готовом для фарфора. Подробнее см. &lt;a href=&quot;git-status&quot;&gt;Git-status [1]&lt;/a&gt; . Подразумевает &lt;code&gt;--dry-run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">При выполнении пробного прогона дайте результат в длинном формате. Подразумевает &lt;code&gt;--dry-run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">При выполнении пробного прогона дайте результат в кратком формате. Подробнее см. &lt;a href=&quot;git-status&quot;&gt;Git-status [1]&lt;/a&gt; . Подразумевает &lt;code&gt;--dry-run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">При преобразовании репозитория используйте уникальную метку для каждой фиксации ( &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; ) и укажите параметр --export-Mark в командной строке. fast-import создаст дамп файла, в котором перечислены все метки и соответствующий ей объект Git SHA-1. Если интерфейс может привязать метки обратно к исходному репозиторию, легко проверить точность и полноту импорта, сравнив каждую фиксацию Git с соответствующей исходной ревизией.</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">При редактировании сообщения о фиксации запустите редактор с содержимым данного файла. &lt;code&gt;commit.template&lt;/code&gt; переменной конфигурации часто используются , чтобы дать этот параметр неявно к команде. Этот механизм может использоваться проектами, которые хотят дать участникам подсказки о том, что писать в сообщении в каком порядке. Если пользователь выходит из редактора, не отредактировав сообщение, фиксация прерывается. Это не действует, если сообщение отправлено другими способами, например, с параметрами &lt;code&gt;-m&lt;/code&gt; или &lt;code&gt;-F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">При редактировании,предоставьте необработанное содержимое объекта,а не красиво напечатанное.В настоящее время это касается только деревьев,которые будут отображаться в их двоичном виде.С этим сложнее работать,но это может помочь при восстановлении дерева,которое настолько повреждено,что не может быть красиво напечатано.Обратите внимание,что вам может понадобиться настроить редактор на чистое чтение и запись двоичных данных.</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">Если этот параметр включен, обработчик &lt;code&gt;post-update&lt;/code&gt; по умолчанию запускает &lt;code&gt;git update-server-info&lt;/code&gt; , чтобы поддерживать информацию, используемую &amp;laquo;тупыми&amp;raquo; транспортами (например, HTTP), в актуальном состоянии. Если вы публикуете репозиторий Git, доступный через HTTP, вам, вероятно, следует включить эту ловушку.</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">При обнаружении сообщения или темы, отличной от ASCII, которые не объявляют свою кодировку, добавьте заголовки / цитаты, чтобы указать, что они закодированы в &amp;lt;encoding&amp;gt;. По умолчанию используется значение &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; ; если это не указано, будет запрошено, если будут обнаружены какие-либо файлы, отличные от ASCII.</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">При стирании учетных данных,соответствующие учетные данные будут удалены из всех файлов.</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">Когда включен extension.worktreeConfig, файл конфигурации &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; читается после &lt;code&gt;.git/config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">При ложном срабатывании слить текущее ответвление с восходящим.</target>
        </trans-unit>
        <trans-unit id="d5dfb7a500ca38e6f311c3fe54f4fbaf71bc47ce" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. Providing an empty &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; to the &lt;code&gt;--refmap&lt;/code&gt; option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">При извлечении ссылок, перечисленных в командной строке, используйте указанный refspec (может быть задан более одного раза) для сопоставления ссылок с ветвями удаленного отслеживания вместо значений переменных конфигурации &lt;code&gt;remote.*.fetch&lt;/code&gt; для удаленного репозитория. См. Подробности в разделе &amp;laquo;Настроенные ветви удаленного отслеживания&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">Когда файлы изменяются вне Git, пользователю нужно будет явно обработать измененные файлы (например, см. Раздел &amp;laquo; &lt;code&gt;Examples&lt;/code&gt; &amp;raquo; в &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; ). Git обычно не обнаруживает изменений в этих файлах.</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">При фильтрации истории с &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; , не подрезать немного истории. (См. &amp;laquo;Упрощение истории&amp;raquo; в &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; для более подробного объяснения.)</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">При первом создании объекты хранятся в отдельных файлах,но для большей эффективности в дальнейшем могут быть сжаты вместе в &quot;пакетные файлы&quot;.</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">Когда задан диапазон отображаемых &lt;code&gt;commit1..commit2&lt;/code&gt; (например, commit1..commit2 или &lt;code&gt;commit2 ^commit1&lt;/code&gt; ), отображать только те коммиты, которые существуют непосредственно в цепочке предков между &lt;code&gt;commit1&lt;/code&gt; и &lt;code&gt;commit2&lt;/code&gt; , т.е. коммиты, которые являются потомками &lt;code&gt;commit1&lt;/code&gt; и предками &lt;code&gt;commit2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">Когда задан диапазон отображаемых &lt;code&gt;commit1..commit2&lt;/code&gt; (например, commit1..commit2 или &lt;code&gt;commit2 ^commit1&lt;/code&gt; ), отображать только те коммиты, которые существуют непосредственно в цепочке предков между &lt;code&gt;commit1&lt;/code&gt; и &lt;code&gt;commit2&lt;/code&gt; , т.е. коммиты, которые являются потомками &lt;code&gt;commit1&lt;/code&gt; и предками &lt;code&gt;commit2&lt;/code&gt; . (См. &amp;laquo;Упрощение истории&amp;raquo; в &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; для более подробного объяснения.)</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">При задании имени section.key, состоящего из двух частей, возвращается значение для section. &amp;lt;url&amp;gt; .key, часть &amp;lt;url&amp;gt; которого лучше всего соответствует заданному URL-адресу (если такой ключ не существует, используется значение для section.key как запасной вариант). Если в качестве имени указан только раздел, сделайте это для всех ключей в разделе и перечислите их. Возвращает код ошибки 1, если значение не найдено.</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">Когда указан номер версии SVN в форме &lt;code&gt;rN&lt;/code&gt; , возвращает соответствующий хеш фиксации Git (при желании за ним может следовать древовидный код, указывающий, в какой ветви следует искать). Когда задано дерево, возвращает соответствующий номер версии SVN.</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">Когда дано,а доступ к репозиторию для клонирования осуществляется через ssh,это указывает путь,не по умолчанию,для команды,запущенной на другом конце.</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">Когда он задан, и репозиторий, из которого выполняется выборка, обрабатывается &lt;code&gt;git fetch-pack&lt;/code&gt; , &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; чтобы указать путь , отличный от пути по умолчанию для команды, выполняемой на другом конце.</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">При &lt;code&gt;--or&lt;/code&gt; нескольких шаблонных выражений в сочетании с --or этот флаг указывается, чтобы ограничить совпадение файлами, в которых есть строки, соответствующие всем из них.</target>
        </trans-unit>
        <trans-unit id="a0b6fe15df65f2d5daa97101d52d41abe4f1ad3a" translate="yes" xml:space="preserve">
          <source>When grepping the object store (with &lt;code&gt;--cached&lt;/code&gt; or giving tree objects), running with multiple threads might perform slower than single threaded if &lt;code&gt;--textconv&lt;/code&gt; is given and there&amp;rsquo;re too many text conversions. So if you experience low performance in this case, it might be desirable to use &lt;code&gt;--threads=1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">Когда он готов, он говорит Алисе получить изменения из репозитория в / home / bob / myrepo. Она делает это с помощью:</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">При импорте переименованного файла или каталога просто удалите старое имя (имена)и измените новое имя (имена)во время соответствующей фиксации.Git выполняет определение переименования после факта,а не явно во время фиксации.</target>
        </trans-unit>
        <trans-unit id="547b791fe6e4a112ecfb6e63c2e9ee0d26e77b05" translate="yes" xml:space="preserve">
          <source>When in cone mode, the &lt;code&gt;git sparse-checkout set&lt;/code&gt; subcommand takes a list of directories instead of a list of sparse-checkout patterns. In this mode, the command &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; sets the directory &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the directories &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">В режиме списка покажите sha1 и зафиксируйте строку темы для каждого заголовка вместе с отношением к восходящей ветке (если есть). Если задано дважды, выведите путь к связанному рабочему дереву (если есть), а также имя восходящей ветки (см. Также &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; ). Обратите внимание, что путь HEAD текущего рабочего дерева не будет напечатан (это всегда будет ваш текущий каталог).</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">Когда информационные ошибки включены,git-daemon будет сообщать клиенту о более многословных ошибках,различая такие условия,как &quot;такого репозитория нет&quot; и &quot;репозиторий не экспортируется&quot;.Это удобнее для клиентов,но может привести к утечке информации о существовании не экспортированных репозиториев.Когда информационные ошибки не включены,все ошибки сообщают клиенту &quot;доступ запрещен&quot;.По умолчанию -нет-неинформативные-ошибки.</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">При инициализации подмодулей файл &lt;code&gt;.gitmodules&lt;/code&gt; в каталоге верхнего уровня содержащего репозитория используется для поиска URL-адреса каждого подмодуля. Этот файл должен быть отформатирован так же, как &lt;code&gt;$GIT_DIR/config&lt;/code&gt; . Ключом к URL каждого подмодуля является &amp;laquo;submodule. $ Name.url&amp;raquo;. Подробнее см. &lt;a href=&quot;gitmodules&quot;&gt;Gitmodules [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">При первоначальном вызове &lt;code&gt;git am&lt;/code&gt; вы даете ему имена почтовых ящиков для обработки. Увидев первый неприменимый патч, он прерывается на середине. Вы можете избавиться от этого одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">При вызове настраиваемого инструмента слияния Git использует набор временных файлов для передачи инструменту. Если инструмент возвращает ошибку и для этой переменной установлено значение &lt;code&gt;true&lt;/code&gt; , эти временные файлы будут сохранены, в противном случае они будут удалены после выхода из инструмента. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">Когда дело доходит до редактирования этого коммита, выполните &lt;code&gt;git reset HEAD^&lt;/code&gt; . В результате HEAD перематывается на единицу, и индекс следует за ним. Однако рабочее дерево остается прежним.</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">Когда неясно,как применить изменение,происходит следующее:</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">Когда неясно,как примирить изменения,происходит следующее:</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">При перечислении ссылок из альтернативного списка указывайте только те ссылки, которые начинаются с данного префикса. Префиксы совпадают, как если бы они были переданы в качестве аргументов для &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; . Чтобы перечислить несколько префиксов, разделите их пробелами. Если &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; , установка &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">При листинге используйте указанный &amp;lt;format&amp;gt;, который может быть &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; и &lt;code&gt;long&lt;/code&gt; . Если не указано иное, по умолчанию используется &lt;code&gt;short&lt;/code&gt; формат .</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">Ослабляя недоступные объекты, не пытайтесь ослабить объекты старше &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; . Это можно использовать для оптимизации записи любых объектов, которые будут немедленно удалены с помощью последующей &lt;code&gt;git prune&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">При слиянии аннотированного (и, возможно, подписанного) тега Git всегда создает фиксацию слияния, даже если возможно быстрое слияние, и шаблон сообщения фиксации подготовлен с сообщением тега. Кроме того, если тег подписан, проверка подписи отображается как комментарий в шаблоне сообщения. См. Также &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">При слиянии нот,будьте более многословными.При обрезке заметок сообщайте имена всех объектов,чьи заметки удалены.</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">При объединении нот работайте тихо.</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">При слиянии нот разрешайте конфликты нот,используя данную стратегию.Признаются следующие стратегии:&quot;ручной&quot; (по умолчанию),&quot;наш&quot;,&quot;их&quot;,&quot;союз&quot; и &quot;cat_sort_uniq&quot;.Эта опция отменяет настройку конфигурации &quot;notes.mergeStrategy&quot;.См.ниже раздел &quot;NOTES MERGE STRATEGIES&quot; для получения дополнительной информации о каждой стратегии слияния записей.</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">Если он отсутствует или установлен по &lt;code&gt;default&lt;/code&gt; , многие поля в структуре stat проверяются, чтобы определить, был ли файл изменен с тех пор, как Git просмотрел его. Когда эта переменная конфигурации установлена ​​на &lt;code&gt;minimal&lt;/code&gt; , субсекундную часть mtime и ctime, uid и gid владельца файла, номер inode (и номер устройства, если Git был скомпилирован для его использования), исключаются из проверка среди этих полей, оставляя только целую вторую часть mtime (и ctime, если &lt;code&gt;core.trustCtime&lt;/code&gt; ) и размер файла для проверки.</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">Когда более одной детали совпадает с контуром,более поздняя линия перекрывает более раннюю.Это переопределение выполняется для каждого атрибута.</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">Когда перемещенные линии окрашиваются, например, с &lt;code&gt;diff.colorMoved&lt;/code&gt; параметра diff.colorMoved , этот параметр управляет &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; как обрабатываются пробелы. Подробные сведения о допустимых режимах см. &lt;code&gt;--color-moved-ws&lt;/code&gt; в &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">При выводе нескольких патчей префиксом темы будет &amp;laquo;[PATCH n / m]&amp;raquo;. Чтобы принудительно добавить 1/1 для одного патча, используйте &lt;code&gt;-n&lt;/code&gt; . Чтобы опустить номера патчей в теме, используйте &lt;code&gt;-N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">Когда используются несколько рабочих деревьев, большинство файлов в $ GIT_DIR относятся к каждому рабочему дереву, за некоторыми известными исключениями. Однако все файлы, находящиеся под &lt;code&gt;common&lt;/code&gt; именем, будут совместно использоваться всеми рабочими деревьями.</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">Когда ни командная строка, ни конфигурация не указывают, что следует отправлять, используется поведение по умолчанию, которое соответствует &lt;code&gt;simple&lt;/code&gt; значению для &lt;code&gt;push.default&lt;/code&gt; : текущая ветвь передается в соответствующую ветвь восходящего потока, но в качестве меры безопасности push прерывается, если восходящая ветвь не имеет того же имени, что и локальная.</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; не указан, предполагается &lt;code&gt;stash@{0}&lt;/code&gt; , в противном случае &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; должен быть ссылкой в ​​форме &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если в командной строке не &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; аргумент --push-option = &amp;lt;option&amp;gt; , &lt;code&gt;git push&lt;/code&gt; ведет себя так, как если бы каждое &amp;lt;value&amp;gt; этой переменной задано как &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">Если в командной строке не &lt;code&gt;--whitespace&lt;/code&gt; флаг --whitespace , этот элемент конфигурации используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">Если в командной строке не было указано refspec, тогда &lt;code&gt;git pull&lt;/code&gt; использует refspec из конфигурации или &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; . В таких случаях применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">Если удаленное управление не указано (через -r), ветвь &lt;code&gt;HEAD&lt;/code&gt; из CVS импортируется в &lt;code&gt;origin&lt;/code&gt; ветвь в репозитории Git, поскольку &lt;code&gt;HEAD&lt;/code&gt; уже имеет особое значение для Git. Когда указан пульт, ветвь &lt;code&gt;HEAD&lt;/code&gt; называется remotes / &amp;lt;remote&amp;gt; / master mirroring &lt;code&gt;git clone&lt;/code&gt; behavior. Используйте эту опцию, если вы хотите импортировать в другую ветку.</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">Если удаленный сервер не указан, по умолчанию будет использоваться &lt;code&gt;origin&lt;/code&gt; пульт, если только для текущей ветви не настроена восходящая ветвь.</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">Находясь на ветке &amp;lt;имя&amp;gt;, он переопределяет &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; для отправки . Он также переопределяет &lt;code&gt;remote.pushDefault&lt;/code&gt; для отправки из ветки &amp;lt;name&amp;gt;. Когда вы извлекаете из одного места (например, из вашего восходящего потока) и отправляете в другое место (например, в ваш собственный репозиторий публикации), вам нужно установить &lt;code&gt;remote.pushDefault&lt;/code&gt; , чтобы указать удаленный пульт для отправки для всех веток, и использовать этот параметр, чтобы переопределить его для конкретной ветки.</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">Находясь в ветке &amp;lt;name&amp;gt;, он сообщает &lt;code&gt;git fetch&lt;/code&gt; и &lt;code&gt;git push&lt;/code&gt; ,с какого пульта выбрать / нажать. Удаленный, на который нужно отправить, может быть переопределен с помощью &lt;code&gt;remote.pushDefault&lt;/code&gt; (для всех веток). Пульт дистанционного управления для текущей ветки может быть переопределен с помощью &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; . Если пульт не настроен или вы не находитесь в какой-либо ветке, по умолчанию используется &lt;code&gt;origin&lt;/code&gt; для выборки и &lt;code&gt;remote.pushDefault&lt;/code&gt; для отправки . Кроме того, &lt;code&gt;.&lt;/code&gt; (точка) - текущий локальный репозиторий (точка-репозиторий), см &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; последнее примечание branch. &amp;lt;name&amp;gt; .merge ниже.</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">При указании одного из этих флагов имя объекта,записанное для путей,не обновляется.Вместо этого,эти опции устанавливают и снимают бит &quot;fsmonitor valid&quot; для путей.См.ниже раздел &quot;Монитор файловой системы&quot; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">При указании одного из этих флагов имя объекта,записанное для путей,не обновляется.Вместо этого,эти опции устанавливают и снимают бит &quot;skip-worktree&quot; для путей.Дополнительные сведения см.в разделе &quot;Бит пропуска рабочего дерева&quot; ниже.</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если один или несколько &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; указаны явно (в командной строке или с помощью &lt;code&gt;--stdin&lt;/code&gt; ), это может быть либо один шаблон, либо пара таких шаблонов, разделенных двоеточием &quot;:&quot; (это означает, что ссылка имя не может содержать двоеточие). Единственный шаблон &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; - это просто сокращение для &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">При упаковке капель быстрого импорта всегда пытаются опорочить последний написанный капля.Если это специально не устроено фронтендом,то,скорее всего,это будет не предыдущая версия того же файла,поэтому сгенерированная дельта будет не самой маленькой.Полученный пакетный файл будет сжат,но не будет оптимальным.</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">При передаче в &lt;code&gt;init&lt;/code&gt; или &lt;code&gt;clone&lt;/code&gt; это регулярное выражение будет сохранено как ключ конфигурации. Смотрите &lt;code&gt;fetch&lt;/code&gt; для описания &lt;code&gt;--ignore-paths&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">При передаче в &lt;code&gt;init&lt;/code&gt; или &lt;code&gt;clone&lt;/code&gt; это регулярное выражение будет сохранено как ключ конфигурации. См. &lt;code&gt;fetch&lt;/code&gt; для описания &lt;code&gt;--ignore-refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">При передаче в &lt;code&gt;init&lt;/code&gt; или &lt;code&gt;clone&lt;/code&gt; это регулярное выражение будет сохранено как ключ конфигурации. Смотрите &lt;code&gt;fetch&lt;/code&gt; для описания &lt;code&gt;--include-paths&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">Когда пути указаны, покажите их (обратите внимание, что на самом деле это не исходные имена путей, а скорее список шаблонов для сопоставления). В противном случае неявно использует корневой уровень дерева в качестве единственного аргумента пути.</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">Когда в командной строке указывается pathspec,зафиксируйте содержимое файлов,соответствующих pathspec,без записи изменений,уже добавленных в индекс.Содержимое этих файлов также инсценируется для следующей фиксации поверх того,что было инсценировано ранее.</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">Когда pathspec задается для &lt;code&gt;git stash push&lt;/code&gt; , новая запись stash записывает измененные состояния только для файлов, которые соответствуют pathspec. Записи индекса и файлы рабочего дерева затем откатываются до состояния HEAD только для этих файлов, оставляя неизменными файлы, которые не соответствуют pathspec.</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">Когда возможно, &lt;code&gt;pack-objects&lt;/code&gt; стараются повторно использовать существующие на диске дельты, чтобы избежать необходимости поиска новых на лету. Это важная оптимизация для обслуживания выборок, потому что это означает, что сервер может вообще избежать раздувания большинства объектов и просто отправлять байты прямо с диска. Эта оптимизация не может работать, когда объект хранится как дельта относительно базы, которой нет у получателя (и которую мы еще не отправляем). В этом случае сервер &amp;laquo;разрывает&amp;raquo; дельту и должен найти новый, у которого высокая стоимость процессора. Поэтому для производительности важно, чтобы набор объектов в дельта-отношениях на диске соответствовал тому, что клиент будет получать.</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">Если он присутствует, он также копирует значение &lt;code&gt;submodule.$name.update&lt;/code&gt; . $ Name.update . Эта команда не изменяет существующую информацию в .git / config. Затем вы можете настроить URL-адреса клонов подмодулей в .git / config для вашей локальной настройки и перейти к &lt;code&gt;git submodule update&lt;/code&gt; ; вы также можете просто использовать &lt;code&gt;git submodule update --init&lt;/code&gt; без явного шага &lt;code&gt;init&lt;/code&gt; если вы не собираетесь настраивать расположение каких-либо подмодулей.</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">При нажатии на пульт, отличный от пульта, с которого вы обычно подключаетесь, работайте как &lt;code&gt;current&lt;/code&gt; . Это самый безопасный вариант и подходит для новичков.</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">При нажатии,попросите удаленный сервер обновить ссылки в одной атомарной транзакции.В случае успеха все ссылки будут обновлены,или ни одна не будет обновлена.Если удаленная сторона не поддерживает эту возможность,нажатие будет неудачным.</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">При чтении переменной &lt;code&gt;core.repositoryformatversion&lt;/code&gt; реализация git, которая поддерживает версию 1, ДОЛЖНА также читать любые ключи конфигурации, найденные в разделе &lt;code&gt;extensions&lt;/code&gt; файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">При чтении трейлеров после токена,разделителя и значения могут быть белые пробела.Также внутри токена и значения могут быть пробелы.Значение может быть разбито на несколько строк с каждой последующей строкой,начинающейся с пробела,как,например,&quot;сгибание&quot; в RFC 822.</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">При чтении значения по умолчанию считываются из системных, глобальных и локальных файлов конфигурации репозитория, а параметры &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--local&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; и &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; могут использоваться для указания команда для чтения только из этого места (см. &lt;a href=&quot;#FILES&quot;&gt;ФАЙЛЫ&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">При записи фиксации добавьте строку с надписью &amp;laquo;(вишня, выбранная из фиксации&amp;hellip;)&amp;raquo; в исходное сообщение фиксации, чтобы указать, из какой фиксации было выбрано это изменение. Это делается только для вишенки без конфликтов. Не используйте эту опцию, если вы выбираете вишенку из своей частной ветки, потому что информация бесполезна для получателя. Если, с другой стороны, вы выбираете вишню между двумя общедоступными ветвями (например, переносите исправление в ветку обслуживания для более ранней версии из ветки разработки), добавление этой информации может быть полезно.</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">При записи вашей собственной работы содержимое измененных файлов в вашем рабочем дереве временно сохраняется в промежуточной области, называемой &amp;laquo;индексом&amp;raquo; с помощью &lt;code&gt;git add&lt;/code&gt; . Файл можно вернуть обратно, только в индексе, но не в рабочем дереве, к тому из последнего коммита с помощью &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; , который эффективно отменяет &lt;code&gt;git add&lt;/code&gt; и предотвращает участие изменений этого файла в следующая фиксация. После создания состояния, которое будет постепенно фиксироваться с помощью этих команд, &lt;code&gt;git commit&lt;/code&gt; (без каких-либо параметров пути) используется для записи того, что было поставлено до сих пор. Это самая простая форма команды. Пример:</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">Когда и удаленное,и локальное отделение называются &quot;test&quot;:</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">Когда используется переименование / копирование, &lt;code&gt;file1&lt;/code&gt; и &lt;code&gt;file2&lt;/code&gt; показывают имя исходного файла для переименования / копирования и имя файла, который производит переименование / копирование, соответственно.</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">При переупаковке с дельта-островами дельта-окно имеет тенденцию забиваться кандидатами, запрещенными конфигурацией. Переупаковка с помощью большого окна --window помогает (и не занимает столько времени, сколько могло бы быть в противном случае, потому что мы можем отклонить некоторые пары объектов на основе островов, прежде чем выполнять какие-либо вычисления с содержимым).</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">При восстановлении файлов в рабочем дереве из индекса используйте этап №2 ( &lt;code&gt;ours&lt;/code&gt; ) или этап №3 ( &lt;code&gt;theirs&lt;/code&gt; ) для несвязанных путей.</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">При восстановлении файлов в рабочем дереве из индекса не прерывайте операцию, если есть не объединенные записи и не &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; , &lt;code&gt;--merge&lt;/code&gt; или &lt;code&gt;--conflict&lt;/code&gt; . Незамкнутые пути на рабочем дереве остаются в покое.</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">При восстановлении файлов рабочего дерева из индекса воссоздайте конфликтное слияние в неупорядоченных путях.</target>
        </trans-unit>
        <trans-unit id="0bde8e78161181c9b276b62a2eb0f3a92764228a" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; line or &lt;code&gt;Signed-off-by&lt;/code&gt; trailer in the log message and use that as the author string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">При получении Svn фиксаций Into Git (как часть &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; или &lt;code&gt;dcommit&lt;/code&gt; операций), обратите внимание на первый &lt;code&gt;From:&lt;/code&gt; или &lt;code&gt;Signed-off-by:&lt;/code&gt; линиях в сообщении журнала и использовании, в качестве автора строки.</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">При использовании спецификаторов диапазона ревизий для ограничения аннотации,строки,которые не изменились с границы диапазона (либо фиксация v2.6.18,либо последняя фиксация,которой в приведенном выше примере более 3 недель),обвиняются в этой фиксации границы диапазона.</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">При перезаписи коммитов с помощью &amp;lt;command&amp;gt; (в настоящее время &lt;code&gt;amend&lt;/code&gt; или &lt;code&gt;rebase&lt;/code&gt; ) и для этой переменной установлено значение &lt;code&gt;true&lt;/code&gt; , Git автоматически копирует ваши заметки из оригинала в перезаписанный коммит. По умолчанию &lt;code&gt;true&lt;/code&gt; , но см. &amp;laquo;Notes.rewriteRef&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">При перезаписи коммитов с помощью &amp;lt;command&amp;gt; (в настоящее время &lt;code&gt;amend&lt;/code&gt; или &lt;code&gt;rebase&lt;/code&gt; ), если эта переменная имеет значение &lt;code&gt;false&lt;/code&gt; , git не будет копировать заметки из оригинала в перезаписанный коммит. По умолчанию &lt;code&gt;true&lt;/code&gt; . См. Также &amp;laquo; &lt;code&gt;notes.rewriteRef&lt;/code&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">При переписывании коммитов,примечания к которым нужно скопировать с оригинала на переписанный коммит.Должен быть список ссылок или глобусов,разделенных двоеточием.</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">При запуске из подкаталога проекта, с помощью этой опции можно указать исключить изменения вне каталога и показать относительные пути к нему. Когда вы не находитесь в подкаталоге (например, в пустом репозитории), вы можете указать, какой подкаталог будет выводиться относительно, указав &amp;lt;path&amp;gt; в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="1526deda1d1c171ba9bb8aedb499ef46fa3558ac" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument. &lt;code&gt;--no-relative&lt;/code&gt; can be used to countermand both &lt;code&gt;diff.relative&lt;/code&gt; config option and previous &lt;code&gt;--relative&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">При запуске из подкаталога команда обычно выводит пути относительно текущего каталога.Эта опция заставляет выводить пути относительно верхней директории проекта.</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">При запуске в каталоге, в котором нет каталога репозитория &quot;.git&quot;, Git пытается найти такой каталог в родительских каталогах, чтобы найти вершину рабочего дерева, но по умолчанию он не пересекает границы файловой системы. Для этой переменной среды можно установить значение true, чтобы Git не останавливался на границах файловой системы. Как и &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; , это не повлияет на явный каталог репозитория, установленный через &lt;code&gt;GIT_DIR&lt;/code&gt; или в командной строке.</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">При запуске команды с параметрами &lt;code&gt;-u&lt;/code&gt; и &lt;code&gt;-m&lt;/code&gt; в результате слияния может потребоваться перезапись путей, которые не отслеживаются в текущей ветви. Команда обычно отказывается продолжить слияние, чтобы не потерять такой путь. Однако этот предохранительный клапан иногда мешает. Например, часто бывает , что другая ветвь добавляется файл , который используется , чтобы быть сгенерированным файлом в вашей отрасли, и спусковой предохранительный клапан при попытке переключиться на эту ветвь после вы запускали &lt;code&gt;make&lt;/code&gt; , но перед запуском &lt;code&gt;make clean&lt;/code&gt; , чтобы удалить генерируемый файл. Эта опция сообщает команде, что нужно читать исключаемый файл для каждого каталога (обычно &lt;code&gt;.gitignore&lt;/code&gt; ), и позволяет перезаписать такой неотслеживаемый, но явно игнорируемый файл.</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">Отправляя патч таким способом, чаще всего вы отправляете свой собственный патч, поэтому в дополнение к маркеру &amp;laquo; &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; &amp;raquo; вы должны опустить строки &lt;code&gt;From:&lt;/code&gt; и &lt;code&gt;Date:&lt;/code&gt; в файле патча. Название патча, вероятно, будет отличаться от темы обсуждения, на которое патч отвечает, поэтому вполне вероятно, что вы захотите сохранить строку Subject:, как в примере выше.</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">Если установлено значение &amp;laquo; &lt;code&gt;always&lt;/code&gt; , всегда выделять совпадения. Когда &lt;code&gt;false&lt;/code&gt; (или &lt;code&gt;never&lt;/code&gt; ), никогда. Если установлено значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;auto&lt;/code&gt; , использовать цвет только тогда, когда вывод записывается на терминал. Если не задано, используется значение &lt;code&gt;color.ui&lt;/code&gt; ( по умолчанию &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">Если установлено значение &lt;code&gt;always&lt;/code&gt; , всегда используйте цвета для интерактивных подсказок и дисплеев (например, те, которые используются командами &amp;laquo;git-add --interactive&amp;raquo; и &amp;laquo;git-clean --interactive&amp;raquo;). Когда ложно (или &lt;code&gt;never&lt;/code&gt; ), никогда. Если установлено значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;auto&lt;/code&gt; , используйте цвета только при выводе на терминал. Если не задано, используется значение &lt;code&gt;color.ui&lt;/code&gt; ( по умолчанию &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;git apply&lt;/code&gt; игнорирует изменения в &lt;code&gt;--ignore-space-change&lt;/code&gt; же, как параметр --ignore-space-change . Если установлено одно из: no, none, never, false сообщает &lt;code&gt;git apply&lt;/code&gt; , чтобы он уважал все различия в пробелах. См. &lt;a href=&quot;git-apply&quot;&gt;Git-apply [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">Если установлено &lt;code&gt;merges&lt;/code&gt; , перебазируйте с помощью &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; , чтобы локальные коммиты слияния включались в перебазирование (подробности см. В &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">Если установлено значение &lt;code&gt;preserve&lt;/code&gt; (устарело в пользу &lt;code&gt;merges&lt;/code&gt; ), перебазируйте с параметром &lt;code&gt;--preserve-merges&lt;/code&gt; , переданным в &lt;code&gt;git rebase&lt;/code&gt; , чтобы локально созданные коммиты слияния не сглаживались.</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;git reset&lt;/code&gt; по умолчанию будет использовать параметр &lt;code&gt;--quiet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;git-rerere&lt;/code&gt; обновляет индекс полученным содержимым после того, как полностью разрешает конфликты с использованием ранее записанного разрешения. По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">При установке значения true клон этого субмодуля будет выполняться как мелкий клон (с глубиной истории 1),если только пользователь явно не запросит не мелкий клон.</target>
        </trans-unit>
        <trans-unit id="6b72e60e4df8bc4b62a55c38ddf1b7b574998e6d" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">Если установлено значение true, автоматически создавать временную запись в тайнике перед началом операции и применять ее после завершения операции. Это означает, что вы можете запустить rebase на грязном рабочем дереве. Однако используйте с осторожностью: последнее приложение тайника после успешной перебазирования может привести к нетривиальным конфликтам. Этот параметр может быть отменен параметрами &lt;code&gt;--no-autostash&lt;/code&gt; и &lt;code&gt;--autostash&lt;/code&gt; команды &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; . По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">Если установлено значение true, выборка с этого пульта по умолчанию также удалит все локальные теги, которые больше не существуют на пульте, если сокращение активировано в целом через &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; , &lt;code&gt;fetch.prune&lt;/code&gt; или &lt;code&gt;--prune&lt;/code&gt; . Переопределяет настройки &lt;code&gt;fetch.pruneTags&lt;/code&gt; , если они есть.</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">Если установлено значение true, выборка с этого пульта по умолчанию также удалит все ссылки удаленного отслеживания, которые больше не существуют на пульте (как если бы в &lt;code&gt;--prune&lt;/code&gt; была указана опция --prune ). Переопределяет настройки &lt;code&gt;fetch.prune&lt;/code&gt; , если они есть.</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">Когда установлено значение true,git-receive-pack будет рекламировать своим клиентам возможности push options.Ложно по умолчанию.</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">Когда установлено значение true,этот пульт будет использоваться для получения объектов промоутеров.</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">Если установлено, выборка или получение будет прервана в случае искаженного объекта или ссылки на несуществующий объект. Кроме того, проверяются различные другие проблемы, в том числе устаревшие проблемы (см. &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ) и потенциальные проблемы безопасности, такие как наличие &lt;code&gt;.GIT&lt;/code&gt; или вредоносного файла &lt;code&gt;.gitmodules&lt;/code&gt; (см. Примечания к выпуску для v2. 2.1 и v2.17.1 для подробностей). Другие проверки работоспособности и безопасности могут быть добавлены в будущих выпусках.</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">При отображении &lt;code&gt;short&lt;/code&gt; или &lt;code&gt;porcelain&lt;/code&gt; вывода состояния распечатайте имя файла дословно и завершите записи NUL вместо LF. Если формат не указан, подразумевается выходной формат &lt;code&gt;--porcelain&lt;/code&gt; . Без опции &lt;code&gt;-z&lt;/code&gt; имена файлов с &amp;laquo;необычными&amp;raquo; символами заключаются в кавычки, как описано для переменной конфигурации &lt;code&gt;core.quotePath&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">При отображении изменений, включающих переименование или копирование, вывод &lt;code&gt;--stat&lt;/code&gt; форматирует путевые имена компактно, комбинируя общий префикс и суффикс путевых имен. Например, изменение, которое перемещает &lt;code&gt;arch/i386/Makefile&lt;/code&gt; в &lt;code&gt;arch/x86/Makefile&lt;/code&gt; при изменении 4 строк, будет показано следующим образом:</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">При отображении сообщений о фиксации,также показывайте заметки,которые хранятся в данном справочнике.Примечания должны быть полностью квалифицированными.Если данный реферат не существует,это не ошибка,но означает,что никакие заметки не должны быть напечатаны.</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">При отображении имен объектов добавляйте к ним префикс &lt;code&gt;^&lt;/code&gt; и удаляйте префикс &lt;code&gt;^&lt;/code&gt; из имен объектов, у которых он уже есть.</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">При отображении значения &amp;lt;name&amp;gt; как символической ссылки, попробуйте сократить значение, например, от &lt;code&gt;refs/heads/master&lt;/code&gt; до &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">При отображении с помощью &lt;code&gt;git diff-tree -c&lt;/code&gt; он сравнивает родителей коммита слияния с результатом слияния (то есть file1..fileN являются родителями). При отображении с помощью &lt;code&gt;git diff-files -c&lt;/code&gt; он сравнивает два неразрешенных родителя слияния с файлом рабочего дерева (т.е. file1 - это этап 2, также известный как &amp;laquo;наша версия&amp;raquo;, file2 - это этап 3, также известный как &amp;laquo;их версия&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">Когда некоторые коммиты были пропущены (используя &quot;git-bisect skip&quot;),то алгоритм биссекции тот же,что и для шага 1)-3).Но затем мы используем примерно следующие шаги:</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">Если указано один или несколько раз, &lt;code&gt;-L&lt;/code&gt; ограничивает аннотацию запрошенными строками.</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">При указании опции -v используется формат:</target>
        </trans-unit>
        <trans-unit id="3b090cc032845d040434a6c212a06329d4b2d7ed" translate="yes" xml:space="preserve">
          <source>When subcommands such as &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;rename&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; can&amp;rsquo;t find the remote in question, the exit status is &lt;code&gt;2&lt;/code&gt;. When the remote already exists, the exit status is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">При переключении ветвей с помощью &lt;code&gt;--merge&lt;/code&gt; поэтапные изменения могут быть потеряны.</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">При переключении веток,если у вас есть локальные изменения в одном или нескольких файлах,которые отличаются между текущей веткой и веткой,в которую вы переключаетесь,команда отказывается переключать ветки,чтобы сохранить ваши изменения в контексте.Однако,с помощью этой опции выполняется трёхстороннее слияние между текущей веткой,содержимым вашего рабочего дерева и новым ответвлением,и вы будете находиться в новом ответвлении.</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">При переключении ветвей продолжайте, даже если индекс или рабочее дерево отличается от &lt;code&gt;HEAD&lt;/code&gt; . Это используется для отбрасывания локальных изменений.</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">При использовании опции &quot;-С&quot; исходное содержимое измененных файлов,а также удаленных файлов (а также немодифицированных файлов,если используется опция &quot;--find-copies-harder&quot;)считаются кандидатами исходных файлов в операции переименования/копирования.Если входные данные были похожи на эти пары файлов,то речь идет об измененном файле fileY и вновь созданном файле file0:</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">Когда аргумент &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; является именем ветки, параметр &lt;code&gt;--detach&lt;/code&gt; может использоваться для отсоединения &lt;code&gt;HEAD&lt;/code&gt; от конца ветки ( &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; проверяет эту ветку без отсоединения &lt;code&gt;HEAD&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">Если &lt;code&gt;--aggressive&lt;/code&gt; параметр --aggressive , &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; будет вызываться с флагом &lt;code&gt;-f&lt;/code&gt; , который, в свою очередь, передаст &lt;code&gt;--no-reuse-delta&lt;/code&gt; в &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; . Это отбросит все существующие дельты и пересчитает их, за счет гораздо большего количества времени на переупаковку.</target>
        </trans-unit>
        <trans-unit id="36c732582138b85601314513444f94ba223454f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--auto-merge&lt;/code&gt; is given, meld will merge all non-conflicting parts automatically, highlight the conflicting parts and wait for user decision. Setting &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--auto-merge&lt;/code&gt; option with &lt;code&gt;meld&lt;/code&gt;. Setting this value to &lt;code&gt;auto&lt;/code&gt; makes git detect whether &lt;code&gt;--auto-merge&lt;/code&gt; is supported and will only use &lt;code&gt;--auto-merge&lt;/code&gt; when available. A value of &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--auto-merge&lt;/code&gt; altogether, and is the default value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">Когда &lt;code&gt;--stdin&lt;/code&gt; опция --stdin , шаблоны считываются из стандарта в виде списка, разделенного новой строкой, а не из аргументов.</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">Когда используется опция &lt;code&gt;-l&lt;/code&gt; , формат меняется на</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">Когда задана опция &lt;code&gt;-z&lt;/code&gt; , пути печатаются как есть и без кавычек, а строки заканчиваются байтом NUL (ASCII 0x00).</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">Когда файл &lt;code&gt;.gitattributes&lt;/code&gt; отсутствует в рабочем дереве, путь в индексе используется как резервный. В процессе оформления &lt;code&gt;.gitattributes&lt;/code&gt; используются атрибуты .gitattributes в индексе, а затем файл в рабочем дереве используется в качестве запасного варианта .</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">Когда переменная среды &lt;code&gt;LESS&lt;/code&gt; не задана, Git устанавливает ее в &lt;code&gt;FRX&lt;/code&gt; (если задана переменная среды &lt;code&gt;LESS&lt;/code&gt; , Git вообще ее не изменяет). Если вы хотите выборочно переопределить настройку Git по умолчанию для &lt;code&gt;LESS&lt;/code&gt; , вы можете установить &lt;code&gt;core.pager&lt;/code&gt; , например, &lt;code&gt;less -S&lt;/code&gt; . Это будет передано в оболочку Git, который переведет последнюю команду в &lt;code&gt;LESS=FRX less -S&lt;/code&gt; . Среда не устанавливает параметр &lt;code&gt;S&lt;/code&gt; , но командная строка устанавливает, давая команду less обрезать длинные строки. Точно так же установка &lt;code&gt;core.pager&lt;/code&gt; на &lt;code&gt;less -+F&lt;/code&gt; отключит &lt;code&gt;F&lt;/code&gt; параметр, заданный средой из командной строки, деактивируя поведение &amp;laquo;выйти, если один экран&amp;raquo; &lt;code&gt;less&lt;/code&gt; . Можно специально активировать некоторые флаги для определенных команд: например, установка &lt;code&gt;pager.blame&lt;/code&gt; на &lt;code&gt;less -S&lt;/code&gt; позволяет обрезать строку только для &lt;code&gt;git blame&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">При &lt;code&gt;core.fsmonitor&lt;/code&gt; переменной конфигурации core.fsmonitor монитор файловой системы добавляется в индекс или удаляется из него при следующем чтении индекса командой. Когда используется &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; , монитор файловой системы немедленно добавляется в индекс или удаляется из него.</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">При &lt;code&gt;core.untrackedCache&lt;/code&gt; переменной конфигурации core.untrackedCache неотслеживаемый кеш добавляется или удаляется из индекса в следующий раз, когда команда читает индекс; в то время как, когда используется &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; , неотслеживаемый кеш немедленно добавляется в индекс или удаляется из него.</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">Если для пути установлен атрибут &lt;code&gt;ident&lt;/code&gt; ity , Git заменяет &lt;code&gt;$Id$&lt;/code&gt; в объекте большого двоичного объекта на &lt;code&gt;$Id:&lt;/code&gt; за которым следует 40-символьное шестнадцатеричное имя объекта большого двоичного объекта, за которым следует знак доллара &lt;code&gt;$&lt;/code&gt; при оформлении заказа. Любая последовательность байтов, которая начинается с &lt;code&gt;$Id:&lt;/code&gt; и заканчивается символом &lt;code&gt;$&lt;/code&gt; в файле рабочего дерева, при регистрации заменяется на &lt;code&gt;$Id$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5a78c9a8f92224d51a41a84dbc93a853baeb6f6" translate="yes" xml:space="preserve">
          <source>When the browser, specified by options or configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;browser.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then &lt;code&gt;git web--browse&lt;/code&gt; will treat the specified tool as a custom command and will use a shell eval to run the command with the URLs passed as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">Когда команда переходит в интерактивный режим,она показывает файлы и каталоги,которые необходимо очистить,и переходит в свой интерактивный командный цикл.</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">Когда команда переходит в интерактивный режим, она показывает вывод подкоманды &lt;code&gt;status&lt;/code&gt; , а затем переходит в интерактивный командный цикл.</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">Когда команда вызывается из подкаталога,покажите путь текущей директории относительно директории верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">При вызове команды из подкаталога,покажите путь к каталогу верхнего уровня относительно текущего каталога (обычно это последовательность &quot;../&quot;,или пустая строка).</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">Когда команда выполняется без pathspec,она ошибается,вместо того,чтобы деинитовать все,чтобы предотвратить ошибки.</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">Когда в командной строке не указывается, что &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; аргументами &amp;lt;refspec&amp;gt; ... или параметрами &lt;code&gt;--all&lt;/code&gt; , &lt;code&gt;--mirror&lt;/code&gt; , &lt;code&gt;--tags&lt;/code&gt; , команда находит &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; по умолчанию , консультируясь с конфигурацией &lt;code&gt;remote.*.push&lt;/code&gt; и если он не найден, &lt;code&gt;push.default&lt;/code&gt; конфигурацию push.default, чтобы решить, что &lt;code&gt;push.default&lt;/code&gt; значение push.default см. в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">Если в командной строке не указано, куда отправлять с аргументом &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; , выполняется консультация с &lt;code&gt;branch.*.remote&lt;/code&gt; конфигурацией branch. *. Для текущей ветки, чтобы определить, куда отправлять. Если конфигурация отсутствует, по умолчанию используется &lt;code&gt;origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">Когда различия при фиксации различаются, &lt;code&gt;git range-diff&lt;/code&gt; воссоздает исходную окраску различий и добавляет внешние маркеры различий - / + с красным / зеленым &lt;strong&gt;фоном&lt;/strong&gt; , чтобы их было легче увидеть, например, когда было изменение в том, какие именно строки были добавлены ,</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">Когда сообщение журнала фиксации начинается с &amp;laquo;squash!&amp;hellip;&amp;raquo; (Или &amp;laquo;fixup!&amp;hellip;&amp;raquo;), И в списке задач уже есть фиксация, которая соответствует тому же &lt;code&gt;...&lt;/code&gt; , автоматически измените список задач rebase -i так что коммит помечено для раздавливания приходит сразу после фиксации необходимо изменить, и изменить действие перемещенного совершить из &lt;code&gt;pick&lt;/code&gt; в &lt;code&gt;squash&lt;/code&gt; (или &lt;code&gt;fixup&lt;/code&gt; ). Фиксация соответствует &lt;code&gt;...&lt;/code&gt; , если совпадает тема фиксации или если &lt;code&gt;...&lt;/code&gt; относится к хешу фиксации. В качестве запасного варианта также работают частичные совпадения с предметом коммита. Рекомендуемый способ создания Fixup / сквош совершающего это с помощью &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; варианты &lt;a href=&quot;git-commit&quot;&gt;мерзавца фиксации [1]&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">Когда установлен ключ конфигурации &lt;code&gt;extensions.partialclone&lt;/code&gt; , он указывает, что репо было создано с частичным клоном (или позже выполнено частичное получение) и что удаленный компьютер мог пропустить отправку определенных нежелательных объектов. Такой пульт называется &amp;laquo;пульт-обещатель&amp;raquo;, и он обещает, что все такие пропущенные объекты могут быть извлечены из него в будущем.</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">Когда для ключа конфигурации &lt;code&gt;extensions.preciousObjects&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , объекты в репозитории НЕ ДОЛЖНЫ быть удалены (например, с помощью &lt;code&gt;git-prune&lt;/code&gt; или &lt;code&gt;git repack -d&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">Когда текущий рабочий каталог находится ниже директории хранилища,выведите &quot;true&quot;,в противном случае &quot;false&quot;.</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">При нахождении текущей рабочей директории внутри рабочего дерева хранилища выведите &quot;true&quot;,иначе &quot;false&quot;.</target>
        </trans-unit>
        <trans-unit id="e614fb1c074d0b3ebd865c7756d786dc01074ea4" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called to generate diffs, and Git does not use its builtin diff machinery. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">Когда переменная среды &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; установлена, вызывается названная ею программа вместо вызова diff, описанного выше. Для добавленного, удаленного или измененного пути &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; вызывается с 7 параметрами:</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">Когда запускается команда git-rebase, она сначала выполняет перехватчик pre-rebase, если он существует. Вы можете использовать этот хук для проверки работоспособности и отклонения перебазирования, если это не подходит. См. Пример в сценарии ловушки предварительной перебазировки шаблона.</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">Когда история включает в себя перекрестные слияния, для двух коммитов может быть более одного &lt;code&gt;best&lt;/code&gt; общего предка. Например, с такой топологией:</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">Когда программа просмотра man, указанная в переменных конфигурации &lt;code&gt;man.viewer&lt;/code&gt; , не входит в число поддерживаемых, будет найдена соответствующая переменная конфигурации &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; . Если эта переменная существует, то указанный инструмент будет рассматриваться как пользовательская команда, и для выполнения команды будет использоваться eval оболочки с переданной в качестве аргументов страницей руководства.</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">Когда вывод поступает на терминал, он по умолчанию имеет цветовую кодировку, как и обычный вывод &lt;code&gt;git diff&lt;/code&gt; . Кроме того, первая строка (добавление фиксации) зеленая, последняя строка (удаление фиксации) красная, вторая строка (с идеальным совпадением) желтая, как заголовок фиксации вывода &lt;code&gt;git show&lt;/code&gt; , а третья Строка окрашивает старую фиксацию в красный цвет, новую - в зеленый, а остальное - как заголовок фиксации &lt;code&gt;git show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Если патч не применяется правильно, вернитесь к трехстороннему слиянию, если патч записывает идентичность больших двоичных объектов, к которым он должен применяться, и эти капли доступны локально. &lt;code&gt;--no-3way&lt;/code&gt; можно использовать для переопределения переменной конфигурации am.threeWay. Для получения дополнительной информации см. Am.threeWay в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">Когда патч не применяется чисто, вернитесь к трехстороннему слиянию, если патч записывает идентичность больших двоичных объектов, к которым он должен применяться, и у нас есть эти капли, доступные локально, возможно, оставляя маркеры конфликтов в файлах в рабочем дереве. для разрешения пользователя. Этот параметр подразумевает параметр &lt;code&gt;--index&lt;/code&gt; и несовместим с параметрами &lt;code&gt;--reject&lt;/code&gt; и &lt;code&gt;--cached&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">Когда отправка завершена, выводится один или несколько &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; или &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; строки, чтобы указать успех или неудачу каждой отправленной ссылки. Вывод отчета о состоянии заканчивается пустой строкой. Поле параметра &amp;lt;why&amp;gt; может быть заключено в кавычки в строке стиля C, если оно содержит LF.</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">Когда известно, что удаленная ветвь, которую вы хотите получить, регулярно перематывается и переустанавливается, ожидается, что ее новый наконечник не будет потомком его предыдущего наконечника (как хранится в вашей ветке удаленного отслеживания при последней выборке). Вы можете использовать знак &lt;code&gt;+&lt;/code&gt; , чтобы указать, что для таких веток потребуются обновления без перемотки вперед. Невозможно определить или объявить, что ветка будет доступна в репозитории с таким поведением; извлекающий пользователь просто должен знать, что это ожидаемый шаблон использования ветки.</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">Когда в репозитории есть голая печать &quot;true&quot;,в противном случае &quot;false&quot;.</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">Если в репозитории выведено мелкое &quot;true&quot;,в противном случае &quot;false&quot;.</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">Когда хранилище назван &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; имеет фиксацию на кончике реф , который отличается от исх у вас есть локально, вы можете использовать &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; синтаксис, чтобы иметь свое локальное имя, двоеточие &lt;code&gt;:&lt;/code&gt; , и его удаленное имя.</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">Когда репозиторий, из которого нужно клонировать, находится на локальном компьютере, этот флаг обходит обычный транспортный механизм &amp;laquo;с учетом Git&amp;raquo; и клонирует репозиторий, создавая копию HEAD и всего, что находится в каталогах объектов и ссылок. Файлы в каталоге &lt;code&gt;.git/objects/&lt;/code&gt; жестко связаны для экономии места, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">Когда репозиторий для клонирования находится на локальном компьютере, вместо использования жестких ссылок автоматически настраивайте &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; для совместного использования объектов с исходным репозиторием. Результирующий репозиторий запускается без какого-либо собственного объекта.</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">Когда результатом &lt;code&gt;git bisect&lt;/code&gt; является фиксация без слияния, вы обычно можете обнаружить проблему, изучив только эту фиксацию. Разработчики могут упростить это, разбив свои изменения на небольшие автономные коммиты. Однако это не поможет в приведенном выше случае, потому что проблема не очевидна при изучении любого отдельного коммита; вместо этого требуется глобальный взгляд на развитие. Что еще хуже, изменение семантики проблемной функции может быть лишь небольшой частью изменений в верхней строке разработки.</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">При использовании функции разделения индекса файлы общих индексов, которые не были изменены с момента, указанного в этой переменной, будут удалены при создании нового файла общего индекса. Значение &amp;laquo;сейчас&amp;raquo; немедленно удаляет все записи, а &amp;laquo;никогда&amp;raquo; полностью подавляет истечение срока. Значение по умолчанию - &amp;laquo;2.weeks.ago&amp;raquo;. Обратите внимание, что файл общего индекса считается измененным (с целью истечения срока его действия) каждый раз, когда на его основе создается новый файл с разделенным индексом или считывается из него. См. &lt;a href=&quot;git-update-index&quot;&gt;Git-update-index [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">Когда используется функция разделенного индекса, это указывает процент записей, которые может содержать разделенный индекс, по сравнению с общим количеством записей как в разделенном индексе, так и в общем индексе до записи нового общего индекса. Значение должно быть от 0 до 100. Если значение равно 0, то всегда записывается новый общий индекс, если он равен 100, новый общий индекс никогда не записывается. По умолчанию значение равно 20, поэтому новый общий индекс будет записан, если количество записей в разделенном индексе будет больше 20 процентов от общего количества записей. См. &lt;a href=&quot;git-update-index&quot;&gt;Git-update-index [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1631afdb92ffecd0a40ddcd8f40433691ff79d82" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt; (or just &lt;code&gt;i&lt;/code&gt;), the rebase is run in interactive mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">Когда значение является &lt;code&gt;interactive&lt;/code&gt; , перебазирование выполняется в интерактивном режиме.</target>
        </trans-unit>
        <trans-unit id="2a8620af5de619d02cbdb1290090cf457f4270c6" translate="yes" xml:space="preserve">
          <source>When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">Когда в репозитории примерно больше свободных объектов, &lt;code&gt;git gc --auto&lt;/code&gt; упакует их. Некоторые команды Porcelain используют эту команду для выполнения время от времени упрощенной сборки мусора. Значение по умолчанию - 6700.</target>
        </trans-unit>
        <trans-unit id="c316674f184677333eb7d2b00fe1f02bf0eda4b8" translate="yes" xml:space="preserve">
          <source>When there are content conflicts, the merge machinery tries to annotate each side&amp;rsquo;s conflict markers with the commits where the content came from. Since the apply backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary. Also, when merge.conflictStyle is set to diff3, the apply backend will use &quot;constructed merge base&quot; to label the content from the merge base, and thus provide no information about the merge base commit whatsoever.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">Если в репозитории имеется большее количество пакетов, не отмеченных &lt;code&gt;*.keep&lt;/code&gt; файлом, &lt;code&gt;git gc --auto&lt;/code&gt; объединяет их в один более крупный пакет. Значение по умолчанию - 50. Установка этого значения в 0 отключает его. Установка &lt;code&gt;gc.auto&lt;/code&gt; на 0 также отключит это.</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">Когда указан только один аргумент, а его нет &lt;code&gt;--&lt;/code&gt; (например, &lt;code&gt;git checkout abc&lt;/code&gt; ), и когда аргумент является как допустимым &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (например, существует ветвь &lt;code&gt;abc&lt;/code&gt; ), так и допустимым &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (например, файл или существует каталог с именем &amp;laquo;abc&amp;raquo;), Git обычно просит вас устранить неоднозначность. Однако, поскольку извлечение ветки является очень распространенной операцией, в такой ситуации &lt;code&gt;git checkout abc&lt;/code&gt; принимает &amp;laquo;abc&amp;raquo; в качестве &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; . Используйте &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; если вы хотите извлечь эти пути из индекса.</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">При установке этих переменных окружения соответствующие аргументы командной строки могут не использоваться.</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">Когда указан этот флаг, пакет читается из стандартного ввода, а затем его копия записывается в &amp;lt;pack-file&amp;gt;. Если &amp;lt;pack-file&amp;gt; не указан, пакет записывается в каталог objects / pack / текущего репозитория Git с именем по умолчанию, определяемым из содержимого пакета. Если &amp;lt;pack-file&amp;gt; не указан, рассмотрите возможность использования --keep, чтобы предотвратить состояние гонки между этим процессом и &lt;code&gt;git repack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">При установке этого флага имена объектов,записанные для путей,не обновляются.Вместо этого,данная опция устанавливает/удаляет бит &quot;assume unchanged&quot; для путей.При включённом бите &quot;assume unchanged&quot; (не изменять)пользователь обещает не изменять файл и позволяет Git'у полагать,что файл рабочего дерева соответствует тому,что записано в индексе.Если вы хотите изменить файл рабочего дерева,вам нужно снять бит,чтобы сообщить Git'у.Это иногда полезно при работе с большим проектом на файловой системе с очень медленным системным вызовом lstat(2)(например,cifs).</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">Когда эта форма &lt;code&gt;git read-tree&lt;/code&gt; возвращается успешно, вы можете увидеть , какие из &amp;laquo;локальных изменений&amp;raquo; , которые были внесены были перенесены, запустив &lt;code&gt;git diff-index --cached $M&lt;/code&gt; . Обратите внимание, что это не обязательно соответствует тому, что &lt;code&gt;git diff-index --cached $H&lt;/code&gt; произвел бы до такого слияния двух деревьев. Это из-за случаев 18 и 19 - если у вас уже были изменения в $ M (например, возможно, вы получили его по электронной почте в форме патча), &lt;code&gt;git diff-index --cached $H&lt;/code&gt; сказал бы вам об изменении до этого слияния, но оно не будет отображаться в &lt;code&gt;git diff-index --cached $M&lt;/code&gt; после слияния двух деревьев.</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">Когда указана эта опция, поведение выглядит так, как если бы в начале командной строки был добавлен специальный аргумент &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; , где &amp;lt;value&amp;gt; принимается как стандартный вывод указанной команды с любыми ведущими и завершающие пробелы обрезаны.</target>
        </trans-unit>
        <trans-unit id="fe0e96d95c4eefa9bfe72917d015cf48a18efcc2" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">Когда этот специальный атрибут считывается &lt;code&gt;git credential&lt;/code&gt; , значение анализируется как URL-адрес и обрабатывается так, как если бы были прочитаны его составные части (например, &lt;code&gt;url=https://example.com&lt;/code&gt; будет вести себя так, как если бы &lt;code&gt;protocol=https&lt;/code&gt; и &lt;code&gt;host=example.com&lt;/code&gt; был предоставлен). Это может помочь вызывающим абонентам избежать самостоятельного анализа URL-адресов. Обратите внимание, что любые компоненты, отсутствующие в URL-адресе (например, в приведенном выше примере нет имени пользователя), будут установлены как пустые; если вы хотите предоставить URL-адрес и переопределить некоторые атрибуты, сначала укажите атрибут URL-адреса, а затем любые переопределения.</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">Когда файлы трассировок записываются в целевую директорию,они будут именоваться в соответствии с последним компонентом SID (опционально за ними следует счетчик,чтобы избежать столкновений имен файлов).</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">При отслеживании нескольких каталогов (с использованием параметров --stdlayout, --branches или --tags) git svn попытается подключиться к корню (или самому высокому разрешенному уровню) репозитория Subversion. Это значение по умолчанию позволяет лучше отслеживать историю, если целые проекты перемещаются в репозиторий, но может вызвать проблемы в репозиториях, где есть ограничения доступа для чтения. Передача &lt;code&gt;--no-minimize-url&lt;/code&gt; позволит git svn принимать URL-адреса как есть, не пытаясь подключиться к каталогу более высокого уровня. Этот параметр отключен по умолчанию, если отслеживается только один URL / ветка (от этого мало пользы).</target>
        </trans-unit>
        <trans-unit id="442a6a05d34f849ad275ea5e7d6f50f5aafe59d9" translate="yes" xml:space="preserve">
          <source>When true, and when reachability bitmaps are enabled, pack-objects will try to send parts of the bitmapped packfile verbatim. This can reduce memory and CPU usage to serve fetches, but might result in sending a slightly larger pack. Defaults to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">Если true, git по умолчанию будет использовать параметр &lt;code&gt;--sparse&lt;/code&gt; в &lt;code&gt;git pack-objects&lt;/code&gt; , если &lt;code&gt;--revs&lt;/code&gt; параметр --revs . Этот алгоритм обходит только деревья, которые появляются на путях, которые вводят новые объекты. Это может иметь значительные преимущества в производительности при вычислении пакета для отправки небольшого изменения. Однако возможно, что в pack-файл будут добавлены дополнительные объекты, если включенные коммиты содержат определенные типы прямого переименования. По умолчанию &lt;code&gt;false&lt;/code&gt; , если не включен &lt;code&gt;feature.experimental&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a46d4189a8b9229b7d91d54cdebfebe81ffd9ae6" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">Если true, git будет включать раздел &amp;laquo;хеш-кеш&amp;raquo; в индекс растрового изображения (если он записан). Этот кеш можно использовать для передачи дельта-эвристики git, что потенциально может привести к улучшению разницы между объектами с растровым отображением и без него (например, при обслуживании выборки между более старым пакетом с растровым отображением и объектами, которые были отправлены с момента последнего gc). Обратной стороной является то, что он потребляет 4 байта на объект дискового пространства. По умолчанию true.</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">Если это так,то при упаковке в stdout git будет использовать растровые пакеты (если они есть)(например,во время серверной стороны получения).По умолчанию равно true.Обычно вам не нужно выключать это значение,если только вы не отлаживаете битовые карты пакета.</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">Если установлено значение true, git будет записывать индекс растрового изображения при упаковке всех объектов на диск (например, при запуске &lt;code&gt;git repack -a&lt;/code&gt; ). Этот индекс может ускорить фазу &amp;laquo;подсчета объектов&amp;raquo; последующих пакетов, созданных для клонов и выборок, за счет некоторого дискового пространства и дополнительного времени, затрачиваемого на начальную репакцию. Это не действует, если создано несколько файлов пакетов. По умолчанию true для голых репозиториев, в противном случае - false.</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">Если установлено значение true, перебазировать ветки поверх полученной ветки вместо объединения ветки по умолчанию с удаленного по умолчанию при запуске &amp;laquo;git pull&amp;raquo;. См. &quot;Branch. &amp;lt;name&amp;gt; .rebase&quot; для настройки этого для каждой ветки.</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">Если установлено значение true, переставьте ветвь &amp;lt;name&amp;gt; поверх выбранной ветки вместо слияния ветки по умолчанию с удаленного по умолчанию при запуске &amp;laquo;git pull&amp;raquo;. См. &quot;Pull.rebase&quot; для того, чтобы сделать это не привязанным к ветке способом.</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">Когда это верно,перезагрузите текущее ответвление на верхней части верхнего течения после извлечения.Если есть удалённое отслеживаемое ответвление,соответствующее верхнему ответвлению,и ответвление верхнего уровня было перебазировано с момента последней загрузки,то этот перебазинг использует эту информацию,чтобы избежать перебазирования нелокальных изменений.</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">Когда даются два дерева,он сравнивает первое дерево со вторым.Когда задан один коммит,он сравнивает коммит со своими родителями.Остальные коммиты,когда они заданы,используются,как если бы они были родителями первого коммита.</target>
        </trans-unit>
        <trans-unit id="6b17aa5b71b9d47ea9adc71f193314f65da5b538" translate="yes" xml:space="preserve">
          <source>When two trees are specified, the user is telling &lt;code&gt;git read-tree&lt;/code&gt; the following:</source>
          <target state="translated">Когда указаны два дерева, пользователь сообщает &lt;code&gt;git read-tree&lt;/code&gt; следующее:</target>
        </trans-unit>
        <trans-unit id="0b1c4e2bbef526c82867f5bdebb7889317040a32" translate="yes" xml:space="preserve">
          <source>When unpacking a corrupt packfile, the command dies at the first corruption. This flag tells it to keep going and make the best effort to recover as many objects as possible.</source>
          <target state="translated">При распаковке поврежденного файла пакета команда умирает при первом повреждении.Этот флаг говорит ей,что нужно продолжать и приложить максимум усилий,чтобы восстановить как можно больше объектов.</target>
        </trans-unit>
        <trans-unit id="5a3166bdcd39ee71b5c10c4011020b35e1491541" translate="yes" xml:space="preserve">
          <source>When unspecified, all references, after filtering done with --heads and --tags, are shown. When &amp;lt;refs&amp;gt;&amp;hellip;​ are specified, only references matching the given patterns are displayed.</source>
          <target state="translated">Если не указано иное, отображаются все ссылки после фильтрации, выполненной с помощью --heads и --tags. Когда указаны &amp;lt;refs&amp;gt;&amp;hellip;, отображаются только ссылки, соответствующие заданным шаблонам.</target>
        </trans-unit>
        <trans-unit id="fa62c673234c7d272766be9489825a6b1fba8b8c" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files.</source>
          <target state="translated">При использовании в сочетании с неотслеживаемым кэшем,он может еще больше повысить производительность,избегая затрат на сканирование всей рабочей директории в поисках новых файлов.</target>
        </trans-unit>
        <trans-unit id="4699c35836688678c5cc37f1963f740eb7581527" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;-B&lt;/code&gt;, omit also the preimage in the deletion part of a delete/create pair.</source>
          <target state="translated">При использовании вместе с &lt;code&gt;-B&lt;/code&gt; опускайте также прообраз в части удаления пары удаление / создание.</target>
        </trans-unit>
        <trans-unit id="81ec7d099c83d3c361cd6013c655cfcd1bc1c8c9" translate="yes" xml:space="preserve">
          <source>When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.</source>
          <target state="translated">При использовании с опциями -C/-c/--amend,или при фиксации после конфликтующей вишни,объявите,что авторство результирующего коммита теперь принадлежит коммиттеру.Это также продлевает временную метку автора.</target>
        </trans-unit>
        <trans-unit id="b6df5147373d036993fb497c4d7575874db40c5c" translate="yes" xml:space="preserve">
          <source>When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number &lt;code&gt;n&lt;/code&gt; controls this aspect of the -B option (defaults to 50%). &lt;code&gt;-B20%&lt;/code&gt; specifies that a change with addition and deletion compared to 20% or more of the file&amp;rsquo;s size are eligible for being picked up as a possible source of a rename to another file.</source>
          <target state="translated">При использовании с -M полностью перезаписанный файл также рассматривается как источник переименования (обычно -M рассматривает только исчезнувший файл как источник переименования), а число &lt;code&gt;n&lt;/code&gt; управляет этим аспектом параметра -B (по умолчанию 50%). &lt;code&gt;-B20%&lt;/code&gt; указывает, что изменение с добавлением и удалением по сравнению с 20% или более от размера файла может быть выбрано как возможный источник переименования в другой файл.</target>
        </trans-unit>
        <trans-unit id="372d4fbee27ed51979ac65f708d9745903af8bc0" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;--all&lt;/code&gt; print description for all recognized commands. This is the default.</source>
          <target state="translated">При использовании с &lt;code&gt;--all&lt;/code&gt; вывести описание всех распознанных команд. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9b2454d94f74e12e4789baf13180d6dd9add197c" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;-ad&lt;/code&gt;, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed).</source>
          <target state="translated">При использовании с &lt;code&gt;-ad&lt;/code&gt; любые недоступные объекты из существующих пакетов будут добавлены в конец файла пакета, а не удалены. Кроме того, все недоступные незакрепленные предметы будут упакованы (а их незакрепленные копии удалены).</target>
        </trans-unit>
        <trans-unit id="80b1c638669214a11658afe3022f9a5fd154c307" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;value-pattern&lt;/code&gt; argument, treat &lt;code&gt;value-pattern&lt;/code&gt; as an exact string instead of a regular expression. This will restrict the name/value pairs that are matched to only those where the value is exactly equal to the &lt;code&gt;value-pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93c22c6857bec96ca286a73d77a732b313ba7be" translate="yes" xml:space="preserve">
          <source>When using --error-unmatch to expand the user supplied &amp;lt;file&amp;gt; (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named &amp;lt;tree-ish&amp;gt; are still present. Using this option with &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt; options does not make any sense.</source>
          <target state="translated">При использовании --error-unmatch для расширения предоставленных пользователем аргументов &amp;lt;file&amp;gt; (то есть шаблона пути) до путей, представьте, что пути, которые были удалены в индексе, поскольку именованные &amp;lt;tree-ish&amp;gt; все еще присутствуют. Использование этой опции с опциями &lt;code&gt;-s&lt;/code&gt; или &lt;code&gt;-u&lt;/code&gt; не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="c409615f2beb16e70015d6d6f46a1b549d1fd7f1" translate="yes" xml:space="preserve">
          <source>When using --hash (and not --dereference) the output format is: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</source>
          <target state="translated">При использовании --hash (а не --dereference) выходной формат: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4048d2aa35caefecff5d81ef992bce0c4fb7143f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--full-history&lt;/code&gt;, Git walks every edge. This will discover the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and the merge &lt;code&gt;M&lt;/code&gt;, but also will reveal the merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;. With parent rewriting, the resulting graph is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081b8dc63c3bf5b426e1b11153b55d3d12af50bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--get&lt;/code&gt;, and the requested variable is not found, behave as if &amp;lt;value&amp;gt; were the value assigned to the that variable.</source>
          <target state="translated">При использовании &lt;code&gt;--get&lt;/code&gt; , а запрошенная переменная не найдена, ведите себя так, как если бы &amp;lt;value&amp;gt; было значением, присвоенным этой переменной.</target>
        </trans-unit>
        <trans-unit id="a0e35ae72d386768f718c98e1facc75ecb16026b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;git diff&lt;/code&gt; to compare with work tree files, do not consider stat-only change as changed. Instead, silently run &lt;code&gt;git update-index --refresh&lt;/code&gt; to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain, and not lower level &lt;code&gt;diff&lt;/code&gt; commands such as &lt;code&gt;git diff-files&lt;/code&gt;.</source>
          <target state="translated">При использовании &lt;code&gt;git diff&lt;/code&gt; для сравнения с файлами рабочего дерева не считайте изменение только статистики измененным. Вместо этого, незаметно запустите &lt;code&gt;git update-index --refresh&lt;/code&gt; , чтобы обновить кэшированную статистическую информацию для путей, содержимое которых в дереве работ соответствует содержимому в индексе. По умолчанию для этого параметра установлено значение true. Обратите внимание, что это влияет только на &lt;code&gt;git diff&lt;/code&gt; Porcelain, но не на команды &lt;code&gt;diff&lt;/code&gt; нижнего уровня, такие как &lt;code&gt;git diff-files&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b88f8d37a4b8b52b11aa1a9190d81927513fc837" translate="yes" xml:space="preserve">
          <source>When using either the ssh:// or file:// transport, the GIT_PROTOCOL environment variable must be set explicitly to include &quot;version=2&quot;.</source>
          <target state="translated">При использовании транспорта ssh://или file://переменная окружения GIT_PROTOCOL должна быть явно установлена на &quot;version=2&quot;.</target>
        </trans-unit>
        <trans-unit id="0ba437f399f8167203a8f1358d574f4341e76291" translate="yes" xml:space="preserve">
          <source>When using multiple --branches or --tags, &lt;code&gt;git svn&lt;/code&gt; does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name). In these cases, use &lt;code&gt;init&lt;/code&gt; to set up your Git repository then, before your first &lt;code&gt;fetch&lt;/code&gt;, edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces. For example:</source>
          <target state="translated">При использовании нескольких --branches или --tags, &lt;code&gt;git svn&lt;/code&gt; не обрабатывает автоматически конфликты имен (например, если две ветки с разных путей имеют одно и то же имя или если ветка и тег имеют одинаковое имя). В этих случаях использование &lt;code&gt;init&lt;/code&gt; , чтобы настроить репозиторий затем, перед вашим первым &lt;code&gt;fetch&lt;/code&gt; , отредактировать файл / файл $ GIT_DIR конфигурации так , что ветви и теги, связанные с различными пространствами имен. Например:</target>
        </trans-unit>
        <trans-unit id="66eede648bb8458831446e45d1bace5161e3e57f" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--simplify-merges&lt;/code&gt; option, the commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; disappear from the results. This is because the rewritten second parents of &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit &lt;code&gt;N&lt;/code&gt;, resulting in a history view as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb2aee242441b06254e02f3a0a2e1341fe75fee4" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--verify&lt;/code&gt; flag, the command requires an exact path:</source>
          <target state="translated">При использовании флага &lt;code&gt;--verify&lt;/code&gt; команда требует точного пути:</target>
        </trans-unit>
        <trans-unit id="33199341df233e06da35e7d1be5de579f81a31d0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;refspec&lt;/code&gt; capability, git normally updates the private ref on successful push. This update is disabled when the remote-helper declares the capability &lt;code&gt;no-private-update&lt;/code&gt;.</source>
          <target state="translated">При использовании возможности &lt;code&gt;refspec&lt;/code&gt; git обычно обновляет частную ссылку при успешном нажатии. Это обновление отключается, когда удаленный помощник объявляет возможность &lt;code&gt;no-private-update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea3a627ae5a8f7b20a77e60b7a062e9084db269" translate="yes" xml:space="preserve">
          <source>When using the default mode, &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9344e268a1ce18a0fd23fc1ab7349b109ba09f95" translate="yes" xml:space="preserve">
          <source>When using the deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like</source>
          <target state="translated">При использовании устаревшего синтаксиса &lt;code&gt;[section.subsection]&lt;/code&gt; изменение значения приведет к добавлению многострочного ключа вместо изменения, если в подразделе содержится хотя бы один символ верхнего регистра. Например, когда конфигурация выглядит как</target>
        </trans-unit>
        <trans-unit id="d587eeb587978498a5260d6dbb9ec4ed92ae5139" translate="yes" xml:space="preserve">
          <source>When using the git:// transport, you can request to use protocol v2 by sending &quot;version=2&quot; as an extra parameter:</source>
          <target state="translated">При использовании транспорта git://вы можете запросить использование протокола v2,отправив &quot;version=2&quot; в качестве дополнительного параметра:</target>
        </trans-unit>
        <trans-unit id="32ff889e17de28054dd0cab540306ba1d148a08f" translate="yes" xml:space="preserve">
          <source>When using the http:// or https:// transport a client makes a &quot;smart&quot; info/refs request as described in &lt;code&gt;http-protocol.txt&lt;/code&gt; and requests that v2 be used by supplying &quot;version=2&quot; in the &lt;code&gt;Git-Protocol&lt;/code&gt; header.</source>
          <target state="translated">При использовании транспорта http: // или https: // клиент делает &amp;laquo;умный&amp;raquo; запрос info / refs, как описано в &lt;code&gt;http-protocol.txt&lt;/code&gt; , и запрашивает, чтобы v2 использовалась, указав &amp;laquo;version = 2&amp;raquo; в &lt;code&gt;Git-Protocol&lt;/code&gt; . заголовок.</target>
        </trans-unit>
        <trans-unit id="1119c741c1d5ff1dc358a8c521dcf54497e7a91a" translate="yes" xml:space="preserve">
          <source>When we discuss merges we&amp;rsquo;ll also see the special name MERGE_HEAD, which refers to the other branch that we&amp;rsquo;re merging in to the current branch.</source>
          <target state="translated">Когда мы обсуждаем слияние, мы также увидим специальное имя MERGE_HEAD, которое относится к другой ветке, которую мы объединяем с текущей веткой.</target>
        </trans-unit>
        <trans-unit id="26b492dec7c9b7098cc4171f2408a6f7f7e92986" translate="yes" xml:space="preserve">
          <source>When we need to be precise, we will use the word &quot;branch&quot; to mean a line of development, and &quot;branch head&quot; (or just &quot;head&quot;) to mean a reference to the most recent commit on a branch. In the example above, the branch head named &quot;A&quot; is a pointer to one particular commit, but we refer to the line of three commits leading up to that point as all being part of &quot;branch A&quot;.</source>
          <target state="translated">Когда нам нужно быть точными,мы будем использовать слово &quot;branch&quot; для обозначения строки разработки,а &quot;branch head&quot; (или просто &quot;head&quot;)для обозначения ссылки на последний коммит в ветке.В приведённом выше примере глава ветки с именем &quot;A&quot; является указателем на один конкретный коммит,но мы ссылаемся на строку из трёх коммитов,ведущих к этой точке,так как все они являются частью &quot;ветки A&quot;.</target>
        </trans-unit>
        <trans-unit id="af865a0e18421a331501b917b6b084d9f08c05af" translate="yes" xml:space="preserve">
          <source>When we want to find out what commits in &lt;code&gt;M&lt;/code&gt; are contaminated with the bug introduced by &lt;code&gt;D&lt;/code&gt; and need fixing, however, we might want to view only the subset of &lt;code&gt;D..M&lt;/code&gt; that are actually descendants of &lt;code&gt;D&lt;/code&gt;, i.e. excluding &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt;. This is exactly what the &lt;code&gt;--ancestry-path&lt;/code&gt; option does. Applied to the &lt;code&gt;D..M&lt;/code&gt; range, it results in:</source>
          <target state="translated">Когда мы хотим узнать, что совершает в &lt;code&gt;M&lt;/code&gt; загрязнены с ошибкой , введенной &lt;code&gt;D&lt;/code&gt; и фиксации необходимости, однако, мы могли бы просмотреть только подмножество &lt;code&gt;D..M&lt;/code&gt; , которые являются фактически потомками &lt;code&gt;D&lt;/code&gt; , т.е. за исключением &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;K&lt;/code&gt; . Это именно то, что &lt;code&gt;--ancestry-path&lt;/code&gt; параметр --ancestry-path . Применительно к диапазону &lt;code&gt;D..M&lt;/code&gt; это приводит к:</target>
        </trans-unit>
        <trans-unit id="bd2b751f52f03b9f39eaea429dccc385cd6f8cb7" translate="yes" xml:space="preserve">
          <source>When writing a script that is expected to handle random user-input, it is a good practice to make it explicit which arguments are which by placing disambiguating &lt;code&gt;--&lt;/code&gt; at appropriate places.</source>
          <target state="translated">При написании сценария, который, как ожидается, будет обрабатывать случайный ввод пользователя, рекомендуется указать, какие аргументы являются какими, путем устранения неоднозначности &lt;code&gt;--&lt;/code&gt; в соответствующих местах.</target>
        </trans-unit>
        <trans-unit id="ec9cac719dc2571ad31301b21a571a63039a88c5" translate="yes" xml:space="preserve">
          <source>When writing remote-helpers for decentralized version control systems, it is advised to keep a local copy of the repository to interact with, and to let the private namespace refs point to this local repository, while the refs/remotes namespace is used to track the remote repository.</source>
          <target state="translated">При написании удаленных помощников для децентрализованных систем управления версиями рекомендуется сохранять локальную копию репозитория для взаимодействия,а также позволять ссылкам на личное пространство имён указывать на этот локальный репозиторий,в то время как для отслеживания удалённого репозитория используется пространство имён refs/remotes.</target>
        </trans-unit>
        <trans-unit id="20c75e316d5f2bc9ee11a82eb08a64c8e94c8af1" translate="yes" xml:space="preserve">
          <source>When writing, the new value is written to the repository local configuration file by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt;, &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to write to that location (you can say &lt;code&gt;--local&lt;/code&gt; but that is the default).</source>
          <target state="translated">При записи новое значение по умолчанию записывается в локальный файл конфигурации репозитория, а параметры &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; , &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; могут использоваться для указания команде записи в это место ( вы можете &lt;code&gt;--local&lt;/code&gt; но это значение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="cd8a515ddc50bbc57c4721fd114c9828b7d7e56b" translate="yes" xml:space="preserve">
          <source>When you are happy with the state of this change, you can merge it into the &quot;test&quot; branch in preparation to make it public:</source>
          <target state="translated">Когда вы будете довольны состоянием этого изменения,вы можете объединить его в &quot;тестовую&quot; ветвь в рамках подготовки к публикации:</target>
        </trans-unit>
        <trans-unit id="778f60f4a64466f8d291144e663a70b4838a03f8" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple &lt;code&gt;git pull&lt;/code&gt; will let you move forward.</source>
          <target state="translated">Когда вы что-то делаете, вы узнаете, что есть изменения, которые могут иметь отношение к тому, что вы делаете. Когда ваши локальные изменения не конфликтуют с изменениями в восходящем потоке, простой &lt;code&gt;git pull&lt;/code&gt; позволит вам двигаться вперед.</target>
        </trans-unit>
        <trans-unit id="f6b623b307a4c06027202dc5b8021ae4a369fe95" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:</source>
          <target state="translated">Когда вы что-то делаете,приходит ваш босс и требует,чтобы вы что-то исправили немедленно.Традиционно,вы делаете фиксацию во временном ответвлении,чтобы сохранить ваши изменения,и возвращаетесь в своё первоначальное ответвление,чтобы сделать экстренное исправление,подобное этому:</target>
        </trans-unit>
        <trans-unit id="5dab203d26aab56f5ab1012e5091a813403ff2db" translate="yes" xml:space="preserve">
          <source>When you are interested in finding the origin for lines 40-60 for file &lt;code&gt;foo&lt;/code&gt;, you can use the &lt;code&gt;-L&lt;/code&gt; option like so (they mean the same thing &amp;mdash; both ask for 21 lines starting at line 40):</source>
          <target state="translated">Если вы хотите найти начало координат строк 40-60 для файла &lt;code&gt;foo&lt;/code&gt; , вы можете использовать опцию &lt;code&gt;-L&lt;/code&gt; следующим образом (они означают одно и то же - обе запрашивают 21 строку, начинающуюся со строки 40):</target>
        </trans-unit>
        <trans-unit id="709f7df580972f427522b82ef732f913e20c2078" translate="yes" xml:space="preserve">
          <source>When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to &lt;code&gt;git rev-list&lt;/code&gt;:</source>
          <target state="translated">Если вас не интересуют изменения старше версии v2.6.18 или изменения старше 3 недель, вы можете использовать спецификаторы диапазона ревизий, аналогичные &lt;code&gt;git rev-list&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da9f31c43174e26846193d472d4442e982c36d7b" translate="yes" xml:space="preserve">
          <source>When you are working in a small closely knit group, it is not unusual to interact with the same repository over and over again. By defining &lt;code&gt;remote&lt;/code&gt; repository shorthand, you can make it easier:</source>
          <target state="translated">Когда вы работаете в небольшой сплоченной группе, нет ничего необычного в том, чтобы взаимодействовать с одним и тем же хранилищем снова и снова. Определив сокращенное обозначение &lt;code&gt;remote&lt;/code&gt; репозитория, вы можете упростить задачу:</target>
        </trans-unit>
        <trans-unit id="9ac50cc4cb199a994adc57ff3704f94a4fe6fd25" translate="yes" xml:space="preserve">
          <source>When you ask &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; to show the conflicts, it runs a three-way diff between the conflicted merge results in the work tree with stages 2 and 3 to show only hunks whose contents come from both sides, mixed (in other words, when a hunk&amp;rsquo;s merge results come only from stage 2, that part is not conflicting and is not shown. Same for stage 3).</source>
          <target state="translated">Когда вы просите &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; показать конфликты, он запускает трехстороннее различие между конфликтующими результатами слияния в дереве работы с этапами 2 и 3, чтобы показать только блоки, содержимое которых поступает с обеих сторон, смешанное (в других Другими словами, когда результаты слияния блока поступают только на этапе 2, эта часть не конфликтует и не отображается. То же самое для этапа 3).</target>
        </trans-unit>
        <trans-unit id="23850e192db360b828b88cc125a57c30022897e8" translate="yes" xml:space="preserve">
          <source>When you perform a squash merge, a merge commit isn&amp;rsquo;t created; instead, the changes from one side are applied as a regular commit to the other side. This means that the merge base for these branches won&amp;rsquo;t have changed, and so when Git goes to perform its next merge, it considers all of the changes that it considered the last time plus the new changes. That means any conflicts may need to be re-resolved. Similarly, anything using the &lt;code&gt;...&lt;/code&gt; notation in &lt;code&gt;git
diff&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, or a GUI will result in showing all of the changes since the original merge base.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0add0b9e7571c844c4ae8fb98b59f1c64d874a" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; and only have one remote, it may implicitly fall back on checking out and tracking e.g. &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt;. This stops working as soon as you have more than one remote with a &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">Когда вы запускаете &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; или &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; и имеете только один пульт, он может неявно отказаться от проверки и отслеживания, например &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt; . Это перестает работать, как только у вас будет более одного пульта со ссылкой на &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; . Этот параметр позволяет установить имя предпочтительного пульта дистанционного управления, которое всегда должно выигрывать, когда дело доходит до устранения неоднозначности. Типичный вариант использования - установить для него значение &lt;code&gt;origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f93e702904ad75a7ffcc41597ebc2474895e0b0" translate="yes" xml:space="preserve">
          <source>When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is &quot;derived&quot; from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2.</source>
          <target state="translated">Когда вы начинаете 3-х стороннее слияние с уже заполненным индексным файлом,предполагается,что он представляет состояние файлов в вашем рабочем дереве,и вы даже можете иметь файлы с изменениями,которые не были записаны в индексном файле.Далее предполагается,что это состояние &quot;выведено&quot; из дерева стадии 2.Трехстороннее слияние отказывается запускаться,если находит в исходном индексном файле запись,не соответствующую 2-му этапу.</target>
        </trans-unit>
        <trans-unit id="6831d00e1f830a484b6c5799e343f596bbc55899" translate="yes" xml:space="preserve">
          <source>When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit.</source>
          <target state="translated">Когда вы хотите просто интегрироваться с работой,ведущей к коммиту,который случайно помечен,например,синхронизируясь с точкой релиза вверх по тегу,вы можете не захотеть делать ненужный коммит слияния.</target>
        </trans-unit>
        <trans-unit id="2f28e5d62e5a87453e903e81e941382b8ac566c1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, just run</source>
          <target state="translated">Когда вы будете готовы, просто бегите</target>
        </trans-unit>
        <trans-unit id="4aa6b6296b8d97b342099d335ec15bc55634ad41" translate="yes" xml:space="preserve">
          <source>When your topic branch is long-lived, however, your topic branch would end up having many such &quot;Merge from master&quot; commits on it, which would unnecessarily clutter the development history. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of &quot;useless merges&quot;.</source>
          <target state="translated">Однако,когда ваша тематическая ветка долгоживущая,в конце концов,в ней будет много таких коммитов &quot;Слияние с мастером&quot;,которые без необходимости будут загромождать историю разработки.Читатели списка рассылки ядра Linux,возможно,помнят,что Линус жаловался на слишком частые тестовые слияния,когда сопровождающий подсистемы просил вытащить из ответвления,полного &quot;бесполезных слияний&quot;.</target>
        </trans-unit>
        <trans-unit id="bd4128428344ae6c28977b2bc5cf00953da1175f" translate="yes" xml:space="preserve">
          <source>When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:</source>
          <target state="translated">Когда ваша тематическая ветка изменяет область перекрытия,которую ваша основная ветка (или верхняя)коснулась,так как ваша тематическая ветка вышла из неё,вы можете протестировать её с последней основной веткой,ещё до того,как ваша тематическая ветка будет готова к проталкиванию вверх по течению:</target>
        </trans-unit>
        <trans-unit id="4f4eaf255ffc69df0530167a4810c74e9370cd43" translate="yes" xml:space="preserve">
          <source>Whenever possible, section headings should clearly describe the task they explain how to do, in language that requires no more knowledge than necessary: for example, &quot;importing patches into a project&quot; rather than &quot;the &lt;code&gt;git am&lt;/code&gt; command&quot;</source>
          <target state="translated">По возможности, заголовки разделов должны четко описывать задачу, которую они объясняют, как выполнять, на языке, который не требует дополнительных знаний, чем необходимо: например, &amp;laquo;импорт патчей в проект&amp;raquo;, а не &amp;laquo;команда &lt;code&gt;git am&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="11683716a14fb2e59c3ad4d48a607606706a0329" translate="yes" xml:space="preserve">
          <source>Where &quot;oldsha1&quot; is the 40 character hexadecimal value previously stored in &amp;lt;ref&amp;gt;, &quot;newsha1&quot; is the 40 character hexadecimal value of &amp;lt;newvalue&amp;gt; and &quot;committer&quot; is the committer&amp;rsquo;s name, email address and date in the standard Git committer ident format.</source>
          <target state="translated">Где oldsha1 - это 40-символьное шестнадцатеричное значение, ранее сохраненное в &amp;lt;ref&amp;gt;, &amp;laquo;newsha1&amp;raquo; - 40-символьное шестнадцатеричное значение &amp;lt;newvalue&amp;gt;, а &amp;laquo;committer&amp;raquo; - имя коммиттера, адрес электронной почты и дата в стандартном формате идентификатора коммиттера Git. ,</target>
        </trans-unit>
        <trans-unit id="9a6682bd90b10ed7b65387d46ac6e3098ba208ce" translate="yes" xml:space="preserve">
          <source>Where all fields are as described above and &quot;message&quot; is the value supplied to the -m option.</source>
          <target state="translated">Где все поля,как описано выше,и &quot;сообщение&quot;-это значение,передаваемое в опцию -m.</target>
        </trans-unit>
        <trans-unit id="1047cdb3a9504c1e49ba180691c6de133fb29736" translate="yes" xml:space="preserve">
          <source>Where to create the Git repository. If not provided, the last component in the p4 depot path is used to create a new directory.</source>
          <target state="translated">Где создать Git-репозиторий.Если это не предусмотрено,для создания нового каталога используется последний компонент пути p4 depot.</target>
        </trans-unit>
        <trans-unit id="de8afe671960d7a395defa2e40a80901d96e2485" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; would produce:</source>
          <target state="translated">В то время как &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; выдаст:</target>
        </trans-unit>
        <trans-unit id="92669e9b8b127c2ba15691914d72dae97b880d0d" translate="yes" xml:space="preserve">
          <source>Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. If merge.directoryRenames is set to &quot;false&quot;, directory rename detection is disabled, meaning that such new files will be left behind in the old directory. If set to &quot;true&quot;, directory rename detection is enabled, meaning that such new files will be moved into the new directory. If set to &quot;conflict&quot;, a conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to &quot;conflict&quot;.</source>
          <target state="translated">Обнаруживает ли Git переименования каталогов,влияя на то,что происходит во время слияния с новыми файлами,добавленными в каталог на одной стороне истории,когда этот каталог был переименован на другой стороне истории.Если параметр merge.directoryRenames установлен в значение &quot;false&quot;,то определение переименования каталога отключается,то есть такие новые файлы будут оставлены в старом каталоге.Если установлено значение &quot;true&quot;,то детектирование переименования директории включено,то есть такие новые файлы будут перемещены в новую директорию.Если установлено значение &quot;конфликт&quot;,то для таких путей будет сообщено о конфликте.Если значение параметра merge.renames равно false,то merge.directoryRenames будет проигнорирован и будет считаться ложным.По умолчанию установлено значение &quot;конфликт&quot;.</target>
        </trans-unit>
        <trans-unit id="6720b94e3bf2c12c61b3c14de0415d18239394a0" translate="yes" xml:space="preserve">
          <source>Whether Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. Defaults to the value of diff.renames.</source>
          <target state="translated">Обнаружит ли Гит переименование.Если установлено значение &quot;false&quot;,определение переименования отключено.Если установлено значение &quot;true&quot;,основное определение переименования включено.По умолчанию равнозначно значению diff.renames.</target>
        </trans-unit>
        <trans-unit id="d1f68ec7a1f81e21d54ab2e76eaccedf11117ff8" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; . If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to the value of diff.renames.</source>
          <target state="translated">Обнаруживает ли и как Git переименование в &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; и &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; . Если установлено значение &amp;laquo;false&amp;raquo;, определение переименования отключено. Если установлено значение &amp;laquo;true&amp;raquo;, включено базовое определение переименования. Если установлено значение &amp;laquo;копии&amp;raquo; или &amp;laquo;копировать&amp;raquo;, Git также обнаружит копии. По умолчанию используется значение diff.renames.</target>
        </trans-unit>
        <trans-unit id="cd914284b278d491020fec9d972b776a56df2f14" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain like &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and not lower level commands such as &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;.</source>
          <target state="translated">Обнаруживает ли Git переименование и каким образом. Если установлено значение &amp;laquo;false&amp;raquo;, определение переименования отключено. Если установлено значение &amp;laquo;true&amp;raquo;, включено базовое определение переименования. Если установлено значение &amp;laquo;копии&amp;raquo; или &amp;laquo;копировать&amp;raquo;, Git также обнаружит копии. По умолчанию true. Обратите внимание, что это влияет только на &lt;code&gt;git diff&lt;/code&gt; Porcelain, например &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; и &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , но не на команды более низкого уровня, такие как &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2329b3f81f31d1e7aac7efc37e396ae5ccc9b5fe" translate="yes" xml:space="preserve">
          <source>Whether git should follow HTTP redirects. If set to &lt;code&gt;true&lt;/code&gt;, git will transparently follow any redirect issued by a server it encounters. If set to &lt;code&gt;false&lt;/code&gt;, git will treat all redirects as errors. If set to &lt;code&gt;initial&lt;/code&gt;, git will follow redirects only for the initial request to a remote, but not for subsequent follow-up HTTP requests. Since git uses the redirected URL as the base for the follow-up requests, this is generally sufficient. The default is &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">Должен ли git следовать перенаправлениям HTTP. Если установлено значение &lt;code&gt;true&lt;/code&gt; , git будет прозрачно следовать любому перенаправлению, выданному сервером, с которым он сталкивается. Если установлено значение &lt;code&gt;false&lt;/code&gt; , git будет рассматривать все перенаправления как ошибки. Если установлено значение &lt;code&gt;initial&lt;/code&gt; , git будет следовать перенаправлениям только для начального запроса к удаленному устройству, но не для последующих последующих HTTP-запросов. Поскольку git использует перенаправленный URL-адрес в качестве основы для последующих запросов, этого обычно достаточно. Значение по умолчанию - &lt;code&gt;initial&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd0092aedf4252969afafd8803ba8faf98999493" translate="yes" xml:space="preserve">
          <source>Whether that update is allowed without &lt;code&gt;--force&lt;/code&gt; depends on the ref namespace it&amp;rsquo;s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; for what those are. Exceptions to those rules particular to &lt;code&gt;git fetch&lt;/code&gt; are noted below.</source>
          <target state="translated">Разрешено ли это обновление без &lt;code&gt;--force&lt;/code&gt; , зависит от пространства имен ref, в которое оно извлекается, типа извлекаемого объекта и от того, считается ли обновление быстрой перемоткой вперед. Как правило, для выборки применяются те же правила, что и при нажатии, см. &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; в &lt;a href=&quot;git-push&quot;&gt;git-push [1],&lt;/a&gt; чтобы узнать, что это такое. Исключения из этих правил, &lt;code&gt;git fetch&lt;/code&gt; к git fetch, указаны ниже.</target>
        </trans-unit>
        <trans-unit id="9c31395d6226db0f96527cf13d7284a32596aaef" translate="yes" xml:space="preserve">
          <source>Whether the CVS server interface is enabled for this repository. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Включен ли интерфейс сервера CVS для этого репозитория. См. &lt;a href=&quot;git-cvsserver&quot;&gt;Git-cvsserver [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e99c94b5e67663cef6460c2b09cda34348e975de" translate="yes" xml:space="preserve">
          <source>Whether to enable the grouping of projects by category on the project list page. The category of a project is determined by the &lt;code&gt;$GIT_DIR/category&lt;/code&gt; file or the &lt;code&gt;gitweb.category&lt;/code&gt; variable in each repository&amp;rsquo;s configuration. Disabled by default (set to 0).</source>
          <target state="translated">Включать ли группировку проектов по категориям на странице списка проектов. Категория проекта определяется &lt;code&gt;$GIT_DIR/category&lt;/code&gt; или переменной &lt;code&gt;gitweb.category&lt;/code&gt; в конфигурации каждого репозитория. По умолчанию отключено (установлено значение 0).</target>
        </trans-unit>
        <trans-unit id="be60442dc9a2bb750c3ffb3e91f602fa8cf454b7" translate="yes" xml:space="preserve">
          <source>Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default.</source>
          <target state="translated">Следует ли распечатать дифстат между ORIG_HEAD и результатом слияния в конце слияния.По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="e6d010b4fa5fb27d92c64dc2f59319c4e77b544c" translate="yes" xml:space="preserve">
          <source>Whether to show a diffstat of what changed upstream since the last rebase. False by default.</source>
          <target state="translated">Показывать ли дифстат того,что изменилось вверх по течению с момента последнего ребрендинга.Ложно по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2153c59644d7df4b2ed210d8ef453074b1a6c2ac" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Следует ли пропускать чтение настроек из общесистемного файла $ (prefix) / etc / gitconfig. Подробнее см. &lt;a href=&quot;git&quot;&gt;Git [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c8173d7da296bd9c5f5aef35e3d739c8852bc79" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; file. This environment variable can be used along with &lt;code&gt;$HOME&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; to create a predictable environment for a picky script, or you can set it temporarily to avoid using a buggy &lt;code&gt;/etc/gitconfig&lt;/code&gt; file while waiting for someone with sufficient permissions to fix it.</source>
          <target state="translated">&lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; ли пропускать чтение настроек из общесистемного файла $ (prefix) / etc / gitconfig . Эту переменную среды можно использовать вместе с &lt;code&gt;$HOME&lt;/code&gt; и &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; чтобы создать предсказуемую среду для придирчивого сценария, или вы можете установить ее временно, чтобы избежать использования &lt;code&gt;/etc/gitconfig&lt;/code&gt; файла / etc / gitconfig , ожидая, пока кто-то с достаточными разрешениями исправит его.</target>
        </trans-unit>
        <trans-unit id="488ddc0ec5d5c663a8e8059a323ed70db5316b78" translate="yes" xml:space="preserve">
          <source>Whether to use ANSI escape sequences to add color to patches. If this is set to &lt;code&gt;always&lt;/code&gt;, &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; will use color for all patches. If it is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, those commands will only use color when output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">Следует ли использовать escape-последовательности ANSI для добавления цвета к заплатам. Если установлено значение &lt;code&gt;always&lt;/code&gt; , &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; и &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; будут использовать цвет для всех патчей. Если установлено значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;auto&lt;/code&gt; , эти команды будут использовать цвет только при выводе на терминал. Если не задано, используется значение &lt;code&gt;color.ui&lt;/code&gt; ( по умолчанию &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="21386b2036d855c8d8dd6eb4c84085329fcf2561" translate="yes" xml:space="preserve">
          <source>Whether to use empty blobs as rename source.</source>
          <target state="translated">Использовать ли пустые капли в качестве источника переименования.</target>
        </trans-unit>
        <trans-unit id="63ea1a80cc99dbbdec2d362a1b57aa7468c9ed6d" translate="yes" xml:space="preserve">
          <source>Whether to verify the SSL certificate when fetching or pushing over HTTPS. Defaults to true. Can be overridden by the &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; environment variable.</source>
          <target state="translated">Следует ли проверять сертификат SSL при получении или передаче по HTTPS. По умолчанию true. Может быть переопределено переменной окружения &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec9fdb5354be84561f27023760593b27a86cd126" translate="yes" xml:space="preserve">
          <source>Which file to place a pattern in depends on how the pattern is meant to be used.</source>
          <target state="translated">В какой файл поместить шаблон,зависит от того,как будет использоваться шаблон.</target>
        </trans-unit>
        <trans-unit id="9342c5a7ca74e113fca6826c098da1e9dea46c59" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each strategy.</source>
          <target state="translated">Какую стратегию слияния выбрать по умолчанию при разрешении конфликтов заметок. Должно быть один из &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;cat_sort_uniq&lt;/code&gt; . По умолчанию &lt;code&gt;manual&lt;/code&gt; . См. Раздел &amp;laquo;ЗАМЕЧАНИЯ ПО СТРАТЕГИЯМ СЛИЯНИЯ&amp;raquo; выше для получения дополнительной информации по каждой стратегии.</target>
        </trans-unit>
        <trans-unit id="7dd75dabb694bc7182031b6cdb5c605283f3ff3a" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section of &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on each strategy.</source>
          <target state="translated">Какую стратегию слияния выбрать по умолчанию при разрешении конфликтов заметок. Должно быть один из &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;cat_sort_uniq&lt;/code&gt; . По умолчанию &lt;code&gt;manual&lt;/code&gt; . См. Раздел &amp;laquo;NOTES MERGE STRATEGIES&amp;raquo; в &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; для получения дополнительной информации по каждой стратегии.</target>
        </trans-unit>
        <trans-unit id="9bd73c0d97037644e549ed3fed8d2491f5cfc8e0" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each available strategy.</source>
          <target state="translated">Какую стратегию слияния выбрать при слиянии заметок с refs / notes / &amp;lt;name&amp;gt;. Это отменяет более общий &quot;notes.mergeStrategy&quot;. См. Раздел &amp;laquo;ПРИМЕЧАНИЯ К СТРАТЕГИЯМ СЛИЯНИЯ&amp;raquo; выше для получения дополнительной информации о каждой доступной стратегии.</target>
        </trans-unit>
        <trans-unit id="f202b61699020bcfa082fe897d7a8560aea486a1" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on the available strategies.</source>
          <target state="translated">Какую стратегию слияния выбрать при слиянии заметок с refs / notes / &amp;lt;name&amp;gt;. Это отменяет более общий &quot;notes.mergeStrategy&quot;. См. Раздел &amp;laquo;NOTES MERGE STRATEGIES&amp;raquo; в &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; для получения дополнительной информации о доступных стратегиях.</target>
        </trans-unit>
        <trans-unit id="556a322f94dd1e45943ded0ebea9906e93ca0c80" translate="yes" xml:space="preserve">
          <source>Which ref (or refs, if a glob or specified more than once), in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;git log&lt;/code&gt; family of commands. This setting can be overridden on the command line or by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">Какую ссылку (или ссылки, если глобус или указано более одного раза), помимо значения по умолчанию, установленного в &lt;code&gt;core.notesRef&lt;/code&gt; или &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; , для чтения заметок при отображении сообщений фиксации с помощью семейства команд &lt;code&gt;git log&lt;/code&gt; . Этот параметр можно переопределить в командной строке или переменной среды &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; . См. &lt;a href=&quot;git-log&quot;&gt;Git-log [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08e8ee8d98ea130471cc368fbf1a571f3d29a34d" translate="yes" xml:space="preserve">
          <source>Which ref to manipulate notes from, instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. This overrides the &lt;code&gt;core.notesRef&lt;/code&gt; setting.</source>
          <target state="translated">С какой ссылки можно работать с заметками, а не с ссылок &lt;code&gt;refs/notes/commits&lt;/code&gt; . Это отменяет настройку &lt;code&gt;core.notesRef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="180171a89f79828ca3aedfa4194b8ff07f802f3f" translate="yes" xml:space="preserve">
          <source>Which refs, in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;log&lt;/code&gt; family of commands. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">Какие рефов, в дополнение к набору по умолчанию с помощью &lt;code&gt;core.notesRef&lt;/code&gt; или &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; , читать ноты с при показе фиксации сообщений с помощью &lt;code&gt;log&lt;/code&gt; семейства команд. См. &lt;a href=&quot;git-notes&quot;&gt;Git-notes [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4dbbdac6096ee85d080e618f1dfec3eb7804653" translate="yes" xml:space="preserve">
          <source>Which will add the following to a file named &lt;code&gt;.gitconfig&lt;/code&gt; in your home directory:</source>
          <target state="translated">Это добавит следующее в файл с именем &lt;code&gt;.gitconfig&lt;/code&gt; в вашем домашнем каталоге:</target>
        </trans-unit>
        <trans-unit id="0b383fc769f1bfb4acb136b5be3ea84e9742db33" translate="yes" xml:space="preserve">
          <source>Which would result in:</source>
          <target state="translated">В результате чего:</target>
        </trans-unit>
        <trans-unit id="5efe59371f7c539c77a16fb753d65287a4a1a881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are in, you can also specify what files are &lt;code&gt;not&lt;/code&gt; in, using negate patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">Хотя &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; обычно используется для указания, в каких файлах находятся, вы также можете указать, каких файлов &lt;code&gt;not&lt;/code&gt; , используя шаблоны отрицания. Например, чтобы удалить &lt;code&gt;unwanted&lt;/code&gt; файл :</target>
        </trans-unit>
        <trans-unit id="133c634c89411bc7bbb73a5aa8f4cda72b5442c2" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are included, you can also specify what files are &lt;code&gt;not&lt;/code&gt; included, using negative patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">Хотя &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; обычно используется для указания, какие файлы включаются, вы также можете указать, какие файлы &lt;code&gt;not&lt;/code&gt; включаются, используя отрицательные шаблоны. Например, чтобы удалить &lt;code&gt;unwanted&lt;/code&gt; файл :</target>
        </trans-unit>
        <trans-unit id="118bfe73a3b1ef14dd8bb7fedadb7cb55f01bcfb" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; was about specifying a single commit parent, these three notations also consider its parents. For example you can say &lt;code&gt;HEAD^2^@&lt;/code&gt;, however you cannot say &lt;code&gt;HEAD^@^2&lt;/code&gt;.</source>
          <target state="translated">Хотя &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; был связан с указанием одного родителя фиксации, эти три нотации также учитывают его родителей. Например, вы можете сказать &lt;code&gt;HEAD^2^@&lt;/code&gt; , но не можете сказать &lt;code&gt;HEAD^@^2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaec58c53324781fb42b4e63ea8a9cb23361a1d5" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT--devo--VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e92ccd1a34f0875d32051d1b819b76c11daddf" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT{litdd}devo{litdd}VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">Хотя &lt;code&gt;git archimport&lt;/code&gt; будет пытаться создать разумные имена веток для импортируемых архивов, также можно указать имена веток Git вручную. Для этого напишите имя ветки Git после каждого параметра &amp;lt;archive / branch&amp;gt;, разделенное двоеточием. Таким образом, вы можете сократить имена веток Arch и преобразовать жаргон Arch в жаргон Git, например, сопоставив ветвь PROJECT {litdd} Dev {litdd} VERSION &quot;master&quot;.</target>
        </trans-unit>
        <trans-unit id="becb5324e2c3fe06edf2ea3e91b298d56c7ab4c0" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;frotz\(nitfol&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;frotz\(nitfol&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3c7753b36510ea58174f6c4603b4398587f401" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">В то время как &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; покажет эту фиксацию, &lt;code&gt;git log -S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; не будет) (поскольку количество вхождений этой строки не изменилось).</target>
        </trans-unit>
        <trans-unit id="9fa3ab181478a04a41a15d625153bef4e8a57c74" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git svn&lt;/code&gt; can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users. Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below).</source>
          <target state="translated">Хотя &lt;code&gt;git svn&lt;/code&gt; может отслеживать историю копий (включая ветки и теги) для репозиториев, использующих стандартный макет, он еще не может отображать историю слияния, которая произошла внутри git, для пользователей SVN. Поэтому рекомендуется, чтобы пользователи сохраняли историю как можно более линейной внутри Git, чтобы облегчить совместимость с SVN (см. Раздел ПРОГНОЗЫ ниже).</target>
        </trans-unit>
        <trans-unit id="a541171ff58e87a1f0dd9a2efc98b39d30771db4" translate="yes" xml:space="preserve">
          <source>While Git can store and handle any file of any type, there are some settings that work better than others. In general, we recommend that text files be stored in UTF-8 without a byte-order mark (BOM) with LF (Unix-style) endings. We also recommend the use of UTF-8 (again, without BOM) in commit messages. These are the settings that work best across platforms and with tools such as &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dffb65164b8303d8f69a39b7acb7d5c91ede142" translate="yes" xml:space="preserve">
          <source>While Git normally leaves file contents alone, it can be configured to normalize line endings to LF in the repository and, optionally, to convert them to CRLF when files are checked out.</source>
          <target state="translated">Хотя Git обычно оставляет содержимое файлов в покое,его можно настроить на нормализацию окончания строк в LF в репозитории и,опционально,на преобразование их в CRLF,когда файлы извлекаются из репозитория.</target>
        </trans-unit>
        <trans-unit id="28e5e3e789710acfbe64ae88514ac76e33edddf4" translate="yes" xml:space="preserve">
          <source>While a tree represents a particular directory state of a working directory, a commit represents that state in &quot;time&quot;, and explains how to get there.</source>
          <target state="translated">В то время как дерево представляет определённое состояние каталога рабочего каталога,коммит представляет это состояние во &quot;времени&quot; и объясняет,как туда добраться.</target>
        </trans-unit>
        <trans-unit id="4340adfab1f511dfd0a9b398534e55b63d70f9b2" translate="yes" xml:space="preserve">
          <source>While an &quot;easy case recovery&quot; sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via &lt;code&gt;git rebase
      --interactive&lt;/code&gt; will be &lt;strong&gt;resurrected&lt;/strong&gt;!</source>
          <target state="translated">Хотя &amp;laquo;легкое восстановление случая&amp;raquo; иногда оказывается успешным даже в тяжелом случае, оно может иметь непредвиденные последствия. Например, коммит, удаленный с помощью &lt;code&gt;git rebase --interactive&lt;/code&gt; будет &lt;strong&gt;воскрешен&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="aeca28e54d758d00b7b9efe81e9021c3ae168604" translate="yes" xml:space="preserve">
          <source>While at it, check the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;final-commit&lt;/code&gt; files as well. If what is in &lt;code&gt;final-commit&lt;/code&gt; is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like &quot;Hi, this is my first patch.\n&quot; in the patch e-mail should come after the three-dash line that signals the end of the commit message.</source>
          <target state="translated">Находясь в нем, проверьте также файлы &lt;code&gt;info&lt;/code&gt; и &lt;code&gt;final-commit&lt;/code&gt; . Если то, что находится в &lt;code&gt;final-commit&lt;/code&gt; , не совсем то, что вы хотели бы видеть в сообщении журнала фиксации, очень вероятно, что получатель в конечном итоге вручную отредактирует сообщение журнала при применении вашего патча. Такие слова, как &amp;laquo;Привет, это мой первый патч. \ N&amp;raquo; в электронном письме с патчем должны идти после трех штриховой линии, которая сигнализирует об окончании сообщения о фиксации.</target>
        </trans-unit>
        <trans-unit id="8ae695a4eabf8fe5dbbd3e5b96e3d4b6e1234599" translate="yes" xml:space="preserve">
          <source>While creating changes is useful, it&amp;rsquo;s even more useful if you can tell later what changed. The most useful command for this is another of the &lt;code&gt;diff&lt;/code&gt; family, namely &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">Хотя создание изменений полезно, это еще более полезно, если вы позже узнаете, что изменилось. Самая полезная команда для этого - другая команда из семейства &lt;code&gt;diff&lt;/code&gt; , а именно &lt;code&gt;git diff-tree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e66bf2723385d320e1625ad06ac948bff457808d" translate="yes" xml:space="preserve">
          <source>While it is possible to override all attributes, well behaving helpers should refrain from doing so for any attribute other than username and password.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a06403fddbfbdfed756ddcbe7e1b6ff85edd7a" translate="yes" xml:space="preserve">
          <source>While one could just alter the configuration settings in the gitweb CGI itself, those changes would be lost upon upgrade. Configuration settings might also be placed into a file in the same directory as the CGI script with the default name &lt;code&gt;gitweb_config.perl&lt;/code&gt; &amp;mdash; allowing one to have multiple gitweb instances with different configurations by the use of symlinks.</source>
          <target state="translated">Хотя можно было просто изменить параметры конфигурации в самом gitweb CGI, эти изменения будут потеряны при обновлении. Параметры конфигурации также могут быть помещены в файл в том же каталоге, что и сценарий CGI, с именем по умолчанию &lt;code&gt;gitweb_config.perl&lt;/code&gt; , что позволяет иметь несколько экземпляров gitweb с разными конфигурациями с помощью символических ссылок.</target>
        </trans-unit>
        <trans-unit id="3129dc27b36b536bbc925e644f78f32bde86376a" translate="yes" xml:space="preserve">
          <source>While parent object ids are provided on the command line, author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">В то время как идентификаторы родительских объектов предоставляются в командной строке,информация об авторе и коммитере берется из следующих переменных окружения,если они установлены:</target>
        </trans-unit>
        <trans-unit id="7921bb694427f6298ff631684ef33f9b3436be57" translate="yes" xml:space="preserve">
          <source>While you are in the middle of working on something complicated, you find an unrelated but obvious and trivial bug. You would like to fix it before continuing. You can use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to save the current state of your work, and after fixing the bug (or, optionally after doing so on a different branch and then coming back), unstash the work-in-progress changes.</source>
          <target state="translated">Пока вы работаете над чем-то сложным, вы обнаруживаете несвязанную, но очевидную и тривиальную ошибку. Прежде чем продолжить, вы хотите исправить это. Вы можете использовать &lt;a href=&quot;git-stash&quot;&gt;git-stash [1],&lt;/a&gt; чтобы сохранить текущее состояние вашей работы, и после исправления ошибки (или, при желании, сделав это в другой ветке и затем вернувшись), открепите незавершенные изменения.</target>
        </trans-unit>
        <trans-unit id="aa47dd8a2f0ebe83c1c9e1c5b54451eb489a4bd1" translate="yes" xml:space="preserve">
          <source>Whitespace separated fields; any run of whitespace can be used as field separator (rules for Perl&amp;rsquo;s &quot;&lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt;&quot;).</source>
          <target state="translated">Поля, разделенные пробелами; любой пробел может использоваться в качестве разделителя полей (правила Perl &quot; &lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt; &quot;).</target>
        </trans-unit>
        <trans-unit id="863aeb0371f511e273bc66c19d53b7877f38ac8a" translate="yes" xml:space="preserve">
          <source>Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:</source>
          <target state="translated">Разделенный пробелами список разрешенных механизмов SMTP-AUTH.Эта настройка заставляет использовать только перечисленные механизмы.Пример:</target>
        </trans-unit>
        <trans-unit id="389ff74463b52646838e41646e64e38a902b85eb" translate="yes" xml:space="preserve">
          <source>Why bisecting merge commits can be harder than bisecting linear history</source>
          <target state="translated">Почему биссектрисные коммиты слияния могут быть сложнее,чем биссектрисная линейная история.</target>
        </trans-unit>
        <trans-unit id="d83d7d2d8de91edadaae0bc956ce69ac2202b5c1" translate="yes" xml:space="preserve">
          <source>Why do I have a file that&amp;rsquo;s always modified?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae988a6589a0546387522087a0861a61e3e4225" translate="yes" xml:space="preserve">
          <source>Wildcards in the pattern such as &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are treated as literal characters.</source>
          <target state="translated">Подстановочные знаки в шаблоне, например &lt;code&gt;*&lt;/code&gt; или &lt;code&gt;?&lt;/code&gt; рассматриваются как буквальные символы.</target>
        </trans-unit>
        <trans-unit id="af4b569cb0fc1bae5a933e3532b964dc5d61facd" translate="yes" xml:space="preserve">
          <source>Will copy all files listed from the index to the working directory (not overwriting existing files).</source>
          <target state="translated">Скопирует все файлы из индекса в рабочую директорию (не перезаписывая существующие файлы).</target>
        </trans-unit>
        <trans-unit id="712e5286413fd90307ff92f23e110885525f2bb8" translate="yes" xml:space="preserve">
          <source>Will fail unless you manually run &lt;code&gt;git fetch origin-push&lt;/code&gt;. This method is of course entirely defeated by something that runs &lt;code&gt;git fetch
--all&lt;/code&gt;, in that case you&amp;rsquo;d need to either disable it or do something more tedious like:</source>
          <target state="translated">Не удастся, если вы вручную не запустите &lt;code&gt;git fetch origin-push&lt;/code&gt; . Этот метод, конечно, полностью &lt;code&gt;git fetch --all&lt;/code&gt; , что запускает git fetch --all , в этом случае вам нужно либо отключить его, либо сделать что-то более утомительное, например:</target>
        </trans-unit>
        <trans-unit id="bfd8a0b8d0916903c6596ed358a3cc07670d304e" translate="yes" xml:space="preserve">
          <source>Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via &lt;code&gt;CreateProcess()&lt;/code&gt; is not an option because it would require the handles to be marked inheritable (and consequently &lt;strong&gt;every&lt;/strong&gt; spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt;).</source>
          <target state="translated">Только для Windows: разрешить перенаправление стандартных дескрипторов ввода / вывода / ошибок на пути, указанные в переменных среды. Это особенно полезно в многопоточных приложениях, где канонический способ передачи стандартных дескрипторов через &lt;code&gt;CreateProcess()&lt;/code&gt; не является вариантом, потому что для этого потребовалось бы, чтобы дескрипторы были помечены как наследуемые (и, следовательно, &lt;strong&gt;каждый&lt;/strong&gt; порожденный процесс унаследовал бы их, возможно, блокируя обычные операции Git. ). Основным предполагаемым вариантом использования является использование именованных каналов для связи (например, &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c510c80ca0db551792868481dfce7936d126272" translate="yes" xml:space="preserve">
          <source>Windows-only: comma-separated list of environment variables' names that need to be unset before spawning any other process. Defaults to &lt;code&gt;PERL5LIB&lt;/code&gt; to account for the fact that Git for Windows insists on using its own Perl interpreter.</source>
          <target state="translated">Только для Windows: разделенный запятыми список имен переменных среды, которые необходимо сбросить перед запуском любого другого процесса. По умолчанию используется &lt;code&gt;PERL5LIB&lt;/code&gt; , чтобы учесть тот факт, что Git для Windows настаивает на использовании собственного интерпретатора Perl.</target>
        </trans-unit>
        <trans-unit id="e74f053e0d02cafdbd0bbd14c65f9fd314f00d13" translate="yes" xml:space="preserve">
          <source>Windows-only: override whether spawned processes inherit only standard file handles (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) or all handles. Can be &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Defaults to &lt;code&gt;auto&lt;/code&gt;, which means &lt;code&gt;true&lt;/code&gt; on Windows 7 and later, and &lt;code&gt;false&lt;/code&gt; on older Windows versions.</source>
          <target state="translated">Только для Windows: переопределить, наследуют ли порожденные процессы только стандартные дескрипторы файлов ( &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; и &lt;code&gt;stderr&lt;/code&gt; ) или все дескрипторы. Может быть &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . По умолчанию установлено значение &amp;laquo; &lt;code&gt;auto&lt;/code&gt; , что означает &amp;laquo; &lt;code&gt;true&lt;/code&gt; в Windows 7 и более поздних версиях и &amp;laquo; &lt;code&gt;false&lt;/code&gt; в более старых версиях Windows.</target>
        </trans-unit>
        <trans-unit id="949442d2f0c16b026f680dbb7df65e881242333c" translate="yes" xml:space="preserve">
          <source>With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:</source>
          <target state="translated">С --abbrev,установленным в 0,команда может быть использована для поиска ближайшего магнетического имени без суффикса:</target>
        </trans-unit>
        <trans-unit id="a158e0380ec8b734a269ad9d0f52eb5eb98f2274" translate="yes" xml:space="preserve">
          <source>With --all, the command can use branch heads as references, so the output shows the reference path as well:</source>
          <target state="translated">С помощью --all команда может использовать головки ответвлений в качестве ссылок,поэтому на выходе также отображается ссылочный путь:</target>
        </trans-unit>
        <trans-unit id="65ee9a1948ccba3bbf4e1e0783ded1eb1bf032c9" translate="yes" xml:space="preserve">
          <source>With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.</source>
          <target state="translated">С помощью --batch или --batch-check при запросе объектов с расширенными SHA-1 выражениями формы tree-ish:path-in-tree следуйте по симлинкам внутри репозитория.Вместо того,чтобы предоставлять вывод о самой ссылке,предоставляйте вывод об объекте,на который дана ссылка.Если сим-ссылка указывает вне дерева (например,ссылка на /foo или ссылка корневого уровня на ../foo),то будет выведена та часть ссылки,которая находится вне дерева.</target>
        </trans-unit>
        <trans-unit id="4f48f3dcfb8092537ede5a515e981d6e213aeb9f" translate="yes" xml:space="preserve">
          <source>With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.</source>
          <target state="translated">С помощью команды --no-commit выполните слияние и остановитесь непосредственно перед созданием коммита слияния,чтобы дать пользователю возможность проверить и в дальнейшем откорректировать результат слияния перед фиксацией.</target>
        </trans-unit>
        <trans-unit id="3e8c9cc261afe4f0a3a9c88b1d66c9688df929d7" translate="yes" xml:space="preserve">
          <source>With --no-log do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">При использовании --no-log не перечисляйте описания в одну строку из самих объединяемых коммитов.</target>
        </trans-unit>
        <trans-unit id="e1adfa5cefd427bf7d3a2a21965629dcaf3c3388" translate="yes" xml:space="preserve">
          <source>With --no-signoff do not add a Signed-off-by line.</source>
          <target state="translated">С --no-signoff не добавляйте подпись по строке.</target>
        </trans-unit>
        <trans-unit id="268060b1be32cd8bc70e7e3bb40c821b809c90c3" translate="yes" xml:space="preserve">
          <source>With --no-squash perform the merge and commit the result. This option can be used to override --squash.</source>
          <target state="translated">С помощью --no-squash выполните слияние и зафиксируйте результат.Эта опция может быть использована для переопределения --squash.</target>
        </trans-unit>
        <trans-unit id="2060c61f3742702f58530c81f5eefb302aeb60c1" translate="yes" xml:space="preserve">
          <source>With --squash, --commit is not allowed, and will fail.</source>
          <target state="translated">С --squash,--commit не разрешается,и будет провал.</target>
        </trans-unit>
        <trans-unit id="865b225dd999d9769e36118a7e13e933131732f5" translate="yes" xml:space="preserve">
          <source>With -n or --no-stat do not show a diffstat at the end of the merge.</source>
          <target state="translated">С -n или --no-stat не показывают дифстата в конце слияния.</target>
        </trans-unit>
        <trans-unit id="008f5911b332311009571603d4810039f3b0a542" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of changing existing URLs, new URL is added.</source>
          <target state="translated">С помощью &lt;code&gt;--add&lt;/code&gt; вместо изменения существующих URL-адресов добавляется новый URL-адрес.</target>
        </trans-unit>
        <trans-unit id="6b50c366c66c543504b13b437403fc08b0e99b0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of replacing the list of currently tracked branches, adds to that list.</source>
          <target state="translated">С &lt;code&gt;--add&lt;/code&gt; , вместо замены списка отслеживаемых в настоящее время ветвей, добавляет в этот список.</target>
        </trans-unit>
        <trans-unit id="b5c6ad97197083d8f93283087955bd70bd89f95f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt; flag, all refs that exist locally are transferred to the remote side. You cannot specify any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; if you use this flag.</source>
          <target state="translated">С флагом &lt;code&gt;--all&lt;/code&gt; все ссылки, которые существуют локально, передаются удаленной стороне. Вы не можете указать какой-либо &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; , если используете этот флаг.</target>
        </trans-unit>
        <trans-unit id="487cd0ed38992f1c8c21d61869ab0ba8c9131e91" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt;, all URLs for the remote will be listed.</source>
          <target state="translated">С &lt;code&gt;--all&lt;/code&gt; будут перечислены все URL-адреса для удаленного.</target>
        </trans-unit>
        <trans-unit id="ea729f224a85b66147f6e662a1c5d14a2abdd751" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--contains&lt;/code&gt;, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), &lt;code&gt;--no-contains&lt;/code&gt; inverts it. With &lt;code&gt;--merged&lt;/code&gt;, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With &lt;code&gt;--no-merged&lt;/code&gt; only branches not merged into the named commit will be listed. If the &amp;lt;commit&amp;gt; argument is missing it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch).</source>
          <target state="translated">С &lt;code&gt;--contains&lt;/code&gt; , показывает только те ветви, которые содержат названный коммит (другими словами, ветки, чьи концы коммитов являются потомками названного коммита), &lt;code&gt;--no-contains&lt;/code&gt; инвертирует его. С &lt;code&gt;--merged&lt;/code&gt; будут перечислены только ветки, слитые в названный коммит (т. Е. Ветки, чьи вершины коммитов доступны из названного коммита). С параметром &lt;code&gt;--no-merged&lt;/code&gt; будут перечислены только ветки, не объединенные в названный коммит. Если аргумент &amp;lt;commit&amp;gt; отсутствует, по умолчанию используется &lt;code&gt;HEAD&lt;/code&gt; (т.е. вершина текущей ветви).</target>
        </trans-unit>
        <trans-unit id="a1afc8d7fd506e98e5a974a8f26c84b23238fb92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create-reflog&lt;/code&gt;, update-ref will create a reflog for each ref even if one would not ordinarily be created.</source>
          <target state="translated">С &lt;code&gt;--create-reflog&lt;/code&gt; update-ref создаст журнал ссылок для каждой ссылки, даже если он обычно не создавался.</target>
        </trans-unit>
        <trans-unit id="7fef88021ca55186dc4070339cc8624e9a30485c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--delete&lt;/code&gt;, instead of changing existing URLs, all URLs matching regex &amp;lt;url&amp;gt; are deleted for remote &amp;lt;name&amp;gt;. Trying to delete all non-push URLs is an error.</source>
          <target state="translated">С &lt;code&gt;--delete&lt;/code&gt; вместо изменения существующих URL-адресов все URL-адреса, соответствующие регулярному выражению &amp;lt;url&amp;gt;, удаляются для удаленного &amp;lt;name&amp;gt;. Попытка удалить все URL-адреса без принудительной отправки является ошибкой.</target>
        </trans-unit>
        <trans-unit id="30918cb51e4372be35c787127ec3b8958bb72e8d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches will be pruned, but do not actually prune them.</source>
          <target state="translated">С параметром &lt;code&gt;--dry-run&lt;/code&gt; сообщайте, какие ветви будут обрезаны, но не обрезайте их на самом деле.</target>
        </trans-unit>
        <trans-unit id="e4cd9a1b8d31ddff1298b3b28b732552e240fb7a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches would be pruned, but do not actually prune them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5189cda6779864f8bd2f5726b39c4529ff52ddf8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff-only&lt;/code&gt;, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.</source>
          <target state="translated">С &lt;code&gt;--ff-only&lt;/code&gt; разрешите слияние как перемотку вперед, когда это возможно. Если это невозможно, откажитесь от слияния и выйдите с ненулевым статусом.</target>
        </trans-unit>
        <trans-unit id="7e8f4fddd68a3a89ff49906c538a7ca7b5ef9dea" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff&lt;/code&gt;, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.</source>
          <target state="translated">С &lt;code&gt;--ff&lt;/code&gt; , когда это возможно, разрешите слияние как перемотку вперед (только обновите указатель ветки, чтобы он соответствовал объединенной ветке; не создавайте фиксацию слияния). Когда это невозможно (когда объединенная история не является потомком текущей истории), создайте фиксацию слияния.</target>
        </trans-unit>
        <trans-unit id="1362a77896d8f49d16b2f9c5015389cf3c365072" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--force&lt;/code&gt;, the fast-forward check is disabled for all refs.</source>
          <target state="translated">С помощью &lt;code&gt;--force&lt;/code&gt; проверка перемотки вперед отключена для всех ссылок.</target>
        </trans-unit>
        <trans-unit id="ba76b155ec3c447a87cfd160419204d256e0f486" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--keep-cr&lt;/code&gt;, call &lt;code&gt;git mailsplit&lt;/code&gt; (see &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;) with the same option, to prevent it from stripping CR at the end of lines. &lt;code&gt;am.keepcr&lt;/code&gt; configuration variable can be used to specify the default behaviour. &lt;code&gt;--no-keep-cr&lt;/code&gt; is useful to override &lt;code&gt;am.keepcr&lt;/code&gt;.</source>
          <target state="translated">С помощью &lt;code&gt;--keep-cr&lt;/code&gt; вызовите &lt;code&gt;git mailsplit&lt;/code&gt; (см. &lt;a href=&quot;git-mailsplit&quot;&gt;Git-mailsplit [1]&lt;/a&gt; ) с той же опцией, чтобы предотвратить удаление CR в конце строк. &lt;code&gt;am.keepcr&lt;/code&gt; конфигурации am.keepcr может использоваться для определения поведения по умолчанию. &lt;code&gt;--no-keep-cr&lt;/code&gt; полезно переопределить &lt;code&gt;am.keepcr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22e7d426b38d094430582cb84fc0432b42834058" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-ff&lt;/code&gt;, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.</source>
          <target state="translated">С &lt;code&gt;--no-ff&lt;/code&gt; во всех случаях создавайте фиксацию слияния, даже если слияние может быть разрешено как перемотка вперед.</target>
        </trans-unit>
        <trans-unit id="5aa5b8e96804090cb89f3aab6cdc283e2c00d87e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; does not import tags from the remote repository.</source>
          <target state="translated">С &lt;code&gt;--no-tags&lt;/code&gt; вариант, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; не импортирует теги из удаленного хранилища.</target>
        </trans-unit>
        <trans-unit id="37eed19521c790d78f1c0615d39722d6298a6cc8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">С помощью &lt;code&gt;--patch&lt;/code&gt; вы можете в интерактивном режиме выбирать блоки из разницы между HEAD и рабочим деревом, которые нужно сохранить. Запись тайника построена так, что ее состояние индекса совпадает с состоянием индекса вашего репозитория, а ее рабочее дерево содержит только изменения, которые вы выбрали в интерактивном режиме. Затем выбранные изменения откатываются от вашего рабочего дерева. См. Раздел &amp;laquo;Интерактивный режим&amp;raquo; в &lt;a href=&quot;git-add&quot;&gt;git-add [1],&lt;/a&gt; чтобы узнать, как работать в режиме &lt;code&gt;--patch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d4d7e74d0f493c9b38977e43daed9cfd8d04693" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--pretty&lt;/code&gt; format other than &lt;code&gt;oneline&lt;/code&gt; and &lt;code&gt;reference&lt;/code&gt; (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as &lt;code&gt;ref@{Nth}&lt;/code&gt; (where &lt;code&gt;Nth&lt;/code&gt; is the reverse-chronological index in the reflog) or as &lt;code&gt;ref@{timestamp}&lt;/code&gt; (with the timestamp for that entry), depending on a few rules:</source>
          <target state="translated">С форматом &lt;code&gt;--pretty&lt;/code&gt; , отличным от &lt;code&gt;oneline&lt;/code&gt; и &lt;code&gt;reference&lt;/code&gt; (по очевидным причинам), это приводит к тому, что в выводе будут две дополнительные строки информации, взятые из журнала ссылок. Обозначение рефлога в выходных данных может отображаться как &lt;code&gt;ref@{Nth}&lt;/code&gt; (где &lt;code&gt;Nth&lt;/code&gt; - это обратный хронологический индекс в рефлоге) или как &lt;code&gt;ref@{timestamp}&lt;/code&gt; (с меткой времени для этой записи), в зависимости от нескольких правил:</target>
        </trans-unit>
        <trans-unit id="35b7bcaa0d1a12c16e7ebe5749afd0aa0913b69d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--prune&lt;/code&gt; option, run pruning against all the remotes that are updated.</source>
          <target state="translated">С параметром &lt;code&gt;--prune&lt;/code&gt; запустите обрезку для всех обновляемых пультов.</target>
        </trans-unit>
        <trans-unit id="9a993d0e8bfe45705897018a009a33a68fb547fb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are manipulated instead of fetch URLs.</source>
          <target state="translated">С помощью &lt;code&gt;--push&lt;/code&gt; управляются URL-адреса push вместо URL-адресов выборки.</target>
        </trans-unit>
        <trans-unit id="d0c8d67cd6d67334176bbc781201963c60a05697" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are queried rather than fetch URLs.</source>
          <target state="translated">С параметром &lt;code&gt;--push&lt;/code&gt; запрашиваются URL-адреса push, а не URL-адреса получения.</target>
        </trans-unit>
        <trans-unit id="a26943d9e66efe8045d055005cf22b61dc280b47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--stdin&lt;/code&gt;, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:</source>
          <target state="translated">С &lt;code&gt;--stdin&lt;/code&gt; update-ref считывает инструкции со стандартного ввода и выполняет все изменения вместе. Укажите команды формы:</target>
        </trans-unit>
        <trans-unit id="46644e8c0f7ae9adba68ae4958242044a646f477" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; imports every tag from the remote repository.</source>
          <target state="translated">С параметром &lt;code&gt;--tags&lt;/code&gt; &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; импортирует каждый тег из удаленного репозитория.</target>
        </trans-unit>
        <trans-unit id="9afd8cc2d67d37867f3891e80c5ed22f0441334c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--topo-order&lt;/code&gt;, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.</source>
          <target state="translated">С &lt;code&gt;--topo-order&lt;/code&gt; они будут показывать 8 6 5 3 7 4 2 1 (или 8 7 4 2 6 5 3 1); некоторые старые коммиты показаны перед новыми, чтобы не показывать смешанные вместе коммиты из двух параллельных треков разработки.</target>
        </trans-unit>
        <trans-unit id="bbe3bdb143c872f8bc3522bea317a2ad84af9235" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &quot;&lt;code&gt;git remote set-head origin -a&lt;/code&gt;&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">С помощью &lt;code&gt;-a&lt;/code&gt; или &lt;code&gt;--auto&lt;/code&gt; удаленный запрашивается, чтобы определить его &lt;code&gt;HEAD&lt;/code&gt; , затем символическая ссылка &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; устанавливается на ту же ветку. например, если удаленный &lt;code&gt;HEAD&lt;/code&gt; указывает на &lt;code&gt;next&lt;/code&gt; , &quot; &lt;code&gt;git remote set-head origin -a&lt;/code&gt; &quot; установит для символической ссылки &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; значение &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; . Это будет работать, только если &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; уже существует; в противном случае он должен быть получен первым.</target>
        </trans-unit>
        <trans-unit id="ca79465e71cd43be9bc8a1c0daf2d4aececc9880" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;git remote set-head origin -a&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f69d8ea721996a0e954b69bd77400aaa01f9c55" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; flag, it deletes the named &amp;lt;ref&amp;gt; after verifying it still contains &amp;lt;oldvalue&amp;gt;.</source>
          <target state="translated">С флагом &lt;code&gt;-d&lt;/code&gt; он удаляет названный &amp;lt;ref&amp;gt; после проверки, что он все еще содержит &amp;lt;oldvalue&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="da9e1b9da40421df76a154165f2b54d479838ea5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;--delete&lt;/code&gt;, the symbolic ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is deleted.</source>
          <target state="translated">С &lt;code&gt;-d&lt;/code&gt; или &lt;code&gt;--delete&lt;/code&gt; удаляется символическая ссылка &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b0b5064fe468e227911615a2b7fcbafb431eef7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-f&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; is run immediately after the remote information is set up.</source>
          <target state="translated">С параметром &lt;code&gt;-f&lt;/code&gt; &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; запускается сразу после настройки удаленной информации.</target>
        </trans-unit>
        <trans-unit id="4c11581a6169e0a17084bd502989c1df6d5ff9b6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; option, a symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set up to point at remote&amp;rsquo;s &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; branch. See also the set-head command.</source>
          <target state="translated">С параметром &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; , символическая ссылка &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; устанавливается так, чтобы указывать на удаленную ветку &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; . См. Также команду set-head.</target>
        </trans-unit>
        <trans-unit id="734f06f2f4ad450ab9efcf1cd7537f18bb0a22f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-n&lt;/code&gt; option, the remote heads are not queried first with &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt;; cached information is used instead.</source>
          <target state="translated">С параметром &lt;code&gt;-n&lt;/code&gt; удаленные головы не запрашиваются сначала с помощью &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt; ; Вместо этого используется кэшированная информация.</target>
        </trans-unit>
        <trans-unit id="dd75e538fb39d452e807a34068040583ee9147bc" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; option, instead of the default glob refspec for the remote to track all branches under the &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; namespace, a refspec to track only &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is created. You can give more than one &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; to track multiple branches without grabbing all branches.</source>
          <target state="translated">С параметром &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; вместо стандартной glob refspec для удаленного отслеживания всех ветвей в пространстве имен &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; создается refspec для отслеживания только &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; . Вы можете указать более одного &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; для отслеживания нескольких ветвей, не захватывая все ветки.</target>
        </trans-unit>
        <trans-unit id="3a17d1e0c132aee2d2be1ec1ea02b9a88fab2a36" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added, even if some trailers with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair are already in the message.</source>
          <target state="translated">При &lt;code&gt;add&lt;/code&gt; новый трейлер будет добавлен, даже если несколько трейлеров с такой же парой (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) уже есть в сообщении.</target>
        </trans-unit>
        <trans-unit id="bdb99f7baa9796a7b973194e1a5ab4a7e3d82b92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added.</source>
          <target state="translated">С &lt;code&gt;add&lt;/code&gt; будет добавлен новый трейлер.</target>
        </trans-unit>
        <trans-unit id="3d04d4d1926f980c37f6ca9761913ed7f096d165" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b61b0983644b0774834807009f4d278bb642b5a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to HEAD. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">С помощью &lt;code&gt;add&lt;/code&gt; создайте новую ветку с именем &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; , начиная с &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , и извлеките &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; в новое рабочее дерево. Если &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; опущено, по умолчанию используется HEAD. По умолчанию &lt;code&gt;-b&lt;/code&gt; отказывается создавать новую ветку, если она уже существует. &lt;code&gt;-B&lt;/code&gt; отменяет эту защиту, сбрасывая &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; на &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d424a0ce9af1bab4df82ba9ed9c152743e40b774" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach &lt;code&gt;HEAD&lt;/code&gt; in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a273ddd960841784db1a589aad98c4feff6c226" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach HEAD in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">С помощью &lt;code&gt;add&lt;/code&gt; отсоедините HEAD в новом рабочем дереве. См. &amp;laquo;ОТДЕЛЕННАЯ ГОЛОВА&amp;raquo; в &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="187a01bfec37522a00b693f68238b703a4e0897c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, suppress feedback messages.</source>
          <target state="translated">С помощью &lt;code&gt;add&lt;/code&gt; подавить сообщения обратной связи.</target>
        </trans-unit>
        <trans-unit id="45995ca3706219a58e816f38cd1d9bf0922ce8ca" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferent&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is already in the message.</source>
          <target state="translated">С &lt;code&gt;addIfDifferent&lt;/code&gt; новый трейлер будет добавлен только в том случае, если в сообщении уже нет трейлера с такой же парой (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="6e3bd24c09b16e87e69f4ad565a18cc8f733f593" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is above or below the line where the new trailer will be added.</source>
          <target state="translated">С &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; новый трейлер будет добавлен только в том случае, если трейлер с такой же парой (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) не находится выше или ниже линии, в которую будет добавлен новый трейлер.</target>
        </trans-unit>
        <trans-unit id="c538516bcb20191b3fc9da51228fff3eefb68cdf" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done.</source>
          <target state="translated">С &lt;code&gt;doNothing&lt;/code&gt; ничего делать не будет.</target>
        </trans-unit>
        <trans-unit id="91898a3512235050c32c7a99a50c8394d7a8397d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done; that is no new trailer will be added if there is already one with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">С &lt;code&gt;doNothing&lt;/code&gt; ничего не будет сделано; то есть новый трейлер не будет добавлен, если в сообщении уже есть трейлер с таким же &amp;lt;token&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="fafece11b5178185f0dda98fe61f1218eca3ec1e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (or variants thereof, e.g. with &lt;code&gt;--cover-letter&lt;/code&gt; or using &lt;code&gt;Z..C&lt;/code&gt; instead of &lt;code&gt;-3 C&lt;/code&gt; to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:</source>
          <target state="translated">С &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (или его вариантами, например, с &lt;code&gt;--cover-letter&lt;/code&gt; или с использованием &lt;code&gt;Z..C&lt;/code&gt; вместо &lt;code&gt;-3 C&lt;/code&gt; для указания диапазона) информационный блок базового дерева отображается в конец первого сообщения, которое выводит команда (либо первый патч, либо сопроводительное письмо), например:</target>
        </trans-unit>
        <trans-unit id="0dbfc249aea522f6a40d4b8be190d1fc0f0eadd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list&lt;/code&gt;, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">С помощью &lt;code&gt;list&lt;/code&gt; вывод в удобном для анализа формате для скриптов. Этот формат останется стабильным для всех версий Git и независимо от конфигурации пользователя. Подробнее см. Ниже.</target>
        </trans-unit>
        <trans-unit id="021957faebf0fa8a6ba6fb4276abb6b8c72afba9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lock&lt;/code&gt;, an explanation why the working tree is locked.</source>
          <target state="translated">С &lt;code&gt;lock&lt;/code&gt; объяснение, почему рабочее дерево заблокировано.</target>
        </trans-unit>
        <trans-unit id="bbe63cab2529b193584b4f7d1c86ee0207fc9968" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, do not remove anything; just report what it would remove.</source>
          <target state="translated">С &lt;code&gt;prune&lt;/code&gt; ничего не удаляйте; просто сообщите, что он удалит.</target>
        </trans-unit>
        <trans-unit id="97f5cdb302d7f0a46689004724feb3d1aca29383" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">С &lt;code&gt;prune&lt;/code&gt; только неиспользуемые рабочие деревья старше &amp;lt;time&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="fe3d9726d2a7e550ec17d9d6b1b3e9e51367506e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ffa86e9306849b846038bae2a07ad322d0f86c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, report all removals.</source>
          <target state="translated">С помощью &lt;code&gt;prune&lt;/code&gt; сообщайте обо всех удалениях.</target>
        </trans-unit>
        <trans-unit id="f6631b122f785beeb20cb0ef884a421b144138ae" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;replace&lt;/code&gt;, an existing trailer with the same &amp;lt;token&amp;gt; will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same &amp;lt;token&amp;gt;) to the place where the new one will be added.</source>
          <target state="translated">При &lt;code&gt;replace&lt;/code&gt; существующий трейлер с тем же символом &amp;lt;token&amp;gt; будет удален, а новый трейлер будет добавлен. Удаленный трейлер будет ближайшим (с тем же &amp;lt;token&amp;gt;) к месту, где будет добавлен новый.</target>
        </trans-unit>
        <trans-unit id="a80ff1485c839f0e248b3acec4853d6b6aaf0d80" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from &lt;code&gt;HEAD&lt;/code&gt;, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b787c22358696a7fd63895c838388aed6d7912a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">С &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; , без &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , вместо создания новой ветки из HEAD, если существует ветвь отслеживания ровно на одном удаленном компьютере, соответствующем базовому имени &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; , создайте новую ветвь на удаленном отслеживании ветвь и отметьте ветвь удаленного отслеживания как &amp;laquo;восходящую&amp;raquo; от новой ветки.</target>
        </trans-unit>
        <trans-unit id="660d18378dc3af084a2ac18df92d87c9aea68c5a" translate="yes" xml:space="preserve">
          <source>With Git bisect it&amp;rsquo;s a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it&amp;rsquo;s rarely more than an hour.</source>
          <target state="translated">С Git bisect это совсем несложно: в лучшем случае я смогу сделать ~ 15 шагов ядра пополам за 20-30 минут, автоматически. Даже с ручной помощью или при разделении пополам нескольких перекрывающихся ошибок редко бывает больше часа.</target>
        </trans-unit>
        <trans-unit id="46d101f0f209ac246ff187c45b6b808668e526b7" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted.</source>
          <target state="translated">С &lt;code&gt;-d&lt;/code&gt; или &lt;code&gt;-D&lt;/code&gt; опции &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; будут удалены. Вы можете указать более одной ветви для удаления. Если в ветке в настоящее время есть журнал ссылок, он также будет удален.</target>
        </trans-unit>
        <trans-unit id="f74d36fd60998cbf589b7f2b7f7bc156998c0334" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-M&lt;/code&gt; option, &amp;lt;oldbranch&amp;gt; will be renamed to &amp;lt;newbranch&amp;gt;. If &amp;lt;oldbranch&amp;gt; had a corresponding reflog, it is renamed to match &amp;lt;newbranch&amp;gt;, and a reflog entry is created to remember the branch renaming. If &amp;lt;newbranch&amp;gt; exists, -M must be used to force the rename to happen.</source>
          <target state="translated">С опцией &lt;code&gt;-m&lt;/code&gt; или &lt;code&gt;-M&lt;/code&gt; &amp;lt;oldbranch&amp;gt; будет переименован в &amp;lt;newbranch&amp;gt;. Если &amp;lt;oldbranch&amp;gt; имел соответствующий журнал ссылок, он переименовывается в соответствии с &amp;lt;newbranch&amp;gt;, и создается запись журнала ссылок для запоминания переименования ветки. Если &amp;lt;newbranch&amp;gt; существует, необходимо использовать -M для принудительного переименования.</target>
        </trans-unit>
        <trans-unit id="078f9b93867e54fc6fd5cb6cccb717d173a4bdbb" translate="yes" xml:space="preserve">
          <source>With a small group, developers may just pull changes from each other&amp;rsquo;s repositories without the need for a central maintainer.</source>
          <target state="translated">В небольшой группе разработчики могут просто извлекать изменения из репозиториев друг друга без необходимости в центральном сопровождающем.</target>
        </trans-unit>
        <trans-unit id="d93af44627c4056a70413d4d1086a466c1eb6057" translate="yes" xml:space="preserve">
          <source>With an optional &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">С необязательным аргументом &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; используйте ссылку, чтобы найти заметки для отображения. Ссылка может указать полное имя ссылки, если она начинается с &lt;code&gt;refs/notes/&lt;/code&gt; ; когда он начинается с &lt;code&gt;notes/&lt;/code&gt; , &lt;code&gt;refs/&lt;/code&gt; и в противном случае &lt;code&gt;refs/notes/&lt;/code&gt; имеет префикс, чтобы сформировать полное имя ссылки.</target>
        </trans-unit>
        <trans-unit id="5888510f888416379a4d4b5651fc198f809cb1eb" translate="yes" xml:space="preserve">
          <source>With an optional argument, you can return to a different commit instead:</source>
          <target state="translated">С необязательным аргументом вы можете вернуться к другому коммиту:</target>
        </trans-unit>
        <trans-unit id="70761b9c0ed85e86f5fe4551851f4fb12dda8ef2" translate="yes" xml:space="preserve">
          <source>With centralized revision control systems this is often accomplished by including every module in one single repository. Developers can check out all modules or only the modules they need to work with. They can even modify files across several modules in a single commit while moving things around or updating APIs and translations.</source>
          <target state="translated">С централизованными системами контроля ревизий это часто достигается путем включения каждого модуля в одно хранилище.Разработчики могут проверить все модули или только те,с которыми им необходимо работать.Они даже могут изменять файлы в нескольких модулях за один коммит,перемещая их или обновляя API и переводы.</target>
        </trans-unit>
        <trans-unit id="4c6d117a828bd4f381c3ccbd2807a5bac87363d5" translate="yes" xml:space="preserve">
          <source>With most hosting providers that support SSH, a single key pair uniquely identifies a user. Therefore, to use multiple accounts, it&amp;rsquo;s necessary to create a key pair for each account. If you&amp;rsquo;re using a reasonably modern OpenSSH version, you can create a new key pair with something like &lt;code&gt;ssh-keygen -t ed25519 -f ~/.ssh/id_committer&lt;/code&gt;. You can then register the public key (in this case, &lt;code&gt;~/.ssh/id_committer.pub&lt;/code&gt;; note the &lt;code&gt;.pub&lt;/code&gt;) with the hosting provider.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34547cdab6bbebc8d70f8627cf92ce4ed49693c0" translate="yes" xml:space="preserve">
          <source>With no arguments, shows a list of existing remotes. Several subcommands are available to perform operations on the remotes.</source>
          <target state="translated">Без аргументов,показывает список существующих пультов.Для выполнения операций на пультах имеется несколько подкоманд.</target>
        </trans-unit>
        <trans-unit id="2d8eac222dcf5b2fb83219646b45ebbea55b5081" translate="yes" xml:space="preserve">
          <source>With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules.</source>
          <target state="translated">Без аргументов,показывает статус существующих субмодулей.Для выполнения операций над подмодулями доступно несколько подкоманд.</target>
        </trans-unit>
        <trans-unit id="2955e54fe9fa9b7446c513283cbd98f27b722daf" translate="yes" xml:space="preserve">
          <source>With no arguments, this will:</source>
          <target state="translated">Без всяких аргументов,это будет:</target>
        </trans-unit>
        <trans-unit id="07ab1293ff3b475c814f1fed59da838b442b2582" translate="yes" xml:space="preserve">
          <source>With no options and no COMMAND or GUIDE given, the synopsis of the &lt;code&gt;git&lt;/code&gt; command and a list of the most commonly used Git commands are printed on the standard output.</source>
          <target state="translated">Без параметров и без указания КОМАНДЫ или РУКОВОДСТВА синопсис команды &lt;code&gt;git&lt;/code&gt; и список наиболее часто используемых команд Git выводятся на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="5afd0acc1bfdb6a1daab0a26aea947b62407909e" translate="yes" xml:space="preserve">
          <source>With something like git.git current tree, I get:</source>
          <target state="translated">С чем-то вроде дерева Git.git current,я понял:</target>
        </trans-unit>
        <trans-unit id="48292de53da5a3060e12b426e889eefbf2d24e76" translate="yes" xml:space="preserve">
          <source>With that configuration the full path to browse repositories would be:</source>
          <target state="translated">При такой конфигурации будет полный путь к просмотру репозиториев:</target>
        </trans-unit>
        <trans-unit id="de963656527f9e7a6067d643ee4aa5bfca1b2d08" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--append&lt;/code&gt; option, include all commits that are present in the existing commit-graph file.</source>
          <target state="translated">С параметром &lt;code&gt;--append&lt;/code&gt; включите все коммиты, которые присутствуют в существующем файле графика фиксации.</target>
        </trans-unit>
        <trans-unit id="14495f11a1a9217fb75c7d6db611a80cccd6e859" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--branch&lt;/code&gt; option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state. The rule &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; implements may be stricter than what &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name). When run with &lt;code&gt;--branch&lt;/code&gt; option in a repository, the input is first expanded for the &amp;ldquo;previous checkout syntax&amp;rdquo; &lt;code&gt;@{-n}&lt;/code&gt;. For example, &lt;code&gt;@{-1}&lt;/code&gt; is a way to refer the last thing that was checked out using &quot;git switch&quot; or &quot;git checkout&quot; operation. This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the &amp;ldquo;previous checkout operation&amp;rdquo; might result in a commit object name when the N-th last thing checked out was not a branch.</source>
          <target state="translated">С параметром &lt;code&gt;--branch&lt;/code&gt; команда берет имя и проверяет, можно ли его использовать в качестве допустимого имени ветки (например, при создании новой ветки). Но будьте осторожны при использовании предыдущего синтаксиса извлечения, который может относиться к отключенному состоянию HEAD. Правило &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; реализует может быть строже, чем указано в &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; (например, в начале компонента ref может появиться тире, но это явно запрещено в начале имени ветки). При запуске с опцией &lt;code&gt;--branch&lt;/code&gt; в репозитории ввод сначала расширяется для &amp;laquo;синтаксиса предыдущей проверки&amp;raquo; &lt;code&gt;@{-n}&lt;/code&gt; . Например, &lt;code&gt;@{-1}&lt;/code&gt; это способ указать последнее, что было проверено с помощью операции &amp;laquo;git switch&amp;raquo; или &amp;laquo;git checkout&amp;raquo;. Эта опция должна использоваться фарфором, чтобы принять этот синтаксис везде, где ожидается имя ветки, чтобы они могли действовать так, как если бы вы ввели имя ветки. В качестве исключения обратите внимание, что &amp;laquo;предыдущая операция проверки&amp;raquo; может привести к получению имени объекта фиксации, если N-я последняя извлеченная вещь не была ветвью.</target>
        </trans-unit>
        <trans-unit id="294719ccdfaa2864ec086fd6924ef46c18c6d01c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--changed-paths&lt;/code&gt; option, compute and write information about the paths changed between a commit and its first parent. This operation can take a while on large repositories. It provides significant performance gains for getting history of a directory or a file with &lt;code&gt;git log -- &amp;lt;path&amp;gt;&lt;/code&gt;. If this option is given, future commit-graph writes will automatically assume that this option was intended. Use &lt;code&gt;--no-changed-paths&lt;/code&gt; to stop storing this data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac44a38e65d55dddeac740d3be63e38e85fa148" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--max-new-filters=&amp;lt;n&amp;gt;&lt;/code&gt; option, generate at most &lt;code&gt;n&lt;/code&gt; new Bloom filters (if &lt;code&gt;--changed-paths&lt;/code&gt; is specified). If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, no limit is enforced. Only commits present in the new layer count against this limit. To retroactively compute Bloom filters over earlier layers, it is advised to use &lt;code&gt;--split=replace&lt;/code&gt;. Overrides the &lt;code&gt;commitGraph.maxNewFilters&lt;/code&gt; configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26f07033bd08bfdb6102afbc60e4bb690a51e35" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--reachable&lt;/code&gt; option, generate the new commit graph by walking commits starting at all refs. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--stdin-packs&lt;/code&gt;.)</source>
          <target state="translated">С параметром &lt;code&gt;--reachable&lt;/code&gt; сгенерируйте новый граф коммитов, пройдя коммиты, начиная со всех ссылок. (Нельзя сочетать с &lt;code&gt;--stdin-commits&lt;/code&gt; &lt;code&gt;--stdin-packs&lt;/code&gt; или --stdin-packs .)</target>
        </trans-unit>
        <trans-unit id="bced3fa737464959bcb0c4d4992aedaa6293d7b5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--shallow&lt;/code&gt; option, only check the tip commit-graph file in a chain of split commit-graphs.</source>
          <target state="translated">С параметром &lt;code&gt;--shallow&lt;/code&gt; проверяйте только файл графа фиксации подсказки в цепочке разделенных графов фиксации.</target>
        </trans-unit>
        <trans-unit id="023fb87ae200847a2eb976930adb7f7ff9a576bb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">С параметром &lt;code&gt;--split&lt;/code&gt; запишите график фиксации как цепочку из нескольких файлов графа фиксации, хранящихся в &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; . Новые коммиты, которых еще нет в графе коммитов, добавляются в новый файл &quot;подсказок&quot;. Этот файл объединяется с существующим файлом, если выполняются следующие условия объединения:</target>
        </trans-unit>
        <trans-unit id="6bf69abea1fff62b20072adaab62de0f43e36b76" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split[=&amp;lt;strategy&amp;gt;]&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. Commit-graph layers are merged based on the strategy and other splitting options. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f402e69b2097f87a53ae26564ee053ba1f630ec" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">С параметром &lt;code&gt;--stdin-commits&lt;/code&gt; сгенерируйте новый граф коммитов, пройдя коммиты, начиная с коммитов, указанных в stdin в виде списка OID в шестнадцатеричном формате, по одному OID на строку. (Нельзя сочетать с &lt;code&gt;--stdin-packs&lt;/code&gt; или &lt;code&gt;--reachable&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="4837cdd22ed59b809de4737c644da886aae1ea19" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. OIDs that resolve to non-commits (either directly, or by peeling tags) are silently ignored. OIDs that are malformed, or do not exist generate an error. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf73ef52d157ce1e4ddc4b827c0a6415ea79de1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-packs&lt;/code&gt; option, generate the new commit graph by walking objects only in the specified pack-indexes. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">С параметром &lt;code&gt;--stdin-packs&lt;/code&gt; сгенерируйте новый граф фиксации, перемещая объекты только в указанных индексах пакетов. (Нельзя сочетать с &lt;code&gt;--stdin-commits&lt;/code&gt; &lt;code&gt;--reachable&lt;/code&gt; или --reachable .)</target>
        </trans-unit>
        <trans-unit id="17857b1a19de2786ab177b98550f7755d5958169" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;subsystem&lt;/code&gt; reflog: after &lt;code&gt;git fetch&lt;/code&gt;, the old tip of &lt;code&gt;subsystem&lt;/code&gt; is at &lt;code&gt;subsystem@{1}&lt;/code&gt;. Subsequent fetches will increase the number. (See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.)</source>
          <target state="translated">С &lt;code&gt;subsystem&lt;/code&gt; reflog: после &lt;code&gt;git fetch&lt;/code&gt; старая подсказка &lt;code&gt;subsystem&lt;/code&gt; находится в &lt;code&gt;subsystem@{1}&lt;/code&gt; . Последующие выборки увеличат число. (См. &lt;a href=&quot;git-reflog&quot;&gt;Git-reflog [1]&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b4f2100600cd65d2bb507aefd40b38b428ed31a7" translate="yes" xml:space="preserve">
          <source>With the example above that would give:</source>
          <target state="translated">На приведенном выше примере:</target>
        </trans-unit>
        <trans-unit id="a003c8ea87ae62c71ced8657b18db066ae621f53" translate="yes" xml:space="preserve">
          <source>With the exception of raw file data (which Git does not interpret) the fast-import input format is text (ASCII) based. This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used.</source>
          <target state="translated">За исключением исходных файловых данных (которые Git не интерпретирует),формат быстрого импорта-текстовый (ASCII).Этот текстовый формат упрощает разработку и отладку фронтендовых программ,особенно когда используется язык более высокого уровня,такой как Perl,Python или Ruby.</target>
        </trans-unit>
        <trans-unit id="832b24adba81a74f8f3c27d1a374c3c9abe6eae9" translate="yes" xml:space="preserve">
          <source>With the latter, you can use the manual viewer of your choice; see &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information.</source>
          <target state="translated">В последнем случае вы можете использовать любое средство просмотра вручную; см. &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="fd552b2cf02d64fea6c3a2fbecdcfeec69fa5199" translate="yes" xml:space="preserve">
          <source>With the right arguments, &lt;code&gt;git diff&lt;/code&gt; can also show us the difference between the working directory and the last commit, or between the index and the last commit:</source>
          <target state="translated">С правильными аргументами &lt;code&gt;git diff&lt;/code&gt; также может показать нам разницу между рабочим каталогом и последней фиксацией или между индексом и последней фиксацией:</target>
        </trans-unit>
        <trans-unit id="6936b3f47f8ae1f272ba09aecb9105ac3f327d8a" translate="yes" xml:space="preserve">
          <source>With the strategies that use 3-way merge (including the default, &lt;code&gt;recursive&lt;/code&gt;), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.</source>
          <target state="translated">В стратегиях, использующих 3-стороннее слияние (включая &lt;code&gt;recursive&lt;/code&gt; по умолчанию ), если изменение было сделано в обеих ветвях, но позже было отменено в одной из ветвей, это изменение будет присутствовать в результате слияния; некоторых людей это поведение сбивает с толку. Это происходит потому, что при выполнении слияния учитываются только заголовки и база слияния, а не отдельные коммиты. Следовательно, алгоритм слияния рассматривает отмененное изменение как полное отсутствие изменений и заменяет вместо этого измененную версию.</target>
        </trans-unit>
        <trans-unit id="993a54cdc4357f066aea765f4571bf68eff0acc7" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git cherry-pick&lt;/code&gt; will let you edit the commit message prior to committing.</source>
          <target state="translated">С этой опцией &lt;code&gt;git cherry-pick&lt;/code&gt; позволит вам редактировать сообщение фиксации перед фиксацией.</target>
        </trans-unit>
        <trans-unit id="333853f3b4bc551496449cd51ab3f625f2fd83b5" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git gc&lt;/code&gt; checks whether any housekeeping is required; if not, it exits without performing any work.</source>
          <target state="translated">С этой опцией &lt;code&gt;git gc&lt;/code&gt; проверяет, требуется ли какая-либо уборка; в противном случае он выходит без выполнения каких-либо действий.</target>
        </trans-unit>
        <trans-unit id="71e625d3b0cf2785820345a3c9b0fc38126ae685" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.</source>
          <target state="translated">С этой опцией &lt;code&gt;git revert&lt;/code&gt; позволит вам редактировать сообщение фиксации перед фиксацией возврата. Это значение по умолчанию, если вы запускаете команду из терминала.</target>
        </trans-unit>
        <trans-unit id="c4b763c3b176a1288a147104d8354f56c0e27e09" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will not start the commit message editor.</source>
          <target state="translated">С этой опцией &lt;code&gt;git revert&lt;/code&gt; не запустит редактор сообщений фиксации.</target>
        </trans-unit>
        <trans-unit id="8c4fe13a9c7d1e41585a8e2b5418a2b1ca5a28f1" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;merge-recursive&lt;/code&gt; spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--patience&lt;/code&gt;.</source>
          <target state="translated">С этой опцией &lt;code&gt;merge-recursive&lt;/code&gt; тратит немного больше времени, чтобы избежать ошибочных слияний, которые иногда возникают из-за несущественных совпадающих строк (например, фигурных скобок из разных функций). Используйте это, когда ветви, которые нужно объединить, сильно разошлись. См. Также &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--patience&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7fa933690b4dfe40d9dc500f9cfa6ba3897c3d" translate="yes" xml:space="preserve">
          <source>With this option, diff output for a merge commit shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">С помощью этой опции вывод diff для фиксации слияния показывает различия от каждого родителя к результату слияния одновременно,вместо того,чтобы показывать пару различий между родителем и результатом по одному за раз.Более того,в нем перечислены только файлы,которые были изменены от всех родителей.</target>
        </trans-unit>
        <trans-unit id="3524864d6b6fccf88decb6caefb79eeb0a8e7c7e" translate="yes" xml:space="preserve">
          <source>With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data. Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced.</source>
          <target state="translated">С помощью этой опции git заменит все имена обновлений,пути,содержимое блоков,сообщения коммитов и тегов,имена и адреса электронной почты в выводе на анонимизированные данные.Два экземпляра одной и той же строки будут заменены эквивалентно (например,два коммита с одним и тем же автором будут иметь в выводе один и тот же анонимизированный автор,но не будут иметь сходства с исходной строкой автора).Сохраняется связь между коммитами,ветками и тегами,а также метки времени коммита (но сообщения и имена коммитов не имеют сходства с оригиналами).Сохраняется относительная структура дерева (например,если у вас есть корневое дерево с 10 файлами и 3 деревьями,то и вывод тоже),но их имена и содержимое файлов будут заменены.</target>
        </trans-unit>
        <trans-unit id="cbb1ff7744c2585e2c6b4c0275539aaae99818d7" translate="yes" xml:space="preserve">
          <source>With this option, parents that are hidden by grafts are packed nevertheless.</source>
          <target state="translated">С помощью этой опции родители,которые скрыты под прививками,тем не менее,упаковываются.</target>
        </trans-unit>
        <trans-unit id="64d24b372615e7424e92210d8b3079a3b6d54b46" translate="yes" xml:space="preserve">
          <source>With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line.</source>
          <target state="translated">С помощью этой опции команда включает текущую ветку в список оборотов,которые будут показаны,когда она не задана в командной строке.</target>
        </trans-unit>
        <trans-unit id="a7994938c4128018ec7f46d918cac8d359a1f2eb" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;git show-branch&lt;/code&gt; without extra parameters would show only the primary branches. In addition, if you happen to be on your topic branch, it is shown as well.</source>
          <target state="translated">При этом &lt;code&gt;git show-branch&lt;/code&gt; без дополнительных параметров будет отображать только основные ветки. Кроме того, если вы оказались в своей тематической ветке, она также отображается.</target>
        </trans-unit>
        <trans-unit id="7d389d82d11c207ddbcbb54d477d308b2e5d9f7f" translate="yes" xml:space="preserve">
          <source>With this, Alice can perform the first part of the &quot;pull&quot; operation alone using the &lt;code&gt;git fetch&lt;/code&gt; command without merging them with her own branch, using:</source>
          <target state="translated">При этом Алиса может выполнить первую часть операции &amp;laquo;вытягивания&amp;raquo; самостоятельно, используя команду &lt;code&gt;git fetch&lt;/code&gt; , не объединяя их со своей собственной веткой, используя:</target>
        </trans-unit>
        <trans-unit id="6062bf6506f2ab2b976dee38aa5322c59a129e2f" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, $GIT_DIR is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and $GIT_COMMON_DIR is set to point back to the main working tree&amp;rsquo;s $GIT_DIR (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">Внутри связанного рабочего дерева $ GIT_DIR настроен так, чтобы указывать на этот частный каталог (например, &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; в примере), а $ GIT_COMMON_DIR настроен так, чтобы указывать обратно на $ GIT_DIR основного рабочего дерева (например, &lt;code&gt;/path/main/.git&lt;/code&gt; ). Эти настройки выполняются в файле &lt;code&gt;.git&lt;/code&gt; , расположенном в верхнем каталоге связанного рабочего дерева.</target>
        </trans-unit>
        <trans-unit id="28d243903fe73e45525c0f96e48fd5d6abc9c7f9" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, &lt;code&gt;$GIT_DIR&lt;/code&gt; is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; is set to point back to the main working tree&amp;rsquo;s &lt;code&gt;$GIT_DIR&lt;/code&gt; (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f531335c76344721aaf744205582ff3be68651bd" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--all&lt;/code&gt; and without any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;, the heads that exist both on the local side and on the remote side are updated.</source>
          <target state="translated">Без &lt;code&gt;--all&lt;/code&gt; и без &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; обновляются заголовки, существующие как на локальной, так и на удаленной стороне.</target>
        </trans-unit>
        <trans-unit id="af870a4c72e2ec7c668a803b1e745b16df6d1c9d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--follow-symlinks&lt;/code&gt;, these would print data about the symlink itself. In the case of &lt;code&gt;HEAD:link&lt;/code&gt;, you would see</source>
          <target state="translated">Без &lt;code&gt;--follow-symlinks&lt;/code&gt; они будут печатать данные о самой символической ссылке . В случае &lt;code&gt;HEAD:link&lt;/code&gt; вы увидите</target>
        </trans-unit>
        <trans-unit id="a213d6298e44415b29925050ee6ffa235637e828" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--force&lt;/code&gt;, the &amp;lt;src&amp;gt; ref is stored at the remote only if &amp;lt;dst&amp;gt; does not exist, or &amp;lt;dst&amp;gt; is a proper subset (i.e. an ancestor) of &amp;lt;src&amp;gt;. This check, known as &quot;fast-forward check&quot;, is performed in order to avoid accidentally overwriting the remote ref and lose other peoples' commits from there.</source>
          <target state="translated">Без &lt;code&gt;--force&lt;/code&gt; ссылка &amp;lt;src&amp;gt; сохраняется на удаленном компьютере только в том случае, если &amp;lt;dst&amp;gt; не существует или &amp;lt;dst&amp;gt; является правильным подмножеством (т. Е. Предком) &amp;lt;src&amp;gt;. Эта проверка, известная как &amp;laquo;ускоренная проверка вперед&amp;raquo;, выполняется, чтобы избежать случайной перезаписи удаленной ссылки и потери оттуда коммитов других людей.</target>
        </trans-unit>
        <trans-unit id="44aa5155d389a8a00fc9a9c0d5c5dc24c0b6b423" translate="yes" xml:space="preserve">
          <source>Without additional configuration, pushes the current branch to the configured upstream (&lt;code&gt;remote.origin.merge&lt;/code&gt; configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.</source>
          <target state="translated">Без дополнительной настройки &lt;code&gt;remote.origin.merge&lt;/code&gt; текущую ветвь в настроенный восходящий поток ( переменная конфигурации remote.origin.merge ), если она имеет то же имя, что и текущая ветвь, и выводит ошибку, не нажимая в противном случае.</target>
        </trans-unit>
        <trans-unit id="0d4981e0bf66e69e6f534946531426d82d26ec6d" translate="yes" xml:space="preserve">
          <source>Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.</source>
          <target state="translated">Без необязательного параметра path все файлы и подкаталоги текущей рабочей директории включаются в архив.Если указан один или несколько путей,то включаются только они.</target>
        </trans-unit>
        <trans-unit id="0aaf17e36c6d625d7976371bb21725d2cea205e0" translate="yes" xml:space="preserve">
          <source>Without any credential helpers defined, Git will try the following strategies to ask the user for usernames and passwords:</source>
          <target state="translated">Если не определены помощники авторизации,Git попробует следующие стратегии,чтобы запросить у пользователя имена пользователей и пароли:</target>
        </trans-unit>
        <trans-unit id="6f8c2669a27a9c22abf3f515b27b1a9a5be3b6dc" translate="yes" xml:space="preserve">
          <source>Without disambiguating &lt;code&gt;--&lt;/code&gt;, Git makes a reasonable guess, but errors out and asking you to disambiguate when ambiguous. E.g. if you have a file called HEAD in your work tree, &lt;code&gt;git diff HEAD&lt;/code&gt; is ambiguous, and you have to say either &lt;code&gt;git diff HEAD --&lt;/code&gt; or &lt;code&gt;git diff -- HEAD&lt;/code&gt; to disambiguate.</source>
          <target state="translated">Без устранения неоднозначности &lt;code&gt;--&lt;/code&gt; Git делает разумное предположение, но выдает ошибку и просит вас устранить неоднозначность, если она неоднозначна. Например, если у вас есть файл с именем HEAD в вашем рабочем дереве, &lt;code&gt;git diff HEAD&lt;/code&gt; неоднозначен, и вы должны сказать либо &lt;code&gt;git diff HEAD --&lt;/code&gt; либо &lt;code&gt;git diff -- HEAD&lt;/code&gt; чтобы устранить неоднозначность.</target>
        </trans-unit>
        <trans-unit id="636ef8b24660180a9f9d02cde9f707a809036029" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Без опции &lt;code&gt;-z&lt;/code&gt; пути с &amp;laquo;необычными&amp;raquo; символами заключаются в кавычки, как описано для переменной конфигурации &lt;code&gt;core.quotePath&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fbf6695514712c3a8e39b514953f35111f6c3ca8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Using &lt;code&gt;-z&lt;/code&gt; the filename is output verbatim and the line is terminated by a NUL byte.</source>
          <target state="translated">Без опции &lt;code&gt;-z&lt;/code&gt; пути с &amp;laquo;необычными&amp;raquo; символами заключаются в кавычки, как описано для переменной конфигурации &lt;code&gt;core.quotePath&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ). При использовании &lt;code&gt;-z&lt;/code&gt; имя файла выводится дословно, а строка заканчивается байтом NUL.</target>
        </trans-unit>
        <trans-unit id="94da29d7f90d6f6f16856adba693bd0f5ed5aeb9" translate="yes" xml:space="preserve">
          <source>Without the &lt;em&gt;--more=1&lt;/em&gt; option, &lt;em&gt;git show-branch&lt;/em&gt; would not output the &lt;em&gt;[master^]&lt;/em&gt; commit, as &lt;em&gt;[mybranch]&lt;/em&gt; commit is a common ancestor of both &lt;em&gt;master&lt;/em&gt; and &lt;em&gt;mybranch&lt;/em&gt; tips. Please see &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">Без &lt;em&gt;--Больше = 1&lt;/em&gt; вариант, &lt;em&gt;мерзавец шоу-отрасль&lt;/em&gt; не будет выводить &lt;em&gt;[мастер ^]&lt;/em&gt; совершить, так как &lt;em&gt;[mybranch]&lt;/em&gt; совершить является общим предком как &lt;em&gt;мастеров&lt;/em&gt; и &lt;em&gt;mybranch&lt;/em&gt; советов. Подробности см. В &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c29d8269d6df0a76bd7b7031ef1a5a35a844def8" translate="yes" xml:space="preserve">
          <source>Without this flag, &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that &quot;&amp;lt;path&amp;gt;&amp;hellip;​&quot; limits only commits, and doesn&amp;rsquo;t limit diff for those commits.</source>
          <target state="translated">Без этого флага &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; показывает коммиты, которые касаются указанных путей, и сравнивает примерно те же указанные пути. При этом отображается полная разница для коммитов, которые касаются указанных путей; это означает, что &amp;laquo;&amp;lt;path&amp;gt;&amp;hellip;&amp;raquo; ограничивает только коммиты и не ограничивает diff для этих коммитов.</target>
        </trans-unit>
        <trans-unit id="b86cf57585935f6e60cc9059e45208393d99c9a8" translate="yes" xml:space="preserve">
          <source>Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Без этой опции пути с &amp;laquo;необычными&amp;raquo; символами заключаются в кавычки, как описано для переменной конфигурации &lt;code&gt;core.quotePath&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8450aafea5471fb336aa6711b707fb955fd65d91" translate="yes" xml:space="preserve">
          <source>Workflow for a third party library</source>
          <target state="translated">Рабочий процесс для сторонней библиотеки</target>
        </trans-unit>
        <trans-unit id="8dfb0e4b50fd82c5ff8bc5fed81147f5e4aadb05" translate="yes" xml:space="preserve">
          <source>Workflow for an artificially split repo</source>
          <target state="translated">Рабочий процесс для искусственно разделенного репо</target>
        </trans-unit>
        <trans-unit id="825ce9e97dc41179ec167b83be91179b5dacd316" translate="yes" xml:space="preserve">
          <source>Workflows</source>
          <target state="translated">Workflows</target>
        </trans-unit>
        <trans-unit id="72b02433b5041ac5ef6045242ff8d0e2784944a3" translate="yes" xml:space="preserve">
          <source>Working branch; defaults to HEAD.</source>
          <target state="translated">Рабочее отделение;по умолчанию-HEAD.</target>
        </trans-unit>
        <trans-unit id="a2b68acce45b31c1701e61880a9ac430bd217ef5" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file for the main working directory in multiple working directory setup (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;).</source>
          <target state="translated">Специальный файл конфигурации рабочего каталога для основного рабочего каталога при настройке нескольких рабочих каталогов (см. &lt;a href=&quot;git-worktree&quot;&gt;Git-worktree [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29f32a47a3074cae8d2558abdc45a4c7a3f4de27" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file.</source>
          <target state="translated">Конфигурационный файл для конкретной рабочей директории.</target>
        </trans-unit>
        <trans-unit id="b7010e71f35d363293e1c71cea9eb7b673f227d7" translate="yes" xml:space="preserve">
          <source>Working trees can be identified by path, either relative or absolute.</source>
          <target state="translated">Рабочие деревья могут быть идентифицированы по пути,относительному или абсолютному.</target>
        </trans-unit>
        <trans-unit id="e5850a4e043e763eb3c70b51337df764ed12f013" translate="yes" xml:space="preserve">
          <source>Working with others</source>
          <target state="translated">Работать с другими</target>
        </trans-unit>
        <trans-unit id="883363a342498bf776fadbacf0d9322246ddce5d" translate="yes" xml:space="preserve">
          <source>Working with others, shared repository style</source>
          <target state="translated">Работа с другими,общий стиль репозитория</target>
        </trans-unit>
        <trans-unit id="62159bf12f9108d11431e1d1114bdbbeecf78451" translate="yes" xml:space="preserve">
          <source>Works just like --signature except the signature is read from a file.</source>
          <target state="translated">Работает так же,как и --подпись,за исключением того,что подпись считывается из файла.</target>
        </trans-unit>
        <trans-unit id="097006f59137099e2d2ccff414198fea83903044" translate="yes" xml:space="preserve">
          <source>Works just like format.signature except the contents of the file specified by this variable will be used as the signature.</source>
          <target state="translated">В качестве сигнатуры будет использовано содержимое файла,указанного этой переменной.</target>
        </trans-unit>
        <trans-unit id="c45647582ec4fc92bdcd3ecd1a16e9638ca339a8" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt;, where &amp;lt;remote&amp;gt; is the current branch&amp;rsquo;s remote (or &lt;code&gt;origin&lt;/code&gt;, if no remote is configured for the current branch).</source>
          <target state="translated">Работает аналогично &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt; , где &amp;lt;remote&amp;gt; - это удаленный узел текущей ветки (или &lt;code&gt;origin&lt;/code&gt; , если для текущей ветки не настроен пульт).</target>
        </trans-unit>
        <trans-unit id="96f0b3b7db8530493b30466426fa80c5c21f66c1" translate="yes" xml:space="preserve">
          <source>Wrap code spawning child processes.</source>
          <target state="translated">Обертывание кода икрометание детских процессов.</target>
        </trans-unit>
        <trans-unit id="1f9c72af7bca7c9666626fcb471d6065e154c93d" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in an alternate object store.</source>
          <target state="translated">Запишите MIDX-файл для пакетных файлов в альтернативное объектное хранилище.</target>
        </trans-unit>
        <trans-unit id="36b48ab2e331354b7c3cc2f14ff9d8ea9d1001c3" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">Запишите MIDX-файл для пакетных файлов в текущей папке .git.</target>
        </trans-unit>
        <trans-unit id="b42a0c66496716fcd8c88f5906d20e5cf08f4975" translate="yes" xml:space="preserve">
          <source>Write a chapter on using plumbing and writing scripts.</source>
          <target state="translated">Напишите главу об использовании сантехники и написании сценариев.</target>
        </trans-unit>
        <trans-unit id="c8e128b9f546fd58c7e614d0f8b8821821084ae1" translate="yes" xml:space="preserve">
          <source>Write a commit-graph after fetching. This overrides the config setting &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt;.</source>
          <target state="translated">Напишите график фиксации после получения. Это отменяет настройку конфигурации &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e518a1279678087b263b8a6d5d4572c2e8b9dd3b" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles.</source>
          <target state="translated">Напишите графический файл коммита на основе коммитов,найденных в пакетных файлах.</target>
        </trans-unit>
        <trans-unit id="31a24952f6ac97438fc3f890b7eeabaf5006955a" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles. If the config option &lt;code&gt;core.commitGraph&lt;/code&gt; is disabled, then this command will output a warning, then return success without writing a commit-graph file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a7e9f2485bf10bd9980490fdf55b0594e99b5f" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all commits in the current commit-graph file along with those reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Напишите файл графика фиксации, содержащий все фиксации в текущем файле графика фиксации, а также те, которые доступны из &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c34e4cbacab76dc7a95f5e0f46081aab1f59603" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all reachable commits.</source>
          <target state="translated">Написать графический файл с коммитами,содержащий все доступные коммиты.</target>
        </trans-unit>
        <trans-unit id="e1238f6b25cc5d29bebfcc60e794e1647b6dd786" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file for the packed commits in your local &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">Напишите файл графика фиксации для упакованных коммитов в локальном каталоге &lt;code&gt;.git&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ba716e808cc8cf569e10d2453e1761bc59eae40" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file, extending the current commit-graph file using commits in &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Напишите файл графика фиксации, расширяя текущий файл графика фиксации, используя фиксации в &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c3a355bd823c82bb9b3a929df0d2e920a5e648" translate="yes" xml:space="preserve">
          <source>Write a new MIDX file.</source>
          <target state="translated">Запишите новый MIDX-файл.</target>
        </trans-unit>
        <trans-unit id="b0d7b6d61dd4b6501290a029b72f9ed15f8cc305" translate="yes" xml:space="preserve">
          <source>Write a reachability bitmap index as part of the repack. This only makes sense when used with &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-A&lt;/code&gt;, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of &lt;code&gt;repack.writeBitmaps&lt;/code&gt;. This option has no effect if multiple packfiles are created.</source>
          <target state="translated">Напишите индекс растрового изображения достижимости как часть переупаковки. Это имеет смысл только при использовании с &lt;code&gt;-a&lt;/code&gt; или &lt;code&gt;-A&lt;/code&gt; , поскольку точечные рисунки должны иметь возможность ссылаться на все достижимые объекты. Эта опция отменяет установку &lt;code&gt;repack.writeBitmaps&lt;/code&gt; . Этот параметр не действует, если создано несколько файлов пакетов.</target>
        </trans-unit>
        <trans-unit id="0ec591cf31eda36450bc843a926c4fd529f9a0da" translate="yes" xml:space="preserve">
          <source>Write a set of patterns to the sparse-checkout file, as given as a list of arguments following the &lt;code&gt;set&lt;/code&gt; subcommand. Update the working directory to match the new patterns. Enable the core.sparseCheckout config setting if it is not already enabled.</source>
          <target state="translated">Запишите набор шаблонов в файл sparse-checkout в виде списка аргументов, следующих за подкомандой &lt;code&gt;set&lt;/code&gt; . Обновите рабочий каталог, чтобы он соответствовал новым шаблонам. Включите параметр конфигурации core.sparseCheckout, если он еще не включен.</target>
        </trans-unit>
        <trans-unit id="041470620f3506e6e154d55da89dd48b2bba6ec8" translate="yes" xml:space="preserve">
          <source>Write and verify Git commit-graph files</source>
          <target state="translated">Запись и проверка файлов коммит-графика Git'а.</target>
        </trans-unit>
        <trans-unit id="fbde21d9f61e2faa3e597fb0c951212436d2d05f" translate="yes" xml:space="preserve">
          <source>Write and verify multi-pack-indexes</source>
          <target state="translated">Пишите и проверяйте мульти-пакеты-индексы</target>
        </trans-unit>
        <trans-unit id="0874d3d36a3af067f281de19e268427b067828a4" translate="yes" xml:space="preserve">
          <source>Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type. If the object is a blob, the contents are written into the file, rather than its object name.</source>
          <target state="translated">Запишите висячие объекты в .git/lost-found/commit/или .git/lost-found/other/,в зависимости от типа.Если объект является блобом,то в файл записывается его содержимое,а не имя объекта.</target>
        </trans-unit>
        <trans-unit id="d9accbc71f1215e3614372f554930a021fe71b0a" translate="yes" xml:space="preserve">
          <source>Write into pairs of files (.pack and .idx), using &amp;lt;base-name&amp;gt; to determine the name of the created file. When this option is used, the two files in a pair are written in &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;.{pack,idx} files. &amp;lt;SHA-1&amp;gt; is a hash based on the pack content and is written to the standard output of the command.</source>
          <target state="translated">Запишите в пары файлов (.pack и .idx), используя &amp;lt;base-name&amp;gt; для определения имени созданного файла. Когда используется эта опция, два файла в паре записываются в файлы &amp;lt;base-name&amp;gt; - &amp;lt;SHA-1&amp;gt;. {Pack, idx}. &amp;lt;SHA-1&amp;gt; - это хэш, основанный на содержимом пакета, который записывается в стандартный вывод команды.</target>
        </trans-unit>
        <trans-unit id="7fe0c30065baa84a0511c3d3081d91c7d606dfea" translate="yes" xml:space="preserve">
          <source>Write or verify a multi-pack-index (MIDX) file.</source>
          <target state="translated">Запись или верификация мультипак-индексного (MIDX)файла.</target>
        </trans-unit>
        <trans-unit id="e39d29fa27aa3fd795b76126771a3ffa6c08d16a" translate="yes" xml:space="preserve">
          <source>Write responses to &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, and &lt;code&gt;ls&lt;/code&gt; queries to the file descriptor &amp;lt;fd&amp;gt; instead of &lt;code&gt;stdout&lt;/code&gt;. Allows &lt;code&gt;progress&lt;/code&gt; output intended for the end-user to be separated from other output.</source>
          <target state="translated">Записывать ответы на запросы &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; и &lt;code&gt;ls&lt;/code&gt; в файловый дескриптор &amp;lt;fd&amp;gt; вместо &lt;code&gt;stdout&lt;/code&gt; . Позволяет отделить вывод о &lt;code&gt;progress&lt;/code&gt; предназначенный для конечного пользователя, от другого вывода.</target>
        </trans-unit>
        <trans-unit id="e189db14fd9c8dacb74b437fa25a566d7b39760b" translate="yes" xml:space="preserve">
          <source>Write the archive to &amp;lt;file&amp;gt; instead of stdout.</source>
          <target state="translated">Записывайте архив в &amp;lt;файл&amp;gt; вместо стандартного вывода.</target>
        </trans-unit>
        <trans-unit id="7dc7fd5fc893589e612150dc5a94bc95c63f6644" translate="yes" xml:space="preserve">
          <source>Write the generated pack index into the specified file. Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack).</source>
          <target state="translated">Запишите сгенерированный индекс пакета в указанный файл.Без этой опции имя файла индекса пакета строится из имени упакованного архивного файла путем замены .pack на .idx (и программа дает сбой,если имя упакованного архива не заканчивается на .pack).</target>
        </trans-unit>
        <trans-unit id="898b44ae7851f33ec7de0339d5f319ea640d48c2" translate="yes" xml:space="preserve">
          <source>Write the list of remote refs fetched in the &lt;code&gt;FETCH_HEAD&lt;/code&gt; file directly under &lt;code&gt;$GIT_DIR&lt;/code&gt;. This is the default. Passing &lt;code&gt;--no-write-fetch-head&lt;/code&gt; from the command line tells Git not to write the file. Under &lt;code&gt;--dry-run&lt;/code&gt; option, the file is never written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee51e3bc5f984d1828334228be7ce34fc987d1e" translate="yes" xml:space="preserve">
          <source>Write the pack contents (what would have been written to .pack file) out to the standard output.</source>
          <target state="translated">Запишите содержимое пакета (то,что было бы записано в файл .pack)в стандартный выходной файл.</target>
        </trans-unit>
        <trans-unit id="f8fab17bc8f3e5385c26a96bd869170c9b748651" translate="yes" xml:space="preserve">
          <source>Write the resulting index out in the named on-disk format version. Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as &lt;code&gt;git add -N&lt;/code&gt;.</source>
          <target state="translated">Запишите получившийся индекс в названной версии формата на диске. Поддерживаются версии 2, 3 и 4. Текущая версия по умолчанию - 2 или 3, в зависимости от того, используются ли дополнительные функции, такие как &lt;code&gt;git add -N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efedecbf7e9a176a45aaee6d10ad017d653ffad6" translate="yes" xml:space="preserve">
          <source>Write to standard error. Note that if &lt;code&gt;--detach&lt;/code&gt; is specified, the process disconnects from the real standard error, making this destination effectively equivalent to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">Пишите в стандартную ошибку. Обратите внимание, что если &lt;code&gt;--detach&lt;/code&gt; , процесс отключается от реальной стандартной ошибки, что делает этот пункт назначения эквивалентным &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04570d31869f8fe0ff9437709cb2be3000b6efb7" translate="yes" xml:space="preserve">
          <source>Write to syslog, using the &lt;code&gt;git-daemon&lt;/code&gt; identifier.</source>
          <target state="translated">Запишите в системный журнал, используя идентификатор &lt;code&gt;git-daemon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b06c59a883065a2aa7a048f19cdd388e420a56a1" translate="yes" xml:space="preserve">
          <source>Write whatever message you want, and all the lines that start with &lt;code&gt;#&lt;/code&gt; will be pruned out, and the rest will be used as the commit message for the change. If you decide you don&amp;rsquo;t want to commit anything after all at this point (you can continue to edit things and update the index), you can just leave an empty message. Otherwise &lt;code&gt;git commit&lt;/code&gt; will commit the change for you.</source>
          <target state="translated">Напишите любое сообщение, которое хотите, и все строки, начинающиеся с символа &lt;code&gt;#&lt;/code&gt; , будут удалены, а остальные будут использоваться в качестве сообщения фиксации для изменения. Если вы решите, что не хотите ничего фиксировать на этом этапе (вы можете продолжать редактировать данные и обновлять индекс), вы можете просто оставить пустое сообщение. В противном случае &lt;code&gt;git commit&lt;/code&gt; зафиксирует изменение за вас.</target>
        </trans-unit>
        <trans-unit id="61b122f3a92e6ba319a161e3ee36a5061ca2ea4c" translate="yes" xml:space="preserve">
          <source>Writes a tree object that represents a subdirectory &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. This can be used to write the tree object for a subproject that is in the named subdirectory.</source>
          <target state="translated">Записывает объект дерева, представляющий подкаталог &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; . Это можно использовать для записи объекта дерева для подпроекта, который находится в названном подкаталоге.</target>
        </trans-unit>
        <trans-unit id="157114a94f76dd225b6968a998012309617b01fe" translate="yes" xml:space="preserve">
          <source>Writes the commit-id into the filename under $GIT_DIR/refs/&amp;lt;filename&amp;gt; on the local end after the transfer is complete.</source>
          <target state="translated">Записывает идентификатор фиксации в имя файла в $ GIT_DIR / refs / &amp;lt;filename&amp;gt; на локальном конце после завершения передачи.</target>
        </trans-unit>
        <trans-unit id="e02c77bcdadadb66d0f7703e015b6bcd89a6c5e3" translate="yes" xml:space="preserve">
          <source>X: &quot;unknown&quot; change type (most probably a bug, please report it)</source>
          <target state="translated">X:&quot;неизвестный&quot; тип изменения (скорее всего,ошибка,пожалуйста,сообщите об этом).</target>
        </trans-unit>
        <trans-unit id="c4701ab33311f5af4d25d032b9d36f7ee2d229e7" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;must&lt;/code&gt; therefore ensure that the most recent commit of the branch you want to dcommit to is the &lt;code&gt;first&lt;/code&gt; parent of the merge. Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch.</source>
          <target state="translated">Следовательно, вы &lt;code&gt;must&lt;/code&gt; убедиться, что самая последняя фиксация ветки, которую вы хотите зафиксировать, является &lt;code&gt;first&lt;/code&gt; родительским элементом слияния. В противном случае произойдет хаос, особенно если первый родительский коммит является более старым коммитом в той же ветке SVN.</target>
        </trans-unit>
        <trans-unit id="33b03e34a8212275c562b3fd47359312e9fb9f26" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">Вы также можете сказать &lt;code&gt;c&lt;/code&gt; или &lt;code&gt;clean&lt;/code&gt; выше, если выбор уникален.</target>
        </trans-unit>
        <trans-unit id="3633df0f340d7a5b00e10a65751fa4510ce91fa7" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;sta&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">Можно также сказать , &lt;code&gt;s&lt;/code&gt; или &lt;code&gt;sta&lt;/code&gt; или &lt;code&gt;status&lt;/code&gt; выше, пока выбор уникален.</target>
        </trans-unit>
        <trans-unit id="80dcbb43282a1e399b57f0acd29e7d516598c299" translate="yes" xml:space="preserve">
          <source>You also need to ensure that each repository is &quot;bare&quot; (without a Git index file) for &lt;code&gt;cvs commit&lt;/code&gt; to work. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Вам также необходимо убедиться, что каждый репозиторий является &amp;laquo;пустым&amp;raquo; (без индексного файла Git), чтобы &lt;code&gt;cvs commit&lt;/code&gt; работал. См. &lt;a href=&quot;gitcvs-migration&quot;&gt;Gitcvs-migration [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63d1d5a88c78a80cfc3950acb2e452ff58df3b69" translate="yes" xml:space="preserve">
          <source>You also should not rewind branches in a submodule beyond commits that were ever recorded in any superproject.</source>
          <target state="translated">Также не следует перематывать ветки в подмодуле за пределами коммитов,которые когда-либо были записаны в каком-либо суперпроекте.</target>
        </trans-unit>
        <trans-unit id="9cb8652293d991a8fc334c9f946fb5900f566815" translate="yes" xml:space="preserve">
          <source>You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run &lt;code&gt;git diff&lt;/code&gt;, because you plan to work on other files and changes with these files are distracting.</source>
          <target state="translated">Вы с удовольствием над чем-то работаете и обнаруживаете, что изменения в этих файлах в порядке. Вы не хотите видеть их при запуске &lt;code&gt;git diff&lt;/code&gt; , потому что вы планируете работать с другими файлами, а изменения в этих файлах отвлекают.</target>
        </trans-unit>
        <trans-unit id="48f9e78ec61620aadfc7c1e71bab372f08845a6f" translate="yes" xml:space="preserve">
          <source>You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don&amp;rsquo;t want to risk disturbing any of it. Instead, you create a temporary linked working tree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.</source>
          <target state="translated">Вы находитесь в середине сеанса рефакторинга, и ваш босс приходит и требует, чтобы вы немедленно что-то исправили. Обычно вы можете использовать &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; для временного хранения ваших изменений, однако ваше рабочее дерево находится в таком беспорядочном состоянии (с новыми, перемещенными и удаленными файлами и другими частями разбросаны вокруг), что вы не делаете Я не хочу рисковать, чтобы что-то нарушить. Вместо этого вы создаете временное связанное рабочее дерево, чтобы внести аварийное исправление, удалить его, когда закончите, а затем возобновить предыдущий сеанс рефакторинга.</target>
        </trans-unit>
        <trans-unit id="bb2df2ca18755cbd46a4ed871293669f22530506" translate="yes" xml:space="preserve">
          <source>You are now ready to commit. You can see what is about to be committed using &lt;code&gt;git diff&lt;/code&gt; with the --cached option:</source>
          <target state="translated">Теперь вы готовы к совершению. Вы можете увидеть, что будет совершено, используя &lt;code&gt;git diff&lt;/code&gt; с параметром --cached:</target>
        </trans-unit>
        <trans-unit id="074e56336e1be0630703b280d6a3b60899f28a4c" translate="yes" xml:space="preserve">
          <source>You can adjust how pages generated by gitweb look using the variables described below. You can change the site name, add common headers and footers for all pages, and add a description of this gitweb installation on its main page (which is the projects list page), etc.</source>
          <target state="translated">Вы можете настроить внешний вид страниц,генерируемых gitweb,используя переменные,описанные ниже.Вы можете изменить название сайта,добавить общие заголовки и колонтитулы для всех страниц,а также добавить описание этой gitweb-инсталляции на его главной странице (это страница со списком проектов)и т.д.</target>
        </trans-unit>
        <trans-unit id="f5130cbe18f25cdc12700266fadc1f554b9c37ce" translate="yes" xml:space="preserve">
          <source>You can also ask git log to show patches:</source>
          <target state="translated">Вы также можете попросить git-журнал показать патчи:</target>
        </trans-unit>
        <trans-unit id="f5378640dc8884e7695fa8d24ebc61aad94be600" translate="yes" xml:space="preserve">
          <source>You can also check out &lt;code&gt;origin/todo&lt;/code&gt; directly to examine it or write a one-off patch. See &lt;a href=&quot;#detached-head&quot;&gt;detached head&lt;/a&gt;.</source>
          <target state="translated">Вы также можете проверить &lt;code&gt;origin/todo&lt;/code&gt; напрямую, чтобы изучить его или написать одноразовый патч. Увидеть &lt;a href=&quot;#detached-head&quot;&gt;оторванную голову&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7520d8990c9fc0c63fb723451f5a4b04ab5ce6bc" translate="yes" xml:space="preserve">
          <source>You can also control this behavior with the &lt;code&gt;core.whitespace&lt;/code&gt; setting if you don&amp;rsquo;t wish to remove the carriage returns from your line endings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dba829f7b6e6b2354184e851e59ecadab491f50" translate="yes" xml:space="preserve">
          <source>You can also edit a patch series with an interactive rebase. This is the same as &lt;a href=&quot;#reordering-patch-series&quot;&gt;reordering a patch series using &lt;code&gt;format-patch&lt;/code&gt;&lt;/a&gt;, so use whichever interface you like best.</source>
          <target state="translated">Вы также можете редактировать серию патчей с помощью интерактивной перебазировки. Это то же самое, что &lt;a href=&quot;#reordering-patch-series&quot;&gt;переупорядочить серию патчей с помощью &lt;code&gt;format-patch&lt;/code&gt; &lt;/a&gt; , поэтому используйте тот интерфейс, который вам больше нравится.</target>
        </trans-unit>
        <trans-unit id="a56f9e1e04034dbb228cdfc1e0cb38c07a8bcbf1" translate="yes" xml:space="preserve">
          <source>You can also fetch branches from other repositories; so</source>
          <target state="translated">Вы также можете получать ветки из других репозиториев;поэтому</target>
        </trans-unit>
        <trans-unit id="bb4e25e283a061b1bebe5a9dd36fbbd03f0e1b4b" translate="yes" xml:space="preserve">
          <source>You can also give &lt;code&gt;git log&lt;/code&gt; a &quot;range&quot; of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches &quot;stable&quot; and &quot;master&quot; diverged from a common commit some time ago, then</source>
          <target state="translated">Вы также можете &lt;code&gt;git log&lt;/code&gt; &amp;laquo;диапазон&amp;raquo; коммитов, первый из которых не обязательно является предком второго; например, если некоторое время назад концы веток &amp;laquo;стабильный&amp;raquo; и &amp;laquo;мастер&amp;raquo; расходились от общего коммита, то</target>
        </trans-unit>
        <trans-unit id="c219057e4d44e965fab9fe1f77892cd8f09c5753" translate="yes" xml:space="preserve">
          <source>You can also give commits names of your own; after running</source>
          <target state="translated">Вы также можете дать свои собственные имена коммитов;после запуска</target>
        </trans-unit>
        <trans-unit id="ef70822bb0476f59f3e8869ce9a522611ff6cac9" translate="yes" xml:space="preserve">
          <source>You can also just enter your password when prompted. While it is possible to place the password (which must be percent-encoded) in the URL, this is not particularly secure and can lead to accidental exposure of credentials, so it is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecebc054603ae5ff87afcd3e6caec5420b5c866" translate="yes" xml:space="preserve">
          <source>You can also override locations of gitweb configuration files during runtime by setting the following environment variables: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; to a non-empty value.</source>
          <target state="translated">Вы также можете переопределить расположение файлов конфигурации gitweb во время выполнения, установив следующие переменные среды: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; и &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; на непустое значение.</target>
        </trans-unit>
        <trans-unit id="c335f539c67224e67ef9ba8bcb55a78f32c2ba64" translate="yes" xml:space="preserve">
          <source>You can also revert an earlier change, for example, the next-to-last:</source>
          <target state="translated">Вы также можете вернуть более раннее изменение,например,следующее за последним:</target>
        </trans-unit>
        <trans-unit id="f6f0f4e5da7f74f3d7e6aefa5597ca88126ce358" translate="yes" xml:space="preserve">
          <source>You can also run &lt;code&gt;git daemon&lt;/code&gt; as an inetd service; see the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; man page for details. (See especially the examples section.)</source>
          <target state="translated">Вы также можете запустить &lt;code&gt;git daemon&lt;/code&gt; как службу inetd; подробности смотрите на странице руководства &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; . (См. Особенно раздел примеров.)</target>
        </trans-unit>
        <trans-unit id="f0a51538febea0717277859dfbb5418b689055cc" translate="yes" xml:space="preserve">
          <source>You can also see what references it offers:</source>
          <target state="translated">Вы также можете посмотреть,какие ссылки он предлагает:</target>
        </trans-unit>
        <trans-unit id="f06fdd5b89ee465ae510128ba09f10dd8adf5eac" translate="yes" xml:space="preserve">
          <source>You can also skip a range of commits, instead of just one commit, using range notation. For example:</source>
          <target state="translated">Вы также можете пропустить ряд коммитов,вместо одного,используя нотацию диапазона.Например:</target>
        </trans-unit>
        <trans-unit id="54e517ee1d2086de2439776d35ac41cdff2f30f7" translate="yes" xml:space="preserve">
          <source>You can also track branches from repositories other than the one you cloned from, using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;:</source>
          <target state="translated">Вы также можете отслеживать ветки из репозиториев, отличных от того, из которого вы клонировали, используя &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="28b63a93050077dfe73e5bbbcd2b4df244cc4f26" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; to create commits, view changes in the index and the working tree files, and individually select diff hunks for inclusion in the index (by right-clicking on the diff hunk and choosing &quot;Stage Hunk For Commit&quot;).</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; для создания коммитов, просмотра изменений в индексе и файлах рабочего дерева, а также индивидуального выбора блоков различий для включения в индекс (щелкнув правой кнопкой мыши блок различий и выбрав &amp;laquo;Stage Hunk For Commit &quot;).</target>
        </trans-unit>
        <trans-unit id="2d89b19204028ed2768f0a7d6951c7af3234e547" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; для создания патчей для A, B и C, а идентификаторы для P, X, Y, Z добавляются в конце первого сообщения.</target>
        </trans-unit>
        <trans-unit id="2c144befb1f45c546071ce64e48b303dc0e810a7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git show&lt;/code&gt; to see any such file:</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;git show&lt;/code&gt; , чтобы увидеть любой такой файл:</target>
        </trans-unit>
        <trans-unit id="49c3eff4b4dfbb20ea17f1bea994d4ab08b8a178" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; instead of &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; if you don&amp;rsquo;t wish to keep commits with a single parent and that makes no change to the tree.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; вместо &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; если вы не хотите сохранять коммиты с единственным родителем и это не меняет дерево.</target>
        </trans-unit>
        <trans-unit id="015df615c0d1b650e7dd0d33e1d03af134ab36e3" translate="yes" xml:space="preserve">
          <source>You can always just jump back to your original &lt;code&gt;master&lt;/code&gt; branch by doing</source>
          <target state="translated">Вы всегда можете просто вернуться к исходной &lt;code&gt;master&lt;/code&gt; ветке, выполнив</target>
        </trans-unit>
        <trans-unit id="e3173f9b04378ce969d4435b57687de248be9e7d" translate="yes" xml:space="preserve">
          <source>You can always view an old version of a file by just checking out the correct revision first. But sometimes it is more convenient to be able to view an old version of a single file without checking anything out; this command does that:</source>
          <target state="translated">Вы всегда можете просмотреть старую версию файла,просто проверив сначала правильную ревизию.Но иногда удобнее иметь возможность просмотреть старую версию одного файла,ничего не извлекая;эта команда делает это:</target>
        </trans-unit>
        <trans-unit id="ac57e48df46d91546d0b6c2ab36f112078813032" translate="yes" xml:space="preserve">
          <source>You can at any time create a new branch by just picking an arbitrary point in the project history, and just writing the SHA-1 name of that object into a file under &lt;code&gt;.git/refs/heads/&lt;/code&gt;. You can use any filename you want (and indeed, subdirectories), but the convention is that the &quot;normal&quot; branch is called &lt;code&gt;master&lt;/code&gt;. That&amp;rsquo;s just a convention, though, and nothing enforces it.</source>
          <target state="translated">Вы можете в любой момент создать новую ветку, просто выбрав произвольную точку в истории проекта и просто записав имя SHA-1 этого объекта в файл в &lt;code&gt;.git/refs/heads/&lt;/code&gt; . Вы можете использовать любое имя файла (и действительно подкаталоги), но по соглашению &quot;нормальная&quot; ветвь называется &lt;code&gt;master&lt;/code&gt; . Однако это всего лишь условность, и ничто не заставляет ее соблюдать.</target>
        </trans-unit>
        <trans-unit id="28fdfbc805da6922683f26cc12f785c6a111b6ce" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;. The URL in this file will be used to access the repository. This file should have the following format:</source>
          <target state="translated">Вы можете &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; имя файла в $ GIT_DIR / branch . URL-адрес в этом файле будет использоваться для доступа к репозиторию. Этот файл должен иметь следующий формат:</target>
        </trans-unit>
        <trans-unit id="184c3e9bbc8e0af36908329654dfda91364d6a99" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:</source>
          <target state="translated">Вы можете &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; имя файла в $ GIT_DIR / remotes . URL-адрес в этом файле будет использоваться для доступа к репозиторию. Refspec в этом файле будет использоваться по умолчанию, если вы не укажете refspec в командной строке. Этот файл должен иметь следующий формат:</target>
        </trans-unit>
        <trans-unit id="a92f2a4a63c6c2d142357d1e5947af0b6de272f3" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a remote which you had previously configured using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or even by a manual edit to the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:</source>
          <target state="translated">Вы можете указать имя пульта дистанционного управления, которое вы ранее настроили с помощью &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; , &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; или даже вручную отредактировав файл &lt;code&gt;$GIT_DIR/config&lt;/code&gt; . URL-адрес этого пульта дистанционного управления будет использоваться для доступа к репозиторию. Refspec этого пульта дистанционного управления будет использоваться по умолчанию, если вы не укажете refspec в командной строке. Запись в конфигурационном файле будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d377d9322805f2d9d1e87d74e556de9916d572ec" translate="yes" xml:space="preserve">
          <source>You can choose whether you want to trust the index file entirely (using the &lt;code&gt;--cached&lt;/code&gt; flag) or ask the diff logic to show any files that don&amp;rsquo;t match the stat state as being &quot;tentatively changed&quot;. Both of these operations are very useful indeed.</source>
          <target state="translated">Вы можете выбрать, хотите ли вы полностью доверять индексному файлу (используя флаг &lt;code&gt;--cached&lt;/code&gt; ) или попросить логику сравнения отображать любые файлы, которые не соответствуют состоянию статистики, как &amp;laquo;предварительно измененные&amp;raquo;. Обе эти операции действительно очень полезны.</target>
        </trans-unit>
        <trans-unit id="7c0716128ee4fbd827cb316e0652131c44810ab6" translate="yes" xml:space="preserve">
          <source>You can configure gitweb to only list and allow viewing of the explicitly exported repositories, via &lt;code&gt;$export_ok&lt;/code&gt; variable in gitweb config file; see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; manpage. If it evaluates to true, gitweb shows repositories only if this file named by &lt;code&gt;$export_ok&lt;/code&gt; exists in its object database (if directory has the magic file named &lt;code&gt;$export_ok&lt;/code&gt;).</source>
          <target state="translated">Вы можете настроить gitweb так, чтобы он отображал только список и разрешал просмотр явно экспортированных репозиториев с помощью переменной &lt;code&gt;$export_ok&lt;/code&gt; export_ok в файле конфигурации gitweb; см. &lt;a href=&quot;gitweb.conf&quot;&gt;справочную страницу gitweb.conf [5]&lt;/a&gt; . Если он имеет значение true, gitweb показывает репозитории только в том случае, если этот файл с именем &lt;code&gt;$export_ok&lt;/code&gt; существует в его базе данных объектов (если в каталоге есть волшебный файл с именем &lt;code&gt;$export_ok&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="03a65df391294815ab470e62357c9e62de1fcfb2" translate="yes" xml:space="preserve">
          <source>You can configure individual repositories shown in gitweb by creating file in the &lt;code&gt;GIT_DIR&lt;/code&gt; of Git repository, or by setting some repo configuration variable (in &lt;code&gt;GIT_DIR/config&lt;/code&gt;, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Вы можете настроить отдельные репозитории, отображаемые в gitweb, создав файл в &lt;code&gt;GIT_DIR&lt;/code&gt; репозитория Git или установив некоторую переменную конфигурации репозитория (в &lt;code&gt;GIT_DIR/config&lt;/code&gt; , см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="45321feeff0945f0a2ba053e8ab969c82cc417c8" translate="yes" xml:space="preserve">
          <source>You can configure the database backend with the following configuration variables:</source>
          <target state="translated">Бэкэнд БД можно настроить с помощью следующих конфигурационных переменных:</target>
        </trans-unit>
        <trans-unit id="d268b7f609741cf4701b8230b6d95314deb17a7a" translate="yes" xml:space="preserve">
          <source>You can create a new commit that undoes whatever was done by the old commit. This is the correct thing if your mistake has already been made public.</source>
          <target state="translated">Вы можете создать новый коммит,который отменяет все,что было сделано старым коммитом.Это правильная вещь,если ваша ошибка уже была обнародована.</target>
        </trans-unit>
        <trans-unit id="d8a9d4babf707e6fca47541eba4fa0b4e8c8edd2" translate="yes" xml:space="preserve">
          <source>You can customize the rules that &lt;code&gt;git diff --word-diff&lt;/code&gt; uses to split words in a line, by specifying an appropriate regular expression in the &quot;diff.*.wordRegex&quot; configuration variable. For example, in TeX a backslash followed by a sequence of letters forms a command, but several such commands can be run together without intervening whitespace. To separate them, use a regular expression in your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">Вы можете настроить правила, которые &lt;code&gt;git diff --word-diff&lt;/code&gt; использует для разделения слов в строке, указав соответствующее регулярное выражение в переменной конфигурации &quot;diff. *. WordRegex&quot;. Например, в TeX обратная косая черта, за которой следует последовательность букв, образует команду, но несколько таких команд можно запускать вместе, не вставляя пробелов. Чтобы разделить их, используйте регулярное выражение в вашем &lt;code&gt;$GIT_DIR/config&lt;/code&gt; (или файле &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ), например:</target>
        </trans-unit>
        <trans-unit id="38bcfec4c9f80337cd439b12b7afb0a63bb0fcb7" translate="yes" xml:space="preserve">
          <source>You can declare that a filter turns a content that by itself is unusable into a usable content by setting the filter.&amp;lt;driver&amp;gt;.required configuration variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Вы можете объявить, что фильтр превращает контент, который сам по себе непригоден для использования, в полезный, установив для переменной конфигурации filter. &amp;lt;driver&amp;gt; .required значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7aeeb9d27bdf323aad4937a225d2c2d1d7d6f4b" translate="yes" xml:space="preserve">
          <source>You can easily create such a branch with Git using interactive rebase.</source>
          <target state="translated">Вы можете легко создать такую ветку с помощью Git'а,используя интерактивный rebase.</target>
        </trans-unit>
        <trans-unit id="2f7816df4cc860a9cfdb50146ff125e3acb46178" translate="yes" xml:space="preserve">
          <source>You can enforce finer grained permissions using update hooks. See &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Controlling access to branches using update hooks&lt;/a&gt;.</source>
          <target state="translated">Вы можете применить более детализированные разрешения с помощью обработчиков обновлений. См. Раздел &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Управление доступом к веткам с помощью обработчиков обновлений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dca6628a0b53b9b002cd44ea35104ed275c53c21" translate="yes" xml:space="preserve">
          <source>You can examine one of those dangling commits with, for example,</source>
          <target state="translated">Например,вы можете изучить один из этих висячих коммитов,</target>
        </trans-unit>
        <trans-unit id="4807484ba96d5012055b128c8602211fd418a27a" translate="yes" xml:space="preserve">
          <source>You can examine such index state with &lt;code&gt;git ls-files --unmerged&lt;/code&gt; command. An example:</source>
          <target state="translated">Вы можете проверить такое состояние индекса с помощью команды &lt;code&gt;git ls-files --unmerged&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="b5f066a300ab7fb920ca504e5ef4559d46dabfb5" translate="yes" xml:space="preserve">
          <source>You can examine the data represented in the object database and the index with various helper tools. For every object, you can use &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; to examine details about the object:</source>
          <target state="translated">Вы можете изучить данные, представленные в базе данных объектов и индексе, с помощью различных вспомогательных инструментов. Для каждого объекта вы можете использовать &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1],&lt;/a&gt; чтобы изучить детали об объекте:</target>
        </trans-unit>
        <trans-unit id="fd093df539bb25e8d4c6b75d7c53e29317d7deb5" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;difftool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git difftool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">Вы можете явно &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; полный путь к инструменту, установив конфигурационную переменную difftool. &amp;lt;tool&amp;gt; .path . Например, вы можете настроить абсолютный путь к kdiff3, установив &lt;code&gt;difftool.kdiff3.path&lt;/code&gt; . В противном случае &lt;code&gt;git difftool&lt;/code&gt; предполагает, что инструмент доступен в PATH.</target>
        </trans-unit>
        <trans-unit id="146074b490cdd862abeb41d866c18f9aaa225cf8" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">Вы можете явно &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; полный путь к инструменту, установив переменную конфигурации mergetool. &amp;lt;tool&amp;gt; .path . Например, вы можете настроить абсолютный путь к kdiff3, установив &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt; . В противном случае &lt;code&gt;git mergetool&lt;/code&gt; предполагает, что инструмент доступен в PATH.</target>
        </trans-unit>
        <trans-unit id="77cbe572067fa57bc4362002e12fc6b7b8a04482" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred browser by setting the configuration variable &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to firefox by setting &lt;code&gt;browser.firefox.path&lt;/code&gt;. Otherwise, &lt;code&gt;git web--browse&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d73514fe413b4199a0b5fc2096f965b3e1620ee" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred man viewer by setting the configuration variable &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to konqueror by setting &lt;code&gt;man.konqueror.path&lt;/code&gt;. Otherwise, &lt;code&gt;git help&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">Вы можете явно &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt; полный путь к предпочитаемой вами программе просмотра man, установив конфигурационную переменную man. &amp;lt;tool&amp;gt; .path . Например, вы можете настроить абсолютный путь к konqueror, установив &lt;code&gt;man.konqueror.path&lt;/code&gt; . В противном случае &lt;code&gt;git help&lt;/code&gt; предполагает, что инструмент доступен в PATH.</target>
        </trans-unit>
        <trans-unit id="11d166169fafafa437c100a2b764012cf5981ced" translate="yes" xml:space="preserve">
          <source>You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don&amp;rsquo;t pass you can use &quot;git bisect&quot; (or better &quot;git bisect run&quot;). So you should perform roughly:</source>
          <target state="translated">Вы можете сосредоточить свои усилия на нескольких точках проверки (например, выпусках RC и бета-версии), что все тестовые примеры T проходят для всех N конфигураций. А когда некоторые тесты не проходят, вы можете использовать &amp;laquo;git bisect&amp;raquo; (или лучше &amp;laquo;git bisect run&amp;raquo;). Итак, вам следует примерно выполнить:</target>
        </trans-unit>
        <trans-unit id="59d0d873078b4f91b40c2ee1e2770f185d430915" translate="yes" xml:space="preserve">
          <source>You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">Вы можете дополнительно сократить количество испытаний, если знаете, какая часть дерева вовлечена в проблему, которую вы отслеживаете, указав параметры пути при выполнении команды &lt;code&gt;bisect start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e5857d2949fb11d516cd50de71765499d023b3f6" translate="yes" xml:space="preserve">
          <source>You can generate diffs between any two versions using &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;:</source>
          <target state="translated">Вы можете генерировать различия между любыми двумя версиями, используя &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="98e4a2c67e91124741c5ae666b50315da705ecdc" translate="yes" xml:space="preserve">
          <source>You can generate the projects list index file using the project_index action (the &lt;code&gt;TXT&lt;/code&gt; link on projects list page) directly from gitweb; see also &quot;Generating projects list using gitweb&quot; section below.</source>
          <target state="translated">Вы можете сгенерировать индексный файл списка проектов с помощью действия project_index ( ссылка &lt;code&gt;TXT&lt;/code&gt; на странице списка проектов) непосредственно из gitweb; см. также раздел &amp;laquo;Создание списка проектов с помощью gitweb&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="5b042e446e3f9ebd4b31fc02aac55f5c329ead7e" translate="yes" xml:space="preserve">
          <source>You can get a list of all available encodings on your platform with the following command:</source>
          <target state="translated">Вы можете получить список всех доступных кодировок на вашей платформе с помощью следующей команды:</target>
        </trans-unit>
        <trans-unit id="3d921181a0df868b1892f0a3e234a9c29e516883" translate="yes" xml:space="preserve">
          <source>You can get just the old (respectively new) term with &lt;code&gt;git bisect terms
--term-old&lt;/code&gt; or &lt;code&gt;git bisect terms --term-good&lt;/code&gt;.</source>
          <target state="translated">Вы можете получить только старый (соответственно новый) термин с помощью &lt;code&gt;git bisect terms --term-old&lt;/code&gt; или &lt;code&gt;git bisect terms --term-good&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41b9643f0720517e2c1772471e0c09d5c46b9644" translate="yes" xml:space="preserve">
          <source>You can give the &lt;code&gt;-m&lt;/code&gt; flag to the command, which would try a three-way merge:</source>
          <target state="translated">Вы можете &lt;code&gt;-m&lt;/code&gt; флаг -m команде, которая попытается выполнить трехстороннее слияние:</target>
        </trans-unit>
        <trans-unit id="36617ae8104572554e1e13e9574934aea0623eb3" translate="yes" xml:space="preserve">
          <source>You can go back and modify the old commit. You should never do this if you have already made the history public; Git does not normally expect the &quot;history&quot; of a project to change, and cannot correctly perform repeated merges from a branch that has had its history changed.</source>
          <target state="translated">Вы можете вернуться и изменить старый коммит.Вам никогда не следует этого делать,если вы уже сделали историю публичной;обычно Git не ожидает,что &quot;история&quot; проекта изменится,и не может корректно выполнять повторные слияния из ветки,история которой изменилась.</target>
        </trans-unit>
        <trans-unit id="427cec7db1c8d9c41ec669de64df63aacc49a26f" translate="yes" xml:space="preserve">
          <source>You can grow a new branch from any commit. For example, switch to &quot;HEAD~3&quot; and create branch &quot;fixup&quot;:</source>
          <target state="translated">Ты можешь вырастить новый филиал из любого коммитета.Например,переключиться на &quot;HEAD~3&quot; и создать &quot;фикс&quot; ветки:</target>
        </trans-unit>
        <trans-unit id="8abddb96169bb94a7080d5c82ed5cac7b229954a" translate="yes" xml:space="preserve">
          <source>You can have a mixture of files show up as &quot;has been updated&quot; and &quot;is still dirty in the working directory&quot; together. You can always tell which file is in which state, since the &quot;has been updated&quot; ones show a valid sha1, and the &quot;not in sync with the index&quot; ones will always have the special all-zero sha1.</source>
          <target state="translated">Вы можете иметь смесь файлов,которые вместе отображаются как &quot;было обновлено&quot; и &quot;все еще грязно в рабочем каталоге&quot;.Вы всегда можете сказать,какой файл находится в каком состоянии,так как &quot;был обновлен&quot; показывает действительный sha1,а &quot;не синхронизирован с индексом&quot; всегда будет иметь специальный all-zero sha1.</target>
        </trans-unit>
        <trans-unit id="ae3f7bca446e950bd716349b25ee5d05aaee6a26" translate="yes" xml:space="preserve">
          <source>You can include a config file from another by setting the special &lt;code&gt;include.path&lt;/code&gt; (or &lt;code&gt;includeIf.*.path&lt;/code&gt;) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times.</source>
          <target state="translated">Вы можете включить файл конфигурации из другого файла, установив в специальной &lt;code&gt;include.path&lt;/code&gt; (или &lt;code&gt;includeIf.*.path&lt;/code&gt; ) имя включаемого файла. Переменная принимает в качестве значения путь и может быть расширена тильдой. Эти переменные можно указывать несколько раз.</target>
        </trans-unit>
        <trans-unit id="5145f6f36a43ec5e98537ca833d15e8282538fcf" translate="yes" xml:space="preserve">
          <source>You can include a config file from another conditionally by setting a &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; variable to the name of the file to be included.</source>
          <target state="translated">Вы можете условно включить файл конфигурации из другого файла, установив в переменной &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; имя включаемого файла.</target>
        </trans-unit>
        <trans-unit id="509dfc228243cbfccb732c55df31d8f926c42b85" translate="yes" xml:space="preserve">
          <source>You can include other configuration file using read_config_file() subroutine. For example, one might want to put gitweb configuration related to access control for viewing repositories via Gitolite (one of Git repository management tools) in a separate file, e.g. in &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt;. To include it, put</source>
          <target state="translated">Вы можете включить другой файл конфигурации, используя подпрограмму read_config_file (). Например, можно поместить конфигурацию gitweb, связанную с контролем доступа для просмотра репозиториев через Gitolite (один из инструментов управления репозиториями Git), в отдельный файл, например, в &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt; . Чтобы включить его, положите</target>
        </trans-unit>
        <trans-unit id="645452c6d997e8f480a9efb060142f580408b9f7" translate="yes" xml:space="preserve">
          <source>You can make a different change on the master branch:</source>
          <target state="translated">Вы можете сделать другое изменение на главной ветке:</target>
        </trans-unit>
        <trans-unit id="9d56811ee77d2943d64ee7741c452578a4d84979" translate="yes" xml:space="preserve">
          <source>You can make interesting things happen to a repository every time you push into it, by setting up &lt;code&gt;hooks&lt;/code&gt; there. See documentation for &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;.</source>
          <target state="translated">Вы можете делать что-то интересное с репозиторием каждый раз, когда в него заходите, установив там &lt;code&gt;hooks&lt;/code&gt; . См. Документацию для &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31caee42f233cd83de2778af5287eb406c23a1ef" translate="yes" xml:space="preserve">
          <source>You can make sure &lt;code&gt;git show-branch&lt;/code&gt; matches the state before those two &lt;code&gt;git merge&lt;/code&gt; you just did. Then, instead of running two &lt;code&gt;git merge&lt;/code&gt; commands in a row, you would merge these two branch heads (this is known as &lt;code&gt;making an Octopus&lt;/code&gt;):</source>
          <target state="translated">Вы можете убедиться, что &lt;code&gt;git show-branch&lt;/code&gt; соответствует состоянию до того, как вы только что сделали &lt;code&gt;git merge&lt;/code&gt; этих двух git . Затем вместо того, чтобы запускать две команды &lt;code&gt;git merge&lt;/code&gt; подряд, вы должны объединить эти две головки веток (это известно как &lt;code&gt;making an Octopus&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="b0c1a53571be700b171dec8a7fa266ccfd88fbe8" translate="yes" xml:space="preserve">
          <source>You can make the appropriate change to your working tree, run &lt;code&gt;git add
&amp;lt;file&amp;gt;&lt;/code&gt; or &lt;code&gt;git rm &amp;lt;file&amp;gt;&lt;/code&gt;, as appropriate, to stage it, and then &lt;code&gt;git
commit --amend&lt;/code&gt;. Your change will be included in the commit, and you&amp;rsquo;ll be prompted to edit the commit message again; if you wish to use the original message verbatim, you can use the &lt;code&gt;--no-edit&lt;/code&gt; option to &lt;code&gt;git
commit&lt;/code&gt; in addition, or just save and quit when your editor opens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f748b043bbe97de82ec4f7b6a5308c58b703d36" translate="yes" xml:space="preserve">
          <source>You can make the server use the end-of-line conversion attributes to set the &lt;code&gt;-k&lt;/code&gt; modes for files by setting the &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config variable. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for more information about end-of-line conversion.</source>
          <target state="translated">Вы можете заставить сервер использовать атрибуты преобразования конца строки для установки режимов &lt;code&gt;-k&lt;/code&gt; для файлов, установив конфигурационную переменную &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; . См. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; для получения дополнительной информации о преобразовании конца строки.</target>
        </trans-unit>
        <trans-unit id="015443f769a79760c1933372fa244563a6a25aba" translate="yes" xml:space="preserve">
          <source>You can omit having to type return here, by setting the configuration variable &lt;code&gt;interactive.singleKey&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Вы можете не вводить здесь return, установив для переменной конфигурации &lt;code&gt;interactive.singleKey&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="358c29af25eb707e9507c2c41ba2c41fddac22f4" translate="yes" xml:space="preserve">
          <source>You can override these rules either by command-line options or by environment variables. The &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--system&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; options will limit the file used to the global, system-wide or per-worktree file respectively. The &lt;code&gt;GIT_CONFIG&lt;/code&gt; environment variable has a similar effect, but you can specify any filename you want.</source>
          <target state="translated">Вы можете переопределить эти правила с помощью параметров командной строки или переменных среды. Параметры &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--system&lt;/code&gt; и &lt;code&gt;--worktree&lt;/code&gt; ограничивают используемый файл глобальным, общесистемным файлом или файлом для каждого рабочего дерева соответственно. &lt;code&gt;GIT_CONFIG&lt;/code&gt; переменной среды имеет такой же эффект, но вы можете указать любое имя файла , который вы хотите.</target>
        </trans-unit>
        <trans-unit id="b9256a8bfff0f4e1e2098927e9ff118ae66b3eab" translate="yes" xml:space="preserve">
          <source>You can perform &quot;git pull&quot;, resolve potential conflicts, and &quot;git push&quot; the result. A &quot;git pull&quot; will create a merge commit C between commits A and B.</source>
          <target state="translated">Вы можете выполнить &quot;git-тянуть&quot;,разрешить потенциальные конфликты и &quot;подтолкнуть&quot; результат.При &quot;проталкивании git'а&quot; создаётся коммит слияния C между коммитами A и B.</target>
        </trans-unit>
        <trans-unit id="189a9ed33e189223869b33620d09d0f720bf3fe1" translate="yes" xml:space="preserve">
          <source>You can provide options via the credential.helper configuration variable (this example drops the cache time to 5 minutes):</source>
          <target state="translated">Вы можете предоставить опции через конфигурационную переменную credential.helper (в этом примере время кэша снижается до 5 минут):</target>
        </trans-unit>
        <trans-unit id="82656460f1d1171626ca7a2547e75d0458741fd5" translate="yes" xml:space="preserve">
          <source>You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped.</source>
          <target state="translated">С помощью этой команды вы можете запросить/установить/заменить/отключить опции.Имя на самом деле является секцией и ключом,разделенным точкой,и значение будет экранировано.</target>
        </trans-unit>
        <trans-unit id="10e463ee2669848fa9bb9fc90b4474d38bbf73be" translate="yes" xml:space="preserve">
          <source>You can rejoin two diverging branches of development using &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;:</source>
          <target state="translated">Вы можете &lt;a href=&quot;git-merge&quot;&gt;объединить&lt;/a&gt; две расходящиеся ветви разработки с помощью git-merge [1] :</target>
        </trans-unit>
        <trans-unit id="3e4277417393477fbeb632e41395d74e0a0e4169" translate="yes" xml:space="preserve">
          <source>You can repack this private repository whenever you feel like.</source>
          <target state="translated">Вы можете переупаковать этот личный репозиторий,когда захотите.</target>
        </trans-unit>
        <trans-unit id="3425cb44f3c2a0393cb24a6806cf1648e47fe578" translate="yes" xml:space="preserve">
          <source>You can repeat steps 2-4 multiple times to break the original code into any number of commits.</source>
          <target state="translated">Вы можете повторить шаги 2-4 раза,чтобы разбить исходный код на любое количество коммитов.</target>
        </trans-unit>
        <trans-unit id="f016259f2ce9ae7193e573b7fa2135698ca39f54" translate="yes" xml:space="preserve">
          <source>You can rewrite the commit log messages using &lt;code&gt;--msg-filter&lt;/code&gt;. For example, &lt;code&gt;git svn-id&lt;/code&gt; strings in a repository created by &lt;code&gt;git svn&lt;/code&gt; can be removed this way:</source>
          <target state="translated">Вы можете переписать сообщения журнала фиксации, используя &lt;code&gt;--msg-filter&lt;/code&gt; . Например, строки &lt;code&gt;git svn-id&lt;/code&gt; в репозитории, созданном &lt;code&gt;git svn&lt;/code&gt; , можно удалить следующим образом:</target>
        </trans-unit>
        <trans-unit id="6928e91b0b4a87a6f0188b338ec935fa803e932d" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;git-bundle verify&lt;/code&gt; to see if you can extract from a bundle that was created with a basis:</source>
          <target state="translated">Вы можете запустить &lt;code&gt;git-bundle verify&lt;/code&gt; , чтобы узнать, можете ли вы извлечь из пакета, который был создан на основе:</target>
        </trans-unit>
        <trans-unit id="28f57e6715a38d45260ef8d226913fe9d5e46420" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;gitk --all&lt;/code&gt; again to see how the commit ancestry looks like, or run &lt;code&gt;show-branch&lt;/code&gt;, which tells you this.</source>
          <target state="translated">Вы можете снова запустить &lt;code&gt;gitk --all&lt;/code&gt; , чтобы увидеть, как выглядит предок фиксации, или запустить &lt;code&gt;show-branch&lt;/code&gt; , который сообщает вам об этом.</target>
        </trans-unit>
        <trans-unit id="ee22a2dcf21325c45ae74e5933824496ebc88dee" translate="yes" xml:space="preserve">
          <source>You can save space and make Git faster by moving these loose objects in to a &quot;pack file&quot;, which stores a group of objects in an efficient compressed format; the details of how pack files are formatted can be found in &lt;a href=&quot;pack-format&quot;&gt;pack format&lt;/a&gt;.</source>
          <target state="translated">Вы можете сэкономить место и ускорить Git, переместив эти незакрепленные объекты в &amp;laquo;файл упаковки&amp;raquo;, в котором группа объектов хранится в эффективном сжатом формате; подробности о том, как форматируются файлы пакетов, можно найти в &lt;a href=&quot;pack-format&quot;&gt;формате пакета&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="923ef556c5ea1d367a9ceb952e817561488d6f46" translate="yes" xml:space="preserve">
          <source>You can see easily that the above is a rename.</source>
          <target state="translated">Легко заметить,что вышеперечисленное-это переименование.</target>
        </trans-unit>
        <trans-unit id="5724c58e846fc905ad55d8bc9c332033225407c5" translate="yes" xml:space="preserve">
          <source>You can set this to &lt;code&gt;link&lt;/code&gt;, in which case a hardlink followed by a delete of the source are used to make sure that object creation will not overwrite existing objects.</source>
          <target state="translated">Вы можете установить это как &lt;code&gt;link&lt;/code&gt; , и в этом случае жесткая ссылка с последующим удалением источника используется, чтобы гарантировать, что создание объекта не будет перезаписывать существующие объекты.</target>
        </trans-unit>
        <trans-unit id="02df8661fe031a54ab42701feedaa37cd7c87875" translate="yes" xml:space="preserve">
          <source>You can setup one single value (single entry/item in this list) at build time by setting the &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; build-time configuration variable. By default it is set to (), i.e. an empty list. This means that gitweb would not try to create project URL (to fetch) from project name.</source>
          <target state="translated">Вы можете установить одно значение (отдельная запись / элемент в этом списке) во время сборки, установив переменную конфигурации &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; во время сборки. По умолчанию он установлен в (), т.е. пустой список. Это означает, что gitweb не будет пытаться создать URL-адрес проекта (для извлечения) из имени проекта.</target>
        </trans-unit>
        <trans-unit id="af5fba33ca90f8278cecf2701efca5c8b71085ca" translate="yes" xml:space="preserve">
          <source>You can specify a list of allowed directories. If no directories are given, all are allowed. This is an additional restriction, gitcvs access still needs to be enabled by the &lt;code&gt;gitcvs.enabled&lt;/code&gt; config option unless &lt;code&gt;--export-all&lt;/code&gt; was given, too.</source>
          <target state="translated">Вы можете указать список разрешенных каталогов. Если каталоги не указаны, разрешены все. Это дополнительное ограничение, доступ к gitcvs по-прежнему должен быть включен с помощью &lt;code&gt;gitcvs.enabled&lt;/code&gt; конфигурации &lt;code&gt;--export-all&lt;/code&gt; если также не был указан --export-all .</target>
        </trans-unit>
        <trans-unit id="a2f1a86c57fcd513fcca4d9c2bf5f81069f36bf3" translate="yes" xml:space="preserve">
          <source>You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add &quot;To:&quot; or &quot;Cc:&quot; headers, configure attachments, change the patch output directory, and sign off patches with configuration variables.</source>
          <target state="translated">Вы можете указать дополнительные строки почтового заголовка,которые будут добавляться к каждому сообщению,настройки по умолчанию для префикса темы и суффикса файла,номер патча при выводе более одного патча,добавить заголовки &quot;To:&quot; или &quot;Cc:&quot;,настроить вложения,изменить каталог вывода патча,а также подписать патчи с помощью конфигурационных переменных.</target>
        </trans-unit>
        <trans-unit id="c33dd2cd2261f81cbd0fc492df4e16b1e747c25d" translate="yes" xml:space="preserve">
          <source>You can specify the information shown for each object by using a custom &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is copied literally to stdout for each object, with placeholders of the form &lt;code&gt;%(atom)&lt;/code&gt; expanded, followed by a newline. The available atoms are:</source>
          <target state="translated">Вы можете указать информацию, отображаемую для каждого объекта, с помощью настраиваемого &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; . &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; копируется буквально на стандартный вывод для каждого объекта, с заполнителями вида &lt;code&gt;%(atom)&lt;/code&gt; расширенной, с последующим переводом строки. Доступные атомы:</target>
        </trans-unit>
        <trans-unit id="50f1e86bfea2179ec0dc9556f31c0b7322253687" translate="yes" xml:space="preserve">
          <source>You can store the files in the repository with Unix line endings and convert them automatically to your platform&amp;rsquo;s line endings. To do that, set the configuration option &lt;code&gt;core.eol&lt;/code&gt; to &lt;code&gt;native&lt;/code&gt; and see the following entry for information about how to configure files as text or binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a94d83b2aa4f52ca10b82e1786cdc28d9f55e56" translate="yes" xml:space="preserve">
          <source>You can tell Git to ignore certain files by creating a file called &lt;code&gt;.gitignore&lt;/code&gt; in the top level of your working directory, with contents such as:</source>
          <target state="translated">Вы можете указать Git игнорировать определенные файлы, создав файл с именем &lt;code&gt;.gitignore&lt;/code&gt; на верхнем уровне вашего рабочего каталога с таким содержимым, как:</target>
        </trans-unit>
        <trans-unit id="491f06c247008ffc2db5fcd9f930c35d5e25a466" translate="yes" xml:space="preserve">
          <source>You can tell Git to split the Git internal information from the directory that it tracks, but we&amp;rsquo;ll ignore that for now: it&amp;rsquo;s not how normal projects work, and it&amp;rsquo;s really only meant for special uses. So the mental model of &quot;the Git information is always tied directly to the working tree that it describes&quot; may not be technically 100% accurate, but it&amp;rsquo;s a good model for all normal use.</source>
          <target state="translated">Вы можете указать Git отделить внутреннюю информацию Git от каталога, который он отслеживает, но пока мы проигнорируем это: это не то, как работают обычные проекты, и на самом деле оно предназначено только для специального использования. Таким образом, ментальная модель &amp;laquo;информация Git всегда напрямую связана с рабочим деревом, которое она описывает&amp;raquo; может быть технически не точной на 100%, но это хорошая модель для любого обычного использования.</target>
        </trans-unit>
        <trans-unit id="eba2ddb51d288f0b3a9988b4f1ccbdcde132a1f4" translate="yes" xml:space="preserve">
          <source>You can test whether the filesystem supports that with the &lt;code&gt;--test-untracked-cache&lt;/code&gt; option. The &lt;code&gt;--untracked-cache&lt;/code&gt; option used to implicitly perform that test in older versions of Git, but that&amp;rsquo;s no longer the case.</source>
          <target state="translated">Вы можете проверить, поддерживает ли файловая система это с помощью параметра &lt;code&gt;--test-untracked-cache&lt;/code&gt; . Параметр &lt;code&gt;--untracked-cache&lt;/code&gt; использовался для неявного выполнения этого теста в старых версиях Git, но теперь это уже не так.</target>
        </trans-unit>
        <trans-unit id="33337304817f97abbb584fa2c7541a14abb9bfcd" translate="yes" xml:space="preserve">
          <source>You can then fix the conflicts during the rebase. Presumably you have not published your topic other than by mail, so rebasing it is not a problem.</source>
          <target state="translated">Тогда вы сможете исправить конфликты во время перезагрузки.Предположительно,вы не публиковали свою тему,кроме как по почте,поэтому ребейзинг не является проблемой.</target>
        </trans-unit>
        <trans-unit id="d6b74e3d43432e56c49f83bf0e8c1bc1b7ac50b8" translate="yes" xml:space="preserve">
          <source>You can then import these into your mail client and send them by hand. However, if you have a lot to send at once, you may prefer to use the &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; script to automate the process. Consult the mailing list for your project first to determine their requirements for submitting patches.</source>
          <target state="translated">Затем вы можете импортировать их в свой почтовый клиент и отправлять вручную. Однако, если вам нужно сразу много отправить, вы можете предпочесть сценарий &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; для автоматизации процесса. Сначала обратитесь к списку рассылки вашего проекта, чтобы определить их требования к отправке исправлений.</target>
        </trans-unit>
        <trans-unit id="ad2194dc994cc556c2451e6a9d4c256f90b5afd4" translate="yes" xml:space="preserve">
          <source>You can then transplant the old &lt;code&gt;subsystem..topic&lt;/code&gt; to the new tip by saying (for the reflog case, and assuming you are on &lt;code&gt;topic&lt;/code&gt; already):</source>
          <target state="translated">Затем вы можете перенести старую &lt;code&gt;subsystem..topic&lt;/code&gt; на новую подсказку, сказав (для случая рефлога и при условии, что вы уже в &lt;code&gt;topic&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="b5bb69809c9820257d5f27c5ec379a4130c453d8" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits given on the command line form a set of commits that are reachable from any of them, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">Вы можете думать об этом как об операции по установке. Коммиты, заданные в командной строке, образуют набор коммитов, которые достижимы из любого из них, а затем коммиты, достижимые из любых коммитов, указанных с &lt;code&gt;^&lt;/code&gt; впереди, вычитаются из этого набора. Остальные коммиты - это то, что отображается в выводе команды. Для дальнейшего ограничения результата можно использовать различные другие параметры и параметры путей.</target>
        </trans-unit>
        <trans-unit id="497fe81f829587b397446cebabae5d6848f111c9" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacfd2b96f144de251fd3721b44d6ad9ca988b86" translate="yes" xml:space="preserve">
          <source>You can try running &lt;code&gt;find .git/objects -type f&lt;/code&gt; before and after you run &lt;code&gt;git prune-packed&lt;/code&gt; if you are curious. Also &lt;code&gt;git
count-objects&lt;/code&gt; would tell you how many unpacked objects are in your repository and how much space they are consuming.</source>
          <target state="translated">Вы можете попробовать запустить &lt;code&gt;find .git/objects -type f&lt;/code&gt; до и после запуска &lt;code&gt;git prune-packed&lt;/code&gt; если вам интересно. Также &lt;code&gt;git count-objects&lt;/code&gt; сообщит вам, сколько распакованных объектов находится в вашем репозитории и сколько места они занимают.</target>
        </trans-unit>
        <trans-unit id="78c0fba98badb6e25ce1949ee53cb8839b8be51a" translate="yes" xml:space="preserve">
          <source>You can update the shared repository with your changes by first committing your changes, and then using the &lt;code&gt;git push&lt;/code&gt; command:</source>
          <target state="translated">Вы можете обновить общий репозиторий своими изменениями, сначала зафиксировав свои изменения, а затем используя команду &lt;code&gt;git push&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fe24364fca4da5268b93a1c7c864762589bec5d4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; to examine the contents of a blob; take, for example, the blob in the entry for &lt;code&gt;COPYING&lt;/code&gt; from the tree above:</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;git-show&quot;&gt;git-show [1],&lt;/a&gt; чтобы проверить содержимое большого двоичного объекта; возьмем, например, blob в записи для &lt;code&gt;COPYING&lt;/code&gt; из дерева выше:</target>
        </trans-unit>
        <trans-unit id="cdee252fbf6b663369bb36f7a81711483c778043" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;git stash push --keep-index&lt;/code&gt; , если хотите сделать две или более фиксации изменений в рабочем дереве, и вы хотите протестировать каждое изменение перед фиксацией:</target>
        </trans-unit>
        <trans-unit id="b954fc6ff3f193031cbeca4547760f3425491805" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash&lt;/code&gt; to simplify the above, like this:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;git stash&lt;/code&gt; , чтобы упростить приведенное выше, например:</target>
        </trans-unit>
        <trans-unit id="c482710749f3dcad6cbdc9701b2eb8b0d7f62e6a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;stable-1&lt;/code&gt; to refer to the commit 1b2e1d63ff.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;stable-1&lt;/code&gt; для ссылки на фиксацию 1b2e1d63ff.</target>
        </trans-unit>
        <trans-unit id="783e49ef6897108ce62c504df5bb1071160ba897" translate="yes" xml:space="preserve">
          <source>You can use a basis based on time:</source>
          <target state="translated">Вы можете использовать основу,основанную на времени:</target>
        </trans-unit>
        <trans-unit id="0dcaab83279bcfe9c2e3dbaa6b4f0d035029ab31" translate="yes" xml:space="preserve">
          <source>You can use a tag that is present in both:</source>
          <target state="translated">Вы можете использовать метку,которая присутствует в обоих:</target>
        </trans-unit>
        <trans-unit id="0967772702daca79ec55cd9be52c70fe75848751" translate="yes" xml:space="preserve">
          <source>You can use different &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; values to control this behavior:</source>
          <target state="translated">Вы можете использовать разные значения &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; для управления этим поведением:</target>
        </trans-unit>
        <trans-unit id="72733e82f897a2af21fcfc3df3447e66ece75165" translate="yes" xml:space="preserve">
          <source>You can use it as a human-readable bundle replacement (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;), or as a format that can be edited before being fed to &lt;code&gt;git fast-import&lt;/code&gt; in order to do history rewrites (an ability relied on by tools like &lt;code&gt;git filter-repo&lt;/code&gt;).</source>
          <target state="translated">Вы можете использовать его как удобочитаемую замену пакета (см. &lt;a href=&quot;git-bundle&quot;&gt;Git-bundle [1]&lt;/a&gt; ) или как формат, который можно редактировать перед передачей в &lt;code&gt;git fast-import&lt;/code&gt; для перезаписи истории (возможность, зависящая от инструментов как &lt;code&gt;git filter-repo&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b34e82e0ff80209e7866272f371ddd1420b0f13" translate="yes" xml:space="preserve">
          <source>You can use mod_perl with gitweb. You must install Apache::Registry (for mod_perl 1.x) or ModPerl::Registry (for mod_perl 2.x) to enable this support.</source>
          <target state="translated">Вы можете использовать mod_perl с gitweb.Вы должны установить Apache::Registry (для mod_perl 1.x)или ModPerl::Registry (для mod_perl 2.x),чтобы включить эту поддержку.</target>
        </trans-unit>
        <trans-unit id="625924bfa2e6c050ea9730ca7a0edb6cfce2bfdc" translate="yes" xml:space="preserve">
          <source>You can use notes to add annotations with information that was not available at the time a commit was written.</source>
          <target state="translated">Вы можете использовать примечания для добавления аннотаций с информацией,которая была недоступна на момент написания коммита.</target>
        </trans-unit>
        <trans-unit id="0bbbcd5b5890880e82d452d584e7cf77013dabac" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@&lt;/code&gt; construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch &lt;code&gt;blabla&lt;/code&gt; then &lt;code&gt;@{1}&lt;/code&gt; means the same as &lt;code&gt;blabla@{1}&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать конструкцию &lt;code&gt;@&lt;/code&gt; с пустой частью ссылки, чтобы получить запись журнала ссылок текущей ветки. Например, если вы находитесь в ветке &lt;code&gt;blabla&lt;/code&gt; , тогда &lt;code&gt;@{1}&lt;/code&gt; означает то же, что и &lt;code&gt;blabla@{1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3a4b2dd2cada66b7023aa9fae3c933422c9fcc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit checked out using &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать синтаксис &lt;code&gt;@{-N}&lt;/code&gt; для ссылки на N-ю последнюю ветвь / фиксацию, извлеченную с помощью операции &amp;laquo;git checkout&amp;raquo;. Вы также можете указать &lt;code&gt;-&lt;/code&gt; что является синонимом &lt;code&gt;@{-1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e21f11f93a4b8bdb963de3cd700b58b5db33242a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit switched to using &quot;git switch&quot; or &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.</source>
          <target state="translated">Вы можете использовать синтаксис &lt;code&gt;@{-N}&lt;/code&gt; для ссылки на N-ю последнюю ветвь / фиксацию, переключенную на использование операции &amp;laquo;git switch&amp;raquo; или &amp;laquo;git checkout&amp;raquo;. Вы также можете указать &lt;code&gt;-&lt;/code&gt; что является синонимом &lt;code&gt;@{-1}&lt;/code&gt; . Это часто используется для быстрого переключения между двумя ветвями или для отмены переключения ветвей по ошибке.</target>
        </trans-unit>
        <trans-unit id="736fc09a09a7b16017fd49ac75e258e953294134" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;gitweb.owner&lt;/code&gt; repository configuration variable to set repository&amp;rsquo;s owner. It is displayed in the project list and summary page.</source>
          <target state="translated">Вы можете использовать переменную конфигурации репозитория &lt;code&gt;gitweb.owner&lt;/code&gt; , чтобы установить владельца репозитория. Он отображается в списке проектов и на странице сводки.</target>
        </trans-unit>
        <trans-unit id="b3762dc0cf78ebbd7cf935ac045ade59a2e3acbf" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;htpasswd&lt;/code&gt; facility that comes with Apache to make these files, but Apache&amp;rsquo;s MD5 crypt method differs from the one used by most C library&amp;rsquo;s crypt() function, so don&amp;rsquo;t use the -m option.</source>
          <target state="translated">Вы можете использовать средство &lt;code&gt;htpasswd&lt;/code&gt; , поставляемое с Apache, для создания этих файлов, но метод шифрования MD5 Apache отличается от метода, используемого большинством функций crypt () библиотеки C, поэтому не используйте параметр -m.</target>
        </trans-unit>
        <trans-unit id="80aa1363be3995d4ec384e59561a0e7a0903c070" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map&lt;/code&gt; convenience function in this filter, and other convenience functions, too. For example, calling &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; will leave out the current commit (but not its changes! If you want that, use &lt;code&gt;git rebase&lt;/code&gt; instead).</source>
          <target state="translated">Вы можете использовать функцию удобства &lt;code&gt;map&lt;/code&gt; в этом фильтре, а также другие функции удобства. Например, вызов &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; оставит текущий коммит (но не его изменения! Если вы этого хотите, используйте вместо этого &lt;code&gt;git rebase&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c32abff787b36e9c877031d224291d8c643f61f1" translate="yes" xml:space="preserve">
          <source>You can use the following files in repository:</source>
          <target state="translated">Вы можете использовать следующие файлы в репозитории:</target>
        </trans-unit>
        <trans-unit id="b6c6eac74692734c5ec1dc3c689d37b0eb0dcea6" translate="yes" xml:space="preserve">
          <source>You can use the number of commits:</source>
          <target state="translated">Вы можете использовать количество коммитов:</target>
        </trans-unit>
        <trans-unit id="4a928f707b340dd3df65a93fa7f9942c5a65d9b2" translate="yes" xml:space="preserve">
          <source>You can very easily automatically bisect broken builds using something like:</source>
          <target state="translated">Вы можете очень легко автоматически бисектировать сломанные сборки,используя что-то вроде:</target>
        </trans-unit>
        <trans-unit id="77487b0c89edd8fd842e99d65a1b39d2c6b378f5" translate="yes" xml:space="preserve">
          <source>You can work through the conflict with a number of tools:</source>
          <target state="translated">Вы можете проработать конфликт с помощью ряда инструментов:</target>
        </trans-unit>
        <trans-unit id="918d78d55a9c451b1a86101242b3194591c9e6cc" translate="yes" xml:space="preserve">
          <source>You can write the mandatory option parameter to an option as a separate word on the command line. That means that all the following uses work:</source>
          <target state="translated">Обязательный параметр опции можно записать в качестве отдельного слова в командной строке.Это означает,что все перечисленное ниже использует работу:</target>
        </trans-unit>
        <trans-unit id="03d917937bc98856220155e739ac2f8752cca599" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f91f3a076bca347349424f4008dca0a1518c15" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials. See credential.h for details.</source>
          <target state="translated">Вы можете написать свои собственные помощники,чтобы взаимодействовать с любой системой,в которой у вас есть учетные данные.Подробности см.на сайте credential.h.</target>
        </trans-unit>
        <trans-unit id="c06b90a2f16de670e5df5d7464445ae0f28559f2" translate="yes" xml:space="preserve">
          <source>You could be using the &lt;code&gt;objects/info/alternates&lt;/code&gt; or &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; mechanisms to &lt;code&gt;borrow&lt;/code&gt; objects from other object stores. A repository with this kind of incomplete object store is not suitable to be published for use with dumb transports but otherwise is OK as long as &lt;code&gt;objects/info/alternates&lt;/code&gt; points at the object stores it borrows from.</source>
          <target state="translated">Вы можете использовать механизмы &lt;code&gt;objects/info/alternates&lt;/code&gt; или &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; для &lt;code&gt;borrow&lt;/code&gt; объектов из других хранилищ объектов. Репозиторий с таким неполным хранилищем объектов не подходит для публикации для использования с немыми транспортами, но в остальном все в порядке, пока &lt;code&gt;objects/info/alternates&lt;/code&gt; указывает в хранилищах объектов, из которых он заимствует.</target>
        </trans-unit>
        <trans-unit id="e2e5ecc00e320fd7f95c1d7def9e5cd07e7e5d74" translate="yes" xml:space="preserve">
          <source>You could do without using any branches at all, by keeping as many local repositories as you would like to have branches, and merging between them with &lt;em&gt;git pull&lt;/em&gt;, just like you merge between branches. The advantage of this approach is that it lets you keep a set of files for each &lt;code&gt;branch&lt;/code&gt; checked out and you may find it easier to switch back and forth if you juggle multiple lines of development simultaneously. Of course, you will pay the price of more disk usage to hold multiple working trees, but disk space is cheap these days.</source>
          <target state="translated">Вы можете вообще обойтись без использования каких-либо веток, сохранив столько локальных репозиториев, сколько вы хотели бы иметь веток, и слияние между ними с помощью &lt;em&gt;git pull&lt;/em&gt; , точно так же, как вы объединяете ветки. Преимущество этого подхода состоит в том, что он позволяет вам сохранять набор файлов для каждой &lt;code&gt;branch&lt;/code&gt; , и вам может быть проще переключаться туда и обратно, если вы одновременно манипулируете несколькими линиями разработки. Конечно, вы заплатите цену большего использования диска для хранения нескольких рабочих деревьев, но в наши дни дисковое пространство дешево.</target>
        </trans-unit>
        <trans-unit id="8ff03510fc9dfa2f41199478909f4845fc0f0bb6" translate="yes" xml:space="preserve">
          <source>You could have an incomplete but locally usable repository by creating a shallow clone. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">Вы можете получить неполный, но доступный локально репозиторий, создав неглубокий клон. См. &lt;a href=&quot;git-clone&quot;&gt;Git-clone [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f736fa76fc678c4f130db13f45faf6b48f41687a" translate="yes" xml:space="preserve">
          <source>You could just visually inspect the commits since e05db0fd:</source>
          <target state="translated">Вы можете просто визуально осмотреть коммиты с e05db0fd:</target>
        </trans-unit>
        <trans-unit id="0d78b2a8d8354041e789d882f2348db69275bdcd" translate="yes" xml:space="preserve">
          <source>You could omit &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, in which case the command degenerates to &quot;check out the current branch&quot;, which is a glorified no-op with rather expensive side-effects to show only the tracking information, if exists, for the current branch.</source>
          <target state="translated">Вы можете опустить &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; , и в этом случае команда вырождается в &amp;laquo;проверить текущую ветвь&amp;raquo;, что является прославленным запретом на выполнение операций с довольно дорогими побочными эффектами, чтобы показать только информацию отслеживания, если она существует, для текущей ветки.</target>
        </trans-unit>
        <trans-unit id="7c5b22847ee058ce78c26cbc63e773fbbc9499cd" translate="yes" xml:space="preserve">
          <source>You create a commit object by giving it the tree that describes the state at the time of the commit, and a list of parents:</source>
          <target state="translated">Вы создаёте объект коммита,предоставляя ему дерево,описывающее состояние на момент коммита,и список родителей:</target>
        </trans-unit>
        <trans-unit id="0fca09140e6ecd8df23b487785db8ea6f6692c80" translate="yes" xml:space="preserve">
          <source>You do not want any end-of-line conversions applied to, nor textual diffs produced for, any binary file you track. You would need to specify e.g.</source>
          <target state="translated">Вы не хотите,чтобы какие-либо преобразования в конце строки применялись к любому бинарному файлу,который вы отслеживаете,или чтобы для него не создавались текстовые различия.Вам нужно будет указать,например</target>
        </trans-unit>
        <trans-unit id="3b6ec2c54535f15330b4b3b431cf4481da43a55b" translate="yes" xml:space="preserve">
          <source>You do random edits, without running &lt;code&gt;git update-index&lt;/code&gt;. And then you notice that the tip of your &quot;upstream&quot; tree has advanced since you pulled from him:</source>
          <target state="translated">Вы вносите случайные изменения без запуска &lt;code&gt;git update-index&lt;/code&gt; . А затем вы замечаете, что верхушка вашего &amp;laquo;восходящего&amp;raquo; дерева продвинулась вперед с тех пор, как вы вытащили его:</target>
        </trans-unit>
        <trans-unit id="96b7f9c5e1f885ad6155a2dabe0351e9e08cd246" translate="yes" xml:space="preserve">
          <source>You do your real work in your working tree that has your primary repository hanging under it as its &lt;code&gt;.git&lt;/code&gt; subdirectory. You &lt;strong&gt;could&lt;/strong&gt; make that repository accessible remotely and ask people to pull from it, but in practice that is not the way things are usually done. A recommended way is to have a public repository, make it reachable by other people, and when the changes you made in your primary working tree are in good shape, update the public repository from it. This is often called &lt;code&gt;pushing&lt;/code&gt;.</source>
          <target state="translated">Вы делаете свою реальную работу в своем рабочем дереве, под которым находится ваш основной репозиторий в виде подкаталога &lt;code&gt;.git&lt;/code&gt; . Вы &lt;strong&gt;можете&lt;/strong&gt; сделать этот репозиторий доступным удаленно и попросить людей извлечь из него данные, но на практике это обычно не так. Рекомендуемый способ - создать общедоступный репозиторий, сделать его доступным для других людей, и когда изменения, внесенные вами в основное рабочее дерево, находятся в хорошей форме, обновить общедоступный репозиторий из него. Это часто называют &lt;code&gt;pushing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0911499c26fd93762ba87b20e89843bed2558fd8" translate="yes" xml:space="preserve">
          <source>You have made some commits, but realize they were premature to be in the &lt;code&gt;master&lt;/code&gt; branch. You want to continue polishing them in a topic branch, so create &lt;code&gt;topic/wip&lt;/code&gt; branch off of the current &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Вы сделали несколько коммитов, но понимаете, что они преждевременны для включения в &lt;code&gt;master&lt;/code&gt; ветку. Вы хотите продолжить их полировку в ветке темы, поэтому создайте ветку &lt;code&gt;topic/wip&lt;/code&gt; от текущей &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9321ccbae87a4bc4f97065bb17cb67a1a81520be" translate="yes" xml:space="preserve">
          <source>You have now created your first Git repository. Of course, since it&amp;rsquo;s empty, that&amp;rsquo;s not very useful, so let&amp;rsquo;s start populating it with data.</source>
          <target state="translated">Вы создали свой первый репозиторий Git. Конечно, поскольку он пуст, это не очень полезно, поэтому давайте начнем заполнять его данными.</target>
        </trans-unit>
        <trans-unit id="d177c25ea329a8110bbd819e0cb66c6b6619b0d7" translate="yes" xml:space="preserve">
          <source>You have now successfully copied somebody else&amp;rsquo;s (mine) remote repository, and checked it out.</source>
          <target state="translated">Теперь вы успешно скопировали чужой (мой) удаленный репозиторий и проверили его.</target>
        </trans-unit>
        <trans-unit id="3cc6b09871d23a7d903d56d9d6eb61d9c29d1dd4" translate="yes" xml:space="preserve">
          <source>You have performed no merges into mywork, so it is just a simple linear sequence of patches on top of &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">Вы не выполнили никаких слияний с моей работой, так что это простая линейная последовательность патчей поверх &lt;code&gt;origin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8744f866557cd48a608818edcb46f21bfb3d75" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;git submodule update&lt;/code&gt; after &lt;code&gt;git pull&lt;/code&gt; if you want to update submodules, too.</source>
          <target state="translated">Вам нужно запустить &lt;code&gt;git submodule update&lt;/code&gt; после &lt;code&gt;git pull&lt;/code&gt; , если вы тоже хотите обновить подмодули.</target>
        </trans-unit>
        <trans-unit id="f82b6e7678c4aeade044d41684916154b148e08d" translate="yes" xml:space="preserve">
          <source>You haven&amp;rsquo;t specified any nodes as heads so it won&amp;rsquo;t be possible to differentiate between un-parented commits and root nodes.</source>
          <target state="translated">Вы не указали какие-либо узлы в качестве заголовков, поэтому будет невозможно отличить коммиты без родителей от корневых узлов.</target>
        </trans-unit>
        <trans-unit id="60617aeef2563268db523c5fdc5a619452e83d26" translate="yes" xml:space="preserve">
          <source>You may also add new content that does not exist in the patch; simply add new lines, each starting with &quot;+&quot;. The addition will appear reverted in the working tree.</source>
          <target state="translated">Вы также можете добавить новый контент,которого нет в патче;просто добавьте новые строки,каждая из которых начинается с &quot;+&quot;.Добавление появится в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="ef502914f7e8ab4571571ef4343614d654bb655c" translate="yes" xml:space="preserve">
          <source>You may also have third-party helpers installed; search for &lt;code&gt;credential-*&lt;/code&gt; in the output of &lt;code&gt;git help -a&lt;/code&gt;, and consult the documentation of individual helpers. Once you have selected a helper, you can tell Git to use it by putting its name into the credential.helper variable.</source>
          <target state="translated">У вас также могут быть установлены сторонние помощники; найдите &lt;code&gt;credential-*&lt;/code&gt; в выводе &lt;code&gt;git help -a&lt;/code&gt; и обратитесь к документации отдельных помощников. После того, как вы выбрали помощника, вы можете указать Git использовать его, указав его имя в переменной credential.helper.</target>
        </trans-unit>
        <trans-unit id="f2298abd2d14c4384844acf0edbfaf0baea1ecae" translate="yes" xml:space="preserve">
          <source>You may also include a &lt;code&gt;!&lt;/code&gt; in front of the ref name to negate the entry, explicitly exposing it, even if an earlier entry marked it as hidden. If you have multiple hideRefs values, later entries override earlier ones (and entries in more-specific config files override less-specific ones).</source>
          <target state="translated">Вы также можете включить &lt;code&gt;!&lt;/code&gt; перед именем ссылки, чтобы отрицать запись, явно раскрывая ее, даже если более ранняя запись пометила ее как скрытую. Если у вас есть несколько значений hideRefs, более поздние записи переопределяют более ранние (а записи в более конкретных файлах конфигурации переопределяют менее конкретные).</target>
        </trans-unit>
        <trans-unit id="ea31f49a09c0b721c12c5805f99a1757f98a096f" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;, which lets you merge the unmerged files using external tools such as Emacs or kdiff3.</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt; , который позволяет объединять не объединенные файлы с помощью внешних инструментов, таких как Emacs или kdiff3.</target>
        </trans-unit>
        <trans-unit id="9adc4f69fd1939534db6a41ec486285df53ebd63" translate="yes" xml:space="preserve">
          <source>You may execute several commands by either using one instance of &lt;code&gt;--exec&lt;/code&gt; with several commands:</source>
          <target state="translated">Вы можете выполнить несколько команд, используя один экземпляр &lt;code&gt;--exec&lt;/code&gt; с несколькими командами:</target>
        </trans-unit>
        <trans-unit id="a70c5e0fed390964e6d887a35161883ab1754024" translate="yes" xml:space="preserve">
          <source>You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to &quot;revert the reversion&quot; (see the &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge How-To&lt;/a&gt; for details).</source>
          <target state="translated">Вы можете найти это полезным после отката слияния ветки темы, так как этот параметр воссоздает ветку темы со свежими коммитами, чтобы ее можно было успешно повторно объединить без необходимости &amp;laquo;отменить реверсию&amp;raquo; (см. &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;Инструкции revert-a-faulty-merge&lt;/a&gt; для подробности).</target>
        </trans-unit>
        <trans-unit id="08631c52a6efa8d7c45c6edcb816f877829615bc" translate="yes" xml:space="preserve">
          <source>You may force &lt;code&gt;git push&lt;/code&gt; to perform the update anyway by preceding the branch name with a plus sign:</source>
          <target state="translated">Вы можете заставить &lt;code&gt;git push&lt;/code&gt; выполнить обновление в любом случае, поставив перед именем ветки знак плюса:</target>
        </trans-unit>
        <trans-unit id="ae2bd0ef4c886d9dfce1ee8146a7755d847ffcc2" translate="yes" xml:space="preserve">
          <source>You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or &quot;revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in&quot;) applied to the revision being tested.</source>
          <target state="translated">Часто можно обнаружить,что во время бисектного сеанса к тестируемой ревизии применяются временные изменения (например,s/#define DEBUG 0/#define DEBUG 1/в заголовочном файле,или &quot;ревизии,в которой нет этой фиксации,этот патч должен применяться для работы над другой проблемой,в которой эта биссекция не заинтересована&quot;).</target>
        </trans-unit>
        <trans-unit id="014dba50ebab24a63a38baad57ed8364492c1d37" translate="yes" xml:space="preserve">
          <source>You may override individual configuration parameters when running any git command by using the &lt;code&gt;-c&lt;/code&gt; option. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Вы можете переопределить отдельные параметры конфигурации при запуске любой команды git, используя параметр &lt;code&gt;-c&lt;/code&gt; . Подробнее см. &lt;a href=&quot;git&quot;&gt;Git [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac5fdcda86efd0f875c444e1e9c4b64fbcccd8a8" translate="yes" xml:space="preserve">
          <source>You may specify configuration in your .git/config</source>
          <target state="translated">Вы можете указать конфигурацию в вашем .git/config</target>
        </trans-unit>
        <trans-unit id="13fb0fac683620e44c1d9b40bc74efe99d0db2f0" translate="yes" xml:space="preserve">
          <source>You may still choose to publish branches whose history is rewritten, and it may be useful for others to be able to fetch those branches in order to examine or test them, but they should not attempt to pull such branches into their own work.</source>
          <target state="translated">Вы все равно можете выбрать публикацию веток,история которых переписана,и другим может быть полезно получить эти ветки для проверки или тестирования,но они не должны пытаться втянуть такие ветки в свою собственную работу.</target>
        </trans-unit>
        <trans-unit id="eb01db138b0fd8c4f790bf23de91d970f6b3f25c" translate="yes" xml:space="preserve">
          <source>You may want to use &lt;code&gt;sslVerify=false&lt;/code&gt; while troubleshooting, if you suspect that the reason you are having trouble connecting is because the certificate you use at the private server &lt;code&gt;example.com&lt;/code&gt; you are trying to set up (or have set up) may not be verified correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594c958b8686511065ebf30dd08d761eb22eafab" translate="yes" xml:space="preserve">
          <source>You might need to instead use: &lt;code&gt;folder = &quot;[Google Mail]/Drafts&quot;&lt;/code&gt; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb3e9e45a2fe07905a833e4999cf989715a0ad3" translate="yes" xml:space="preserve">
          <source>You might need to instead use: folder = &quot;[Google Mail]/Drafts&quot; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">Вам может потребоваться вместо этого использовать: folder = &quot;[Google Mail] / Drafts&quot;, если вы получите сообщение об ошибке &amp;laquo;Папка не существует&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ce52beb4e545845637d5d5a0a1bc64e60b253c82" translate="yes" xml:space="preserve">
          <source>You might want to build on one of these remote-tracking branches on a branch of your own, just as you would for a tag:</source>
          <target state="translated">Возможно,вы захотите построить на одной из этих удалённых отслеживаемых ветвей свою собственную ветку,точно так же,как и для тега:</target>
        </trans-unit>
        <trans-unit id="d0620c25fa90dc1aefb86ac91dfbd9e4eb8b29d0" translate="yes" xml:space="preserve">
          <source>You might want to recreate merge commits, e.g. if you have a history like this:</source>
          <target state="translated">Возможно,вы захотите воссоздать коммиты слияния,например,если у вас есть такая история:</target>
        </trans-unit>
        <trans-unit id="76dbf6258421c615799bec755123a1d09c6ae993" translate="yes" xml:space="preserve">
          <source>You need to push the new tag to a public Git server (see &quot;DISTRIBUTED WORKFLOWS&quot; below). This makes the tag available to others tracking your project. The push could also trigger a post-update hook to perform release-related items such as building release tarballs and preformatted documentation pages.</source>
          <target state="translated">Вам необходимо подтолкнуть новый тэг к публичному Git-серверу (см.ниже &quot;DISTRIBUTED WORKFLOWS&quot;).Это сделает тег доступным для других,отслеживающих ваш проект.Этот толчок может также вызвать пост-обновление для выполнения связанных с релизом элементов,таких как тарболы для сборки релиза и страницы с предварительно отформатированной документацией.</target>
        </trans-unit>
        <trans-unit id="23c2bb7cb1fc9b6f4a240d36b5b4f0b94079730d" translate="yes" xml:space="preserve">
          <source>You need to set the configuration variable &lt;code&gt;rerere.enabled&lt;/code&gt; in order to enable this command.</source>
          <target state="translated">Вам нужно установить переменную конфигурации &lt;code&gt;rerere.enabled&lt;/code&gt; , чтобы включить эту команду.</target>
        </trans-unit>
        <trans-unit id="beb1062efd31de3a255af22760556d9dc5fafa01" translate="yes" xml:space="preserve">
          <source>You normally only do signed tags for major releases or things like that, while the light-weight tags are useful for any marking you want to do &amp;mdash; any time you decide that you want to remember a certain point, just create a private tag for it, and you have a nice symbolic name for the state at that point.</source>
          <target state="translated">Обычно вы делаете подписанные теги только для основных выпусков или тому подобного, в то время как облегченные теги полезны для любой маркировки, которую вы хотите сделать - каждый раз, когда вы решаете, что хотите запомнить определенный момент, просто создайте для него частный тег , и у вас есть хорошее символическое имя для состояния в этот момент.</target>
        </trans-unit>
        <trans-unit id="0eafb62c845e9f30a39264ada6b686e1d1ebb7b8" translate="yes" xml:space="preserve">
          <source>You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, &lt;code&gt;git fetch&lt;/code&gt; allows you to configure &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">Вы часто взаимодействуете с одним и тем же удаленным репозиторием, регулярно и многократно выполняя выборку из него. Чтобы отслеживать прогресс такого удаленного репозитория, &lt;code&gt;git fetch&lt;/code&gt; позволяет вам настраивать переменные конфигурации &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b67cab4bffb98d3ad72ff6748f9f8b98887d9f3" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">Вероятно, вы не захотите вызывать эту команду напрямую; он предназначен для использования в качестве помощника по учетным данным другими частями Git. См. &lt;a href=&quot;gitcredentials&quot;&gt;Gitcredentials [7]&lt;/a&gt; или &lt;code&gt;EXAMPLES&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="467e6fc50e0615f651de6ffbcc6e0f17ecbae432" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">Вероятно, вы не захотите вызывать эту команду напрямую; он предназначен для использования в качестве помощника по учетным данным другими частями git. См. &lt;a href=&quot;gitcredentials&quot;&gt;Gitcredentials [7]&lt;/a&gt; или &lt;code&gt;EXAMPLES&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="c924d93ebd8e89f99e14509235b47dec1acfaa5d" translate="yes" xml:space="preserve">
          <source>You read a &quot;tree&quot; file from the object database, and use that to populate (and overwrite&amp;mdash;​don&amp;rsquo;t do this if your index contains any unsaved state that you might want to restore later!) your current index. Normal operation is just</source>
          <target state="translated">Вы читаете &amp;laquo;древовидный&amp;raquo; файл из объектной базы данных и используете его для заполнения (и перезаписи - не делайте этого, если ваш индекс содержит несохраненное состояние, которое вы, возможно, захотите восстановить позже!) Вашего текущего индекса. Нормальная работа просто</target>
        </trans-unit>
        <trans-unit id="e01bf60bb2a8e848b7516e87eb6405fb0e476f7b" translate="yes" xml:space="preserve">
          <source>You really filtered all refs: use &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; when calling git-filter-branch.</source>
          <target state="translated">Вы действительно отфильтровали все ссылки: используйте &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; при вызове git-filter-branch.</target>
        </trans-unit>
        <trans-unit id="0cb205f517a67a8e523ed9cfa8681dc8f8d7b0ce" translate="yes" xml:space="preserve">
          <source>You really removed all variants of a filename, if a blob was moved over its lifetime. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; can help you find renames.</source>
          <target state="translated">Вы действительно удалили все варианты имени файла, если большой двоичный объект был перемещен за время своего существования. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; может помочь вам найти переименования.</target>
        </trans-unit>
        <trans-unit id="a347f016fee70b8901448b2a81ecd1980ba100a9" translate="yes" xml:space="preserve">
          <source>You see, Git is actually the best tool to find out about the source of Git itself!</source>
          <target state="translated">Видите ли,на самом деле Git-лучший инструмент,позволяющий узнать об источнике самого Git'а!</target>
        </trans-unit>
        <trans-unit id="2f7c7430f5ab3ddee895946cce58e0edcbc9b3f3" translate="yes" xml:space="preserve">
          <source>You should &lt;strong&gt;never&lt;/strong&gt; do any work of your own on the branches that are created by &lt;code&gt;git cvsimport&lt;/code&gt;. By default initial import will create and populate a &quot;master&quot; branch from the CVS repository&amp;rsquo;s main branch which you&amp;rsquo;re free to work with; after that, you need to &lt;code&gt;git merge&lt;/code&gt; incremental imports, or any CVS branches, yourself. It is advisable to specify a named remote via -r to separate and protect the incoming branches.</source>
          <target state="translated">Вы &lt;strong&gt;никогда&lt;/strong&gt; не должны выполнять какую-либо собственную работу с ветками, созданными &lt;code&gt;git cvsimport&lt;/code&gt; . По умолчанию при первоначальном импорте создается и заполняется &amp;laquo;главная&amp;raquo; ветвь из основной ветки репозитория CVS, с которой вы можете свободно работать; после этого вам нужно самостоятельно выполнить &lt;code&gt;git merge&lt;/code&gt; инкрементный импорт или любые ветки CVS. Рекомендуется указать именованный удаленный сервер с помощью -r для разделения и защиты входящих ветвей.</target>
        </trans-unit>
        <trans-unit id="ac5b50c688e69b32b2a523ca6520323d9259e65e" translate="yes" xml:space="preserve">
          <source>You should consider using &lt;code&gt;dcommit&lt;/code&gt; instead of this command. Commit specified commit or tree objects to SVN. This relies on your imported fetch data being up to date. This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit. All merging is assumed to have taken place independently of &lt;code&gt;git svn&lt;/code&gt; functions.</source>
          <target state="translated">Вам следует подумать об использовании &lt;code&gt;dcommit&lt;/code&gt; вместо этой команды. Зафиксировать указанные объекты фиксации или дерева в SVN. Это зависит от актуальности импортированных данных выборки. Это не делает абсолютно никаких попыток исправления при фиксации в SVN, он просто перезаписывает файлы теми, которые указаны в дереве или фиксации. Предполагается, что все слияние происходило независимо от функций &lt;code&gt;git svn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0db0149a7a61b2b34d3de583889773851c606fb" translate="yes" xml:space="preserve">
          <source>You should now compile the checked-out version and test it. If that version works correctly, type</source>
          <target state="translated">Теперь вы должны скомпилировать проверенную версию и протестировать ее.Если эта версия работает корректно,введите</target>
        </trans-unit>
        <trans-unit id="adc89a3f88e3fe44040e1f3bf11644a95272fcdb" translate="yes" xml:space="preserve">
          <source>You should put your personal name, generally a form using a given name and family name. For example, the current maintainer of Git uses &quot;Junio C Hamano&quot;. This will be the name portion that is stored in every commit you make.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce522d2b57e2c5b1484c387e3121e7cf3c762ef" translate="yes" xml:space="preserve">
          <source>You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.</source>
          <target state="translated">Вы должны воздержаться от злоупотребления этой опцией,чтобы тайком внести существенные изменения в фиксацию слияния.Приемлемы небольшие исправления,такие как удаление имени релиза/версии.</target>
        </trans-unit>
        <trans-unit id="de1993c72b3b1ad3dd18c76738408f9f041af6eb" translate="yes" xml:space="preserve">
          <source>You should understand the implications of rewriting history if you amend a commit that has already been published. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.)</source>
          <target state="translated">Вы должны понимать последствия перезаписи истории, если вы изменяете коммит, который уже был опубликован. (См. Раздел &amp;laquo;ВОССТАНОВЛЕНИЕ ИЗ UPSTREAM REBASE&amp;raquo; в &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a5048e0c5c1221139fe969fc6db15713d2b83eb5" translate="yes" xml:space="preserve">
          <source>You should understand the implications of using &lt;code&gt;git rebase&lt;/code&gt; on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below.</source>
          <target state="translated">Вы должны понимать последствия использования &lt;code&gt;git rebase&lt;/code&gt; для общего репозитория. См. Также ВОССТАНОВЛЕНИЕ ИЗ UPSTREAM REBASE ниже.</target>
        </trans-unit>
        <trans-unit id="7550fee71eb33261ce4427a0e3743a34c95d7107" translate="yes" xml:space="preserve">
          <source>You should work through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; before reading this tutorial.</source>
          <target state="translated">Перед чтением этого руководства вы должны &lt;a href=&quot;gittutorial&quot;&gt;изучить gittutorial [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33b464d633d5d3d359d8c081bd1ef24a08ba23d1" translate="yes" xml:space="preserve">
          <source>You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it.</source>
          <target state="translated">Затем вы переносите пучок на другую машину для замены /home/me/tmp/file.bundle и вытаскиваете из него.</target>
        </trans-unit>
        <trans-unit id="98122f0a874f3f8b610fdbc33b228a3b5afee64a" translate="yes" xml:space="preserve">
          <source>You update your working directory from the index by &quot;checking out&quot; files. This is not a very common operation, since normally you&amp;rsquo;d just keep your files updated, and rather than write to your working directory, you&amp;rsquo;d tell the index files about the changes in your working directory (i.e. &lt;code&gt;git update-index&lt;/code&gt;).</source>
          <target state="translated">Вы обновляете свой рабочий каталог из индекса, &amp;laquo;извлекая&amp;raquo; файлы. Это не очень распространенная операция, поскольку обычно вы просто обновляете свои файлы и вместо того, чтобы писать в свой рабочий каталог, вы сообщаете индексным файлам об изменениях в вашем рабочем каталоге (например, &lt;code&gt;git update-index&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="57134770b9c7f61c90927970f67f3d2eceaa4a12" translate="yes" xml:space="preserve">
          <source>You will continue to do your day-to-day work in your personal repository, but periodically &quot;push&quot; changes from your personal repository into your public repository, allowing other developers to pull from that repository. So the flow of changes, in a situation where there is one other developer with a public repository, looks like this:</source>
          <target state="translated">Вы будете продолжать выполнять свою повседневную работу в вашем личном репозитории,но периодически &quot;проталкивать&quot; изменения из вашего личного репозитория в ваше публичное хранилище,позволяя другим разработчикам извлекать изменения из этого хранилища.Таким образом,поток изменений в ситуации,когда есть еще один разработчик с публичным репозиторием,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="cee01be09864f7d5b244e4c87ca6f6106e652b44" translate="yes" xml:space="preserve">
          <source>You will need to run &lt;code&gt;git add --renormalize&lt;/code&gt; to have this take effect. Note that if you are making these changes on a project that is used across platforms, you&amp;rsquo;ll probably want to make it in a per-user configuration file or in the one in &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;, since making it in a &lt;code&gt;.gitattributes&lt;/code&gt; file in the repository will apply to all users of the repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8876e4496883cded62698bb08d4c1d5f289e1dee" translate="yes" xml:space="preserve">
          <source>You will see both of these things throughout the code.</source>
          <target state="translated">Вы увидите обе эти вещи по всему кодексу.</target>
        </trans-unit>
        <trans-unit id="4dda56fbfc3230573e73ab526d0f70db698497a1" translate="yes" xml:space="preserve">
          <source>You will see informational messages on dangling objects. They are objects that still exist in the repository but are no longer referenced by any of your branches, and can (and will) be removed after a while with &lt;code&gt;gc&lt;/code&gt;. You can run &lt;code&gt;git fsck --no-dangling&lt;/code&gt; to suppress these messages, and still view real errors.</source>
          <target state="translated">Вы увидите информационные сообщения о висящих объектах. Это объекты, которые все еще существуют в репозитории, но на которые больше не ссылается ни одна из ваших веток, и могут (и будут) через некоторое время удалены с помощью &lt;code&gt;gc&lt;/code&gt; . Вы можете запустить &lt;code&gt;git fsck --no-dangling&lt;/code&gt; , чтобы подавить эти сообщения и по-прежнему просматривать реальные ошибки.</target>
        </trans-unit>
        <trans-unit id="f2fc4e070409aa778dc2444037511e0ef4801d3d" translate="yes" xml:space="preserve">
          <source>You will see two files, &lt;code&gt;pack-*.pack&lt;/code&gt; and &lt;code&gt;pack-*.idx&lt;/code&gt;, in &lt;code&gt;.git/objects/pack&lt;/code&gt; directory. They are closely related to each other, and if you ever copy them by hand to a different repository for whatever reason, you should make sure you copy them together. The former holds all the data from the objects in the pack, and the latter holds the index for random access.</source>
          <target state="translated">Вы увидите два файла, &lt;code&gt;pack-*.pack&lt;/code&gt; и &lt;code&gt;pack-*.idx&lt;/code&gt; , в каталоге &lt;code&gt;.git/objects/pack&lt;/code&gt; . Они тесно связаны друг с другом, и если вы когда-либо копируете их вручную в другой репозиторий по какой-либо причине, вам следует убедиться, что вы копируете их вместе. Первый содержит все данные от объектов в пакете, а второй содержит индекс для произвольного доступа.</target>
        </trans-unit>
        <trans-unit id="266addba668945d927bfdfb63b85369114140000" translate="yes" xml:space="preserve">
          <source>You will still have to tell people by other means, such as mail. (Git provides the &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to send preformatted pull requests to upstream maintainers to simplify this task.)</source>
          <target state="translated">Вам все равно придется сообщить людям другие средства, например, по почте. (Git предоставляет &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt; для отправки предварительно отформатированных запросов на вытягивание вышестоящим разработчикам, чтобы упростить эту задачу.)</target>
        </trans-unit>
        <trans-unit id="67a2c97a3fe15102ccbc39363d071f9caa744775" translate="yes" xml:space="preserve">
          <source>You would normally use &lt;code&gt;git merge-index&lt;/code&gt; with supplied &lt;code&gt;git merge-one-file&lt;/code&gt; to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge.</source>
          <target state="translated">Обычно вы используете &lt;code&gt;git merge-index&lt;/code&gt; с прилагаемым &lt;code&gt;git merge-one-file&lt;/code&gt; для выполнения этого последнего шага. Сценарий обновляет файлы в рабочем дереве по мере объединения каждого пути и в конце успешного объединения.</target>
        </trans-unit>
        <trans-unit id="acf5d70c570af359d1fc1b3db4b2e1cb44907ec4" translate="yes" xml:space="preserve">
          <source>You wouldn&amp;rsquo;t need to ever change it in gitweb config file.</source>
          <target state="translated">Вам не нужно когда-либо менять его в конфигурационном файле gitweb.</target>
        </trans-unit>
        <trans-unit id="065eff42d50778a1002dd0b7a890143f4063288e" translate="yes" xml:space="preserve">
          <source>You write your current index file to a &quot;tree&quot; object with the program</source>
          <target state="translated">Вы записываете свой текущий индексный файл в &quot;древовидный&quot; объект с программой</target>
        </trans-unit>
        <trans-unit id="49012e7b5c219e4c44033d7ce0ec88b78d68a780" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now initialized the working directory&amp;mdash;​you may notice a new directory created, named &quot;.git&quot;.</source>
          <target state="translated">Теперь вы инициализировали рабочий каталог - вы можете заметить, что создан новый каталог с именем &quot;.git&quot;.</target>
        </trans-unit>
        <trans-unit id="8e4b96aa3f69a0a980be2d48bd9eb2298bc44f3c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now made your first real Git commit. And if you&amp;rsquo;re interested in looking at what &lt;code&gt;git commit&lt;/code&gt; really does, feel free to investigate: it&amp;rsquo;s a few very simple shell scripts to generate the helpful (?) commit message headers, and a few one-liners that actually do the commit itself (&lt;code&gt;git commit&lt;/code&gt;).</source>
          <target state="translated">Теперь вы сделали свой первый настоящий коммит Git. И если вам интересно посмотреть, что на самом деле делает &lt;code&gt;git commit&lt;/code&gt; , не стесняйтесь исследовать: это несколько очень простых сценариев оболочки для генерации полезных (?) Заголовков сообщений фиксации и несколько однострочных сообщений, которые фактически выполняют саму фиксацию ( &lt;code&gt;git commit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6fd65e242e5023949f1979a313cb8892375303bf" translate="yes" xml:space="preserve">
          <source>Your &quot;public repository&quot; is now ready to accept your changes. Come back to the machine you have your private repository. From there, run this command:</source>
          <target state="translated">Ваш &quot;общедоступный репозиторий&quot; теперь готов принять ваши изменения.Возвращайтесь на машину,на которой у вас есть ваше личное хранилище.Оттуда запустите эту команду:</target>
        </trans-unit>
        <trans-unit id="77f5c1536424041eff5dddce9b9dc699480c5921" translate="yes" xml:space="preserve">
          <source>Your private repository&amp;rsquo;s Git directory is usually &lt;code&gt;.git&lt;/code&gt;, but your public repository is often named after the project name, i.e. &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt;. Let&amp;rsquo;s create such a public repository for project &lt;code&gt;my-git&lt;/code&gt;. After logging into the remote machine, create an empty directory:</source>
          <target state="translated">Каталог Git вашего личного репозитория обычно &lt;code&gt;.git&lt;/code&gt; , но ваш публичный репозиторий часто называют в честь имени проекта, то есть &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; . Создадим такой публичный репозиторий для проекта &lt;code&gt;my-git&lt;/code&gt; . После входа на удаленный компьютер создайте пустой каталог:</target>
        </trans-unit>
        <trans-unit id="b96e6decf426a8986abe42a514d0d538e2f36071" translate="yes" xml:space="preserve">
          <source>Your work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven&amp;rsquo;t, then does the right thing. So with the following sequence:</source>
          <target state="translated">Ваше дерево работ по-прежнему основано на вашем HEAD ($ JC), но с тех пор в него внесены некоторые изменения. Трехстороннее слияние гарантирует, что вы не добавляли или не изменяли записи индекса с $ JC, а если нет, то поступает правильно. Итак, в следующей последовательности:</target>
        </trans-unit>
        <trans-unit id="8ff2148494456dea5c056275d6718302d7ecd982" translate="yes" xml:space="preserve">
          <source>Zero or more &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands may be included to update the contents of the branch prior to creating the commit. These commands may be supplied in any order. However it is recommended that a &lt;code&gt;filedeleteall&lt;/code&gt; command precede all &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands in the same commit, as &lt;code&gt;filedeleteall&lt;/code&gt; wipes the branch clean (see below).</source>
          <target state="translated">Ноль или более &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; и &lt;code&gt;notemodify&lt;/code&gt; могут быть включены для обновления содержимого ветки до создания фиксации. Эти команды могут подаваться в любом порядке. Однако рекомендуется, &lt;code&gt;filedeleteall&lt;/code&gt; команда filedeleteall предшествовала всем &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; и &lt;code&gt;notemodify&lt;/code&gt; в одной фиксации, поскольку &lt;code&gt;filedeleteall&lt;/code&gt; очищает ветку (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="480b45cead8c71eaa647209c97491be4a36ea289" translate="yes" xml:space="preserve">
          <source>Zero or more protocol options may be entered after the last &lt;code&gt;push&lt;/code&gt; command, before the batch&amp;rsquo;s terminating blank line.</source>
          <target state="translated">После последней команды &lt;code&gt;push&lt;/code&gt; перед завершающей пустой строкой пакета можно ввести ноль или более параметров протокола .</target>
        </trans-unit>
        <trans-unit id="fbdec3db39874b3b5b75476184662777ddc44fd6" translate="yes" xml:space="preserve">
          <source>[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="b3a075bbccfeeb4bedba2aca4addb159d1acee3d" translate="yes" xml:space="preserve">
          <source>[&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;path&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="d31c8b5c3af548ff2d95f4e227ea28f0f9277441" translate="yes" xml:space="preserve">
          <source>[&amp;lt;refname&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;refname&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="e961d55ee5b355694495464c07c86f7fba23e9a9" translate="yes" xml:space="preserve">
          <source>[--] &amp;lt;path&amp;gt;&amp;hellip;​</source>
          <target state="translated">[-] &amp;lt;путь&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="1eb3d578c1f910d18345d8eb23a781efa2f8d23d" translate="yes" xml:space="preserve">
          <source>[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium work item for: Multi-Pack Index (MIDX)</source>
          <target state="translated">[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Рабочий элемент Chromium для: Multi-Pack Index (MIDX)</target>
        </trans-unit>
        <trans-unit id="25a96ba2d3b7a7d8ee2c18075362c090194ac1d0" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; An earlier RFC for the multi-pack-index feature</source>
          <target state="translated">[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; Более ранний RFC для функции multi-pack-index</target>
        </trans-unit>
        <trans-unit id="347fffb72e72a788a9461ff2e246ae61494e14d7" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 Contributor&amp;rsquo;s summit notes (includes discussion of MIDX)</source>
          <target state="translated">[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Заметки участников саммита Git Merge 2018 (включая обсуждение MIDX)</target>
        </trans-unit>
        <trans-unit id="feea73f842c5a1ec74b307b98128568bae22544a" translate="yes" xml:space="preserve">
          <source>[DEPRECATED: use &lt;code&gt;--rebase-merges&lt;/code&gt; instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved.</source>
          <target state="translated">[УСТАРЕЛО: вместо этого используйте &lt;code&gt;--rebase-merges&lt;/code&gt; ] Воссоздавать коммиты слияния вместо сглаживания истории путем воспроизведения коммитов, которые вводит коммит слияния. Разрешение конфликтов слияния или ручные поправки к коммитам слияния не сохраняются.</target>
        </trans-unit>
        <trans-unit id="a59f280e0e654176579fad979c6b2390d4560b5d" translate="yes" xml:space="preserve">
          <source>[EXPERIMENTAL] Set to &lt;code&gt;true&lt;/code&gt; to use the experimental built-in implementation of the interactive version of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; instead of the Perl script version. Is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">[ЭКСПЕРИМЕНТАЛЬНЫЙ] Установите значение &lt;code&gt;true&lt;/code&gt; , чтобы использовать экспериментальную встроенную реализацию интерактивной версии &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; вместо версии сценария Perl. Является ли &lt;code&gt;false&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f8205d704abeeab8758bae84f0f9eac80a6c4899" translate="yes" xml:space="preserve">
          <source>[NOTE] &lt;code&gt;git rerere&lt;/code&gt; relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, &lt;code&gt;git rerere&lt;/code&gt; may fail to record a conflict resolution. To work around this, the &lt;code&gt;conflict-marker-size&lt;/code&gt; setting in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; can be used.</source>
          <target state="translated">[ПРИМЕЧАНИЕ] &lt;code&gt;git rerere&lt;/code&gt; использует маркеры конфликта в файле для обнаружения конфликта. Если файл уже содержит строки, которые выглядят так же, как строки с маркерами конфликта, &lt;code&gt;git rerere&lt;/code&gt; может не записать разрешение конфликта. Чтобы обойти это, можно использовать настройку &lt;code&gt;conflict-marker-size&lt;/code&gt; в &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac4bc8630c3c03bfd813e3fe5057d1c466974ce5" translate="yes" xml:space="preserve">
          <source>[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;The Economic Impacts of Inadequate Infratructure for Software Testing&lt;/em&gt;. Nist Planning Report 02-3&lt;/a&gt;, see Executive Summary and Chapter 8.</source>
          <target state="translated">[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;Экономические последствия неадекватной инфраструктуры для тестирования программного обеспечения&lt;/em&gt; . Отчет о планировании Nist 02-3&lt;/a&gt; , см. Резюме и главу 8.</target>
        </trans-unit>
        <trans-unit id="e5f919a0494a6ccb56ff39496ebf8651f04232d2" translate="yes" xml:space="preserve">
          <source>[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Code Conventions for the Java Programming Language&lt;/em&gt;. Sun Microsystems.&lt;/a&gt;</source>
          <target state="translated">[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Соглашения о коде для языка программирования Java&lt;/em&gt; . Sun Microsystems.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de6da26d7d92c3d4bdee11d004d96506e88a1b00" translate="yes" xml:space="preserve">
          <source>[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Software maintenance&lt;/em&gt;. Wikipedia.&lt;/a&gt;</source>
          <target state="translated">[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Обслуживание программного обеспечения&lt;/em&gt; . Wikipedia.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a21dac2771422b1ce396ac7103119df3289ef40d" translate="yes" xml:space="preserve">
          <source>[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano. &lt;em&gt;Automated bisect success story&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Джунио Си Хамано. &lt;em&gt;Автоматическая история успеха пополам&lt;/em&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e39006ce98590e4632510795aafbc71a8d5177" translate="yes" xml:space="preserve">
          <source>[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Christian Couder. &lt;em&gt;Fully automated bisecting with &quot;git bisect run&quot;&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Кристиан Кудер. &lt;em&gt;Полностью автоматизированное деление пополам с помощью &quot;git bisect run&quot;&lt;/em&gt; . LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a12b60ab9e79fee2e4613d666532029fdb7e1f4d" translate="yes" xml:space="preserve">
          <source>[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection divides users and developers&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Джонатан Корбет. &lt;em&gt;Разделение пополам разделяет пользователей и разработчиков&lt;/em&gt; . LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb3a1d698c871451809a03759d2052ad730db3fa" translate="yes" xml:space="preserve">
          <source>[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar. &lt;em&gt;Re: BUG 2.6.23-rc3 can&amp;rsquo;t see sd partitions on Alpha&lt;/em&gt;. Linux-kernel mailing list.&lt;/a&gt;</source>
          <target state="translated">[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Инго Мольнар. &lt;em&gt;Re: ОШИБКА 2.6.23-rc3 не может видеть разделы sd на Alpha&lt;/em&gt; . Список рассылки ядра Linux.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91adb50bf54c20a1b51a7a5bd4f97f72154e309d" translate="yes" xml:space="preserve">
          <source>[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano and the git-list. &lt;em&gt;git-bisect(1) Manual Page&lt;/em&gt;. Linux Kernel Archives.&lt;/a&gt;</source>
          <target state="translated">[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Джунио Си Хамано и git-list. &lt;em&gt;git-bisect (1) Страница руководства&lt;/em&gt; . Архивы ядра Linux.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e3bcbb19b635de003c473322577e0da443bd26" translate="yes" xml:space="preserve">
          <source>[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf. &lt;em&gt;bbchop&lt;/em&gt;. GitHub.&lt;/a&gt;</source>
          <target state="translated">[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Элдвульф. &lt;em&gt;bbchop&lt;/em&gt; . GitHub.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4720dfbb1b4c30f403e79c3ea73865f0f4c5faef" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:/~[user]/path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:/~[user]/path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="5995beae7c11faa4cc7064555dea6942a8fa3779" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="8bc9eff643c5f26b1d25ab8fdf5a5ddc87d11ead" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.</source>
          <target state="translated">\ 0 завершение строки при выводе и не заключайте имена файлов в кавычки. Для получения дополнительной информации см. ФОРМАТ ВЫВОДА ниже.</target>
        </trans-unit>
        <trans-unit id="d0b23d6e6728ae49ec5909ad48b79671e7245999" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT below for more information.</source>
          <target state="translated">\ 0 завершение строки при выводе и не заключайте имена файлов в кавычки. См. ВЫХОД ниже для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ec441d8e621550cb4deb96e2b1ad67311ed0768f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; directory that is a &lt;code&gt;bare&lt;/code&gt; repository (i.e. without its own working tree), that is typically used for exchanging histories with others by pushing into it and fetching from it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; каталог , который является &lt;code&gt;bare&lt;/code&gt; хранилищем (т.е. без его собственного рабочего дерева), который обычно используется для обмена историй с другими, нажав на него , и извлечение из него.</target>
        </trans-unit>
        <trans-unit id="ea844fb65222d001b2e2f561d577c3d6a932db4a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;.git&lt;/code&gt; directory at the root of the working tree;</source>
          <target state="translated">&lt;code&gt;.git&lt;/code&gt; каталог в корне рабочего дерева;</target>
        </trans-unit>
        <trans-unit id="f0d4bf33608fee8383e25a39f62fec37be3db742" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;lot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc234069c4e3ee03ef8f7670cb491ed5411b65b6" translate="yes" xml:space="preserve">
          <source>a NUL (only exists if renamed/copied);</source>
          <target state="translated">NUL (существует только в случае переименования/копирования);</target>
        </trans-unit>
        <trans-unit id="079f5a842faae1ecf0933e998354e66093295bb8" translate="yes" xml:space="preserve">
          <source>a NUL.</source>
          <target state="translated">NUL.</target>
        </trans-unit>
        <trans-unit id="e9278592288a5c5c028d9d1d04c2201af670c4f7" translate="yes" xml:space="preserve">
          <source>a URL like &quot;git://example.org/path/to/repo.git&quot; will be rewritten to &quot;ssh://example.org/path/to/repo.git&quot; for pushes, but pulls will still use the original URL.</source>
          <target state="translated">URL типа &quot;git://example.org/path/to/repo.git&quot; будет переписан на &quot;ssh://example.org/path/to/repo.git&quot; для pushhes,но pulls все равно будет использовать оригинальный URL.</target>
        </trans-unit>
        <trans-unit id="96a7d2b2a7356a40bc207f3d1e0038c9f743ef8f" translate="yes" xml:space="preserve">
          <source>a URL like &quot;work:repo.git&quot; or like &quot;host.xz:/path/to/repo.git&quot; will be rewritten in any context that takes a URL to be &quot;git://git.host.xz/repo.git&quot;.</source>
          <target state="translated">URL типа &quot;work:repo.git&quot; или типа &quot;host.xz:/path/to/repo.git&quot; будет переписан в любом контексте,который принимает URL как &quot;git://git.host.xz/repo.git&quot;.</target>
        </trans-unit>
        <trans-unit id="da90a472a42edab28f6103dd507b377a59e39919" translate="yes" xml:space="preserve">
          <source>a colon.</source>
          <target state="translated">двоеточие.</target>
        </trans-unit>
        <trans-unit id="07112c294a121f7cc6ed6654ce50e53f206b098f" translate="yes" xml:space="preserve">
          <source>a comment describing this commit.</source>
          <target state="translated">комментарий,описывающий этот коммит.</target>
        </trans-unit>
        <trans-unit id="6fd45c543fb44740f3ae2218676d1d2f809372d6" translate="yes" xml:space="preserve">
          <source>a committer: The name of the person who actually created the commit, with the date it was done. This may be different from the author, for example, if the author was someone who wrote a patch and emailed it to the person who used it to create the commit.</source>
          <target state="translated">коммиттером:Имя человека,который на самом деле создал коммит,с датой,когда он был сделан.Это может отличаться от автора,например,если автором был кто-то,кто написал патч и отправил его по электронной почте человеку,который использовал его для создания коммита.</target>
        </trans-unit>
        <trans-unit id="475363380919fa9dad3daaa5151af4a7ecf7fe63" translate="yes" xml:space="preserve">
          <source>a file called &lt;code&gt;HEAD&lt;/code&gt;, that has &lt;code&gt;ref: refs/heads/master&lt;/code&gt; in it. This is similar to a symbolic link and points at &lt;code&gt;refs/heads/master&lt;/code&gt; relative to the &lt;code&gt;HEAD&lt;/code&gt; file.</source>
          <target state="translated">файл с именем &lt;code&gt;HEAD&lt;/code&gt; , в котором есть &lt;code&gt;ref: refs/heads/master&lt;/code&gt; . Это похоже на символическую ссылку и указывает на &lt;code&gt;refs/heads/master&lt;/code&gt; относительно файла &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956892125b0edbb5f2b693d0431acccf4dd5c1cd" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; directory.</source>
          <target state="translated">файл в &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8f92bb4f6fe9e686ed78d483dc8804c1d0837c" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; directory, or</source>
          <target state="translated">файл в &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; , или</target>
        </trans-unit>
        <trans-unit id="6fb331171394d95fbb7a35c4b995f2a83f23618c" translate="yes" xml:space="preserve">
          <source>a file that has &lt;code&gt;any&lt;/code&gt; difference what-so-ever in the three trees will stay as separate entries in the index. It&amp;rsquo;s up to &quot;porcelain policy&quot; to determine how to remove the non-0 stages, and insert a merged version.</source>
          <target state="translated">файл, который имеет &lt;code&gt;any&lt;/code&gt; различие в трех деревьях, останется в индексе как отдельные записи. Это дело &amp;laquo;фарфоровой политики&amp;raquo;, чтобы определить, как удалить этапы, отличные от 0, и вставить объединенную версию.</target>
        </trans-unit>
        <trans-unit id="fcb1d336b0be584d8054e8f7d63b3480aea0ee1d" translate="yes" xml:space="preserve">
          <source>a function called &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt;, typically defined in &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (note that older versions of Git used to have it in &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; instead), and declared in &lt;code&gt;builtin.h&lt;/code&gt;.</source>
          <target state="translated">функция с именем &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt; , обычно определяемая в &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (обратите внимание, что в старых версиях Git она использовалась вместо &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; ) и объявлялась в &lt;code&gt;builtin.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d20b77e1575c57d2803f17741070661ffe1f7923" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;Index: &quot;</source>
          <target state="translated">строка,которая начинается с &quot;Индекса&quot;:&quot;</target>
        </trans-unit>
        <trans-unit id="eac485dbe3dc8258452b85ab1fdc03917425590f" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;diff -&quot;, or</source>
          <target state="translated">строка,которая начинается с &quot;diff -&quot;,или</target>
        </trans-unit>
        <trans-unit id="8cb077e79c6b205418cec26b6f4930fe1ae56b3b" translate="yes" xml:space="preserve">
          <source>a newline.</source>
          <target state="translated">новую линию.</target>
        </trans-unit>
        <trans-unit id="678e3fa85625ddb634df3223f890cd55081ea7cd" translate="yes" xml:space="preserve">
          <source>a raw &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">необработанный &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a839de3aabe2c207992e1add851477714b9c5e" translate="yes" xml:space="preserve">
          <source>a remote in the Git configuration file: &lt;code&gt;$GIT_DIR/config&lt;/code&gt;,</source>
          <target state="translated">пульт в файле конфигурации Git: &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f9af7071efb1bd7dd22ebf85f05d8810442b8586" translate="yes" xml:space="preserve">
          <source>a space between time and time zone</source>
          <target state="translated">промежуток между временем и часовым поясом</target>
        </trans-unit>
        <trans-unit id="65b604e2f985f7317d6866f6730d409a3832783e" translate="yes" xml:space="preserve">
          <source>a space instead of the &lt;code&gt;T&lt;/code&gt; date/time delimiter</source>
          <target state="translated">пробел вместо разделителя даты / времени &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bc00ebd3440c4f401b07128f1c136e115562dd8" translate="yes" xml:space="preserve">
          <source>a space.</source>
          <target state="translated">место.</target>
        </trans-unit>
        <trans-unit id="97a7ee5f8a960df69981e9527fa176cfdf9705cf" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;objects&lt;/code&gt;, which will contain all the objects of your project. You should never have any real reason to look at the objects directly, but you might want to know that these objects are what contains all the real &lt;code&gt;data&lt;/code&gt; in your repository.</source>
          <target state="translated">подкаталог с именем &lt;code&gt;objects&lt;/code&gt; , который будет содержать все объекты вашего проекта. У вас никогда не должно быть реальной причины смотреть на объекты напрямую, но вы можете знать, что именно эти объекты содержат все реальные &lt;code&gt;data&lt;/code&gt; в вашем репозитории.</target>
        </trans-unit>
        <trans-unit id="045a27e5aab449465c7a517674ebf98a06438921" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;refs&lt;/code&gt;, which contains references to objects.</source>
          <target state="translated">подкаталог с именем &lt;code&gt;refs&lt;/code&gt; , содержащий ссылки на объекты.</target>
        </trans-unit>
        <trans-unit id="03097f133fc01ec710880af30fddc9a8cd7c34db" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used.</source>
          <target state="translated">табуляция или NUL при использовании опции &lt;code&gt;-z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9346da07fb77dd97b82dc62a47eb3edc36d2b7a0" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used; only exists for C or R.</source>
          <target state="translated">табуляция или NUL при использовании опции &lt;code&gt;-z&lt;/code&gt; ; существует только для C или R.</target>
        </trans-unit>
        <trans-unit id="c40734bc76bdc997f13a3bade66db88cc0dc137e" translate="yes" xml:space="preserve">
          <source>a tab;</source>
          <target state="translated">закладка;</target>
        </trans-unit>
        <trans-unit id="19150edbe2f84d3c01f8f24ddf7de6b06a212def" translate="yes" xml:space="preserve">
          <source>a tree: The SHA-1 name of a tree object (as defined below), representing the contents of a directory at a certain point in time.</source>
          <target state="translated">дерево:SHA-1 имя объекта дерева (как определено ниже),представляющего содержимое директории в определенный момент времени.</target>
        </trans-unit>
        <trans-unit id="013edfaa8480f23dc64a9a565714902a0f70e19a" translate="yes" xml:space="preserve">
          <source>a valid head &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">допустимое &lt;code&gt;name&lt;/code&gt; &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; (т.е. ссылка refs / heads / &amp;lt;head&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="c3796b26d9f35f82d5c7ba0548ce633809586698" translate="yes" xml:space="preserve">
          <source>a valid tag &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">допустимое &lt;code&gt;name&lt;/code&gt; тега (например, ссылка &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fdbf716e8cd4fd3ff778984618bbe33ffeee814c" translate="yes" xml:space="preserve">
          <source>a) are ancestor of the &quot;bad&quot; commit (including the &quot;bad&quot; commit itself), b) are not ancestor of a &quot;good&quot; commit (excluding the &quot;good&quot; commits).</source>
          <target state="translated">a)являются предком &quot;плохого&quot; коммита (включая сам &quot;плохой&quot; коммит),b)не являются предком &quot;хорошего&quot; коммита (исключая &quot;хорошие&quot; коммиты).</target>
        </trans-unit>
        <trans-unit id="8682c02d1bc4bfce128a794497013605d86c32b6" translate="yes" xml:space="preserve">
          <source>a) regular use</source>
          <target state="translated">а)регулярное использование</target>
        </trans-unit>
        <trans-unit id="4ff2759bc14568ced83be0be38a4abafea668a32" translate="yes" xml:space="preserve">
          <source>abbreviated commit hash</source>
          <target state="translated">сокращённое обязательство хэш</target>
        </trans-unit>
        <trans-unit id="83baab4c4f5445b3450e34e24f8066fea1ac11f2" translate="yes" xml:space="preserve">
          <source>abbreviated parent hashes</source>
          <target state="translated">сокращённые скобки</target>
        </trans-unit>
        <trans-unit id="33579b1cb5338205dc784843012a5c0a9e8cacae" translate="yes" xml:space="preserve">
          <source>abbreviated tree hash</source>
          <target state="translated">укороченный древесный гашиш</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="832e60dfe198126ed45442b9d54f0a366515eefc" translate="yes" xml:space="preserve">
          <source>absorbgitdirs</source>
          <target state="translated">absorbgitdirs</target>
        </trans-unit>
        <trans-unit id="f412f21dd1d844e9ed4c1cbd73b06dc725c5d8bd" translate="yes" xml:space="preserve">
          <source>access method (one of &quot;ext&quot; or &quot;pserver&quot;)</source>
          <target state="translated">способ доступа (один из &quot;ext&quot; или &quot;pserver&quot;)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="6d8bcdb6bdc1c6a236c5092142b208eb67008cee" translate="yes" xml:space="preserve">
          <source>add &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</source>
          <target state="translated">добавить &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="89052c7d90a34c914815c621a3c8abaf890dfcb5" translate="yes" xml:space="preserve">
          <source>add [-b &amp;lt;branch&amp;gt;] [-f|--force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [--] &amp;lt;repository&amp;gt; [&amp;lt;path&amp;gt;]</source>
          <target state="translated">добавить [-b &amp;lt;ветка&amp;gt;] [-f | --force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [-] &amp;lt;repository&amp;gt; [&amp;lt;путь &amp;gt;]</target>
        </trans-unit>
        <trans-unit id="96b545065b00a5b7501087e2c1e93926449febd5" translate="yes" xml:space="preserve">
          <source>add a missing &lt;code&gt;\n&lt;/code&gt; to the last line if necessary.</source>
          <target state="translated">при необходимости добавьте отсутствующий &lt;code&gt;\n&lt;/code&gt; в последнюю строку.</target>
        </trans-unit>
        <trans-unit id="90bc127779a3e8fd8565532d33e4a134cd45f11d" translate="yes" xml:space="preserve">
          <source>add everything under the current directory.</source>
          <target state="translated">добавить все под текущую директорию.</target>
        </trans-unit>
        <trans-unit id="cb81f0f2d76a3c8759a19442b315f5c3a72e8b01" translate="yes" xml:space="preserve">
          <source>add untracked</source>
          <target state="translated">добавить бесследный</target>
        </trans-unit>
        <trans-unit id="c22e3f3bd42e15a0bc002a5cba9cb2e9cb547df3" translate="yes" xml:space="preserve">
          <source>add.ignore-errors (deprecated)</source>
          <target state="translated">add.ignore-errors (устаревшие)</target>
        </trans-unit>
        <trans-unit id="0d6211d85b6c5ebebd00bc700587b97d87d96f79" translate="yes" xml:space="preserve">
          <source>add.ignoreErrors</source>
          <target state="translated">add.ignoreErrors</target>
        </trans-unit>
        <trans-unit id="47d07ea3a984d5f17b8a52280b424c7e874d91e2" translate="yes" xml:space="preserve">
          <source>add.interactive.useBuiltin</source>
          <target state="translated">add.interactive.useBuiltin</target>
        </trans-unit>
        <trans-unit id="e441bfa1c3e8c860d35d02080c0d58234a3dc31b" translate="yes" xml:space="preserve">
          <source>addEmbeddedRepo</source>
          <target state="translated">addEmbeddedRepo</target>
        </trans-unit>
        <trans-unit id="5fba0af68b4dc6017c79ff69ba4b3844f76b2dc5" translate="yes" xml:space="preserve">
          <source>addEmptyPathspec</source>
          <target state="translated">addEmptyPathspec</target>
        </trans-unit>
        <trans-unit id="a9b80c1de3c9ac007c7c119f277608c2e2a51269" translate="yes" xml:space="preserve">
          <source>addIgnoredFile</source>
          <target state="translated">addIgnoredFile</target>
        </trans-unit>
        <trans-unit id="ceb99972d01848a4af9e45ab5cd53f0d9ea700b4" translate="yes" xml:space="preserve">
          <source>added content</source>
          <target state="translated">добавленное содержимое</target>
        </trans-unit>
        <trans-unit id="782f82176de20dd76d4373d2acfc3406073964ff" translate="yes" xml:space="preserve">
          <source>adding context (&quot; &quot;) or removal (&quot;-&quot;) lines</source>
          <target state="translated">добавление строк контекста (&quot; &quot;)или удаление (&quot;-&quot;)</target>
        </trans-unit>
        <trans-unit id="39de4cfc4c6e6827c5f11475b89460e1b545a7f9" translate="yes" xml:space="preserve">
          <source>adds the following to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">добавляет в &lt;code&gt;.git/config&lt;/code&gt; следующее :</target>
        </trans-unit>
        <trans-unit id="f6acb502d3f3dcf967568ec1f1f05756c7001015" translate="yes" xml:space="preserve">
          <source>advice.*</source>
          <target state="translated">advice.*</target>
        </trans-unit>
        <trans-unit id="0608c4054662dd902e1314f7e450e3eaa81c1143" translate="yes" xml:space="preserve">
          <source>agent</source>
          <target state="translated">agent</target>
        </trans-unit>
        <trans-unit id="dc642557f3a1ed15b666c3bf8c010e9d1bceffe0" translate="yes" xml:space="preserve">
          <source>alias.*</source>
          <target state="translated">alias.*</target>
        </trans-unit>
        <trans-unit id="16f3bac085c702b24dd56dd8fdf474c5d21e6639" translate="yes" xml:space="preserve">
          <source>alice and cindy can push into master, only bob can push into doc-update. david is the release manager and is the only person who can create and push version tags.</source>
          <target state="translated">alice и Cindy могут проталкивать в мастер,только bob может проталкивать в doc-update.david является менеджером релизов и единственным человеком,который может создавать и проталкивать теги версий.</target>
        </trans-unit>
        <trans-unit id="ae21c64a87f6bb0b8e16e55c48be4cc638d7bd3f" translate="yes" xml:space="preserve">
          <source>align</source>
          <target state="translated">align</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="29702e41afdcf565d852a6355913f10360a2f8b0" translate="yes" xml:space="preserve">
          <source>all parent object ids</source>
          <target state="translated">идентификаторы всех родительских объектов</target>
        </trans-unit>
        <trans-unit id="6664a4a284b9aeecc837369fce6272fe3547f795" translate="yes" xml:space="preserve">
          <source>allow-indentation-change</source>
          <target state="translated">allow-indentation-change</target>
        </trans-unit>
        <trans-unit id="890c8ad25c4c255f4dda7bba71ccde4b6eb54f1a" translate="yes" xml:space="preserve">
          <source>allows you to browse any commits from the last 2 weeks of commits that modified files under the &quot;drivers&quot; directory. (Note: you can adjust gitk&amp;rsquo;s fonts by holding down the control key while pressing &quot;-&quot; or &quot;+&quot;.)</source>
          <target state="translated">позволяет вам просматривать любые коммиты за последние 2 недели, которые изменяли файлы в каталоге &quot;drivers&quot;. (Примечание: вы можете настроить шрифты gitk, удерживая клавишу Control и одновременно нажимая &amp;laquo;-&amp;raquo; или &amp;laquo;+&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="8733169fb7d8912aa579031eed0a4b26ef5718fe" translate="yes" xml:space="preserve">
          <source>alternate object database</source>
          <target state="translated">БД альтернативного объекта</target>
        </trans-unit>
        <trans-unit id="385d97ddc2cf0f165b1e517e2de9a74c662d0d92" translate="yes" xml:space="preserve">
          <source>alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.</source>
          <target state="translated">альтернативный:абсолютный путь к базам данных альтернативных объектов;может появляться несколько раз,по одной строке на каждый путь.Обратите внимание,что если путь содержит непечатаемые символы,то он может быть окружен двойными кавычками и содержать обратно зашифрованные экранирующие последовательности в стиле C.</target>
        </trans-unit>
        <trans-unit id="459a9aeba984b09598ccfb2133b8ae65d179153d" translate="yes" xml:space="preserve">
          <source>although the full, 40-character SHA-1s would be supplied. If the foreign ref does not yet exist the &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If a ref is to be deleted, the &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; will be supplied as &lt;code&gt;(delete)&lt;/code&gt; and the &lt;code&gt;&amp;lt;local
SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If the local commit was specified by something other than a name which could be expanded (such as &lt;code&gt;HEAD~&lt;/code&gt;, or a SHA-1) it will be supplied as it was originally given.</source>
          <target state="translated">хотя будут предоставлены полные 40-символьные SHA-1. Если внешняя ссылка еще не существует, &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; будет 40 &lt;code&gt;0&lt;/code&gt; . Если ссылка должна быть удалена, &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; будет предоставлен как &lt;code&gt;(delete)&lt;/code&gt; а &lt;code&gt;&amp;lt;local SHA-1&amp;gt;&lt;/code&gt; будет равен 40 &lt;code&gt;0&lt;/code&gt; . Если локальная фиксация была указана чем-то другим, кроме имени, которое может быть расширено (например, &lt;code&gt;HEAD~&lt;/code&gt; или SHA-1), оно будет предоставлено в том виде, в котором оно было изначально задано.</target>
        </trans-unit>
        <trans-unit id="b16bb5afab4c1802eaeada40ac59f4ec78c01be8" translate="yes" xml:space="preserve">
          <source>always show in columns</source>
          <target state="translated">всегда показываться колонками</target>
        </trans-unit>
        <trans-unit id="b0c4ba6a734338f8b0a5e21fcbb05d3afcd198af" translate="yes" xml:space="preserve">
          <source>always shows the difference between the HEAD and the index file&amp;mdash;​this is what you&amp;rsquo;d commit if you created the commit now&amp;mdash;​and that</source>
          <target state="translated">всегда показывает разницу между HEAD и индексным файлом - это то, что вы бы зафиксировали, если бы создали фиксацию сейчас - и что</target>
        </trans-unit>
        <trans-unit id="96e8155732e8324ae26f64d4516eb6fe696ac84f" translate="yes" xml:space="preserve">
          <source>am</source>
          <target state="translated">am</target>
        </trans-unit>
        <trans-unit id="400226a3b8758d7d662c424a478d16cceecd29ed" translate="yes" xml:space="preserve">
          <source>am.keepcr</source>
          <target state="translated">am.keepcr</target>
        </trans-unit>
        <trans-unit id="80b11664f9cdc0c4da5b2cf9cbae91e78f24cb5f" translate="yes" xml:space="preserve">
          <source>am.threeWay</source>
          <target state="translated">am.threeWay</target>
        </trans-unit>
        <trans-unit id="d9de89ed653daadc282d17fa341547ccd80f5e0c" translate="yes" xml:space="preserve">
          <source>amWorkDir</source>
          <target state="translated">amWorkDir</target>
        </trans-unit>
        <trans-unit id="b1cc99b811681fb579eeabe4a14a5e1ec1bab455" translate="yes" xml:space="preserve">
          <source>amend the previous commit, adding all your new changes, using your original message.</source>
          <target state="translated">изменить предыдущий коммит,добавить все новые изменения,используя оригинальное сообщение.</target>
        </trans-unit>
        <trans-unit id="461152b367e8ab9740fb2e9ee2da4d7175e9e2a2" translate="yes" xml:space="preserve">
          <source>an LF or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used, to terminate the record.</source>
          <target state="translated">LF или NUL при использовании параметра &lt;code&gt;-z&lt;/code&gt; для завершения записи.</target>
        </trans-unit>
        <trans-unit id="75eada615f3da2b986734d58bb672366de760679" translate="yes" xml:space="preserve">
          <source>an author: The name of the person responsible for this change, together with its date.</source>
          <target state="translated">автор:Имя лица,ответственного за это изменение,вместе с его датой.</target>
        </trans-unit>
        <trans-unit id="b441fe44ea3ab3bff759abb792c8a7f4c7974b0c" translate="yes" xml:space="preserve">
          <source>an entry in &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">запись в &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; в &lt;code&gt;Makefile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d25597e1ded62863dd59e418a49b42af285a609" translate="yes" xml:space="preserve">
          <source>an entry in the &lt;code&gt;commands[]&lt;/code&gt; array in &lt;code&gt;git.c&lt;/code&gt;, and</source>
          <target state="translated">запись в массиве &lt;code&gt;commands[]&lt;/code&gt; в &lt;code&gt;git.c&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="5037f82b8aa7002eda9aed7d8c0898525bc2f00d" translate="yes" xml:space="preserve">
          <source>and Git will continue applying the rest of the patches.</source>
          <target state="translated">и Гит продолжит применение остальных патчей.</target>
        </trans-unit>
        <trans-unit id="b3b2e45f7b37ac14dc28b61e29aee3c419229fda" translate="yes" xml:space="preserve">
          <source>and Git will create the commit for you and continue applying the remaining patches from the mailbox.</source>
          <target state="translated">и Git создаст для вас коммит и продолжит применение оставшихся патчей из почтового ящика.</target>
        </trans-unit>
        <trans-unit id="7067f391e9f25da3da4a562c780b468101adb659" translate="yes" xml:space="preserve">
          <source>and Git will prompt you for a commit message and then create the new commit. Check to make sure it looks like what you expected with</source>
          <target state="translated">и Git запросит у вас сообщение о фиксации,а затем создаст новый коммит.Проверьте,выглядит ли сообщение так,как вы ожидали.</target>
        </trans-unit>
        <trans-unit id="11bda7867b55ea900931dbe2ab8c87a36a0443d9" translate="yes" xml:space="preserve">
          <source>and bundle topic branches still cooking.</source>
          <target state="translated">и объединять тематические ветки,которые еще готовят.</target>
        </trans-unit>
        <trans-unit id="06675e26cc6f5bedf7b0e9b9d71e33fb64fa4ef8" translate="yes" xml:space="preserve">
          <source>and email them.</source>
          <target state="translated">и отправить их по электронной почте.</target>
        </trans-unit>
        <trans-unit id="d5d63b233efdc161b2104f0e091d210beeb2fe60" translate="yes" xml:space="preserve">
          <source>and hack away. The equivalent of &lt;code&gt;cvs update&lt;/code&gt; is</source>
          <target state="translated">и взломать. Эквивалент &lt;code&gt;cvs update&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4b59596148297f0688711ac4f92721dbc18215b" translate="yes" xml:space="preserve">
          <source>and if it detects that the file &quot;file0&quot; is completely rewritten, it changes it to:</source>
          <target state="translated">и если он обнаруживает,что файл &quot;file0&quot; полностью переписан,он меняет его на другой:</target>
        </trans-unit>
        <trans-unit id="e1426704be98b9dd3d938c5a6a31b3fe4ee9a995" translate="yes" xml:space="preserve">
          <source>and in fact a lot of the common Git command combinations can be scripted with the &lt;code&gt;git xyz&lt;/code&gt; interfaces. You can learn things by just looking at what the various git scripts do. For example, &lt;code&gt;git reset&lt;/code&gt; used to be the above two lines implemented in &lt;code&gt;git reset&lt;/code&gt;, but some things like &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; are slightly more complex scripts around the basic Git commands.</source>
          <target state="translated">и на самом деле многие стандартные комбинации команд Git могут быть написаны с помощью интерфейсов &lt;code&gt;git xyz&lt;/code&gt; . Вы можете узнать многое, просто посмотрев, что делают различные сценарии git. Например, &lt;code&gt;git reset&lt;/code&gt; - это две приведенные выше строки, реализованные в &lt;code&gt;git reset&lt;/code&gt; , но некоторые вещи, такие как &lt;code&gt;git status&lt;/code&gt; и &lt;code&gt;git commit&lt;/code&gt; , представляют собой несколько более сложные сценарии вокруг основных команд Git.</target>
        </trans-unit>
        <trans-unit id="c2f880dab39040d1bcbb6d73323cfccc9f1141f6" translate="yes" xml:space="preserve">
          <source>and it is assumed unchanged.</source>
          <target state="translated">и предполагается,что она не изменилась.</target>
        </trans-unit>
        <trans-unit id="6fdb49363e42ba495e98dac786aceef7ea588734" translate="yes" xml:space="preserve">
          <source>and it will be gone. There&amp;rsquo;s no external repository, and there&amp;rsquo;s no history outside the project you created.</source>
          <target state="translated">и его не будет. Нет внешнего репозитория и нет истории вне созданного вами проекта.</target>
        </trans-unit>
        <trans-unit id="14be792a7fbd836c220980afe820c5835c201a25" translate="yes" xml:space="preserve">
          <source>and it would create the new branch &lt;code&gt;mybranch&lt;/code&gt; at the earlier commit, and check out the state at that time.</source>
          <target state="translated">и он создаст новую ветку &lt;code&gt;mybranch&lt;/code&gt; при предыдущей фиксации и проверит состояние в это время.</target>
        </trans-unit>
        <trans-unit id="fb7e74a8bf932246eae1a7c59b5aab5d50647a84" translate="yes" xml:space="preserve">
          <source>and its path_info based equivalent</source>
          <target state="translated">и его эквивалент,основанный на информации о пути</target>
        </trans-unit>
        <trans-unit id="a6415488fda4ace1ca3739dceaaf3db60a5dafcb" translate="yes" xml:space="preserve">
          <source>and just looked for the sha of the missing object (4b9458b) in that whole thing. It&amp;rsquo;s up to you&amp;mdash;​Git does &lt;strong&gt;have&lt;/strong&gt; a lot of information, it is just missing one particular blob version.</source>
          <target state="translated">и просто искал sha отсутствующего объекта (4b9458b) во всем этом. Это до Вы- Git действительно &lt;strong&gt;есть&lt;/strong&gt; много информации, это просто не хватает одной конкретной версии блоб.</target>
        </trans-unit>
        <trans-unit id="eb603cb6e80c68fe39b18e84f04c311f5ab01061" translate="yes" xml:space="preserve">
          <source>and make the shared repository writable by the group.</source>
          <target state="translated">и сделать общий репозиторий доступным для записи группой.</target>
        </trans-unit>
        <trans-unit id="40981e3225f4d7efce8a1f1ac883a144a32ed884" translate="yes" xml:space="preserve">
          <source>and once you&amp;rsquo;re happy with your manual merge, just do a</source>
          <target state="translated">и когда вы будете довольны своим ручным слиянием, просто выполните</target>
        </trans-unit>
        <trans-unit id="f6523905096e4cb79385536bede182fe1d21d437" translate="yes" xml:space="preserve">
          <source>and optionally give a branch-name for the remote end as a second argument.</source>
          <target state="translated">и,опционально,дать имя ветки для удаленного конца в качестве второго аргумента.</target>
        </trans-unit>
        <trans-unit id="1f7c0eb7c2d3e76709e99a0799e2c00adb5d4360" translate="yes" xml:space="preserve">
          <source>and running &lt;code&gt;git config section.Subsection.key value2&lt;/code&gt; will result in</source>
          <target state="translated">и запуск &lt;code&gt;git config section.Subsection.key value2&lt;/code&gt; приведет к</target>
        </trans-unit>
        <trans-unit id="b8d13d365846b56f54fcde0e313df5ef17ad9601" translate="yes" xml:space="preserve">
          <source>and see two files:</source>
          <target state="translated">и увидеть два файла:</target>
        </trans-unit>
        <trans-unit id="1846440a645e968f28127df0e1b2bcc1010c9293" translate="yes" xml:space="preserve">
          <source>and that is what higher level &lt;code&gt;git merge -s resolve&lt;/code&gt; is implemented with.</source>
          <target state="translated">и это то, с чем реализовано &lt;code&gt;git merge -s resolve&lt;/code&gt; более высокого уровня .</target>
        </trans-unit>
        <trans-unit id="dbbcc5be724df383b84cd8c32e02ab45353e6975" translate="yes" xml:space="preserve">
          <source>and the &quot;parent&quot; object refers to the previous commit:</source>
          <target state="translated">а &quot;родительский&quot; объект ссылается на предыдущий коммит:</target>
        </trans-unit>
        <trans-unit id="4982e2ffe4444f7d8ccaa2ccbbc307cc4fa3f8c7" translate="yes" xml:space="preserve">
          <source>and the contents of the deleted file fileX is similar enough to the contents of the created file file0, then rename detection merges these filepairs and creates:</source>
          <target state="translated">и содержимое удаленного файла fileX достаточно похоже на содержимое созданного файла file0,затем определение переименования объединяет эти пары файлов и создает их:</target>
        </trans-unit>
        <trans-unit id="3cf2f14796ecd3906febf042b64b0f6c0a0234bc" translate="yes" xml:space="preserve">
          <source>and the contents of these files is just the compressed data plus a header identifying their length and their type. The type is either a blob, a tree, a commit, or a tag.</source>
          <target state="translated">а содержимым этих файлов являются только сжатые данные плюс заголовок,определяющий их длину и тип.Тип-это либо капля,либо дерево,либо коммит,либо тег.</target>
        </trans-unit>
        <trans-unit id="97b7ea8f565fdb4b8f72207a4543ec3a6beb2426" translate="yes" xml:space="preserve">
          <source>and the new object name to be stored in the ref.</source>
          <target state="translated">и новое имя объекта,которое будет сохранено в справочнике.</target>
        </trans-unit>
        <trans-unit id="06596f8fbe14d561db35acf97529690afeae6531" translate="yes" xml:space="preserve">
          <source>and the result of &lt;code&gt;git merge-base A M&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;. Commit &lt;code&gt;2&lt;/code&gt; is also a common ancestor between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;M&lt;/code&gt;, but &lt;code&gt;1&lt;/code&gt; is a better common ancestor, because &lt;code&gt;2&lt;/code&gt; is an ancestor of &lt;code&gt;1&lt;/code&gt;. Hence, &lt;code&gt;2&lt;/code&gt; is not a merge base.</source>
          <target state="translated">а результат &lt;code&gt;git merge-base A M&lt;/code&gt; равен &lt;code&gt;1&lt;/code&gt; . Коммит &lt;code&gt;2&lt;/code&gt; также является общим предком между &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;M&lt;/code&gt; , но &lt;code&gt;1&lt;/code&gt; - лучший общий предок, потому что &lt;code&gt;2&lt;/code&gt; является предком &lt;code&gt;1&lt;/code&gt; . Следовательно, &lt;code&gt;2&lt;/code&gt; не является базой слияния.</target>
        </trans-unit>
        <trans-unit id="bf29b3f3be3e9d8f538aa9b7974f9c3a714fd3f2" translate="yes" xml:space="preserve">
          <source>and then annotate the change between the commit and its parents, using &lt;code&gt;commit^!&lt;/code&gt; notation:</source>
          <target state="translated">а затем аннотируйте изменения между коммитом и его родителями, используя &lt;code&gt;commit^!&lt;/code&gt; обозначения:</target>
        </trans-unit>
        <trans-unit id="3d8806f072cf60f02c7512a460d821442ce16fa0" translate="yes" xml:space="preserve">
          <source>and then giving the reason for the commit on stdin (either through redirection from a pipe or file, or by just typing it at the tty).</source>
          <target state="translated">и затем объяснить причину коммита на stdin (либо путем перенаправления из трубы или файла,либо просто набрав его в tty).</target>
        </trans-unit>
        <trans-unit id="2fd91a322e9e060ddc98865e40de279b845a572c" translate="yes" xml:space="preserve">
          <source>and then he just cut-and-pastes the output commands after verifying that they look OK.</source>
          <target state="translated">а затем он просто вырезает и пропускает выходные команды после проверки,что они выглядят нормально.</target>
        </trans-unit>
        <trans-unit id="b658ed87bd1868d8fc441785cf7c93c3c281001b" translate="yes" xml:space="preserve">
          <source>and then moving BFC after BBC and squashing it.</source>
          <target state="translated">а затем переместить BFC после BBC и раздавить его.</target>
        </trans-unit>
        <trans-unit id="339c37a1cbc67af9c8927014dc829b0049bb4b31" translate="yes" xml:space="preserve">
          <source>and then untar the new code in the working tree. Alternately you could &lt;code&gt;rsync&lt;/code&gt; the changes into the working tree.</source>
          <target state="translated">а затем распаковать новый код в рабочем дереве. В качестве альтернативы вы можете &lt;code&gt;rsync&lt;/code&gt; изменения в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="617666725e1b9f6239b44390652378dd9926ce18" translate="yes" xml:space="preserve">
          <source>and these are evaluated in this order.</source>
          <target state="translated">и они оцениваются в таком порядке.</target>
        </trans-unit>
        <trans-unit id="9adeb030984d30c37dccabf36290b3a5065c7248" translate="yes" xml:space="preserve">
          <source>and they&amp;rsquo;ll be gone. (You should only run &lt;code&gt;git prune&lt;/code&gt; on a quiescent repository&amp;mdash;​it&amp;rsquo;s kind of like doing a filesystem fsck recovery: you don&amp;rsquo;t want to do that while the filesystem is mounted. &lt;code&gt;git prune&lt;/code&gt; is designed not to cause any harm in such cases of concurrent accesses to a repository but you might receive confusing or scary messages.)</source>
          <target state="translated">и они уйдут. (Вы должны запускать &lt;code&gt;git prune&lt;/code&gt; только в неподвижном репозитории - это похоже на восстановление файловой системы с помощью fsck: вы не хотите делать это, пока файловая система смонтирована. &lt;code&gt;git prune&lt;/code&gt; разработан, чтобы не причинять никакого вреда в таких случаях одновременный доступ к репозиторию, но вы можете получить запутанные или пугающие сообщения.)</target>
        </trans-unit>
        <trans-unit id="cd197c11bb84be1a5bb09ba9b42e3b50427dcfec" translate="yes" xml:space="preserve">
          <source>and this will just output the name of the resulting tree, in this case (if you have done exactly as I&amp;rsquo;ve described) it should be</source>
          <target state="translated">и это просто выведет имя результирующего дерева, в этом случае (если вы сделали именно так, как я описал) оно должно быть</target>
        </trans-unit>
        <trans-unit id="b1af0fa00d023b5f61dc1f79856e5725ea01dd35" translate="yes" xml:space="preserve">
          <source>and thus it is really quite easy to parse for some line- and word-oriented parser (which should be quite natural for most scripting languages).</source>
          <target state="translated">и,таким образом,он действительно довольно легко поддается синтаксическому анализу для некоторых линейно-и словесно-ориентированных парсеров (что должно быть вполне естественно для большинства скриптовых языков).</target>
        </trans-unit>
        <trans-unit id="66cee198375e167a1653a383c43e2bb725e3ca7a" translate="yes" xml:space="preserve">
          <source>and use the &quot;linus&quot; keyword with &lt;code&gt;git pull&lt;/code&gt; instead of the full URL.</source>
          <target state="translated">и используйте ключевое слово linus с &lt;code&gt;git pull&lt;/code&gt; вместо полного URL.</target>
        </trans-unit>
        <trans-unit id="d296b286b6d11f02bc95ddc0eea6f99abc87487a" translate="yes" xml:space="preserve">
          <source>and you can now, since you told Git about the previous state of &lt;code&gt;hello&lt;/code&gt;, ask Git what has changed in the tree compared to your old index, using the &lt;code&gt;git diff-files&lt;/code&gt; command:</source>
          <target state="translated">и теперь вы можете, так как вы сообщили Git о предыдущем состоянии &lt;code&gt;hello&lt;/code&gt; , спросить Git, что изменилось в дереве по сравнению с вашим старым индексом, используя команду &lt;code&gt;git diff-files&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c22810b9d38d8e650ac736b5ccfb992ea7f0787f" translate="yes" xml:space="preserve">
          <source>and you have now told Git to track those two files.</source>
          <target state="translated">и ты сказал Гиту отследить эти два файла.</target>
        </trans-unit>
        <trans-unit id="7078b738b08f05f21971cffe5f9577bcab9aaf44" translate="yes" xml:space="preserve">
          <source>and you will end up with an index with all of the &amp;lt;tree1&amp;gt; entries in &quot;stage1&quot;, all of the &amp;lt;tree2&amp;gt; entries in &quot;stage2&quot; and all of the &amp;lt;tree3&amp;gt; entries in &quot;stage3&quot;. When performing a merge of another branch into the current branch, we use the common ancestor tree as &amp;lt;tree1&amp;gt;, the current branch head as &amp;lt;tree2&amp;gt;, and the other branch head as &amp;lt;tree3&amp;gt;.</source>
          <target state="translated">и вы получите индекс со всеми записями &amp;lt;tree1&amp;gt; в &amp;laquo;stage1&amp;raquo;, всеми записями &amp;lt;tree2&amp;gt; в &amp;laquo;stage2&amp;raquo; и всеми записями &amp;lt;tree3&amp;gt; в &amp;laquo;stage3&amp;raquo;. При выполнении слияния другой ветви в текущую ветвь мы используем дерево общих предков как &amp;lt;tree1&amp;gt;, заголовок текущей ветки как &amp;lt;tree2&amp;gt;, а заголовок другой ветви как &amp;lt;tree3&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="17b48e857b44d8864349e98c537796214a8362f4" translate="yes" xml:space="preserve">
          <source>and your index file will now be equivalent to the tree that you saved earlier. However, that is only your 'index' file: your working directory contents have not been modified.</source>
          <target state="translated">и ваш индексный файл теперь будет эквивалентен дереву,которое вы сохранили ранее.Однако,это только ваш &quot;индексный&quot; файл:содержимое вашей рабочей директории не было изменено.</target>
        </trans-unit>
        <trans-unit id="9f158fb3a1f2423d0104e077166f5b26c8204522" translate="yes" xml:space="preserve">
          <source>and your index file will now be equivalent to the tree that you saved earlier. However, that is only your &lt;code&gt;index&lt;/code&gt; file: your working directory contents have not been modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7df7a4e50a38db45b495588bed9a4abd67c32fe" translate="yes" xml:space="preserve">
          <source>and your repository is good again!</source>
          <target state="translated">и твой репозиторий снова хорош!</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="86c8af583af4d12d1e63765efb1b3cf2c23eb581" translate="yes" xml:space="preserve">
          <source>any external helpers are named by their protocol (e.g., use &lt;code&gt;hg&lt;/code&gt; to allow the &lt;code&gt;git-remote-hg&lt;/code&gt; helper)</source>
          <target state="translated">любые внешние помощники называются по их протоколу (например, используйте &lt;code&gt;hg&lt;/code&gt; , чтобы разрешить помощник &lt;code&gt;git-remote-hg&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8fe566b6d0fcd9f8f079b9cbd5dff1c192d0bda1" translate="yes" xml:space="preserve">
          <source>any path matches itself</source>
          <target state="translated">любой путь совпадает сам по себе</target>
        </trans-unit>
        <trans-unit id="951f5c774520ac2d893d49506bb03ddb31fc70a0" translate="yes" xml:space="preserve">
          <source>api index</source>
          <target state="translated">индекс api</target>
        </trans-unit>
        <trans-unit id="1ac3324252e6efe491b8f90f3588d4cd0cfc38d7" translate="yes" xml:space="preserve">
          <source>api trace2</source>
          <target state="translated">api-след2</target>
        </trans-unit>
        <trans-unit id="37f7547fef4fd60a7d07405e2e68e608cab796d3" translate="yes" xml:space="preserve">
          <source>api-trace2</source>
          <target state="translated">api-trace2</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="69f45da1683c501696ebfa086d25192af3807dc6" translate="yes" xml:space="preserve">
          <source>apply</source>
          <target state="translated">apply</target>
        </trans-unit>
        <trans-unit id="0c2fcb1d034ab205423e1d7ec6d29da9bf89a06b" translate="yes" xml:space="preserve">
          <source>apply [--index] [-q|--quiet] [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">применить [--index] [-q | --quiet] [&amp;lt;stash&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="41e3e8c05614ede7d2046024aa32acb852d9e90a" translate="yes" xml:space="preserve">
          <source>apply backend: When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the &quot;old&quot; lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c563ce0a13a71f68c4323807b8df4dc3dd3653" translate="yes" xml:space="preserve">
          <source>apply the change that would be shown by &lt;code&gt;git show topic^&lt;/code&gt;. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results.</source>
          <target state="translated">примените изменение, которое будет показано &lt;code&gt;git show topic^&lt;/code&gt; . В этом примере исправление не применяется чисто, поэтому информация о конфликте записывается в индекс и рабочее дерево, а новые результаты фиксации отсутствуют.</target>
        </trans-unit>
        <trans-unit id="07666f4e66bd4bf8ab64d3029da991c3b016c0f9" translate="yes" xml:space="preserve">
          <source>apply them, interactively, with your sign-offs.</source>
          <target state="translated">применить их,в интерактивном режиме,со своими вывесками.</target>
        </trans-unit>
        <trans-unit id="c778c31b66fdb0077c39c1643484bc80e939a6ef" translate="yes" xml:space="preserve">
          <source>apply.ignoreWhitespace</source>
          <target state="translated">apply.ignoreWhitespace</target>
        </trans-unit>
        <trans-unit id="3828727a8ed2b41298eb944c27d30c630bbaecf8" translate="yes" xml:space="preserve">
          <source>apply.whitespace</source>
          <target state="translated">apply.whitespace</target>
        </trans-unit>
        <trans-unit id="e90a34fe73108d3def10c8aa75dd41cf4b8df564" translate="yes" xml:space="preserve">
          <source>applypatch-msg</source>
          <target state="translated">applypatch-msg</target>
        </trans-unit>
        <trans-unit id="6edf8749a5d3dba0628223b6880e8abfb4f10d76" translate="yes" xml:space="preserve">
          <source>araxis</source>
          <target state="translated">araxis</target>
        </trans-unit>
        <trans-unit id="8c4f0e515d3499448f3629d033cf224f688edc27" translate="yes" xml:space="preserve">
          <source>arbitrary shell command that takes a single argument (the sha1 of the commit recorded in the superproject) is executed. When &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; is set to &lt;code&gt;!command&lt;/code&gt;, the remainder after the exclamation mark is the custom command.</source>
          <target state="translated">Выполняется произвольная команда оболочки, которая принимает единственный аргумент (sha1 фиксации, записанной в суперпроекте). Если для &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; установлено значение &lt;code&gt;!command&lt;/code&gt; , остаток после восклицательного знака является пользовательской командой.</target>
        </trans-unit>
        <trans-unit id="ebfb55f4432b592119a10592e4f26272cc72359e" translate="yes" xml:space="preserve">
          <source>archive</source>
          <target state="translated">archive</target>
        </trans-unit>
        <trans-unit id="02ffa0b70f36225abe68ab3c5392918d20ddbb24" translate="yes" xml:space="preserve">
          <source>are files GIT_EXTERNAL_DIFF can use to read the contents of &amp;lt;old|new&amp;gt;,</source>
          <target state="translated">файлы, которые GIT_EXTERNAL_DIFF может использовать для чтения содержимого &amp;lt;old | new&amp;gt;,</target>
        </trans-unit>
        <trans-unit id="f04207e23f9202de330ee8bdec5f2a1b205be329" translate="yes" xml:space="preserve">
          <source>are incompatible with the following options:</source>
          <target state="translated">несовместимы со следующими вариантами:</target>
        </trans-unit>
        <trans-unit id="bf5659661ce871a6788ee6b1bec9770f7f549075" translate="yes" xml:space="preserve">
          <source>are roughly equivalent.</source>
          <target state="translated">примерно эквивалентны.</target>
        </trans-unit>
        <trans-unit id="bfc0acfc5f4a94969ee2f529469c80db6f5db191" translate="yes" xml:space="preserve">
          <source>are the 40-hexdigit SHA-1 hashes,</source>
          <target state="translated">это 40-гекс-цифровые хэши SHA-1,</target>
        </trans-unit>
        <trans-unit id="377a5f0a9c724f4b4e656d090beb28e896803b78" translate="yes" xml:space="preserve">
          <source>are the octal representation of the file modes.</source>
          <target state="translated">это восьмеричное представление файловых режимов.</target>
        </trans-unit>
        <trans-unit id="536f158f6dfd529865dcb865a97bb16804e34d70" translate="yes" xml:space="preserve">
          <source>arguments</source>
          <target state="translated">arguments</target>
        </trans-unit>
        <trans-unit id="d73d25bb51bc0192ff2858618720527615dee66a" translate="yes" xml:space="preserve">
          <source>arrange &lt;code&gt;git push&lt;/code&gt; to push all local branches to their corresponding branch of the mothership machine.</source>
          <target state="translated">аранжируйте &lt;code&gt;git push&lt;/code&gt; , чтобы переместить все локальные ветки в соответствующую ветку материнской машины.</target>
        </trans-unit>
        <trans-unit id="7dc74bb7dc6b2238e853c884d0d310e31daffb87" translate="yes" xml:space="preserve">
          <source>as long as the shared repository does not have any branches other than &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">пока у общего репозитория нет других веток, кроме &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb2841c784dffc3f3e69b38c87cb3ad64f719624" translate="yes" xml:space="preserve">
          <source>as they are probably more user specific than repository specific. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more information about this.</source>
          <target state="translated">поскольку они, вероятно, более специфичны для пользователя, чем для репозитория. См. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; для получения дополнительной информации об этом.</target>
        </trans-unit>
        <trans-unit id="ec09624f8bf140a91e574552f4201e093095f93f" translate="yes" xml:space="preserve">
          <source>ask each</source>
          <target state="translated">спрашивать каждого</target>
        </trans-unit>
        <trans-unit id="a4da794aacaf85856a7722c9d864566d302089fc" translate="yes" xml:space="preserve">
          <source>at this point the two branches have diverged, with different changes made in each. To merge the changes made in experimental into master, run</source>
          <target state="translated">в этот момент две ветви разошлись,в каждую из них вносились разные изменения.Чтобы соединить изменения,сделанные в экспериментальном режиме,в мастерском,выполните следующие действия.</target>
        </trans-unit>
        <trans-unit id="56cb56551e60df919190b545acc4efd3487df2da" translate="yes" xml:space="preserve">
          <source>at-open-brace &lt;code&gt;@{&lt;/code&gt; is used as a notation to access a reflog entry.</source>
          <target state="translated">at-open-brace &lt;code&gt;@{&lt;/code&gt; используется как обозначение для доступа к записи рефлога.</target>
        </trans-unit>
        <trans-unit id="c6f57180e462a4f1e9de24fbe811cfb2c24a0cf9" translate="yes" xml:space="preserve">
          <source>atom</source>
          <target state="translated">atom</target>
        </trans-unit>
        <trans-unit id="fc88c6b3cc380853de27e44642207df9743ff63d" translate="yes" xml:space="preserve">
          <source>attr</source>
          <target state="translated">attr</target>
        </trans-unit>
        <trans-unit id="c0357eb71b4a8821fe200d8b8eb01baef86fac5a" translate="yes" xml:space="preserve">
          <source>author date (format respects --date= option)</source>
          <target state="translated">дата автора (формат уважает-date=опция)</target>
        </trans-unit>
        <trans-unit id="2a06a73ff8fc368a2739a3e178ba7f2389794fbb" translate="yes" xml:space="preserve">
          <source>author date, ISO 8601-like format</source>
          <target state="translated">дата создания,формат ISO 8601</target>
        </trans-unit>
        <trans-unit id="242b07f5f5075eaa7fd5b51606a9b4162ff6c885" translate="yes" xml:space="preserve">
          <source>author date, RFC2822 style</source>
          <target state="translated">дата создания,RFC2822 стиль</target>
        </trans-unit>
        <trans-unit id="203f076a8dfae351b5cbfcddc2f39e2529b4ab40" translate="yes" xml:space="preserve">
          <source>author date, UNIX timestamp</source>
          <target state="translated">дата создания,отметка времени UNIX</target>
        </trans-unit>
        <trans-unit id="5b659229f527fa360f4003ca474cb9646e5df53b" translate="yes" xml:space="preserve">
          <source>author date, relative</source>
          <target state="translated">дата создания,родственник</target>
        </trans-unit>
        <trans-unit id="d04a676256ca4278418fc83a6c6099b60b59d9c4" translate="yes" xml:space="preserve">
          <source>author date, short format (&lt;code&gt;YYYY-MM-DD&lt;/code&gt;)</source>
          <target state="translated">дата автора, краткий формат ( &lt;code&gt;YYYY-MM-DD&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ca050c864ebffd969007968bf223faf21875eae7" translate="yes" xml:space="preserve">
          <source>author date, strict ISO 8601 format</source>
          <target state="translated">дата создания,строгий формат ISO 8601</target>
        </trans-unit>
        <trans-unit id="7ddbfb879a548122c7fc198acb1c1b2f4c9b9921" translate="yes" xml:space="preserve">
          <source>author email</source>
          <target state="translated">электронное письмо автора</target>
        </trans-unit>
        <trans-unit id="8edafcfb5bfb68f54b13aeb0dafbb6187a753701" translate="yes" xml:space="preserve">
          <source>author email (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">адрес электронной почты автора (относительно .mailmap, см. &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; или &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="83daf4aca33631f2eb4acd6a25a656b0af3f5ee2" translate="yes" xml:space="preserve">
          <source>author email local-part (the part before the &lt;code&gt;@&lt;/code&gt; sign)</source>
          <target state="translated">адрес электронной почты автора local-part (часть до знака &lt;code&gt;@&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5d4130a7bcbeec5d4a298b1e471f17266d9c3b2a" translate="yes" xml:space="preserve">
          <source>author local-part (see &lt;code&gt;%al&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">автор local-part (см. &lt;code&gt;%al&lt;/code&gt; ) в отношении .mailmap, см. &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; или &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a38923d0b44faf2fd760ba1064fa8cccf3161910" translate="yes" xml:space="preserve">
          <source>author local-part (see &lt;code&gt;%cl&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">автор local-part (см. &lt;code&gt;%cl&lt;/code&gt; ) с соблюдением .mailmap, см. &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; или &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c377e3db13b17a5dec490aa3f6ac58e35bd02ae8" translate="yes" xml:space="preserve">
          <source>author name</source>
          <target state="translated">имя автора</target>
        </trans-unit>
        <trans-unit id="bd2cf54c8d8427c36e72436dee6f5edfa55f4e21" translate="yes" xml:space="preserve">
          <source>author name (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">имя автора (в отношении .mailmap, см. &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; или &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="aa42d4b548d53eeb1e514e0662eb0b64c3782193" translate="yes" xml:space="preserve">
          <source>author name, email and date</source>
          <target state="translated">имя автора,адрес электронной почты и дата</target>
        </trans-unit>
        <trans-unit id="d00ed3c485ca1a6ad6088b1642369eb27039d0b8" translate="yes" xml:space="preserve">
          <source>author.email</source>
          <target state="translated">author.email</target>
        </trans-unit>
        <trans-unit id="290b3c3f6920221191e3db343ad6fbf3a2f939e8" translate="yes" xml:space="preserve">
          <source>author.name</source>
          <target state="translated">author.name</target>
        </trans-unit>
        <trans-unit id="9c3bb49ffea1144231cbe02d904b8d9018744e9d" translate="yes" xml:space="preserve">
          <source>avatar</source>
          <target state="translated">avatar</target>
        </trans-unit>
        <trans-unit id="0bb01d8924d6b902321a6c09d5c0a45ab1342655" translate="yes" xml:space="preserve">
          <source>b) independent fixup</source>
          <target state="translated">б)самостоятельное исправление</target>
        </trans-unit>
        <trans-unit id="aeca33ec4bf9a7bd6b90cc303f5a8ac32af312c1" translate="yes" xml:space="preserve">
          <source>backport a critical fix.</source>
          <target state="translated">зайти в критический тупик.</target>
        </trans-unit>
        <trans-unit id="fe676f1ea27d4114d62d0b88a9999860d1c162c1" translate="yes" xml:space="preserve">
          <source>bare repository</source>
          <target state="translated">голый репозиторий</target>
        </trans-unit>
        <trans-unit id="e95c0d71e5a737bfc209f7013e45e233a7480a96" translate="yes" xml:space="preserve">
          <source>base-name</source>
          <target state="translated">base-name</target>
        </trans-unit>
        <trans-unit id="5b2505039ac5af9e197f5dad04113906a9cf9a2a" translate="yes" xml:space="preserve">
          <source>bc</source>
          <target state="translated">bc</target>
        </trans-unit>
        <trans-unit id="3c2369c6416caa1993808240594282dd4fcb95c1" translate="yes" xml:space="preserve">
          <source>bc3</source>
          <target state="translated">bc3</target>
        </trans-unit>
        <trans-unit id="b7c7d5d4b182d06d7f89fcb3d277474733c67444" translate="yes" xml:space="preserve">
          <source>be quiet if files exist or are not in the index</source>
          <target state="translated">не шуметь,если файлы существуют или нет в индексе.</target>
        </trans-unit>
        <trans-unit id="bfa1cf02635b780783c9853aaca57e1c719e79ad" translate="yes" xml:space="preserve">
          <source>because the hostnames differ. Nor would it match &lt;code&gt;foo.example.com&lt;/code&gt;; Git compares hostnames exactly, without considering whether two hosts are part of the same domain. Likewise, a config entry for &lt;code&gt;http://example.com&lt;/code&gt; would not match: Git compares the protocols exactly.</source>
          <target state="translated">потому что имена хостов различаются. Он также не будет соответствовать &lt;code&gt;foo.example.com&lt;/code&gt; ; Git точно сравнивает имена хостов, не учитывая, являются ли два хоста частью одного домена. Точно так же запись конфигурации для &lt;code&gt;http://example.com&lt;/code&gt; не будет соответствовать: Git точно сравнивает протоколы.</target>
        </trans-unit>
        <trans-unit id="bd766456dd7d080025c5f2a3029a29c2bb5419ef" translate="yes" xml:space="preserve">
          <source>because the hostnames differ. Nor would it match &lt;code&gt;foo.example.com&lt;/code&gt;; Git compares hostnames exactly, without considering whether two hosts are part of the same domain. Likewise, a config entry for &lt;code&gt;http://example.com&lt;/code&gt; would not match: Git compares the protocols exactly. However, you may use wildcards in the domain name and other pattern matching techniques as with the &lt;code&gt;http.&amp;lt;url&amp;gt;.*&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="fc5afa849d013727d8acf30682a03a891f7aca7e" translate="yes" xml:space="preserve">
          <source>bisect</source>
          <target state="translated">bisect</target>
        </trans-unit>
        <trans-unit id="e04a67a1c220ec3759550df9a963521323148d66" translate="yes" xml:space="preserve">
          <source>blame</source>
          <target state="translated">blame</target>
        </trans-unit>
        <trans-unit id="72092ff956b5b07bf4d598501177651a9897b3f1" translate="yes" xml:space="preserve">
          <source>blame.blankBoundary</source>
          <target state="translated">blame.blankBoundary</target>
        </trans-unit>
        <trans-unit id="2862b4a0ea76b67385f8581e3bd4cf75e32e65d0" translate="yes" xml:space="preserve">
          <source>blame.coloring</source>
          <target state="translated">blame.coloring</target>
        </trans-unit>
        <trans-unit id="c55af0af464fc28e395cedf375c27ed38ea08dd7" translate="yes" xml:space="preserve">
          <source>blame.date</source>
          <target state="translated">blame.date</target>
        </trans-unit>
        <trans-unit id="574525f7353221a33787a1a7d1232b7faf51b9bb" translate="yes" xml:space="preserve">
          <source>blame.ignoreRevsFile</source>
          <target state="translated">blame.ignoreRevsFile</target>
        </trans-unit>
        <trans-unit id="8d9e3a327869e356dde043a93aea128672ec4a32" translate="yes" xml:space="preserve">
          <source>blame.markIgnoredLines</source>
          <target state="translated">blame.markIgnoredLines</target>
        </trans-unit>
        <trans-unit id="96c64bfbb0487dbb1fe121cc068a07b1b6f2001d" translate="yes" xml:space="preserve">
          <source>blame.markUnblamables</source>
          <target state="translated">blame.markUnblamables</target>
        </trans-unit>
        <trans-unit id="244ba240ca074db6d0f0d4bb8de34505a6383151" translate="yes" xml:space="preserve">
          <source>blame.showEmail</source>
          <target state="translated">blame.showEmail</target>
        </trans-unit>
        <trans-unit id="f2560ddc149bc689a9eb1559b1e046e4885feda7" translate="yes" xml:space="preserve">
          <source>blame.showRoot</source>
          <target state="translated">blame.showRoot</target>
        </trans-unit>
        <trans-unit id="3bc20f9fcb1740f5d09c92cd6bf8bd32d164c6ae" translate="yes" xml:space="preserve">
          <source>blame_incremental</source>
          <target state="translated">blame_incremental</target>
        </trans-unit>
        <trans-unit id="0fd0bcfb44f83e7d5ac7a8922578276b9af48746" translate="yes" xml:space="preserve">
          <source>blob</source>
          <target state="translated">blob</target>
        </trans-unit>
        <trans-unit id="815675cd53e5196255182a0fd392e03df0fcd193" translate="yes" xml:space="preserve">
          <source>blob object</source>
          <target state="translated">объект блобирования</target>
        </trans-unit>
        <trans-unit id="751eae742e521df559ef7ed559fa3259d5b09b0d" translate="yes" xml:space="preserve">
          <source>blob_plain</source>
          <target state="translated">blob_plain</target>
        </trans-unit>
        <trans-unit id="c06f874d67ebcdd1994d59e3867ceb303b9b6698" translate="yes" xml:space="preserve">
          <source>blobdiff</source>
          <target state="translated">blobdiff</target>
        </trans-unit>
        <trans-unit id="f7d5b2b95861daea9933ef0a243f733bbc79235e" translate="yes" xml:space="preserve">
          <source>blocks</source>
          <target state="translated">blocks</target>
        </trans-unit>
        <trans-unit id="02083f4579e08a612425c0c1a17ee47add783b94" translate="yes" xml:space="preserve">
          <source>body</source>
          <target state="translated">body</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="f6edb368393f0758009b3afd170f648a63e11385" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are merge-bases of A and B. Neither one is better than the other (both are &lt;code&gt;best&lt;/code&gt; merge bases). When the &lt;code&gt;--all&lt;/code&gt; option is not given, it is unspecified which best one is output.</source>
          <target state="translated">и &lt;code&gt;1&lt;/code&gt; , и &lt;code&gt;2&lt;/code&gt; являются базами слияния A и B. Ни один из них не лучше другого (оба являются &lt;code&gt;best&lt;/code&gt; базами слияния). Если параметр &lt;code&gt;--all&lt;/code&gt; не указан, не указано, какой из них будет выводиться лучше всего.</target>
        </trans-unit>
        <trans-unit id="ab885ad5b5ecb443f904caddcf71de38ec2ad4fc" translate="yes" xml:space="preserve">
          <source>both from a symlink following standpoint &lt;strong&gt;and&lt;/strong&gt; an error checking standpoint. The &quot;refs/&quot; rule for symlinks means that symlinks that point to &quot;outside&quot; the tree are safe: they&amp;rsquo;ll be followed for reading but not for writing (so we&amp;rsquo;ll never write through a ref symlink to some other tree, if you have copied a whole archive by creating a symlink tree).</source>
          <target state="translated">как с точки зрения символической ссылки, так &lt;strong&gt;и&lt;/strong&gt; с точки зрения проверки ошибок. Правило &quot;refs /&quot; для символических ссылок означает, что символические ссылки, указывающие на &quot;вне&quot; дерева, безопасны: они будут отслеживаться для чтения, но не для записи (поэтому мы никогда не будем писать через символическую ссылку ref на какое-либо другое дерево, если вы скопировали весь архив, создав дерево символических ссылок).</target>
        </trans-unit>
        <trans-unit id="10d735e581f1e2505cd69675691925490e447c44" translate="yes" xml:space="preserve">
          <source>branch</source>
          <target state="translated">branch</target>
        </trans-unit>
        <trans-unit id="d9ebdce6e5eb5490d2736b1657cb3bbdff2a24c8" translate="yes" xml:space="preserve">
          <source>branch &amp;lt;branchname&amp;gt; [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">ветка &amp;lt;имя-ветки&amp;gt; [&amp;lt;ветка&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="4d89d47c3496bed1c997cfd4749bbb345956b062" translate="yes" xml:space="preserve">
          <source>branch name: refers to the commit at the head of the given branch</source>
          <target state="translated">название ветки:относится к коммиту во главе данной ветки</target>
        </trans-unit>
        <trans-unit id="7cf9cb4f1f0d11974da193a921ad56188af0dbfb" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.description</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.description</target>
        </trans-unit>
        <trans-unit id="c972b8f442dc56f76ff5821861f38f9df9f740a2" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.merge</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.merge</target>
        </trans-unit>
        <trans-unit id="12b705785a619a7af3091b413cd10bc5f913cd36" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.mergeOptions</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.mergeOptions</target>
        </trans-unit>
        <trans-unit id="e3044fee5f265c567fa94779be6a4b05485a2ef5" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.pushRemote</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.pushRemote</target>
        </trans-unit>
        <trans-unit id="089608ebf4ab438938386db74054dd0539e68174" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.rebase</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.rebase</target>
        </trans-unit>
        <trans-unit id="ae2da89c53e9406d5454991c9de79d2701626513" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.remote</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.remote</target>
        </trans-unit>
        <trans-unit id="c1beb4d53b0941d5b69587d5619ae40af0e82fb0" translate="yes" xml:space="preserve">
          <source>branch.autoSetupMerge</source>
          <target state="translated">branch.autoSetupMerge</target>
        </trans-unit>
        <trans-unit id="a348d9eb171112632f68ea4fa0280f35b7af36d9" translate="yes" xml:space="preserve">
          <source>branch.autoSetupRebase</source>
          <target state="translated">branch.autoSetupRebase</target>
        </trans-unit>
        <trans-unit id="c4907ecf78c64eedfc547e343a00efb0d648c80c" translate="yes" xml:space="preserve">
          <source>branch.sort</source>
          <target state="translated">branch.sort</target>
        </trans-unit>
        <trans-unit id="52a9ce4a0d3c21f1c0c5dc576930fbb59ad74018" translate="yes" xml:space="preserve">
          <source>branches</source>
          <target state="translated">branches</target>
        </trans-unit>
        <trans-unit id="ef98362b8a6b0c8cd804b0d227aa1ffeaba89786" translate="yes" xml:space="preserve">
          <source>browser</source>
          <target state="translated">browser</target>
        </trans-unit>
        <trans-unit id="d7b49d5666ac0fe3243cf929f3fbea5d40512cc5" translate="yes" xml:space="preserve">
          <source>browser.&amp;lt;tool&amp;gt;.cmd</source>
          <target state="translated">browser.&amp;lt;tool&amp;gt;.cmd</target>
        </trans-unit>
        <trans-unit id="1afa7a8068dc2826b24730832089e6b8ae806f4d" translate="yes" xml:space="preserve">
          <source>browser.&amp;lt;tool&amp;gt;.path</source>
          <target state="translated">browser.&amp;lt;tool&amp;gt;.path</target>
        </trans-unit>
        <trans-unit id="ce3731defbdc7875cff0c020e900192d6b65542c" translate="yes" xml:space="preserve">
          <source>bugreport</source>
          <target state="translated">bugreport</target>
        </trans-unit>
        <trans-unit id="26a194e96e2873f688a8836d3ee9bd5e7be08547" translate="yes" xml:space="preserve">
          <source>built-in values (some set during build stage),</source>
          <target state="translated">встроенные значения (некоторые из них задаются на этапе сборки),</target>
        </trans-unit>
        <trans-unit id="7581496de8d7f905da83e60fe5216caab582c109" translate="yes" xml:space="preserve">
          <source>bumping format version numbers of individual data files (e.g., index, packfiles, etc). This restricts the incompatibilities only to those files.</source>
          <target state="translated">номера версий отдельных файлов данных (например,индекс,пакетные файлы и т.д.)в формате бампажа.Это ограничивает несовместимость только с этими файлами.</target>
        </trans-unit>
        <trans-unit id="d59795de8a4d83834e525b589b2bb0c12e4542c1" translate="yes" xml:space="preserve">
          <source>bundle</source>
          <target state="translated">bundle</target>
        </trans-unit>
        <trans-unit id="c8bebbf42f3ec7d29b62f6981d42b56fa9e07016" translate="yes" xml:space="preserve">
          <source>but can be used to amend a merge commit.</source>
          <target state="translated">но может быть использовано для исправления коммита слияния.</target>
        </trans-unit>
        <trans-unit id="e0e9a8eb5c66f16a9e8325bbfe07678355605d3b" translate="yes" xml:space="preserve">
          <source>but if $REV is empty, the commit object name from master will be printed.</source>
          <target state="translated">но если $REV пуст,то будет выведено имя объекта коммита от мастера.</target>
        </trans-unit>
        <trans-unit id="d086642ebaf2071be1a4671ed3801412d03ee7ac" translate="yes" xml:space="preserve">
          <source>but that may become cumbersome, when you have many attributes. Using macro attributes, you can define an attribute that, when set, also sets or unsets a number of other attributes at the same time. The system knows a built-in macro attribute, &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">но это может стать громоздким, когда у вас много атрибутов. Используя атрибуты макроса, вы можете определить атрибут, который, когда он установлен, также устанавливает или отменяет установку ряда других атрибутов одновременно. Система знает встроенный атрибут макроса, &lt;code&gt;binary&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b354ac610248436418f0a768b2a238f599b63512" translate="yes" xml:space="preserve">
          <source>but that may sometimes help you guess which tags might come after the given commit.</source>
          <target state="translated">но иногда это может помочь вам угадать,какие метки могут прийти после данного коммита.</target>
        </trans-unit>
        <trans-unit id="481514e03c29bd6e6c21bcf330cca66f7a8e5e03" translate="yes" xml:space="preserve">
          <source>but the command invocation was &lt;code&gt;git diff-files myfile&lt;/code&gt;, then the junkfile entry would be removed from the list because only &quot;myfile&quot; is under consideration.</source>
          <target state="translated">но вызов команды был &lt;code&gt;git diff-files myfile&lt;/code&gt; , тогда запись файла нежелательной почты будет удалена из списка, поскольку рассматривается только &amp;laquo;myfile&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9a4d92b29b4ea9cb527dbdd917995ee8e6390c1d" translate="yes" xml:space="preserve">
          <source>but this time instead of immediately making the commit, let&amp;rsquo;s take an intermediate step, and ask for diffs along the way to keep track of what&amp;rsquo;s happening:</source>
          <target state="translated">но на этот раз вместо того, чтобы немедленно сделать фиксацию, давайте сделаем промежуточный шаг и по пути запросим различия, чтобы отслеживать, что происходит:</target>
        </trans-unit>
        <trans-unit id="4a4c509be280ffc999d52daf10f3af16adbf10ad" translate="yes" xml:space="preserve">
          <source>but to avoid common mistakes with filename globbing etc., the command will not normally add totally new entries or remove old entries, i.e. it will normally just update existing cache entries.</source>
          <target state="translated">но чтобы избежать обычных ошибок с глобусом имен файлов и т.д.,команда обычно не будет добавлять абсолютно новые записи или удалять старые,т.е.она просто будет обновлять существующие записи в кэше.</target>
        </trans-unit>
        <trans-unit id="0c8f2a0a85b88cfa647434356130399dff07d5d7" translate="yes" xml:space="preserve">
          <source>but with the algorithm used by git bisect we get:</source>
          <target state="translated">но с алгоритмом,используемым гит-бисектом,мы получаем:</target>
        </trans-unit>
        <trans-unit id="08885cdf79de4806bc91b025b32f3b00703dcf8c" translate="yes" xml:space="preserve">
          <source>by listing files as arguments to the &lt;code&gt;commit&lt;/code&gt; command (without --interactive or --patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);</source>
          <target state="translated">путем перечисления файлов в качестве аргументов команды &lt;code&gt;commit&lt;/code&gt; (без переключателя --interactive или --patch), и в этом случае фиксация проигнорирует изменения, внесенные в индекс, и вместо этого запишет текущее содержимое перечисленных файлов (которое уже должно быть известно в Git);</target>
        </trans-unit>
        <trans-unit id="3836fcf09d79e41b99edac70e256133efc12bff7" translate="yes" xml:space="preserve">
          <source>by moving the &quot;pick 4&quot; line will result in the following history:</source>
          <target state="translated">переместив строку &quot;Пиктограмма 4&quot;,вы получите следующую историю:</target>
        </trans-unit>
        <trans-unit id="906ba5e6f6707165a9878468ec60f33a2ff34b96" translate="yes" xml:space="preserve">
          <source>by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to incrementally &quot;add&quot; changes to the index before using the &lt;code&gt;commit&lt;/code&gt; command (Note: even modified files must be &quot;added&quot;);</source>
          <target state="translated">с помощью &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; для постепенного &amp;laquo;добавления&amp;raquo; изменений в индекс перед использованием команды &lt;code&gt;commit&lt;/code&gt; (Примечание: даже измененные файлы должны быть &amp;laquo;добавлены&amp;raquo;);</target>
        </trans-unit>
        <trans-unit id="e48f31443a096bff3238667996c3f171f13b5f0c" translate="yes" xml:space="preserve">
          <source>by using &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; to remove files from the working tree and the index, again before using the &lt;code&gt;commit&lt;/code&gt; command;</source>
          <target state="translated">используя &lt;a href=&quot;git-rm&quot;&gt;git-rm [1],&lt;/a&gt; чтобы удалить файлы из рабочего дерева и индекса, снова перед использованием команды &lt;code&gt;commit&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="093a3f97e95959ebe22524ee0ce832b0babc748b" translate="yes" xml:space="preserve">
          <source>by using the --interactive or --patch switches with the &lt;code&gt;commit&lt;/code&gt; command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate these modes.</source>
          <target state="translated">с помощью переключателей --interactive или --patch с командой &lt;code&gt;commit&lt;/code&gt; чтобы один за другим решить, какие файлы или фрагменты должны быть частью фиксации в дополнение к содержимому в индексе, перед завершением операции. См. Раздел &amp;laquo;Интерактивный режим&amp;raquo; в &lt;a href=&quot;git-add&quot;&gt;git-add [1],&lt;/a&gt; чтобы узнать, как управлять этими режимами.</target>
        </trans-unit>
        <trans-unit id="4834ad1b53b94300bc089b00aaeed76c52aebbcd" translate="yes" xml:space="preserve">
          <source>by using the -a switch with the &lt;code&gt;commit&lt;/code&gt; command to automatically &quot;add&quot; changes from all known files (i.e. all files that are already listed in the index) and to automatically &quot;rm&quot; files in the index that have been removed from the working tree, and then perform the actual commit;</source>
          <target state="translated">с помощью переключателя -a с командой &lt;code&gt;commit&lt;/code&gt; для автоматического &amp;laquo;добавления&amp;raquo; изменений из всех известных файлов (т. е. всех файлов, которые уже перечислены в индексе) и для автоматического &amp;laquo;rm&amp;raquo; файлов в индексе, которые были удалены из рабочего дерева , а затем выполнить фактическую фиксацию;</target>
        </trans-unit>
        <trans-unit id="b03592806efabfeeb709f5a70a7c172669b00538" translate="yes" xml:space="preserve">
          <source>cache</source>
          <target state="translated">cache</target>
        </trans-unit>
        <trans-unit id="0c93713c1e43fccf897b7b4f02e822c65d557fdf" translate="yes" xml:space="preserve">
          <source>cached</source>
          <target state="translated">cached</target>
        </trans-unit>
        <trans-unit id="9eafea1e818b36cfe83084dbfcee79ccb268deb8" translate="yes" xml:space="preserve">
          <source>cancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree.</source>
          <target state="translated">отменить вишневый выбор.Другими словами,вернуться в состояние пре-вишни,сохранив все локальные изменения,которые у вас были в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="21ca164274e6e0b587a5c99674b651b198887373" translate="yes" xml:space="preserve">
          <source>cat-blob</source>
          <target state="translated">cat-blob</target>
        </trans-unit>
        <trans-unit id="1b0b597309b09f88e890e96ee25a4239e209bcc6" translate="yes" xml:space="preserve">
          <source>cat-blob-fd</source>
          <target state="translated">cat-blob-fd</target>
        </trans-unit>
        <trans-unit id="1b860f3f13df1c0a7cb167ae98ab823bd793ef37" translate="yes" xml:space="preserve">
          <source>cat-file</source>
          <target state="translated">cat-file</target>
        </trans-unit>
        <trans-unit id="6bdc4dd4748a2bfb630e761b44a4eee74e5812c1" translate="yes" xml:space="preserve">
          <source>category (or &lt;code&gt;gitweb.category&lt;/code&gt;)</source>
          <target state="translated">категория (или &lt;code&gt;gitweb.category&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d027a2f7150c9c1d54212c981331ced097d02521" translate="yes" xml:space="preserve">
          <source>cd_to_toplevel</source>
          <target state="translated">cd_to_toplevel</target>
        </trans-unit>
        <trans-unit id="2cf64e447b84b497b2491b7af072a229eefe2651" translate="yes" xml:space="preserve">
          <source>chain</source>
          <target state="translated">chain</target>
        </trans-unit>
        <trans-unit id="eea15bfc0410c3d01d0daf4a8e336e46da972ca0" translate="yes" xml:space="preserve">
          <source>changeset</source>
          <target state="translated">changeset</target>
        </trans-unit>
        <trans-unit id="60863ff2c00bd434be8f30a313cc6bf530d01628" translate="yes" xml:space="preserve">
          <source>check the branch names in an external repository (if not known).</source>
          <target state="translated">проверить имена ответвлений во внешнем репозитории (если неизвестно).</target>
        </trans-unit>
        <trans-unit id="1f1c087ebd5ee9330247a27b3cb5e1c3309d1b49" translate="yes" xml:space="preserve">
          <source>check-ignore</source>
          <target state="translated">check-ignore</target>
        </trans-unit>
        <trans-unit id="d5491e7e7124a22dd73fa746ba129c59f9dc6d5d" translate="yes" xml:space="preserve">
          <source>checkout</source>
          <target state="translated">checkout</target>
        </trans-unit>
        <trans-unit id="f1d6e05726e233a2ab8de16435d659a28a2e35a7" translate="yes" xml:space="preserve">
          <source>checkout a new branch &lt;code&gt;mine&lt;/code&gt; from master.</source>
          <target state="translated">проверить новую ветку &lt;code&gt;mine&lt;/code&gt; от мастера.</target>
        </trans-unit>
        <trans-unit id="baa127da3b2e7bb80d470a5c5b3ed484fc3ecffa" translate="yes" xml:space="preserve">
          <source>checkout-index</source>
          <target state="translated">checkout-index</target>
        </trans-unit>
        <trans-unit id="77ccc4847f3f5995981f07a9aaa766d505e363d0" translate="yes" xml:space="preserve">
          <source>checkout.defaultRemote</source>
          <target state="translated">checkout.defaultRemote</target>
        </trans-unit>
        <trans-unit id="dede2b7b3445b7f569a7e102150c9e77ea7be895" translate="yes" xml:space="preserve">
          <source>checkout.guess</source>
          <target state="translated">checkout.guess</target>
        </trans-unit>
        <trans-unit id="7993ca6fc917dfcd7447613538a9f2529705f4e5" translate="yes" xml:space="preserve">
          <source>checkoutAmbiguousRemoteBranchName</source>
          <target state="translated">checkoutAmbiguousRemoteBranchName</target>
        </trans-unit>
        <trans-unit id="9c92181fd5e68d410f28e18265218b8c3a8a1b78" translate="yes" xml:space="preserve">
          <source>checks if the current directory is within the working tree of the repository, and otherwise dies.</source>
          <target state="translated">проверяет,находится ли текущий каталог в рабочем дереве репозитория,и в противном случае умирает.</target>
        </trans-unit>
        <trans-unit id="2e41d31ec807e404264bdbe4cf0898e0675b3d63" translate="yes" xml:space="preserve">
          <source>checks if the working tree associated with the repository exists, and otherwise dies. Often done before calling cd_to_toplevel, which is impossible to do if there is no working tree.</source>
          <target state="translated">проверяет существование рабочего дерева,связанного с репозиторием,и в противном случае умирает.Часто это делается перед вызовом cd_to_toplevel,что невозможно сделать при отсутствии рабочего дерева.</target>
        </trans-unit>
        <trans-unit id="6ce38e1ed1561eb51f91bed4e5b8b42001fa1cda" translate="yes" xml:space="preserve">
          <source>checks out all files in the index. Cannot be used together with explicit filenames.</source>
          <target state="translated">проверяет все файлы в индексе.Не может использоваться вместе с явными именами файлов.</target>
        </trans-unit>
        <trans-unit id="b095764396dd7603ab632901ad86334026f5e97f" translate="yes" xml:space="preserve">
          <source>checks out an older version. Continue like this, telling Git at each stage whether the version it gives you is good or bad, and notice that the number of revisions left to test is cut approximately in half each time.</source>
          <target state="translated">проверяет старую версию.Продолжайте в том же духе,говоря Git'у на каждом этапе,хорошая это версия или плохая,и заметьте,что количество ревизий,оставленных для проверки,каждый раз сокращается примерно наполовину.</target>
        </trans-unit>
        <trans-unit id="9d48ee970ac151e88a06bd52df27d444e45a115f" translate="yes" xml:space="preserve">
          <source>checks that the working tree and index associated with the repository have no uncommitted changes to tracked files. Otherwise it emits an error message of the form &lt;code&gt;Cannot
&amp;lt;action&amp;gt;: &amp;lt;reason&amp;gt;. &amp;lt;hint&amp;gt;&lt;/code&gt;, and dies. Example:</source>
          <target state="translated">проверяет, что в рабочем дереве и индексе, связанном с репозиторием, нет незафиксированных изменений отслеживаемых файлов. В противном случае выдается сообщение об ошибке в форме &lt;code&gt;Cannot &amp;lt;action&amp;gt;: &amp;lt;reason&amp;gt;. &amp;lt;hint&amp;gt;&lt;/code&gt; и умирает. Пример:</target>
        </trans-unit>
        <trans-unit id="fde288e73fa35b620c1d091cd10bc2b4ef783b38" translate="yes" xml:space="preserve">
          <source>cherry-pick</source>
          <target state="translated">cherry-pick</target>
        </trans-unit>
        <trans-unit id="4d3ec7cec131af0636c8c4eb3ed9fad46bbbd8fe" translate="yes" xml:space="preserve">
          <source>cherry-picking</source>
          <target state="translated">cherry-picking</target>
        </trans-unit>
        <trans-unit id="13bb03a5ed8a80118d832f3194a1f24bdfb90600" translate="yes" xml:space="preserve">
          <source>chromium (also supported as chromium-browser)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1aab85a96cc8931c6cead1715bf9f08fbd159e1" translate="yes" xml:space="preserve">
          <source>citool</source>
          <target state="translated">citool</target>
        </trans-unit>
        <trans-unit id="6a1cec45eaf37b34e1b1d89130d7746fe4006346" translate="yes" xml:space="preserve">
          <source>clean</source>
          <target state="translated">clean</target>
        </trans-unit>
        <trans-unit id="6191f3c6c1156403f2abec74131f05962f1abaa8" translate="yes" xml:space="preserve">
          <source>clean.requireForce</source>
          <target state="translated">clean.requireForce</target>
        </trans-unit>
        <trans-unit id="168cbb2ea52b9e34d271accecfa7d7951e948a99" translate="yes" xml:space="preserve">
          <source>clear</source>
          <target state="translated">clear</target>
        </trans-unit>
        <trans-unit id="5e0072329d5085c5bc5c23c2fa873dd42900958b" translate="yes" xml:space="preserve">
          <source>clone</source>
          <target state="translated">clone</target>
        </trans-unit>
        <trans-unit id="65b7b2d52a3b114f58dca240d43da422bee2212d" translate="yes" xml:space="preserve">
          <source>clone sets these configuration variables by default. It arranges &lt;code&gt;git pull&lt;/code&gt; to fetch and store the branches of mothership machine to local &lt;code&gt;remotes/origin/*&lt;/code&gt; remote-tracking branches.</source>
          <target state="translated">clone устанавливает эти переменные конфигурации по умолчанию. Он организует &lt;code&gt;git pull&lt;/code&gt; для извлечения и сохранения ветвей материнской машины на локальных удаленных &lt;code&gt;remotes/origin/*&lt;/code&gt; ветках удаленного отслеживания.</target>
        </trans-unit>
        <trans-unit id="915d6fb92a6ac08fb7138984ea283c14a9573f89" translate="yes" xml:space="preserve">
          <source>clone.defaultRemoteName</source>
          <target state="translated">clone.defaultRemoteName</target>
        </trans-unit>
        <trans-unit id="b0039cf0af8bf144bcdb5512b615336fbd740a49" translate="yes" xml:space="preserve">
          <source>cloneurl (or multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt;)</source>
          <target state="translated">cloneurl (или многозначный &lt;code&gt;gitweb.url&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ada0de0751f70d1f9286c0a71669d799d3961206" translate="yes" xml:space="preserve">
          <source>codecompare</source>
          <target state="translated">codecompare</target>
        </trans-unit>
        <trans-unit id="d2cff126ddc906e1a4a856fa830eddaf46fcb2f4" translate="yes" xml:space="preserve">
          <source>collapse multiple consecutive empty lines into one empty line</source>
          <target state="translated">свернуть несколько последовательных пустых строк в одну пустую строку</target>
        </trans-unit>
        <trans-unit id="6dd0fe8001145bec4a12d0e22da711c4970d000b" translate="yes" xml:space="preserve">
          <source>color</source>
          <target state="translated">color</target>
        </trans-unit>
        <trans-unit id="a5c6de6e1d6a5426c3f20e289bee4cb63cd9b46d" translate="yes" xml:space="preserve">
          <source>color specification, as described under Values in the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. By default, colors are shown only when enabled for log output (by &lt;code&gt;color.diff&lt;/code&gt;, &lt;code&gt;color.ui&lt;/code&gt;, or &lt;code&gt;--color&lt;/code&gt;, and respecting the &lt;code&gt;auto&lt;/code&gt; settings of the former if we are going to a terminal). &lt;code&gt;%C(auto,...)&lt;/code&gt; is accepted as a historical synonym for the default (e.g., &lt;code&gt;%C(auto,red)&lt;/code&gt;). Specifying &lt;code&gt;%C(always,...)&lt;/code&gt; will show the colors even when color is not otherwise enabled (though consider just using &lt;code&gt;--color=always&lt;/code&gt; to enable color for the whole output, including this format and anything else git might color). &lt;code&gt;auto&lt;/code&gt; alone (i.e. &lt;code&gt;%C(auto)&lt;/code&gt;) will turn on auto coloring on the next placeholders until the color is switched again.</source>
          <target state="translated">спецификация цвета, как описано в разделе &amp;laquo;Значения&amp;raquo; раздела &amp;laquo;КОНФИГУРАЦИОННЫЙ ФАЙЛ&amp;raquo; &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; . По умолчанию цвета отображаются только при включении вывода журнала (с помощью &lt;code&gt;color.diff&lt;/code&gt; , &lt;code&gt;color.ui&lt;/code&gt; или &lt;code&gt;--color&lt;/code&gt; и с соблюдением &lt;code&gt;auto&lt;/code&gt; настроек первого, если мы идем к терминалу). &lt;code&gt;%C(auto,...)&lt;/code&gt; принимается как исторический синоним значения по умолчанию (например, &lt;code&gt;%C(auto,red)&lt;/code&gt; ). Указание &lt;code&gt;%C(always,...)&lt;/code&gt; будет отображать цвета, даже если в противном случае цвет не включен (хотя рассмотрите возможность использования просто &lt;code&gt;--color=always&lt;/code&gt; , чтобы включить цвет для всего вывода, включая этот формат и все остальное, что может раскрасить git). &lt;code&gt;auto&lt;/code&gt; в одиночку (т.е. &lt;code&gt;%C(auto)&lt;/code&gt; ) включит автоматическое окрашивание следующих заполнителей, пока цвет не будет снова переключен.</target>
        </trans-unit>
        <trans-unit id="a4f66bcbf0c2d907db9d73e18998c425a594621e" translate="yes" xml:space="preserve">
          <source>color.advice</source>
          <target state="translated">color.advice</target>
        </trans-unit>
        <trans-unit id="8c847b9d6812ac606092130570e37493e972ad8a" translate="yes" xml:space="preserve">
          <source>color.advice.hint</source>
          <target state="translated">color.advice.hint</target>
        </trans-unit>
        <trans-unit id="46ab34863195debec0a658a6884ce1958a8721f8" translate="yes" xml:space="preserve">
          <source>color.blame.highlightRecent</source>
          <target state="translated">color.blame.highlightRecent</target>
        </trans-unit>
        <trans-unit id="cf152df8d71a4044f40941cffe12b4c5947d84c6" translate="yes" xml:space="preserve">
          <source>color.blame.repeatedLines</source>
          <target state="translated">color.blame.repeatedLines</target>
        </trans-unit>
        <trans-unit id="8ab572aa07e705b6cbb5dc02e6cc07d1c537adb5" translate="yes" xml:space="preserve">
          <source>color.branch</source>
          <target state="translated">color.branch</target>
        </trans-unit>
        <trans-unit id="ca9ef171160b4af8190637b4572026e1b567c98a" translate="yes" xml:space="preserve">
          <source>color.branch.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.branch.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ce3eb96e296266263902a69bbdcb71f2305cb04d" translate="yes" xml:space="preserve">
          <source>color.decorate.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.decorate.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="afd9432dd61dede344700077be0856defef90c96" translate="yes" xml:space="preserve">
          <source>color.diff</source>
          <target state="translated">color.diff</target>
        </trans-unit>
        <trans-unit id="f6c051574f795381da2ac0bc58ffe0019036f226" translate="yes" xml:space="preserve">
          <source>color.diff.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.diff.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92611cb178c25cb2a36a185c2d51eb34ec21f182" translate="yes" xml:space="preserve">
          <source>color.grep</source>
          <target state="translated">color.grep</target>
        </trans-unit>
        <trans-unit id="514f2bfe2d4e52955ecf7c8018e222f3399098ca" translate="yes" xml:space="preserve">
          <source>color.grep.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.grep.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2a6e9053b32a43b99b387012d73632508c2e585a" translate="yes" xml:space="preserve">
          <source>color.interactive</source>
          <target state="translated">color.interactive</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
