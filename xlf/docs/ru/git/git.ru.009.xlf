<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="a8fe9598336f37cb9328ca8052e59b151a7933de" translate="yes" xml:space="preserve">
          <source>Text viewer for use by Git commands (e.g., &lt;code&gt;less&lt;/code&gt;). The value is meant to be interpreted by the shell. The order of preference is the &lt;code&gt;$GIT_PAGER&lt;/code&gt; environment variable, then &lt;code&gt;core.pager&lt;/code&gt; configuration, then &lt;code&gt;$PAGER&lt;/code&gt;, and then the default chosen at compile time (usually &lt;code&gt;less&lt;/code&gt;).</source>
          <target state="translated">Средство просмотра текста для использования командами Git (например, &lt;code&gt;less&lt;/code&gt; ). Значение предназначено для интерпретации оболочкой. Порядок предпочтения - переменная среды &lt;code&gt;$GIT_PAGER&lt;/code&gt; , затем конфигурация &lt;code&gt;core.pager&lt;/code&gt; , затем &lt;code&gt;$PAGER&lt;/code&gt; , а затем значение по умолчанию, выбираемое во время компиляции (обычно &lt;code&gt;less&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0bd1b0b7ad0ea4fe7d508b463e4e610ef00887b1" translate="yes" xml:space="preserve">
          <source>That is, a pattern followed by an attributes list, separated by whitespaces. Leading and trailing whitespaces are ignored. Lines that begin with &lt;code&gt;#&lt;/code&gt; are ignored. Patterns that begin with a double quote are quoted in C style. When the pattern matches the path in question, the attributes listed on the line are given to the path.</source>
          <target state="translated">То есть шаблон, за которым следует список атрибутов, разделенных пробелами. Начальные и конечные пробелы игнорируются. Строки, начинающиеся с символа &lt;code&gt;#&lt;/code&gt; , игнорируются. Образцы, начинающиеся с двойной кавычки, цитируются в стиле C. Когда шаблон соответствует рассматриваемому пути, ему присваиваются атрибуты, перечисленные в строке.</target>
        </trans-unit>
        <trans-unit id="a2ed6bb3b9b6e451ccc6f660ef58cfb1d5aab73c" translate="yes" xml:space="preserve">
          <source>That is, from left to right:</source>
          <target state="translated">То есть,слева направо:</target>
        </trans-unit>
        <trans-unit id="8f093c96f9e4fd62eb55be18fd622f6079c4aad2" translate="yes" xml:space="preserve">
          <source>That is, from the left to the right:</source>
          <target state="translated">То есть,слева направо:</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">То есть:</target>
        </trans-unit>
        <trans-unit id="aa54aa26ef67ef77a7b5a4203a2f21478483f336" translate="yes" xml:space="preserve">
          <source>That means that even if you offer only read access (e.g. by using the pserver method), &lt;code&gt;git-cvsserver&lt;/code&gt; should have write access to the database to work reliably (otherwise you need to make sure that the database is up to date any time &lt;code&gt;git-cvsserver&lt;/code&gt; is executed).</source>
          <target state="translated">Это означает, что даже если вы предлагаете доступ только для чтения (например, с помощью метода pserver), &lt;code&gt;git-cvsserver&lt;/code&gt; должен иметь доступ на запись в базу данных для надежной работы (в противном случае вам нужно убедиться, что база данных обновлена ​​в любое время &lt;code&gt;git-cvsserver&lt;/code&gt; выполняется).</target>
        </trans-unit>
        <trans-unit id="452813997abf32b7a81b495ef3287ae8cfa66246" translate="yes" xml:space="preserve">
          <source>That means that if you do a &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; followed by a &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt;, the &lt;code&gt;git checkout-index&lt;/code&gt; only checks out the stuff that really changed.</source>
          <target state="translated">Это означает, что если вы выполните &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; , за которым следует &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt; , &lt;code&gt;git checkout-index&lt;/code&gt; проверяет только то, что действительно изменилось.</target>
        </trans-unit>
        <trans-unit id="a1aaaec20914cfb53973b0431f384394f0c406ca" translate="yes" xml:space="preserve">
          <source>That puts the heads and tags for each fork in their own island (named &quot;1234&quot; or similar), and the pull refs for each go into their own &quot;1234-pull&quot;.</source>
          <target state="translated">Это помещает головки и метки для каждой вилки на своем острове (названном &quot;1234&quot; или похожем),а тяговые ссылки для каждой из них идут в свой собственный &quot;1234-pull&quot;.</target>
        </trans-unit>
        <trans-unit id="767670eb6ab18d660b358046eb00166f0a64fef3" translate="yes" xml:space="preserve">
          <source>That will produce the diff between the tips of the two branches. If you&amp;rsquo;d prefer to find the diff from their common ancestor to test, you can use three dots instead of two:</source>
          <target state="translated">Это создаст разницу между кончиками двух ветвей. Если вы предпочитаете для проверки найти разницу от их общего предка, вы можете использовать три точки вместо двух:</target>
        </trans-unit>
        <trans-unit id="2ab4548e0b841bbace5e0a92c23778ab654224e3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why the &quot;git replace&quot; command was created. Technically it stores replacements &quot;refs&quot; in the &quot;refs/replace/&quot; hierarchy. These &quot;refs&quot; are like branches (that are stored in &quot;refs/heads/&quot;) or tags (that are stored in &quot;refs/tags&quot;), and that means that they can automatically be shared like branches or tags among developers.</source>
          <target state="translated">Вот почему была создана команда &amp;laquo;git replace&amp;raquo;. Технически он хранит замену &amp;laquo;refs&amp;raquo; в иерархии &amp;laquo;refs / replace /&amp;raquo;. Эти &amp;laquo;ссылки&amp;raquo; похожи на ветки (которые хранятся в &amp;laquo;refs / Heads /&amp;raquo;) или теги (которые хранятся в &amp;laquo;refs / tags&amp;raquo;), и это означает, что они могут автоматически совместно использоваться разработчиками, как ветки или теги.</target>
        </trans-unit>
        <trans-unit id="e7f78784e12fead6a14f302d919d7dfe2a02b05b" translate="yes" xml:space="preserve">
          <source>The &quot;child_class&quot; field is a rough classification, such as &quot;editor&quot;, &quot;pager&quot;, &quot;transport/*&quot;, and &quot;hook&quot;. Unclassified children are classified with &quot;?&quot;.</source>
          <target state="translated">Поле &quot;child_class&quot; представляет собой грубую классификацию,такую как &quot;редактор&quot;,&quot;пейджер&quot;,&quot;транспорт/*&quot; и &quot;крюк&quot;.Незасекреченные дети классифицируются с помощью &quot;?&quot;.</target>
        </trans-unit>
        <trans-unit id="fe5496d60fae83b54bfa30bb265cd284e395a597" translate="yes" xml:space="preserve">
          <source>The &quot;child_id&quot; field can be used to match this child_start with the corresponding child_exit event.</source>
          <target state="translated">Поле &quot;child_id&quot; может быть использовано для сопоставления этого дочернего_start с соответствующим событием child_exit.</target>
        </trans-unit>
        <trans-unit id="2ee1a593683be8a9c62bf7139373ea713a6461c3" translate="yes" xml:space="preserve">
          <source>The &quot;commit&quot; object links a physical state of a tree with a description of how we got there and why. Use the &lt;code&gt;--pretty=raw&lt;/code&gt; option to &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; or &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; to examine your favorite commit:</source>
          <target state="translated">Объект &amp;laquo;фиксация&amp;raquo; связывает физическое состояние дерева с описанием того, как мы туда попали и почему. Используйте параметр &lt;code&gt;--pretty=raw&lt;/code&gt; для &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; или &lt;a href=&quot;git-log&quot;&gt;git-log [1],&lt;/a&gt; чтобы проверить свой любимый коммит:</target>
        </trans-unit>
        <trans-unit id="6db6601ce62b96f9f8fba54efac9ee5967a731f4" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; value consists of a list of triplets in the form &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; where &quot;position&quot; is the label after which to insert the link, &quot;link&quot; is a format string where &lt;code&gt;%n&lt;/code&gt; expands to the project name, &lt;code&gt;%f&lt;/code&gt; to the project path within the filesystem (i.e. &quot;$projectroot/$project&quot;), &lt;code&gt;%h&lt;/code&gt; to the current hash ('h' gitweb parameter) and &lt;code&gt;%b&lt;/code&gt; to the current hash base ('hb' gitweb parameter); &lt;code&gt;%%&lt;/code&gt; expands to '%'.</source>
          <target state="translated">Значение &amp;laquo;по умолчанию&amp;raquo; состоит из списка троек в форме &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; где &amp;laquo;позиция&amp;raquo; - это метка, после которой следует вставить ссылку, &amp;laquo;ссылка&amp;raquo;. представляет собой строку формата, в которой &lt;code&gt;%n&lt;/code&gt; расширяется до имени проекта, &lt;code&gt;%f&lt;/code&gt; до пути к проекту в файловой системе (например, &quot;$ projectroot / $ project&quot;), &lt;code&gt;%h&lt;/code&gt; до текущего хэша (параметр gitweb 'h') и &lt;code&gt;%b&lt;/code&gt; до текущая хеш-база (параметр gitweb 'hb'); &lt;code&gt;%%&lt;/code&gt; заменяется на &quot;%&quot;.</target>
        </trans-unit>
        <trans-unit id="a92a8477d5d97d17f1c481b90522235992b0aec5" translate="yes" xml:space="preserve">
          <source>The &quot;delete&quot; subcommand deletes single entries from the reflog. Its argument must be an &lt;code&gt;exact&lt;/code&gt; entry (e.g. &quot;&lt;code&gt;git reflog delete
master@{2}&lt;/code&gt;&quot;). This subcommand is also typically not used directly by end users.</source>
          <target state="translated">Подкоманда &amp;laquo;delete&amp;raquo; удаляет отдельные записи из журнала ссылок. Его аргумент должен быть &lt;code&gt;exact&lt;/code&gt; записью (например, &amp;laquo; &lt;code&gt;git reflog delete master@{2}&lt;/code&gt; &amp;raquo;). Эта подкоманда также обычно не используется конечными пользователями напрямую.</target>
        </trans-unit>
        <trans-unit id="15cc724d6cfbdaca681c81ec6b39527ea7ba3e75" translate="yes" xml:space="preserve">
          <source>The &quot;downwards graduation&quot; discussed above cannot be done by actually merging downwards, however, since that would merge &lt;code&gt;all&lt;/code&gt; changes on the unstable branch into the stable one. Hence the following:</source>
          <target state="translated">Однако описанная выше &amp;laquo;нисходящая градация&amp;raquo; не может быть осуществлена ​​путем фактического слияния вниз, поскольку это объединит &lt;code&gt;all&lt;/code&gt; изменения в нестабильной ветке в стабильную. Отсюда следующее:</target>
        </trans-unit>
        <trans-unit id="4b681909e4d1085f8faa13044f43a355b4e9ca0a" translate="yes" xml:space="preserve">
          <source>The &quot;exec&quot; command launches the command in a shell (the one specified in &lt;code&gt;$SHELL&lt;/code&gt;, or the default shell if &lt;code&gt;$SHELL&lt;/code&gt; is not set), so you can use shell features (like &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot; &amp;hellip;​). The command is run from the root of the working tree.</source>
          <target state="translated">Команда &quot;exec&quot; запускает команду в оболочке (той, которая указана в &lt;code&gt;$SHELL&lt;/code&gt; , или оболочке по умолчанию, если &lt;code&gt;$SHELL&lt;/code&gt; не установлена), поэтому вы можете использовать функции оболочки (например, &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot; ...). Команда запускается из корня рабочего дерева.</target>
        </trans-unit>
        <trans-unit id="3e27bb28ac33a3ed0da91ec19b0543d1741f2754" translate="yes" xml:space="preserve">
          <source>The &quot;exec_id&quot; field is a command-unique id and is only useful if the &lt;code&gt;exec()&lt;/code&gt; fails and a corresponding exec_result event is generated.</source>
          <target state="translated">Поле &amp;laquo;exec_id&amp;raquo; является уникальным для команды идентификатором и полезно только в том случае, если &lt;code&gt;exec()&lt;/code&gt; не работает и создается соответствующее событие exec_result.</target>
        </trans-unit>
        <trans-unit id="111dec81403753e6a7d49025386f92b4f5a7ce80" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; subcommand checks whether a ref has a reflog. It exits with zero status if the reflog exists, and non-zero status if it does not.</source>
          <target state="translated">Подкоманда &quot;существует&quot; проверяет,есть ли у ссылки рефлог.Она выходит с нулевым статусом,если рефлог существует,и ненулевым,если нет.</target>
        </trans-unit>
        <trans-unit id="b084a3a2964fff409a1c4bd5eaf3ff2af985bb46" translate="yes" xml:space="preserve">
          <source>The &quot;experimental&quot; branch is the one you just created, and the &quot;master&quot; branch is a default branch that was created for you automatically. The asterisk marks the branch you are currently on; type</source>
          <target state="translated">Экспериментальная&quot; ветка-это та,которую вы только что создали,а &quot;основная&quot; ветка-это ветка по умолчанию,которая была создана для вас автоматически.Звездочкой отмечена ветка,в которой вы в данный момент находитесь;наберите</target>
        </trans-unit>
        <trans-unit id="8a5c55e5646a8a6620c2e2207d5f34af5eadc4f2" translate="yes" xml:space="preserve">
          <source>The &quot;expire&quot; subcommand prunes older reflog entries. Entries older than &lt;code&gt;expire&lt;/code&gt; time, or entries older than &lt;code&gt;expire-unreachable&lt;/code&gt; time and not reachable from the current tip, are removed from the reflog. This is typically not used directly by end users &amp;mdash; instead, see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">Подкоманда &quot;expire&quot; удаляет старые записи журнала ссылок. Записи старше времени &lt;code&gt;expire&lt;/code&gt; срока или записи старше времени &lt;code&gt;expire-unreachable&lt;/code&gt; и недостижимые из текущей подсказки удаляются из журнала ссылок. Обычно это не используется напрямую конечными пользователями - вместо этого см. &lt;a href=&quot;git-gc&quot;&gt;Git-gc [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51ddfbdb206861a134ce9d36a0cd6f8dcb912a92" translate="yes" xml:space="preserve">
          <source>The &quot;extent of changes&quot; parameter can be tweaked from the default 80% (that is, unless more than 80% of the original material is deleted, the broken pairs are merged back into a single modification) by giving a second number to -B option, like these:</source>
          <target state="translated">Параметр &quot;степень изменений&quot; может быть откорректирован с 80% по умолчанию (т.е.если не удалено более 80% исходного материала,сломанные пары объединяются обратно в одну модификацию)путем присвоения второго числа опции -B,вроде этих:</target>
        </trans-unit>
        <trans-unit id="4be913eb74285fc0f11c845775de3706d8e8ac4f" translate="yes" xml:space="preserve">
          <source>The &quot;git-diff-tree&quot; command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file.</source>
          <target state="translated">Команда &quot;git-diff-tree&quot; начинает вывод с распечатки хэша того,что сравнивается.После этого все команды выводят по одной строке на каждый изменённый файл.</target>
        </trans-unit>
        <trans-unit id="14e841537fdff67ebd6d58e11774065ab0f0ebfa" translate="yes" xml:space="preserve">
          <source>The &quot;indent&quot; filter is well-behaved in this regard: it will not modify input that is already correctly indented. In this case, the lack of a smudge filter means that the clean filter &lt;code&gt;must&lt;/code&gt; accept its own output without modifying it.</source>
          <target state="translated">В этом отношении фильтр &amp;laquo;Отступ&amp;raquo; ведет себя хорошо: он не будет изменять ввод, который уже имеет правильный отступ. В этом случае отсутствие фильтра пятен означает, что чистый фильтр &lt;code&gt;must&lt;/code&gt; принимать собственный вывод, не изменяя его.</target>
        </trans-unit>
        <trans-unit id="2a9f18fc49cc181471bfbc97a47a88e9bcc1179f" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the &lt;code&gt;add&lt;/code&gt; command to add any new or modified files to the index.</source>
          <target state="translated">&amp;laquo;Индекс&amp;raquo; содержит снимок содержимого рабочего дерева, и именно этот снимок используется в качестве содержимого следующей фиксации. Таким образом, после внесения каких-либо изменений в рабочее дерево и перед запуском команды фиксации вы должны использовать команду &lt;code&gt;add&lt;/code&gt; для добавления любых новых или измененных файлов в индекс.</target>
        </trans-unit>
        <trans-unit id="6b5b86b50febe55839cf4e73fade50a78b6b0a0e" translate="yes" xml:space="preserve">
          <source>The &quot;master&quot; branch that was created at the time you cloned is a copy of the HEAD in the repository that you cloned from. That repository may also have had other branches, though, and your local repository keeps branches which track each of those remote branches, called remote-tracking branches, which you can view using the &lt;code&gt;-r&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;:</source>
          <target state="translated">&amp;laquo;Главная&amp;raquo; ветвь, созданная во время клонирования, является копией HEAD в репозитории, из которого вы клонировали. Однако у этого репозитория могут быть и другие ветки, и ваш локальный репозиторий хранит ветки, которые отслеживают каждую из этих удаленных веток, называемых ветками удаленного отслеживания, которые вы можете просмотреть с помощью параметра &lt;code&gt;-r&lt;/code&gt; в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b0e05ae2162ea2794c2d7383fd67bd0eb622aa45" translate="yes" xml:space="preserve">
          <source>The &quot;name&quot; field is an arbitrary string to describe the command mode. For example, checkout can checkout a branch or an individual file. And these variations typically have different performance characteristics that are not comparable.</source>
          <target state="translated">Поле &quot;имя&quot; является произвольной строкой для описания режима команды.Например,можно проверить ветку или отдельный файл.И эти вариации,как правило,имеют различные характеристики производительности,которые не поддаются сравнению.</target>
        </trans-unit>
        <trans-unit id="dd5002fa5ace7f79f3506e0a4b77fdeff5bda038" translate="yes" xml:space="preserve">
          <source>The &quot;non-cached&quot; mode takes a different approach, and is potentially the more useful of the two in that what it does can&amp;rsquo;t be emulated with a &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt;. Thus that&amp;rsquo;s the default mode. The non-cached version asks the question:</source>
          <target state="translated">Режим &amp;laquo;без кеширования&amp;raquo; использует другой подход и потенциально является более полезным из двух, поскольку то, что он делает, нельзя эмулировать с помощью &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt; . Таким образом, это режим по умолчанию. Некешированная версия задает вопрос:</target>
        </trans-unit>
        <trans-unit id="fb600e178320a3e93fbf20a6c6f69b12e2843e17" translate="yes" xml:space="preserve">
          <source>The &quot;pull&quot; command thus performs two operations: it fetches changes from a remote branch, then merges them into the current branch.</source>
          <target state="translated">Таким образом,команда &quot;pull&quot; выполняет две операции:извлекает изменения из удаленного ответвления,затем сливает их в текущее.</target>
        </trans-unit>
        <trans-unit id="70b3edc9504f2665b7793306c4b0a620ef20dadb" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is destination of a push operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">&amp;laquo;Удаленный&amp;raquo; репозиторий, являющийся местом назначения операции push. Этот параметр может быть либо URL-адресом (см. Раздел URL-адреса &lt;a href=&quot;#URLS&quot;&gt;GIT&lt;/a&gt; ниже), либо именем удаленного устройства (см. Раздел &amp;laquo; &lt;a href=&quot;#REMOTES&quot;&gt;УДАЛЕННЫЕ УДАЛЕНИЯ&amp;raquo;&lt;/a&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="0610be2d46404a8f9561c2512c45bc2650bc2b77" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">&amp;laquo;Удаленный&amp;raquo; репозиторий, являющийся источником операции выборки или извлечения. Этот параметр может быть либо URL-адресом (см. Раздел URL-адреса &lt;a href=&quot;#URLS&quot;&gt;GIT&lt;/a&gt; ниже), либо именем удаленного устройства (см. Раздел &amp;laquo; &lt;a href=&quot;#REMOTES&quot;&gt;УДАЛЕННЫЕ УДАЛЕНИЯ&amp;raquo;&lt;/a&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="672e385879e10047919cb534a388204453fa9b9b" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository to query. This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">&quot;Удаленный&quot; репозиторий для запроса. Этот параметр может быть либо URL-адресом, либо именем удаленного устройства (см. Разделы GIT URLS и REMOTES в &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c6967bbb137406cb4cb1860aeca604a66e63b551" translate="yes" xml:space="preserve">
          <source>The &quot;show&quot; subcommand (which is also the default, in the absence of any subcommands) shows the log of the reference provided in the command-line (or &lt;code&gt;HEAD&lt;/code&gt;, by default). The reflog covers all recent actions, and in addition the &lt;code&gt;HEAD&lt;/code&gt; reflog records branch switching. &lt;code&gt;git reflog show&lt;/code&gt; is an alias for &lt;code&gt;git log -g --abbrev-commit
--pretty=oneline&lt;/code&gt;; see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for more information.</source>
          <target state="translated">Подкоманда &quot;show&quot; (которая также используется по умолчанию при отсутствии каких-либо подкоманд) показывает журнал ссылки, предоставленной в командной строке (или &lt;code&gt;HEAD&lt;/code&gt; по умолчанию). Reflog охватывает все недавние действия, а также &lt;code&gt;HEAD&lt;/code&gt; reflog записывает переключение ветвей. &lt;code&gt;git reflog show&lt;/code&gt; - это псевдоним для &lt;code&gt;git log -g --abbrev-commit --pretty=oneline&lt;/code&gt; ; см. &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="9f44e4ac17ec1a545f86623659c266196a2646a2" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; command is a useful way to get a quick summary of the situation:</source>
          <target state="translated">Команда &quot;статус&quot;-это полезный способ получить быстрый обзор ситуации:</target>
        </trans-unit>
        <trans-unit id="97877392fd9cfcae446bf7fdee6a5be7af0d7e1e" translate="yes" xml:space="preserve">
          <source>The &quot;tar.gz&quot; and &quot;tgz&quot; formats are defined automatically and default to &lt;code&gt;gzip -cn&lt;/code&gt;. You may override them with custom commands.</source>
          <target state="translated">Форматы &quot;tar.gz&quot; и &quot;tgz&quot; определяются автоматически и по умолчанию имеют значение &lt;code&gt;gzip -cn&lt;/code&gt; . Вы можете переопределить их с помощью специальных команд.</target>
        </trans-unit>
        <trans-unit id="de5a671425f0a835fc1aa7cc9c82d529d93b1856" translate="yes" xml:space="preserve">
          <source>The &quot;tree&quot; object here refers to the new state of the tree:</source>
          <target state="translated">Объект &quot;дерево&quot; здесь относится к новому состоянию дерева:</target>
        </trans-unit>
        <trans-unit id="e01253337b76bf7642cbcef035c48eb0188a2f7d" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; field may be an integer or a string.</source>
          <target state="translated">Поле &quot;значение&quot; может быть целым числом или строкой.</target>
        </trans-unit>
        <trans-unit id="38b8f4a1de6f86897b3e2a50acc4b0dda41fe280" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dataref&amp;gt; represents the blob, tree, or commit object at &amp;lt;path&amp;gt; and can be used in later &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, or &lt;code&gt;ls&lt;/code&gt; commands.</source>
          <target state="translated">&amp;lt;dataref&amp;gt; представляет большой двоичный объект, дерево или объект фиксации в &amp;lt;path&amp;gt; и может использоваться в более поздних командах &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; , &lt;code&gt;filemodify&lt;/code&gt; или &lt;code&gt;ls&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="118ecd88d0a05a5c1cb4a877b8fac543b0b9ad8d" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dst&amp;gt; tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; argument is set to update some ref at the destination with &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; with &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; configuration variable, &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; part can be omitted&amp;mdash;​such a push will update a ref that &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; normally updates without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; on the command line. Otherwise, missing &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; means to update the same ref as the &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;dst&amp;gt; сообщает, какая ссылка на удаленной стороне обновляется этим нажатием. Здесь нельзя использовать произвольные выражения, необходимо указать действительную ссылку. Если &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; без аргумента &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; установлен для обновления некоторой ссылки в месте назначения с помощью &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; с переменной конфигурации &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; , часть &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; может быть опущена - например, push обновит ссылку, которая обычно обновляется &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; без &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; в командной строке. В противном случае отсутствует &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; означает обновление той же ссылки, что и &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a11f746174b65907575be3c7e94b2869a6db53ed" translate="yes" xml:space="preserve">
          <source>The &amp;lt;feature&amp;gt; part of the command may be any one of the following:</source>
          <target state="translated">Часть &amp;lt;feature&amp;gt; команды может быть любой из следующих:</target>
        </trans-unit>
        <trans-unit id="12c10723a00c71e41369dc4ab439f9bc656fc9a7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;file&amp;gt; list given to the command can be exact pathnames, file glob patterns, or leading directory names. The command removes only the paths that are known to Git. Giving the name of a file that you have not told Git about does not remove that file.</source>
          <target state="translated">Список &amp;lt;file&amp;gt;, передаваемый команде, может содержать точные пути, шаблоны файловых глобусов или ведущие имена каталогов. Команда удаляет только пути, известные Git. Указание имени файла, о котором вы не сообщили Git, не удаляет этот файл.</target>
        </trans-unit>
        <trans-unit id="d9a9d78d51370431396c79c2da7d525a4215ec53" translate="yes" xml:space="preserve">
          <source>The &amp;lt;paths&amp;gt; parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them).</source>
          <target state="translated">Параметры &amp;lt;paths&amp;gt;, если они заданы, используются для ограничения сравнения именованными путями (вы можете указать имена каталогов и получить diff для всех файлов в них).</target>
        </trans-unit>
        <trans-unit id="be0e9224a3c31468000ef31d0ee2d41289501c7f" translate="yes" xml:space="preserve">
          <source>The &amp;lt;src&amp;gt; is often the name of the branch you would want to push, but it can be any arbitrary &quot;SHA-1 expression&quot;, such as &lt;code&gt;master~4&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;).</source>
          <target state="translated">&amp;lt;src&amp;gt; часто является именем ветки, которую вы хотите отправить, но это может быть любое произвольное &amp;laquo;выражение SHA-1&amp;raquo;, например &lt;code&gt;master~4&lt;/code&gt; или &lt;code&gt;HEAD&lt;/code&gt; (см. &lt;a href=&quot;gitrevisions&quot;&gt;Gitrevisions [7]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="94b79c58bc3ec3bceec3b732165a2a52f94063c6" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is present in the database but never &lt;code&gt;directly&lt;/code&gt; used. A dangling commit could be a root node.</source>
          <target state="translated">&amp;lt;type&amp;gt; объект &amp;lt;object&amp;gt; присутствует в базе данных, но никогда &lt;code&gt;directly&lt;/code&gt; не используется. Висящий коммит может быть корневым узлом.</target>
        </trans-unit>
        <trans-unit id="c165697ba8df58634f80c6f82752d5afcdee5578" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is referred to but isn&amp;rsquo;t present in the database.</source>
          <target state="translated">На объект &amp;lt;type&amp;gt; &amp;lt;object&amp;gt; имеется ссылка, но он отсутствует в базе данных.</target>
        </trans-unit>
        <trans-unit id="5e6573bf54036812f2655d363c6262b69c0dca40" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, isn&amp;rsquo;t actually referred to directly or indirectly in any of the trees or commits seen. This can mean that there&amp;rsquo;s another root node that you&amp;rsquo;re not specifying or that the tree is corrupt. If you haven&amp;rsquo;t missed a root node then you might as well delete unreachable nodes since they can&amp;rsquo;t be used.</source>
          <target state="translated">Объект &amp;lt;type&amp;gt; &amp;lt;object&amp;gt; на самом деле не упоминается прямо или косвенно ни в одном из наблюдаемых деревьев или коммитов. Это может означать, что есть еще один корневой узел, который вы не указываете, или что дерево повреждено. Если вы не пропустили корневой узел, вы также можете удалить недоступные узлы, поскольку они не могут быть использованы.</target>
        </trans-unit>
        <trans-unit id="afa0888330a84b7e0fff615f1c9b8a57ecf94505" translate="yes" xml:space="preserve">
          <source>The 'git sh-i18n scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by Git&amp;rsquo;s porcelain programs implemented in shell script. It provides wrappers for the GNU &lt;code&gt;gettext&lt;/code&gt; and &lt;code&gt;eval_gettext&lt;/code&gt; functions accessible through the &lt;code&gt;gettext.sh&lt;/code&gt; script, and provides pass-through fallbacks on systems without GNU gettext.</source>
          <target state="translated">Сценарий 'git sh-i18n' предназначен для получения (использования &lt;code&gt;.&lt;/code&gt; ) Фарфоровыми программами Git, реализованными в сценарии оболочки. Он предоставляет оболочки для функций GNU &lt;code&gt;gettext&lt;/code&gt; и &lt;code&gt;eval_gettext&lt;/code&gt; , доступные через сценарий &lt;code&gt;gettext.sh&lt;/code&gt; , и обеспечивает сквозные резервные варианты для систем без GNU gettext.</target>
        </trans-unit>
        <trans-unit id="75c51ca5866a2731f86888419b9fb61d16567aec" translate="yes" xml:space="preserve">
          <source>The (fully qualified) refname from which to show notes when showing commit messages. The value of this variable can be set to a glob, in which case notes from all matching refs will be shown. You may also specify this configuration variable several times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">Имя (полностью квалифицированное),с которого будут показываться заметки при показе сообщений о фиксации.Значение этой переменной может быть установлено в глобус,в этом случае будут показываться заметки из всех совпадающих ссылок.Вы также можете указать эту переменную конфигурации несколько раз.Предупреждение будет выдано для несуществующих ссылок,но глобус,не совпадающий ни с какими ссылками,будет беззвучно проигнорирован.</target>
        </trans-unit>
        <trans-unit id="1e4ce979f13cefaaddaddc6c3ce47e1170286daa" translate="yes" xml:space="preserve">
          <source>The (possibly remote) repository to clone from. See the &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; section below for more information on specifying repositories.</source>
          <target state="translated">Репозиторий (возможно удаленный) для клонирования. См. Раздел &lt;a href=&quot;#URLS&quot;&gt;URL-адреса GIT&lt;/a&gt; ниже для получения дополнительной информации об указании репозиториев.</target>
        </trans-unit>
        <trans-unit id="0958323d0ba18cc1a0d938e257756d1659d52ec9" translate="yes" xml:space="preserve">
          <source>The --exclude-existing form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don&amp;rsquo;t exist in the local repository.</source>
          <target state="translated">Форма --exclude-existing - это фильтр, выполняющий обратное. Он считывает ссылки со стандартного ввода, по одной ссылке в строке, и показывает те, которых нет в локальном репозитории.</target>
        </trans-unit>
        <trans-unit id="a043107d8410def266c54e81fdffaefcdaf6dd4c" translate="yes" xml:space="preserve">
          <source>The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option.</source>
          <target state="translated">Опция --smtp-server-option должна быть повторена для каждой опции,которую вы хотите передать серверу.Аналогично,для каждого параметра должны быть использованы различные строки в конфигурационных файлах.</target>
        </trans-unit>
        <trans-unit id="b478196a2fb02489b622996c5ea9b31713647e4d" translate="yes" xml:space="preserve">
          <source>The .git location may be auto-discovered, or come from &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable. If the repository is auto discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the .git file is.</source>
          <target state="translated">Местоположение .git может быть обнаружено автоматически или &lt;code&gt;$GIT_DIR&lt;/code&gt; переменной среды $ GIT_DIR . Если репозиторий автоматически обнаруживается через файл .git (например, из подмодулей или связанного рабочего дерева), местоположение .git будет последним местоположением, где находится каталог .git, а не файлом .git.</target>
        </trans-unit>
        <trans-unit id="489d70f8c8831a28cdf6bb81a4079dab3fec8b7e" translate="yes" xml:space="preserve">
          <source>The 40-hex object name of the object.</source>
          <target state="translated">Имя объекта размером в 40 гексов.</target>
        </trans-unit>
        <trans-unit id="edba0bac58d4604af8b0ccc3234ca39328b25c20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; command can create a tar or zip archive from any version of a project; for example:</source>
          <target state="translated">Команда &lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt; может создать tar или zip-архив из любой версии проекта; например:</target>
        </trans-unit>
        <trans-unit id="8ff01ddb94fa5e45588517f77b5eb76be2068bf4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command correctly handles history that includes merge commits. However, when the commit that it finds is a merge commit, the user may need to work harder than usual to figure out why that commit introduced a problem.</source>
          <target state="translated">Команда &lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]&lt;/a&gt; правильно обрабатывает историю, которая включает коммиты слияния. Однако, когда обнаруженная фиксация является фиксацией слияния, пользователю может потребоваться больше усилий, чем обычно, чтобы выяснить, почему эта фиксация привела к проблеме.</target>
        </trans-unit>
        <trans-unit id="a1047413b5c194a852bce97f1a7a5b5c064c8f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; command can show the contents of any object, though the higher-level &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; is usually more useful.</source>
          <target state="translated">Команда &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt; может отображать содержимое любого объекта, хотя &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; более высокого уровня обычно более полезен.</target>
        </trans-unit>
        <trans-unit id="0ea75322cb21a3c3c8fac48d1e6228de3fae3cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; command allows constructing commits with arbitrary parents and trees.</source>
          <target state="translated">Команда &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; позволяет создавать коммиты с произвольными родителями и деревьями.</target>
        </trans-unit>
        <trans-unit id="efc26cd7227657520a6926ebb23db38544c357a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-describe&quot;&gt;git-describe[1]&lt;/a&gt; command does the opposite, naming the revision using a tag on which the given commit is based:</source>
          <target state="translated">Команда &lt;a href=&quot;git-describe&quot;&gt;git-describe [1]&lt;/a&gt; делает обратное, называя ревизию с помощью тега, на котором основана данная фиксация:</target>
        </trans-unit>
        <trans-unit id="9903942bbbf43f525c7cf036d25898c86f9d9d7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command runs a number of self-consistency checks on the repository, and reports on any problems. This may take some time.</source>
          <target state="translated">Команда &lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt; запускает ряд проверок самосогласованности репозитория и сообщает о любых проблемах. Это может занять некоторое время.</target>
        </trans-unit>
        <trans-unit id="ff835519b77a7ea3e8c99474cee535ec38ab3bd6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command will sometimes complain about dangling objects. They are not a problem.</source>
          <target state="translated">Команда &lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt; иногда жалуется на болтающиеся объекты. Это не проблема.</target>
        </trans-unit>
        <trans-unit id="d818a9097a56e35195bf0f4a41317be4c1298cc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; command performs packing, pruning, and more for you, so is normally the only high-level command you need.</source>
          <target state="translated">Команда &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; выполняет упаковку, сокращение и многое другое за вас, поэтому обычно это единственная команда высокого уровня, которая вам нужна.</target>
        </trans-unit>
        <trans-unit id="7674cbc9fda493edc257e040882a4d3b2fee5da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; command provides a simple way to start browsing the repository using gitweb. The default server when using instaweb is lighttpd.</source>
          <target state="translated">Команда &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; предоставляет простой способ начать просмотр репозитория с помощью gitweb. Сервер по умолчанию при использовании instaweb - lighttpd.</target>
        </trans-unit>
        <trans-unit id="3d865565a2d1aab8d65d5524c33990e3ecd5eee4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; commands also provide special help for merges:</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;ГИТ-журнал [1]&lt;/a&gt; и &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; команда также предоставляют специальную помощь для слияний:</target>
        </trans-unit>
        <trans-unit id="869571e8bf360d23843fed69fde509a99aec51ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command can show lists of commits. On its own, it shows all commits reachable from the parent commit; but you can also make more specific requests:</source>
          <target state="translated">Команда &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; может отображать списки коммитов. Сам по себе он показывает все коммиты, доступные из родительского коммита; но вы также можете сделать более конкретные запросы:</target>
        </trans-unit>
        <trans-unit id="49730fd39b9c73a554b2cce254c7d8e26a1047e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; command is a low-level command that is occasionally useful for translating some name for a commit to the object name for that commit:</source>
          <target state="translated">Команда &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; - это команда низкого уровня, которая иногда бывает полезна для преобразования некоторого имени фиксации в имя объекта для этой фиксации:</target>
        </trans-unit>
        <trans-unit id="d0ac1c8438cdf91fddee2ad5a2dd381f720a6756" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; command is available since Git 1.5.3. Users with Git 1.5.2 can look up the submodule commits in the repository and manually check them out; earlier versions won&amp;rsquo;t recognize the submodules at all.</source>
          <target state="translated">Команда &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; доступна с Git 1.5.3. Пользователи Git 1.5.2 могут искать коммиты подмодуля в репозитории и вручную проверять их; более ранние версии вообще не распознают подмодули.</target>
        </trans-unit>
        <trans-unit id="8ffc16af4f4197ccdbaaceb3fe6721dcc4562d83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; command updates the index with information from the working directory. You generally update the index information by just specifying the filename you want to update, like so:</source>
          <target state="translated">Команда &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; обновляет индекс информацией из рабочего каталога. Обычно вы обновляете информацию индекса, просто указывая имя файла, которое вы хотите обновить, например:</target>
        </trans-unit>
        <trans-unit id="20874526426e66810d4174f5227a378a8de7e91c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git repo-filter&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="translated">Инструмент &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; является альтернативой git-filter-branch, который не страдает от этих проблем с производительностью или проблем безопасности (упомянутых ниже). Для тех, у кого есть существующий инструментарий, который полагается на git-filter-branch, &lt;code&gt;git repo-filter&lt;/code&gt; также предоставляет &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;неубедительную&lt;/a&gt; замену git-filter-branch с несколькими фильтрами (с некоторыми оговорками). Хотя filter-lamely страдает от тех же проблем безопасности, что и git-filter-branch, он, по крайней мере, немного улучшает проблемы с производительностью.</target>
        </trans-unit>
        <trans-unit id="ad21d56fce6cdd39ef4f92ed0708902d059eaafc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual&quot;&gt;Git User&amp;rsquo;s Manual&lt;/a&gt; provides a more comprehensive introduction to Git.</source>
          <target state="translated">Руководство &lt;a href=&quot;user-manual&quot;&gt;пользователя Git&lt;/a&gt; содержит более полное введение в Git.</target>
        </trans-unit>
        <trans-unit id="89c784f1b1d17488cfe361d4581fd69d6d34303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; both provide introductions to the underlying Git architecture.</source>
          <target state="translated">И &lt;a href=&quot;user-manual#git-concepts&quot;&gt;глава, &lt;/a&gt;&lt;a href=&quot;gitcore-tutorial&quot;&gt;посвященная &lt;/a&gt;концепциям Git, и руководство по gitcore [7] предоставляют введение в базовую архитектуру Git.</target>
        </trans-unit>
        <trans-unit id="5f7a0a0ce9975de955e97678d53d0386ebf8b091" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file is used to define the skip-worktree reference bitmap. When Git updates the working directory, it updates the skip-worktree bits in the index based on this file. The files matching the patterns in the file will appear in the working directory, and the rest will not.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; файл используются для определения пропуска worktree ссылочных растрового. Когда Git обновляет рабочий каталог, он обновляет биты skip-worktree в индексе на основе этого файла. Файлы, соответствующие шаблонам в файле, появятся в рабочем каталоге, а остальные - нет.</target>
        </trans-unit>
        <trans-unit id="18927ccc4077efc9fa00280f487bf7ea52068011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; part of the command may contain any sequence of bytes that does not contain &lt;code&gt;LF&lt;/code&gt;. The &lt;code&gt;LF&lt;/code&gt; after the command is optional. Callers may wish to process the output through a tool such as sed to remove the leading part of the line, for example:</source>
          <target state="translated">Часть команды &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; может содержать любую последовательность байтов, не содержащую &lt;code&gt;LF&lt;/code&gt; . &lt;code&gt;LF&lt;/code&gt; после команды не является обязательным. Вызывающие могут захотеть обработать вывод с помощью такого инструмента, как sed, чтобы удалить начальную часть строки, например:</target>
        </trans-unit>
        <trans-unit id="38ecaff497a30523addb0d68ac2f3ff7d62121ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) or the full 40-byte SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be written. The path is relative to the top level of the tree named by &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; может быть ссылка знака ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) или полный 40-байтовый SHA-1 тег Git, фиксация или дерево объектов, существовавшей ранее или ожиданий должны быть записано. Путь &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; относительно верхнего уровня дерева, названного &amp;lt;dataref&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="df9429d81584e26f1a55e7eff78d6952383c6adf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be written.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; может быть либо опознавательный знак ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) установлен ранее или полный 40-байтовый SHA-1 из сгустка Git, существовавшие ранее , или готов быть записаны.</target>
        </trans-unit>
        <trans-unit id="d38490ce2af2d9b14b21e7e25c13d2a1c79c408e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; part of the command may contain any of the options listed in the OPTIONS section that do not change import semantics, without the leading &lt;code&gt;--&lt;/code&gt; and is treated in the same way.</source>
          <target state="translated">Часть команды &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; может содержать любые параметры, перечисленные в разделе OPTIONS, которые не изменяют семантику импорта, без начала &lt;code&gt;--&lt;/code&gt; и обрабатывается таким же образом.</target>
        </trans-unit>
        <trans-unit id="73cfe0e2f7b7cccff976b7e355044194793ceedb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; is used for pushes only. It is optional and defaults to &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; используется только для толчков. Это необязательно, по умолчанию используется &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="226bf97de37dae89426f4bcaf2c8464c2aaac4ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; notation includes &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; but excludes the &amp;lt;n&amp;gt;th parent (i.e. a shorthand for &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;), with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given. This is typically useful for merge commits where you can just pass &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; to get all the commits in the branch that was merged in merge commit &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; (including &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; itself).</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; обозначения включают в себя &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; но исключает &amp;lt;п&amp;gt; я родитель (т.е. сокращение для &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; ), с &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 , если не дано. Обычно это полезно для &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; слияния, где вы можете просто передать &amp;lt;commit&amp;gt; ^ - чтобы получить все коммиты в ветке, которые были объединены в коммите слияния &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; (включая сам &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="382c52b269a126869d3f5e611e50db349c01a555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, &lt;code&gt;-a&lt;/code&gt;. Using &lt;code&gt;--&lt;/code&gt; is probably a good policy in scripts.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; это просто хорошая идея , когда вы знаете , остальные будут имена файлов; это предотвратит проблемы с именем файла, например, &lt;code&gt;-a&lt;/code&gt; . Использование &lt;code&gt;--&lt;/code&gt; вероятно, хорошая политика в скриптах.</target>
        </trans-unit>
        <trans-unit id="1a7c2f7d5b7ec8386e86076d812d974232af3082" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cached&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;only&lt;/strong&gt; work with the index. For example, &lt;code&gt;git grep&lt;/code&gt;, when used without a commit to specify from which commit to look for strings in, usually works on files in the working tree, but with the &lt;code&gt;--cached&lt;/code&gt; option, it looks for strings in the index.</source>
          <target state="translated">Параметр &lt;code&gt;--cached&lt;/code&gt; используется, чтобы запросить команду, которая обычно работает с файлами в рабочем дереве, работать &lt;strong&gt;только&lt;/strong&gt; с индексом. Например, &lt;code&gt;git grep&lt;/code&gt; при использовании без фиксации, чтобы указать, в какой фиксации искать строки, обычно работает с файлами в рабочем дереве, но с параметром &lt;code&gt;--cached&lt;/code&gt; он ищет строки в индексе.</target>
        </trans-unit>
        <trans-unit id="93eb90d6c0bfdb16dcadbf4c72d38d80f8bf4451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--dry-run&lt;/code&gt; option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths).</source>
          <target state="translated">Параметр &lt;code&gt;--dry-run&lt;/code&gt; может использоваться для получения сводной информации о том, что включено в любой из вышеперечисленных вариантов для следующего коммита, задав тот же набор параметров (параметры и пути).</target>
        </trans-unit>
        <trans-unit id="45e26263ba79c46b47e35a4fe67d4d8f33b37e0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--env-filter&lt;/code&gt; option can be used to modify committer and/or author identity. For example, if you found out that your commits have the wrong identity due to a misconfigured user.email, you can make a correction, before publishing the project, like this:</source>
          <target state="translated">Параметр &lt;code&gt;--env-filter&lt;/code&gt; может использоваться для изменения личности коммиттера и / или автора. Например, если вы обнаружили, что ваши коммиты имеют неправильную идентификацию из-за неправильно настроенной электронной почты user.email, вы можете внести исправления перед публикацией проекта, например:</target>
        </trans-unit>
        <trans-unit id="b4b7635118d0a90fb277012f2d96d5181b61e4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--index&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;also&lt;/strong&gt; affect the index. For example, &lt;code&gt;git stash apply&lt;/code&gt; usually merges changes recorded in a stash entry to the working tree, but with the &lt;code&gt;--index&lt;/code&gt; option, it also merges changes to the index as well.</source>
          <target state="translated">Параметр &lt;code&gt;--index&lt;/code&gt; используется, чтобы попросить команду, которая обычно работает с файлами в рабочем дереве, &lt;strong&gt;также&lt;/strong&gt; повлиять на индекс. Например, &lt;code&gt;git stash apply&lt;/code&gt; обычно объединяет изменения, записанные в записи &lt;code&gt;--index&lt;/code&gt; , с рабочим деревом, но с параметром --index он также объединяет изменения в индекс.</target>
        </trans-unit>
        <trans-unit id="f5e672ca7275921f27bc57abfee8498efa38d837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numstat&lt;/code&gt; option gives the diffstat(1) information but is designed for easier machine consumption. An entry in &lt;code&gt;--numstat&lt;/code&gt; output looks like this:</source>
          <target state="translated">Опция &lt;code&gt;--numstat&lt;/code&gt; дает информацию о diffstat (1), но предназначена для облегчения использования машины. Запись в &lt;code&gt;--numstat&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="824224d8413c92cfa07b10a7d5f109653a254225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--patch&lt;/code&gt; option implies &lt;code&gt;--keep-index&lt;/code&gt;. You can use &lt;code&gt;--no-keep-index&lt;/code&gt; to override this.</source>
          <target state="translated">Параметр &lt;code&gt;--patch&lt;/code&gt; подразумевает &lt;code&gt;--keep-index&lt;/code&gt; . Вы можете использовать &lt;code&gt;--no-keep-index&lt;/code&gt; , чтобы переопределить это.</target>
        </trans-unit>
        <trans-unit id="cd53bf0606653a9e38fc2f67928f722d519b8437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--prune-tags&lt;/code&gt; option is equivalent to having &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; declared in the refspecs of the remote. This can lead to some seemingly strange interactions:</source>
          <target state="translated">Параметр &lt;code&gt;--prune-tags&lt;/code&gt; эквивалентен объявлению &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; в refspecs пульта дистанционного управления. Это может привести к некоторым, казалось бы, странным взаимодействиям:</target>
        </trans-unit>
        <trans-unit id="eedbb7a82985c4671f5041c09553972a9225fc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rebase-merges&lt;/code&gt; mode is similar in spirit to the deprecated &lt;code&gt;--preserve-merges&lt;/code&gt; but works with interactive rebases, where commits can be reordered, inserted and dropped at will.</source>
          <target state="translated">Режим &lt;code&gt;--rebase-merges&lt;/code&gt; по духу похож на устаревший &lt;code&gt;--preserve-merges&lt;/code&gt; но работает с интерактивными перебазами, где коммиты можно переупорядочивать, вставлять и отбрасывать по желанию.</target>
        </trans-unit>
        <trans-unit id="8061f1189be4b513311a10997c4e6fc449baeaf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--simplify-by-decoration&lt;/code&gt; option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).</source>
          <target state="translated">Параметр &lt;code&gt;--simplify-by-decoration&lt;/code&gt; позволяет просматривать только общую картину топологии истории, исключая коммиты, на которые не ссылаются теги. Коммиты помечаются как! TREESAME (другими словами, сохраняются после правил упрощения истории, описанных выше), если (1) на них ссылаются теги, или (2) они изменяют содержимое путей, указанных в командной строке. Все остальные коммиты помечены как TREESAME (подлежат упрощению).</target>
        </trans-unit>
        <trans-unit id="16b8753fdc735c82bb8e4b4e3197e33fe132b018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--summary&lt;/code&gt; option describes newly added, deleted, renamed and copied files. The &lt;code&gt;--stat&lt;/code&gt; option adds diffstat(1) graph to the output. These options can be combined with other options, such as &lt;code&gt;-p&lt;/code&gt;, and are meant for human consumption.</source>
          <target state="translated">Параметр &lt;code&gt;--summary&lt;/code&gt; описывает недавно добавленные, удаленные, переименованные и скопированные файлы. Параметр &lt;code&gt;--stat&lt;/code&gt; добавляет к выходным данным график diffstat (1). Эти параметры можно комбинировать с другими параметрами, такими как &lt;code&gt;-p&lt;/code&gt; , и они предназначены для использования человеком.</target>
        </trans-unit>
        <trans-unit id="2fb3a538afbb18a8ca912f0cecf9a31cb6701775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; option instructs &lt;code&gt;git config&lt;/code&gt; to ensure that incoming and outgoing values are canonicalize-able under the given &amp;lt;type&amp;gt;. If no &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; is given, no canonicalization will be performed. Callers may unset an existing &lt;code&gt;--type&lt;/code&gt; specifier with &lt;code&gt;--no-type&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; указывает &lt;code&gt;git config&lt;/code&gt; , чтобы входящие и исходящие значения могли быть канонизированы для данного &amp;lt;type&amp;gt;. Если не &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; , канонизация выполняться не будет. Вызывающие могут &lt;code&gt;--type&lt;/code&gt; существующий спецификатор --type с помощью &lt;code&gt;--no-type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c9422891d35819a54a8ef0ba6d7016d122547ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options require O(n^2) processing time where n is the number of potential rename/copy targets. This option prevents rename/copy detection from running if the number of rename/copy targets exceeds the specified number.</source>
          <target state="translated">Параметры &lt;code&gt;-M&lt;/code&gt; и &lt;code&gt;-C&lt;/code&gt; требуют времени обработки O (n ^ 2), где n - количество потенциальных целей переименования / копирования. Эта опция предотвращает запуск обнаружения переименования / копирования, если количество целей переименования / копирования превышает указанное число.</target>
        </trans-unit>
        <trans-unit id="73fff0c26b859dbfe915afb814a50fa7bc541c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options have the exact same semantics as &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt;, except instead of the branch being renamed it along with its config and reflog will be copied to a new name.</source>
          <target state="translated">Параметры &lt;code&gt;-c&lt;/code&gt; и &lt;code&gt;-C&lt;/code&gt; имеют ту же семантику, что и &lt;code&gt;-m&lt;/code&gt; и &lt;code&gt;-M&lt;/code&gt; , за исключением того, что вместо того, чтобы переименовывать ветку, она вместе с ее конфигурацией и журналом ссылок будет скопирована с новым именем.</target>
        </trans-unit>
        <trans-unit id="89a7df63322c3f15984d17c0e2db0a5d71e95aa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-F&lt;/code&gt; options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given.</source>
          <target state="translated">Параметры &lt;code&gt;-m&lt;/code&gt; и &lt;code&gt;-F&lt;/code&gt; можно указывать любое количество раз в любом порядке. Сообщение журнала фиксации будет составлено в том порядке, в котором указаны параметры.</target>
        </trans-unit>
        <trans-unit id="f4502e6a26132411ed2e9fd1c43849a487e5e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is mutually exclusive with &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, and &lt;code&gt;-F&lt;/code&gt;.</source>
          <target state="translated">Параметр &lt;code&gt;-m&lt;/code&gt; является взаимоисключающим с &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; и &lt;code&gt;-F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38779d2c15d6e090718b82e6af2f8c359ec976d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.git-credentials&lt;/code&gt; file is stored in plaintext. Each credential is stored on its own line as a URL like:</source>
          <target state="translated">&lt;code&gt;.git-credentials&lt;/code&gt; файла хранятся в незашифрованном виде . Все учетные данные хранятся в отдельной строке в виде URL-адреса, например:</target>
        </trans-unit>
        <trans-unit id="905c63d14654cde00625cb5e82c7038bc34ea94e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file inside the superproject. A project usually uses this file to suggest defaults for the upstream collection of repositories for the mapping that is required between a submodule&amp;rsquo;s name and its path.</source>
          <target state="translated">В &lt;code&gt;.gitmodules&lt;/code&gt; файл внутри суперпроекте. Проект обычно использует этот файл, чтобы предлагать значения по умолчанию для вышестоящей коллекции репозиториев для требуемого сопоставления между именем подмодуля и его путем.</target>
        </trans-unit>
        <trans-unit id="0bb4fdb786947245a90430b5697a0e9422df1d21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file, located in the top-level directory of a Git working tree, is a text file with a syntax matching the requirements of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; файл, расположенный в каталоге верхнего уровня рабочего дерева Git, представляет собой текстовый файл с синтаксисом , соответствующие требования &lt;a href=&quot;git-config&quot;&gt;ГИТ-конфигурации [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5324d8792f18dd9ac59490b336e09b1bd43353e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.mailmap&lt;/code&gt; feature is used to coalesce together commits by the same person in the shortlog, where their name and/or email address was spelled differently.</source>
          <target state="translated">Функция &lt;code&gt;.mailmap&lt;/code&gt; используется для объединения коммитов одного и того же человека в коротком журнале, где их имя и / или адрес электронной почты были написаны по-разному.</target>
        </trans-unit>
        <trans-unit id="73c3a5a96a8a6a48d412facd438733454a4a63a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; ref is set to point at the commit that introduced the change that is difficult to apply.</source>
          <target state="translated">&lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; исй установлено в точку фиксации , что внесли изменения , которые трудно применить.</target>
        </trans-unit>
        <trans-unit id="df208c183263acdaf73c0a978db9f5c35380bc6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables and the &lt;code&gt;--date&lt;/code&gt; option support the following date formats:</source>
          <target state="translated">В &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; переменные окружения и &lt;code&gt;--date&lt;/code&gt; поддержка опции следующие форматы даты:</target>
        </trans-unit>
        <trans-unit id="ad08232602558aa9979e8ccc7bf4df9612b12ec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables support the following date formats:</source>
          <target state="translated">В &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; переменные среды поддерживают следующие форматы даты:</target>
        </trans-unit>
        <trans-unit id="9c24e5e1da9f8726ec7abe4516a017b9495c2fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable may be passed to &lt;code&gt;git-http-backend&lt;/code&gt; to bypass the check for the &quot;git-daemon-export-ok&quot; file in each repository before allowing export of that repository.</source>
          <target state="translated">&lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; переменная среды может быть передана &lt;code&gt;git-http-backend&lt;/code&gt; для обхода проверки для файла &amp;laquo;ГИТ-демон-экспорт ОК&amp;raquo; в каждом хранилище , прежде чем разрешить экспорт этого хранилища.</target>
        </trans-unit>
        <trans-unit id="387cfeb550226cfd9e601b1b72a83920c3f36040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; environment variable (or the &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; config variable) may be set to change the largest ref negotiation request that git will handle during a fetch; any fetch requiring a larger buffer will not succeed. This value should not normally need to be changed, but may be helpful if you are fetching from a repository with an extremely large number of refs. The value can be specified with a unit (e.g., &lt;code&gt;100M&lt;/code&gt; for 100 megabytes). The default is 10 megabytes.</source>
          <target state="translated">&lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; переменной среды (или &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; переменная конфигурация) может быть установлены для изменения большого запроса исх переговоров , что мерзавец будет обрабатывать во время выборки; любая выборка, требующая большего размера буфера, не будет успешной. Обычно это значение не требуется изменять, но может быть полезно, если вы выполняете выборку из репозитория с очень большим количеством ссылок. Значение может быть указано в единицах измерения (например, &lt;code&gt;100M&lt;/code&gt; для 100 мегабайт). По умолчанию - 10 мегабайт.</target>
        </trans-unit>
        <trans-unit id="166eca4501cd90cd3b21f8df969c5ee397d12242" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; environment variable can be set to achieve the same effect as the &lt;code&gt;--no-replace-objects&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; переменная окружения может быть установлен для достижения того же эффекта, что и &lt;code&gt;--no-replace-objects&lt;/code&gt; опции.</target>
        </trans-unit>
        <trans-unit id="8bee9745a8d6377da5f35089625008b4042f0f35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; environment variables can be inspected, just as in &lt;code&gt;pre-receive&lt;/code&gt; hook, after accepting a signed push.</source>
          <target state="translated">В &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; переменные окружения может быть проверены, так же , как и в &lt;code&gt;pre-receive&lt;/code&gt; крюк, после принятия подписанного толчка.</target>
        </trans-unit>
        <trans-unit id="8bc6550bd201f7a8ce8611abf35f278e4b89d03c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; pointer stays the same.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; указатель остается неизменным.</target>
        </trans-unit>
        <trans-unit id="652c0cf20ffd72216eb399a1f559569365b85933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; is optional (it used to be required).</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; после &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; не является обязательным (раньше требуется).</target>
        </trans-unit>
        <trans-unit id="c1bff9f88ec1fe482fd273291dfad27de492749b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; is optional (it used to be required) but recommended. Always including it makes debugging a fast-import stream easier as the next command always starts in column 0 of the next line, even if &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; did not end with an &lt;code&gt;LF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; после &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; не является обязательным (раньше требуются) , но рекомендуется. Его постоянное включение упрощает отладку потока быстрого импорта, так как следующая команда всегда начинается в столбце 0 следующей строки, даже если &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; не заканчивается &lt;code&gt;LF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec7a854b1a4c70ca562f0584186eed412906ec8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required).</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; после команды является необязательным (оно используется для требуется).</target>
        </trans-unit>
        <trans-unit id="9a136595a2c2895a25e4571b5fe242dd49c2174e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required). Note that for reasons of backward compatibility, if the commit ends with a &lt;code&gt;data&lt;/code&gt; command (i.e. it has no &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; or &lt;code&gt;notemodify&lt;/code&gt; commands) then two &lt;code&gt;LF&lt;/code&gt; commands may appear at the end of the command instead of just one.</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; после команды является необязательным (оно используется для требуется). Обратите внимание, что из соображений обратной совместимости, если фиксация завершается командой &lt;code&gt;data&lt;/code&gt; (т. &lt;code&gt;filemodify&lt;/code&gt; ней отсутствуют команды &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; , filemodify , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; или &lt;code&gt;notemodify&lt;/code&gt; ), то в конце команды могут появиться две &lt;code&gt;LF&lt;/code&gt; - команды. вместо одного.</target>
        </trans-unit>
        <trans-unit id="6afb1837ee3e8f65249dcb4905156711b603dd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MERGE_HEAD&lt;/code&gt; ref is set to point to the other branch head.</source>
          <target state="translated">&lt;code&gt;MERGE_HEAD&lt;/code&gt; исх установлен в точке к другой голове ветви.</target>
        </trans-unit>
        <trans-unit id="4dcd07a8427d3cae73e7340717a2be5da78b122e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^0&lt;/code&gt; suffix is necessary as fast-import does not permit a branch to start from itself, and the branch is created in memory before the &lt;code&gt;from&lt;/code&gt; command is even read from the input. Adding &lt;code&gt;^0&lt;/code&gt; will force fast-import to resolve the commit through Git&amp;rsquo;s revision parsing library, rather than its internal branch table, thereby loading in the existing value of the branch.</source>
          <target state="translated">&lt;code&gt;^0&lt;/code&gt; суффикса необходимо , так как быстро импорт не разрешает ветку , чтобы начать с себя, и ветка создается в памяти до того , как &lt;code&gt;from&lt;/code&gt; команды даже прочитать от входа. Добавление &lt;code&gt;^0&lt;/code&gt; заставит быстрый импорт разрешить фиксацию через библиотеку синтаксического анализа ревизий Git, а не его внутреннюю таблицу веток, тем самым загружая существующее значение ветки.</target>
        </trans-unit>
        <trans-unit id="675155c0bc0c9682b02ea7dc72c6fe717f8d57df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^r1 r2&lt;/code&gt; set operation appears so often that there is a shorthand for it. When you have two commits &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by &lt;code&gt;^r1 r2&lt;/code&gt; and it can be written as &lt;code&gt;r1..r2&lt;/code&gt;.</source>
          <target state="translated">Операция набора &lt;code&gt;^r1 r2&lt;/code&gt; появляется так часто, что есть сокращение для нее. Когда у вас есть две фиксации &lt;code&gt;r1&lt;/code&gt; и &lt;code&gt;r2&lt;/code&gt; (названные в соответствии с синтаксисом, описанным в УКАЗАНИИ ИЗМЕНЕНИЙ выше), вы можете запросить коммиты, доступные из r2, за исключением тех, которые достижимы из r1 с помощью &lt;code&gt;^r1 r2&lt;/code&gt; и их можно записать как &lt;code&gt;r1..r2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c300333c575f956c2060e4236a825e5a15abf118" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a/&lt;/code&gt; and &lt;code&gt;b/&lt;/code&gt; filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, &lt;code&gt;/dev/null&lt;/code&gt; is &lt;code&gt;not&lt;/code&gt; used in place of the &lt;code&gt;a/&lt;/code&gt; or &lt;code&gt;b/&lt;/code&gt; filenames.</source>
          <target state="translated">В &lt;code&gt;a/&lt;/code&gt; и &lt;code&gt;b/&lt;/code&gt; имена файлов являются одинаковыми , если переименовать / копировать не участвует. Тем более, даже для создания или удаления, &lt;code&gt;/dev/null&lt;/code&gt; является &lt;code&gt;not&lt;/code&gt; используется вместо &lt;code&gt;a/&lt;/code&gt; или &lt;code&gt;b/&lt;/code&gt; имен файлов.</target>
        </trans-unit>
        <trans-unit id="eab33dae66d0744b7d6024e6ba0526d3cbdb099d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base commit&lt;/code&gt; is shown as &quot;base-commit: &quot; followed by the 40-hex of the commit object name. A &lt;code&gt;prerequisite patch&lt;/code&gt; is shown as &quot;prerequisite-patch-id: &quot; followed by the 40-hex &lt;code&gt;patch id&lt;/code&gt;, which can be obtained by passing the patch through the &lt;code&gt;git patch-id --stable&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;base commit&lt;/code&gt; показана как &amp;laquo;базовая фиксации:&amp;raquo; , а затем 40-гекса имени объекта фиксации. Предварительный &lt;code&gt;prerequisite patch&lt;/code&gt; отображается как &amp;laquo;prerequisite-patch-id:&amp;raquo;, за которым следует 40-шестнадцатеричный &lt;code&gt;patch id&lt;/code&gt; , который можно получить, передав патч через команду &lt;code&gt;git patch-id --stable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4310c66d08d5e3db5f29a0976c449ecfedbc1c27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; field may be used in a future enhancement to do category-based filtering.</source>
          <target state="translated">Поле &lt;code&gt;category&lt;/code&gt; может использоваться в будущем усовершенствовании для фильтрации на основе категорий.</target>
        </trans-unit>
        <trans-unit id="957c03f80393df2f84f209da8b3d5d5b6c66e351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commit walkers&lt;/code&gt; are sometimes also called &lt;code&gt;dumb transports&lt;/code&gt;, because they do not require any Git aware smart server like Git Native transport does. Any stock HTTP server that does not even support directory index would suffice. But you must prepare your repository with &lt;code&gt;git update-server-info&lt;/code&gt; to help dumb transport downloaders.</source>
          <target state="translated">В &lt;code&gt;commit walkers&lt;/code&gt; иногда также называют &lt;code&gt;dumb transports&lt;/code&gt; , потому что они не требуют какого - либо осведомленного смарта - сервера Git , как Git Native транспорт делает. Подойдет любой стандартный HTTP-сервер, который даже не поддерживает индекс каталогов. Но вы должны подготовить свой репозиторий с помощью &lt;code&gt;git update-server-info&lt;/code&gt; , чтобы упростить транспортировку загрузчиков.</target>
        </trans-unit>
        <trans-unit id="16292719b3497b67052d324a828a5bf607c10cb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;committer&lt;/code&gt; command indicates who made this commit, and when they made it.</source>
          <target state="translated">Команда &lt;code&gt;committer&lt;/code&gt; указывает, кто совершил эту фиксацию и когда они ее сделали.</target>
        </trans-unit>
        <trans-unit id="7e0ffba56fb259ff8ccb9999d0c02587815b0675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable allows you to define what &lt;code&gt;diff&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; should consider whitespace errors for all paths in the project (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This attribute gives you finer control per path.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; конфигурационные переменные позволяет определить , что &lt;code&gt;diff&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; следует учитывать пробельные ошибки для всех путей в проекте (см &lt;a href=&quot;git-config&quot;&gt;ГИТ-конфигурация [1]&lt;/a&gt; ). Этот атрибут дает вам более точный контроль над путем.</target>
        </trans-unit>
        <trans-unit id="c4cf312c5837f50305786c4fff7bd921da0df1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;committer&lt;/code&gt; must supply the commit message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty commit message use a 0 length data. Commit messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">Команда &lt;code&gt;data&lt;/code&gt; следующая за &lt;code&gt;committer&lt;/code&gt; должна предоставить сообщение фиксации ( синтаксис команды &lt;code&gt;data&lt;/code&gt; см. Ниже ). Чтобы импортировать пустое сообщение фиксации, используйте данные длины 0. Сообщения коммитов имеют произвольную форму и не интерпретируются Git. В настоящее время они должны быть закодированы в UTF-8, поскольку быстрый импорт не позволяет указывать другие кодировки.</target>
        </trans-unit>
        <trans-unit id="fe1dcaff1f205cb554cce0caa7f556f5b3750431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;tagger&lt;/code&gt; must supply the annotated tag message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty tag message use a 0 length data. Tag messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">Команда &lt;code&gt;data&lt;/code&gt; после &lt;code&gt;tagger&lt;/code&gt; должна предоставить аннотированное сообщение тега ( синтаксис команды &lt;code&gt;data&lt;/code&gt; см. Ниже ). Чтобы импортировать пустое сообщение тега, используйте данные длины 0. Сообщения тегов имеют произвольную форму и не интерпретируются Git. В настоящее время они должны быть закодированы в UTF-8, поскольку быстрый импорт не позволяет указывать другие кодировки.</target>
        </trans-unit>
        <trans-unit id="463a929e2c19b7bbf028008ad9aa5a5763e6cf66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export-marks&lt;/code&gt; and &lt;code&gt;import-marks&lt;/code&gt; capabilities, if specified, affect this command in so far as they are passed on to &lt;code&gt;git fast-export&lt;/code&gt;, which then will load/store a table of marks for local objects. This can be used to implement for incremental operations.</source>
          <target state="translated">Возможности &lt;code&gt;export-marks&lt;/code&gt; и &lt;code&gt;import-marks&lt;/code&gt; , если они указаны, влияют на эту команду, поскольку они передаются в &lt;code&gt;git fast-export&lt;/code&gt; , который затем загружает / сохраняет таблицу меток для локальных объектов. Это можно использовать для дополнительных операций.</target>
        </trans-unit>
        <trans-unit id="b29369cc7c91f799f3a98b04ce067ccee4eaff48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra-info&lt;/code&gt; is again command-dependent. If it is empty, the preceding SP is also omitted. Currently, no commands pass any &lt;code&gt;extra-info&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;extra-info&lt;/code&gt; снова команда-зависимой. Если он пуст, предыдущий SP также опускается. В настоящее время никакие команды не передают &lt;code&gt;extra-info&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42c3cfeeb6fb7d3b809e4b2424ab05b633a62a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with &lt;code&gt;%n&lt;/code&gt; instead of &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">Формат &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; позволяет указать, какую информацию вы хотите отображать. Он немного похож на формат printf, за исключением того, что вы получаете новую строку с &lt;code&gt;%n&lt;/code&gt; вместо &lt;code&gt;\n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d12446e6ba50613ffa6591e4d86ab902d5b116f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is the same as in the &lt;code&gt;commit&lt;/code&gt; command; see above for details.</source>
          <target state="translated">Команда &lt;code&gt;from&lt;/code&gt; такая же, как и в команде &lt;code&gt;commit&lt;/code&gt; ; подробности см. выше.</target>
        </trans-unit>
        <trans-unit id="d9bc1ff5b134d7635edcea3cd4e631a291483167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is used to specify the commit to initialize this branch from. This revision will be the first ancestor of the new commit. The state of the tree built at this commit will begin with the state at the &lt;code&gt;from&lt;/code&gt; commit, and be altered by the content modifications in this commit.</source>
          <target state="translated">Команда &lt;code&gt;from&lt;/code&gt; используется для указания фиксации, из которой будет инициализирована эта ветка. Эта ревизия будет первым предком нового коммита. Состояние дерева построен на этой фиксации будет начинаться с государства на &lt;code&gt;from&lt;/code&gt; фиксации, и может быть изменен путем модификации содержимого в этом фиксации.</target>
        </trans-unit>
        <trans-unit id="75dab416c6ca16533650ccb3bdbb6f1c8c80e31e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git add&lt;/code&gt; command will not add ignored files by default. If any ignored files were explicitly specified on the command line, &lt;code&gt;git add&lt;/code&gt; will fail with a list of ignored files. Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored. The &lt;code&gt;git add&lt;/code&gt; command can be used to add ignored files with the &lt;code&gt;-f&lt;/code&gt; (force) option.</source>
          <target state="translated">Команда &lt;code&gt;git add&lt;/code&gt; по умолчанию не добавляет игнорируемые файлы. Если какие-либо игнорируемые файлы были явно указаны в командной строке, &lt;code&gt;git add&lt;/code&gt; завершится ошибкой со списком игнорируемых файлов. Игнорируемые файлы, полученные в результате рекурсии каталогов или подстановки имен файлов, выполняемой Git (укажите ваши глобусы перед оболочкой), будут автоматически игнорироваться. &lt;code&gt;git add&lt;/code&gt; команду можно использовать для добавления игнорируемых файлов с &lt;code&gt;-f&lt;/code&gt; опцией (сила).</target>
        </trans-unit>
        <trans-unit id="9bd7293224a598d82d7fb9b059bf233156e9f91a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git bundle&lt;/code&gt; command packages objects and references in an archive at the originating machine, which can then be imported into another repository using &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, or &lt;code&gt;git clone&lt;/code&gt;, after moving the archive by some means (e.g., by sneakernet).</source>
          <target state="translated">Команда &lt;code&gt;git bundle&lt;/code&gt; упаковывает объекты и ссылки в архив на исходной машине, которые затем можно импортировать в другой репозиторий с помощью &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; или &lt;code&gt;git clone&lt;/code&gt; после перемещения архива каким-либо образом (например, с помощью sneakernet).</target>
        </trans-unit>
        <trans-unit id="3d9620664b0c9d56c3287a812c3ff6b6d1c8717f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git diff-*&lt;/code&gt; family works by first comparing two sets of files:</source>
          <target state="translated">Семейство &lt;code&gt;git diff-*&lt;/code&gt; работает, сначала сравнивая два набора файлов:</target>
        </trans-unit>
        <trans-unit id="597ca1f538bf6e2f60b9e6f9e15d7129efb080fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; operation always stores the head of the last fetched branch in FETCH_HEAD. For example, if you run &lt;code&gt;git fetch&lt;/code&gt; without specifying a local branch as the target of the operation</source>
          <target state="translated">Операция &lt;code&gt;git fetch&lt;/code&gt; всегда сохраняет заголовок последней выбранной ветки в FETCH_HEAD. Например, если вы запустите &lt;code&gt;git fetch&lt;/code&gt; без указания локальной ветки в качестве цели операции</target>
        </trans-unit>
        <trans-unit id="f809c0db2fabe1b716a044f1ae315c3eafe27e59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fmt-merge-msg&lt;/code&gt; command can be used to give a good default for automated &lt;code&gt;git merge&lt;/code&gt; invocations. The automated message can include the branch description.</source>
          <target state="translated">&lt;code&gt;git fmt-merge-msg&lt;/code&gt; команда может быть использована , чтобы дать хорошее значение по умолчанию для автоматического &lt;code&gt;git merge&lt;/code&gt; вызовов. Автоматическое сообщение может включать описание ветки.</target>
        </trans-unit>
        <trans-unit id="dae50540309298598631c32bc4ba09615f81ee1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git gc --auto&lt;/code&gt; command will run the &lt;code&gt;pre-auto-gc&lt;/code&gt; hook. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">Команда &lt;code&gt;git gc --auto&lt;/code&gt; запустит перехватчик &lt;code&gt;pre-auto-gc&lt;/code&gt; . См. &lt;a href=&quot;githooks&quot;&gt;Githooks [5]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="cfc7fc175318cd6dff60f69f9572984dc7656815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git grep&lt;/code&gt; command can search for strings in any version of your project, so</source>
          <target state="translated">Команда &lt;code&gt;git grep&lt;/code&gt; может искать строки в любой версии вашего проекта, поэтому</target>
        </trans-unit>
        <trans-unit id="10370106ed757f0fcfa619078db112558b3f4b4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git log&lt;/code&gt; command has a weakness: it must present commits in a list. When the history has lines of development that diverged and then merged back together, the order in which &lt;code&gt;git log&lt;/code&gt; presents those commits is meaningless.</source>
          <target state="translated">У команды &lt;code&gt;git log&lt;/code&gt; есть недостаток: она должна представлять коммиты в списке. Когда в истории есть линии развития, которые расходятся, а затем снова сливаются, порядок, в котором &lt;code&gt;git log&lt;/code&gt; представляет эти коммиты, не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="2918fcbf92a1ba7da67f920488e3f1571c6c776d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git pull&lt;/code&gt; command can also be given &lt;code&gt;.&lt;/code&gt; as the &quot;remote&quot; repository, in which case it just merges in a branch from the current repository; so the commands</source>
          <target state="translated">Также можно &lt;code&gt;git pull&lt;/code&gt; команду git pull &lt;code&gt;.&lt;/code&gt; как &amp;laquo;удаленный&amp;raquo; репозиторий, и в этом случае он просто сливается с веткой из текущего репозитория; так что команды</target>
        </trans-unit>
        <trans-unit id="ae6be494d942d11be1fef84bf75e14340e42ba70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git sh-setup&lt;/code&gt; scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions.</source>
          <target state="translated">Сценарий &lt;code&gt;git sh-setup&lt;/code&gt; предназначен для получения (использования &lt;code&gt;.&lt;/code&gt; ) Другими сценариями оболочки для настройки некоторых переменных, указывающих на обычные каталоги Git и нескольких вспомогательных функций оболочки.</target>
        </trans-unit>
        <trans-unit id="b8d00251834fb59fdb3aac3b6b6d2fd6617d8c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git status&lt;/code&gt; command can be used to obtain a summary of which files have changes that are staged for the next commit.</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; команда может быть использована для получения резюме, какие файлы имеют изменения, постановочные для следующей фиксации.</target>
        </trans-unit>
        <trans-unit id="1114dd8f20b27292636eee44dbca10b695a7e192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; command does a couple of things:</source>
          <target state="translated">Команда &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; выполняет несколько действий:</target>
        </trans-unit>
        <trans-unit id="851ad3692f8ce86e89fabf82d757953cfb293665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git svn log&lt;/code&gt; command will not work on repositories using this, either. Using this conflicts with the &lt;code&gt;useSvmProps&lt;/code&gt; option for (hopefully) obvious reasons.</source>
          <target state="translated">Команда &lt;code&gt;git svn log&lt;/code&gt; также не будет работать с репозиториями, использующими это. Использование этого параметра конфликтует с параметром &lt;code&gt;useSvmProps&lt;/code&gt; по (надеюсь) очевидным причинам.</target>
        </trans-unit>
        <trans-unit id="54f2e5960f99dce6a894019f61b5f183cfaf541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git switch&lt;/code&gt; command normally expects a branch head, but will also accept an arbitrary commit when invoked with --detach; for example, you can check out the commit referenced by a tag:</source>
          <target state="translated">Команда &lt;code&gt;git switch&lt;/code&gt; обычно ожидает заголовок ветки, но также примет произвольный коммит при вызове с --detach; например, вы можете проверить фиксацию, на которую ссылается тег:</target>
        </trans-unit>
        <trans-unit id="5df4353714e03396f22186d308b555d9fc45aa0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git unpack-objects&lt;/code&gt; command can read the packed archive and expand the objects contained in the pack into &quot;one-file one-object&quot; format; this is typically done by the smart-pull commands when a pack is created on-the-fly for efficient network transport by their peers.</source>
          <target state="translated">Команда &lt;code&gt;git unpack-objects&lt;/code&gt; может прочитать упакованный архив и развернуть объекты, содержащиеся в пакете, в формат &amp;laquo;один файл - один объект&amp;raquo;; это обычно выполняется командами smart-pull, когда пакет создается на лету для эффективного сетевого транспорта их одноранговыми узлами.</target>
        </trans-unit>
        <trans-unit id="472b18d3af19081ec08acbffb4a8b9828ded3de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git write-tree&lt;/code&gt; command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0.</source>
          <target state="translated">Команда &lt;code&gt;git write-tree&lt;/code&gt; отказывается писать бессмысленное дерево и будет жаловаться на несоединенные записи, если увидит одну запись, которая не является стадией 0.</target>
        </trans-unit>
        <trans-unit id="57ed6fd41631cf164adf8f1a5f87022b80e95155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git-fetch&lt;/code&gt; command, with no arguments, will update all of the remote-tracking branches to the latest version found in the original repository. It will not touch any of your own branches&amp;mdash;​not even the &quot;master&quot; branch that was created for you on clone.</source>
          <target state="translated">Команда &lt;code&gt;git-fetch&lt;/code&gt; без аргументов обновит все ветки удаленного отслеживания до последней версии, найденной в исходном репозитории. Он не коснется ни одной из ваших собственных веток - даже &amp;laquo;главной&amp;raquo; ветки, которая была создана для вас в клоне.</target>
        </trans-unit>
        <trans-unit id="b7a1f970e8485b643b6fd9d3ee5bf5ec87b44b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gitlink&lt;/code&gt; entry contains the object name of the commit that the superproject expects the submodule&amp;rsquo;s working directory to be at.</source>
          <target state="translated">Запись &lt;code&gt;gitlink&lt;/code&gt; содержит имя объекта коммита, в котором суперпроект ожидает, что рабочий каталог подмодуля будет находиться в.</target>
        </trans-unit>
        <trans-unit id="20a22a2e8dd656430183eebd26fcd541802b3980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and git-web{litdd}browse[1].</source>
          <target state="translated">&lt;code&gt;help.browser&lt;/code&gt; , &lt;code&gt;web.browser&lt;/code&gt; и &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; также будет проверяться , если &lt;code&gt;web&lt;/code&gt; выбран формат (либо опции командной строки или переменной конфигурации). См. &lt;code&gt;-w|--web&lt;/code&gt; в разделе ОПЦИИ выше и git-web {litdd} browse [1].</target>
        </trans-unit>
        <trans-unit id="d643b3df461bdc6854f7d047b7c0264699b4e1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;includeIf&lt;/code&gt; sections allow you to include config directives from another source. These sections behave identically to each other with the exception that &lt;code&gt;includeIf&lt;/code&gt; sections may be ignored if their condition does not evaluate to true; see &quot;Conditional includes&quot; below.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; и &lt;code&gt;includeIf&lt;/code&gt; разделы позволяют включать директивы конфигурации из другого источника. Эти секции ведут себя идентично друг другу, за исключением того, что секции &lt;code&gt;includeIf&lt;/code&gt; могут быть проигнорированы, если их условие не истинно; см. &amp;laquo;Условное включение&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="25df8c5531688eabec317d8bad065a9bd5755f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (&lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt;) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the &lt;code&gt;label&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to proceed.</source>
          <target state="translated">Команда &lt;code&gt;label&lt;/code&gt; связывает метку с текущим HEAD, когда эта команда выполняется. Эти метки создаются как локальные ссылки рабочего дерева ( &lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt; rewritten / &amp;lt;label&amp;gt; ), которые будут удалены после завершения перебазирования. Таким образом, операции перебазирования в нескольких рабочих деревьях, связанных с одним и тем же репозиторием, не мешают друг другу. Если команда &lt;code&gt;label&lt;/code&gt; не работает, она немедленно переносится с полезным сообщением о том, как действовать.</target>
        </trans-unit>
        <trans-unit id="a21f07c748b4f824d325c5d844a166616c79a19e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command produces a list of refs in which each ref may be followed by a list of attributes. The following ref list attributes are defined.</source>
          <target state="translated">Команда &lt;code&gt;list&lt;/code&gt; создает список ссылок, в котором за каждой ссылкой может следовать список атрибутов. Определены следующие атрибуты списка ссылок.</target>
        </trans-unit>
        <trans-unit id="a1948673e2dc6e9b36baf9466260194608388c73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command can also be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; команда также может быть использована , когда &lt;code&gt;filemodify&lt;/code&gt; может появиться директива, что позволяет использовать его в середине фиксации.</target>
        </trans-unit>
        <trans-unit id="9f751fdc4139000f76be8c4b7f0362d024d6ccd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maint&lt;/code&gt; branch should now be fast-forwarded to the newly released code so that maintenance fixes can be tracked for the current release:</source>
          <target state="translated">&lt;code&gt;maint&lt;/code&gt; ветвь должна теперь быть быстро передана в недавно выпущенный код , так что исправления обслуживания может быть отслежены для текущей версии:</target>
        </trans-unit>
        <trans-unit id="3d08be0d91fe4ba76005ea415ec8dd980a19baaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;man.viewer&lt;/code&gt; configuration variable will be checked if the &lt;code&gt;man&lt;/code&gt; format is chosen. The following values are currently supported:</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; переменной конфигурации будет проверяться , если &lt;code&gt;man&lt;/code&gt; выбран формат. В настоящее время поддерживаются следующие значения:</target>
        </trans-unit>
        <trans-unit id="4d99fda454f21ad231a7b020da5a33fbc1590dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;master&lt;/code&gt; branch is supposed to be a superset of &lt;code&gt;maint&lt;/code&gt;. If this condition does not hold, then &lt;code&gt;maint&lt;/code&gt; contains some commits that are not included on &lt;code&gt;master&lt;/code&gt;. The fixes represented by those commits will therefore not be included in your feature release.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; филиал должен быть надмножеством &lt;code&gt;maint&lt;/code&gt; . Если это условие не выполняется, то &lt;code&gt;maint&lt;/code&gt; содержит некоторые коммиты, которые не включены в &lt;code&gt;master&lt;/code&gt; . Поэтому исправления, представленные этими коммитами, не будут включены в ваш выпуск функции.</target>
        </trans-unit>
        <trans-unit id="60a9438818e32daade34327aac8510a028d0a280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.driver&lt;/code&gt; variable&amp;rsquo;s value is used to construct a command to run to merge ancestor&amp;rsquo;s version (&lt;code&gt;%O&lt;/code&gt;), current version (&lt;code&gt;%A&lt;/code&gt;) and the other branches' version (&lt;code&gt;%B&lt;/code&gt;). These three tokens are replaced with the names of temporary files that hold the contents of these versions when the command line is built. Additionally, %L will be replaced with the conflict marker size (see below).</source>
          <target state="translated">Значение переменной &lt;code&gt;merge.*.driver&lt;/code&gt; Используется для создания команды для выполнения слияния версии предка ( &lt;code&gt;%O&lt;/code&gt; ), текущей версии ( &lt;code&gt;%A&lt;/code&gt; ) и версии других ветвей ( &lt;code&gt;%B&lt;/code&gt; ). Эти три токена заменяются именами временных файлов, содержащих содержимое этих версий, при построении командной строки. Кроме того,% L будет заменен размером маркера конфликта (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="8135860bcb3c213dc65a79f9d59c1c4cf76a9b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.name&lt;/code&gt; variable gives the driver a human-readable name.</source>
          <target state="translated">&lt;code&gt;merge.*.name&lt;/code&gt; переменной дает водителю имя удобочитаемый.</target>
        </trans-unit>
        <trans-unit id="531f58358e8d95bd1e04306b8f06edec09e06aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.recursive&lt;/code&gt; variable specifies what other merge driver to use when the merge driver is called for an internal merge between common ancestors, when there are more than one. When left unspecified, the driver itself is used for both internal merge and the final merge.</source>
          <target state="translated">&lt;code&gt;merge.*.recursive&lt;/code&gt; переменная определяет , что другой водитель слияния использовать , когда драйвер слияния называется для внутреннего слияния между общими предками, когда есть больше чем один. Если не указано иное, сам драйвер используется как для внутреннего, так и для окончательного слияния.</target>
        </trans-unit>
        <trans-unit id="0e9e9f9df980dcf05008ee310843fafb365f76e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge&lt;/code&gt; command will merge the specified revision(s) into whatever is HEAD at that time. With &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt;, the commit message of the specified merge commit will be used. When the &lt;code&gt;-C&lt;/code&gt; is changed to a lower-case &lt;code&gt;-c&lt;/code&gt;, the message will be opened in an editor after a successful merge so that the user can edit the message.</source>
          <target state="translated">Команда &lt;code&gt;merge&lt;/code&gt; объединит указанные ревизии с тем, что в это время является HEAD. С &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt; будет использоваться сообщение фиксации указанной фиксации слияния. Когда &lt;code&gt;-C&lt;/code&gt; изменяется на &lt;code&gt;-c&lt;/code&gt; в нижнем регистре , сообщение будет открыто в редакторе после успешного слияния, чтобы пользователь мог редактировать сообщение.</target>
        </trans-unit>
        <trans-unit id="103d9db55b62f87264ea4e2293c619e5e886c09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; line appears only if at least one of the &amp;lt;mode&amp;gt; is different from the rest. Extended headers with information about detected contents movement (renames and copying detection) are designed to work with diff of two &amp;lt;tree-ish&amp;gt; and are not used by combined diff format.</source>
          <target state="translated">&lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; линия появляется только тогда , когда по крайней мере один из &amp;lt;режим&amp;gt; отличается от остальных. Расширенные заголовки с информацией об обнаруженном перемещении содержимого (обнаружение переименований и копий) предназначены для работы с diff из двух &amp;lt;tree-ish&amp;gt; и не используются в комбинированном формате diff.</target>
        </trans-unit>
        <trans-unit id="245bf1c27c1e24c16ea60d971116c678983044e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching.</source>
          <target state="translated">&lt;code&gt;p4-pre-submit&lt;/code&gt; крючок выполняется , если он существует и является исполняемым. Хук не принимает никаких параметров и ничего из стандартного ввода. Выход из этого скрипта с ненулевым статусом предотвращает запуск &lt;code&gt;git-p4 submit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55ac82e7ce6eab5b9d775518541be1b358e64d26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;post-update&lt;/code&gt; hook can tell what are the heads that were pushed, but it does not know what their original and updated values are, so it is a poor place to do log old..new. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook does get both original and updated values of the refs. You might consider it instead if you need them.</source>
          <target state="translated">&lt;code&gt;post-update&lt;/code&gt; крючок может сказать , что начальники , которые были оттеснены, но он не знает , что их оригинальные и обновленные значения, так это плохое место , чтобы сделать журнал old..new. &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;После приема&lt;/em&gt;&lt;/a&gt; крючок действительно получает как оригинальные , так и обновленные значения рефов. Вы можете рассмотреть это вместо этого, если они вам понадобятся.</target>
        </trans-unit>
        <trans-unit id="7b1878af31d43f94d962552d8195f8f92835c4ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pre-receive&lt;/code&gt; hook MUST NOT update any refs to point to quarantined objects. Other programs accessing the repository will not be able to see the objects (and if the pre-receive hook fails, those refs would become corrupted). For safety, any ref updates from within &lt;code&gt;pre-receive&lt;/code&gt; are automatically rejected.</source>
          <target state="translated">Ловушка &lt;code&gt;pre-receive&lt;/code&gt; НЕ ДОЛЖНА обновлять какие-либо ссылки, чтобы указывать на объекты в карантине. Другие программы, обращающиеся к репозиторию, не смогут видеть объекты (и если перехватчик предварительного приема не сработает, эти ссылки будут повреждены). В целях безопасности любые обновления ref из &lt;code&gt;pre-receive&lt;/code&gt; автоматически отклоняются.</target>
        </trans-unit>
        <trans-unit id="eb98cabc50bf16dce560817c25a1c4d64601cce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pu&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; ветвь будет обновляться , даже если это не быстро вперед, потому что он предваряется знаком плюс; &lt;code&gt;tmp&lt;/code&gt; не будет.</target>
        </trans-unit>
        <trans-unit id="d5f7235d0f9a5c833ca324eff7dc4ec19b6e7285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pull&lt;/code&gt; command knows where to get updates from because of certain configuration variables that were set by the first &lt;code&gt;git clone&lt;/code&gt; command; see &lt;code&gt;git config -l&lt;/code&gt; and the &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">Команда &lt;code&gt;pull&lt;/code&gt; знает, откуда получать обновления из-за определенных переменных конфигурации, которые были установлены первой командой &lt;code&gt;git clone&lt;/code&gt; ; подробности см. в &lt;code&gt;git config -l&lt;/code&gt; и на странице руководства &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9716ab4c9bb8eabfdb4d2f2052c2761838dfc4ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^!&lt;/code&gt; notation includes commit &lt;code&gt;r1&lt;/code&gt; but excludes all of its parents. By itself, this notation denotes the single commit &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1^!&lt;/code&gt; нотация включает фиксацию &lt;code&gt;r1&lt;/code&gt; , но исключает всех ее родителей. Само по себе это обозначение обозначает одиночный коммит &lt;code&gt;r1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec7b0d87246117fbc7ede1e9fb5e445953432dc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^@&lt;/code&gt; notation means all parents of &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1^@&lt;/code&gt; обозначения означает , что все родители &lt;code&gt;r1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906a6c33616cfaeeffbd4277ee44152fa9cd28f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;raw&lt;/code&gt; format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and &lt;code&gt;parents&lt;/code&gt; information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with &lt;code&gt;git log --raw&lt;/code&gt;. To get full object names in a raw diff format, use &lt;code&gt;--no-abbrev&lt;/code&gt;.</source>
          <target state="translated">В &lt;code&gt;raw&lt;/code&gt; формат показывает весь фиксации точно так , как хранящиеся в фиксации объекта. Примечательно, что хэши отображаются полностью, независимо от того, используется ли --abbrev или --no-abbrev, а информация о &lt;code&gt;parents&lt;/code&gt; показывает истинные родительские коммиты без учета графтов или упрощения истории. Обратите внимание, что этот формат влияет на способ отображения &lt;code&gt;git log --raw&lt;/code&gt; , но не на способ отображения различий, например, с помощью git log --raw . Чтобы получить полные имена объектов в формате raw diff, используйте &lt;code&gt;--no-abbrev&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2ae08cd51826a72547a4936e1fee7033d540d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive&lt;/code&gt; strategy can take the following options:</source>
          <target state="translated">&lt;code&gt;recursive&lt;/code&gt; стратегия может принимать следующие параметры:</target>
        </trans-unit>
        <trans-unit id="2274cd304e0d47984767afeee4d877ca51fbdd54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/heads/*&lt;/code&gt; namespace will only accept commit objects, and updates only if they can be fast-forwarded.</source>
          <target state="translated">Пространство имен &lt;code&gt;refs/heads/*&lt;/code&gt; будет принимать только объекты фиксации и обновлять, только если они могут быть перенаправлены.</target>
        </trans-unit>
        <trans-unit id="73d202d810478ee27aec0a92a74e6cf7efe8db45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/tags/*&lt;/code&gt; namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.</source>
          <target state="translated">Пространство имен &lt;code&gt;refs/tags/*&lt;/code&gt; будет принимать любой тип объекта (поскольку коммиты, деревья и капли могут быть помечены), и любые обновления для них будут отклонены.</target>
        </trans-unit>
        <trans-unit id="8f1fa8b6ca43d585bbef39f492a9db57e9ecc9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command can also be used to create lightweight (non-annotated) tags. For example:</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; команда также может быть использована для создания облегченных метки (без аннотированной). Например:</target>
        </trans-unit>
        <trans-unit id="bd2e909f258c6aa58fa07c5acaee67caeb1da10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command resets the HEAD, index and worktree to the specified revision. It is similar to an &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt;, but refuses to overwrite untracked files. If the &lt;code&gt;reset&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a &lt;code&gt;reset&lt;/code&gt; command was inserted into the todo list manually and contains a typo).</source>
          <target state="translated">Команда &lt;code&gt;reset&lt;/code&gt; сбрасывает HEAD, индекс и рабочее дерево до указанной версии. Он похож на &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt; , но отказывается перезаписывать неотслеживаемые файлы. Если команда &lt;code&gt;reset&lt;/code&gt; завершается неудачно, она немедленно изменяется в расписании с полезным сообщением, как отредактировать список задач (обычно это происходит, когда команда &lt;code&gt;reset&lt;/code&gt; была вставлена ​​в список задач вручную и содержит опечатку).</target>
        </trans-unit>
        <trans-unit id="06cca2918a8a255dfff1d384369e4d4195e47f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shortlog&lt;/code&gt; view is more compact; it shows one commit per line.</source>
          <target state="translated">Представление &lt;code&gt;shortlog&lt;/code&gt; более компактно; он показывает одну фиксацию на строку.</target>
        </trans-unit>
        <trans-unit id="49d7635e517e74681985e2d5acfe0d3faa2b57eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tagger&lt;/code&gt; command uses the same format as &lt;code&gt;committer&lt;/code&gt; within &lt;code&gt;commit&lt;/code&gt;; again see above for details.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; команда использует тот же формат, &lt;code&gt;committer&lt;/code&gt; внутри &lt;code&gt;commit&lt;/code&gt; ; снова см. выше для деталей.</target>
        </trans-unit>
        <trans-unit id="c5d1574573f9cb9deb3517e06eb81c31c726f5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;textconv&lt;/code&gt; config option is used to define a program for performing such a conversion. The program should take a single argument, the name of a file to convert, and produce the resulting text on stdout.</source>
          <target state="translated">&lt;code&gt;textconv&lt;/code&gt; вариант конфигурации используется для определения программы для выполнения такого преобразования. Программа должна принимать единственный аргумент, имя файла, который нужно преобразовать, и выдавать результирующий текст на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="5a024de933cb7ecb7f2684cd23c20dd59cced4c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tformat:&lt;/code&gt; format works exactly like &lt;code&gt;format:&lt;/code&gt;, except that it provides &quot;terminator&quot; semantics instead of &quot;separator&quot; semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the &quot;oneline&quot; format does. For example:</source>
          <target state="translated">Формат &lt;code&gt;tformat:&lt;/code&gt; format работает точно так же, как &lt;code&gt;format:&lt;/code&gt; , за исключением того, что он обеспечивает семантику &amp;laquo;терминатора&amp;raquo; вместо семантики &amp;laquo;разделителя&amp;raquo;. Другими словами, к каждой фиксации добавляется символ конца сообщения (обычно новая строка), а не разделитель между записями. Это означает, что последняя запись в однострочном формате будет правильно завершена новой строкой, как и в &amp;laquo;однострочном&amp;raquo; формате. Например:</target>
        </trans-unit>
        <trans-unit id="52696bbc1bd35a1c1c6d78b6535a11990db3bb34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables. See &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;user.name&lt;/code&gt; и &lt;code&gt;user.email&lt;/code&gt; переменные определяют , что заканчивается в &lt;code&gt;author&lt;/code&gt; и &lt;code&gt;committer&lt;/code&gt; области фиксации объектов. Если вам нужен &lt;code&gt;author&lt;/code&gt; или &lt;code&gt;committer&lt;/code&gt; быть разными, &lt;code&gt;author.name&lt;/code&gt; , &lt;code&gt;author.email&lt;/code&gt; , &lt;code&gt;committer.name&lt;/code&gt; или &lt;code&gt;committer.email&lt;/code&gt; переменные могут быть установлены. Кроме того, все они могут быть переопределены переменными среды &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt; , &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; и &lt;code&gt;EMAIL&lt;/code&gt; . См. &lt;a href=&quot;git-commit-tree&quot;&gt;Git-commit-tree [1]&lt;/a&gt; Чтобы получить больше информации.</target>
        </trans-unit>
        <trans-unit id="16ffcc56d5f44fe2ccdfd792b9ad74a964b837f9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;hellip;​&lt;/em&gt; (three-dot) Symmetric Difference Notation</source>
          <target state="translated">&lt;em&gt;...&lt;/em&gt; (три-точка) Симметричный разница Notation</target>
        </trans-unit>
        <trans-unit id="3ca01d997f3f16d56fc54554bfe9b469c32c5dff" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;..&lt;/em&gt; (two-dot) Range Notation</source>
          <target state="translated">&lt;em&gt;..&lt;/em&gt; (два-точка) Диапазон Notation</target>
        </trans-unit>
        <trans-unit id="28292c9406d9116658f021a9e7e686e22523649d" translate="yes" xml:space="preserve">
          <source>The C rewrite is first included with Git version 2.22 (and Git for Windows version 2.19). This option serves as an escape hatch to re-enable the legacy version in case any bugs are found in the rewrite. This option and the shell script version of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; will be removed in some future release.</source>
          <target state="translated">Перезапись на C впервые включена в Git версии 2.22 (и Git для Windows версии 2.19). Эта опция служит аварийным выходом для повторного включения устаревшей версии в случае обнаружения каких-либо ошибок при перезаписи. Этот параметр и версия сценария оболочки &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; будут удалены в некоторых будущих выпусках.</target>
        </trans-unit>
        <trans-unit id="dbe462d7e2f126482bf0dec3d004def2c9c89bb6" translate="yes" xml:space="preserve">
          <source>The CVS module you want to import. Relative to &amp;lt;CVSROOT&amp;gt;. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; tries to read it from &lt;code&gt;CVS/Repository&lt;/code&gt;.</source>
          <target state="translated">Модуль CVS, который вы хотите импортировать. Относительно &amp;lt;CVSROOT&amp;gt;. Если не указан, &lt;code&gt;git cvsimport&lt;/code&gt; пытается прочитать его из &lt;code&gt;CVS/Repository&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fdb00c7bf3f2937ed399ea5a7eb5783533387f" translate="yes" xml:space="preserve">
          <source>The Event Format Target</source>
          <target state="translated">Формат события Цель</target>
        </trans-unit>
        <trans-unit id="91f31eeacecff37ec38db2aff37269235d7422bb" translate="yes" xml:space="preserve">
          <source>The GIT_TRACE_&amp;lt;key&amp;gt; mechanism allows each &amp;lt;key&amp;gt; to write to a different file (in addition to just stderr).</source>
          <target state="translated">Механизм GIT_TRACE_ &amp;lt;key&amp;gt; позволяет каждому &amp;lt;key&amp;gt; записывать в другой файл (помимо stderr).</target>
        </trans-unit>
        <trans-unit id="eb9c24f633d0777727caf33c8ede260c0246d232" translate="yes" xml:space="preserve">
          <source>The GPG key ID of the key that signed the push certificate.</source>
          <target state="translated">Идентификатор ключа GPG ключа,который подписал сертификат push.</target>
        </trans-unit>
        <trans-unit id="7fd047e9e0dcddc0ec24d2bfa4a8d0b4477b60c4" translate="yes" xml:space="preserve">
          <source>The Git Repository</source>
          <target state="translated">Git-репозиторий</target>
        </trans-unit>
        <trans-unit id="ec69c4a3fd32f0743df23ab218ec13475fdae8cc" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; below) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="translated">Файл конфигурации Git содержит ряд переменных, которые влияют на поведение команд Git. Файлы &lt;code&gt;.git/config&lt;/code&gt; и, возможно, &lt;code&gt;config.worktree&lt;/code&gt; (см. &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; ниже) в каждом репозитории используются для хранения конфигурации этого репозитория, а &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; используется для хранения конфигурации для каждого пользователя в качестве резервных значений для &lt;code&gt;.git/config&lt;/code&gt; файл. Файл &lt;code&gt;/etc/gitconfig&lt;/code&gt; можно использовать для хранения общесистемной конфигурации по умолчанию.</target>
        </trans-unit>
        <trans-unit id="c4676de1f2b8af7673ad60d0d802fc7e29d8da30" translate="yes" xml:space="preserve">
          <source>The Git object directory contains a &lt;code&gt;pack&lt;/code&gt; directory containing packfiles (with suffix &quot;.pack&quot;) and pack-indexes (with suffix &quot;.idx&quot;). The pack-indexes provide a way to lookup objects and navigate to their offset within the pack, but these must come in pairs with the packfiles. This pairing depends on the file names, as the pack-index differs only in suffix with its pack- file. While the pack-indexes provide fast lookup per packfile, this performance degrades as the number of packfiles increases, because abbreviations need to inspect every packfile and we are more likely to have a miss on our most-recently-used packfile. For some large repositories, repacking into a single packfile is not feasible due to storage space or excessive repack times.</source>
          <target state="translated">Каталог объектов Git содержит каталог &lt;code&gt;pack&lt;/code&gt; содержащий файлы пакетов (с суффиксом &amp;laquo;.pack&amp;raquo;) и индексы пакетов (с суффиксом &amp;laquo;.idx&amp;raquo;). Индексы пакетов обеспечивают способ поиска объектов и перехода к их смещению в пакете, но они должны идти парами с файлами пакетов. Это сочетание зависит от имен файлов, так как индекс-пакет отличается только суффиксом от его файла-пакета. В то время как индексы пакетов обеспечивают быстрый поиск по каждому пакетному файлу, эта производительность снижается по мере увеличения количества пакетных файлов, потому что сокращения должны проверять каждый пакетный файл, и мы, скорее всего, пропустим наш последний использованный пакетный файл. Для некоторых больших репозиториев переупаковка в один пакетный файл невозможна из-за места для хранения или чрезмерного времени переупаковки.</target>
        </trans-unit>
        <trans-unit id="a2329c4ac9f08d776040ac221ffa562b7323c3f6" translate="yes" xml:space="preserve">
          <source>The Git protocol gives better performance and reliability, but on a host with a web server set up, HTTP exports may be simpler to set up.</source>
          <target state="translated">Git-протокол обеспечивает более высокую производительность и надёжность,но на хосте с настроенным веб-сервером экспорт HTTP может быть проще в настройке.</target>
        </trans-unit>
        <trans-unit id="1179b23d825b14c0a26acd1779bd21e4b7a2880e" translate="yes" xml:space="preserve">
          <source>The Git remote to import this CVS repository into. Moves all CVS branches into remotes/&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt; akin to the way &lt;code&gt;git clone&lt;/code&gt; uses &lt;code&gt;origin&lt;/code&gt; by default.</source>
          <target state="translated">Пульт Git для импорта этого репозитория CVS. Перемещает все ветки CVS в удаленные / &amp;lt;remote&amp;gt; / &amp;lt;branch&amp;gt; аналогично тому, как &lt;code&gt;git clone&lt;/code&gt; использует &lt;code&gt;origin&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="bd47eb27f30e04cbdc75cd21789edadd8836d3bb" translate="yes" xml:space="preserve">
          <source>The Git repository browser</source>
          <target state="translated">Браузер Git-репозитория</target>
        </trans-unit>
        <trans-unit id="076055123196294023f50dc3852a8243be06956f" translate="yes" xml:space="preserve">
          <source>The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by &lt;code&gt;git gui&lt;/code&gt;'s Repository Visualize actions.</source>
          <target state="translated">Браузер репозитория Git. Показывает ветки, историю фиксации и различия файлов. gitk - это утилита, запускаемая действиями &lt;code&gt;git gui&lt;/code&gt; Repository Visualize.</target>
        </trans-unit>
        <trans-unit id="703dfd23887a83d4329e915dd0bcbd7608c6b6a7" translate="yes" xml:space="preserve">
          <source>The Git repository to import to. If the directory doesn&amp;rsquo;t exist, it will be created. Default is the current directory.</source>
          <target state="translated">Репозиторий Git для импорта. Если каталог не существует, он будет создан. По умолчанию это текущий каталог.</target>
        </trans-unit>
        <trans-unit id="6970e04ce98d2b4a3b2c6e8de2880e4a745e2c4f" translate="yes" xml:space="preserve">
          <source>The HEAD then refers to the SHA-1 of the commit instead of to a branch, and git branch shows that you are no longer on a branch:</source>
          <target state="translated">Затем HEAD ссылается на SHA-1 коммита,а не на ветку,и git-ветка показывает,что вы больше не находитесь на ветке:</target>
        </trans-unit>
        <trans-unit id="895d60d2bce01273de11df4a950c78fe3184bcf0" translate="yes" xml:space="preserve">
          <source>The HTTP USER_AGENT string presented to an HTTP server. The default value represents the version of the client Git such as git/1.7.1. This option allows you to override this value to a more common value such as Mozilla/4.0. This may be necessary, for instance, if connecting through a firewall that restricts HTTP connections to a set of common USER_AGENT strings (but not including those like git/1.7.1). Can be overridden by the &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; environment variable.</source>
          <target state="translated">Строка HTTP USER_AGENT, представленная HTTP-серверу. Значение по умолчанию представляет версию клиента Git, например git / 1.7.1. Эта опция позволяет вам заменить это значение на более распространенное значение, такое как Mozilla / 4.0. Это может быть необходимо, например, при подключении через брандмауэр, который ограничивает HTTP-соединения набором общих строк USER_AGENT (но не включая такие, как git / 1.7.1). Может быть переопределено переменной окружения &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00aa9820c66c0255936f6c8707aec2ad36a5c140" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)</source>
          <target state="translated">Командная строка HTTP-демон,которая будет выполнена.Здесь можно указать параметры командной строки,а в конце командной строки будет добавлен конфигурационный файл.В настоящее время поддерживаются apache2,lighttpd,mongoose,plackup,python и webrick.(По умолчанию:lighttpd)</target>
        </trans-unit>
        <trans-unit id="adee6c32cf5372a9cc214e1cabc3f604f4a421cf" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line to start gitweb on your working repository. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">Командная строка демона HTTP для запуска gitweb в вашем рабочем репозитории. См. &lt;a href=&quot;git-instaweb&quot;&gt;Git-instaweb [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a20118bebd861685578a19065b0fb24ab670ec89" translate="yes" xml:space="preserve">
          <source>The MIDX file format uses a chunk-based approach (similar to the commit-graph file) that allows optional data to be added.</source>
          <target state="translated">Формат MIDX-файла использует подход,основанный на блоках (аналогично файлу с графическим коммитом),что позволяет добавлять необязательные данные.</target>
        </trans-unit>
        <trans-unit id="64e372cd9f501c41226d338629f4adfe7884c507" translate="yes" xml:space="preserve">
          <source>The MIDX is stored in a file named &lt;code&gt;multi-pack-index&lt;/code&gt; in the .git/objects/pack directory. This could be stored in the pack directory of an alternate. It refers only to packfiles in that same directory.</source>
          <target state="translated">MIDX хранится в файле с именем &lt;code&gt;multi-pack-index&lt;/code&gt; в каталоге .git / objects / pack. Это может быть сохранено в каталоге пакета альтернативы. Это относится только к пакетным файлам в том же каталоге.</target>
        </trans-unit>
        <trans-unit id="be240040a2b303919e9f8b3f8c55bd2d4b871823" translate="yes" xml:space="preserve">
          <source>The MIDX keeps only one record per object ID. If an object appears in multiple packfiles, then the MIDX selects the copy in the most- recently modified packfile.</source>
          <target state="translated">MIDX хранит только одну запись на идентификатор объекта.Если объект появляется в нескольких пакетных файлах,то MIDX выбирает копию в последнем измененном пакетном файле.</target>
        </trans-unit>
        <trans-unit id="d248ab48f510e2fbd4b16391dc71868ce2bb9eb7" translate="yes" xml:space="preserve">
          <source>The MUA corrupted your patch; &quot;am&quot; would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what &lt;code&gt;patch&lt;/code&gt; file contains and check for the common corruption patterns mentioned above.</source>
          <target state="translated">MUA испортил ваш патч; &amp;laquo;am&amp;raquo; будет жаловаться, что патч не применяется. Загляните в подкаталог .git / rebase-apply / и посмотрите, какой файл &lt;code&gt;patch&lt;/code&gt; содержит, и проверьте общие шаблоны повреждения, упомянутые выше.</target>
        </trans-unit>
        <trans-unit id="dcfedffa2e791a211c838c6711816e41fded8f05" translate="yes" xml:space="preserve">
          <source>The Normal Format Target</source>
          <target state="translated">Нормальная форматная цель</target>
        </trans-unit>
        <trans-unit id="500d32200a061b0c3eb8acb59a37b1ba3087273e" translate="yes" xml:space="preserve">
          <source>The Object Database</source>
          <target state="translated">База данных объектов</target>
        </trans-unit>
        <trans-unit id="b3b387e6e23160b9001074a3b231e88c333277a0" translate="yes" xml:space="preserve">
          <source>The PERF target is intended for interactive performance analysis during development and is quite noisy.</source>
          <target state="translated">Цель PERF предназначена для интерактивного анализа производительности в процессе разработки и достаточно шумна.</target>
        </trans-unit>
        <trans-unit id="716ba6c2a540215443944eab8349af10087e97bb" translate="yes" xml:space="preserve">
          <source>The Performance Format Target</source>
          <target state="translated">Цель формата производительности</target>
        </trans-unit>
        <trans-unit id="ca04878afc5a61720c26b830b963e827e884a4f1" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Actually the possible values of this option are:</source>
          <target state="translated">Версия SSL для использования при согласовании SSL-соединения, если вы хотите установить значение по умолчанию. Доступная версия и версия по умолчанию зависят от того, была ли libcurl создана для NSS или OpenSSL, а также от конкретной конфигурации используемой криптографической библиотеки. Внутренне это устанавливает параметр &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; ; см. документацию libcurl для получения дополнительных сведений о формате этой опции и поддерживаемой версии ssl. Фактически возможные значения этой опции:</target>
        </trans-unit>
        <trans-unit id="6c8d77384dcf5927fceefc0c82e6aa35599c0a0b" translate="yes" xml:space="preserve">
          <source>The Trace2 API can be used to print debug, performance, and telemetry information to stderr or a file. The Trace2 feature is inactive unless explicitly enabled by enabling one or more Trace2 Targets.</source>
          <target state="translated">API Trace2 может использоваться для печати отладочной,производительной и телеметрической информации в stderr или в файл.Функция Trace2 неактивна,если явно не включена при включении одной или нескольких целей Trace2.</target>
        </trans-unit>
        <trans-unit id="6bdbd91221731e97e635f28174406bd894d81047" translate="yes" xml:space="preserve">
          <source>The Trace2 API defines a set of high-level messages with known fields, such as (&lt;code&gt;start&lt;/code&gt;: &lt;code&gt;argv&lt;/code&gt;) and (&lt;code&gt;exit&lt;/code&gt;: {&lt;code&gt;exit-code&lt;/code&gt;, &lt;code&gt;elapsed-time&lt;/code&gt;}).</source>
          <target state="translated">Trace2 API определяет набор сообщений высокого уровня с известными полями, такими как ( &lt;code&gt;start&lt;/code&gt; : &lt;code&gt;argv&lt;/code&gt; ) и ( &lt;code&gt;exit&lt;/code&gt; : { &lt;code&gt;exit-code&lt;/code&gt; , &lt;code&gt;elapsed-time&lt;/code&gt; }).</target>
        </trans-unit>
        <trans-unit id="c8d932fd39b46f7d652bfdd2be6511ab09fc4671" translate="yes" xml:space="preserve">
          <source>The Trace2 API is intended to replace the existing (Trace1) printf-style tracing provided by the existing &lt;code&gt;GIT_TRACE&lt;/code&gt; and &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; facilities. During initial implementation, Trace2 and Trace1 may operate in parallel.</source>
          <target state="translated">API Trace2 предназначен для замены существующей трассировки в стиле printf (Trace1), предоставляемой существующими средствами &lt;code&gt;GIT_TRACE&lt;/code&gt; и &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; . Во время первоначальной реализации Trace2 и Trace1 могут работать параллельно.</target>
        </trans-unit>
        <trans-unit id="a5397d7e9698d7ad87ff097450bf8a8e1a772416" translate="yes" xml:space="preserve">
          <source>The Trace2 code also defines a set of private functions and data types in the &lt;code&gt;trace2/&lt;/code&gt; directory. These symbols are prefixed with &lt;code&gt;tr2_&lt;/code&gt; and should only be used by functions in &lt;code&gt;trace2.c&lt;/code&gt;.</source>
          <target state="translated">Код Trace2 также определяет набор частных функций и типов данных в &lt;code&gt;trace2/&lt;/code&gt; . Эти символы имеют префикс &lt;code&gt;tr2_&lt;/code&gt; и должны использоваться только функциями в &lt;code&gt;trace2.c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e231fe7d9a0eb53151c1a418399ded2fd9db9e8" translate="yes" xml:space="preserve">
          <source>The URL for a submodule. This variable is copied from the .gitmodules file to the git config via &lt;code&gt;git submodule init&lt;/code&gt;. The user can change the configured URL before obtaining the submodule via &lt;code&gt;git submodule update&lt;/code&gt;. If neither submodule.&amp;lt;name&amp;gt;.active or submodule.active are set, the presence of this variable is used as a fallback to indicate whether the submodule is of interest to git commands. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">URL-адрес подмодуля. Эта переменная копируется из файла .gitmodules в конфигурацию &lt;code&gt;git submodule init&lt;/code&gt; через git submodule init . Пользователь может изменить настроенный URL-адрес перед получением подмодуля через &lt;code&gt;git submodule update&lt;/code&gt; . Если ни submodule. &amp;lt;name&amp;gt; .active, ни submodule.active не установлены, наличие этой переменной используется в качестве запасного варианта, чтобы указать, представляет ли подмодуль интерес для команд git. См. Подробности в &lt;a href=&quot;git-submodule&quot;&gt;git- &lt;/a&gt;&lt;a href=&quot;gitmodules&quot;&gt;submodule [ &lt;/a&gt;1] и gitmodules [5] .</target>
        </trans-unit>
        <trans-unit id="307f8458b88cd1196dc3047eb250fdb8e3348b46" translate="yes" xml:space="preserve">
          <source>The URL of a remote repository. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">URL-адрес удаленного репозитория. См. &lt;a href=&quot;git-fetch&quot;&gt;Git-fetch [1]&lt;/a&gt; или &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c06c873fe7803ddcdb456ba837dbd24d10b389" translate="yes" xml:space="preserve">
          <source>The URL to the remote repository.</source>
          <target state="translated">URL к удаленному репозиторию.</target>
        </trans-unit>
        <trans-unit id="846d99295948de526a5621f0a520c5a9a78af747" translate="yes" xml:space="preserve">
          <source>The Workflow</source>
          <target state="translated">Рабочий процесс</target>
        </trans-unit>
        <trans-unit id="91d8165377483e9123ecf4a3d5455b3b1999d185" translate="yes" xml:space="preserve">
          <source>The above can also be written as simply</source>
          <target state="translated">Вышеизложенное также может быть написано просто</target>
        </trans-unit>
        <trans-unit id="13c712cb6756cc53fb3407886d0503d18cb537c0" translate="yes" xml:space="preserve">
          <source>The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace, unless the branch.&amp;lt;name&amp;gt;.fetch option is used to specify a non-default refspec.</source>
          <target state="translated">Приведенная выше команда копирует все ветки из удаленного пространства имен refs / Heads / и сохраняет их в локальном пространстве имен refs / remotes / origin /, если только параметр branch. &amp;lt;name&amp;gt; .fetch не используется для указания refspec не по умолчанию.</target>
        </trans-unit>
        <trans-unit id="61e1efd32cbb415eea7b734b98558317a6d1aac3" translate="yes" xml:space="preserve">
          <source>The above command would change the origin repository to</source>
          <target state="translated">Вышеуказанная команда изменит репозиторий источника на</target>
        </trans-unit>
        <trans-unit id="cc504649b9359e7717badcdf0f10e04d6127c3a0" translate="yes" xml:space="preserve">
          <source>The above configuration expects your public repositories to live under &lt;code&gt;/pub/git&lt;/code&gt; and will serve them as &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt;, both as clonable Git URL and as browseable gitweb interface. If you then start your &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; with &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; then you can even use the &lt;code&gt;git://&lt;/code&gt; URL with exactly the same path.</source>
          <target state="translated">Приведенная выше конфигурация предполагает, что ваши общедоступные репозитории будут находиться в &lt;code&gt;/pub/git&lt;/code&gt; и будут обслуживать их как &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt; , как как клонируемый URL-адрес Git, так и как просматриваемый интерфейс gitweb. Если вы затем запустите свой &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; с помощью &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; , тогда вы даже можете использовать URL-адрес &lt;code&gt;git://&lt;/code&gt; с точно таким же путем.</target>
        </trans-unit>
        <trans-unit id="baa5f35656f9b3f3ba646932132fa97233a197b9" translate="yes" xml:space="preserve">
          <source>The above is all you need to know to resolve a simple merge. But Git also provides more information to help resolve conflicts:</source>
          <target state="translated">Все,что вам нужно знать,чтобы решить проблему простого слияния.Но Git также предоставляет больше информации для разрешения конфликтов:</target>
        </trans-unit>
        <trans-unit id="70fce3bc08ea4ed40bcc99c52f88c26bd24f0b87" translate="yes" xml:space="preserve">
          <source>The above is the description of a Git merge at the lowest level, to help you understand what conceptually happens under the hood. In practice, nobody, not even Git itself, runs &lt;code&gt;git cat-file&lt;/code&gt; three times for this. There is a &lt;code&gt;git merge-index&lt;/code&gt; program that extracts the stages to temporary files and calls a &quot;merge&quot; script on it:</source>
          <target state="translated">Выше приведено описание слияния Git на самом низком уровне, чтобы помочь вам понять, что концептуально происходит под капотом. На практике никто, даже сам Git, для этого трижды не запускает &lt;code&gt;git cat-file&lt;/code&gt; . Существует программа &lt;code&gt;git merge-index&lt;/code&gt; , которая извлекает этапы во временные файлы и вызывает на них сценарий &amp;laquo;слияния&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="eb77c0d462477bf4637c28037a03befbbf605c33" translate="yes" xml:space="preserve">
          <source>The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise.</source>
          <target state="translated">Абсолютный путь к рабочему дереву,в котором проверяется ссылка,если она проверяется в любом связанном дереве.Пустая строка в противном случае.</target>
        </trans-unit>
        <trans-unit id="76cd9fb4bfcc53cf44ccfea4ed1923acc958405e" translate="yes" xml:space="preserve">
          <source>The accepted attributes are &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;, &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;blink&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;italic&lt;/code&gt;, and &lt;code&gt;strike&lt;/code&gt; (for crossed-out or &quot;strikethrough&quot; letters). The position of any attributes with respect to the colors (before, after, or in between), doesn&amp;rsquo;t matter. Specific attributes may be turned off by prefixing them with &lt;code&gt;no&lt;/code&gt; or &lt;code&gt;no-&lt;/code&gt; (e.g., &lt;code&gt;noreverse&lt;/code&gt;, &lt;code&gt;no-ul&lt;/code&gt;, etc).</source>
          <target state="translated">Принятая атрибуты &lt;code&gt;bold&lt;/code&gt; , &lt;code&gt;dim&lt;/code&gt; , &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;blink&lt;/code&gt; , &lt;code&gt;reverse&lt;/code&gt; , &lt;code&gt;italic&lt;/code&gt; и &lt;code&gt;strike&lt;/code&gt; (для перечеркнутого или &amp;laquo;зачеркивания&amp;raquo; буквы). Положение любых атрибутов по отношению к цветам (до, после или между) не имеет значения. Специфические атрибуты могут быть выключены не предварив их &lt;code&gt;no&lt;/code&gt; или &lt;code&gt;no-&lt;/code&gt; (например, &lt;code&gt;noreverse&lt;/code&gt; , &lt;code&gt;no-ul&lt;/code&gt; и т.д.).</target>
        </trans-unit>
        <trans-unit id="0bb8a69a5cde6b982a60a95e4956ebdf1a59fa5f" translate="yes" xml:space="preserve">
          <source>The accepted patterns in the cone pattern set are:</source>
          <target state="translated">В наборе шаблонов конусов используются общепринятые шаблоны:</target>
        </trans-unit>
        <trans-unit id="ec26e1bb6d1ddd903fea6ea4b1aec39f9a4bdff7" translate="yes" xml:space="preserve">
          <source>The action of fixing up manually what a failed automatic &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; left behind.</source>
          <target state="translated">Действие по исправлению вручную того, что осталось после неудачного автоматического &lt;a href=&quot;#def_merge&quot;&gt;слияния&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91929f919cdca3ddad9711d4446a1108e24ab05c" translate="yes" xml:space="preserve">
          <source>The action of updating all or part of the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; with a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; from the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and updating the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; if the whole working tree has been pointed at a new &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">Действие обновления всех или частей &lt;a href=&quot;#def_working_tree&quot;&gt;рабочего дерева&lt;/a&gt; с &lt;a href=&quot;#def_tree_object&quot;&gt;объектом дерева&lt;/a&gt; или &lt;a href=&quot;#def_blob_object&quot;&gt;сгустком&lt;/a&gt; из &lt;a href=&quot;#def_object_database&quot;&gt;базы данных объектов&lt;/a&gt; , а также обновления &lt;a href=&quot;#def_index&quot;&gt;индекса&lt;/a&gt; и &lt;a href=&quot;#def_HEAD&quot;&gt;ГОЛОВУ&lt;/a&gt; , если все рабочее дерево было отмечено в новом &lt;a href=&quot;#def_branch&quot;&gt;филиале&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf91c6dac7e4978798d8310657f124dd799f4bf4" translate="yes" xml:space="preserve">
          <source>The action that will be run. Defaults to &lt;code&gt;projects_list&lt;/code&gt; if repo is not set, and to &lt;code&gt;summary&lt;/code&gt; otherwise.</source>
          <target state="translated">Действие, которое будет запущено. Значения по умолчанию для &lt;code&gt;projects_list&lt;/code&gt; если репо не установлено, и &lt;code&gt;summary&lt;/code&gt; в противном случае.</target>
        </trans-unit>
        <trans-unit id="e262b52287502541a33fa85d5cf2fdae897da448" translate="yes" xml:space="preserve">
          <source>The active branch LRU, when coupled with the filename string pool and lazy loading of subtrees, allows fast-import to efficiently import projects with 2,000+ branches and 45,114+ files in a very limited memory footprint (less than 2.7 MiB per active branch).</source>
          <target state="translated">LRU активной ветки в сочетании со строковым пулом имён файлов и ленивой загрузкой поддеревьев позволяет быстро импортировать проекты с 2000+ветками и 45 114+файлами в очень ограниченном объеме памяти (менее 2.7 Мб на одну активную ветку).</target>
        </trans-unit>
        <trans-unit id="5b37048d4139b83b97c29aa7a22d2da66c283ae2" translate="yes" xml:space="preserve">
          <source>The actual configuration line should be on one line.</source>
          <target state="translated">Фактическая линия конфигурации должна быть на одной линии.</target>
        </trans-unit>
        <trans-unit id="b70c0ba474f3173fff896ac2745af10a69e6cc3b" translate="yes" xml:space="preserve">
          <source>The additional AliasMatch makes it so that</source>
          <target state="translated">Дополнительный AliasMatch делает его так,что</target>
        </trans-unit>
        <trans-unit id="d6139a3bd26979c3a7767519a48aa9c385b73634" translate="yes" xml:space="preserve">
          <source>The advantage of doing this is that the history of &lt;code&gt;next&lt;/code&gt; will be clean. For example, some topics merged into &lt;code&gt;next&lt;/code&gt; may have initially looked promising, but were later found to be undesirable or premature. In such a case, the topic is reverted out of &lt;code&gt;next&lt;/code&gt; but the fact remains in the history that it was once merged and reverted. By recreating &lt;code&gt;next&lt;/code&gt;, you give another incarnation of such topics a clean slate to retry, and a feature release is a good point in history to do so.</source>
          <target state="translated">Преимущество этого заключается в том, что история &lt;code&gt;next&lt;/code&gt; будет чистой. Например, некоторые темы, объединенные в &lt;code&gt;next&lt;/code&gt; могли поначалу казаться многообещающими, но позже были признаны нежелательными или преждевременными. В таком случае тема возвращается из &lt;code&gt;next&lt;/code&gt; но в истории остается факт, что она когда-то была объединена и возвращена. Воссоздавая &lt;code&gt;next&lt;/code&gt; , вы даете другому воплощению таких тем &amp;laquo;чистый лист&amp;raquo;, чтобы повторить попытку, и выпуск новой функции - хороший момент в истории для этого.</target>
        </trans-unit>
        <trans-unit id="2f1746fed6139a8489ee3d916322bdcbeb17e684" translate="yes" xml:space="preserve">
          <source>The advantage of using an external diff command is flexibility. You are not bound to find line-oriented changes, nor is it necessary for the output to resemble unified diff. You are free to locate and report changes in the most appropriate way for your data format.</source>
          <target state="translated">Преимуществом использования внешней команды сравнения является гибкость.Вы не обязаны находить линейно-ориентированные изменения,также не требуется,чтобы вывод был похож на унифицированный diff.Вы можете свободно находить и сообщать об изменениях наиболее подходящим для вашего формата данных способом.</target>
        </trans-unit>
        <trans-unit id="37f935f00ace4f7aca8e441adbbf1abe0704a83a" translate="yes" xml:space="preserve">
          <source>The am backend drops any &quot;empty&quot; commits, regardless of whether the commit started empty (had no changes relative to its parent to start with) or ended empty (all changes were already applied upstream in other commits).</source>
          <target state="translated">Бэкэнд am выкидывает любые &quot;пустые&quot; коммиты,независимо от того,начался ли коммит пустым (не было никаких изменений относительно его родителя для начала)или закончился пустым (все изменения уже были применены до этого в других коммитах).</target>
        </trans-unit>
        <trans-unit id="013053835d145f0cc494db8211a188c9999bae09" translate="yes" xml:space="preserve">
          <source>The area where a pair of conflicting changes happened is marked with markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The part before the &lt;code&gt;=======&lt;/code&gt; is typically your side, and the part afterwards is typically their side.</source>
          <target state="translated">Область, в которой произошла пара конфликтующих изменений, отмечена маркерами &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; . Часть перед &lt;code&gt;=======&lt;/code&gt; обычно является вашей стороной, а часть после нее - их стороной.</target>
        </trans-unit>
        <trans-unit id="bbce7a566319a0fa5122538fad84df16b94a33f3" translate="yes" xml:space="preserve">
          <source>The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.</source>
          <target state="translated">Аргументом к этому варианту может быть глобус на именах ссылок,ссылка или (возможно,сокращённое)SHA-1 коммита.Указание глобуса эквивалентно указанию этого параметра несколько раз,по одному для каждого совпадающего имени ссылки.</target>
        </trans-unit>
        <trans-unit id="6083c463b2a8fa637d23cd99c59e9746cb6a7539" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;diff&lt;/code&gt; affects how Git generates diffs for particular files. It can tell Git whether to generate a textual patch for the path or to treat the path as a binary file. It can also affect what line is shown on the hunk header &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; line, tell Git to use an external command to generate the diff, or ask Git to convert binary files to a text format before generating the diff.</source>
          <target state="translated">Атрибут &lt;code&gt;diff&lt;/code&gt; влияет на то, как Git генерирует различия для определенных файлов. Он может сообщить Git, следует ли создавать текстовый патч для пути или рассматривать путь как двоичный файл. Это также может повлиять на то, какая строка отображается в строке заголовка блока &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; , указать Git использовать внешнюю команду для генерации различий или попросить Git преобразовать двоичные файлы в текстовый формат перед создание diff.</target>
        </trans-unit>
        <trans-unit id="e3fef41e3a691b83ea57e915fd492f173e96b0ec" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;merge&lt;/code&gt; affects how three versions of a file are merged when a file-level merge is necessary during &lt;code&gt;git merge&lt;/code&gt;, and other commands such as &lt;code&gt;git revert&lt;/code&gt; and &lt;code&gt;git cherry-pick&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; атрибутов влияет на способ слияния трех версий файла, когда слияние на уровне файла необходимо во время &lt;code&gt;git merge&lt;/code&gt; , и другие команды, такие как &lt;code&gt;git revert&lt;/code&gt; и &lt;code&gt;git cherry-pick&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fe7b4a122d21c0258f6159b6aeead7d915c58b4" translate="yes" xml:space="preserve">
          <source>The attributes allow a fine-grained control, how the line endings are converted. Here is an example that will make Git normalize .txt, .vcproj and .sh files, ensure that .vcproj files have CRLF and .sh files have LF in the working directory, and prevent .jpg files from being normalized regardless of their content.</source>
          <target state="translated">Атрибуты позволяют осуществлять мелкозернистый контроль,а также преобразовывать окончания линий.Вот пример,который заставит Git'а нормализовать .txt,.vcproj и .sh файлы,убедиться,что .vcproj файлы имеют CRLF,а .sh файлы имеют LF в рабочем каталоге,и предотвратить нормализацию .jpg файлов вне зависимости от их содержимого.</target>
        </trans-unit>
        <trans-unit id="0849ab3d36b0ce6d3f6183dc21f6e83ad1520176" translate="yes" xml:space="preserve">
          <source>The author name and email address to use when no author information can be found in the patch description.</source>
          <target state="translated">Имя автора и адрес электронной почты для использования,когда в описании патча нет информации об авторе.</target>
        </trans-unit>
        <trans-unit id="b012a2641006f12bad01716515743698d7deabe2" translate="yes" xml:space="preserve">
          <source>The author of a piece of code.</source>
          <target state="translated">Автор куска кода.</target>
        </trans-unit>
        <trans-unit id="147440e8e5aa984c82659720dc655a2dca5add95" translate="yes" xml:space="preserve">
          <source>The backend process sets GIT_COMMITTER_NAME to &lt;code&gt;$REMOTE_USER&lt;/code&gt; and GIT_COMMITTER_EMAIL to &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt;, ensuring that any reflogs created by &lt;code&gt;git-receive-pack&lt;/code&gt; contain some identifying information of the remote user who performed the push.</source>
          <target state="translated">Внутренний процесс устанавливает GIT_COMMITTER_NAME равным &lt;code&gt;$REMOTE_USER&lt;/code&gt; и GIT_COMMITTER_EMAIL равным &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt; , гарантируя, что любые рефлоги, созданные &lt;code&gt;git-receive-pack&lt;/code&gt; , содержат некоторую идентифицирующую информацию об удаленном пользователе, который выполнил push.</target>
        </trans-unit>
        <trans-unit id="21e5e59ef58a1f64125adda00de18248644f6705" translate="yes" xml:space="preserve">
          <source>The base object could also be deltified if it&amp;rsquo;s in the same pack. Ref-delta can also refer to an object outside the pack (i.e. the so-called &quot;thin pack&quot;). When stored on disk however, the pack should be self contained to avoid cyclic dependency.</source>
          <target state="translated">Базовый объект также может быть удален, если он находится в одной упаковке. Ref-delta может также относиться к объекту за пределами упаковки (т.е. так называемой &amp;laquo;тонкой упаковке&amp;raquo;). Однако при хранении на диске пакет должен быть автономным, чтобы избежать циклической зависимости.</target>
        </trans-unit>
        <trans-unit id="1877d075d52f12eee201f2607da0c072a35f24bc" translate="yes" xml:space="preserve">
          <source>The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the &lt;code&gt;base commit&lt;/code&gt;, which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more &lt;code&gt;prerequisite patches&lt;/code&gt;, which are well-known patches in flight that is not yet part of the &lt;code&gt;base commit&lt;/code&gt; that need to be applied on top of &lt;code&gt;base commit&lt;/code&gt; in topological order before the patches can be applied.</source>
          <target state="translated">Информационный блок базового дерева используется разработчиками или сторонними тестировщиками, чтобы знать точное состояние, к которому применяется серия исправлений. Он состоит из &lt;code&gt;base commit&lt;/code&gt; , которая является хорошо известной фиксацией, которая является частью стабильной части истории проекта , над которой работают все остальные, и нуля или более &lt;code&gt;prerequisite patches&lt;/code&gt; , которые являются хорошо известными исправлениями в стадии разработки, которые еще не часть &lt;code&gt;base commit&lt;/code&gt; которая должна быть применена поверх &lt;code&gt;base commit&lt;/code&gt; в топологическом порядке, прежде чем можно будет применить исправления.</target>
        </trans-unit>
        <trans-unit id="dc39b1b9637026dfb15dfa743421fbe1dc2277e7" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background.</source>
          <target state="translated">Допустимые основные цвета: &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;black&lt;/code&gt; , &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;yellow&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; , &lt;code&gt;magenta&lt;/code&gt; , &lt;code&gt;cyan&lt;/code&gt; и &lt;code&gt;white&lt;/code&gt; . Первый цвет - передний план; второй - фон.</target>
        </trans-unit>
        <trans-unit id="d4e1b119ab89bbecfc6f0f5d854268dcecbb088f" translate="yes" xml:space="preserve">
          <source>The basic form described in DESCRIPTION with a Git directory, a working directory, a &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry.</source>
          <target state="translated">Базовая форма, описанная в &lt;code&gt;gitlink&lt;/code&gt; , с каталогом Git, рабочим каталогом, gitlink и &lt;code&gt;.gitmodules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b21f7863c055f0aa6938a038ffa25acf7017fe84" translate="yes" xml:space="preserve">
          <source>The basic greedy diff algorithm. Currently, this is the default.</source>
          <target state="translated">Основной алгоритм жадности.В настоящее время это алгоритм по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ebbd31d9dd00322abaa4bb83a8b03f787c70d43c" translate="yes" xml:space="preserve">
          <source>The basic requirements:</source>
          <target state="translated">Основные требования:</target>
        </trans-unit>
        <trans-unit id="675f96a5f033def81701bda4e874ec2fbad8a388" translate="yes" xml:space="preserve">
          <source>The below documentation is the same as what&amp;rsquo;s found in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">Приведенная ниже документация такая же, как и в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f55762f9996c39bda184001319965b733714f313" translate="yes" xml:space="preserve">
          <source>The best way to get one is by using the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command to download a copy of an existing repository. If you don&amp;rsquo;t already have a project in mind, here are some interesting examples:</source>
          <target state="translated">Лучший способ получить его - использовать команду &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; для загрузки копии существующего репозитория. Если у вас еще нет проекта, вот несколько интересных примеров:</target>
        </trans-unit>
        <trans-unit id="e2b6c88cac94cf24687d4ba9657759c1ab28582a" translate="yes" xml:space="preserve">
          <source>The best way to see how this works is using the &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; command; running gitk now on a Git repository and looking for merge commits will help understand how Git organizes history.</source>
          <target state="translated">Лучший способ увидеть, как это работает, - использовать команду &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; ; запуск gitk в репозитории Git и поиск коммитов слияния помогут понять, как Git организует историю.</target>
        </trans-unit>
        <trans-unit id="8130ad227eb2e1ffe8f116dc4280c5919bb4cd97" translate="yes" xml:space="preserve">
          <source>The branch &lt;code&gt;test&lt;/code&gt; is short for &lt;code&gt;refs/heads/test&lt;/code&gt;.</source>
          <target state="translated">Филиал &lt;code&gt;test&lt;/code&gt; короток для &lt;code&gt;refs/heads/test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="420b2dd61e4562065a5bd273fcdbaecde70d1742" translate="yes" xml:space="preserve">
          <source>The branch LRU builtin to fast-import tends to behave very well, and the cost of activating an inactive branch is so low that bouncing around between branches has virtually no impact on import performance.</source>
          <target state="translated">LRU-отделения,построенные для быстрого импорта,ведут себя очень хорошо,а стоимость активации неактивной ветви настолько низка,что скачок между ветвями практически не влияет на производительность импорта.</target>
        </trans-unit>
        <trans-unit id="58be5b6cbe7d7c0a923608fe1415c68702e2aa84" translate="yes" xml:space="preserve">
          <source>The chain of operation</source>
          <target state="translated">Цепь работы</target>
        </trans-unit>
        <trans-unit id="cb0b83bdafd60672fc0fb681d6c09ff33adfb7dc" translate="yes" xml:space="preserve">
          <source>The changes are still visible in the submodule&amp;rsquo;s reflog.</source>
          <target state="translated">Изменения все еще видны в журнале ссылок подмодуля.</target>
        </trans-unit>
        <trans-unit id="e18a17400a7fdeb34351715eb209f43bb56b69d6" translate="yes" xml:space="preserve">
          <source>The clone command creates a new directory named after the project (&lt;code&gt;git&lt;/code&gt; or &lt;code&gt;linux&lt;/code&gt; in the examples above). After you cd into this directory, you will see that it contains a copy of the project files, called the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, together with a special top-level directory named &lt;code&gt;.git&lt;/code&gt;, which contains all the information about the history of the project.</source>
          <target state="translated">Команда clone создает новый каталог, названный в честь проекта ( &lt;code&gt;git&lt;/code&gt; или &lt;code&gt;linux&lt;/code&gt; в приведенных выше примерах). После того, как вы войдете в этот каталог, вы увидите, что он содержит копию файлов проекта, называемую &lt;a href=&quot;#def_working_tree&quot;&gt;рабочим деревом&lt;/a&gt; , вместе со специальным каталогом верхнего уровня с именем &lt;code&gt;.git&lt;/code&gt; , который содержит всю информацию об истории проекта.</target>
        </trans-unit>
        <trans-unit id="9b1ff6b6614bf65ff7cf18fa7ac8ca0c73c31da4" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;git commit -a&lt;/code&gt; first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you.</source>
          <target state="translated">Команда &lt;code&gt;git commit -a&lt;/code&gt; сначала просматривает ваше рабочее дерево, замечает, что вы изменили hello.c и удалили goodbye.c, и выполняет необходимые для вас &lt;code&gt;git add&lt;/code&gt; и &lt;code&gt;git rm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95cb34ce247ae47a8a7d5a122ee875bb99decb40" translate="yes" xml:space="preserve">
          <source>The command allows for creation and fast-forwarding of sha1 refs (heads/tags) on the remote end (strictly speaking, it is the local end &lt;code&gt;git-receive-pack&lt;/code&gt; runs, but to the user who is sitting at the send-pack end, it is updating the remote. Confused?)</source>
          <target state="translated">Команда позволяет создавать и пересылать ссылки sha1 (заголовки / теги) на удаленном конце (строго говоря, это запускается &lt;code&gt;git-receive-pack&lt;/code&gt; на локальном конце , но для пользователя, который сидит на конце send-pack) , он обновляет пульт.</target>
        </trans-unit>
        <trans-unit id="2b42e9d45bef456324952e5870d272017a1a991c" translate="yes" xml:space="preserve">
          <source>The command also looks at &lt;code&gt;core.trustctime&lt;/code&gt; configuration variable. It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Команда также просматривает переменную конфигурации &lt;code&gt;core.trustctime&lt;/code&gt; . Это может быть полезно, когда время изменения inode регулярно изменяется чем-то вне Git (сканеры файловой системы и системы резервного копирования используют ctime для пометки обработанных файлов) (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2d2a0a5d3ee3b745ff8e27d667799782d3fee27" translate="yes" xml:space="preserve">
          <source>The command by default does not allow an update that is not a fast-forward to prevent such loss of history.</source>
          <target state="translated">Команда по умолчанию не разрешает обновление,которое не является быстрой перемоткой,чтобы предотвратить такую потерю истории.</target>
        </trans-unit>
        <trans-unit id="57bd298a9fbda93bedda739fa9a93ffd1fbe53dd" translate="yes" xml:space="preserve">
          <source>The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes branch tips to be packed as well. Useful for a repository with many branches of historical interests.</source>
          <target state="translated">Команда по умолчанию упаковывает все теги и ссылки,которые уже упакованы,и оставляет другие ссылки.Это связано с тем,что ветки,как ожидается,будут активно развиваться,а упаковка их советов не поможет в работе.Эта опция приводит к тому,что советы веток также упаковываются.Полезно для репозитория с множеством веток,имеющих исторический интерес.</target>
        </trans-unit>
        <trans-unit id="affc62639786f9435bc3e40b781bdaefab9bf88f" translate="yes" xml:space="preserve">
          <source>The command can also be used to restore the content in the index with &lt;code&gt;--staged&lt;/code&gt;, or restore both the working tree and the index with &lt;code&gt;--staged --worktree&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--staged&lt;/code&gt; также можно использовать для восстановления содержимого индекса с помощью --staged или для восстановления как рабочего дерева, так и индекса с помощью &lt;code&gt;--staged --worktree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="033264e01f6eaf7651e64aee25dc83cea3397f0e" translate="yes" xml:space="preserve">
          <source>The command finds the most recent tag that is reachable from a commit. If the tag points to the commit, then only the tag is shown. Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a &quot;human-readable&quot; object name which can also be used to identify the commit to other git commands.</source>
          <target state="translated">Команда находит последний тег,доступный из коммита.Если метка указывает на фиксацию,то отображается только метка.В противном случае,она суффиксовывает имя метки с количеством дополнительных коммитов поверх объекта с меткой и сокращенным именем объекта последнего коммита.В результате получается &quot;читаемое человеком&quot; имя объекта,которое также может быть использовано для идентификации коммита к другим командам git'а.</target>
        </trans-unit>
        <trans-unit id="3ab56fbe7068ffbc29e1e09d644dcd93a3d4ced5" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;color.status&lt;/code&gt; (or &lt;code&gt;status.color&lt;/code&gt; &amp;mdash; they mean the same thing and the latter is kept for backward compatibility) and &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; configuration variables to colorize its output.</source>
          <target state="translated">Команда &lt;code&gt;color.status&lt;/code&gt; (или &lt;code&gt;status.color&lt;/code&gt; - они означают одно и то же, а последнее сохраняется для обратной совместимости) и переменные конфигурации &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; для раскрашивания ее вывода.</target>
        </trans-unit>
        <trans-unit id="426f574eb4223ad0c1806f2471b371a9ce2ce62b" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;core.filemode&lt;/code&gt; configuration variable. If your repository is on a filesystem whose executable bits are unreliable, this should be set to &lt;code&gt;false&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This causes the command to ignore differences in file modes recorded in the index and the file mode on the filesystem if they differ only on executable bit. On such an unfortunate filesystem, you may need to use &lt;code&gt;git update-index --chmod=&lt;/code&gt;.</source>
          <target state="translated">Команда &lt;code&gt;core.filemode&lt;/code&gt; переменную конфигурации core.filemode . Если ваш репозиторий находится в файловой системе, исполняемые биты которой ненадежны, следует установить значение &lt;code&gt;false&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ). Это заставляет команду игнорировать различия в режимах файлов, записанных в индексе, и режимах файлов в файловой системе, если они отличаются только исполняемым битом. В такой неудачной файловой системе вам может потребоваться использовать &lt;code&gt;git update-index --chmod=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c1fbeab69cdf1a35e381ef7eff39e0ef873ae8e" translate="yes" xml:space="preserve">
          <source>The command is kept primarily for historical reasons; fingers of many people who learned Git long before &lt;code&gt;git log&lt;/code&gt; was invented by reading Linux kernel mailing list are trained to type it.</source>
          <target state="translated">Команда сохраняется в основном по историческим причинам; пальцы многих людей, которые изучили Git задолго до того, как &lt;code&gt;git log&lt;/code&gt; был изобретен путем чтения списка рассылки ядра Linux, обучены его печатать.</target>
        </trans-unit>
        <trans-unit id="078766939aed50311c1dcee68ff982a08734592e" translate="yes" xml:space="preserve">
          <source>The command line for those commands that support taking submodules as part of their pathspecs. Most commands have a boolean flag &lt;code&gt;--recurse-submodules&lt;/code&gt; which specify whether to recurse into submodules. Examples are &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;checkout&lt;/code&gt;. Some commands take enums, such as &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;, where you can specify how submodules are affected.</source>
          <target state="translated">Командная строка для тех команд, которые поддерживают включение подмодулей в свои спецификации пути. Большинство команд имеют логический флаг &lt;code&gt;--recurse-submodules&lt;/code&gt; , который указывает, нужно ли выполнять рекурсию в подмодули. Примеры: &lt;code&gt;grep&lt;/code&gt; и &lt;code&gt;checkout&lt;/code&gt; . Некоторые команды используют перечисления, такие как &lt;code&gt;fetch&lt;/code&gt; и &lt;code&gt;push&lt;/code&gt; , где вы можете указать, как будут затронуты подмодули.</target>
        </trans-unit>
        <trans-unit id="0c67f633874ba0fbe1af2a193c1c589167c2ab4d" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. See &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; section above.</source>
          <target state="translated">Команда просматривает переменную конфигурации &lt;code&gt;core.ignorestat&lt;/code&gt; . См. Раздел &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="5f7f0d79e587cabe73eebce8a6424fb5cae3c144" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. When this is true, paths updated with &lt;code&gt;git update-index paths...&lt;/code&gt; and paths updated with other Git commands that update both index and working tree (e.g. &lt;code&gt;git apply --index&lt;/code&gt;, &lt;code&gt;git checkout-index -u&lt;/code&gt;, and &lt;code&gt;git read-tree -u&lt;/code&gt;) are automatically marked as &quot;assume unchanged&quot;. Note that &quot;assume unchanged&quot; bit is &lt;strong&gt;not&lt;/strong&gt; set if &lt;code&gt;git update-index --refresh&lt;/code&gt; finds the working tree file matches the index (use &lt;code&gt;git update-index --really-refresh&lt;/code&gt; if you want to mark them as &quot;assume unchanged&quot;).</source>
          <target state="translated">Команда просматривает переменную конфигурации &lt;code&gt;core.ignorestat&lt;/code&gt; . Когда это правда, пути обновляются с помощью &lt;code&gt;git update-index paths...&lt;/code&gt; и пути обновляются другими командами Git, которые обновляют как индекс, так и рабочее дерево (например, &lt;code&gt;git apply --index&lt;/code&gt; , &lt;code&gt;git checkout-index -u&lt;/code&gt; и &lt;code&gt;git read-tree -u&lt;/code&gt; ) автоматически помечаются как &amp;laquo;принять без изменений&amp;raquo;. Обратите внимание, что бит &amp;laquo;считать неизменным&amp;raquo; &lt;strong&gt;не&lt;/strong&gt; устанавливается, если &lt;code&gt;git update-index --refresh&lt;/code&gt; обнаруживает, что файл рабочего дерева соответствует индексу (используйте &lt;code&gt;git update-index --really-refresh&lt;/code&gt; , если вы хотите пометить их как &amp;laquo;предполагать без изменений&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="719021beca97cba355f40567331ed4531fab91cd" translate="yes" xml:space="preserve">
          <source>The command loop shows the list of subcommands available, and gives a prompt &quot;What now&amp;gt; &quot;. In general, when the prompt ends with a single &lt;code&gt;&amp;gt;&lt;/code&gt;, you can pick only one of the choices given and type return, like this:</source>
          <target state="translated">Цикл команд показывает список доступных подкоманд и подсказку &amp;laquo;Что теперь&amp;gt;&amp;raquo;. В общем, когда подсказка заканчивается одним символом &lt;code&gt;&amp;gt;&lt;/code&gt; , вы можете выбрать только один из предложенных вариантов и ввести return, например:</target>
        </trans-unit>
        <trans-unit id="653e31d7d7203bdc451cd54eed957012f41434d3" translate="yes" xml:space="preserve">
          <source>The command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run &lt;code&gt;git am --abort&lt;/code&gt; before running the command with mailbox names.</source>
          <target state="translated">Команда отказывается обрабатывать новые почтовые ящики до завершения текущей операции, поэтому, если вы решите начать с нуля, запустите &lt;code&gt;git am --abort&lt;/code&gt; перед запуском команды с именами почтовых ящиков.</target>
        </trans-unit>
        <trans-unit id="ddc41d8aed51eb71b1c7af7000815eb2a4b359d3" translate="yes" xml:space="preserve">
          <source>The command stream is terminated by a blank line. In some cases (indicated in the documentation of the relevant commands), this blank line is followed by a payload in some other protocol (e.g., the pack protocol), while in others it indicates the end of input.</source>
          <target state="translated">Поток команд завершается пустой строкой.В некоторых случаях (указанных в документации к соответствующим командам)за этой пустой строкой следует полезная нагрузка в каком-то другом протоколе (например,в протоколе pack),а в других она указывает на конец ввода.</target>
        </trans-unit>
        <trans-unit id="d1cdce0d3b2e7df2146074a7208b9f02c1bab1a7" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git diff-tree&lt;/code&gt; command to control how the changes the commit introduces are shown.</source>
          <target state="translated">Команда принимает параметры, применимые к команде &lt;code&gt;git diff-tree&lt;/code&gt; , чтобы управлять отображением изменений, вносимых фиксацией.</target>
        </trans-unit>
        <trans-unit id="35fc48f2de1638c3a16917e24656f5cccec37735" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git log&lt;/code&gt; command to control what is shown and how. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">Команда принимает параметры, применимые к команде &lt;code&gt;git log&lt;/code&gt; , чтобы контролировать, что и как показывать. См. &lt;a href=&quot;git-log&quot;&gt;Git-log [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="704cfc598be528aca39957bda30b48a4e32947ac" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command to control what is shown and how, and options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown.</source>
          <target state="translated">Команда принимает параметры, применимые к команде &lt;code&gt;git rev-list&lt;/code&gt; , чтобы управлять тем, что и как показывать, и параметры, применимые к командам &lt;code&gt;git diff-*&lt;/code&gt; , чтобы управлять тем, как отображаются изменения, вносимые каждой фиксацией.</target>
        </trans-unit>
        <trans-unit id="05dd6533643357a7eb4c0a33aa8aafdf86be046c" translate="yes" xml:space="preserve">
          <source>The command takes various subcommands, and different options depending on the subcommand:</source>
          <target state="translated">Команда принимает различные подкоманды,а также различные опции в зависимости от подкоманды:</target>
        </trans-unit>
        <trans-unit id="5dfb0879d1b00c6726b4c473489aecee6c7360c1" translate="yes" xml:space="preserve">
          <source>The command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Команда, которую должен вызвать драйвер diff для создания преобразованной в текст версии файла. Результат преобразования используется для создания удобочитаемой разницы. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76561fd073c2b7875043b506e4a6c918bbf27fef" translate="yes" xml:space="preserve">
          <source>The command usually removes loose refs under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; hierarchy after packing them. This option tells it not to.</source>
          <target state="translated">Команда обычно удаляет свободные &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; иерархии $ GIT_DIR / refs после их упаковки. Эта опция запрещает.</target>
        </trans-unit>
        <trans-unit id="77170493947dd63f2044149c05ae4eb27dc0d118" translate="yes" xml:space="preserve">
          <source>The command usually shows percentage progress. This flag suppresses it.</source>
          <target state="translated">Команда обычно показывает прогресс в процентах.Этот флаг его подавляет.</target>
        </trans-unit>
        <trans-unit id="3df5350b5d92a4c7df677ed19aeefaf4fd05338a" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a blob object to a worktree file upon checkout. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Команда, которая используется для преобразования содержимого объекта blob в файл рабочего дерева при оформлении заказа. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e78c7e2042e4de22f48dc29ab38867e1c8242106" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a worktree file to a blob upon checkin. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Команда, которая используется для преобразования содержимого файла рабочего дерева в большой двоичный объект при регистрации. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6711f072ffccd6a7948d8fcfc289d0284bd97d1" translate="yes" xml:space="preserve">
          <source>The command will only rewrite the &lt;code&gt;positive&lt;/code&gt; refs mentioned in the command line (e.g. if you pass &lt;code&gt;a..b&lt;/code&gt;, only &lt;code&gt;b&lt;/code&gt; will be rewritten). If you specify no filters, the commits will be recommitted without any changes, which would normally have no effect. Nevertheless, this may be useful in the future for compensating for some Git bugs or such, therefore such a usage is permitted.</source>
          <target state="translated">Команда перезапишет только &lt;code&gt;positive&lt;/code&gt; ссылки, указанные в командной строке (например, если вы передадите &lt;code&gt;a..b&lt;/code&gt; , будет перезаписан только &lt;code&gt;b&lt;/code&gt; ). Если вы не укажете фильтры, коммиты будут повторяться без каких-либо изменений, что обычно не имеет никакого эффекта. Тем не менее, это может быть полезно в будущем для компенсации некоторых ошибок Git или подобных, поэтому такое использование разрешено.</target>
        </trans-unit>
        <trans-unit id="6c1d44a42d537aa236fa8b0c18f8ebc1e0d665b8" translate="yes" xml:space="preserve">
          <source>The command writes the commit object name of the common ancestor to the standard output, so we captured its output to a variable, because we will be using it in the next step. By the way, the common ancestor commit is the &quot;Initial commit&quot; commit in this case. You can tell it by:</source>
          <target state="translated">Команда записывает имя объекта коммита общего предка в стандартный вывод,поэтому мы перехватили его вывод в переменную,так как будем использовать его в следующем шаге.Кстати,общий предковый коммит в данном случае является коммитом &quot;Начальный коммит&quot;.Об этом можно судить по:</target>
        </trans-unit>
        <trans-unit id="277f50b8984fb8f1e24e58a015e232c719b0136b" translate="yes" xml:space="preserve">
          <source>The command&amp;rsquo;s second form creates a new branch head named &amp;lt;branchname&amp;gt; which points to the current &lt;code&gt;HEAD&lt;/code&gt;, or &amp;lt;start-point&amp;gt; if given. As a special case, for &amp;lt;start-point&amp;gt;, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Вторая форма команды создает новый заголовок ветки с именем &amp;lt;branchname&amp;gt;, который указывает на текущий &lt;code&gt;HEAD&lt;/code&gt; или &amp;lt;start-point&amp;gt;, если он задан. В качестве особого случая для &amp;lt;start-point&amp;gt; вы можете использовать &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; в качестве ярлыка для базы слияния &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , если существует ровно одна база слияния. Вы можете пропустить не более одного из &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;B&lt;/code&gt; , и в этом случае по умолчанию используется &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0384db43c537c0cba33bbce02fa39c058435bd6c" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-from=&amp;lt;file&amp;gt; specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file.</source>
          <target state="translated">Флаг командной строки --exclude-from = &amp;lt;file&amp;gt; указывает файл, содержащий список шаблонов. Шаблоны упорядочены в том же порядке, в котором они появляются в файле.</target>
        </trans-unit>
        <trans-unit id="84de3c7a7b3ba54b91bb57a464ea60b526231897" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-per-directory=&amp;lt;name&amp;gt; specifies a name of the file in each directory &lt;code&gt;git ls-files&lt;/code&gt; examines, normally &lt;code&gt;.gitignore&lt;/code&gt;. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files.</source>
          <target state="translated">Флаг командной строки --exclude-per-directory = &amp;lt;name&amp;gt; указывает имя файла в каждом каталоге, который проверяет &lt;code&gt;git ls-files&lt;/code&gt; , обычно &lt;code&gt;.gitignore&lt;/code&gt; . Файлы в более глубоких каталогах имеют приоритет. Выкройки упорядочены в том же порядке, в котором они появляются в файлах.</target>
        </trans-unit>
        <trans-unit id="de25d36c95ea6a374c3001c57d5c8bbae6052f57" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude=&amp;lt;pattern&amp;gt; specifies a single pattern. Patterns are ordered in the same order they appear in the command line.</source>
          <target state="translated">Флаг командной строки --exclude = &amp;lt;pattern&amp;gt; задает один шаблон. Шаблоны упорядочены в том же порядке, в котором они появляются в командной строке.</target>
        </trans-unit>
        <trans-unit id="57163e2560363b464673a4a43dc95a7ad9f9ef3b" translate="yes" xml:space="preserve">
          <source>The commit &quot;D&quot; is called a &quot;merge base&quot; for branch &quot;main&quot; and &quot;dev&quot; because it&amp;rsquo;s the best common ancestor for these branches for a merge.</source>
          <target state="translated">Коммит &amp;laquo;D&amp;raquo; называется &amp;laquo;базой слияния&amp;raquo; для веток &amp;laquo;main&amp;raquo; и &amp;laquo;dev&amp;raquo;, потому что это лучший общий предок для этих веток для слияния.</target>
        </trans-unit>
        <trans-unit id="f185c14cbc82f3e4dae044b7f66a7608424887fa" translate="yes" xml:space="preserve">
          <source>The commit author name is taken from the &quot;From: &quot; line of the message, and commit author date is taken from the &quot;Date: &quot; line of the message. The &quot;Subject: &quot; line is used as the title of the commit, after stripping common prefix &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;. The &quot;Subject: &quot; line is supposed to concisely describe what the commit is about in one line of text.</source>
          <target state="translated">Имя автора фиксации берется из строки &amp;laquo;От:&amp;raquo; сообщения, а дата автора фиксации берется из строки &amp;laquo;Дата:&amp;raquo; сообщения. Строка &amp;laquo;Тема:&amp;raquo; используется в качестве заголовка коммита после удаления общего префикса &amp;laquo;[PATCH &amp;lt;anything&amp;gt;]&amp;raquo;. Строка &amp;laquo;Тема:&amp;raquo; должна кратко описывать, о чем идет речь, в одной строке текста.</target>
        </trans-unit>
        <trans-unit id="2f12acdb07fb960bc2fd1e07b27cc4a2b35ad054" translate="yes" xml:space="preserve">
          <source>The commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">Формат списка фиксации может быть изменён путём установки параметра конфигурации rebase.instructionFormat.Настроенный формат команды автоматически преобразует длинный хэш коммита в формат.</target>
        </trans-unit>
        <trans-unit id="56b4186deed0365516ca63a760921d1d85d5abd6" translate="yes" xml:space="preserve">
          <source>The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject.</source>
          <target state="translated">Сообщение журнала фиксации,извлечённое из электронной почты,обычно за исключением строки заголовка,которая приходит из темы письма.</target>
        </trans-unit>
        <trans-unit id="448543278984728d32d400e55fc12701ecc9668d" translate="yes" xml:space="preserve">
          <source>The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by i18n.commitencoding (defaulting to UTF-8) by transliterating them. This used to be optional but now it is the default.</source>
          <target state="translated">Сообщение журнала коммитов,имя автора и электронная почта автора берутся из письма,и после минимального декодирования MIME-кодировки передачи,перекодируются в кодовую таблицу,указанную i18n.commitencoding (по умолчанию в UTF-8)путём их транслитерации.Раньше это было необязательно,но теперь по умолчанию.</target>
        </trans-unit>
        <trans-unit id="682ec5a16062666d3ac4c15995f4c320f0569ce3" translate="yes" xml:space="preserve">
          <source>The commit message is formed by the title taken from the &quot;Subject: &quot;, a blank line and the body of the message up to where the patch begins. Excess whitespace at the end of each line is automatically stripped.</source>
          <target state="translated">Сообщение о фиксации формируется по заголовку,взятому из &quot;Тема&quot;:&quot;пустой строкой и телом сообщения до того места,где начинается заплатка.Излишние пробелы в конце каждой строки автоматически удаляются.</target>
        </trans-unit>
        <trans-unit id="9d14a63335261988fcede52b815289c8a87983a5" translate="yes" xml:space="preserve">
          <source>The commit message is supplied either directly with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option, or indirectly from the tag or commit when the second tree-ish denotes such an object, or it is requested by invoking an editor (see &lt;code&gt;--edit&lt;/code&gt; option below).</source>
          <target state="translated">Сообщение о фиксации предоставляется либо напрямую с параметром &lt;code&gt;-m&lt;/code&gt; или &lt;code&gt;-F&lt;/code&gt; , либо косвенно из тега или фиксации, когда второе древовидное обозначение обозначает такой объект, или оно запрашивается путем вызова редактора (см. &lt;code&gt;--edit&lt;/code&gt; ниже) ,</target>
        </trans-unit>
        <trans-unit id="50413d61f19e8e0d39eb4098c01c599c7c407f25" translate="yes" xml:space="preserve">
          <source>The commit object names shown above would be different for you, but they should match the HEAD commit object names of your repositories. You can check it by running &lt;code&gt;git ls-remote ../a&lt;/code&gt;.</source>
          <target state="translated">Имена объектов фиксации, показанные выше, будут для вас другими, но они должны совпадать с именами объектов фиксации HEAD ваших репозиториев. Вы можете проверить это, запустив &lt;code&gt;git ls-remote ../a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b7bb35b4ae403135d95400938252724b91ca0d2" translate="yes" xml:space="preserve">
          <source>The commit objects record the encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in &lt;code&gt;X&lt;/code&gt; and we are outputting in &lt;code&gt;X&lt;/code&gt;, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output.</source>
          <target state="translated">Объекты фиксации записывают кодировку, используемую для сообщения журнала, в их заголовке кодировки; эту опцию можно использовать, чтобы указать команде, что нужно перекодировать сообщение журнала фиксации в кодировке, предпочитаемой пользователем. Для команд, не связанных с сантехникой, по умолчанию используется UTF-8. Обратите внимание: если объект утверждает, что он закодирован в &lt;code&gt;X&lt;/code&gt; , а мы выводим в &lt;code&gt;X&lt;/code&gt; , мы выведем объект дословно; это означает, что недопустимые последовательности в исходной фиксации могут быть скопированы в вывод.</target>
        </trans-unit>
        <trans-unit id="8a40378090f508382eab3e21e0b4382b3bab0ad4" translate="yes" xml:space="preserve">
          <source>The commit, equivalent to what other systems call a &quot;changeset&quot; or &quot;version&quot;, represents a step in the project&amp;rsquo;s history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development.</source>
          <target state="translated">Фиксация, эквивалентная тому, что другие системы называют &amp;laquo;набором изменений&amp;raquo; или &amp;laquo;версией&amp;raquo;, представляет собой шаг в истории проекта, а каждый родительский элемент представляет собой непосредственно предшествующий шаг. Коммиты с более чем одним родителем представляют собой слияние независимых направлений развития.</target>
        </trans-unit>
        <trans-unit id="7d3d64efc4f4511458592fa6c8a58dcfb8579da7" translate="yes" xml:space="preserve">
          <source>The commits are guaranteed to be listed in the order that they were processed by rebase.</source>
          <target state="translated">Гарантируется,что коммиты будут перечислены в том порядке,в котором они были обработаны rebase.</target>
        </trans-unit>
        <trans-unit id="00a94582df69c83885533dbdc944c957c3a549e0" translate="yes" xml:space="preserve">
          <source>The commits marked with &lt;code&gt;*&lt;/code&gt; touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with &lt;code&gt;+&lt;/code&gt;. Then you can test the result to make sure your work-in-progress still works with what is in the latest master.</source>
          <target state="translated">Коммиты, отмеченные &lt;code&gt;*&lt;/code&gt; , касаются одной и той же области в том же файле; вам необходимо разрешить конфликты при создании коммита, отмеченного знаком &lt;code&gt;+&lt;/code&gt; . Затем вы можете протестировать результат, чтобы убедиться, что ваша незавершенная работа по-прежнему работает с тем, что есть в последней версии мастера.</target>
        </trans-unit>
        <trans-unit id="a3fd88845d0ae86224cb7a800b3122f1cf56cb03" translate="yes" xml:space="preserve">
          <source>The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..&amp;lt;upstream&amp;gt; are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).</source>
          <target state="translated">Коммиты, которые были ранее сохранены во временной области, затем повторно применяются к текущей ветке, один за другим, по порядку. Обратите внимание, что любые коммиты в HEAD, которые вводят те же текстовые изменения, что и фиксация в HEAD .. &amp;lt;upstream&amp;gt;, опускаются (т. Е. Патч, уже принятый восходящим потоком с другим сообщением фиксации или меткой времени, будет пропущен).</target>
        </trans-unit>
        <trans-unit id="18d247bf08e46b2d89a403ce14a86d7b99503646" translate="yes" xml:space="preserve">
          <source>The complete message in a commit and tag object is &lt;code&gt;contents&lt;/code&gt;. Its first line is &lt;code&gt;contents:subject&lt;/code&gt;, where subject is the concatenation of all lines of the commit message up to the first blank line. The next line is &lt;code&gt;contents:body&lt;/code&gt;, where body is all of the lines after the first blank line. The optional GPG signature is &lt;code&gt;contents:signature&lt;/code&gt;. The first &lt;code&gt;N&lt;/code&gt; lines of the message is obtained using &lt;code&gt;contents:lines=N&lt;/code&gt;. Additionally, the trailers as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt; are obtained as &lt;code&gt;trailers&lt;/code&gt; (or by using the historical alias &lt;code&gt;contents:trailers&lt;/code&gt;). Non-trailer lines from the trailer block can be omitted with &lt;code&gt;trailers:only&lt;/code&gt;. Whitespace-continuations can be removed from trailers so that each trailer appears on a line by itself with its full content with &lt;code&gt;trailers:unfold&lt;/code&gt;. Both can be used together as &lt;code&gt;trailers:unfold,only&lt;/code&gt;.</source>
          <target state="translated">Полное сообщение в объекте фиксации и тега - это &lt;code&gt;contents&lt;/code&gt; . Его первая строка - это &lt;code&gt;contents:subject&lt;/code&gt; , где тема - это объединение всех строк сообщения фиксации до первой пустой строки. Следующая строка - &lt;code&gt;contents:body&lt;/code&gt; , где body - все строки после первой пустой строки. Необязательная подпись GPG - это &lt;code&gt;contents:signature&lt;/code&gt; . Первые &lt;code&gt;N&lt;/code&gt; строка сообщений получают , используя &lt;code&gt;contents:lines=N&lt;/code&gt; . Кроме того, трейлеры, интерпретируемые &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interp-trailers [1]&lt;/a&gt; , получаются как &lt;code&gt;trailers&lt;/code&gt; (или с использованием исторического псевдонима &lt;code&gt;contents:trailers&lt;/code&gt; ). Линии без прицепа от блока прицепа можно не устанавливать с &lt;code&gt;trailers:only&lt;/code&gt; . Пробелы-продолжения могут быть удалены из трейлеров, чтобы каждый трейлер появлялся в отдельной строке со своим полным содержанием с &lt;code&gt;trailers:unfold&lt;/code&gt; . Оба могут использоваться вместе как &lt;code&gt;trailers:unfold,only&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cfefd9783776d68186cc88921bf5543257f8ee9" translate="yes" xml:space="preserve">
          <source>The complete series produces the same end result as your own (probably much messier!) development process did.</source>
          <target state="translated">Полная серия дает тот же конечный результат,что и ваша собственная (возможно,гораздо более запутанная!)разработка.</target>
        </trans-unit>
        <trans-unit id="94ed81b46eb91e159691e77d6f1f3c669ea0f93b" translate="yes" xml:space="preserve">
          <source>The condition starts with a keyword followed by a colon and some data whose format and meaning depends on the keyword. Supported keywords are:</source>
          <target state="translated">Условие начинается с ключевого слова,за которым следует двоеточие и некоторые данные,формат и значение которых зависит от ключевого слова.Поддерживаются ключевые слова:</target>
        </trans-unit>
        <trans-unit id="b796e8b15faa41177d638a7b320c951a662a1b91" translate="yes" xml:space="preserve">
          <source>The config settings that start with &lt;code&gt;feature.&lt;/code&gt; modify the defaults of a group of other config settings. These groups are created by the Git developer community as recommended defaults and are subject to change. In particular, new config options may be added with different defaults.</source>
          <target state="translated">Параметры конфигурации, которые начинаются с &lt;code&gt;feature.&lt;/code&gt; изменить значения по умолчанию для группы других параметров конфигурации. Эти группы создаются сообществом разработчиков Git как рекомендуемые значения по умолчанию и могут быть изменены. В частности, могут быть добавлены новые параметры конфигурации с другими значениями по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0fd18e355006d4a8cb0ab9547d6ae9db29a772ac" translate="yes" xml:space="preserve">
          <source>The config variable &lt;code&gt;ssh.variant&lt;/code&gt; can be set to override this detection. Valid values are &lt;code&gt;ssh&lt;/code&gt; (to use OpenSSH options), &lt;code&gt;plink&lt;/code&gt;, &lt;code&gt;putty&lt;/code&gt;, &lt;code&gt;tortoiseplink&lt;/code&gt;, &lt;code&gt;simple&lt;/code&gt; (no options except the host and remote command). The default auto-detection can be explicitly requested using the value &lt;code&gt;auto&lt;/code&gt;. Any other value is treated as &lt;code&gt;ssh&lt;/code&gt;. This setting can also be overridden via the environment variable &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt;.</source>
          <target state="translated">Переменная конфигурации &lt;code&gt;ssh.variant&lt;/code&gt; может быть установлена ​​для отмены этого обнаружения. Допустимые значения: &lt;code&gt;ssh&lt;/code&gt; (для использования параметров OpenSSH), &lt;code&gt;plink&lt;/code&gt; , &lt;code&gt;putty&lt;/code&gt; , &lt;code&gt;tortoiseplink&lt;/code&gt; , &lt;code&gt;simple&lt;/code&gt; (без параметров, кроме команды host и remote). Автоопределение по умолчанию можно явно запросить с помощью значения &lt;code&gt;auto&lt;/code&gt; . Любое другое значение рассматривается как &lt;code&gt;ssh&lt;/code&gt; . Этот параметр также можно переопределить с помощью переменной среды &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82dcb1f42fdd78b7a73229a297c6923dd8af63df" translate="yes" xml:space="preserve">
          <source>The configuration file &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the superproject. Git only recurses into active submodules (see &quot;ACTIVE SUBMODULES&quot; section below).</source>
          <target state="translated">Конфигурационный файл &lt;code&gt;$GIT_DIR/config&lt;/code&gt; в суперпроекте. Git рекурсирует только в активные подмодули (см. Ниже раздел &amp;laquo;АКТИВНЫЕ ПОДМОДУЛИ&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="774734ca6d9570e50bffe1b21770dfa34405f67a" translate="yes" xml:space="preserve">
          <source>The configuration file is used to override the default settings that were built into gitweb at the time the &lt;code&gt;gitweb.cgi&lt;/code&gt; script was generated.</source>
          <target state="translated">Файл конфигурации используется для переопределения настроек по умолчанию, которые были встроены в gitweb во время &lt;code&gt;gitweb.cgi&lt;/code&gt; скрипта gitweb.cgi .</target>
        </trans-unit>
        <trans-unit id="b47107ae705aecdb184ade3561dff30a01436bf4" translate="yes" xml:space="preserve">
          <source>The configuration inside the submodule. This includes &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the submodule, but also settings in the tree such as a &lt;code&gt;.gitattributes&lt;/code&gt; or &lt;code&gt;.gitignore&lt;/code&gt; files that specify behavior of commands inside the submodule.</source>
          <target state="translated">Конфигурация внутри подмодуля. Это включает в себя &lt;code&gt;$GIT_DIR/config&lt;/code&gt; в подмодуле, а также настройки в дереве, такие как файлы &lt;code&gt;.gitattributes&lt;/code&gt; или &lt;code&gt;.gitignore&lt;/code&gt; , которые определяют поведение команд внутри подмодуля.</target>
        </trans-unit>
        <trans-unit id="9f6d6d393008f1bcb3935ac97c688c0c97bcd837" translate="yes" xml:space="preserve">
          <source>The configuration of submodules</source>
          <target state="translated">Конфигурация субмодулей</target>
        </trans-unit>
        <trans-unit id="386a88f6456b2a92a88834767dd0b8e7846f5609" translate="yes" xml:space="preserve">
          <source>The configuration variables &lt;code&gt;$projects_list_group_categories&lt;/code&gt; and &lt;code&gt;$project_list_default_category&lt;/code&gt; are described in &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;</source>
          <target state="translated">Переменные конфигурации &lt;code&gt;$projects_list_group_categories&lt;/code&gt; и &lt;code&gt;$project_list_default_category&lt;/code&gt; описаны в &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7bf08d06e6b6627f964eab6068d66314f0702240" translate="yes" xml:space="preserve">
          <source>The configuration variables are used by both the Git plumbing and the porcelains. The variables are divided into sections, wherein the fully qualified variable name of the variable itself is the last dot-separated segment and the section name is everything before the last dot. The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character. Some variables may appear multiple times; we say then that the variable is multivalued.</source>
          <target state="translated">Переменные конфигурации используются и сантехникой Git, и фарфором. Переменные разделены на разделы, при этом полное имя переменной самой переменной является последним сегментом, разделенным точками, а имя раздела - это все, что находится до последней точки. Имена переменных не чувствительны к регистру, допускают использование только буквенно-цифровых символов и &lt;code&gt;-&lt;/code&gt; и должны начинаться с алфавитного символа. Некоторые переменные могут появляться несколько раз; мы говорим тогда, что переменная многозначна.</target>
        </trans-unit>
        <trans-unit id="9ba005fddfd40c1aca4a3afcc24f0bfe0be0d141" translate="yes" xml:space="preserve">
          <source>The configuration variables described below configure some of gitweb links: their target and their look (text or image), and where to find page prerequisites (stylesheet, favicon, images, scripts). Usually they are left at their default values, with the possible exception of &lt;code&gt;@stylesheets&lt;/code&gt; variable.</source>
          <target state="translated">Переменные конфигурации, описанные ниже, настраивают некоторые ссылки gitweb: их цель и внешний вид (текст или изображение), а также где найти предварительные требования к странице (таблица стилей, значок, изображения, сценарии). Обычно они оставляют значения по умолчанию, за возможным исключением переменной &lt;code&gt;@stylesheets&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="352cabf788111a2af3c96521f974380812252a38" translate="yes" xml:space="preserve">
          <source>The configuration variables described below control how gitweb finds Git repositories, and how repositories are displayed and accessed.</source>
          <target state="translated">Переменные конфигурации,описанные ниже,управляют тем,как gitweb находит Git-репозитории,а также тем,как репозитории отображаются и к каким репозиториям осуществляется доступ.</target>
        </trans-unit>
        <trans-unit id="3f43fd6b4f50ff73ead39001e9e7b24eaf91129d" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; means the &amp;lt;n&amp;gt;th branch/commit checked out before the current one.</source>
          <target state="translated">Конструкция &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; означает, что &amp;lt;n&amp;gt; -я ветвь / фиксация извлечена перед текущей.</target>
        </trans-unit>
        <trans-unit id="532c17d263ea0447251201d507a716aaf6f28f2e" translate="yes" xml:space="preserve">
          <source>The content to be committed can be specified in several ways:</source>
          <target state="translated">Контент,который будет зафиксирован,может быть указан несколькими способами:</target>
        </trans-unit>
        <trans-unit id="a3c1db69a05b050bddfd156a5df9e51b55df4af8" translate="yes" xml:space="preserve">
          <source>The contents of the actual line is output after the above header, prefixed by a TAB. This is to allow adding more header elements later.</source>
          <target state="translated">Содержимое фактической строки выводится после приведенного выше заголовка с префиксом TAB.Это позволяет добавлять больше элементов заголовка позже.</target>
        </trans-unit>
        <trans-unit id="07ff8c430a66890255703acd59c46fb9590b9dc8" translate="yes" xml:space="preserve">
          <source>The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.</source>
          <target state="translated">Содержимое объектов блоба-это неинтерпретированные последовательности байтов.На уровне ядра отсутствует трансляция кодировок.</target>
        </trans-unit>
        <trans-unit id="1b5efb2fc6b2c2f5d21112887ebec33fa1322cd1" translate="yes" xml:space="preserve">
          <source>The contents of the included file are inserted immediately, as if they had been found at the location of the include directive. If the value of the variable is a relative path, the path is considered to be relative to the configuration file in which the include directive was found. See below for examples.</source>
          <target state="translated">Содержимое включенного файла вставляется немедленно,как если бы он был найден в месте расположения директивы include.Если значение переменной является относительным путем,то этот путь считается относительным к конфигурационному файлу,в котором была найдена директива include.Примеры см.ниже.</target>
        </trans-unit>
        <trans-unit id="8e2acace54c1bc95e05b068c1615156bf7369b0d" translate="yes" xml:space="preserve">
          <source>The core Git is often called &quot;plumbing&quot;, with the prettier user interfaces on top of it called &quot;porcelain&quot;. You may not want to use the plumbing directly very often, but it can be good to know what the plumbing does when the porcelain isn&amp;rsquo;t flushing.</source>
          <target state="translated">Ядро Git часто называют &amp;laquo;сантехническим&amp;raquo;, а более красивые пользовательские интерфейсы поверх него - &amp;laquo;фарфором&amp;raquo;. Возможно, вы не захотите очень часто пользоваться водопроводом напрямую, но будет полезно знать, что делает водопровод, когда фарфор не смывается.</target>
        </trans-unit>
        <trans-unit id="bdff9728a51893f686262a6a471251953f8ca49c" translate="yes" xml:space="preserve">
          <source>The core.multiPackIndex config setting must be on to consume MIDX files.</source>
          <target state="translated">Настройка конфигурации core.multiPackIndex должна быть включена для использования MIDX-файлов.</target>
        </trans-unit>
        <trans-unit id="4fd34d18ba310e6b91e875c3fcf517fe13b68829" translate="yes" xml:space="preserve">
          <source>The cost matrix is populated thusly: for each pair of commits, both diffs are generated and the &quot;diff of diffs&quot; is generated, with 3 context lines, then the number of lines in that diff is used as cost.</source>
          <target state="translated">Матрица стоимости заполняется таким образом:для каждой пары коммитов генерируются как diff,так и &quot;diff of diffs&quot;,с 3-мя строками контекста,затем в качестве стоимости используется количество строк в этом диффузоре.</target>
        </trans-unit>
        <trans-unit id="588bd7a488f6b8b596aae7dca46a3809b4412eb0" translate="yes" xml:space="preserve">
          <source>The cost of an edge &lt;code&gt;o--C&lt;/code&gt; is the size of &lt;code&gt;C&lt;/code&gt;'s diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge &lt;code&gt;o--o&lt;/code&gt; is free. The fudge factor is necessary because even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common, they may still share a few empty lines and such, possibly making the assignment &lt;code&gt;1--C&lt;/code&gt;, &lt;code&gt;o--o&lt;/code&gt; slightly cheaper than &lt;code&gt;1--o&lt;/code&gt;, &lt;code&gt;o--C&lt;/code&gt; even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding.</source>
          <target state="translated">Стоимость ребра &lt;code&gt;o--C&lt;/code&gt; - это размер разницы &lt;code&gt;C&lt;/code&gt; , измененный с учетом коэффициента подделки, который должен быть меньше 100%. Стоимость лезвия &lt;code&gt;o--o&lt;/code&gt; бесплатно. Фактор выдумки необходим, потому что даже если &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; не имеют ничего общего, они все равно могут использовать несколько пустых строк и тому подобное, что, возможно, делает присвоение &lt;code&gt;1--C&lt;/code&gt; , &lt;code&gt;o--o&lt;/code&gt; немного дешевле, чем &lt;code&gt;1--o&lt;/code&gt; , &lt;code&gt;o--C&lt;/code&gt; , даже если &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;C&lt;/code&gt; не имеют ничего общего. С фактором фаджа нам требуется гораздо большая общая часть, чтобы патчи считались соответствующими.</target>
        </trans-unit>
        <trans-unit id="1995b336f91a29b5d0cf1cb6bf6d7c2407fa802c" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline. The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL. In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file. Git understands the following attributes:</source>
          <target state="translated">Учетные данные разделены на набор именованных атрибутов, по одному атрибуту в каждой строке. Каждый атрибут определяется парой &quot;ключ-значение&quot;, разделенной знаком &lt;code&gt;=&lt;/code&gt; (равно), за которым следует новая строка. Ключ может содержать любые байты, кроме &lt;code&gt;=&lt;/code&gt; , новой строки или NUL. Значение может содержать любые байты, кроме новой строки или NUL. В обоих случаях все байты обрабатываются как есть (т. Е. Нет кавычек, и нельзя передавать значение с новой строкой или NUL в нем). Список атрибутов заканчивается пустой строкой или концом файла. Git понимает следующие атрибуты:</target>
        </trans-unit>
        <trans-unit id="332163de0b53725f6a8fdbb5dfbee2d72f5e952f" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s password, if we are asking it to be stored.</source>
          <target state="translated">Пароль учетных данных, если мы просим его сохранить.</target>
        </trans-unit>
        <trans-unit id="b2af82f2f4002bb109eae365a3025f169b56089c" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, from the user, or from a previously run helper).</source>
          <target state="translated">Имя пользователя для учетных данных, если оно у нас уже есть (например, из URL-адреса, от пользователя или от ранее запущенного помощника).</target>
        </trans-unit>
        <trans-unit id="327d8af868005c380ff04a569542ec1ad381deca" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. In more detail: Your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; in your repository, except when using a &lt;a href=&quot;#def_detached_HEAD&quot;&gt;detached HEAD&lt;/a&gt;, in which case it directly references an arbitrary commit.</source>
          <target state="translated">Текущая &lt;a href=&quot;#def_branch&quot;&gt;ветка&lt;/a&gt; . Более подробно: ваше &lt;a href=&quot;#def_working_tree&quot;&gt;рабочее дерево&lt;/a&gt; обычно выводится из состояния дерева, на которое ссылается HEAD. HEAD - это ссылка на одну из &lt;a href=&quot;#def_head&quot;&gt;голов&lt;/a&gt; в вашем репозитории, за исключением случаев использования &lt;a href=&quot;#def_detached_HEAD&quot;&gt;отдельной HEAD&lt;/a&gt; , когда она напрямую ссылается на произвольную фиксацию.</target>
        </trans-unit>
        <trans-unit id="6a22129f9e2c1c598b41ac7718060a19c57ba2df" translate="yes" xml:space="preserve">
          <source>The current branch and &lt;code&gt;HEAD&lt;/code&gt; pointer stay at the last commit successfully made.</source>
          <target state="translated">Текущая ветвь и указатель &lt;code&gt;HEAD&lt;/code&gt; остаются на последней успешно выполненной фиксации.</target>
        </trans-unit>
        <trans-unit id="0f49d1c21e2564ca60f22933641a619ec1965bd6" translate="yes" xml:space="preserve">
          <source>The current branch is reset to &amp;lt;upstream&amp;gt;, or &amp;lt;newbase&amp;gt; if the --onto option was supplied. This has the exact same effect as &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (or &amp;lt;newbase&amp;gt;). ORIG_HEAD is set to point at the tip of the branch before the reset.</source>
          <target state="translated">Текущая ветвь сбрасывается на &amp;lt;upstream&amp;gt; или &amp;lt;newbase&amp;gt;, если была указана опция --onto. Это имеет тот же эффект, что и &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (или &amp;lt;newbase&amp;gt;). ORIG_HEAD устанавливается так, чтобы указывать на конец ветви перед сбросом.</target>
        </trans-unit>
        <trans-unit id="485fe33a04a6d00e71aec5bce139a108011107ac" translate="yes" xml:space="preserve">
          <source>The current command-line parameters used for each variant are as follows:</source>
          <target state="translated">Текущие параметры командной строки,используемые для каждого варианта,следующие:</target>
        </trans-unit>
        <trans-unit id="f1d20a076d93bfe14eb345a4d54fe76b72904bc4" translate="yes" xml:space="preserve">
          <source>The current index and work tree is derived from $H, but the user may have local changes in them since $H.</source>
          <target state="translated">Текущий индекс и дерево работы получены из $H,но у пользователя могут быть локальные изменения с $H.</target>
        </trans-unit>
        <trans-unit id="7bc299cda3bedfdcbabc4a6883d29c81bf74d5df" translate="yes" xml:space="preserve">
          <source>The current index file for the repository. It is usually not found in a bare repository.</source>
          <target state="translated">Текущий файл индекса для репозитория.Обычно он не встречается в &quot;голом&quot; репозитории.</target>
        </trans-unit>
        <trans-unit id="6561295b83003ebae9a9c6ca19e06cdfe7bf9b70" translate="yes" xml:space="preserve">
          <source>The currently defined format versions are:</source>
          <target state="translated">В настоящее время определены версии формата:</target>
        </trans-unit>
        <trans-unit id="66a8472981ef80b1cce56bd59cf5f4d97c11f9f9" translate="yes" xml:space="preserve">
          <source>The currently supported hooks are described below.</source>
          <target state="translated">Ниже описаны поддерживаемые в настоящее время крючки.</target>
        </trans-unit>
        <trans-unit id="8715361e5840de7b556e67eacf990927a206b328" translate="yes" xml:space="preserve">
          <source>The custom diff driver command. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Пользовательская команда драйвера diff. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e530b24daf8e53e45f57000d6a6174670a1f6d2" translate="yes" xml:space="preserve">
          <source>The data content for the file has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">Содержание данных для файла еще не было предоставлено.Фронтенд хочет предоставить его как часть этой команды изменения.</target>
        </trans-unit>
        <trans-unit id="f92713104ec45ad60b839fa902e6ffedd1e05a41" translate="yes" xml:space="preserve">
          <source>The data content for the file was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it.</source>
          <target state="translated">Содержимое данных для файла уже было предоставлено предыдущей командой &lt;code&gt;blob&lt;/code&gt; . Веб-интерфейсу просто нужно его подключить.</target>
        </trans-unit>
        <trans-unit id="abeb69d3d4bae2cc1a5a16e58850f1c93c17369b" translate="yes" xml:space="preserve">
          <source>The data content for the note has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">Содержание данных для примечания еще не было предоставлено.Фронтенд хочет предоставить его как часть этой команды изменения.</target>
        </trans-unit>
        <trans-unit id="81c47d0a0bfa5328ac109608aa42a36ac0ca6a45" translate="yes" xml:space="preserve">
          <source>The data content for the note was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it to the commit that is to be annotated.</source>
          <target state="translated">Содержимое данных для заметки уже было предоставлено предыдущей командой &lt;code&gt;blob&lt;/code&gt; . Веб-интерфейсу просто нужно связать его с коммитом, который нужно аннотировать.</target>
        </trans-unit>
        <trans-unit id="d1c68865b9a230a071410342b903f7a0e48271ba" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;gitdir:&lt;/code&gt; is used as a glob pattern. If the location of the .git directory matches the pattern, the include condition is met.</source>
          <target state="translated">Данные, следующие за ключевым словом &lt;code&gt;gitdir:&lt;/code&gt; , используются как шаблон глобуса . Если расположение каталога .git соответствует шаблону, условие включения выполняется.</target>
        </trans-unit>
        <trans-unit id="c1597312d460a92e79d09c37c305ec85acdf7d09" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;onbranch:&lt;/code&gt; is taken to be a pattern with standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. If we are in a worktree where the name of the branch that is currently checked out matches the pattern, the include condition is met.</source>
          <target state="translated">Данные, следующие за ключевым словом &lt;code&gt;onbranch:&lt;/code&gt; , считаются шаблоном со стандартными подстановочными знаками подстановки и двумя дополнительными, &lt;code&gt;**/&lt;/code&gt; и &lt;code&gt;/**&lt;/code&gt; , которые могут соответствовать нескольким компонентам пути. Если мы находимся в рабочем дереве, где имя ветви, которая в настоящее время извлечена, соответствует шаблону, условие включения выполняется.</target>
        </trans-unit>
        <trans-unit id="7c053d7b296d35ca64db938819dea858103dc6da" translate="yes" xml:space="preserve">
          <source>The data transfer of the packfile is always multiplexed, using the same semantics of the &lt;code&gt;side-band-64k&lt;/code&gt; capability from protocol version 1. This means that each packet, during the packfile data stream, is made up of a leading 4-byte pkt-line length (typical of the pkt-line format), followed by a 1-byte stream code, followed by the actual data.</source>
          <target state="translated">Передача данных пакетного файла всегда мультиплексируется с использованием той же семантики, что и возможности &lt;code&gt;side-band-64k&lt;/code&gt; из версии протокола 1. Это означает, что каждый пакет во время потока данных пакетного файла состоит из ведущего 4-байтового пакета. длина строки (типичная для формата pkt-line), за которой следует 1-байтовый код потока, за которым следуют фактические данные.</target>
        </trans-unit>
        <trans-unit id="c2900c14cd751c2ba06b33eb8d53cbdb905b94a4" translate="yes" xml:space="preserve">
          <source>The database cannot be reliably regenerated in a consistent form after the branch it is tracking has changed. Example: For merged branches, &lt;code&gt;git-cvsserver&lt;/code&gt; only tracks one branch of development, and after a &lt;code&gt;git merge&lt;/code&gt; an incrementally updated database may track a different branch than a database regenerated from scratch, causing inconsistent CVS revision numbers. &lt;code&gt;git-cvsserver&lt;/code&gt; has no way of knowing which branch it would have picked if it had been run incrementally pre-merge. So if you have to fully or partially (from old backup) regenerate the database, you should be suspicious of pre-existing CVS sandboxes.</source>
          <target state="translated">База данных не может быть надежно восстановлена ​​в согласованной форме после изменения ветви, которую она отслеживает. Пример: для объединенных ветвей &lt;code&gt;git-cvsserver&lt;/code&gt; отслеживает только одну ветвь разработки, а после &lt;code&gt;git merge&lt;/code&gt; постепенно обновляемая база данных может отслеживать другую ветку, чем база данных, регенерированная с нуля, что приводит к несогласованным номерам ревизий CVS. &lt;code&gt;git-cvsserver&lt;/code&gt; не имеет возможности узнать, какую ветку он выбрал бы, если бы запускался постепенно перед слиянием. Поэтому, если вам нужно полностью или частично (из старой резервной копии) регенерировать базу данных, вы должны с подозрением относиться к уже существующим песочницам CVS.</target>
        </trans-unit>
        <trans-unit id="44d2a77b29a1133933d2693560e181324cc0bf34" translate="yes" xml:space="preserve">
          <source>The database has an object whose hash doesn&amp;rsquo;t match the object database value. This indicates a serious data integrity problem.</source>
          <target state="translated">В базе данных есть объект, хэш которого не соответствует значению базы данных объектов. Это указывает на серьезную проблему целостности данных.</target>
        </trans-unit>
        <trans-unit id="28234e35fb4524e90d740d3154dc66c02cb1f7a2" translate="yes" xml:space="preserve">
          <source>The default &amp;lt;ref&amp;gt; is &quot;master&quot;.</source>
          <target state="translated">По умолчанию &amp;lt;ref&amp;gt; - &quot;master&quot;.</target>
        </trans-unit>
        <trans-unit id="c033f0ddddff0b7a496ef058316bfe1c29b59dcb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of 'A' is 'origin/B' sometimes we say &quot;'A' is tracking 'origin/B'&quot;.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;Ветвь по&lt;/a&gt; умолчанию, которая объединяется с рассматриваемой ветвью (или ветвь, о которой идет речь, перебазируется на). Он настраивается через branch. &amp;lt;name&amp;gt; .remote и branch. &amp;lt;name&amp;gt; .merge. Если восходящей ветвью 'A' является 'origin / B', иногда мы говорим: &amp;laquo;'A' отслеживает 'origin / B'&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0e2c938aad423666052c9b862a31c7bd282b15cb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;origin/B&lt;/code&gt; sometimes we say &quot;&lt;code&gt;A&lt;/code&gt; is tracking &lt;code&gt;origin/B&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;Ветвь по&lt;/a&gt; умолчанию, которая объединяется с рассматриваемой ветвью (или ветвь, о которой идет речь, перебазируется на). Он настраивается через branch. &amp;lt;name&amp;gt; .remote и branch. &amp;lt;name&amp;gt; .merge. Если восходящей ветвью &lt;code&gt;A&lt;/code&gt; является &lt;code&gt;origin/B&lt;/code&gt; , иногда мы говорим: &amp;laquo; &lt;code&gt;A&lt;/code&gt; отслеживает &lt;code&gt;origin/B&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2a57474834373f0012a2eee4dc03542456f6b683" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;applypatch-msg&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;commit-msg&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">&lt;code&gt;applypatch-msg&lt;/code&gt; умолчанию , если он включен, запускает перехватчик &lt;code&gt;commit-msg&lt;/code&gt; , если последний включен.</target>
        </trans-unit>
        <trans-unit id="1004092b458b148233da1997202a081689268a8e" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;commit-msg&lt;/code&gt; hook, when enabled, detects duplicate &quot;Signed-off-by&quot; lines, and aborts the commit if one is found.</source>
          <target state="translated">Перехватчик &lt;code&gt;commit-msg&lt;/code&gt; по умолчанию , когда он включен, обнаруживает повторяющиеся строки &amp;laquo;Signed-off-by&amp;raquo; и прерывает фиксацию, если таковая обнаружена.</target>
        </trans-unit>
        <trans-unit id="54e7a2ab7a7ead4c100931e31ff4408636c3868d" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;post-receive&lt;/code&gt; hook is empty, but there is a sample script &lt;code&gt;post-receive-email&lt;/code&gt; provided in the &lt;code&gt;contrib/hooks&lt;/code&gt; directory in Git distribution, which implements sending commit emails.</source>
          <target state="translated">По умолчанию &lt;code&gt;post-receive&lt;/code&gt; крючок пуст, но есть пример сценарий &lt;code&gt;post-receive-email&lt;/code&gt; предоставляется в &lt;code&gt;contrib/hooks&lt;/code&gt; каталог в распределении Гита, который реализует отправку писем фиксации.</target>
        </trans-unit>
        <trans-unit id="a71e842d9eb90ca6731ba585809c1f8c19eb80f6" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-applypatch&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">&lt;code&gt;pre-applypatch&lt;/code&gt; умолчанию , если он включен, запускает перехватчик &lt;code&gt;pre-commit&lt;/code&gt; , если последний включен.</target>
        </trans-unit>
        <trans-unit id="b4266565542333c335464dc9285134a4a9b31011" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled&amp;mdash;​and with the &lt;code&gt;hooks.allownonascii&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents the use of non-ASCII filenames.</source>
          <target state="translated">Хук &lt;code&gt;pre-commit&lt;/code&gt; умолчанию , если он включен - и если для &lt;code&gt;hooks.allownonascii&lt;/code&gt; конфигурации hooks.allownonascii не задано значение или установлено значение false - предотвращается использование имен файлов, отличных от ASCII.</target>
        </trans-unit>
        <trans-unit id="c591fe93d0021a0c7991225b1a062c31f35ddd16" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled, catches introduction of lines with trailing whitespaces and aborts the commit when such a line is found.</source>
          <target state="translated">Хук &lt;code&gt;pre-commit&lt;/code&gt; умолчанию , когда он включен, улавливает введение строк с завершающими пробелами и прерывает фиксацию, когда такая строка обнаруживается.</target>
        </trans-unit>
        <trans-unit id="5c24125124251d23fec260bbe8f20bf4ce1ae496" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-merge-commit&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">Перехватчик &lt;code&gt;pre-merge-commit&lt;/code&gt; по умолчанию , если он включен, запускает ловушку &lt;code&gt;pre-commit&lt;/code&gt; , если последний включен.</target>
        </trans-unit>
        <trans-unit id="c0f0841a2790ebd8e4684a32dafde265e2735139" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;update&lt;/code&gt; hook, when enabled&amp;mdash;​and with &lt;code&gt;hooks.allowunannotated&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents unannotated tags to be pushed.</source>
          <target state="translated">Перехватчик &lt;code&gt;update&lt;/code&gt; умолчанию , если он включен - и &lt;code&gt;hooks.allowunannotated&lt;/code&gt; опция конфигурации hooks.allowunannotated не задана или установлена ​​на false - предотвращает отправку неаннотированных тегов.</target>
        </trans-unit>
        <trans-unit id="e99caaee535fa5770d85355802dd91eb002c650f" translate="yes" xml:space="preserve">
          <source>The default behavior of this command when no &amp;lt;refspec&amp;gt; is given can be configured by setting the &lt;code&gt;push&lt;/code&gt; option of the remote, or the &lt;code&gt;push.default&lt;/code&gt; configuration variable.</source>
          <target state="translated">Поведение этой команды по умолчанию, когда не указан &amp;lt;refspec&amp;gt;, можно настроить, установив опцию &lt;code&gt;push&lt;/code&gt; на пульте дистанционного управления или переменную конфигурации &lt;code&gt;push.default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04fb2222b71daf513a74198926f20b6eb1c65e53" translate="yes" xml:space="preserve">
          <source>The default can be changed by the &lt;code&gt;commit.cleanup&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Значение по умолчанию можно изменить с помощью переменной конфигурации &lt;code&gt;commit.cleanup&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d2b951210087bf6a12979c879cea7654da192ce" translate="yes" xml:space="preserve">
          <source>The default can be changed using the status.showUntrackedFiles configuration variable documented in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Значение по умолчанию можно изменить с помощью переменной конфигурации status.showUntrackedFiles, задокументированной в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4804356dda86c0d39019920e2a204580a3348e0" translate="yes" xml:space="preserve">
          <source>The default configuration with no configuration file at all may work perfectly well for some installations. Still, a configuration file is useful for customizing or tweaking the behavior of gitweb in many ways, and some optional features will not be present unless explicitly enabled using the configurable &lt;code&gt;%features&lt;/code&gt; variable (see also &quot;Configuring gitweb features&quot; section below).</source>
          <target state="translated">Конфигурация по умолчанию без файла конфигурации может отлично работать для некоторых установок. Тем не менее, файл конфигурации полезен для настройки или настройки поведения gitweb разными способами, и некоторые дополнительные функции не будут присутствовать, если явно не включены с помощью переменной configurable &lt;code&gt;%features&lt;/code&gt; (см. Также раздел &amp;laquo;Настройка функций gitweb&amp;raquo; ниже).</target>
        </trans-unit>
        <trans-unit id="ba35598baf99b4759b4ac8e8e152046ad84f4f70" translate="yes" xml:space="preserve">
          <source>The default destination is &lt;code&gt;syslog&lt;/code&gt; if &lt;code&gt;--inetd&lt;/code&gt; or &lt;code&gt;--detach&lt;/code&gt; is specified, otherwise &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">Назначением по умолчанию является &lt;code&gt;syslog&lt;/code&gt; если &lt;code&gt;--inetd&lt;/code&gt; или &lt;code&gt;--detach&lt;/code&gt; , в противном случае - &lt;code&gt;stderr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08a91820da4ab8ff0557091a83e78baf95e62cbc" translate="yes" xml:space="preserve">
          <source>The default development &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Whenever you create a Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, a branch named &quot;master&quot; is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;Ветвь&lt;/a&gt; разработки по умолчанию . Каждый раз, когда вы создаете &lt;a href=&quot;#def_repository&quot;&gt;репозиторий&lt;/a&gt; Git , создается ветка с именем &amp;laquo;master&amp;raquo;, которая становится активной ветвью. В большинстве случаев это локальная разработка, хотя это чисто условно и не требуется.</target>
        </trans-unit>
        <trans-unit id="9cfb0587d78b80316db2bf990e0689e616d2c4e9" translate="yes" xml:space="preserve">
          <source>The default diff tool to use when &lt;code&gt;--gui&lt;/code&gt; is specified.</source>
          <target state="translated">Инструмент сравнения по умолчанию, используемый при &lt;code&gt;--gui&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2106f60990b064f5f08c291bb6d584e30eb4aef6" translate="yes" xml:space="preserve">
          <source>The default diff tool to use.</source>
          <target state="translated">Инструмент сравнения по умолчанию.</target>
        </trans-unit>
        <trans-unit id="ef7818a768aaedb1852c90af2f69c6d87d81a9be" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output a signature containing the Git version number. Use this variable to change that default. Set this variable to the empty string (&quot;&quot;) to suppress signature generation.</source>
          <target state="translated">По умолчанию для формата-patch выводится подпись,содержащая номер версии Git'а.Используйте эту переменную,чтобы изменить это значение по умолчанию.Установите эту переменную в пустую строку (&quot;&quot;)для подавления генерации сигнатур.</target>
        </trans-unit>
        <trans-unit id="04f69f6bfbe685cc6892bfe73707b968c4b7e627" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the &lt;code&gt;[PATCH]&lt;/code&gt; subject prefix. Use this variable to change that prefix.</source>
          <target state="translated">По умолчанию format-patch выводит файлы с префиксом темы &lt;code&gt;[PATCH]&lt;/code&gt; . Используйте эту переменную, чтобы изменить префикс.</target>
        </trans-unit>
        <trans-unit id="9305a301a407a477c0982cd809ad589540305e9b" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the suffix &lt;code&gt;.patch&lt;/code&gt;. Use this variable to change that suffix (make sure to include the dot if you want it).</source>
          <target state="translated">По умолчанию format-patch выводит файлы с &lt;code&gt;.patch&lt;/code&gt; . Используйте эту переменную, чтобы изменить этот суффикс (не забудьте добавить точку, если хотите).</target>
        </trans-unit>
        <trans-unit id="82f6ff06915abbfaa5bafadf3e71c6515eea8a49" translate="yes" xml:space="preserve">
          <source>The default for the patch directory is patches or the value of the &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; environment variable.</source>
          <target state="translated">По умолчанию для каталога исправлений используются исправления или значение переменной среды &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63e417c4ba57abb65259188be896bb91267bad84" translate="yes" xml:space="preserve">
          <source>The default for the series file is &amp;lt;patches&amp;gt;/series or the value of the &lt;code&gt;$QUILT_SERIES&lt;/code&gt; environment variable.</source>
          <target state="translated">По умолчанию для файла серии используется &amp;lt;patches&amp;gt; / series или значение переменной среды &lt;code&gt;$QUILT_SERIES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43b413a4d69c795f1a4cc6e5069d43aa254cba9e" translate="yes" xml:space="preserve">
          <source>The default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie&amp;rsquo;s remark on your side. The only thing you can tell is that your side wants to say it is hard and you&amp;rsquo;d prefer to go shopping, while the other side wants to claim it is easy.</source>
          <target state="translated">Формат по умолчанию не показывает, что было сказано в оригинале в конфликтной области. Вы не можете сказать, сколько строк удалено и заменено репликой Барби на вашей стороне. Единственное, что вы можете сказать, это то, что ваша сторона хочет сказать, что это сложно, и вы предпочитаете пойти по магазинам, в то время как другая сторона хочет заявить, что это легко.</target>
        </trans-unit>
        <trans-unit id="2c9ac4b5e02925d5a2242fa228d32b0af91d581b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-notes&lt;/code&gt;, unless the &lt;code&gt;format.notes&lt;/code&gt; configuration is set.</source>
          <target state="translated">По умолчанию &lt;code&gt;--no-notes&lt;/code&gt; , если не &lt;code&gt;format.notes&lt;/code&gt; конфигурация format.notes .</target>
        </trans-unit>
        <trans-unit id="e210eb7dbec89858b8e72d64e2d379a9aada6a48" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-thread&lt;/code&gt;, unless the &lt;code&gt;format.thread&lt;/code&gt; configuration is set. If &lt;code&gt;--thread&lt;/code&gt; is specified without a style, it defaults to the style specified by &lt;code&gt;format.thread&lt;/code&gt; if any, or else &lt;code&gt;shallow&lt;/code&gt;.</source>
          <target state="translated">По умолчанию используется &lt;code&gt;--no-thread&lt;/code&gt; , если не &lt;code&gt;format.thread&lt;/code&gt; конфигурация format.thread . Если &lt;code&gt;--thread&lt;/code&gt; указан без стиля, по умолчанию используется стиль, указанный в &lt;code&gt;format.thread&lt;/code&gt; , если таковой имеется, или &lt;code&gt;shallow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9abe1131612b105426f13be17707662aa8662d23" translate="yes" xml:space="preserve">
          <source>The default is false, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.ignoreCase true if appropriate when the repository is created.</source>
          <target state="translated">Значение по умолчанию - false, за исключением того, что &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; или &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; проверят и установят core.ignoreCase true, если это необходимо, при создании репозитория.</target>
        </trans-unit>
        <trans-unit id="fcf73b7882b6e3d265136d0071b137412decce56" translate="yes" xml:space="preserve">
          <source>The default is not to print any annotation lines. If no number is given to &lt;code&gt;-n&lt;/code&gt;, only the first line is printed. If the tag is not annotated, the commit message is displayed instead.</source>
          <target state="translated">По умолчанию строки аннотаций не печатаются. Если номер &lt;code&gt;-n&lt;/code&gt; не указан , печатается только первая строка. Если тег не аннотирован, вместо него отображается сообщение о фиксации.</target>
        </trans-unit>
        <trans-unit id="19baf950afb8f746e54b7299adf6fbd6966f659a" translate="yes" xml:space="preserve">
          <source>The default is to diff against our branch (-2) and the cleanly resolved paths. The option -0 can be given to omit diff output for unmerged entries and just show &quot;Unmerged&quot;.</source>
          <target state="translated">По умолчанию используется сравнение с нашей веткой (-2)и чисто разрешенными путями.Опция -0 может быть задана для того,чтобы опустить вывод diff для неупорядоченных записей и просто показать &quot;Неупорядоченные&quot;.</target>
        </trans-unit>
        <trans-unit id="70f152ab57d660d365ae81763277f72b2d86f307" translate="yes" xml:space="preserve">
          <source>The default is true (when core.filemode is not specified in the config file).</source>
          <target state="translated">Значение по умолчанию равно true (когда в конфигурационном файле не указан режим core.filemode).</target>
        </trans-unit>
        <trans-unit id="03228e9bc81b32ffbccac2430f1d794dd7591d2a" translate="yes" xml:space="preserve">
          <source>The default is true, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.symlinks false if appropriate when the repository is created.</source>
          <target state="translated">По умолчанию установлено значение true, за исключением того, что &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; или &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; будут проверять и устанавливать core.symlinks false, если это необходимо, при создании репозитория.</target>
        </trans-unit>
        <trans-unit id="72445c1104c1c11ef748913a9c6e570e5a73c947" translate="yes" xml:space="preserve">
          <source>The default location of the CVS checkout to use for the export.</source>
          <target state="translated">Местоположение по умолчанию проверки CVS для использования при экспорте.</target>
        </trans-unit>
        <trans-unit id="116262510e324641581bf8e5fe54c44cc1ec58f5" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling a single branch.</source>
          <target state="translated">Стратегия слияния по умолчанию,используемая при вытягивании одной ветки.</target>
        </trans-unit>
        <trans-unit id="a808540aa8de08b00cb350dbc14ab54e33fa8faf" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling multiple branches at once.</source>
          <target state="translated">Стратегия слияния по умолчанию,используемая при перетягивании нескольких ветвей одновременно.</target>
        </trans-unit>
        <trans-unit id="e2e648395119cc70a2e9e998b6f3d4c60294fc12" translate="yes" xml:space="preserve">
          <source>The default mode for format-patch to determine which parts of the cover letter will be populated using the branch&amp;rsquo;s description. See the &lt;code&gt;--cover-from-description&lt;/code&gt; option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">Режим по умолчанию для format-patch, чтобы определить, какие части сопроводительного письма будут заполнены с использованием описания ветки. См. &lt;code&gt;--cover-from-description&lt;/code&gt; в &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="063faead523251f77be0529092965c3429cc8003" translate="yes" xml:space="preserve">
          <source>The default module path for &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; to use instead of /usr/lib/apache2/modules. Only used if httpd is Apache.</source>
          <target state="translated">Путь к модулю по умолчанию для &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1], который&lt;/a&gt; следует использовать вместо / usr / lib / apache2 / modules. Используется только если httpd - это Apache.</target>
        </trans-unit>
        <trans-unit id="91f8aff2bf27bb7f60525104a4a75d78c7ffe52b" translate="yes" xml:space="preserve">
          <source>The default notes merge strategy is &quot;manual&quot;, which checks out conflicting notes in a special work tree for resolving notes conflicts (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to resolve the conflicts in that work tree. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">Стратегия слияния заметок по умолчанию - &amp;laquo;ручная&amp;raquo;, которая проверяет конфликтующие заметки в специальном рабочем дереве для разрешения конфликтов заметок ( &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ) и инструктирует пользователя разрешить конфликты в этом рабочем дереве. Когда это будет сделано, пользователь может либо завершить слияние с помощью &lt;code&gt;git notes merge --commit&lt;/code&gt; , либо прервать слияние с помощью &lt;code&gt;git notes merge --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d49acb565d9b642605b0a997d7ebc3213ecdde25" translate="yes" xml:space="preserve">
          <source>The default pretty format for log/show/whatchanged command, See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;.</source>
          <target state="translated">Красивый формат по умолчанию для команды log / show / whatchanged, см. &lt;a href=&quot;git-log&quot;&gt;Git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; , &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c642123af45071133c151f29614b42c5bfc1ffac" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when fetching. See option --upload-pack of &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">Программа по умолчанию, выполняемая на удаленной стороне при загрузке. См. Параметр --upload-pack в &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02bc1378d0d05db5e7ff2ca7062e80f4098e5579" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when pushing. See option --receive-pack of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">Программа по умолчанию, выполняемая на удаленной стороне при нажатии. См. Параметр --receive-pack в &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1520b8813a02e6817b17665a2200c8c1eb73489c" translate="yes" xml:space="preserve">
          <source>The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, &quot;origin&quot; is assumed to be the default remote. If the superproject doesn&amp;rsquo;t have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead.</source>
          <target state="translated">Пульт по умолчанию - это удаленный от ветки удаленного отслеживания текущей ветки. Если такой ветви удаленного отслеживания не существует или HEAD отсоединен, предполагается, что &quot;origin&quot; является удаленным по умолчанию. Если суперпроект не имеет настроенного удаленного компьютера по умолчанию, суперпроект является его собственным авторитетным восходящим потоком, и вместо него используется текущий рабочий каталог.</target>
        </trans-unit>
        <trans-unit id="0d78370864f4fde80869e4efb080139612c8d161" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">Набор по умолчанию &quot;refspec&quot; для &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; . См. &lt;a href=&quot;git-fetch&quot;&gt;Git-fetch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e7461b63dbe3a9bd4be74e77260f6121d70becf" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">Набор по умолчанию &quot;refspec&quot; для &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; . См. &lt;a href=&quot;git-push&quot;&gt;Git-push [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1d55965a766c32086046542d13a0c5cafb5d20" translate="yes" xml:space="preserve">
          <source>The default set of branches for &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. See &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;.</source>
          <target state="translated">Набор веток по умолчанию для &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; . См. &lt;a href=&quot;git-show-branch&quot;&gt;Git-show-branch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f8a6ecfdcb232e0e35afa31c75a9bb76e3ba014" translate="yes" xml:space="preserve">
          <source>The default template directory includes some directory structure, suggested &quot;exclude patterns&quot; (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), and sample hook files.</source>
          <target state="translated">Каталог шаблонов по умолчанию включает некоторую структуру каталогов, предлагаемые &amp;laquo;шаблоны исключения&amp;raquo; (см. &lt;a href=&quot;gitignore&quot;&gt;Gitignore [5]&lt;/a&gt; ) и примеры файлов ловушек .</target>
        </trans-unit>
        <trans-unit id="5c5dda91be7317473d73b4f4f28156d762d8905f" translate="yes" xml:space="preserve">
          <source>The default threading style for &lt;code&gt;git format-patch&lt;/code&gt;. Can be a boolean value, or &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one. A true boolean value is the same as &lt;code&gt;shallow&lt;/code&gt;, and a false value disables threading.</source>
          <target state="translated">Стиль потока по умолчанию для &lt;code&gt;git format-patch&lt;/code&gt; . Может быть логическим значением, &lt;code&gt;shallow&lt;/code&gt; или &lt;code&gt;deep&lt;/code&gt; . &lt;code&gt;shallow&lt;/code&gt; цепочка делает каждое письмо ответом на начало серии, где заголовок выбирается из сопроводительного письма, &lt;code&gt;--in-reply-to&lt;/code&gt; и первого патча в этом порядке. &lt;code&gt;deep&lt;/code&gt; цепочка делает каждое письмо ответом на предыдущее. Истинное логическое значение совпадает с &lt;code&gt;shallow&lt;/code&gt; , а ложное значение отключает многопоточность.</target>
        </trans-unit>
        <trans-unit id="0eb7f832f6b33a6020eb8629fee287c4b15b4801" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default 'origin' is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">Исходный &lt;a href=&quot;#def_repository&quot;&gt;репозиторий&lt;/a&gt; по умолчанию . У большинства проектов есть, по крайней мере, один восходящий проект, который они отслеживают. По умолчанию для этой цели используется &amp;laquo;origin&amp;raquo;. Новые обновления восходящего потока будут загружаться в &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;ветки удаленного отслеживания с&lt;/a&gt; именем origin / name-of-upstream-branch, которые вы можете увидеть с помощью &lt;code&gt;git branch -r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f838be44da45fd1828d0b46b391485ccd56187e" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default &lt;code&gt;origin&lt;/code&gt; is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">Исходный &lt;a href=&quot;#def_repository&quot;&gt;репозиторий&lt;/a&gt; по умолчанию . У большинства проектов есть, по крайней мере, один восходящий проект, который они отслеживают. По умолчанию для этой цели используется &lt;code&gt;origin&lt;/code&gt; . Новые обновления восходящего потока будут загружаться в &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;ветки удаленного отслеживания с&lt;/a&gt; именем origin / name-of-upstream-branch, которые вы можете увидеть с помощью &lt;code&gt;git branch -r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66087a54aa582dff2f539d6f92ec2461ac3012fd" translate="yes" xml:space="preserve">
          <source>The default value for --window is 10 and --depth is 50. The maximum depth is 4095.</source>
          <target state="translated">Значение по умолчанию для --window равно 10,а -глубина-50.Максимальная глубина-4095.</target>
        </trans-unit>
        <trans-unit id="90d3816cdd271ff4f563d74700f0c34c9ae7702c" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;$projectroot&lt;/code&gt; is &lt;code&gt;/pub/git&lt;/code&gt;. You can change it during building gitweb via &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; build configuration variable.</source>
          <target state="translated">Значение по умолчанию для &lt;code&gt;$projectroot&lt;/code&gt; - &lt;code&gt;/pub/git&lt;/code&gt; . Вы можете изменить его во время сборки gitweb с помощью переменной конфигурации сборки &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78bcbc1a976cbafa1db494161487aec966c7436d" translate="yes" xml:space="preserve">
          <source>The default value is either &lt;code&gt;static/gitweb.js&lt;/code&gt;, or &lt;code&gt;static/gitweb.min.js&lt;/code&gt; if the &lt;code&gt;JSMIN&lt;/code&gt; build variable was defined, i.e. if JavaScript minifier was used at build time. &lt;strong&gt;Note&lt;/strong&gt; that this single file is generated from multiple individual JavaScript &quot;modules&quot;.</source>
          <target state="translated">Значение по умолчанию - &lt;code&gt;static/gitweb.js&lt;/code&gt; или &lt;code&gt;static/gitweb.min.js&lt;/code&gt; , если была определена переменная сборки &lt;code&gt;JSMIN&lt;/code&gt; , т.е. если во время сборки использовался минификатор JavaScript. &lt;strong&gt;Обратите внимание,&lt;/strong&gt; что этот единственный файл создается из нескольких отдельных &amp;laquo;модулей&amp;raquo; JavaScript.</target>
        </trans-unit>
        <trans-unit id="88fcf9aad2af8490af6dabfabbb5732019a6c8e1" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile variable at installation time. If this variable is empty, gitweb will fall back to scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for repositories.</source>
          <target state="translated">Значение по умолчанию для этой переменной определяется переменной &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile во время установки. Если эта переменная пуста, gitweb вернется к сканированию &lt;code&gt;$projectroot&lt;/code&gt; предмет репозиториев.</target>
        </trans-unit>
        <trans-unit id="da622b41696b803144c5254aad9443c84211d515" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the build-time configuration variable &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt;, which defaults to 2007.</source>
          <target state="translated">Значение по умолчанию этой переменной определяется переменной конфигурации &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt; времени сборки , которая по умолчанию равна 2007.</target>
        </trans-unit>
        <trans-unit id="777a0a86855d35a436d0a0e990f3b787a636cb43" translate="yes" xml:space="preserve">
          <source>The defined extensions are:</source>
          <target state="translated">Определенные расширения:</target>
        </trans-unit>
        <trans-unit id="2309a4e043845fb6e7e786e69af3d5ed57221f3f" translate="yes" xml:space="preserve">
          <source>The definition of a diff driver is done in &lt;code&gt;gitconfig&lt;/code&gt;, not &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">Определение драйвера diff выполняется в &lt;code&gt;gitconfig&lt;/code&gt; , а не в файле &lt;code&gt;gitattributes&lt;/code&gt; , поэтому, строго говоря, эта страница руководства - неподходящее место для обсуждения этого вопроса . Однако ...</target>
        </trans-unit>
        <trans-unit id="05fbc211f0bbdc85a5cbba915fe02006f8119e9e" translate="yes" xml:space="preserve">
          <source>The definition of a merge driver is done in the &lt;code&gt;.git/config&lt;/code&gt; file, not in the &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">Определение драйвера слияния делается в файле &lt;code&gt;.git/config&lt;/code&gt; , а не в файле &lt;code&gt;gitattributes&lt;/code&gt; , поэтому, строго говоря, эта страница руководства - неподходящее место для обсуждения этого вопроса . Однако ...</target>
        </trans-unit>
        <trans-unit id="096c7fcd9c9053c9edd8c72ca9c95b04e65c3409" translate="yes" xml:space="preserve">
          <source>The deletion removes the superproject&amp;rsquo;s tracking data, which are both the &lt;code&gt;gitlink&lt;/code&gt; entry and the section in the &lt;code&gt;.gitmodules&lt;/code&gt; file. The submodule&amp;rsquo;s working directory is removed from the file system, but the Git directory is kept around as it to make it possible to checkout past commits without requiring fetching from another repository.</source>
          <target state="translated">Удаление удаляет данные отслеживания суперпроекта, которые являются одновременно &lt;code&gt;gitlink&lt;/code&gt; и разделом в файле &lt;code&gt;.gitmodules&lt;/code&gt; . Рабочий каталог подмодуля удаляется из файловой системы, но каталог Git сохраняется, чтобы можно было проверять прошлые коммиты, не требуя выборки из другого репозитория.</target>
        </trans-unit>
        <trans-unit id="c4fe2a741691af413a8b078592b8e6a937844e84" translate="yes" xml:space="preserve">
          <source>The delta data is a sequence of instructions to reconstruct an object from the base object. If the base object is deltified, it must be converted to canonical form first. Each instruction appends more and more data to the target object until it&amp;rsquo;s complete. There are two supported instructions so far: one for copy a byte range from the source object and one for inserting new data embedded in the instruction itself.</source>
          <target state="translated">Дельта-данные - это последовательность инструкций для восстановления объекта из базового объекта. Если базовый объект разделен, он должен быть сначала преобразован в каноническую форму. Каждая инструкция добавляет к целевому объекту все больше и больше данных, пока не будет завершена. На данный момент поддерживаются две инструкции: одна для копирования диапазона байтов из исходного объекта и одна для вставки новых данных, встроенных в саму инструкцию.</target>
        </trans-unit>
        <trans-unit id="892bc72de2972bd5305c51b8962327a3cfb2518f" translate="yes" xml:space="preserve">
          <source>The depth parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 50, which is the default for the &lt;code&gt;--depth&lt;/code&gt; option when &lt;code&gt;--aggressive&lt;/code&gt; isn&amp;rsquo;t in use.</source>
          <target state="translated">Параметр глубины, используемый в алгоритме дельта-сжатия, используемом &lt;code&gt;git gc --aggressive&lt;/code&gt; . По умолчанию это 50, что является значением по умолчанию для параметра &lt;code&gt;--depth&lt;/code&gt; , когда &lt;code&gt;--aggressive&lt;/code&gt; не используется.</target>
        </trans-unit>
        <trans-unit id="71588492154c20723b86643e523c1d2b33771cc9" translate="yes" xml:space="preserve">
          <source>The design of fast-import allows it to import large projects in a minimum amount of memory usage and processing time. Assuming the frontend is able to keep up with fast-import and feed it a constant stream of data, import times for projects holding 10+ years of history and containing 100,000+ individual commits are generally completed in just 1-2 hours on quite modest (~$2,000 USD) hardware.</source>
          <target state="translated">Конструкция быстрого импорта позволяет импортировать большие проекты с минимальными затратами памяти и времени на обработку.Если предположить,что фронтенд способен идти в ногу с быстрым импортом и подавать ему постоянный поток данных,то время импорта для проектов с более чем 10-летней историей и содержащих более 100 000 отдельных коммитов,как правило,выполняется всего за 1-2 часа на достаточно скромном (~$2 000 USD)аппаратном обеспечении.</target>
        </trans-unit>
        <trans-unit id="c420d947d2d5939e423cde725977f1dbb1cf946b" translate="yes" xml:space="preserve">
          <source>The developer might want to rebase those commits to a newer &lt;code&gt;master&lt;/code&gt; while keeping the branch topology, for example when the first topic branch is expected to be integrated into &lt;code&gt;master&lt;/code&gt; much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">Разработчик может захотеть перенастроить эти коммиты на новый &lt;code&gt;master&lt;/code&gt; , сохранив топологию веток, например, когда ожидается, что первая ветка темы будет интегрирована в &lt;code&gt;master&lt;/code&gt; намного раньше, чем вторая, скажем, для разрешения конфликтов слияния с изменениями в DownloadButton класс, который превратился в &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38adb1a4eb1052b4c27e8f4f4a52ae35ba0619ad" translate="yes" xml:space="preserve">
          <source>The diff above shows the differences between the working-tree version of file.txt and the stage 2 and stage 3 versions. So instead of preceding each line by a single &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, it now uses two columns: the first column is used for differences between the first parent and the working directory copy, and the second for differences between the second parent and the working directory copy. (See the &quot;COMBINED DIFF FORMAT&quot; section of &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for a details of the format.)</source>
          <target state="translated">Приведенная выше разница показывает различия между версией файла file.txt в виде рабочего дерева и версиями стадии 2 и стадии 3. Таким образом, вместо того, чтобы предварять каждую строку одним &lt;code&gt;+&lt;/code&gt; или &lt;code&gt;-&lt;/code&gt; , теперь он использует два столбца: первый столбец используется для различий между первым родительским элементом и копией рабочего каталога, а второй - для различий между вторым родительским элементом и копией рабочего каталога. , (См. Раздел &amp;laquo;КОМБИНИРОВАННЫЙ DIFF FORMAT&amp;raquo; в &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; для получения подробной информации о формате.)</target>
        </trans-unit>
        <trans-unit id="330f16adb7b4cb162abae538c3471400c6f3dfa4" translate="yes" xml:space="preserve">
          <source>The diff commands &lt;code&gt;git diff-index&lt;/code&gt;, &lt;code&gt;git diff-files&lt;/code&gt;, and &lt;code&gt;git diff-tree&lt;/code&gt; can be told to manipulate differences they find in unconventional ways before showing &lt;code&gt;diff&lt;/code&gt; output. The manipulation is collectively called &quot;diffcore transformation&quot;. This short note describes what they are and how to use them to produce &lt;code&gt;diff&lt;/code&gt; output that is easier to understand than the conventional kind.</source>
          <target state="translated">Команды diff &lt;code&gt;git diff-index&lt;/code&gt; , &lt;code&gt;git diff-files&lt;/code&gt; и &lt;code&gt;git diff-tree&lt;/code&gt; можно указать, чтобы они манипулировали обнаруженными различиями нетрадиционными способами перед отображением вывода &lt;code&gt;diff&lt;/code&gt; . Эта манипуляция в совокупности называется &amp;laquo;преобразованием diffcore&amp;raquo;. В этой короткой заметке описывается, что это такое и как их использовать для создания вывода &lt;code&gt;diff&lt;/code&gt; , который легче понять, чем обычный вид.</target>
        </trans-unit>
        <trans-unit id="4e50a3e21215031cd44c450ab91735643c2d6198" translate="yes" xml:space="preserve">
          <source>The diffcore mechanism is fed a list of such comparison results (each of which is called &quot;filepair&quot;, although at this point each of them talks about a single file), and transforms such a list into another list. There are currently 5 such transformations:</source>
          <target state="translated">Механизм дифкора подает список результатов такого сравнения (каждый из которых называется &quot;файловой парой&quot;,хотя на данный момент каждый из них говорит об одном файле),и преобразует такой список в другой список.В настоящее время существует 5 таких преобразований:</target>
        </trans-unit>
        <trans-unit id="5ccc68add0025f283e287a514f59373a91910067" translate="yes" xml:space="preserve">
          <source>The directory holding the sha1 objects is missing.</source>
          <target state="translated">Каталог,в котором хранятся объекты sha1,отсутствует.</target>
        </trans-unit>
        <trans-unit id="3e56ce3070b6d1fe8bc11b5262f83540c8411c39" translate="yes" xml:space="preserve">
          <source>The directory to find the quilt patches.</source>
          <target state="translated">Каталог для поиска квилтовых патчей.</target>
        </trans-unit>
        <trans-unit id="0bb0f16c4fefb50922eb2b1990a8580cecff19f2" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with:</source>
          <target state="translated">Проще всего это сделать:</target>
        </trans-unit>
        <trans-unit id="114ebd710b84299f5cb327f93e8be01e979eae23" translate="yes" xml:space="preserve">
          <source>The easy case</source>
          <target state="translated">Простой футляр</target>
        </trans-unit>
        <trans-unit id="ae6685a0ed898fdf61a802d261028cc9079a0958" translate="yes" xml:space="preserve">
          <source>The editor used to edit the commit log message will be chosen from the &lt;code&gt;GIT_EDITOR&lt;/code&gt; environment variable, the core.editor configuration variable, the &lt;code&gt;VISUAL&lt;/code&gt; environment variable, or the &lt;code&gt;EDITOR&lt;/code&gt; environment variable (in that order). See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details.</source>
          <target state="translated">Редактор, используемый для редактирования сообщения журнала фиксации, будет выбран из &lt;code&gt;GIT_EDITOR&lt;/code&gt; среды GIT_EDITOR, переменной конфигурации core.editor, переменной среды &lt;code&gt;VISUAL&lt;/code&gt; или &lt;code&gt;EDITOR&lt;/code&gt; среды EDITOR (в указанном порядке). Подробнее см. &lt;a href=&quot;git-var&quot;&gt;Git-var [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e4dbd523803a96213d55b1fc234d8888f00a89f" translate="yes" xml:space="preserve">
          <source>The effect of the &lt;code&gt;git add&lt;/code&gt; was to add one entry to the index file:</source>
          <target state="translated">Эффект &lt;code&gt;git add&lt;/code&gt; заключался в добавлении одной записи в индексный файл:</target>
        </trans-unit>
        <trans-unit id="8c668b981ec948c02063906a293d8a4332dec951" translate="yes" xml:space="preserve">
          <source>The effect of this is best shown by way of comparing to &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting. The example turns into:</source>
          <target state="translated">Эффект от этого лучше всего демонстрируется путем сравнения &lt;code&gt;--full-history&lt;/code&gt; с родительской перезаписью. Пример превращается в:</target>
        </trans-unit>
        <trans-unit id="f01b79da1b24a8459870505ceabc7acd5dc253cb" translate="yes" xml:space="preserve">
          <source>The effective value of &quot;core.notesRef&quot; (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.</source>
          <target state="translated">Эффективное значение &quot;core.notesRef&quot; (возможно,переопределенное GIT_NOTES_REF)также неявно добавляется в список отображаемых ссылок.</target>
        </trans-unit>
        <trans-unit id="47170c140110158e7cecc3842f11a773c4cf2ae7" translate="yes" xml:space="preserve">
          <source>The effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead.</source>
          <target state="translated">Эффект от этого в основном постоянен,например,когда стаи и сыпучие предметы объединяются в одну пачку,существующие дельты в этой пачке могут быть использованы повторно,но есть также различные случаи,когда мы можем выбрать неоптимальную дельту из более новой пачки вместо нее.</target>
        </trans-unit>
        <trans-unit id="e05ce4cdee1f111bdf6e1a5c14e6220d9920c4e2" translate="yes" xml:space="preserve">
          <source>The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry therefore detects when commits have been &quot;copied&quot; by means of &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;, &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; or &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">Тест эквивалентности основан на различии после удаления пробелов и номеров строк. Таким образом, git-cherry определяет, когда коммиты были &amp;laquo;скопированы&amp;raquo; с помощью &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]&lt;/a&gt; , &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; или &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5c570f3616a5224dd6e91327ceb211453e9ddc" translate="yes" xml:space="preserve">
          <source>The error event may be emitted more than once. The format string allows post-processors to group errors by type without worrying about specific error arguments.</source>
          <target state="translated">Событие об ошибке может выдаваться несколько раз.Строка форматирования позволяет постпроцессорам группировать ошибки по типам,не беспокоясь о конкретных аргументах ошибок.</target>
        </trans-unit>
        <trans-unit id="2c5c3dbbaebe5825bdfa9c22deed2d10f337e86e" translate="yes" xml:space="preserve">
          <source>The event format target is a JSON-based format of event data suitable for telemetry analysis. This format is enabled with the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable or the &lt;code&gt;trace2.eventTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">Целевой формат события - это формат данных события на основе JSON, подходящий для анализа телеметрии. Этот формат включен с &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; переменной окружения или &lt;code&gt;trace2.eventTarget&lt;/code&gt; системы или глобальные настройки конфигурации.</target>
        </trans-unit>
        <trans-unit id="bb53cc945a6f48ddfeb31dcd9983e9640d488cf9" translate="yes" xml:space="preserve">
          <source>The ever-versatile &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command can also be used to examine tree objects, but &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; will give you more details:</source>
          <target state="translated">Универсальная команда &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; также может использоваться для изучения объектов дерева, но &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt; предоставит вам более подробную информацию:</target>
        </trans-unit>
        <trans-unit id="2cae5c144ae6a6f552f7dcee7bbaf0209258a3bd" translate="yes" xml:space="preserve">
          <source>The example configuration presented here is guaranteed to be backwards and forward compatible.</source>
          <target state="translated">Представленный здесь пример конфигурации гарантированно будет совместим с обратной и прямой ориентацией.</target>
        </trans-unit>
        <trans-unit id="77578078110fe9093d1036dd58aeebc2db7df1b8" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored, however a non-zero exit code will generate an error message.</source>
          <target state="translated">Код выхода из этого вызова крюка игнорируется,однако ненулевой код выхода будет выдавать сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="1e405cb397afa437170eea29059b03dcf97426f6" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored; the only thing left for &lt;code&gt;git-receive-pack&lt;/code&gt; to do at that point is to exit itself anyway.</source>
          <target state="translated">Код выхода из этого вызова ловушки игнорируется; единственное, что остается сделать &lt;code&gt;git-receive-pack&lt;/code&gt; на этом этапе, - это все равно выйти из себя.</target>
        </trans-unit>
        <trans-unit id="5a81c04e486b5c66b0be7554a6e91773cfd1a9a9" translate="yes" xml:space="preserve">
          <source>The exit status determines whether git will use the data from the hook to limit its search. On error, it will fall back to verifying all files and folders.</source>
          <target state="translated">Статус выхода определяет,будет ли git использовать данные с крюка для ограничения поиска.При ошибке он вернётся к проверке всех файлов и папок.</target>
        </trans-unit>
        <trans-unit id="863cf74b97781c15eaa4bf39c81be105821817bd" translate="yes" xml:space="preserve">
          <source>The exit value of this program is negative on error, and the number of conflicts otherwise (truncated to 127 if there are more than that many conflicts). If the merge was clean, the exit value is 0.</source>
          <target state="translated">Значение выхода этой программы отрицательно на ошибку,а количество конфликтов в противном случае (усечено до 127,если конфликтов больше).Если слияние было чистым,то значение выхода равно 0.</target>
        </trans-unit>
        <trans-unit id="600e0ed5040d09634bf101b6adc431e3349d2258" translate="yes" xml:space="preserve">
          <source>The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after &lt;code&gt;format-patch&lt;/code&gt; has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the &lt;code&gt;notes.rewrite&lt;/code&gt; configuration options in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; to use this workflow).</source>
          <target state="translated">Ожидаемый вариант использования этого - написать вспомогательное объяснение для фиксации, которое не принадлежит собственно сообщению журнала фиксации, и включить его в отправку патча. Хотя можно просто написать эти объяснения после запуска &lt;code&gt;format-patch&lt;/code&gt; , но перед отправкой, сохранение их в виде заметок Git позволяет сохранять их между версиями серии исправлений (но см. Обсуждение &lt;code&gt;notes.rewrite&lt;/code&gt; конфигурации notes.rewrite в &lt;a href=&quot;git-notes&quot;&gt;git-notes [ 1],&lt;/a&gt; чтобы использовать этот рабочий процесс).</target>
        </trans-unit>
        <trans-unit id="7c7921a0c6ea4cec42a427f589011997d35e15f9" translate="yes" xml:space="preserve">
          <source>The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service.</source>
          <target state="translated">Внешняя команда может по выбору записать одну строку на свой стандартный выход для отправки запрашивающему в качестве сообщения об ошибке при отказе в обслуживании.</target>
        </trans-unit>
        <trans-unit id="34c4f9db557882c9df4177a31e00a543de8934c9" translate="yes" xml:space="preserve">
          <source>The extra &lt;code&gt;NUL&lt;/code&gt; before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to &lt;code&gt;NUL&lt;/code&gt; would yield the pathname, but if that is &lt;code&gt;NUL&lt;/code&gt;, the record will show two paths.</source>
          <target state="translated">Дополнительный &lt;code&gt;NUL&lt;/code&gt; перед путем к прообразу в переименованном случае позволяет сценариям, которые читают вывод, определять, является ли текущая читаемая запись записью с одним путем или записью переименования / копирования без предварительного чтения. После чтения добавленных и удаленных строк чтение до &lt;code&gt;NUL&lt;/code&gt; даст имя пути, но если это &lt;code&gt;NUL&lt;/code&gt; , запись покажет два пути.</target>
        </trans-unit>
        <trans-unit id="1b54438722ed3844a0702f9ed09c56d6aef28ee2" translate="yes" xml:space="preserve">
          <source>The fast-import backend itself can import into an empty repository (one that has already been initialized by &lt;code&gt;git init&lt;/code&gt;) or incrementally update an existing populated repository. Whether or not incremental imports are supported from a particular foreign source depends on the frontend program in use.</source>
          <target state="translated">Сам бэкэнд быстрого импорта может импортировать в пустой репозиторий (тот, который уже был инициализирован &lt;code&gt;git init&lt;/code&gt; ) или постепенно обновлять существующий заполненный репозиторий. Поддерживается ли добавочный импорт из конкретного внешнего источника или нет, зависит от используемой клиентской программы.</target>
        </trans-unit>
        <trans-unit id="3dfacf796b68e98a60c628fed43445479dc82ce1" translate="yes" xml:space="preserve">
          <source>The fast-import mechanism used by &lt;code&gt;git p4&lt;/code&gt; creates one pack file for each invocation of &lt;code&gt;git p4 sync&lt;/code&gt;. Normally, Git garbage compression (&lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;) automatically compresses these to fewer pack files, but explicit invocation of &lt;code&gt;git repack -adf&lt;/code&gt; may improve performance.</source>
          <target state="translated">Механизм быстрого импорта, используемый &lt;code&gt;git p4&lt;/code&gt; , создает один файл пакета для каждого вызова &lt;code&gt;git p4 sync&lt;/code&gt; . Обычно сжатие мусора Git ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; ) автоматически сжимает их до меньшего количества файлов пакетов, но явный вызов &lt;code&gt;git repack -adf&lt;/code&gt; может улучшить производительность.</target>
        </trans-unit>
        <trans-unit id="53e903dc94674f5b365dd31d16a6c2e334c714e3" translate="yes" xml:space="preserve">
          <source>The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.</source>
          <target state="translated">Протоколы fetch и push не предназначены для того,чтобы предотвратить кражу одной стороной данных из другого репозитория,которые не предназначались для общего доступа.Если у вас есть личные данные,которые необходимо защитить от злоумышленников,лучше всего хранить их в другом репозитории.Это относится как к клиентам,так и к серверам.В частности,пространства имен на сервере не эффективны для контроля доступа на чтение;вы должны предоставлять доступ на чтение только тем клиентам,которым вы доверите доступ на чтение всему репозиторию.</target>
        </trans-unit>
        <trans-unit id="648bf821f46e9909499e1fbac0dd96a1ab871eb7" translate="yes" xml:space="preserve">
          <source>The fields (including the &lt;code&gt;-&amp;gt;&lt;/code&gt;) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped.</source>
          <target state="translated">Поля (включая &lt;code&gt;-&amp;gt;&lt;/code&gt; ) отделены друг от друга одним пробелом. Если имя файла содержит пробелы или другие непечатаемые символы, это поле будет заключено в кавычки в виде строкового литерала C: оно будет заключено в двойные кавычки ASCII (34), а внутренние специальные символы будут экранированы обратной косой чертой.</target>
        </trans-unit>
        <trans-unit id="3994e582754827987cb1dab035b29a73b90c4b3e" translate="yes" xml:space="preserve">
          <source>The file consists of sections and variables. A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable.</source>
          <target state="translated">Файл состоит из разделов и переменных. Раздел начинается с названия раздела в квадратных скобках и продолжается до начала следующего раздела. Имена разделов нечувствительны к регистру. Только буквенно-цифровые символы &lt;code&gt;-&lt;/code&gt; и &lt;code&gt;.&lt;/code&gt; разрешены в названиях разделов. Каждая переменная должна принадлежать какому-либо разделу, что означает, что перед первым параметром переменной должен быть заголовок раздела.</target>
        </trans-unit>
        <trans-unit id="b77694751b662ffffe51a33dc2cd7f9b8be897f4" translate="yes" xml:space="preserve">
          <source>The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the &lt;code&gt;--name&lt;/code&gt; option of &lt;code&gt;git submodule add&lt;/code&gt;. Each submodule section also contains the following required keys:</source>
          <target state="translated">Файл содержит по одному подразделу на каждый подмодуль, а значение подраздела - это имя подмодуля. В качестве имени задается путь, по которому был добавлен подмодуль, если он не был настроен с &lt;code&gt;--name&lt;/code&gt; опции --name команды &lt;code&gt;git submodule add&lt;/code&gt; . Каждый раздел подмодуля также содержит следующие обязательные ключи:</target>
        </trans-unit>
        <trans-unit id="d7d8ebbce919f993c68a8bac80b9fbb16d92024e" translate="yes" xml:space="preserve">
          <source>The file format includes parameters for the object ID hash function, so a future change of hash algorithm does not require a change in format.</source>
          <target state="translated">Формат файла включает в себя параметры хэш-функции идентификатора объекта,поэтому дальнейшее изменение хэш-алгоритма не требует изменения формата.</target>
        </trans-unit>
        <trans-unit id="1bb6e340dc566db02505e0c4003761a9d85c40c1" translate="yes" xml:space="preserve">
          <source>The file is concluded with a trailer:</source>
          <target state="translated">Файл завершается трейлером:</target>
        </trans-unit>
        <trans-unit id="996f5fbcdb16f7d7ee85c3a6ae77d46a1781884a" translate="yes" xml:space="preserve">
          <source>The file parameters can point at the user&amp;rsquo;s working file (e.g. &lt;code&gt;new-file&lt;/code&gt; in &quot;git-diff-files&quot;), &lt;code&gt;/dev/null&lt;/code&gt; (e.g. &lt;code&gt;old-file&lt;/code&gt; when a new file is added), or a temporary file (e.g. &lt;code&gt;old-file&lt;/code&gt; in the index). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; should not worry about unlinking the temporary file --- it is removed when &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; exits.</source>
          <target state="translated">Параметры файла могут указывать на рабочий файл пользователя (например, &lt;code&gt;new-file&lt;/code&gt; в &quot;git-diff-files&quot;), &lt;code&gt;/dev/null&lt;/code&gt; (например, &lt;code&gt;old-file&lt;/code&gt; при добавлении нового файла) или временный файл (например, &lt;code&gt;old-file&lt;/code&gt; в индексе). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; не должен беспокоиться об отключении временного файла - он удаляется при выходе из &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b979e5d416845ad4db7c29ab613bf67d05d7d448" translate="yes" xml:space="preserve">
          <source>The files are read in the order given above, with last value found taking precedence over values read earlier. When multiple values are taken then all values of a key from all files will be used.</source>
          <target state="translated">Файлы считываются в порядке,указанном выше,при этом найденное последнее значение имеет приоритет над значениями,прочитанными ранее.При считывании нескольких значений будут использованы все значения ключа из всех файлов.</target>
        </trans-unit>
        <trans-unit id="22cd650e22be9431ebec70f16e27f0954b25a243" translate="yes" xml:space="preserve">
          <source>The files to read the patch from. &lt;code&gt;-&lt;/code&gt; can be used to read from the standard input.</source>
          <target state="translated">Файлы, из которых следует читать патч. &lt;code&gt;-&lt;/code&gt; можно использовать для чтения со стандартного ввода.</target>
        </trans-unit>
        <trans-unit id="fc839d554b73db3187cb52551b31c221d5647965" translate="yes" xml:space="preserve">
          <source>The filter is expected to respond with a list of &quot;key=value&quot; pairs terminated with a flush packet. If the filter does not experience problems then the list must contain a &quot;success&quot; status. Right after these packets the filter is expected to send the content in zero or more pkt-line packets and a flush packet at the end. Finally, a second list of &quot;key=value&quot; pairs terminated with a flush packet is expected. The filter can change the status in the second list or keep the status as is with an empty list. Please note that the empty list must be terminated with a flush packet regardless.</source>
          <target state="translated">Ожидается,что фильтр ответит списком пар &quot;ключ=значение&quot;,завершенных пакетом флеш.Если фильтр не испытывает проблем,то список должен содержать статус &quot;успешно&quot;.Сразу после этих пакетов фильтр должен отправить содержимое в нулевом или большем количестве пакетов pkt-line и флеш-пакет в конце.Наконец,ожидается второй список пар &quot;ключ=значение&quot;,завершенных флеш-пакетом.Фильтр может изменить статус во втором списке или сохранить статус как есть с пустым списком.Пожалуйста,обратите внимание,что пустой список должен быть прерван флеш-пакетом независимо от этого.</target>
        </trans-unit>
        <trans-unit id="48c7b9e769ad1a8ac7a03d8a91befba4e1dc75d4" translate="yes" xml:space="preserve">
          <source>The filter that will be applied when fetching from this promisor remote.</source>
          <target state="translated">Фильтр,который будет применяться при извлечении с этого удаленного промульстера.</target>
        </trans-unit>
        <trans-unit id="67e1cbcd0bc26ca591869ec55e18981d4a05f31d" translate="yes" xml:space="preserve">
          <source>The filters are applied in the order as listed below. The &amp;lt;command&amp;gt; argument is always evaluated in the shell context using the &lt;code&gt;eval&lt;/code&gt; command (with the notable exception of the commit filter, for technical reasons). Prior to that, the &lt;code&gt;$GIT_COMMIT&lt;/code&gt; environment variable will be set to contain the id of the commit being rewritten. Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; after the filters have run.</source>
          <target state="translated">Фильтры применяются в порядке, указанном ниже. Аргумент &amp;lt;command&amp;gt; всегда оценивается в контексте оболочки с помощью команды &lt;code&gt;eval&lt;/code&gt; (за заметным исключением фильтра фиксации по техническим причинам). Перед этим в &lt;code&gt;$GIT_COMMIT&lt;/code&gt; окружения $ GIT_COMMIT будет установлен идентификатор перезаписываемого коммита. Кроме того, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL и GIT_COMMITTER_DATE берутся из текущего коммита и экспортируются в среду, чтобы повлиять на автора и &lt;a href=&quot;git-commit-tree&quot;&gt;коммит-дерево&lt;/a&gt; после фиксации, созданное [1- замещающим деревом]. фильтры сработали.</target>
        </trans-unit>
        <trans-unit id="96e6a8e11c595c66ed126e7ed94498b41b8ef74c" translate="yes" xml:space="preserve">
          <source>The final &quot;/&quot; is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.</source>
          <target state="translated">Окончательное &quot;/&quot; важно.Экспортируемое имя буквально просто префиксовано с указанной строкой.Противопоставьте это следующему примеру.</target>
        </trans-unit>
        <trans-unit id="5e71083855686454b686d549c1aa754044d9c24f" translate="yes" xml:space="preserve">
          <source>The final result will be a series of commits, one for each patch in the original mailbox, with authorship and commit log message each taken from the message containing each patch.</source>
          <target state="translated">Окончательным результатом будет серия коммитов,по одному для каждого патча в исходном почтовом ящике,с сообщением об авторстве и сообщением журнала коммитов,каждое из которых взято из сообщения,содержащего каждый патч.</target>
        </trans-unit>
        <trans-unit id="d06dc79919ba8d7d4e32bae22586b9e61ea6ab90" translate="yes" xml:space="preserve">
          <source>The first &quot;git bisect&quot; subcommand to use is &quot;git bisect start&quot; to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one &quot;bad&quot; and at least one &quot;good&quot; commit. They can be passed in the initial call to &quot;git bisect start&quot; like this:</source>
          <target state="translated">Первая подкоманда &quot;git-бисект&quot; используется для начала поиска.Затем должны быть установлены границы,ограничивающие пространство фиксации.Обычно это делается путём задания одного &quot;плохого&quot; и,как минимум,одного &quot;хорошего&quot; коммита.При первом вызове они могут быть переданы в &quot;git-bisect start&quot; вот так:</target>
        </trans-unit>
        <trans-unit id="3dd96cc8c67fe6f3794e1faadfc16d4e75778490" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;origin&lt;/code&gt;, just tells Git to fetch from the repository you originally cloned from. The second argument tells Git to fetch the branch named &lt;code&gt;todo&lt;/code&gt; from the remote repository, and to store it locally under the name &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt;.</source>
          <target state="translated">Первый аргумент, &lt;code&gt;origin&lt;/code&gt; , просто сообщает Git, что нужно выполнить выборку из репозитория, из которого вы изначально клонировали. Второй аргумент указывает Git получить ветку с именем &lt;code&gt;todo&lt;/code&gt; из удаленного репозитория и сохранить ее локально под именем &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81bbac8df429c9294b949507806676c0327c9227" translate="yes" xml:space="preserve">
          <source>The first character given by this option will be the default character used when another separator is not specified in the config for this trailer.</source>
          <target state="translated">Первый символ,заданный этой опцией,будет символом по умолчанию,используемым,когда другой разделитель не указан в конфигурационном файле для этого трейлера.</target>
        </trans-unit>
        <trans-unit id="39b9ae2f52daae0742c9cd959c54a342268035c6" translate="yes" xml:space="preserve">
          <source>The first command fetches the &lt;code&gt;maint&lt;/code&gt; branch from the repository at &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; and the second command uses &lt;code&gt;FETCH_HEAD&lt;/code&gt; to examine the branch with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. The fetched objects will eventually be removed by git&amp;rsquo;s built-in housekeeping (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;).</source>
          <target state="translated">Первая команда извлекает ветку &lt;code&gt;maint&lt;/code&gt; из репозитория по адресу &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; , а вторая команда использует &lt;code&gt;FETCH_HEAD&lt;/code&gt; для проверки ветки с помощью &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; . Полученные объекты в конечном итоге будут удалены встроенной функцией &lt;a href=&quot;git-gc&quot;&gt;git&lt;/a&gt; (см. Git-gc [1] ).</target>
        </trans-unit>
        <trans-unit id="fc54aa6f7f46c36afb224191ab9ce02506aa2fd9" translate="yes" xml:space="preserve">
          <source>The first defense against such problems is backups. You can back up a Git directory using clone, or just using cp, tar, or any other backup mechanism.</source>
          <target state="translated">Первая защита от таких проблем-резервное копирование.Вы можете создать резервную копию директории Git'а с помощью клона или просто с помощью cp,tar или любого другого механизма резервного копирования.</target>
        </trans-unit>
        <trans-unit id="eb17679ed2c14d3eecb0f1bd83c98beea1f4bea4" translate="yes" xml:space="preserve">
          <source>The first format is what gets used when &lt;code&gt;--stage&lt;/code&gt; is omitted or is not &lt;code&gt;--stage=all&lt;/code&gt;. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.</source>
          <target state="translated">Первый формат используется, когда &lt;code&gt;--stage&lt;/code&gt; опущено или не &lt;code&gt;--stage=all&lt;/code&gt; . Поле tempname - это имя временного файла, содержащего содержимое файла, а path - это отслеживаемое имя пути в индексе. Выводятся только запрошенные записи.</target>
        </trans-unit>
        <trans-unit id="e7e26fcb00a95d796be86027e9776fd349443123" translate="yes" xml:space="preserve">
          <source>The first is simple and appropriate if you do not have secure storage available for a password. It is generally configured by adding this to your config:</source>
          <target state="translated">Первое просто и уместно,если у вас нет защищенного хранилища для пароля.Обычно он настраивается путем добавления его в конфигурацию:</target>
        </trans-unit>
        <trans-unit id="561e4f0c34cc864db97b2078e570c6b7cf2ee83d" translate="yes" xml:space="preserve">
          <source>The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:</source>
          <target state="translated">Первая строка входного сигнала 0 в качестве режима удаления пути;SHA-1 не имеет значения,пока он хорошо отформатирован.Затем вторая и третья строка передает для этого пути записи стадии 1 и стадии 2.После всего вышесказанного мы бы закончили на этом:</target>
        </trans-unit>
        <trans-unit id="d7a467221d570ce5d2e2454d168c252049fa7e64" translate="yes" xml:space="preserve">
          <source>The first number is the number of objects which are kept in individual files. The second is the amount of space taken up by those &quot;loose&quot; objects.</source>
          <target state="translated">Первое число-это количество объектов,которые хранятся в отдельных файлах.Второе число-количество места,занимаемого этими &quot;свободными&quot; объектами.</target>
        </trans-unit>
        <trans-unit id="1517f019c895db91a3158888218e464c0e667ed4" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the hook is the indicator for the working directory being updated. &quot;1&quot; meaning working directory was updated or &quot;0&quot; when the working directory was not updated.</source>
          <target state="translated">Первым параметром,передаваемым на крючок,является индикатор обновляемой рабочей директории.&quot;1&quot; означает,что рабочий каталог был обновлен или &quot;0&quot;-когда рабочий каталог не обновлялся.</target>
        </trans-unit>
        <trans-unit id="69f4b05a4b19ebccc10062a19a78b72d37ff6b60" translate="yes" xml:space="preserve">
          <source>The first rule takes precedence in the case of a single &amp;lt;commit&amp;gt;. To apply the second rule, i.e., format everything since the beginning of history up until &amp;lt;commit&amp;gt;, use the &lt;code&gt;--root&lt;/code&gt; option: &lt;code&gt;git format-patch
--root &amp;lt;commit&amp;gt;&lt;/code&gt;. If you want to format only &amp;lt;commit&amp;gt; itself, you can do this with &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Первое правило имеет приоритет в случае единственного &amp;lt;commit&amp;gt;. Чтобы применить второе правило, то есть отформатировать все с начала истории до &amp;lt;commit&amp;gt;, используйте параметр &lt;code&gt;--root&lt;/code&gt; : &lt;code&gt;git format-patch --root &amp;lt;commit&amp;gt;&lt;/code&gt; . Если вы хотите отформатировать только сам &amp;lt;commit&amp;gt;, вы можете сделать это с помощью &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088dfc95ab36375e45956a12e0a84d20b54cd1e3" translate="yes" xml:space="preserve">
          <source>The first step is trivial: when you want to tell Git about any changes to your working tree, you use the &lt;code&gt;git update-index&lt;/code&gt; program. That program normally just takes a list of filenames you want to update, but to avoid trivial mistakes, it refuses to add new entries to the index (or remove existing ones) unless you explicitly tell it that you&amp;rsquo;re adding a new entry with the &lt;code&gt;--add&lt;/code&gt; flag (or removing an entry with the &lt;code&gt;--remove&lt;/code&gt;) flag.</source>
          <target state="translated">Первый шаг тривиален: когда вы хотите сообщить Git о любых изменениях в вашем рабочем дереве, вы используете программу &lt;code&gt;git update-index&lt;/code&gt; . Эта программа обычно просто берет список имен файлов, которые вы хотите обновить, но, чтобы избежать тривиальных ошибок, она отказывается добавлять новые записи в индекс (или удалять существующие), если вы явно не укажете, что добавляете новую запись с Флаг &lt;code&gt;--add&lt;/code&gt; (или удаление записи с флагом &lt;code&gt;--remove&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1763915dd6826ebefd6dfcb3fd9fb79e61ff2f7" translate="yes" xml:space="preserve">
          <source>The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.).</source>
          <target state="translated">В первый раз,когда коммит появляется в потоке,он имеет различную другую информацию о нём,распечатанную с меткой из одного слова в начале каждой строки,описывающей дополнительную информацию о коммите (автор,электронная почта,коммиттер,даты,резюме и т.д.).</target>
        </trans-unit>
        <trans-unit id="33e2d00ff1c333999b37d340bc5ae3e8a3bfd826" translate="yes" xml:space="preserve">
          <source>The first time you run it, you will be prompted for your credentials. Enter the app-specific or your regular password as appropriate. If you have credential helper configured (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt;), the password will be saved in the credential store so you won&amp;rsquo;t have to type it the next time.</source>
          <target state="translated">При первом запуске вам будет предложено ввести учетные данные. Введите пароль для конкретного приложения или свой обычный пароль. Если у вас настроен помощник по &lt;a href=&quot;git-credential&quot;&gt;учетным&lt;/a&gt; данным (см. Git-credential [1] ), пароль будет сохранен в хранилище учетных данных, поэтому вам не придется вводить его в следующий раз.</target>
        </trans-unit>
        <trans-unit id="1c77b9db9c00c5ba7e83e0fb24758e48237c23ee" translate="yes" xml:space="preserve">
          <source>The first two lines indicate that it is showing the two branches with the titles of their top-of-the-tree commits, you are currently on &lt;code&gt;master&lt;/code&gt; branch (notice the asterisk &lt;code&gt;*&lt;/code&gt; character), and the first column for the later output lines is used to show commits contained in the &lt;code&gt;master&lt;/code&gt; branch, and the second column for the &lt;code&gt;mybranch&lt;/code&gt; branch. Three commits are shown along with their titles. All of them have non blank characters in the first column (&lt;code&gt;*&lt;/code&gt; shows an ordinary commit on the current branch, &lt;code&gt;-&lt;/code&gt; is a merge commit), which means they are now part of the &lt;code&gt;master&lt;/code&gt; branch. Only the &quot;Some work&quot; commit has the plus &lt;code&gt;+&lt;/code&gt; character in the second column, because &lt;code&gt;mybranch&lt;/code&gt; has not been merged to incorporate these commits from the master branch. The string inside brackets before the commit log message is a short name you can use to name the commit. In the above example, &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;mybranch&lt;/code&gt; are branch heads. &lt;code&gt;master^&lt;/code&gt; is the first parent of &lt;code&gt;master&lt;/code&gt; branch head. Please see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; if you want to see more complex cases.</source>
          <target state="translated">Первые две строки указывают на то, что он показывает две ветви с заголовками их коммитов на вершине дерева, вы в настоящее время находитесь на &lt;code&gt;master&lt;/code&gt; ветке (обратите внимание на символ звездочки &lt;code&gt;*&lt;/code&gt; ), а первый столбец для последующих выходных строк - используется для отображения коммитов, содержащихся в &lt;code&gt;master&lt;/code&gt; ветке, и второй столбец для ветки &lt;code&gt;mybranch&lt;/code&gt; . Показаны три коммита с их названиями. Все они имеют непустые символы в первом столбце ( &lt;code&gt;*&lt;/code&gt; показывает обычную фиксацию в текущей ветке, &lt;code&gt;-&lt;/code&gt; это фиксация слияния), что означает, что теперь они являются частью &lt;code&gt;master&lt;/code&gt; ветки. Только коммит &quot;Some work&quot; имеет плюс &lt;code&gt;+&lt;/code&gt; во втором столбце, потому что &lt;code&gt;mybranch&lt;/code&gt; не был объединен для включения этих коммитов из основной ветки. Строка в скобках перед сообщением журнала фиксации - это короткое имя, которое можно использовать для названия фиксации. В приведенном выше примере &lt;code&gt;master&lt;/code&gt; и &lt;code&gt;mybranch&lt;/code&gt; являются головками веток. &lt;code&gt;master^&lt;/code&gt; - это первый родительский элемент &lt;code&gt;master&lt;/code&gt; ветки. Пожалуйста, &lt;a href=&quot;gitrevisions&quot;&gt;прочтите gitrevisions [7],&lt;/a&gt; если вы хотите увидеть более сложные случаи.</target>
        </trans-unit>
        <trans-unit id="6b2c923c8cb34a6329089d3ed63e2b76d6f7ceed" translate="yes" xml:space="preserve">
          <source>The folder to drop the mails into, which is typically the Drafts folder. For example: &quot;INBOX.Drafts&quot;, &quot;INBOX/Drafts&quot; or &quot;[Gmail]/Drafts&quot;. Required.</source>
          <target state="translated">Папка для пересылки писем,в которую обычно помещается папка Drafts (Черновики).Например:&quot;INBOX.Drafts&quot;,&quot;INBOX/Drafts&quot; или &quot;[Gmail]/Drafts&quot;.Требуется.</target>
        </trans-unit>
        <trans-unit id="396ef1fe12b6dc07f4e5a4f66f87333df9fb56e3" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;update&lt;/code&gt; procedures are only available via the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable:</source>
          <target state="translated">Следующие процедуры &lt;code&gt;update&lt;/code&gt; доступны только через переменную конфигурации &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="109e44e80a38f6553ddae4455bbabc5ec0d98180" translate="yes" xml:space="preserve">
          <source>The following Thunderbird extensions are needed: AboutConfig from &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/&lt;/a&gt; and External Editor from &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8&lt;/a&gt;</source>
          <target state="translated">Необходимы следующие расширения Thunderbird: AboutConfig из &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/&lt;/a&gt; и External Editor из &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6722fafbaf6d78a6b809eec36e0605e28b20857" translate="yes" xml:space="preserve">
          <source>The following are helper commands used by the above; end users typically do not use them directly.</source>
          <target state="translated">Ниже приведены вспомогательные команды,используемые выше;конечные пользователи обычно не используют их напрямую.</target>
        </trans-unit>
        <trans-unit id="7e10909a1942dd56a826033bd880f2f38314517d" translate="yes" xml:space="preserve">
          <source>The following command switches to the &quot;master&quot; branch:</source>
          <target state="translated">Следующая команда переключается на ветвь &quot;Ведущий&quot;:</target>
        </trans-unit>
        <trans-unit id="7a4f4c25f3029fcde1d4a38239fa9b13c5887156" translate="yes" xml:space="preserve">
          <source>The following command-line options change import semantics and may therefore not be passed as option:</source>
          <target state="translated">Следующие опции командной строки изменяют семантику импорта и поэтому могут не передаваться как опция:</target>
        </trans-unit>
        <trans-unit id="932cde1c301ce345d40b274a1f81ff3e5be711e6" translate="yes" xml:space="preserve">
          <source>The following command-specific comments apply:</source>
          <target state="translated">Действуют следующие комментарии к конкретным командам:</target>
        </trans-unit>
        <trans-unit id="d6f2de10386ef19748ad0fa0931b3359b3969227" translate="yes" xml:space="preserve">
          <source>The following config settings can be used to modify &lt;code&gt;git p4&lt;/code&gt; behavior. They all are in the &lt;code&gt;git-p4&lt;/code&gt; section.</source>
          <target state="translated">Следующие настройки конфигурации можно использовать для изменения поведения &lt;code&gt;git p4&lt;/code&gt; . Все они находятся в разделе &lt;code&gt;git-p4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f68ee79cc1f0c0e26a0c766d89a6823644298bab" translate="yes" xml:space="preserve">
          <source>The following configuration variables tell gitweb where to find files. The values of these variables are paths on the filesystem.</source>
          <target state="translated">Следующие конфигурационные переменные сообщают gitweb,где искать файлы.Значения этих переменных-пути в файловой системе.</target>
        </trans-unit>
        <trans-unit id="446ebc694e2441273405a78869483ed3506272c8" translate="yes" xml:space="preserve">
          <source>The following date formats are supported. A frontend should select the format it will use for this import by passing the format name in the --date-format=&amp;lt;fmt&amp;gt; command-line option.</source>
          <target state="translated">Поддерживаются следующие форматы даты. Интерфейс должен выбрать формат, который он будет использовать для этого импорта, передав имя формата в параметре командной строки --date-format = &amp;lt;fmt&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="e77a52167245e31f57d9305063355588365e98e5" translate="yes" xml:space="preserve">
          <source>The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories.</source>
          <target state="translated">Следующее описание делит низкоуровневые команды на команды,которые управляют объектами (в репозитории,индексе и рабочем дереве),команды,которые опрашивают и сравнивают объекты,а также команды,которые перемещают объекты и ссылки между репозиториями.</target>
        </trans-unit>
        <trans-unit id="8ce90b7b29314319d9c33a8b52e106d84ec9670f" translate="yes" xml:space="preserve">
          <source>The following escape sequences (beside &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;) are recognized: &lt;code&gt;\n&lt;/code&gt; for newline character (NL), &lt;code&gt;\t&lt;/code&gt; for horizontal tabulation (HT, TAB) and &lt;code&gt;\b&lt;/code&gt; for backspace (BS). Other char escape sequences (including octal escape sequences) are invalid.</source>
          <target state="translated">Распознаются следующие escape-последовательности (кроме &lt;code&gt;\&quot;&lt;/code&gt; и &lt;code&gt;\\&lt;/code&gt; ): &lt;code&gt;\n&lt;/code&gt; для символа новой строки (NL), &lt;code&gt;\t&lt;/code&gt; для горизонтальной табуляции (HT, TAB) и &lt;code&gt;\b&lt;/code&gt; для возврата на место (BS). Другие escape-последовательности char (включая восьмеричные escape-последовательности) недопустимы.</target>
        </trans-unit>
        <trans-unit id="11e92a0ce8b123a34278f747bf61153deb05c5a4" translate="yes" xml:space="preserve">
          <source>The following example shows three branches, &quot;master&quot;, &quot;fixes&quot; and &quot;mhf&quot;:</source>
          <target state="translated">В следующем примере показаны три ветви:&quot;ведущая&quot;,&quot;исправляет&quot; и &quot;мхф&quot;:</target>
        </trans-unit>
        <trans-unit id="4297ab330b843af6f1af2259ff9a055a87b6bf37" translate="yes" xml:space="preserve">
          <source>The following features from &amp;lsquo;svn log&amp;rsquo; are supported:</source>
          <target state="translated">Поддерживаются следующие функции из svn log:</target>
        </trans-unit>
        <trans-unit id="9b96392c24cd31061920293e2fd2511a8543969f" translate="yes" xml:space="preserve">
          <source>The following flags further affect the behavior when comparing commits (but not trees).</source>
          <target state="translated">Следующие флаги еще больше влияют на поведение при сравнении коммитов (но не деревьев).</target>
        </trans-unit>
        <trans-unit id="c98119f1eba9806e1383e47ef0aa9d751dbdff13" translate="yes" xml:space="preserve">
          <source>The following format are available:</source>
          <target state="translated">Доступен следующий формат:</target>
        </trans-unit>
        <trans-unit id="5f08fc55d496958a337ddcb6a67febfb89f85554" translate="yes" xml:space="preserve">
          <source>The following key/value pairs are common to all events:</source>
          <target state="translated">Следующие пары ключ/значение являются общими для всех событий:</target>
        </trans-unit>
        <trans-unit id="0a5e5ff367236dbd6bf5580d5af5e71ae090b770" translate="yes" xml:space="preserve">
          <source>The following options affect the way the simplification is performed:</source>
          <target state="translated">Следующие опции влияют на способ упрощения:</target>
        </trans-unit>
        <trans-unit id="d99d5d2882d3fb95fadc56a0416699f5b886386d" translate="yes" xml:space="preserve">
          <source>The following options are available in either location:</source>
          <target state="translated">Следующие варианты доступны в любом месте:</target>
        </trans-unit>
        <trans-unit id="6e9dd1ef0925dcf9e09b1e6e501e8d0360e77eba" translate="yes" xml:space="preserve">
          <source>The following options are defined and (under suitable circumstances) set by Git if the remote helper has the &lt;code&gt;option&lt;/code&gt; capability.</source>
          <target state="translated">Следующие параметры определены и (при подходящих обстоятельствах) установлены Git, если удаленный помощник имеет возможность &lt;code&gt;option&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad97d4ffb6c58a93bf3193a5402926d11d214aa1" translate="yes" xml:space="preserve">
          <source>The following options select the commits to be shown:</source>
          <target state="translated">Следующие опции выбирают показываемые фиксации:</target>
        </trans-unit>
        <trans-unit id="04bd1c24e8e494894e5123ce96e6c123a135b194" translate="yes" xml:space="preserve">
          <source>The following options:</source>
          <target state="translated">Следующие варианты:</target>
        </trans-unit>
        <trans-unit id="7b3b3b2ba3a3d71942fecd2cbccdbee3fd847246" translate="yes" xml:space="preserve">
          <source>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.</source>
          <target state="translated">Следующая последовательность пытается перенести заплатку обратно,отступает,потому что код,к которому применяется заплатка,слишком сильно изменился,а затем пытается снова,на этот раз проявляя большую осторожность в сопоставлении строк контекста.</target>
        </trans-unit>
        <trans-unit id="0fb6c7c3c1a2e6361aa6d0f3ddafd309ebc6378c" translate="yes" xml:space="preserve">
          <source>The following sequence checks out the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes &lt;code&gt;hello.c&lt;/code&gt; by mistake, and gets it back from the index.</source>
          <target state="translated">Следующая последовательность проверяет &lt;code&gt;master&lt;/code&gt; ветвь, возвращает &lt;code&gt;Makefile&lt;/code&gt; к двум ревизиям, по ошибке удаляет &lt;code&gt;hello.c&lt;/code&gt; и возвращает его из индекса.</target>
        </trans-unit>
        <trans-unit id="b8a40037f7e020ad1f156eb7f08942ca8112c080" translate="yes" xml:space="preserve">
          <source>The following sequence switches to the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes hello.c by mistake, and gets it back from the index.</source>
          <target state="translated">Следующая последовательность переключает на &lt;code&gt;master&lt;/code&gt; ветвь, возвращает &lt;code&gt;Makefile&lt;/code&gt; к двум ревизиям, по ошибке удаляет hello.c и возвращает его из индекса.</target>
        </trans-unit>
        <trans-unit id="75477915a08ed3777518303fe3302c5a880167a8" translate="yes" xml:space="preserve">
          <source>The following sequences have a special meaning:</source>
          <target state="translated">Следующие последовательности имеют особое значение:</target>
        </trans-unit>
        <trans-unit id="b07d72a39fdd44876a293ab8f917fa6a1014bd8c" translate="yes" xml:space="preserve">
          <source>The following subcommands are available:</source>
          <target state="translated">Доступны следующие подкоманды:</target>
        </trans-unit>
        <trans-unit id="55332124e1bbf00265c49abce68b19cb8696bb39" translate="yes" xml:space="preserve">
          <source>The following syntaxes may be used with them:</source>
          <target state="translated">С ними можно использовать следующие синтаксисы:</target>
        </trans-unit>
        <trans-unit id="f9c489d8b69bf82a63ff4a237dd2bd772b8fb351" translate="yes" xml:space="preserve">
          <source>The following tables show what happens when there are unmerged entries:</source>
          <target state="translated">В следующих таблицах показано,что происходит при наличии неупорядоченных записей:</target>
        </trans-unit>
        <trans-unit id="3cc98c85c7406728df501340aea8c7fdc3f04d78" translate="yes" xml:space="preserve">
          <source>The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions.</source>
          <target state="translated">Следующие советы и хитрости были собраны от различных пользователей быстрого импорта,и предлагаются здесь в качестве предложений.</target>
        </trans-unit>
        <trans-unit id="177a564b8e3982405afb3b516ab4bbb5063d1ee7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; omits blobs larger than n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, &lt;code&gt;blob:limit=1k&lt;/code&gt; is the same as &lt;code&gt;blob:limit=1024&lt;/code&gt;.</source>
          <target state="translated">Форма &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; пропускает большие двоичные объекты размером более n байтов или единиц. n может быть нулевым. Суффиксы k, m и g могут использоваться для обозначения единиц в KiB, MiB или GiB. Например, &lt;code&gt;blob:limit=1k&lt;/code&gt; совпадает с &lt;code&gt;blob:limit=1024&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94349f8d4383b34d05a696da3b05af67f12eec03" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:none&lt;/code&gt; omits all blobs.</source>
          <target state="translated">Форма &lt;code&gt;--filter=blob:none&lt;/code&gt; пропускает все капли.</target>
        </trans-unit>
        <trans-unit id="39c705af761382dd23f074438f9b0e646bf492af" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; can also be used to combined several filters, but this is harder than just repeating the &lt;code&gt;--filter&lt;/code&gt; flag and is usually not necessary. Filters are joined by &lt;code&gt;+&lt;/code&gt; and individual filters are %-encoded (i.e. URL-encoded). Besides the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; characters, the following characters are reserved and also must be encoded: &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt;&lt;code&gt;'`&lt;/code&gt; as well as all characters with ASCII code &amp;lt;= &lt;code&gt;0x20&lt;/code&gt;, which includes space and newline.</source>
          <target state="translated">Форма &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; также может использоваться для объединения нескольких фильтров, но это сложнее, чем просто повторение флага &lt;code&gt;--filter&lt;/code&gt; , и обычно в этом нет необходимости. Фильтры объединяются знаком &lt;code&gt;+&lt;/code&gt; , а отдельные фильтры кодируются% (т. Е. Кодируются URL). Помимо символов &lt;code&gt;+&lt;/code&gt; и &lt;code&gt;%&lt;/code&gt; , следующие символы зарезервированы и также должны быть закодированы: &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt; &lt;code&gt;'`&lt;/code&gt; ,А также все символы с кодом ASCII &amp;lt; = &lt;code&gt;0x20&lt;/code&gt; , который включает пробел и новую строку.</target>
        </trans-unit>
        <trans-unit id="d52505ec75878146eb9054dceb4728d58b485513" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; uses a sparse-checkout specification contained in the blob (or blob-expression) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; to omit blobs that would not be not required for a sparse checkout on the requested refs.</source>
          <target state="translated">Форма &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; использует спецификацию sparse-checkout, содержащуюся в blob (или blob-expression) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; , чтобы опустить капли, которые не требуются для разреженной проверки на запрашиваемые исх.</target>
        </trans-unit>
        <trans-unit id="ef46a11218e9457b2745a05e86c211527bd23b7c" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; omits all blobs and trees whose depth from the root tree is &amp;gt;= &amp;lt;depth&amp;gt; (minimum depth if an object is located at multiple depths in the commits traversed). &amp;lt;depth&amp;gt;=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). &amp;lt;depth&amp;gt;=1 will include only the tree and blobs which are referenced directly by a commit reachable from &amp;lt;commit&amp;gt; or an explicitly-given object. &amp;lt;depth&amp;gt;=2 is like &amp;lt;depth&amp;gt;=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.</source>
          <target state="translated">Форма &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; исключает все капли и деревья, глубина которых от корневого дерева&amp;gt; = &amp;lt;depth&amp;gt; (минимальная глубина, если объект расположен на нескольких глубинах в пройденных коммитах). &amp;lt;depth&amp;gt; = 0 не будет включать никакие деревья или капли, если они явно не включены в командную строку (или стандартный ввод, если используется --stdin). &amp;lt;depth&amp;gt; = 1 будет включать только дерево и большие двоичные объекты, на которые напрямую ссылается фиксация, доступная из &amp;lt;commit&amp;gt; или явно заданного объекта. &amp;lt;depth&amp;gt; = 2 похож на &amp;lt;depth&amp;gt; = 1, но вместе с тем включает деревья и капли, еще на один уровень, удаленный из явно заданного коммита или дерева.</target>
        </trans-unit>
        <trans-unit id="143c72f9a0abe1adb065cd1c00c0271a08c274c4" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.</source>
          <target state="translated">Форма &lt;code&gt;--missing=allow-any&lt;/code&gt; позволит продолжить обход объекта, если обнаружен отсутствующий объект. Недостающие объекты будут автоматически исключены из результатов.</target>
        </trans-unit>
        <trans-unit id="280716e3ccf86616960848b089fdadef81ba797d" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing object will raise an error.</source>
          <target state="translated">Форма &lt;code&gt;--missing=allow-promisor&lt;/code&gt; похожа на &lt;code&gt;allow-any&lt;/code&gt; , но позволяет продолжить обход объекта только для EXPECTED promisor отсутствующих объектов. Неожиданно отсутствующий объект вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="563d9e750d01dbe920d57035d16bed3d91b9aea6" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.</source>
          <target state="translated">Форма &lt;code&gt;--missing=allow-promisor&lt;/code&gt; похожа на &lt;code&gt;allow-any&lt;/code&gt; , но позволяет продолжить обход объекта только для EXPECTED promisor отсутствующих объектов. Неожиданно отсутствующие объекты вызовут ошибку.</target>
        </trans-unit>
        <trans-unit id="28c618ed732782b866de4c7dcf716daa2ac64119" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">Форма &lt;code&gt;--missing=error&lt;/code&gt; запрашивает остановку пакетных объектов с ошибкой, если обнаружен отсутствующий объект. Это действие по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2ed32158adb2f2f236ac5307d5ba7c30f0630796" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that rev-list stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">Форма &lt;code&gt;--missing=error&lt;/code&gt; запрашивает остановку списка rev-list с ошибкой, если обнаружен отсутствующий объект. Это действие по умолчанию.</target>
        </trans-unit>
        <trans-unit id="67e4b67693941fe412533d5210bde2a413de8fb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=print&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will also print a list of the missing objects. Object IDs are prefixed with a &amp;ldquo;?&amp;rdquo; character.</source>
          <target state="translated">Форма &lt;code&gt;--missing=print&lt;/code&gt; похожа на &lt;code&gt;allow-any&lt;/code&gt; , но также выводит список отсутствующих объектов. Перед идентификаторами объектов стоит знак &amp;laquo;?&amp;raquo;. персонаж.</target>
        </trans-unit>
        <trans-unit id="09994cb2384da5eddbe0ae0a9a1ceca76d8c8bcc" translate="yes" xml:space="preserve">
          <source>The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;. The colon can be omitted when &amp;lt;dst&amp;gt; is empty. &amp;lt;src&amp;gt; is typically a ref, but it can also be a fully spelled hex object name.</source>
          <target state="translated">Формат параметра &amp;lt;refspec&amp;gt; - необязательный плюс &lt;code&gt;+&lt;/code&gt; , за которым следует исходный &amp;lt;src&amp;gt;, за которым следует двоеточие &lt;code&gt;:&lt;/code&gt; , за которым следует ссылка назначения &amp;lt;dst&amp;gt;. Если &amp;lt;dst&amp;gt; пуст, двоеточие можно опустить. &amp;lt;src&amp;gt; обычно является ссылкой, но также может быть полностью записанным шестнадцатеричным именем объекта.</target>
        </trans-unit>
        <trans-unit id="05c09db4c870e826391cf6ebde5a8cc33d2791f6" translate="yes" xml:space="preserve">
          <source>The format of these files is username followed by the encrypted password, for example:</source>
          <target state="translated">Формат этих файлов-имя пользователя и зашифрованный пароль:</target>
        </trans-unit>
        <trans-unit id="65670970ee487305077ce344ca1fb6c36a889cee" translate="yes" xml:space="preserve">
          <source>The former lets your shell expand the fileglob, and you are asking the dot-C files in your working tree to be overwritten with the version in the index. The latter passes the &lt;code&gt;*.c&lt;/code&gt; to Git, and you are asking the paths in the index that match the pattern to be checked out to your working tree. After running &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt;, you will &lt;code&gt;not&lt;/code&gt; see &lt;code&gt;hello.c&lt;/code&gt; in your working tree with the former, but with the latter you will.</source>
          <target state="translated">Первый позволяет вашей оболочке расширять файловый глобус, и вы запрашиваете, чтобы файлы dot-C в вашем рабочем дереве были перезаписаны версией в индексе. Последний передает &lt;code&gt;*.c&lt;/code&gt; в Git, и вы запрашиваете пути в индексе, соответствующие шаблону, для извлечения в ваше рабочее дерево. После запуска &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt; , вы &lt;code&gt;not&lt;/code&gt; увидите &lt;code&gt;hello.c&lt;/code&gt; в своем рабочем дереве с первым, но со вторым вы увидите.</target>
        </trans-unit>
        <trans-unit id="b363974f459c2a2b237a919650aa9dc9f75161d2" translate="yes" xml:space="preserve">
          <source>The frontend must specify the number of bytes of data.</source>
          <target state="translated">Во фронтенде должно быть указано количество байт данных.</target>
        </trans-unit>
        <trans-unit id="23957db0f038e6b4263285c2923ad6ce72a805ca" translate="yes" xml:space="preserve">
          <source>The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.</source>
          <target state="translated">Полное имя объекта SHA-1 (40-байтовая шестнадцатеричная строка),или ведущая подстрока,уникальная в репозитории.Например,dae86e1950b1277e545cee180551750029cfe735 и dae86e имена одного и того же объекта коммита,если в вашем репозитории нет другого объекта,чье имя начинается с dae86e.</target>
        </trans-unit>
        <trans-unit id="ce332106cb9361add9aaf31aea030a425aeed7be" translate="yes" xml:space="preserve">
          <source>The full name is occasionally useful if, for example, there ever exists a tag and a branch with the same name.</source>
          <target state="translated">Полное имя иногда полезно,если,например,когда-нибудь существует тег и ветка с таким же именем.</target>
        </trans-unit>
        <trans-unit id="d24187cae372eb76b2a26570ccfd9def8c8abdf6" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">Полный набор шаблонов допускает произвольные совпадения шаблонов и сложные правила включения / исключения. Это может привести к совпадению шаблонов O (N * M) при обновлении индекса, где N - количество шаблонов, а M - количество путей в индексе. Чтобы &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; эту проблему с производительностью, можно использовать более ограниченный набор шаблонов, когда включен core.spareCheckoutCone .</target>
        </trans-unit>
        <trans-unit id="6d3e98918a57498bee35c9ef416c5932bb448c1f" translate="yes" xml:space="preserve">
          <source>The full syntax for a p4 view is documented in &lt;code&gt;p4 help views&lt;/code&gt;. &lt;code&gt;git p4&lt;/code&gt; knows only a subset of the view syntax. It understands multi-line mappings, overlays with &lt;code&gt;+&lt;/code&gt;, exclusions with &lt;code&gt;-&lt;/code&gt; and double-quotes around whitespace. Of the possible wildcards, &lt;code&gt;git p4&lt;/code&gt; only handles &lt;code&gt;&amp;hellip;​&lt;/code&gt;, and only when it is at the end of the path. &lt;code&gt;git p4&lt;/code&gt; will complain if it encounters an unhandled wildcard.</source>
          <target state="translated">Полный синтаксис представления p4 задокументирован в представлениях справки &lt;code&gt;p4 help views&lt;/code&gt; . &lt;code&gt;git p4&lt;/code&gt; знает только подмножество синтаксиса представления. Он понимает многострочные сопоставления, наложения с &lt;code&gt;+&lt;/code&gt; , исключения с &lt;code&gt;-&lt;/code&gt; и двойные кавычки вокруг пробелов. Из возможных масок, &lt;code&gt;git p4&lt;/code&gt; только ручка &lt;code&gt;&amp;hellip;​&lt;/code&gt; и только тогда , когда он находится в конце пути. &lt;code&gt;git p4&lt;/code&gt; будет жаловаться, если встретит необработанный подстановочный знак.</target>
        </trans-unit>
        <trans-unit id="18d1519c9cf5420b92be3f082cd6f0aa89c3d260" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;skip_commit&lt;/code&gt; is defined as follows:</source>
          <target state="translated">Функция &lt;code&gt;skip_commit&lt;/code&gt; определяется следующим образом:</target>
        </trans-unit>
        <trans-unit id="af7dd50b5e9b3d3ec2ae519f399794527002dc23" translate="yes" xml:space="preserve">
          <source>The functions defined by the Trace2 API are declared and documented in &lt;code&gt;trace2.h&lt;/code&gt;. It defines the API functions and wrapper macros for Trace2.</source>
          <target state="translated">Функции, определенные API Trace2, объявлены и задокументированы в &lt;code&gt;trace2.h&lt;/code&gt; . Он определяет функции API и макросы оболочки для Trace2.</target>
        </trans-unit>
        <trans-unit id="e5521fd46bed9d589b56b651d5f3ef04e9a3b2a8" translate="yes" xml:space="preserve">
          <source>The future of bisecting</source>
          <target state="translated">Будущее биссекции</target>
        </trans-unit>
        <trans-unit id="2aa4427c10c7d5c13ef7bbb9898f5fea28090dd1" translate="yes" xml:space="preserve">
          <source>The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment.</source>
          <target state="translated">Общая идея заключается в следующем:мы генерируем матрицу стоимости между коммитами в обоих диапазонах коммитов,затем решаем наименее затратное задание.</target>
        </trans-unit>
        <trans-unit id="0339eef2339eb8367ea8564b9ff6721cd9dea407" translate="yes" xml:space="preserve">
          <source>The git commit is created relative to the current origin revision (HEAD by default). A parent commit is created based on the origin, and then the unshelve commit is created based on that.</source>
          <target state="translated">Фиксация git'а создаётся относительно текущей ревизии источника (HEAD по умолчанию).Родительская коммиссия создаётся на основе исходной ревизии,а затем на основе неразборчивой коммисии.</target>
        </trans-unit>
        <trans-unit id="a5bbcd1beb35762403be84a14e62e0a4eb5d5226" translate="yes" xml:space="preserve">
          <source>The git object database</source>
          <target state="translated">База данных git-объектов</target>
        </trans-unit>
        <trans-unit id="80d403b9b878573aec88e9c705123dc6feedf769" translate="yes" xml:space="preserve">
          <source>The gitweb CGI script for viewing Git repositories over the web uses a perl script fragment as its configuration file. You can set variables using &quot;&lt;code&gt;our $variable = value&lt;/code&gt;&quot;; text from a &quot;#&quot; character until the end of a line is ignored. See &lt;strong&gt;perlsyn&lt;/strong&gt;(1) for details.</source>
          <target state="translated">Сценарий Gitweb CGI для просмотра репозиториев Git через Интернет использует фрагмент сценария Perl в качестве файла конфигурации. Вы можете установить переменные, используя &quot; &lt;code&gt;our $variable = value&lt;/code&gt; &quot;; текст от символа &quot;#&quot; до конца строки игнорируется. Подробности смотрите в &lt;strong&gt;perlsyn&lt;/strong&gt; (1).</target>
        </trans-unit>
        <trans-unit id="a1a6c42c76028a67bf39dd75b77a2307812be731" translate="yes" xml:space="preserve">
          <source>The gitweb cgi script provides users an easy way to browse your project&amp;rsquo;s revisions, file contents and logs without having to install Git. Features like RSS/Atom feeds and blame/annotation details may optionally be enabled.</source>
          <target state="translated">Сценарий gitweb cgi предоставляет пользователям простой способ просматривать редакции вашего проекта, содержимое файлов и журналы без установки Git. При желании могут быть включены такие функции, как каналы RSS / Atom и сведения об авторстве / аннотации.</target>
        </trans-unit>
        <trans-unit id="eefcb42be74db518327d9c82beb9a165d884846e" translate="yes" xml:space="preserve">
          <source>The gitweb features that are configurable via &lt;code&gt;%feature&lt;/code&gt; hash are listed below. This should be a complete list, but ultimately the authoritative and complete list is in gitweb.cgi source code, with features described in the comments.</source>
          <target state="translated">Ниже перечислены функции gitweb, которые можно настроить с помощью хэша &lt;code&gt;%feature&lt;/code&gt; . Это должен быть полный список, но в конечном итоге авторитетный и полный список находится в исходном коде gitweb.cgi с функциями, описанными в комментариях.</target>
        </trans-unit>
        <trans-unit id="bee84a897df9efb668b9aee969a1e660ed8af0a4" translate="yes" xml:space="preserve">
          <source>The gitweb.extraBranchRefs is actually a multi-valued configuration variable, so following example is also correct and the result is the same as of the snippet above:</source>
          <target state="translated">gitweb.extraBranchRefs на самом деле является многозначной конфигурационной переменной,поэтому следующий пример также корректен,и результат такой же,как и в приведённом выше фрагменте:</target>
        </trans-unit>
        <trans-unit id="ab9a5e4603e46ba18e0a4c5efe881c7ac8def35b" translate="yes" xml:space="preserve">
          <source>The given URL is recorded into &lt;code&gt;.gitmodules&lt;/code&gt; for use by subsequent users cloning the superproject. If the URL is given relative to the superproject&amp;rsquo;s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject&amp;rsquo;s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in &lt;code&gt;.gitmodules&lt;/code&gt;.</source>
          <target state="translated">Данный URL-адрес записывается в &lt;code&gt;.gitmodules&lt;/code&gt; для использования последующими пользователями, клонирующими суперпроект. Если URL-адрес указан относительно репозитория суперпроекта, предполагается, что репозитории суперпроекта и подмодулей будут храниться вместе в одном и том же относительном местоположении, и необходимо указать только URL-адрес суперпроекта. git-submodule правильно найдет подмодуль, используя относительный URL-адрес в &lt;code&gt;.gitmodules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1190edfebfe2406cf333713a0e461379865b033f" translate="yes" xml:space="preserve">
          <source>The goal of this tutorial is to introduce two fundamental pieces of Git&amp;rsquo;s architecture&amp;mdash;​the object database and the index file&amp;mdash;​and to provide the reader with everything necessary to understand the rest of the Git documentation.</source>
          <target state="translated">Цель этого руководства - познакомить с двумя фундаментальными частями архитектуры Git - объектной базой данных и индексным файлом - и предоставить читателю все необходимое для понимания остальной части документации Git.</target>
        </trans-unit>
        <trans-unit id="880a291c14c1099392ebdd9b73ec08c93b7220d1" translate="yes" xml:space="preserve">
          <source>The hard case</source>
          <target state="translated">Твердый чехол</target>
        </trans-unit>
        <trans-unit id="7d2a187748caf680c0e66173f60176ec60ea02ab" translate="yes" xml:space="preserve">
          <source>The header consists of 256 4-byte network byte order integers. N-th entry of this table records the number of objects in the corresponding pack, the first byte of whose object name is less than or equal to N. This is called the &lt;code&gt;first-level fan-out&lt;/code&gt; table.</source>
          <target state="translated">Заголовок состоит из 256 4-байтовых целых чисел сетевого порядка байтов. N-я запись этой таблицы записывает количество объектов в соответствующем пакете, первый байт имени объекта которого меньше или равен N. Это называется таблицей &lt;code&gt;first-level fan-out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e2dd021a6a8dc94bfb40a62a04904f17b8f1dab" translate="yes" xml:space="preserve">
          <source>The header is followed by number of object entries, each of which looks like this:</source>
          <target state="translated">За заголовком следует количество записей объекта,каждая из которых выглядит так:</target>
        </trans-unit>
        <trans-unit id="10743ced5c1563e940127b440ba806235a399ac8" translate="yes" xml:space="preserve">
          <source>The header is followed by sorted 24-byte entries, one entry per object in the pack. Each entry is:</source>
          <target state="translated">За заголовком следуют отсортированные 24-байтовые записи,по одной записи на объект в пакете.Каждая запись:</target>
        </trans-unit>
        <trans-unit id="03910dca7f1c0af7f3d0e6986f455aceaec86f05" translate="yes" xml:space="preserve">
          <source>The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information.</source>
          <target state="translated">Заголовок электронного письма настраивается с помощью опций командной строки.Если он не указан в командной строке,пользователю будет предложено предоставить необходимую информацию с помощью интерфейса ReadLine.</target>
        </trans-unit>
        <trans-unit id="53d28fdf80ee055eff1005765033449c285d4f79" translate="yes" xml:space="preserve">
          <source>The hook always runs after the automatic note copying (see &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) has happened, and thus has access to these notes.</source>
          <target state="translated">Хук всегда запускается после того, как произошло автоматическое копирование заметок (см. &amp;laquo;Notes.rewrite. &amp;lt;command&amp;gt;&amp;raquo; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; ), и, таким образом, имеет доступ к этим заметкам.</target>
        </trans-unit>
        <trans-unit id="55997df4465d2b793292e1300e70ff2f9e1a3588" translate="yes" xml:space="preserve">
          <source>The hook executes once for each ref to be updated, and takes three parameters:</source>
          <target state="translated">Крюк выполняет один раз для каждой ссылки,которая будет обновлена,и принимает три параметра:</target>
        </trans-unit>
        <trans-unit id="6422fdbff7a8b80abf6e11b9c756369981239875" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the message file in place, and can be used to normalize the message into some project standard format. It can also be used to refuse the commit after inspecting the message file.</source>
          <target state="translated">Крючок позволяет редактировать файл сообщения на месте,и может быть использован для нормализации сообщения в каком-либо стандартном формате проекта.Он также может быть использован для отказа от фиксации после просмотра файла сообщения.</target>
        </trans-unit>
        <trans-unit id="7dd8785c8f6fdd3a8a45999afa9f773631b556f1" translate="yes" xml:space="preserve">
          <source>The hook receives a list of the rewritten commits on stdin, in the format</source>
          <target state="translated">Крюк получает список переписанных коммитов на stdin,в формате</target>
        </trans-unit>
        <trans-unit id="ffb0d43685532aa46e893849969758ab23367451" translate="yes" xml:space="preserve">
          <source>The hook receives the commit with which the tip of the current branch is going to be updated. It can exit with a non-zero status to refuse the push (when it does so, it must not modify the index or the working tree). Or it can make any necessary changes to the working tree and to the index to bring them to the desired state when the tip of the current branch is updated to the new commit, and exit with a zero status.</source>
          <target state="translated">Крюк получает коммит,с помощью которого будет обновляться кончик текущей ветки.Он может выйти с ненулевым статусом,чтобы отказать в нажатии (при этом он не должен изменять ни индекс,ни рабочее дерево).Или же он может внести любые необходимые изменения в рабочее дерево и в индекс,чтобы привести их в желаемое состояние при обновлении вершины текущей ветки до нового коммита,и выйти с нулевым статусом.</target>
        </trans-unit>
        <trans-unit id="6e0236cadc345b5114c4c6984e7438ed153e1f2f" translate="yes" xml:space="preserve">
          <source>The hook should exit with non-zero status if it wants to disallow updating the named ref. Otherwise it should exit with zero.</source>
          <target state="translated">Крюк должен выйти с ненулевым статусом,если он хочет запретить обновление именованного справочника.В противном случае он должен выйти с нулем.</target>
        </trans-unit>
        <trans-unit id="9739d79c49b82b53238e48aeefee9c342d93a499" translate="yes" xml:space="preserve">
          <source>The hook should output to stdout the list of all files in the working directory that may have changed since the requested time. The logic should be inclusive so that it does not miss any potential changes. The paths should be relative to the root of the working directory and be separated by a single NUL.</source>
          <target state="translated">Крюк должен выводить в stdout список всех файлов в рабочей директории,которые могли измениться со времени запроса.Логика должна быть всеохватывающей,чтобы не пропустить никаких потенциальных изменений.Пути должны быть относительно корня рабочей директории и разделены одним NUL.</target>
        </trans-unit>
        <trans-unit id="022998a9843b7be307eb2d587f13704cf2ce86bd" translate="yes" xml:space="preserve">
          <source>The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:</source>
          <target state="translated">Горизонтальная линия истории A---Q принимается за первую родительскую линию каждого слияния.Коммиты:</target>
        </trans-unit>
        <trans-unit id="bdf0ebdfb4273a6fce7952dfa28834b6e411cd7f" translate="yes" xml:space="preserve">
          <source>The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to &quot;ssh&quot;.</source>
          <target state="translated">Гипотетические записи команды прокси на самом деле имеют постфикс,чтобы определить,к какому URL они относятся.Вот как изменить запись для kernel.org на &quot;ssh&quot;.</target>
        </trans-unit>
        <trans-unit id="4399284bfb632a08cce3f3533db563320f49af23" translate="yes" xml:space="preserve">
          <source>The id of a tree object to diff against.</source>
          <target state="translated">Идентификатор древовидного объекта для сравнения.</target>
        </trans-unit>
        <trans-unit id="0505b9e9f78e78efa1c8b76bc422638cba05b1b7" translate="yes" xml:space="preserve">
          <source>The id of a tree object.</source>
          <target state="translated">Идентификатор объекта дерева.</target>
        </trans-unit>
        <trans-unit id="2e60e84271eec03fd28b067b32c84bb5fbe76999" translate="yes" xml:space="preserve">
          <source>The id of the tree object(s) to be read/merged.</source>
          <target state="translated">Идентификатор объекта(ов)дерева,который должен быть прочитан(ы)или погружен(ы).</target>
        </trans-unit>
        <trans-unit id="fb9074ec22bab96e3e97d4855db9bfaed224187c" translate="yes" xml:space="preserve">
          <source>The idea is that every 3 test for example, &quot;git bisect&quot; could ask the user to test a commit that has already been found to be &quot;good&quot; or &quot;bad&quot; (because one of its descendants or one of its ancestors has been found to be &quot;good&quot; or &quot;bad&quot; respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log.</source>
          <target state="translated">Идея заключается в том,что каждые 3 теста,например,&quot;git-бисект&quot; может попросить пользователя протестировать коммит,который уже был признан &quot;хорошим&quot; или &quot;плохим&quot; (потому что один из его потомков или один из его предков был признан &quot;хорошим&quot; или &quot;плохим&quot; соответственно).Если случится так,что коммит ранее был ошибочно классифицирован,то биссекция может быть прервана досрочно,надеюсь,до того,как будет сделано слишком много ошибок.Тогда пользователю придётся посмотреть,что произошло,а затем перезапустить биссекцию,используя фиксированный лог биссектрис.</target>
        </trans-unit>
        <trans-unit id="b3a07b8c786a1b03697e9ded467b22cd2ece1ab4" translate="yes" xml:space="preserve">
          <source>The idea is to manually tell &lt;code&gt;git rebase&lt;/code&gt; &quot;where the old &lt;code&gt;subsystem&lt;/code&gt; ended and your &lt;code&gt;topic&lt;/code&gt; began&quot;, that is, what the old merge base between them was. You will have to find a way to name the last commit of the old &lt;code&gt;subsystem&lt;/code&gt;, for example:</source>
          <target state="translated">Идея состоит в том, чтобы вручную указать &lt;code&gt;git rebase&lt;/code&gt; , &amp;laquo;где закончилась старая &lt;code&gt;subsystem&lt;/code&gt; и началась ваша &lt;code&gt;topic&lt;/code&gt; &amp;raquo;, то есть какова была старая база слияния между ними. Вам нужно будет найти способ назвать последний коммит старой &lt;code&gt;subsystem&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="1ff2a3a30d68d12ef6b058f357f43e3bd9cd4f0f" translate="yes" xml:space="preserve">
          <source>The idx files to verify.</source>
          <target state="translated">IDX-файлы для проверки.</target>
        </trans-unit>
        <trans-unit id="fd29bd486dc43b124e6d98a808e18b86c2905ae4" translate="yes" xml:space="preserve">
          <source>The import checks out from CVS every revision of every file. Reportedly cvsimport can average some twenty revisions per second, so for a medium-sized project this should not take more than a couple of minutes. Larger projects or remote repositories may take longer.</source>
          <target state="translated">Импорт проверяется из CVS каждой ревизии каждого файла.Сообщается,что cvsimport может в среднем составлять около двадцати ревизий в секунду,так что для среднего проекта это не должно занять более пары минут.Более крупные проекты или удалённые репозитории могут занимать больше времени.</target>
        </trans-unit>
        <trans-unit id="69f04e00f7076b8b130e67c7134e53f7f1076bf2" translate="yes" xml:space="preserve">
          <source>The import is incremental, so if you call it again next month it will fetch any CVS updates that have been made in the meantime. For this to work, you must not modify the imported branches; instead, create new branches for your own changes, and merge in the imported branches as necessary.</source>
          <target state="translated">Импорт является инкрементальным,так что если вы позвоните ему снова в следующем месяце,он будет получать любые CVS обновления,которые были сделаны за это время.Чтобы это сработало,вы не должны изменять импортированные ветки;вместо этого,создайте новые ветки для собственных изменений и слияйте импортированные ветки по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="807035ab1f5be4f0cb3563dc9b49740571ca0fa4" translate="yes" xml:space="preserve">
          <source>The index</source>
          <target state="translated">Индекс</target>
        </trans-unit>
        <trans-unit id="4284ed429265f3c1afc30e4fc09197d88352698c" translate="yes" xml:space="preserve">
          <source>The index and the working tree are adjusted as if you had previously run &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt;. This allows you to start a new history that records a set of paths similar to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; by easily running &lt;code&gt;git commit -a&lt;/code&gt; to make the root commit.</source>
          <target state="translated">Индекс и рабочее дерево настраиваются так, как если бы вы ранее запускали &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt; . Это позволяет вам начать новую историю, которая записывает набор путей, подобных &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; , путем простого выполнения &lt;code&gt;git commit -a&lt;/code&gt; для выполнения корневого коммита.</target>
        </trans-unit>
        <trans-unit id="0818281aa21612fb5fa362015c64c5645d861084" translate="yes" xml:space="preserve">
          <source>The index contains all the information necessary to generate a single (uniquely determined) tree object.</source>
          <target state="translated">Индекс содержит всю информацию,необходимую для генерации одного (однозначно определенного)объекта дерева.</target>
        </trans-unit>
        <trans-unit id="3d9fb9e020c0d003a42d72f87f16ba2ba38226e6" translate="yes" xml:space="preserve">
          <source>The index enables fast comparisons between the tree object it defines and the working tree.</source>
          <target state="translated">Индекс позволяет быстро сравнивать определяемый им объект дерева с рабочим деревом.</target>
        </trans-unit>
        <trans-unit id="eb65460c6179ccddcd4479166e9da44d8f5c40d8" translate="yes" xml:space="preserve">
          <source>The index file</source>
          <target state="translated">Файл индекса</target>
        </trans-unit>
        <trans-unit id="181ab401ce7a15640077d5cb413c24fc6eb6a97e" translate="yes" xml:space="preserve">
          <source>The index file is a cache of the state of a directory tree, used to create commits, check out working directories, and hold the various trees involved in a merge.</source>
          <target state="translated">Индексный файл представляет собой кэш состояния дерева каталогов,используемый для создания коммитов,извлечения рабочих каталогов и хранения различных деревьев,участвующих в слиянии.</target>
        </trans-unit>
        <trans-unit id="a98935eae61bfe66b9928e790965f624bf2f8b5b" translate="yes" xml:space="preserve">
          <source>The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.</source>
          <target state="translated">Файл индекса инициализируется списком всех путей и,для каждого пути,блочным объектом и набором атрибутов.Объект-объект представляет содержимое файла в качестве заголовка текущей ветки.Атрибуты (время последнего изменения,размер и т.д.)берутся из соответствующего файла в рабочем дереве.Последующие изменения в рабочем дереве можно найти,сравнив эти атрибуты.Индекс может обновляться новым содержимым,а из содержимого,хранящегося в индексе,могут создаваться новые коммиты.</target>
        </trans-unit>
        <trans-unit id="803387e9a63472a3287bdc2446032cf6e023e1d9" translate="yes" xml:space="preserve">
          <source>The index is a binary file (generally kept in &lt;code&gt;.git/index&lt;/code&gt;) containing a sorted list of path names, each with permissions and the SHA-1 of a blob object; &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; can show you the contents of the index:</source>
          <target state="translated">Индекс - это двоичный файл (обычно хранящийся в &lt;code&gt;.git/index&lt;/code&gt; ), содержащий отсортированный список имен путей, каждое с разрешениями и SHA-1 объекта blob; &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt; может показать вам содержимое индекса:</target>
        </trans-unit>
        <trans-unit id="a9316182499a37d7c3626ac01aa8aab4c013b473" translate="yes" xml:space="preserve">
          <source>The index is also capable of storing multiple entries (called &quot;stages&quot;) for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.</source>
          <target state="translated">Индекс также способен хранить несколько записей (называемых &quot;этапами&quot;)для данного патнамента.Эти этапы используются для хранения различных неупорядоченных версий файла в процессе слияния.</target>
        </trans-unit>
        <trans-unit id="188f5a2d7cb942916f4771a1884b995e88b4142c" translate="yes" xml:space="preserve">
          <source>The index is thus a sort of temporary staging area, which is filled with a tree which you are in the process of working on.</source>
          <target state="translated">Таким образом,индекс представляет собой своего рода временную инсценировочную область,которая заполняется деревом,над которым вы работаете.</target>
        </trans-unit>
        <trans-unit id="272f4c7f98ef3d0d8ac3fea3ee0b1455507c7b6c" translate="yes" xml:space="preserve">
          <source>The index is updated after successful completion, but the change must still be committed.</source>
          <target state="translated">Индекс обновляется после успешного завершения,но изменение все равно должно быть зафиксировано.</target>
        </trans-unit>
        <trans-unit id="aaf3f3d73cad6f7ed8d83d0912688100fa696756" translate="yes" xml:space="preserve">
          <source>The index line includes the blob object names before and after the change. The &amp;lt;mode&amp;gt; is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.</source>
          <target state="translated">Строка индекса включает имена больших двоичных объектов до и после изменения. &amp;lt;Режим&amp;gt; включается, если режим файла не изменяется; в противном случае отдельные строки указывают старый и новый режим.</target>
        </trans-unit>
        <trans-unit id="0c2192b5aebec33a414387c35e4e32f7ffc2561e" translate="yes" xml:space="preserve">
          <source>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using &lt;code&gt;-f&lt;/code&gt; will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using &lt;code&gt;--ours&lt;/code&gt; or &lt;code&gt;--theirs&lt;/code&gt;. With &lt;code&gt;-m&lt;/code&gt;, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</source>
          <target state="translated">Индекс может содержать не объединенные записи из-за предыдущего неудачного объединения. По умолчанию, если вы попытаетесь извлечь такую ​​запись из индекса, операция извлечения завершится ошибкой и ничего не будет извлечено. Использование &lt;code&gt;-f&lt;/code&gt; игнорирует эти несвязанные записи. Содержимое с определенной стороны слияния можно извлечь из индекса с помощью &lt;code&gt;--ours&lt;/code&gt; или &lt;code&gt;--theirs&lt;/code&gt; . С помощью &lt;code&gt;-m&lt;/code&gt; изменения, внесенные в файл рабочего дерева, можно отменить, чтобы воссоздать исходный конфликтующий результат слияния.</target>
        </trans-unit>
        <trans-unit id="4d0d51f29d49355316c3cef38c96a8eb5dfc2a8a" translate="yes" xml:space="preserve">
          <source>The index must be in a fully merged state.</source>
          <target state="translated">Индекс должен быть в полностью объединенном состоянии.</target>
        </trans-unit>
        <trans-unit id="76af7fc7918327fcfae98949c1f8a57aa6273691" translate="yes" xml:space="preserve">
          <source>The information &lt;code&gt;git rerere&lt;/code&gt; records is also used when running &lt;code&gt;git rebase&lt;/code&gt;. After blowing away the test merge and continuing development on the topic branch:</source>
          <target state="translated">Информация о записях &lt;code&gt;git rerere&lt;/code&gt; также используется при запуске &lt;code&gt;git rebase&lt;/code&gt; . После удаления тестового слияния и продолжения разработки в тематической ветке:</target>
        </trans-unit>
        <trans-unit id="15901a24c7f8cf8a87522005a6e5af387df87a55" translate="yes" xml:space="preserve">
          <source>The information regarding a particular file, stored in the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;. An index entry can be unmerged, if a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; was started, but not yet finished (i.e. if the index contains multiple versions of that file).</source>
          <target state="translated">Информация о конкретном файле, хранящаяся в &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; . Запись индекса может быть отключена, если &lt;a href=&quot;#def_merge&quot;&gt;объединение&lt;/a&gt; было начато, но еще не завершено (т.е. если индекс содержит несколько версий этого файла).</target>
        </trans-unit>
        <trans-unit id="e1b41d54924f3d005ef481db0b83a44bcb5b9a26" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;git svn clone&lt;/code&gt; can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use &lt;code&gt;git svn&lt;/code&gt; to interact with the same Subversion repository, you can do the initial &lt;code&gt;git svn clone&lt;/code&gt; to a repository on a server and have each person clone that repository with &lt;code&gt;git clone&lt;/code&gt;:</source>
          <target state="translated">Первоначальный &lt;code&gt;git svn clone&lt;/code&gt; может занять довольно много времени (особенно для больших репозиториев Subversion). Если несколько человек (или один человек с несколькими машинами) хотят использовать &lt;code&gt;git svn&lt;/code&gt; для взаимодействия с одним и тем же репозиторием Subversion, вы можете выполнить начальное &lt;code&gt;git svn clone&lt;/code&gt; в репозиторий на сервере и попросить каждого человека клонировать этот репозиторий с помощью &lt;code&gt;git clone&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="086eba2d4da1f4350d7506d860bddbb6a3656718" translate="yes" xml:space="preserve">
          <source>The initial clone may be time-consuming for a large project, but you will only need to clone once.</source>
          <target state="translated">Первоначальный клон может занять много времени для большого проекта,но клонировать нужно будет только один раз.</target>
        </trans-unit>
        <trans-unit id="de40e4660568a286f9924fcf84aa107b9295fcd9" translate="yes" xml:space="preserve">
          <source>The initial revision lays the foundation for almost everything Git has today, but is small enough to read in one sitting.</source>
          <target state="translated">Первоначальная ревизия закладывает основу почти для всего,что есть у Git'а сегодня,но достаточно мала,чтобы читать за один присест.</target>
        </trans-unit>
        <trans-unit id="c62040180edff3420ed3a70f2f1e520bccaa26ac" translate="yes" xml:space="preserve">
          <source>The insane thing. You really want to call the new version &quot;X&quot; too, &lt;code&gt;even though&lt;/code&gt; others have already seen the old one. So just use &lt;code&gt;git tag -f&lt;/code&gt; again, as if you hadn&amp;rsquo;t already published the old one.</source>
          <target state="translated">Безумие. Вы действительно хотите назвать новую версию &quot;X&quot;, &lt;code&gt;even though&lt;/code&gt; другие уже видели старую. Так что просто снова используйте &lt;code&gt;git tag -f&lt;/code&gt; , как будто вы еще не опубликовали старую версию.</target>
        </trans-unit>
        <trans-unit id="861707a12241605e66eb9230fb32f3c54a08448e" translate="yes" xml:space="preserve">
          <source>The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.</source>
          <target state="translated">Целью этой опции является выбор и выбор строк патча для применения,или даже изменение содержимого строк для постановки.Это может быть быстрее и гибче,чем использование интерактивного селектора.Однако,легко запутаться и создать патч,который не применим к индексу.См.раздел Редактирование патчей ниже.</target>
        </trans-unit>
        <trans-unit id="44c76b656c6ccb35aba2b96c920b5e782121a3bc" translate="yes" xml:space="preserve">
          <source>The interactive backend drops commits by default that started empty and halts if it hits a commit that ended up empty. The &lt;code&gt;--keep-empty&lt;/code&gt; option exists for the interactive backend to allow it to keep commits that started empty.</source>
          <target state="translated">Интерактивный бэкэнд отбрасывает коммиты по умолчанию, которые начинались с нуля, и останавливается, если попадает в коммит, который в итоге оказался пустым. Для интерактивного бэкэнда существует опция &lt;code&gt;--keep-empty&lt;/code&gt; , позволяющая сохранять пустые коммиты.</target>
        </trans-unit>
        <trans-unit id="c4d1b3aab1a5f39909af0bdb9766437575ff6138" translate="yes" xml:space="preserve">
          <source>The interactive mode is meant for this type of workflow:</source>
          <target state="translated">Интерактивный режим предназначен для данного типа рабочего процесса:</target>
        </trans-unit>
        <trans-unit id="bed5d62a356c4ef72d5d10899b110555c8810a69" translate="yes" xml:space="preserve">
          <source>The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current &lt;code&gt;master&lt;/code&gt; while working on the branch, only to rebase all the commits onto &lt;code&gt;master&lt;/code&gt; eventually (skipping the merge commits).</source>
          <target state="translated">Интерактивная команда rebase изначально была разработана для обработки отдельных серий исправлений. Таким образом, имеет смысл исключить коммиты слияния из списка задач, так как разработчик мог объединить текущий &lt;code&gt;master&lt;/code&gt; во время работы над веткой только для того, чтобы в конечном итоге перенастроить все коммиты на &lt;code&gt;master&lt;/code&gt; (пропуская коммиты слияния).</target>
        </trans-unit>
        <trans-unit id="54aff08446e09f30da133e329eb3f3646033c66c" translate="yes" xml:space="preserve">
          <source>The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">Интерактивное перебазирование остановится, когда команда завершится неудачно (т.е. завершится со статусом, отличным от 0), чтобы дать вам возможность решить проблему. Вы можете продолжить с помощью &lt;code&gt;git rebase --continue&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7f537099e4a0d8d8faba9c5e743d565b88b9dd" translate="yes" xml:space="preserve">
          <source>The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience.</source>
          <target state="translated">Интерфейс (ввод,вывод,набор опций и семантика)для этих низкоуровневых команд должен быть намного более стабильным,чем команды уровня фарфора,потому что эти команды в первую очередь предназначены для использования в сценариях.С другой стороны,интерфейс команд уровня фарфора может быть изменен,чтобы улучшить работу конечного пользователя.</target>
        </trans-unit>
        <trans-unit id="bf907bc1bbd0905aa866d8781057341315704641" translate="yes" xml:space="preserve">
          <source>The internal block size to use when converting a revision specifier such as &lt;code&gt;@all&lt;/code&gt; into a list of specific change numbers. Instead of using a single call to &lt;code&gt;p4 changes&lt;/code&gt; to find the full list of changes for the conversion, there are a sequence of calls to &lt;code&gt;p4 changes -m&lt;/code&gt;, each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable.</source>
          <target state="translated">Внутренний размер блока, используемый при преобразовании спецификатора ревизии, такого как &lt;code&gt;@all&lt;/code&gt; , в список конкретных номеров изменений. Вместо использования одного вызова &lt;code&gt;p4 changes&lt;/code&gt; для поиска полного списка изменений для преобразования, существует последовательность вызовов &lt;code&gt;p4 changes -m&lt;/code&gt; , каждый из которых запрашивает один блок изменений заданного размера. Размер блока по умолчанию - 500, что обычно подходит.</target>
        </trans-unit>
        <trans-unit id="b58ee91a98701b75ecd0edc6713c67b3efbc3330" translate="yes" xml:space="preserve">
          <source>The internals are documented in the &lt;a href=&quot;api-index&quot;&gt;Git API documentation&lt;/a&gt;.</source>
          <target state="translated">Внутреннее устройство задокументировано в документации &lt;a href=&quot;api-index&quot;&gt;Git API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="051387312310d89e1f2cd1a7644ba37793a94a7c" translate="yes" xml:space="preserve">
          <source>The known attack vectors are as follows:</source>
          <target state="translated">Известные векторы атаки следующие:</target>
        </trans-unit>
        <trans-unit id="d0880a7ce92ec68d75b7997f1b8b330766294029" translate="yes" xml:space="preserve">
          <source>The lack of a central group of &quot;committers&quot; means there is less need for formal decisions about who is &quot;in&quot; and who is &quot;out&quot;.</source>
          <target state="translated">Отсутствие центральной группы &quot;коммиттеров&quot; означает меньшую необходимость в формальных решениях о том,кто находится &quot;в&quot;,а кто &quot;вне&quot;.</target>
        </trans-unit>
        <trans-unit id="d217f82f775261a888c8090d4fd57de90a2943db" translate="yes" xml:space="preserve">
          <source>The last diff is empty, but no new commits have been made, and the head still doesn&amp;rsquo;t contain the new line:</source>
          <target state="translated">Последний diff пуст, но новых коммитов не было, а в заголовке все еще нет новой строки:</target>
        </trans-unit>
        <trans-unit id="fc6ae42476a6037281df209d5a37adfb042c084d" translate="yes" xml:space="preserve">
          <source>The last three commits (&lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;HEAD^&lt;/code&gt;, and &lt;code&gt;HEAD~2&lt;/code&gt;) were bad and you do not want to ever see them again. Do &lt;strong&gt;not&lt;/strong&gt; do this if you have already given these commits to somebody else. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for the implications of doing so.)</source>
          <target state="translated">Последние три коммита ( &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;HEAD^&lt;/code&gt; и &lt;code&gt;HEAD~2&lt;/code&gt; ) были плохими, и вы больше не хотите их видеть. Вы &lt;strong&gt;не&lt;/strong&gt; делайте этого , если вы уже дали эти коммиты кому - то другому. (См. Раздел &amp;laquo;ВОССТАНОВЛЕНИЕ ИЗ UPSTREAM REBASE&amp;raquo; в &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1],&lt;/a&gt; чтобы узнать о последствиях этого.)</target>
        </trans-unit>
        <trans-unit id="9b2685798225cd4befed46a027cdbd30eb245ee2" translate="yes" xml:space="preserve">
          <source>The latest stash you created is stored in &lt;code&gt;refs/stash&lt;/code&gt;; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the most recently created stash, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before it, &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer &lt;code&gt;n&lt;/code&gt; is equivalent to &lt;code&gt;stash@{n}&lt;/code&gt;).</source>
          <target state="translated">Последний созданный вами тайник хранится в &lt;code&gt;refs/stash&lt;/code&gt; ; более старые тайники находятся в журнале ссылок в этой ссылке и могут быть названы с использованием обычного синтаксиса журнала ссылок (например, &lt;code&gt;stash@{0}&lt;/code&gt; - это последний созданный тайник, &lt;code&gt;stash@{1}&lt;/code&gt; - предшествующий ему, &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; также возможно). На тайники также можно ссылаться, указав только индекс тайника (например, целое число &lt;code&gt;n&lt;/code&gt; эквивалентно &lt;code&gt;stash@{n}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8bb7601b8118e6905d96f76a29452df6bc2ae98e" translate="yes" xml:space="preserve">
          <source>The latter is not available by default, unless configured.</source>
          <target state="translated">Последнее не доступно по умолчанию,если оно не настроено.</target>
        </trans-unit>
        <trans-unit id="9096be046e467fbce79d2a6fe63b310a7a8be174" translate="yes" xml:space="preserve">
          <source>The latter use of the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values can be overridden by giving the &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; parameter(s) on the command line.</source>
          <target state="translated">Последнее использование значений &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; можно переопределить, &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; параметр (ы) --refmap = &amp;lt;refspec&amp;gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="55ffd562f6b8b4abf7958d261df418cb81ead100" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock an individual reference. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 100 (i.e., retry for 100ms).</source>
          <target state="translated">Продолжительность времени в миллисекундах,чтобы повторить попытку заблокировать индивидуальную ссылку.Значение 0 означает не повторять попытку вообще;-1 означает повторять попытку бесконечно.По умолчанию 100 (т.е.повторная попытка в течение 100 мс).</target>
        </trans-unit>
        <trans-unit id="68a6d4f84896f5fe182696f59cffd1c668106a0a" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock the &lt;code&gt;packed-refs&lt;/code&gt; file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1 second).</source>
          <target state="translated">Время в миллисекундах до повторной попытки блокировки файла с &lt;code&gt;packed-refs&lt;/code&gt; . Значение 0 означает, что попытки не повторяться вообще; -1 означает пытаться бесконечно. По умолчанию 1000 (т. Е. Повторите попытку в течение 1 секунды).</target>
        </trans-unit>
        <trans-unit id="fff6cc41c6311b04938a1f36a103054a2f1d2e11" translate="yes" xml:space="preserve">
          <source>The list above is ordered by decreasing precedence; a URL that matches a config key&amp;rsquo;s path is preferred to one that matches its user name. For example, if the URL is &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; a config key match of &lt;code&gt;https://example.com/foo&lt;/code&gt; will be preferred over a config key match of &lt;code&gt;https://user@example.com&lt;/code&gt;.</source>
          <target state="translated">Приведенный выше список упорядочен по убыванию приоритета; URL-адрес, соответствующий пути ключа конфигурации, предпочтительнее, чем URL-адрес, соответствующий его имени пользователя. Например, если URL-адрес &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; ,совпадение ключа конфигурации &lt;code&gt;https://example.com/foo&lt;/code&gt; будет предпочтительнее совпадения ключа конфигурации &lt;code&gt;https://user@example.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34cf6a4a25da733f5b8366288a8f31ad385fa0ee" translate="yes" xml:space="preserve">
          <source>The list of identifiers, and other information, of the objects in a &lt;a href=&quot;#def_pack&quot;&gt;pack&lt;/a&gt;, to assist in efficiently accessing the contents of a pack.</source>
          <target state="translated">Список идентификаторов и другая информация об объектах в &lt;a href=&quot;#def_pack&quot;&gt;пакете&lt;/a&gt; , чтобы помочь в эффективном доступе к содержимому пакета.</target>
        </trans-unit>
        <trans-unit id="58413b6422259538de8b3cfc5351841a4fb3ade2" translate="yes" xml:space="preserve">
          <source>The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.</source>
          <target state="translated">Список файлов почтового ящика для чтения патчей.Если вы не предоставите этот аргумент,команда будет читаться со стандартного входа.Если вы предоставите каталоги,они будут рассматриваться как мейлдиры.</target>
        </trans-unit>
        <trans-unit id="811a0eecf6c6689902c9fc1e00fe667f20b10132" translate="yes" xml:space="preserve">
          <source>The list of remotes which are fetched by &quot;git remote update &amp;lt;group&amp;gt;&quot;. See &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">Список пультов, которые выбираются командой &quot;git remote update &amp;lt;group&amp;gt;&quot;. См. &lt;a href=&quot;git-remote&quot;&gt;Git-remote [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3aadf5969931435dfd81a576572d271c1b7df1e4" translate="yes" xml:space="preserve">
          <source>The list you get with &quot;ls&quot; :-)</source>
          <target state="translated">Список,который вы получаете с &quot;ls&quot; :-)</target>
        </trans-unit>
        <trans-unit id="2d5bfecbee3eeb5c71f69bd43de88bc34222a07d" translate="yes" xml:space="preserve">
          <source>The local offset is specified by &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; as a positive or negative offset from UTC. For example EST (which is 5 hours behind UTC) would be expressed in &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; by &amp;ldquo;-0500&amp;rdquo; while UTC is &amp;ldquo;+0000&amp;rdquo;. The local offset does not affect &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;; it is used only as an advisement to help formatting routines display the timestamp.</source>
          <target state="translated">Локальное смещение указывается &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; как положительное или отрицательное смещение от UTC. Например, EST (который на 5 часов ниже UTC) будет выражен в &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; как &amp;laquo;-0500&amp;raquo;, а UTC - &amp;laquo;+0000&amp;raquo;. Локальное смещение не влияет на &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; ; он используется только как совет, помогающий процедурам форматирования отображать метку времени.</target>
        </trans-unit>
        <trans-unit id="ab508d82c7d8a4545e2bb32ec9ec4fb2386a14cb" translate="yes" xml:space="preserve">
          <source>The location of an augmenting mailmap file. The default mailmap, located in the root of the repository, is loaded first, then the mailmap file pointed to by this variable. The location of the mailmap file may be in a repository subdirectory, or somewhere outside of the repository itself. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">Расположение расширяемого файла почтовой карты. Карта почты по умолчанию, расположенная в корне репозитория, загружается первой, а затем файл карты почты, на который указывает эта переменная. Местоположение файла mailmap может быть в подкаталоге репозитория или где-то за пределами самого репозитория. См. &lt;a href=&quot;git-shortlog&quot;&gt;Git-shortlog [1]&lt;/a&gt; и &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bb0979c637e06c575b3f731f106ded5d4b916f" translate="yes" xml:space="preserve">
          <source>The location of per-instance and system-wide configuration files can be overridden using the following environment variables:</source>
          <target state="translated">Местоположение каждого экземпляра и общесистемных конфигурационных файлов может быть переопределено с помощью следующих переменных окружения:</target>
        </trans-unit>
        <trans-unit id="9446c1e5cce4b2ece4fc10ff79540962e21c6551" translate="yes" xml:space="preserve">
          <source>The magic word &lt;code&gt;top&lt;/code&gt; (magic signature: &lt;code&gt;/&lt;/code&gt;) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory.</source>
          <target state="translated">Волшебное слово &lt;code&gt;top&lt;/code&gt; (magic signature: &lt;code&gt;/&lt;/code&gt; ) обеспечивает совпадение с шаблоном из корня рабочего дерева, даже если вы запускаете команду из подкаталога.</target>
        </trans-unit>
        <trans-unit id="64ba77ac0581cbecc6b691422d0c5681817b2387" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands (plus help and quit).</source>
          <target state="translated">В основном цикле команд есть 6 подкоманд (плюс справка и выход).</target>
        </trans-unit>
        <trans-unit id="0b0bee129956915b1cb776d4190a01b55932ed3c" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands.</source>
          <target state="translated">В основном цикле команд есть 6 подкоманд.</target>
        </trans-unit>
        <trans-unit id="821ddd85eba2b4bc6e95a82521b10b32287622db" translate="yes" xml:space="preserve">
          <source>The main trunk is stored in the Git branch named &lt;code&gt;origin&lt;/code&gt;, and additional CVS branches are stored in Git branches with the same names. The most recent version of the main trunk is also left checked out on the &lt;code&gt;master&lt;/code&gt; branch, so you can start adding your own changes right away.</source>
          <target state="translated">Основной ствол хранится в ветке Git с именем &lt;code&gt;origin&lt;/code&gt; , а дополнительные ветки CVS хранятся в ветвях Git с такими же именами. Самая последняя версия основного ствола также не используется в &lt;code&gt;master&lt;/code&gt; ветке, поэтому вы можете сразу же начать добавлять свои собственные изменения.</target>
        </trans-unit>
        <trans-unit id="f31023370321849385c22bc8ae521136bfffac45" translate="yes" xml:space="preserve">
          <source>The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path. With this option, the full p4 depot path is retained in Git. For example, path &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt;, when imported from &lt;code&gt;//depot/main/&lt;/code&gt;, becomes &lt;code&gt;foo/bar.c&lt;/code&gt;. With &lt;code&gt;--keep-path&lt;/code&gt;, the Git path is instead &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt;.</source>
          <target state="translated">Отображение имен файлов из пути депо p4 в Git по умолчанию включает удаление всего пути депо. С этим параметром в Git сохраняется полный путь к депо p4. Так , например, путь &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt; , когда импортируется из &lt;code&gt;//depot/main/&lt;/code&gt; , становится &lt;code&gt;foo/bar.c&lt;/code&gt; . С &lt;code&gt;--keep-path&lt;/code&gt; , путь Гита вместо этого &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="696795b724c116f40755fe0ffd2f815f95c8f529" translate="yes" xml:space="preserve">
          <source>The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to &lt;code&gt;commit&lt;/code&gt;. This is typically more work than it&amp;rsquo;s worth however, as marks are inexpensive to store and easy to use.</source>
          <target state="translated">Команда mark здесь необязательна, так как некоторые интерфейсы решили самостоятельно сгенерировать Git SHA-1 для большого двоичного объекта и &lt;code&gt;commit&lt;/code&gt; непосредственно для фиксации . Однако, как правило, это больше работы, чем она того стоит, поскольку марки недорого хранить и просты в использовании.</target>
        </trans-unit>
        <trans-unit id="154d6f76415eae422478f55f25c1ddb853a4e1ab" translate="yes" xml:space="preserve">
          <source>The maximum delta depth used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no maximum depth is given on the command line. Defaults to 50. Maximum value is 4095.</source>
          <target state="translated">Максимальная глубина дельты, используемая &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1],&lt;/a&gt; когда максимальная глубина не указана в командной строке. По умолчанию - 50. Максимальное значение - 4095.</target>
        </trans-unit>
        <trans-unit id="9325da9117f9b4afd884e4f7e837bf9ca641172e" translate="yes" xml:space="preserve">
          <source>The maximum memory in bytes used for caching deltas in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; before writing them out to a pack. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Repacking large repositories on machines which are tight with memory might be badly impacted by this though, especially if this cache pushes the system into swapping. A value of 0 means no limit. The smallest size of 1 byte may be used to virtually disable this cache. Defaults to 256 MiB.</source>
          <target state="translated">Максимальный объем памяти в байтах, используемый для кэширования дельт в &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; перед их записью в пакет. Этот кеш используется для ускорения фазы записи объекта, так как не требуется повторно вычислять окончательный результат дельты после того, как будет найдено наилучшее соответствие для всех объектов. Это может сильно повлиять на переупаковку больших репозиториев на машинах с ограниченным объемом памяти, особенно если этот кеш подталкивает систему к подкачке. Значение 0 означает отсутствие ограничений. Наименьший размер в 1 байт может использоваться для виртуального отключения этого кэша. По умолчанию 256 МБ.</target>
        </trans-unit>
        <trans-unit id="a0015a1c1a155cb39bc99dd58a785f6e45fb6909" translate="yes" xml:space="preserve">
          <source>The maximum size of a delta, that is cached in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Defaults to 1000. Maximum value is 65535.</source>
          <target state="translated">Максимальный размер дельты, которая кешируется в &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; . Этот кеш используется для ускорения фазы записи объекта, так как не требуется повторно вычислять окончательный результат дельты после того, как будет найдено наилучшее соответствие для всех объектов. По умолчанию - 1000. Максимальное значение - 65535.</target>
        </trans-unit>
        <trans-unit id="d2696797b76aad16406d56dd354feaf085869327" translate="yes" xml:space="preserve">
          <source>The maximum size of a pack. This setting only affects packing to a file when repacking, i.e. the git:// protocol is unaffected. It can be overridden by the &lt;code&gt;--max-pack-size&lt;/code&gt; option of &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. Reaching this limit results in the creation of multiple packfiles; which in turn prevents bitmaps from being created. The minimum size allowed is limited to 1 MiB. The default is unlimited. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">Максимальный размер пачки. Этот параметр влияет только на упаковку в файл при переупаковке, т.е. протокол git: // не изменяется. Его можно &lt;code&gt;--max-pack-size&lt;/code&gt; с помощью опции --max-pack-size в &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; . Достижение этого предела приводит к созданию нескольких файлов пакетов; что, в свою очередь, предотвращает создание растровых изображений. Минимальный допустимый размер ограничен 1 МиБ. По умолчанию не ограничено. Поддерживаются общие суффиксы единиц измерения &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; или &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb8ed32c533714ca4a8bb85ec574c3c5791f3a2f" translate="yes" xml:space="preserve">
          <source>The maximum size of memory that is consumed by each thread in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for pack window memory when no limit is given on the command line. The value can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. When left unconfigured (or set explicitly to 0), there will be no limit.</source>
          <target state="translated">Максимальный размер памяти, потребляемой каждым потоком в &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; для памяти окна пакета, когда в командной строке не задано ограничение. Значение может иметь суффикс &amp;laquo;k&amp;raquo;, &amp;laquo;m&amp;raquo; или &amp;laquo;g&amp;raquo;. Если оставить ненастроенным (или явно установить на 0), ограничения не будет.</target>
        </trans-unit>
        <trans-unit id="565cc584b68c5b675a716ec7daae7fd9f3343784" translate="yes" xml:space="preserve">
          <source>The meaning of each part of feature configuration is described below:</source>
          <target state="translated">Значение каждой части конфигурации функции описано ниже:</target>
        </trans-unit>
        <trans-unit id="657f593653b8985b76ea363799992d9ccd8552d1" translate="yes" xml:space="preserve">
          <source>The merge driver can learn the pathname in which the merged result will be stored via placeholder &lt;code&gt;%P&lt;/code&gt;.</source>
          <target state="translated">Драйвер объединения может узнать путь к файлу , в котором объединенный результат будет сохранен через заполнитель &lt;code&gt;%P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a4ee88dc1fd419e5903b5a6b97383e8c2a1fab9" translate="yes" xml:space="preserve">
          <source>The merge driver is expected to leave the result of the merge in the file named with &lt;code&gt;%A&lt;/code&gt; by overwriting it, and exit with zero status if it managed to merge them cleanly, or non-zero if there were conflicts.</source>
          <target state="translated">Ожидается, что драйвер слияния оставит результат слияния в файле с именем &lt;code&gt;%A&lt;/code&gt; , перезаписав его, и выйдет с нулевым статусом, если ему удалось слить их чисто, или ненулевым, если были конфликты.</target>
        </trans-unit>
        <trans-unit id="d39522f0982abae4a359335f63ed088d0f4a4c4e" translate="yes" xml:space="preserve">
          <source>The merge mechanism (&lt;code&gt;git merge&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; commands) allows the backend &lt;code&gt;merge strategies&lt;/code&gt; to be chosen with &lt;code&gt;-s&lt;/code&gt; option. Some strategies can also take their own options, which can be passed by giving &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; arguments to &lt;code&gt;git merge&lt;/code&gt; and/or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">Механизм слияния (команды &lt;code&gt;git merge&lt;/code&gt; и &lt;code&gt;git pull&lt;/code&gt; ) позволяет выбирать &lt;code&gt;merge strategies&lt;/code&gt; серверной части с параметром &lt;code&gt;-s&lt;/code&gt; . Некоторые стратегии также могут иметь свои собственные параметры, которые можно передать, передав аргументы &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; командам &lt;code&gt;git merge&lt;/code&gt; и / или &lt;code&gt;git pull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa594438c3581495b74bb79c047cb66382bd8b0d" translate="yes" xml:space="preserve">
          <source>The merge workflow works by copying branches between upstream and downstream. Upstream can merge contributions into the official history; downstream base their work on the official history.</source>
          <target state="translated">Рабочий процесс слияния работает путем копирования веток между восходящими и нисходящими потоками.Upstream могут объединять вклады в официальную историю;downstream основывают свою работу на официальной истории.</target>
        </trans-unit>
        <trans-unit id="1df107645dfce75dc8613a8a0f6007cf8381d780" translate="yes" xml:space="preserve">
          <source>The merge-base command finds a common ancestor of the given commits, and always returns one or the other in the case where one is a descendant of the other; so the above output shows that e05db0fd actually is an ancestor of v1.5.0-rc1.</source>
          <target state="translated">Команда на основе слияния находит общего предка данных коммитов и всегда возвращает того или иного в случае,если один из них является потомком другого;таким образом,вышеприведенный вывод показывает,что e05db0fd на самом деле является предком v1.5.0-rc1.</target>
        </trans-unit>
        <trans-unit id="19f5c4372c6fc154ead993a9f4b5a82da922524d" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt; and command line with &lt;code&gt;-m&lt;/code&gt; are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">Сообщение, взятое из файла с &lt;code&gt;-F&lt;/code&gt; и командной строки с &lt;code&gt;-m&lt;/code&gt; , обычно используется как неизмененное сообщение тега. Эта опция позволяет вам редактировать сообщение, полученное из этих источников.</target>
        </trans-unit>
        <trans-unit id="1e2b72f6afed427d21f4e345d320e470730d82f9" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt;, command line with &lt;code&gt;-m&lt;/code&gt;, and from commit object with &lt;code&gt;-C&lt;/code&gt; are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">Сообщение, полученное из файла с &lt;code&gt;-F&lt;/code&gt; , командной строки с &lt;code&gt;-m&lt;/code&gt; и из объекта фиксации с &lt;code&gt;-C&lt;/code&gt; , обычно используется как неизмененное сообщение журнала фиксации. Эта опция позволяет вам редактировать сообщение, полученное из этих источников.</target>
        </trans-unit>
        <trans-unit id="ae16f65784862fd6e529b736650355763df13327" translate="yes" xml:space="preserve">
          <source>The method by which a submodule is updated by &lt;code&gt;git submodule update&lt;/code&gt;, which is the only affected command, others such as &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; are unaffected. It exists for historical reasons, when &lt;code&gt;git submodule&lt;/code&gt; was the only command to interact with submodules; settings like &lt;code&gt;submodule.active&lt;/code&gt; and &lt;code&gt;pull.rebase&lt;/code&gt; are more specific. It is populated by &lt;code&gt;git submodule init&lt;/code&gt; from the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;.</source>
          <target state="translated">Метод обновления подмодуля с помощью &lt;code&gt;git submodule update&lt;/code&gt; , который является единственной затронутой командой, другие, такие как &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; , не затрагиваются. Он существует по историческим причинам, когда &lt;code&gt;git submodule&lt;/code&gt; был единственной командой для взаимодействия с подмодулями; настройки , такие как &lt;code&gt;submodule.active&lt;/code&gt; и &lt;code&gt;pull.rebase&lt;/code&gt; более специфичны. Он заполняется &lt;code&gt;git submodule init&lt;/code&gt; из &lt;a href=&quot;gitmodules&quot;&gt;файла gitmodules [5]&lt;/a&gt; . См. Описание команды &lt;code&gt;update&lt;/code&gt; в &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04ef06b50b9899f38b1e5f5c81eb00396b6d2328" translate="yes" xml:space="preserve">
          <source>The mode parameter is optional (defaults to &lt;code&gt;all&lt;/code&gt;), and is used to specify the handling of untracked files; when -u is not used, the default is &lt;code&gt;normal&lt;/code&gt;, i.e. show untracked files and directories.</source>
          <target state="translated">Параметр режима является необязательным (по умолчанию &lt;code&gt;all&lt;/code&gt; ) и используется для указания обработки неотслеживаемых файлов; когда -u не используется, по умолчанию используется &lt;code&gt;normal&lt;/code&gt; режим, т.е. показывать неотслеживаемые файлы и каталоги.</target>
        </trans-unit>
        <trans-unit id="daee71f2e966cf5f390a0401b9f0381f1242178c" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to &lt;code&gt;traditional&lt;/code&gt;.</source>
          <target state="translated">Параметр mode используется для указания обработки игнорируемых файлов. Это необязательно: по умолчанию используется &lt;code&gt;traditional&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="789771a80f50eaf70002a855307c4e88ea3d25bd" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to &lt;code&gt;all&lt;/code&gt;, and if specified, it must be stuck to the option (e.g. &lt;code&gt;-uno&lt;/code&gt;, but not &lt;code&gt;-u no&lt;/code&gt;).</source>
          <target state="translated">Параметр режима используется для указания обработки неотслеживаемых файлов. Это необязательно: по умолчанию используется &lt;code&gt;all&lt;/code&gt; , и если он указан, он должен быть привязан к опции (например, &lt;code&gt;-uno&lt;/code&gt; , но не &lt;code&gt;-u no&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d56062b3fd6eee94e49e5896b7d127ee25df01a1" translate="yes" xml:space="preserve">
          <source>The modifications stashed away by this command can be listed with &lt;code&gt;git stash list&lt;/code&gt;, inspected with &lt;code&gt;git stash show&lt;/code&gt;, and restored (potentially on top of a different commit) with &lt;code&gt;git stash apply&lt;/code&gt;. Calling &lt;code&gt;git stash&lt;/code&gt; without any arguments is equivalent to &lt;code&gt;git stash push&lt;/code&gt;. A stash is by default listed as &quot;WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;​&quot;, but you can give a more descriptive message on the command line when you create one.</source>
          <target state="translated">Изменения, спрятанные с помощью этой команды, могут быть перечислены с помощью &lt;code&gt;git stash list&lt;/code&gt; , проверены с помощью &lt;code&gt;git stash show&lt;/code&gt; и восстановлены (возможно, поверх другой фиксации) с помощью &lt;code&gt;git stash apply&lt;/code&gt; . Вызов &lt;code&gt;git stash&lt;/code&gt; без аргументов эквивалентен &lt;code&gt;git stash push&lt;/code&gt; . Тайник по умолчанию отображается как &amp;laquo;WIP на имя &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;&amp;raquo;, но вы можете дать более информативное сообщение в командной строке при его создании.</target>
        </trans-unit>
        <trans-unit id="e06fa83026ee56ec3b62a659fa5a44c6e4e4728d" translate="yes" xml:space="preserve">
          <source>The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)</source>
          <target state="translated">Путь к модулю (нужен только если httpd-это Apache).(По умолчанию:/usr/lib/apache2/modules).</target>
        </trans-unit>
        <trans-unit id="08ed4170506fa174e84f549a0e3f26086c486529" translate="yes" xml:space="preserve">
          <source>The more complex forms are:</source>
          <target state="translated">Чем сложнее формы:</target>
        </trans-unit>
        <trans-unit id="7d735293dee944ca58932a7261110828d307c793" translate="yes" xml:space="preserve">
          <source>The most common cause of dangling objects is that you&amp;rsquo;ve rebased a branch, or you have pulled from somebody else who rebased a branch&amp;mdash;​see &lt;a href=&quot;#cleaning-up-history&quot;&gt;Rewriting history and maintaining patch series&lt;/a&gt;. In that case, the old head of the original branch still exists, as does everything it pointed to. The branch pointer itself just doesn&amp;rsquo;t, since you replaced it with another one.</source>
          <target state="translated">Наиболее частая причина появления висячих объектов - это то, что вы перебазировали ветку или получили данные от кого-то еще, кто переустановил ветку - см. &lt;a href=&quot;#cleaning-up-history&quot;&gt;Перезапись истории и поддержание серии исправлений&lt;/a&gt; . В этом случае старый заголовок исходной ветки все еще существует, как и все, на что он указывал. Сам указатель ветки просто не работает, так как вы заменили его другим.</target>
        </trans-unit>
        <trans-unit id="8bc143dd44c89f63596943262174b04211332773" translate="yes" xml:space="preserve">
          <source>The multi-pack-index (MIDX for short) stores a list of objects and their offsets into multiple packfiles. It contains:</source>
          <target state="translated">Мульти-пакет-индекс (MIDX для краткости)хранит список объектов и их смещения в нескольких пакетных файлах.Он содержит:</target>
        </trans-unit>
        <trans-unit id="4ca15f678a55a1443f2d701a54958e45ad8a0235" translate="yes" xml:space="preserve">
          <source>The multi-pack-index allows many packfiles, especially in a context where repacking is expensive (such as a very large repo), or unexpected maintenance time is unacceptable (such as a high-demand build machine). However, the multi-pack-index needs to be rewritten in full every time. We can extend the format to be incremental, so writes are fast. By storing a small &quot;tip&quot; multi-pack-index that points to large &quot;base&quot; MIDX files, we can keep writes fast while still reducing the number of binary searches required for object lookups.</source>
          <target state="translated">Мультипакет-индекс позволяет использовать множество упаковочных файлов,особенно в условиях,когда переупаковка является дорогостоящей (например,очень крупный репо),или неожиданное время обслуживания недопустимо (например,строительная машина,пользующаяся большим спросом).Тем не менее,мультипакет-индекс необходимо каждый раз переписывать полностью.Мы можем расширить формат,чтобы он был инкрементальным,поэтому записи происходят быстро.Сохраняя небольшой &quot;tip&quot; мультипакет-индекс,который указывает на большие &quot;базовые&quot; MIDX-файлы,мы можем продолжать запись быстро,при этом сокращая количество бинарных поисков,необходимых для поиска объектов.</target>
        </trans-unit>
        <trans-unit id="d98c840529f1ab7c2fa3df48a823219f4ff9a17e" translate="yes" xml:space="preserve">
          <source>The multi-pack-index files refer to multiple pack-files and loose objects.</source>
          <target state="translated">Мульти-пакет-индексные файлы относятся к нескольким пакетным файлам и свободным объектам.</target>
        </trans-unit>
        <trans-unit id="1e0c8af9211e361d1a35789c37df84247f7ae9ac" translate="yes" xml:space="preserve">
          <source>The name and the e-mail address of the owner of the key that signed the push certificate.</source>
          <target state="translated">Имя и электронный адрес владельца ключа,который подписал сертификат push.</target>
        </trans-unit>
        <trans-unit id="2551d22d5e60fb51293e5ef827d3f2d640624d55" translate="yes" xml:space="preserve">
          <source>The name of a commit at which to start the new branch; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Имя коммита, с которого начинается новая ветка; подробности см. в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; . По умолчанию &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0efd5464958e1be85e38672256be6f6e17bc462a" translate="yes" xml:space="preserve">
          <source>The name of a local ref which can be considered &amp;ldquo;upstream&amp;rdquo; from the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; in the same way as &lt;code&gt;refname&lt;/code&gt; above. Additionally respects &lt;code&gt;:track&lt;/code&gt; to show &quot;[ahead N, behind M]&quot; and &lt;code&gt;:trackshort&lt;/code&gt; to show the terse version: &quot;&amp;gt;&quot; (ahead), &quot;&amp;lt;&quot; (behind), &quot;&amp;lt;&amp;gt;&quot; (ahead and behind), or &quot;=&quot; (in sync). &lt;code&gt;:track&lt;/code&gt; also prints &quot;[gone]&quot; whenever unknown upstream ref is encountered. Append &lt;code&gt;:track,nobracket&lt;/code&gt; to show tracking information without brackets (i.e &quot;ahead N, behind M&quot;).</source>
          <target state="translated">Имя локальной ссылки, которую можно рассматривать как восходящую по сравнению с отображаемой ссылкой. Уважает &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; и &lt;code&gt;:rstrip&lt;/code&gt; таким же образом , как &lt;code&gt;refname&lt;/code&gt; выше. Дополнительно учитывает &lt;code&gt;:track&lt;/code&gt; , чтобы показать &amp;laquo;[впереди N, позади M]&amp;raquo; и &lt;code&gt;:trackshort&lt;/code&gt; чтобы показать краткую версию: &amp;laquo;&amp;gt;&amp;raquo; (впереди), &amp;laquo;&amp;lt;&amp;raquo; (сзади), &amp;laquo;&amp;lt;&amp;gt;&amp;raquo; (впереди и сзади) или &amp;laquo; = &quot;(синхронно). &lt;code&gt;:track&lt;/code&gt; также выводит &amp;laquo;[ушел]&amp;raquo; всякий раз, когда встречается неизвестная ссылка в восходящем направлении. Добавьте &lt;code&gt;:track,nobracket&lt;/code&gt; без скобок , чтобы отображать информацию об отслеживании без скобок (например, &amp;laquo;впереди N, позади M&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="285243cf13ade280f7038dfb92bbdaa7d26dec36" translate="yes" xml:space="preserve">
          <source>The name of a local ref which represents the &lt;code&gt;@{push}&lt;/code&gt; location for the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt;, &lt;code&gt;:rstrip&lt;/code&gt;, &lt;code&gt;:track&lt;/code&gt;, &lt;code&gt;:trackshort&lt;/code&gt;, &lt;code&gt;:remotename&lt;/code&gt;, and &lt;code&gt;:remoteref&lt;/code&gt; options as &lt;code&gt;upstream&lt;/code&gt; does. Produces an empty string if no &lt;code&gt;@{push}&lt;/code&gt; ref is configured.</source>
          <target state="translated">Имя локальной ссылки, которая представляет расположение &lt;code&gt;@{push}&lt;/code&gt; для отображаемой ссылки. Уважает &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; , &lt;code&gt;:rstrip&lt;/code&gt; , &lt;code&gt;:track&lt;/code&gt; , &lt;code&gt;:trackshort&lt;/code&gt; , &lt;code&gt;:remotename&lt;/code&gt; и &lt;code&gt;:remoteref&lt;/code&gt; варианты , как &lt;code&gt;upstream&lt;/code&gt; делает. Создает пустую строку, если не настроено &lt;code&gt;@{push}&lt;/code&gt; ref.</target>
        </trans-unit>
        <trans-unit id="25973fbcb02049e23787d52ffa23363b0665166c" translate="yes" xml:space="preserve">
          <source>The name of a new directory to clone into. The &quot;humanish&quot; part of the source repository is used if no directory is explicitly given (&lt;code&gt;repo&lt;/code&gt; for &lt;code&gt;/path/to/repo.git&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt; for &lt;code&gt;host.xz:foo/.git&lt;/code&gt;). Cloning into an existing directory is only allowed if the directory is empty.</source>
          <target state="translated">Имя нового каталога для клонирования. &amp;laquo;Humanish&amp;raquo; часть исходного хранилища используется , если каталог не задан явно ( &lt;code&gt;repo&lt;/code&gt; для &lt;code&gt;/path/to/repo.git&lt;/code&gt; и &lt;code&gt;foo&lt;/code&gt; для &lt;code&gt;host.xz:foo/.git&lt;/code&gt; ). Клонирование в существующий каталог разрешено только в том случае, если каталог пуст.</target>
        </trans-unit>
        <trans-unit id="3c836d4cc86fbcc3a897aa8fab973465c40a1899" translate="yes" xml:space="preserve">
          <source>The name of an existing branch already in fast-import&amp;rsquo;s internal branch table. If fast-import doesn&amp;rsquo;t know the name, it&amp;rsquo;s treated as a SHA-1 expression.</source>
          <target state="translated">Имя существующей ветки уже во внутренней таблице ветвей быстрого импорта. Если fast-import не знает имени, он обрабатывается как выражение SHA-1.</target>
        </trans-unit>
        <trans-unit id="c21a579b2f8550495cd7f286a4f77b45b3df2f6e" translate="yes" xml:space="preserve">
          <source>The name of an existing branch to rename.</source>
          <target state="translated">Название существующего филиала для переименования.</target>
        </trans-unit>
        <trans-unit id="b35cfa9e6735c6918643ac8769ab4e5dd81020f0" translate="yes" xml:space="preserve">
          <source>The name of an external credential helper, and any associated options. If the helper name is not an absolute path, then the string &lt;code&gt;git
credential-&lt;/code&gt; is prepended. The resulting string is executed by the shell (so, for example, setting this to &lt;code&gt;foo --option=bar&lt;/code&gt; will execute &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; via the shell. See the manual of specific helpers for examples of their use.</source>
          <target state="translated">Имя внешнего помощника по учетным данным и все связанные параметры. Если имя помощника не является абсолютным путем, то добавляется строка &lt;code&gt;git credential-&lt;/code&gt; . Результирующая строка выполняется оболочкой (так, например, установка этого параметра на &lt;code&gt;foo --option=bar&lt;/code&gt; приведет к выполнению &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; через оболочку. Примеры их использования см. В руководстве по конкретным помощникам.</target>
        </trans-unit>
        <trans-unit id="7efaaad02f8c0d5eaaddaa5b6f8a8113410c8ef1" translate="yes" xml:space="preserve">
          <source>The name of one of the following can be used instead of a URL as &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">Вместо URL в качестве аргумента &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; можно использовать имя одного из следующих :</target>
        </trans-unit>
        <trans-unit id="f54520854ea19fafb55997c9840c558f7f80fed9" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the object that is replaced. The content of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the replacement object.</source>
          <target state="translated">Имя &lt;code&gt;replace&lt;/code&gt; ссылки - это SHA-1 заменяемого объекта. Содержимое ссылки на &lt;code&gt;replace&lt;/code&gt; - это SHA-1 объекта замены.</target>
        </trans-unit>
        <trans-unit id="117daad0c937bbfd67b26eaa98382dde664a6203" translate="yes" xml:space="preserve">
          <source>The name of the branch to create or delete. The new branch name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a branch name.</source>
          <target state="translated">Имя ветки, которую нужно создать или удалить. Новое имя ветки должно пройти все проверки, определенные &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]&lt;/a&gt; . Некоторые из этих проверок могут ограничивать символы, разрешенные в имени ветки.</target>
        </trans-unit>
        <trans-unit id="f40b450a4e1f94bf798289a960712dae0a6f632b" translate="yes" xml:space="preserve">
          <source>The name of the client can be given to &lt;code&gt;git p4&lt;/code&gt; in multiple ways. The variable &lt;code&gt;git-p4.client&lt;/code&gt; takes precedence if it exists. Otherwise, normal p4 mechanisms of determining the client are used: environment variable &lt;code&gt;P4CLIENT&lt;/code&gt;, a file referenced by &lt;code&gt;P4CONFIG&lt;/code&gt;, or the local host name.</source>
          <target state="translated">Имя клиента может быть присвоено &lt;code&gt;git p4&lt;/code&gt; несколькими способами. Переменная &lt;code&gt;git-p4.client&lt;/code&gt; имеет приоритет, если она существует. В противном случае используются обычные механизмы p4 для определения клиента: переменная среды &lt;code&gt;P4CLIENT&lt;/code&gt; , файл, на который ссылается &lt;code&gt;P4CONFIG&lt;/code&gt; , или имя локального хоста.</target>
        </trans-unit>
        <trans-unit id="d25f4900ca4ac26428c337fc8a49a0fffaa87baa" translate="yes" xml:space="preserve">
          <source>The name of the current branch is stored in .git/HEAD.</source>
          <target state="translated">Имя текущей ветки хранится в файле .git/HEAD.</target>
        </trans-unit>
        <trans-unit id="9192c74ec25457f29baaadaeb1d2b767ba20ddac" translate="yes" xml:space="preserve">
          <source>The name of the local ref being pushed, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the local ref is omitted.</source>
          <target state="translated">Имя отправляемой локальной ссылки за вычетом ее префикса &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; . В случае удаления имя локальной ссылки опускается.</target>
        </trans-unit>
        <trans-unit id="61c75d700127b0c70d569d247bca51622e343006" translate="yes" xml:space="preserve">
          <source>The name of the local ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">Имя обновляемого локального ref за вычетом его префикса &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40299b8374a45bc90296f421fddf5763cb8c6908" translate="yes" xml:space="preserve">
          <source>The name of the object to show. For a more complete list of ways to spell object names, see the &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Имя отображаемого объекта. Более полный список способов &lt;a href=&quot;gitrevisions&quot;&gt;написания&lt;/a&gt; имен объектов см. В разделе &amp;laquo;УКАЗАНИЕ ИЗМЕНЕНИЙ&amp;raquo; в gitrevisions [7] .</target>
        </trans-unit>
        <trans-unit id="15cfdda92a704493f44c3f6bda85fdb4fe25cc87" translate="yes" xml:space="preserve">
          <source>The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append &lt;code&gt;:short&lt;/code&gt;. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; (&lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt;) is appended, strips &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; slash-separated path components from the front (back) of the refname (e.g. &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). If &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; is a negative number, strip as many path components as necessary from the specified end to leave &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; path components (e.g. &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;tags/foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). When the ref does not have enough components, the result becomes an empty string if stripping with positive &amp;lt;N&amp;gt;, or it becomes the full refname if stripping with negative &amp;lt;N&amp;gt;. Neither is an error.</source>
          <target state="translated">Имя ссылки (часть после $ GIT_DIR /). Для недвусмысленного краткого имени ссылки добавьте &lt;code&gt;:short&lt;/code&gt; . Параметр core.warnAmbiguousRefs используется для выбора режима строгого сокращения. Если &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; ( &lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt; ) добавляется, полосы &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; прорезных разделенные компоненты пути от передней (задней) части refname (например , &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; поворачивает &lt;code&gt;refs/tags/foo&lt;/code&gt; в &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; превращает &lt;code&gt;refs/tags/foo&lt;/code&gt; в &lt;code&gt;refs&lt;/code&gt; ). Если &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; - отрицательное число, удалите столько компонентов пути, сколько необходимо с указанного конца, чтобы оставить &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; компоненты пути (например, &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; превращает &lt;code&gt;refs/tags/foo&lt;/code&gt; в &lt;code&gt;tags/foo&lt;/code&gt; , а &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; превращает &lt;code&gt;refs/tags/foo&lt;/code&gt; в &lt;code&gt;refs&lt;/code&gt; ). Когда в ссылке недостаточно компонентов, результатом становится пустая строка при удалении с положительным &amp;lt;N&amp;gt; или полное имя ссылки при удалении с отрицательным &amp;lt;N&amp;gt;. Это тоже не ошибка.</target>
        </trans-unit>
        <trans-unit id="d3667dc69f3d60260150d30873ae903291e9c610" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being fetched from, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the remote ref is &quot;(none)&quot;.</source>
          <target state="translated">Имя извлекаемого удаленного ref за вычетом его префикса &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; . В случае удаления имя удаленного ссылки - &amp;laquo;(нет)&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f1e1380262032f81dbdd04e4a724dd0dac2f66a0" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">Имя обновляемого удаленного ref за вычетом его префикса &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf1208454bdf4c7c5a0ab602103e6dd838ca212a" translate="yes" xml:space="preserve">
          <source>The name of the repository in gitweb is the path to its &lt;code&gt;$GIT_DIR&lt;/code&gt; (its object database) relative to &lt;code&gt;$projectroot&lt;/code&gt;. Therefore the repository $repo can be found at &quot;$projectroot/$repo&quot;.</source>
          <target state="translated">Имя репозитория в gitweb - это путь к его &lt;code&gt;$GIT_DIR&lt;/code&gt; (его объектной базе данных) относительно &lt;code&gt;$projectroot&lt;/code&gt; . Поэтому репозиторий $ repo можно найти по адресу &amp;laquo;$ projectroot / $ repo&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1b6cc45302b6351d18e813818cde0845c0a5a22a" translate="yes" xml:space="preserve">
          <source>The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a tag name.</source>
          <target state="translated">Имя тега, который нужно создать, удалить или описать. Новое имя тега должно пройти все проверки, определенные &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]&lt;/a&gt; . Некоторые из этих проверок могут ограничивать символы, разрешенные в имени тега.</target>
        </trans-unit>
        <trans-unit id="964fd80a7ebc3b646125e059ac3c7f8c3a22061f" translate="yes" xml:space="preserve">
          <source>The named branches will be interpreted as if specified with the &lt;code&gt;-t&lt;/code&gt; option on the &lt;code&gt;git remote add&lt;/code&gt; command line.</source>
          <target state="translated">Именованные ветки будут интерпретироваться так, как если бы они были указаны с параметром &lt;code&gt;-t&lt;/code&gt; в командной строке &lt;code&gt;git remote add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7226417649eb7c8f42ca4934a290033c08aad1c" translate="yes" xml:space="preserve">
          <source>The names of objects to show (defaults to &lt;code&gt;HEAD&lt;/code&gt;). For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Имена отображаемых объектов (по умолчанию &lt;code&gt;HEAD&lt;/code&gt; ). Более полный список способов &lt;a href=&quot;gitrevisions&quot;&gt;написания&lt;/a&gt; имен объектов см. В разделе &amp;laquo;УКАЗАНИЕ ИЗМЕНЕНИЙ&amp;raquo; в gitrevisions [7] .</target>
        </trans-unit>
        <trans-unit id="df439b2df93c9264d2652e8aa379f62f3b6ab5ac" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names they point at, are written to &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. This information may be used by scripts or other git commands, such as &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">Имена &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; вместе с именами объектов, на которые они указывают, записываются в .git / FETCH_HEAD . Эта информация может использоваться скриптами или другими командами git, такими как &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9c4b549f992b26edb42d00411780a65661d81d" translate="yes" xml:space="preserve">
          <source>The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.</source>
          <target state="translated">Нативный транспорт (например,git://URL)не производит аутентификацию и должен использоваться с осторожностью в незащищенных сетях.</target>
        </trans-unit>
        <trans-unit id="86d32cda4c46d201605240981feec896fb3daceb" translate="yes" xml:space="preserve">
          <source>The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.</source>
          <target state="translated">Новая глава филиала укажет на этот коммит.Он может быть указан в качестве имени ответвления,дополнения к коммиту или метки.Если эта опция опущена,вместо неё будет использоваться текущий HEAD.</target>
        </trans-unit>
        <trans-unit id="597e47a48a8bd8b3528838dd5cebedeb7b241f60" translate="yes" xml:space="preserve">
          <source>The new name for an existing branch. The same restrictions as for &amp;lt;branchname&amp;gt; apply.</source>
          <target state="translated">Новое имя существующей ветки. Применяются те же ограничения, что и для &amp;lt;branchname&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="ade318097a09c67b5bdaa6c1344cf2a281d7cac8" translate="yes" xml:space="preserve">
          <source>The next parameter is the pattern. This option has to be used for patterns starting with &lt;code&gt;-&lt;/code&gt; and should be used in scripts passing user input to grep. Multiple patterns are combined by &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="translated">Следующий параметр - это узор. Этот параметр должен использоваться для шаблонов, начинающихся с &lt;code&gt;-&lt;/code&gt; , и должен использоваться в сценариях, передающих ввод пользователя в grep. Несколько шаблонов объединяются с помощью &lt;code&gt;or&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00f28e3b882b5553d45ceeb08082d3dcda522dd0" translate="yes" xml:space="preserve">
          <source>The next step of merging is to merge these three versions of the file, using 3-way merge. This is done by giving &lt;code&gt;git merge-one-file&lt;/code&gt; command as one of the arguments to &lt;code&gt;git merge-index&lt;/code&gt; command:</source>
          <target state="translated">Следующим шагом слияния является слияние этих трех версий файла с помощью 3-стороннего слияния. Для этого нужно &lt;code&gt;git merge-index&lt;/code&gt; команду &lt;code&gt;git merge-one-file&lt;/code&gt; в качестве одного из аргументов команды git merge-index :</target>
        </trans-unit>
        <trans-unit id="c203649e7405cacf1f66f3229b4d864ccf1b5f34" translate="yes" xml:space="preserve">
          <source>The nonce string the process asked the signer to include in the push certificate. If this does not match the value recorded on the &quot;nonce&quot; header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate &quot;git push&quot; session.</source>
          <target state="translated">Строка nonce,которую процесс попросил подписать сертификат,должна быть включена в сертификат push.Если она не совпадает со значением,записанным в заголовке &quot;nonce&quot; в сертификате push,это может указывать на то,что сертификат является действительным,который проигрывается с отдельного сеанса &quot;git push&quot;.</target>
        </trans-unit>
        <trans-unit id="a81eae6f204563324e9f0299e6e5a18af11339c2" translate="yes" xml:space="preserve">
          <source>The normal format target is a tradition printf format and similar to GIT_TRACE format. This format is enabled with the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable or the &lt;code&gt;trace2.normalTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">Целевым объектом нормального формата является традиционный формат printf, аналогичный формату GIT_TRACE. Этот формат включен с &lt;code&gt;GIT_TRACE2&lt;/code&gt; переменной окружения или &lt;code&gt;trace2.normalTarget&lt;/code&gt; системы или глобальные настройки конфигурации.</target>
        </trans-unit>
        <trans-unit id="08867837836724d3f4c3cfbd7d03fa5d964eec62" translate="yes" xml:space="preserve">
          <source>The number of additional commits is the number of commits which would be displayed by &quot;git log v1.0.4..parent&quot;. The hash suffix is &quot;-g&quot; + unambiguous abbreviation for the tip commit of parent (which was &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt;). The &quot;g&quot; prefix stands for &quot;git&quot; and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.</source>
          <target state="translated">Количество дополнительных коммитов - это количество коммитов, которое будет отображаться &quot;git log v1.0.4..parent&quot;. Суффикс хеш-функции - &quot;-g&quot; + однозначное сокращение для &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt; фиксации родительского элемента ( 2414721b194453f058079d897d13c4e377f92dc6 ). Префикс &amp;laquo;g&amp;raquo; означает &amp;laquo;git&amp;raquo; и используется для описания версии программного обеспечения в зависимости от SCM, с помощью которого программное обеспечение управляется. Это полезно в среде, где люди могут использовать разные SCM.</target>
        </trans-unit>
        <trans-unit id="83386653d6009935020ea78a4c28a793cc5fa198" translate="yes" xml:space="preserve">
          <source>The number of curl sessions (counted across slots) to be kept across requests. They will not be ended with curl_easy_cleanup() until http_cleanup() is invoked. If USE_CURL_MULTI is not defined, this value will be capped at 1. Defaults to 1.</source>
          <target state="translated">Количество сеансов скручивания (подсчитывается по слотам),которое должно сохраняться по запросам.Они не будут завершаться функцией curl_easy_cleanup()до тех пор,пока не будет вызвана http_cleanup().Если USE_CURL_MULTI не определено,то это значение будет ограничено значением 1.По умолчанию 1.</target>
        </trans-unit>
        <trans-unit id="eb593ed0188a165abaa2fc9b58825ac993fcfa11" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">Количество файлов,которые необходимо учитывать при определении переименования при слиянии;если не указано,по умолчанию установлено значение diff.renameLimit.Этот параметр не действует,если обнаружение переименования отключено.</target>
        </trans-unit>
        <trans-unit id="b49ca7e6ecad75b8cf0b0ec3dcf469e017a13140" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. Defaults to the value of diff.renameLimit.</source>
          <target state="translated">Количество файлов, которые следует учитывать при выполнении обнаружения переименования в &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; и &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; . По умолчанию используется значение diff.renameLimit.</target>
        </trans-unit>
        <trans-unit id="62caddb975571c60931b3e5e41910f9ec3dfea6e" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing the copy/rename detection; equivalent to the &lt;code&gt;git diff&lt;/code&gt; option &lt;code&gt;-l&lt;/code&gt;. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">Количество файлов, которые следует учитывать при выполнении обнаружения копирования / переименования; эквивалент опции &lt;code&gt;git diff&lt;/code&gt; &lt;code&gt;-l&lt;/code&gt; . Этот параметр не действует, если отключено определение переименования.</target>
        </trans-unit>
        <trans-unit id="f40a726880d5eda55c8da498a0add02c8ea2a7b1" translate="yes" xml:space="preserve">
          <source>The number of push options given on the command line of &lt;code&gt;git push --push-option=...&lt;/code&gt; can be read from the environment variable &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt;, and the options themselves are found in &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt;, &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt;,&amp;hellip;​ If it is negotiated to not use the push options phase, the environment variables will not be set. If the client selects to use push options, but doesn&amp;rsquo;t transmit any, the count variable will be set to zero, &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt;.</source>
          <target state="translated">Количество параметров push, заданных в командной строке &lt;code&gt;git push --push-option=...&lt;/code&gt; , можно прочитать из переменной среды &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt; , а сами параметры находятся в &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt; , &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt; ,&amp;hellip; Если согласовано, чтобы не используйте фазу push-параметров, переменные среды не будут установлены. Если клиент выбирает использование опций push, но не передает их, переменная count будет установлена ​​в ноль, &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ad10bd3ab58adc794f2122271c46d58529bef4" translate="yes" xml:space="preserve">
          <source>The number of spaces between columns. One space by default.</source>
          <target state="translated">Количество промежутков между колоннами.Один пробел по умолчанию.</target>
        </trans-unit>
        <trans-unit id="911462b0802b22317c5a57a0a0510dbf0c397a66" translate="yes" xml:space="preserve">
          <source>The number of submodules fetched at the same time. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">Количество подмодулей, загружаемых одновременно. По умолчанию используется параметр &lt;code&gt;submodule.fetchJobs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34de3b8749bfae0c14ff8d34783f05c9920748b5" translate="yes" xml:space="preserve">
          <source>The object can be a blob or a submodule commit. It implies the &lt;code&gt;-t&lt;/code&gt; option in &lt;code&gt;git-log&lt;/code&gt; to also find trees.</source>
          <target state="translated">Объектом может быть большой двоичный объект или фиксация подмодуля. Это подразумевает параметр &lt;code&gt;-t&lt;/code&gt; в &lt;code&gt;git-log&lt;/code&gt; , чтобы также находить деревья.</target>
        </trans-unit>
        <trans-unit id="2794f5933199b4937a09c41b8d049f6b88620c25" translate="yes" xml:space="preserve">
          <source>The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits.</source>
          <target state="translated">Объектная база данных содержит объекты трёх основных типов:блобы,содержащие файловые данные;деревья,указывающие на блобы и другие деревья для построения иерархии каталогов;и коммиты,каждый из которых ссылается на одно дерево и некоторое количество родительских коммитов.</target>
        </trans-unit>
        <trans-unit id="b5ea163b65a2243d9fc238d7c50700c517adc350" translate="yes" xml:space="preserve">
          <source>The object database is the rather elegant system used to store the history of your project&amp;mdash;​files, directories, and commits.</source>
          <target state="translated">База данных объектов - довольно элегантная система, используемая для хранения истории вашего проекта - файлов, каталогов и коммитов.</target>
        </trans-unit>
        <trans-unit id="db080c7937810b605e4381605a2e18077b89e3c0" translate="yes" xml:space="preserve">
          <source>The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append &lt;code&gt;:short&lt;/code&gt;. For an abbreviation of the object name with desired length append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt;, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.</source>
          <target state="translated">Имя объекта (также известное как SHA-1). Для однозначного сокращения имени объекта добавьте &lt;code&gt;:short&lt;/code&gt; . Для сокращения имени объекта с желаемой длиной добавьте &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; , где минимальная длина - MINIMUM_ABBREV. Длина может быть превышена для обеспечения уникальных имен объектов.</target>
        </trans-unit>
        <trans-unit id="b335d1a75376848bee9affb50a6203b316fcc02d" translate="yes" xml:space="preserve">
          <source>The object referenced by &amp;lt;src&amp;gt; is used to update the &amp;lt;dst&amp;gt; reference on the remote side. Whether this is allowed depends on where in &lt;code&gt;refs/*&lt;/code&gt; the &amp;lt;dst&amp;gt; reference lives as described in detail below, in those sections &quot;update&quot; means any modifications except deletes, which as noted after the next few sections are treated differently.</source>
          <target state="translated">Объект, на который ссылается &amp;lt;src&amp;gt;, используется для обновления ссылки &amp;lt;dst&amp;gt; на удаленной стороне. Разрешено ли это, зависит от того, где в &lt;code&gt;refs/*&lt;/code&gt; находится ссылка &amp;lt;dst&amp;gt;, как подробно описано ниже, в этих разделах &amp;laquo;обновление&amp;raquo; означает любые модификации, кроме удалений, которые, как указано после следующих нескольких разделов, обрабатываются по-разному.</target>
        </trans-unit>
        <trans-unit id="afdbad7acf93ca3457880eb431fd58ab07141e11" translate="yes" xml:space="preserve">
          <source>The object table is actually a hashtable keyed on the object name (the unique SHA-1). This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile. Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source.</source>
          <target state="translated">Таблица объектов на самом деле является хэш-таблицей,к которой привязано имя объекта (уникальный SHA-1).Такая конфигурация хранения позволяет быстро импортировать данные для повторного использования существующего или уже записанного объекта и избежать записи дубликатов в файл выходного пакета.Дубликаты на удивление часто встречаются при импорте,как правило,из-за слияния ветвей в исходном тексте.</target>
        </trans-unit>
        <trans-unit id="0b16e9c4d73790474d293fcd4d96547c235d7d1f" translate="yes" xml:space="preserve">
          <source>The object that the new tag will refer to, usually a commit. Defaults to HEAD.</source>
          <target state="translated">Объект,на который будет ссылаться новый тег,обычно коммит.По умолчанию HEAD.</target>
        </trans-unit>
        <trans-unit id="5468420c6f62137502c6bb00574138b237765047" translate="yes" xml:space="preserve">
          <source>The object type may be a blob, representing the contents of a file, or another tree, representing the contents of a subdirectory. Since trees and blobs, like all other objects, are named by the SHA-1 hash of their contents, two trees have the same SHA-1 name if and only if their contents (including, recursively, the contents of all subdirectories) are identical. This allows Git to quickly determine the differences between two related tree objects, since it can ignore any entries with identical object names.</source>
          <target state="translated">Типом объекта может быть блок,представляющий содержимое файла,или другое дерево,представляющее содержимое поддиректории.Так как деревья и блобы,как и все остальные объекты,именуются по SHA-1 хэшу их содержимого,то два дерева имеют одно и то же SHA-1 имя,если и только в том случае,если их содержимое (включая,рекурсивно,содержимое всех подкаталогов)идентично.Это позволяет Git'у быстро определить различия между двумя связанными объектами дерева,так как он может игнорировать любые записи с одинаковыми именами объектов.</target>
        </trans-unit>
        <trans-unit id="abf9c48e6cb6157bcc4ecdd7fbfd1167ee2a4bc5" translate="yes" xml:space="preserve">
          <source>The object types in some more detail:</source>
          <target state="translated">Объекты типизируются более подробно:</target>
        </trans-unit>
        <trans-unit id="1aa11fdf087f0d8d0d32eb67b923b0efa29ecf46" translate="yes" xml:space="preserve">
          <source>The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id.</source>
          <target state="translated">Объекты выводятся в порядке их нахождения в индексном файле,который должен быть (в правильно построенном файле)отсортирован по идентификатору объекта.</target>
        </trans-unit>
        <trans-unit id="113c9617d3615ff46d1de3788621403d384bc970" translate="yes" xml:space="preserve">
          <source>The official repository of the &lt;code&gt;git gui&lt;/code&gt; project can be found at:</source>
          <target state="translated">Официальный репозиторий проекта &lt;code&gt;git gui&lt;/code&gt; можно найти по адресу:</target>
        </trans-unit>
        <trans-unit id="d2925f4342d92a06228b4eeddfbffd0ada540f91" translate="yes" xml:space="preserve">
          <source>The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:</source>
          <target state="translated">Единственный коммит в этом списке,не связанный с CMake,возможно,был очень хорошо мотивирован работой по исправлению всех тех ошибок,которые были введены при переходе на CMake,но он решает другую проблему.Чтобы разделить эту ветку на две тематические ветки,можно отредактировать список todo таким образом:</target>
        </trans-unit>
        <trans-unit id="680930999bd0e3bf9880124c135a89bca3a329f3" translate="yes" xml:space="preserve">
          <source>The oneline descriptions are purely for your pleasure; &lt;code&gt;git rebase&lt;/code&gt; will not look at them but at the commit names (&quot;deadbee&quot; and &quot;fa1afe1&quot; in this example), so do not delete or edit the names.</source>
          <target state="translated">Однострочные описания предназначены исключительно для вашего удовольствия; &lt;code&gt;git rebase&lt;/code&gt; будет смотреть не на них, а на имена коммитов (&amp;laquo;deadbee&amp;raquo; и &amp;laquo;fa1afe1&amp;raquo; в этом примере), поэтому не удаляйте и не редактируйте имена.</target>
        </trans-unit>
        <trans-unit id="b174b5f513a45da66bee660cec63368b38af2a1f" translate="yes" xml:space="preserve">
          <source>The only difference between this command and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems.</source>
          <target state="translated">Единственное различие между этой командой и &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; состоит в том, что они используют несколько разные форматы вывода, и эта команда существует только для обратной совместимости для поддержки существующих сценариев и предоставления более знакомого имени команды для людей, работающих с другими системами SCM.</target>
        </trans-unit>
        <trans-unit id="90482aceb580582ec33d188b8fb1bca29f8136a1" translate="yes" xml:space="preserve">
          <source>The option can have the following values, defaulting to &lt;code&gt;group&lt;/code&gt; if no value is given:</source>
          <target state="translated">Параметр может иметь следующие значения, по умолчанию для &lt;code&gt;group&lt;/code&gt; если значение не указано:</target>
        </trans-unit>
        <trans-unit id="72a352b7174eb63582b749d1295b267e0dae9887" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;limit&amp;gt; is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:</source>
          <target state="translated">Необязательный &amp;lt;limit&amp;gt; полезен в случаях, когда ваша тема основана на другой работе, не относящейся к апстриму. Если продолжить предыдущий пример, это может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="4136e1c0c625091f77db10ec0b76e55e39fdb1b6" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;style&amp;gt; argument can be either &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one.</source>
          <target state="translated">Необязательный аргумент &amp;lt;style&amp;gt; может быть &lt;code&gt;shallow&lt;/code&gt; или &lt;code&gt;deep&lt;/code&gt; . &lt;code&gt;shallow&lt;/code&gt; цепочка делает каждое письмо ответом на начало серии, где заголовок выбирается из сопроводительного письма, &lt;code&gt;--in-reply-to&lt;/code&gt; и первого патча в этом порядке. &lt;code&gt;deep&lt;/code&gt; цепочка делает каждое письмо ответом на предыдущее.</target>
        </trans-unit>
        <trans-unit id="3dd98bdacd886ba292b303baaba2ecefebed8bab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;encoding&lt;/code&gt; command indicates the encoding of the commit message. Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them.</source>
          <target state="translated">Необязательная команда &lt;code&gt;encoding&lt;/code&gt; указывает кодировку сообщения фиксации. Большинство коммитов - это UTF-8, и кодировка опущена, но это позволяет импортировать сообщения коммитов в git без предварительного их перекодирования.</target>
        </trans-unit>
        <trans-unit id="b0ae75c1b10bf71d7e20ef9926e29585fa74a2e0" translate="yes" xml:space="preserve">
          <source>The optional argument &amp;lt;path&amp;gt; is the relative location for the cloned submodule to exist in the superproject. If &amp;lt;path&amp;gt; is not given, the canonical part of the source repository is used (&quot;repo&quot; for &quot;/path/to/repo.git&quot; and &quot;foo&quot; for &quot;host.xz:foo/.git&quot;). If &amp;lt;path&amp;gt; exists and is already a valid Git repository, then it is staged for commit without cloning. The &amp;lt;path&amp;gt; is also used as the submodule&amp;rsquo;s logical name in its configuration entries unless &lt;code&gt;--name&lt;/code&gt; is used to specify a logical name.</source>
          <target state="translated">Необязательный аргумент &amp;lt;path&amp;gt; - это относительное местоположение клонированного подмодуля, существующего в суперпроекте. Если &amp;lt;path&amp;gt; не указан, используется каноническая часть исходного репозитория (&amp;laquo;репо&amp;raquo; для &amp;laquo;/path/to/repo.git&amp;raquo; и &amp;laquo;foo&amp;raquo; для &amp;laquo;host.xz: foo / .git&amp;raquo;). Если &amp;lt;path&amp;gt; существует и уже является допустимым репозиторием Git, то он готовится к фиксации без клонирования. &amp;lt;path&amp;gt; также используется как логическое имя подмодуля в его записях конфигурации, если &lt;code&gt;--name&lt;/code&gt; не используется для указания логического имени.</target>
        </trans-unit>
        <trans-unit id="476c5c2c4870d6be72c4d31b42e1450136c51807" translate="yes" xml:space="preserve">
          <source>The optional configuration variable &lt;code&gt;core.excludesFile&lt;/code&gt; indicates a path to a file containing patterns of file names to exclude, similar to &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;. Patterns in the exclude file are used in addition to those in &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;.</source>
          <target state="translated">Необязательная переменная конфигурации &lt;code&gt;core.excludesFile&lt;/code&gt; указывает путь к файлу, содержащему шаблоны имен файлов для исключения, аналогично &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; . Шаблоны в файле исключения используются в дополнение к &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; в $ GIT_DIR / info / exclude .</target>
        </trans-unit>
        <trans-unit id="ad80c43bd988ae6e6061dfab8a056d2afaee7691" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--contains&lt;/code&gt;, &lt;code&gt;--no-contains&lt;/code&gt;, &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; serve four related but different purposes:</source>
          <target state="translated">Параметры &lt;code&gt;--contains&lt;/code&gt; , --no &lt;code&gt;--no-contains&lt;/code&gt; , &lt;code&gt;--merged&lt;/code&gt; и --no &lt;code&gt;--no-merged&lt;/code&gt; служат для четырех связанных, но разных целей:</target>
        </trans-unit>
        <trans-unit id="081a3bdc8213b4774c97cebf32978af69c3476cb" translate="yes" xml:space="preserve">
          <source>The order of stages 1, 2 and 3 (hence the order of three &amp;lt;tree-ish&amp;gt; command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:</source>
          <target state="translated">Порядок этапов 1, 2 и 3 (отсюда порядок трех аргументов командной строки &amp;lt;tree-ish&amp;gt;) важен, когда вы начинаете трехстороннее слияние с уже заполненным индексным файлом. Вот краткое описание того, как работает алгоритм:</target>
        </trans-unit>
        <trans-unit id="3fb57cf5101f783ba73fc6eba17ed42ef2940627" translate="yes" xml:space="preserve">
          <source>The order of the flags used to matter, but not anymore.</source>
          <target state="translated">Раньше порядок следования флагов имел значение,но теперь уже нет.</target>
        </trans-unit>
        <trans-unit id="32a54a6aa8ff67e3d76c47c6fabd2affc1e5cbb5" translate="yes" xml:space="preserve">
          <source>The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the &lt;code&gt;-C&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt; options.</source>
          <target state="translated">При переименовании всего файла автоматически отслеживается происхождение строк (в настоящее время нет возможности отключить отслеживание переименования). Чтобы следить за строками, перемещенными из одного файла в другой, или за строками, которые были скопированы и вставлены из другого файла и т. Д., См. &lt;code&gt;-C&lt;/code&gt; и &lt;code&gt;-M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b66619a4ae8f145d6aac4431781b08d6ac86597a" translate="yes" xml:space="preserve">
          <source>The origin revision can be changed with the &quot;--origin&quot; option.</source>
          <target state="translated">Ревизия начала отсчета может быть изменена с помощью опции &quot;--начало&quot;.</target>
        </trans-unit>
        <trans-unit id="617fe8d1d55cfe9ccc09f76fcfa190410b239da3" translate="yes" xml:space="preserve">
          <source>The original format used by Greg Kroah-Hartman&amp;rsquo;s &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; script</source>
          <target state="translated">Исходный формат, используемый скриптом Грега Кроа-Хартмана &lt;code&gt;send_lots_of_email.pl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7a5cdcdcd4d6fcaaf02e53acebd8443c9b015da" translate="yes" xml:space="preserve">
          <source>The original job of &lt;code&gt;git rev-parse&lt;/code&gt; is now taken by the function &lt;code&gt;setup_revisions()&lt;/code&gt;, which parses the revisions and the common command-line options for the revision walker. This information is stored in the struct &lt;code&gt;rev_info&lt;/code&gt; for later consumption. You can do your own command-line option parsing after calling &lt;code&gt;setup_revisions()&lt;/code&gt;. After that, you have to call &lt;code&gt;prepare_revision_walk()&lt;/code&gt; for initialization, and then you can get the commits one by one with the function &lt;code&gt;get_revision()&lt;/code&gt;.</source>
          <target state="translated">Первоначальную работу &lt;code&gt;git rev-parse&lt;/code&gt; теперь выполняет функция &lt;code&gt;setup_revisions()&lt;/code&gt; , которая анализирует версии и общие параметры командной строки для обходчика версий. Эта информация сохраняется в структуре &lt;code&gt;rev_info&lt;/code&gt; для дальнейшего использования. Вы можете выполнить собственный синтаксический анализ параметров командной строки после вызова &lt;code&gt;setup_revisions()&lt;/code&gt; . После этого вы должны вызвать &lt;code&gt;prepare_revision_walk()&lt;/code&gt; для инициализации, а затем вы можете получать коммиты один за другим с помощью функции &lt;code&gt;get_revision()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c9da327e28b59015cec84abd98a33aec635328d" translate="yes" xml:space="preserve">
          <source>The original tags are not deleted, but can be overwritten; use &quot;--tag-name-filter cat&quot; to simply update the tags. In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul.</source>
          <target state="translated">Оригинальные теги не удаляются,но могут быть перезаписаны;используйте &quot;--tag-name-filter cat&quot; для простого обновления тегов.В этом случае,будьте очень осторожны и убедитесь,что у вас есть резервная копия старых тегов на случай,если преобразование прошло неудачно.</target>
        </trans-unit>
        <trans-unit id="6c2cf73d4477ea65ac2368f08dedbcc07c9eafb4" translate="yes" xml:space="preserve">
          <source>The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for &quot;git bisect&quot; when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite.</source>
          <target state="translated">Другая приятная вещь с тестовыми наборами,это то,что когда у тебя есть такой набор,ты уже знаешь,как проверить на плохое поведение.Таким образом,вы можете использовать эти знания для создания нового тестового случая &quot;git-бисекта&quot;,когда кажется,что есть регрессия.Так что будет проще бисектировать ошибку и исправлять её.А затем вы можете добавить только что созданный тестовый кейс в свой набор тестов.</target>
        </trans-unit>
        <trans-unit id="94bda500b4b5c47f0218909469e6ab7f1eee52b6" translate="yes" xml:space="preserve">
          <source>The other way to drive the bisection process is to tell &quot;git bisect&quot; to launch a script or command at each bisection step to know if the current commit is &quot;good&quot; or &quot;bad&quot;. To do that, we use the &quot;git bisect run&quot; command. For example:</source>
          <target state="translated">Другой способ управления биссектрисным процессом-сказать &quot;git-бисексуалу&quot; о запуске скрипта или команды на каждом биссектрисном шаге,чтобы узнать,является ли текущий коммит &quot;хорошим&quot; или &quot;плохим&quot;.Для этого мы используем команду &quot;запуск бисекта git'а&quot;.Например:</target>
        </trans-unit>
        <trans-unit id="013b9f528101f55f667633859403afae697697c4" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable (see below). If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">Формат вывода изменен для машинного анализа (см. Ниже). Если также указан &lt;code&gt;--stdin&lt;/code&gt; , пути ввода разделяются символом NUL вместо символа перевода строки.</target>
        </trans-unit>
        <trans-unit id="4ebdc78d172a0b82e38a898aa2ae716344def4d5" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable. If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">Формат вывода изменен для машинного анализа. Если также указан &lt;code&gt;--stdin&lt;/code&gt; , пути ввода разделяются символом NUL вместо символа перевода строки.</target>
        </trans-unit>
        <trans-unit id="885a3d9b027501a3f7ddd2554d827f984cacfcf5" translate="yes" xml:space="preserve">
          <source>The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated.</source>
          <target state="translated">Формат вывода аналогичен формату &quot;Фарфор&quot;,но он не содержит фактических строк из файла,который аннотируется.</target>
        </trans-unit>
        <trans-unit id="16ca2e6d144e9c4d47f91cfe57ded6c4b6f874af" translate="yes" xml:space="preserve">
          <source>The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time.</source>
          <target state="translated">Вывод этой команды предназначен для использования в качестве шаблонного комментария коммита.По умолчанию,длинный формат,рассчитан на то,чтобы быть удобочитаемым,многословным и описательным.Его содержание и формат могут быть изменены в любое время.</target>
        </trans-unit>
        <trans-unit id="467b04ab4f0f42e5eb4db50995625d7a06a04bbc" translate="yes" xml:space="preserve">
          <source>The output is in the format: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вывод имеет формат: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="297e105083265b9b5df9c784faa30006468bc5fd" translate="yes" xml:space="preserve">
          <source>The output is of the form: &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</source>
          <target state="translated">Вывод имеет вид: &amp;lt;путь&amp;gt; COLON SP &amp;lt;атрибут&amp;gt; COLON SP &amp;lt;info&amp;gt; LF.</target>
        </trans-unit>
        <trans-unit id="00d47eecfb8e7c432b9a2a4461da0aa0b0a14445" translate="yes" xml:space="preserve">
          <source>The output is the new tag&amp;rsquo;s &amp;lt;object&amp;gt; identifier.</source>
          <target state="translated">Результатом является идентификатор &amp;lt;object&amp;gt; нового тега.</target>
        </trans-unit>
        <trans-unit id="c209f5f99a30592095be06f60778bfc6143218e8" translate="yes" xml:space="preserve">
          <source>The output of &quot;git fetch&quot; depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol.</source>
          <target state="translated">Вывод &quot;git fetch&quot; зависит от используемого метода транспортировки;в этом разделе описывается вывод при получении по Git-протоколу (локально или через ssh)и протоколу Smart HTTP.</target>
        </trans-unit>
        <trans-unit id="249df455a76d6d8a4ee813f24ba8c68836888f67" translate="yes" xml:space="preserve">
          <source>The output of &quot;git push&quot; depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).</source>
          <target state="translated">Вывод &quot;git push&quot; зависит от используемого метода транспортировки;в этом разделе описывается вывод при нажатии на Git-протокол (локально или через ssh).</target>
        </trans-unit>
        <trans-unit id="2012a50a7ce95c41c81b087cc42352c50e07741b" translate="yes" xml:space="preserve">
          <source>The output of ls-refs is as follows:</source>
          <target state="translated">Вывод ls-refs выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="c9897264787fe814346af61567793268dae2ec95" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;range-diff&lt;/code&gt; command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable &lt;code&gt;range-diff&lt;/code&gt; (as opposed to something like the &lt;code&gt;--stable&lt;/code&gt; option to &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id[1]&lt;/a&gt;). There&amp;rsquo;s also no equivalent of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for &lt;code&gt;range-diff&lt;/code&gt;, the output is not intended to be machine-readable.</source>
          <target state="translated">Выходные данные команды &lt;code&gt;range-diff&lt;/code&gt; могут быть изменены. Он предназначен для удобочитаемого вывода из фарфора, а не для использования в разных версиях Git для получения текстуально стабильного &lt;code&gt;range-diff&lt;/code&gt; (в отличие от чего-то вроде опции &lt;code&gt;--stable&lt;/code&gt; для &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id [1]&lt;/a&gt; ) , Также нет эквивалента &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt; для &lt;code&gt;range-diff&lt;/code&gt; , вывод не предназначен для машинного чтения.</target>
        </trans-unit>
        <trans-unit id="acccdb81223db3ebfe60a727e12d9a4ed87719fe" translate="yes" xml:space="preserve">
          <source>The output order is determined by the order of glob patterns in &amp;lt;orderfile&amp;gt;. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.</source>
          <target state="translated">Порядок вывода определяется порядком шаблонов глобусов в &amp;lt;orderfile&amp;gt;. Все файлы с именами пути, соответствующими первому шаблону, выводятся первыми, все файлы с именами пути, которые соответствуют второму шаблону (но не первому), выводятся следующими, и так далее. Все файлы с именами пути, которые не соответствуют ни одному шаблону, выводятся последними, как если бы в конце файла был неявный шаблон соответствия всем. Если несколько имен пути имеют одинаковый ранг (они соответствуют одному и тому же шаблону, но не более ранним шаблонам), их порядок вывода относительно друг друга является нормальным порядком.</target>
        </trans-unit>
        <trans-unit id="70ec2e58d64c53608a589a3f892a41e430e23c0e" translate="yes" xml:space="preserve">
          <source>The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:</source>
          <target state="translated">Общее время,необходимое для вычисления этого алгоритма-это время,необходимое для вычисления n+m commit diffs,а затем n*m diffs патчей,плюс время,необходимое для вычисления наименее затратного распределения между n и m diffs.Git использует реализацию алгоритма Джонкера-Волжанта для решения задачи задания,имеющей кубическую сложность во время выполнения.Сопоставление,найденное в этом случае,будет выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="f8c05a901b25f6434301621f82a267dcb0caae54" translate="yes" xml:space="preserve">
          <source>The p4 changes will be created as the user invoking &lt;code&gt;git p4 submit&lt;/code&gt;. The &lt;code&gt;--preserve-user&lt;/code&gt; option will cause ownership to be modified according to the author of the Git commit. This option requires admin privileges in p4, which can be granted using &lt;code&gt;p4 protect&lt;/code&gt;.</source>
          <target state="translated">Изменения p4 будут созданы, когда пользователь вызовет &lt;code&gt;git p4 submit&lt;/code&gt; . Параметр &lt;code&gt;--preserve-user&lt;/code&gt; приведет к изменению права собственности в соответствии с автором коммита Git. Эта опция требует прав администратора в p4, которые могут быть предоставлены с помощью &lt;code&gt;p4 protect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc53387773cbb38b899a330a03a788e5288eab48" translate="yes" xml:space="preserve">
          <source>The p4 client specification is maintained with the &lt;code&gt;p4 client&lt;/code&gt; command and contains among other fields, a View that specifies how the depot is mapped into the client repository. The &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; commands can consult the client spec when given the &lt;code&gt;--use-client-spec&lt;/code&gt; option or when the useClientSpec variable is true. After &lt;code&gt;git p4 clone&lt;/code&gt;, the useClientSpec variable is automatically set in the repository configuration file. This allows future &lt;code&gt;git p4 submit&lt;/code&gt; commands to work properly; the submit command looks only at the variable and does not have a command-line option.</source>
          <target state="translated">Спецификация клиента p4 поддерживается с помощью команды &lt;code&gt;p4 client&lt;/code&gt; и содержит среди других полей представление, которое определяет, как депо отображается в репозиторий клиента. В &lt;code&gt;clone&lt;/code&gt; и &lt;code&gt;sync&lt;/code&gt; команда может обратиться к спецификации клиента , когда предоставляются &lt;code&gt;--use-client-spec&lt;/code&gt; варианта или когда переменная useClientSpec верно. После &lt;code&gt;git p4 clone&lt;/code&gt; переменная useClientSpec автоматически устанавливается в файле конфигурации репозитория. Это позволяет будущим командам &lt;code&gt;git p4 submit&lt;/code&gt; работать правильно; команда submit смотрит только на переменную и не имеет параметра командной строки.</target>
        </trans-unit>
        <trans-unit id="9fec68b06723905b09b9270262e6a13c1b490876" translate="yes" xml:space="preserve">
          <source>The p4 depot path argument to &lt;code&gt;git p4 sync&lt;/code&gt; and &lt;code&gt;git p4 clone&lt;/code&gt; can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:</source>
          <target state="translated">Аргумент пути депо p4 для &lt;code&gt;git p4 sync&lt;/code&gt; и &lt;code&gt;git p4 clone&lt;/code&gt; может быть одним или несколькими разделенными пробелами путями депо p4 с необязательным спецификатором ревизии p4 в конце:</target>
        </trans-unit>
        <trans-unit id="d877dea1de89fdb5a15efd47a5debfe5403b96f4" translate="yes" xml:space="preserve">
          <source>The pack-indexes (.idx files) remain in the pack directory so we can delete the MIDX file, set core.midx to false, or downgrade without any loss of information.</source>
          <target state="translated">Пакеты-индексы (.idx файлы)остаются в каталоге пакетов,поэтому мы можем удалить MIDX-файл,установить core.midx в false или понизить рейтинг без потери информации.</target>
        </trans-unit>
        <trans-unit id="933f30be1e83e4fe09dc8528b693f5b5a75f065d" translate="yes" xml:space="preserve">
          <source>The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack.</source>
          <target state="translated">Формат упакованного архива (.pack)разработан таким образом,чтобы его можно было распаковать без дополнительной информации.Поэтому каждый объект,от которого зависит дельта,должен присутствовать в пакете.</target>
        </trans-unit>
        <trans-unit id="75cd7427877d4a48fded775aaaba114771e37304" translate="yes" xml:space="preserve">
          <source>The packfile(s) created by fast-import do not encourage good disk access patterns. This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data. Git also clusters commits together, speeding up revision traversal through better cache locality.</source>
          <target state="translated">Файлы пакетов,созданные при быстром импорте,не поощряют хорошие шаблоны доступа к диску.Это вызвано тем,что быстрый импорт записывает данные в порядке их поступления на стандартный вход,в то время как Git обычно упорядочивает данные в пакетных файлах,чтобы последние (текущие подсказки)данные появлялись перед историческими данными.Git также собирает коммиты вместе,ускоряя обход ревизий за счёт лучшего расположения кэша.</target>
        </trans-unit>
        <trans-unit id="73715b9a828b5f7ca9623cd366d376d487c8e126" translate="yes" xml:space="preserve">
          <source>The partial clone feature records special &quot;promisor&quot; packs that may point to objects that are not stored locally, but available on request to a server. The multi-pack-index does not currently track these promisor packs.</source>
          <target state="translated">Функция частичного клонирования записывает специальные пакеты &quot;promisor&quot;,которые могут указывать на объекты,которые не хранятся локально,но доступны по запросу к серверу.Мультипакет-индекс в настоящее время не отслеживает эти пакеты &quot;promisor&quot;.</target>
        </trans-unit>
        <trans-unit id="608e992a19f0287b5b2e4cbdc92416d882bd253c" translate="yes" xml:space="preserve">
          <source>The password to use when logging in to the server.</source>
          <target state="translated">Пароль для входа на сервер.</target>
        </trans-unit>
        <trans-unit id="f899bc9ba76fee3c960f01f1f955c5a4bf020e98" translate="yes" xml:space="preserve">
          <source>The patch extracted from e-mail.</source>
          <target state="translated">Заплатка,извлеченная из электронной почты.</target>
        </trans-unit>
        <trans-unit id="621265bbad5d0651c63283720f8a5ccddfdeeb61" translate="yes" xml:space="preserve">
          <source>The patch is expected to be inline, directly following the message. Any line that is of the form:</source>
          <target state="translated">Предполагается,что патч будет встроен непосредственно после сообщения.Любая строка в форме:</target>
        </trans-unit>
        <trans-unit id="eedf9ed2547b7a76bcd6fb69785bf954af8d224f" translate="yes" xml:space="preserve">
          <source>The patch itself does not apply cleanly. That is &lt;code&gt;bad&lt;/code&gt; but does not have much to do with your MUA. You might want to rebase the patch with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; before regenerating it in this case.</source>
          <target state="translated">Сам патч не наносится чисто. Это &lt;code&gt;bad&lt;/code&gt; но не имеет отношения к вашему MUA. В этом случае вы можете захотеть переустановить патч с помощью &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1],&lt;/a&gt; прежде чем регенерировать его.</target>
        </trans-unit>
        <trans-unit id="c9ecbf09d9172bac5285d567a6e1031058a01024" translate="yes" xml:space="preserve">
          <source>The patch produced by &lt;code&gt;git format-patch&lt;/code&gt; is in UNIX mailbox format, with a fixed &quot;magic&quot; time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:</source>
          <target state="translated">Патч, созданный &lt;code&gt;git format-patch&lt;/code&gt; , находится в формате почтового ящика UNIX с фиксированной &amp;laquo;волшебной&amp;raquo; меткой времени, указывающей, что файл выводится из format-patch, а не из реального почтового ящика, например:</target>
        </trans-unit>
        <trans-unit id="7072603eb0a607d061c366f3e4a9cba6cffbd377" translate="yes" xml:space="preserve">
          <source>The path can be either absolute or relative. A relative path is taken as relative to the directory where the hooks are run (see the &quot;DESCRIPTION&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">Путь может быть как абсолютным, так и относительным. Относительный путь берется относительно каталога, в котором выполняются перехватчики (см. Раздел &amp;laquo;ОПИСАНИЕ&amp;raquo; &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6ccace0f35f0f4e5cab0e8cffbdf924135579b2e" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;false&quot;; this is specified by listing the name of the attribute prefixed with a dash &lt;code&gt;-&lt;/code&gt; in the attribute list.</source>
          <target state="translated">У пути есть атрибут со специальным значением &amp;laquo;false&amp;raquo;; это указывается путем перечисления имени атрибута с префиксом тире &lt;code&gt;-&lt;/code&gt; в списке атрибутов.</target>
        </trans-unit>
        <trans-unit id="96cc920a42ed7b296307f756480841c1366430ee" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;true&quot;; this is specified by listing only the name of the attribute in the attribute list.</source>
          <target state="translated">Путь имеет атрибут со специальным значением &quot;true&quot;;это указывается путём перечисления только имени атрибута в списке атрибутов.</target>
        </trans-unit>
        <trans-unit id="f3d259c7dde8e69cba5e131da2dcac58054c5102" translate="yes" xml:space="preserve">
          <source>The path has the attribute with specified string value; this is specified by listing the name of the attribute followed by an equal sign &lt;code&gt;=&lt;/code&gt; and its value in the attribute list.</source>
          <target state="translated">Путь имеет атрибут с указанным строковым значением; это указывается путем перечисления имени атрибута, за которым следует знак равенства &lt;code&gt;=&lt;/code&gt; и его значение в списке атрибутов.</target>
        </trans-unit>
        <trans-unit id="9a89a340b481b20bfabef5b1bcb5482c1e173e57" translate="yes" xml:space="preserve">
          <source>The path to a list of object names (i.e. one unabbreviated SHA-1 per line) that are known to be broken in a non-fatal way and should be ignored. On versions of Git 2.20 and later comments (&lt;code&gt;#&lt;/code&gt;), empty lines, and any leading and trailing whitespace is ignored. Everything but a SHA-1 per line will error out on older versions.</source>
          <target state="translated">Путь к списку имен объектов (т. Е. По одному несокращенному SHA-1 на строку), которые, как известно, нарушаются нефатальным образом и должны игнорироваться. В версиях Git 2.20 и более поздних версиях комментарии ( &lt;code&gt;#&lt;/code&gt; ), пустые строки и любые начальные и конечные пробелы игнорируются. Все, кроме SHA-1 на строку, будет ошибкой в ​​более старых версиях.</target>
        </trans-unit>
        <trans-unit id="66bacdcfb6546645ce51a1173beecea036fe198b" translate="yes" xml:space="preserve">
          <source>The path to higher software quality is significantly improved software testing.</source>
          <target state="translated">Путь к более высокому качеству программного обеспечения-это значительно улучшенное тестирование программного обеспечения.</target>
        </trans-unit>
        <trans-unit id="a62f8e77f19dbb91947274f4224d3b2000deceef" translate="yes" xml:space="preserve">
          <source>The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository&amp;rsquo;s path on the server.</source>
          <target state="translated">Путь, по которому будут использоваться учетные данные. Например, для доступа к удаленному репозиторию https это будет путь к репозиторию на сервере.</target>
        </trans-unit>
        <trans-unit id="75a6542b84624c1ec2a2753cb02bac2dc12deb38" translate="yes" xml:space="preserve">
          <source>The path within the &amp;lt;repository&amp;gt; that the action is performed on, for those actions that require it.</source>
          <target state="translated">Путь в &amp;lt;репозитории&amp;gt;, над которым выполняется действие, для тех действий, которые требуют этого.</target>
        </trans-unit>
        <trans-unit id="42c5355b2496aa717e00373f3c96e2614e271309" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing previously stored cookie lines, which should be used in the Git http session, if they match the server. The file format of the file to read cookies from should be plain HTTP headers or the Netscape/Mozilla cookie file format (see &lt;code&gt;curl(1)&lt;/code&gt;). NOTE that the file specified with http.cookieFile is used only as input unless http.saveCookies is set.</source>
          <target state="translated">Путь к файлу, содержащему ранее сохраненные строки cookie, которые следует использовать в HTTP-сеансе Git, если они соответствуют серверу. Формат файла для чтения файлов cookie должен быть простым заголовком HTTP или форматом файла cookie Netscape / Mozilla (см. &lt;code&gt;curl(1)&lt;/code&gt; ). ОБРАТИТЕ ВНИМАНИЕ, что файл, указанный с помощью http.cookieFile, используется только в качестве входных данных, если не установлен http.saveCookies.</target>
        </trans-unit>
        <trans-unit id="cdb891f79fbec881d22446bf8cf74ef0a3e451e0" translate="yes" xml:space="preserve">
          <source>The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below.</source>
          <target state="translated">Пути,упомянутые в выводе,в отличие от многих других команд Git'а,создаются относительно текущей директории,если вы работаете в подкаталоге (это специально для помощи в вырезании и вставке).См.ниже опцию конфигурации status.relativePaths.</target>
        </trans-unit>
        <trans-unit id="ae851010ea42ad696931dec57e7a58d6d0655b81" translate="yes" xml:space="preserve">
          <source>The pathspecs are used to limit the world diff operates in. They remove the filepairs outside the specified sets of pathnames. E.g. If the input set of filepairs included:</source>
          <target state="translated">С помощью pathspecs ограничивается диапазон мира,в котором работает диффирамма.Они удаляют пары файлов вне заданных наборов имен.Например,если входной набор пар файлов включен:</target>
        </trans-unit>
        <trans-unit id="a35fe6e03b5cf8e686f61a60362e87d3cf937722" translate="yes" xml:space="preserve">
          <source>The pattern &quot;foo/*&quot;, matches &quot;foo/test.json&quot; (a regular file), &quot;foo/bar&quot; (a directory), but it does not match &quot;foo/bar/hello.c&quot; (a regular file), as the asterisk in the pattern does not match &quot;bar/hello.c&quot; which has a slash in it.</source>
          <target state="translated">Шаблон &quot;foo/*&quot; совпадает с &quot;foo/test.json&quot; (обычный файл),&quot;foo/bar&quot; (каталог),но не совпадает с &quot;foo/bar/hello.c&quot; (обычный файл),так как звездочка в шаблоне не совпадает со звездочкой &quot;bar/hello.c&quot;,в которой есть косая черта.</target>
        </trans-unit>
        <trans-unit id="472a6ff8d8e6e0153adf76e5ad83f89df7215b9f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;doc/frotz&lt;/code&gt; and &lt;code&gt;/doc/frotz&lt;/code&gt; have the same effect in any &lt;code&gt;.gitignore&lt;/code&gt; file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.</source>
          <target state="translated">Узор &lt;code&gt;doc/frotz&lt;/code&gt; и &lt;code&gt;/doc/frotz&lt;/code&gt; имеют тот же эффект в любом &lt;code&gt;.gitignore&lt;/code&gt; файле. Другими словами, ведущая косая черта не имеет значения, если в шаблоне уже есть средняя косая черта.</target>
        </trans-unit>
        <trans-unit id="7f3e3da749b8fed6cc11585c7aa5dbe77eee53ad" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;foo/&lt;/code&gt; will match a directory &lt;code&gt;foo&lt;/code&gt; and paths underneath it, but will not match a regular file or a symbolic link &lt;code&gt;foo&lt;/code&gt; (this is consistent with the way how pathspec works in general in Git)</source>
          <target state="translated">Шаблон &lt;code&gt;foo/&lt;/code&gt; будет соответствовать каталогу &lt;code&gt;foo&lt;/code&gt; и путям под ним, но не будет соответствовать обычному файлу или символической ссылке &lt;code&gt;foo&lt;/code&gt; (это согласуется с тем, как pathspec в целом работает в Git)</target>
        </trans-unit>
        <trans-unit id="32166ee916b00891724c1bd52223b5e1e2d10da0" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;hello.*&lt;/code&gt; matches any file or folder whose name begins with &lt;code&gt;hello&lt;/code&gt;. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. &lt;code&gt;/hello.*&lt;/code&gt;; the pattern now matches &lt;code&gt;hello.txt&lt;/code&gt;, &lt;code&gt;hello.c&lt;/code&gt; but not &lt;code&gt;a/hello.java&lt;/code&gt;.</source>
          <target state="translated">Шаблон &lt;code&gt;hello.*&lt;/code&gt; Соответствует любому файлу или папке, имя которых начинается с &lt;code&gt;hello&lt;/code&gt; . Если кто-то хочет ограничить это только каталогом, а не его подкаталогами, можно добавить перед шаблоном косую черту, т.е. &lt;code&gt;/hello.*&lt;/code&gt; ; шаблон теперь соответствует &lt;code&gt;hello.txt&lt;/code&gt; , &lt;code&gt;hello.c&lt;/code&gt; , но не &lt;code&gt;a/hello.java&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b35cb663783a3682a66157f3dc9fd508efdfceba" translate="yes" xml:space="preserve">
          <source>The pattern can contain standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. Please refer to &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for details. For convenience:</source>
          <target state="translated">Шаблон может содержать стандартные подстановочные знаки подстановки и два дополнительных, &lt;code&gt;**/&lt;/code&gt; и &lt;code&gt;/**&lt;/code&gt; , которые могут соответствовать нескольким компонентам пути. Пожалуйста, обратитесь к &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; за подробностями. Для удобства:</target>
        </trans-unit>
        <trans-unit id="ae88d32c3f9079756948f2fdc8ae4c4c2e834b93" translate="yes" xml:space="preserve">
          <source>The patterns given should not begin with &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, or &lt;code&gt;refs/remotes&lt;/code&gt; when applied to &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, or &lt;code&gt;--remotes&lt;/code&gt;, respectively, and they must begin with &lt;code&gt;refs/&lt;/code&gt; when applied to &lt;code&gt;--glob&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt;. If a trailing &lt;code&gt;/*&lt;/code&gt; is intended, it must be given explicitly.</source>
          <target state="translated">Приведенные шаблоны не должны начинаться с &lt;code&gt;refs/heads&lt;/code&gt; , &lt;code&gt;refs/tags&lt;/code&gt; или &lt;code&gt;refs/remotes&lt;/code&gt; при применении к &lt;code&gt;--branches&lt;/code&gt; , &lt;code&gt;--tags&lt;/code&gt; или &lt;code&gt;--remotes&lt;/code&gt; соответственно, и они должны начинаться с &lt;code&gt;refs/&lt;/code&gt; при применении к &lt;code&gt;--glob&lt;/code&gt; или &lt;code&gt;--all&lt;/code&gt; . Если предполагается завершающий &lt;code&gt;/*&lt;/code&gt; , он должен быть указан явно.</target>
        </trans-unit>
        <trans-unit id="86b0de7f6b1176e8c07c5aaa523447c3abd4915b" translate="yes" xml:space="preserve">
          <source>The performance format target (PERF) is a column-based format to replace GIT_TRACE_PERFORMANCE and is suitable for development and testing, possibly to complement tools like gprof. This format is enabled with the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable or the &lt;code&gt;trace2.perfTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">Целевой формат производительности (PERF) - это формат на основе столбцов, который заменяет GIT_TRACE_PERFORMANCE и подходит для разработки и тестирования, возможно, для дополнения таких инструментов, как gprof. Этот формат включен с &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; переменной окружения или &lt;code&gt;trace2.perfTarget&lt;/code&gt; системы или глобальные настройки конфигурации.</target>
        </trans-unit>
        <trans-unit id="506071bbd9d0908b14e8f015ca1b0ff23e4ec21e" translate="yes" xml:space="preserve">
          <source>The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:</source>
          <target state="translated">Производительность git-фильтровальной линейки медленна в ледниковом режиме;ее конструкция делает невозможным,чтобы обратно совместимая реализация когда-либо была быстрой:</target>
        </trans-unit>
        <trans-unit id="d698b970e30734158c98cc5647b57a259a47bb36" translate="yes" xml:space="preserve">
          <source>The person who put a piece of code into Git.</source>
          <target state="translated">Человек,который вставил кусок кода в Гита.</target>
        </trans-unit>
        <trans-unit id="81b84527afb0ae2e697e75bbd7638af25fa12741" translate="yes" xml:space="preserve">
          <source>The pickaxe search is described in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; (the description of &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; option, which refers to pickaxe entry in &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt; for more details).</source>
          <target state="translated">Поиск кирки описан в &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; (описание опции &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; , которая относится к записи кирки в &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt; для более подробной информации).</target>
        </trans-unit>
        <trans-unit id="525e6a0e6ee3d9fa31ab39c46532aa0c693111e1" translate="yes" xml:space="preserve">
          <source>The placeholders are:</source>
          <target state="translated">Держатели мест:</target>
        </trans-unit>
        <trans-unit id="1651136b42ed906ec527c0b5bb6ead2e015774c3" translate="yes" xml:space="preserve">
          <source>The point of this helper is to reduce the number of times you must type your username or password. For example:</source>
          <target state="translated">Смысл этого помощника заключается в том,чтобы уменьшить количество раз,когда вы должны ввести имя пользователя или пароль.Например:</target>
        </trans-unit>
        <trans-unit id="c89cea9d29e269d3d21a2bb103d39e43b1e539d2" translate="yes" xml:space="preserve">
          <source>The porcelain format</source>
          <target state="translated">Формат фарфора</target>
        </trans-unit>
        <trans-unit id="26e08a1995b67cc0010521ba6bed170106483645" translate="yes" xml:space="preserve">
          <source>The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The &lt;code&gt;--line-porcelain&lt;/code&gt; option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:</source>
          <target state="translated">Формат фарфора обычно подавляет информацию о фиксации, которая уже была просмотрена. Например, будут показаны две строки, относящиеся к одной и той же фиксации, но детали для этой фиксации будут показаны только один раз. Это более эффективно, но может потребовать от читателя сохранения большего количества состояний. Параметр &lt;code&gt;--line-porcelain&lt;/code&gt; может использоваться для вывода полной информации о фиксации для каждой строки, что позволяет более простое (но менее эффективное) использование, например:</target>
        </trans-unit>
        <trans-unit id="20c54b7279b5d1b2be6928d44083be1fd00dfbb8" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are only present if and only if the value is true. The first attribute of a worktree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">Формат фарфора имеет строку для каждого атрибута. Атрибуты перечислены с меткой и значением, разделенными одним пробелом. Булевы атрибуты (например, &lt;code&gt;bare&lt;/code&gt; и &lt;code&gt;detached&lt;/code&gt; ) перечислены только как метка и присутствуют только тогда и только тогда, когда значение истинно. Первым атрибутом рабочего дерева всегда является &lt;code&gt;worktree&lt;/code&gt; , пустая строка указывает конец записи. Например:</target>
        </trans-unit>
        <trans-unit id="a362940b066b853917862099c8e9ab263cba72b1" translate="yes" xml:space="preserve">
          <source>The port number to bind the gitweb httpd to. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">Номер порта, к которому нужно привязать gitweb httpd. См. &lt;a href=&quot;git-instaweb&quot;&gt;Git-instaweb [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0cecf31c324042fa16f4839249194885b3982bae" translate="yes" xml:space="preserve">
          <source>The port number to bind the httpd to. (Default: 1234)</source>
          <target state="translated">Номер порта,к которому нужно привязать httpd.(По умолчанию:1234)</target>
        </trans-unit>
        <trans-unit id="735bfd35b5b101e4c116696c3cd1ebf6bc58faa9" translate="yes" xml:space="preserve">
          <source>The possible options are:</source>
          <target state="translated">Возможные варианты:</target>
        </trans-unit>
        <trans-unit id="8bc0e360ec6eefb74bc5a1aed65f13e846b6d915" translate="yes" xml:space="preserve">
          <source>The preferred strategy for rolling out a version bump (whether whole repository or for a single file) is to teach git to read the new format, and allow writing the new format with a config switch or command line option (for experimentation or for those who do not care about backwards compatibility with older gits). Then after a long period to allow the reading capability to become common, we may switch to writing the new format by default.</source>
          <target state="translated">Предпочтительная стратегия развертывания бампа версии (как для всего репозитория,так и для одного файла)-научить git'а читать новый формат и разрешить запись нового формата с помощью конфигурационного переключателя или опции командной строки (для экспериментов или для тех,кого не волнует обратная совместимость со старыми gits'ами).Затем,по прошествии долгого времени,чтобы возможность чтения стала обычным делом,мы можем переключиться на запись нового формата по умолчанию.</target>
        </trans-unit>
        <trans-unit id="adf8f6f66c16d1ab5dcd5c39342b75931e439ba4" translate="yes" xml:space="preserve">
          <source>The prefix ability basically makes it trivial to use &lt;code&gt;git checkout-index&lt;/code&gt; as an &quot;export as tree&quot; function. Just read the desired tree into the index, and do:</source>
          <target state="translated">Возможность префикса в основном упрощает использование &lt;code&gt;git checkout-index&lt;/code&gt; в качестве функции &amp;laquo;экспорта в виде дерева&amp;raquo;. Просто прочтите нужное дерево в индексе и выполните:</target>
        </trans-unit>
        <trans-unit id="0f1fc4f35ab6b79f4468bd7525c0542dc9193da5" translate="yes" xml:space="preserve">
          <source>The previously introduced &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; is just a wrapper for &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">Ранее представленный &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; - это просто оболочка для &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="675ae216ecd575fef2e1ffa9eadeda52bdab6e90" translate="yes" xml:space="preserve">
          <source>The primary problem with rewriting the history of a branch has to do with merging. Suppose somebody fetches your branch and merges it into their branch, with a result something like this:</source>
          <target state="translated">Основная проблема с переписыванием истории ветки связана со слиянием.Предположим,что кто-то забирает ваше ответвление и сливает его в своё ответвление,в результате чего получается что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="ff3dc4a94f1f540e3dd725f6eef6c2d405d85a87" translate="yes" xml:space="preserve">
          <source>The primary tool we&amp;rsquo;ve been using to create commits is &lt;code&gt;git-commit
-a&lt;/code&gt;, which creates a commit including every change you&amp;rsquo;ve made to your working tree. But what if you want to commit changes only to certain files? Or only certain changes to certain files?</source>
          <target state="translated">Основным инструментом, который мы использовали для создания &lt;code&gt;git-commit -a&lt;/code&gt; , является git-commit -a , который создает коммит, включающий все изменения, внесенные вами в свое рабочее дерево. Но что, если вы хотите зафиксировать изменения только в определенных файлах? Или только определенные изменения в определенных файлах?</target>
        </trans-unit>
        <trans-unit id="bc32172ebad82b3a8531284b76fc91d0e2655fc8" translate="yes" xml:space="preserve">
          <source>The protection it offers over &lt;code&gt;--force&lt;/code&gt; is ensuring that subsequent changes your work wasn&amp;rsquo;t based on aren&amp;rsquo;t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don&amp;rsquo;t have anything except the remote tracking info to go by as a heuristic for refs you&amp;rsquo;re expected to have seen &amp;amp; are willing to clobber.</source>
          <target state="translated">Защита, которую он предлагает сверх &lt;code&gt;--force&lt;/code&gt; , гарантирует, что последующие изменения, на которых ваша работа не основана, не затерты, но это тривиально побеждено, если какой-то фоновый процесс обновляет ссылки в фоновом режиме. У нас нет ничего, кроме информации об удаленном отслеживании, которую можно было бы использовать в качестве эвристики для ссылок, которые вы, как ожидается, видели и готовы заткнуть.</target>
        </trans-unit>
        <trans-unit id="c8ef7004934ae749808b9e22322b2c11275f98e4" translate="yes" xml:space="preserve">
          <source>The protocol names currently used by git are:</source>
          <target state="translated">Имена протоколов,которые в настоящее время используются git'ом:</target>
        </trans-unit>
        <trans-unit id="19913c2c5a680884fd5ab271ea84dfe92e10bf53" translate="yes" xml:space="preserve">
          <source>The protocol over which the credential will be used (e.g., &lt;code&gt;https&lt;/code&gt;).</source>
          <target state="translated">Протокол, по которому будут использоваться учетные данные (например, &lt;code&gt;https&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="27c53e4d1c63b3496c93b1976851fe0522937712" translate="yes" xml:space="preserve">
          <source>The provided options must not contain a NUL or LF character.</source>
          <target state="translated">Предоставляемые опции не должны содержать символов NUL или LF.</target>
        </trans-unit>
        <trans-unit id="5fb1f43ddd5fc4b8ac18d086f82e6f88c9ed5855" translate="yes" xml:space="preserve">
          <source>The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.</source>
          <target state="translated">Цель gitignore-файлов-обеспечить,чтобы определённые файлы,не отслеживаемые Git'ом,оставались не отслеженными.</target>
        </trans-unit>
        <trans-unit id="a2b9675d20ab3c1e80e15b296d660914f6ea2131" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not suppressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. A non-zero exit means a failure of the hook and aborts the commit. It should not be used as replacement for pre-commit hook.</source>
          <target state="translated">Целью ловушки является редактирование файла сообщения на месте, и это не подавляется параметром &lt;code&gt;--no-verify&lt;/code&gt; . Ненулевой выход означает отказ ловушки и отмену фиксации. Его не следует использовать как замену ловушке перед фиксацией.</target>
        </trans-unit>
        <trans-unit id="383a661ab7ffdec395082f1f22f245f53263885b" translate="yes" xml:space="preserve">
          <source>The push URL of a remote repository. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">URL-адрес удаленного репозитория. См. &lt;a href=&quot;git-push&quot;&gt;Git-push [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8cd29a2b80ae7f4721c7a9c69324052af609357" translate="yes" xml:space="preserve">
          <source>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</source>
          <target state="translated">Толчок,сделанный другим человеком,обновил ветку,которая использовалась для указания на коммит X,чтобы указать на коммит A.Это быстрая перемотка вперед.</target>
        </trans-unit>
        <trans-unit id="79a20eedac198c71849aef6d1fe1606ea1ee319f" translate="yes" xml:space="preserve">
          <source>The quilt series file.</source>
          <target state="translated">Файл серии одеял.</target>
        </trans-unit>
        <trans-unit id="eb2f9ed5ec284eab8396a9b582f3da5582d364ca" translate="yes" xml:space="preserve">
          <source>The raw output format from &quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot; and &quot;git diff --raw&quot; are very similar.</source>
          <target state="translated">Формат исходного вывода из &quot;git-diff-index&quot;,&quot;git-diff-tree&quot;,&quot;git-diff-files&quot; и &quot;git-diff --raw&quot; очень похож.</target>
        </trans-unit>
        <trans-unit id="a6ab1028c44c2d54846a9217b4a7ad959d178f38" translate="yes" xml:space="preserve">
          <source>The reachability bitmap is currently paired directly with a single packfile, using the pack-order as the object order to hopefully compress the bitmaps well using run-length encoding. This could be extended to pair a reachability bitmap with a multi-pack-index. If the multi-pack-index is extended to store a &quot;stable object order&quot; (a function Order(hash) = integer that is constant for a given hash, even as the multi-pack-index is updated) then a reachability bitmap could point to a multi-pack-index and be updated independently.</source>
          <target state="translated">В настоящее время растровое изображение доступно в паре непосредственно с одним пакетным файлом,используя пакетный порядок в качестве объекта,чтобы,надеюсь,хорошо сжимать растровые изображения с помощью кодирования длины пробега.Это может быть расширено до пары достижимого растрового изображения с мультипаковым индексом.Если Multi-pack-index расширен для хранения &quot;стабильного порядка объектов&quot; (функция Order(hash)=целое число,которое является постоянным для данного хэша,даже при обновлении Multi-pack-index),то растровое изображение достижимости может указывать на мультипакет-индекс и обновляться независимо.</target>
        </trans-unit>
        <trans-unit id="0aca04dff2f76e52dde4dcdd1542bfe4e1470100" translate="yes" xml:space="preserve">
          <source>The reason fast-import uses &lt;code&gt;:&lt;/code&gt; to denote a mark reference is this character is not legal in a Git branch name. The leading &lt;code&gt;:&lt;/code&gt; makes it easy to distinguish between the mark 42 (&lt;code&gt;:42&lt;/code&gt;) and the branch 42 (&lt;code&gt;42&lt;/code&gt; or &lt;code&gt;refs/heads/42&lt;/code&gt;), or an abbreviated SHA-1 which happened to consist only of base-10 digits.</source>
          <target state="translated">Причина, по которой в быстром импорте используется &lt;code&gt;:&lt;/code&gt; для обозначения ссылки на метку, этот символ недопустим в имени ветки Git. Интерлиньяж &lt;code&gt;:&lt;/code&gt; позволяет легко различать метку 42 ( &lt;code&gt;:42&lt;/code&gt; ) и ветвь 42 ( &lt;code&gt;42&lt;/code&gt; или &lt;code&gt;refs/heads/42&lt;/code&gt; ) или сокращенный SHA-1, который состоит только из цифр с основанием 10.</target>
        </trans-unit>
        <trans-unit id="1aba410e8fcfe74102eea2fcf73898889acee3ed" translate="yes" xml:space="preserve">
          <source>The reason it doesn&amp;rsquo;t error out when provided without &lt;code&gt;--prune&lt;/code&gt; or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do.</source>
          <target state="translated">Причина, по которой он не выводит ошибку, когда он предоставляется без &lt;code&gt;--prune&lt;/code&gt; или его версий конфигурации, заключается в гибкости настроенных версий и в поддержании соответствия 1 = 1 между тем, что делают флаги командной строки, и тем, что делают версии конфигурации.</target>
        </trans-unit>
        <trans-unit id="b2defd752d90b2a93e28eb3efe0e516f3fc264fc" translate="yes" xml:space="preserve">
          <source>The rebase will stop where &lt;code&gt;pick&lt;/code&gt; has been replaced with &lt;code&gt;edit&lt;/code&gt; or when a step in the list fails to mechanically resolve conflicts and needs your help. When you are done editing and/or resolving conflicts you can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;. If you decide that things are getting too hairy, you can always bail out with &lt;code&gt;git rebase
--abort&lt;/code&gt;. Even after the rebase is complete, you can still recover the original branch by using the &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;.</source>
          <target state="translated">Перебазирование будет остановлено там, где &lt;code&gt;pick&lt;/code&gt; был заменен на &lt;code&gt;edit&lt;/code&gt; или когда шаг в списке не может механически разрешить конфликты и требует вашей помощи. Когда вы закончите редактирование и / или разрешение конфликтов, вы можете продолжить с помощью &lt;code&gt;git rebase --continue&lt;/code&gt; . Если вы решите, что ситуация становится слишком сложной, вы всегда можете спастись с помощью &lt;code&gt;git rebase --abort&lt;/code&gt; . Даже после завершения перестановки вы все равно можете восстановить исходную ветку с помощью &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="939cf091c711a461fc7775d9278b48a4457f30c1" translate="yes" xml:space="preserve">
          <source>The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the &lt;code&gt;refs/heads/&lt;/code&gt; hierarchy is used to represent local branches).</source>
          <target state="translated">Пространство имен ref является иерархическим. Для разных целей используются разные подиерархии (например, &lt;code&gt;refs/heads/&lt;/code&gt; иерархия используются для представления локальных ветвей).</target>
        </trans-unit>
        <trans-unit id="d11d2f57237e560f1ae2f7da112ae694568b2d78" translate="yes" xml:space="preserve">
          <source>The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; options in the same way as &lt;code&gt;refname&lt;/code&gt; above.</source>
          <target state="translated">Ссылка, на которую ссылается данный символический номер. Если не символическая ссылка, ничего не печатается. Уважает &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; и &lt;code&gt;:rstrip&lt;/code&gt; вариантов таким же образом , как &lt;code&gt;refname&lt;/code&gt; выше.</target>
        </trans-unit>
        <trans-unit id="09256802b46aa557905f47df9fc0a1148d341199" translate="yes" xml:space="preserve">
          <source>The reflogs are kept by default for 30 days, after which they may be pruned. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; and &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; to learn how to control this pruning, and see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">Рефлоги по умолчанию хранятся в течение 30 дней, после чего их можно удалить. См. &lt;a href=&quot;git-reflog&quot;&gt;Git-reflog [1]&lt;/a&gt; и &lt;a href=&quot;git-gc&quot;&gt;git-gc [1],&lt;/a&gt; чтобы узнать, как управлять этим сокращением, а также подробности в разделе &amp;laquo; &lt;a href=&quot;gitrevisions&quot;&gt;УКАЗАНИЕ&lt;/a&gt; ИЗМЕНЕНИЙ&amp;raquo; в gitrevisions [7] .</target>
        </trans-unit>
        <trans-unit id="29e87ce112fa8f38582e71025c0e3c162626939f" translate="yes" xml:space="preserve">
          <source>The refname parameter is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 arguments are the object names for the refname before and after the update. Note that the hook is called before the refname is updated, so either sha1-old is 0{40} (meaning there is no such ref yet), or it should match what is recorded in refname.</source>
          <target state="translated">Параметр refname относится к $GIT_DIR;например,для головы ведущего это &quot;refs/heads/master&quot;.Два аргумента sha1-это имена объектов для имени ссылки до и после обновления.Обратите внимание,что крюк вызывается до обновления имени,поэтому либо sha1-old равен 0{40}.(это означает,что такого реффикса еще нет),или он должен совпадать с тем,что записано в имени реффикса.</target>
        </trans-unit>
        <trans-unit id="21810fe3549bedbdcfb85519d93701f4c1ec8042" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs that were created will have sha1-old equal to 0{40}, while refs that were deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">Значение имени refname относительно $GIT_DIR;например,для головы-ведущего это &quot;refs/heads/master&quot;.Два значения sha1 перед каждым именем ссылки-это имена объектов для имени ссылки до и после обновления.Ссылки,которые были созданы,будут иметь sha1-old равное 0{40},в то время как удаленные будут иметь sha1-new равное 0{40},в противном случае sha1-old и sha1-new должны быть действительными объектами в хранилище.</target>
        </trans-unit>
        <trans-unit id="f7cd6bb7198b77eda24e90f3bdabb1a4fb56aeb0" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs to be created will have sha1-old equal to 0{40}, while refs to be deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">Значение имени refname относительно $GIT_DIR;например,для головы-ведущего это &quot;refs/heads/master&quot;.Два значения sha1 перед каждым именем ссылки-это имена объектов для имени ссылки до и после обновления.Создаваемые ссылки будут иметь sha1-old равное 0{40},в то время как удаляемые ссылки будут иметь sha1-new равное 0{40},в противном случае sha1-old и sha1-new должны быть действительными объектами в хранилище.</target>
        </trans-unit>
        <trans-unit id="ce26e3499eea5a4c24942a8e072b3a9539557d0b" translate="yes" xml:space="preserve">
          <source>The regex can also be set via a diff driver or configuration option, see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; or &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.</source>
          <target state="translated">Регулярное выражение также можно установить с помощью драйвера diff или параметра конфигурации, см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; или &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; . Его предоставление явно отменяет любой драйвер diff или настройку конфигурации. Драйверы различий переопределяют параметры конфигурации.</target>
        </trans-unit>
        <trans-unit id="db9cbae31eee7dd0453a2f75d2431a49c7ce5a43" translate="yes" xml:space="preserve">
          <source>The regex must capture the source branch name in $1.</source>
          <target state="translated">Регекс должен захватить имя ветки-источника в $1.</target>
        </trans-unit>
        <trans-unit id="2f22e3781909efae9d373f9fa46942441b8a264c" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Регулярное выражение, которое драйвер diff должен использовать для распознавания заголовка ханка. Также может использоваться встроенный шаблон. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4211f7342bdc098f581fc9d7939f84dc24cd9689" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to split words in a line. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Регулярное выражение, которое драйвер diff должен использовать для разделения слов в строке. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f0619f2eb83a7faf485cba23bd4bbef8fb0cb4dd" translate="yes" xml:space="preserve">
          <source>The remainder of the line, after stripping the spaces, is used as the help associated to the option.</source>
          <target state="translated">Оставшаяся часть строки после удаления пробелов используется в качестве справки,связанной с опцией.</target>
        </trans-unit>
        <trans-unit id="19c5350e9da63f63a8abbccc7168a03dfd13ebac" translate="yes" xml:space="preserve">
          <source>The remaining features cannot be overridden on a per project basis.</source>
          <target state="translated">Остальные функции не могут быть переопределены для каждого проекта.</target>
        </trans-unit>
        <trans-unit id="303228bfc99fc67a561e0782dc3e0ceb08c259bb" translate="yes" xml:space="preserve">
          <source>The remote branch name for a submodule, used by &lt;code&gt;git submodule
update --remote&lt;/code&gt;. Set this option to override the value found in the &lt;code&gt;.gitmodules&lt;/code&gt; file. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">Имя удаленной ветки для подмодуля, используемое &lt;code&gt;git submodule update --remote&lt;/code&gt; . Установите этот параметр, чтобы переопределить значение, найденное в файле &lt;code&gt;.gitmodules&lt;/code&gt; . См. Подробности в &lt;a href=&quot;git-submodule&quot;&gt;git- &lt;/a&gt;&lt;a href=&quot;gitmodules&quot;&gt;submodule [ &lt;/a&gt;1] и gitmodules [5] .</target>
        </trans-unit>
        <trans-unit id="4fdf928f1cd746e7574e5e26895f63052b9e3300" translate="yes" xml:space="preserve">
          <source>The remote configuration is achieved using the &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Удаленная конфигурация достигается с использованием переменных конфигурации &lt;code&gt;remote.origin.url&lt;/code&gt; и &lt;code&gt;remote.origin.fetch&lt;/code&gt; . (См. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7b65b070cfabceee72964f903404025034f8258" translate="yes" xml:space="preserve">
          <source>The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.</source>
          <target state="translated">Удаленный конец не сообщил об успешном обновлении ссылки,возможно,из-за временной ошибки на удаленной стороне,перерыва в сетевом соединении или другой временной ошибки.</target>
        </trans-unit>
        <trans-unit id="53c927a78ca0c11dc61a2c100f0e02c446d49374" translate="yes" xml:space="preserve">
          <source>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (for pushes to the checked out branch), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (for forced non-fast-forward updates), &lt;code&gt;receive.denyDeletes&lt;/code&gt; or &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt;. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Удаленный конец отклонил обновление. Обычно вызывается перехватчиком на удаленной стороне или потому, что в удаленном репозитории действует одна из следующих опций безопасности: &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (для отправки на извлеченную ветку), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (для принудительных обновлений без быстрой перемотки вперед). ), &lt;code&gt;receive.denyDeletes&lt;/code&gt; или &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt; . См. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9422d899b3eadda77c8387091e37d96facb6c2f" translate="yes" xml:space="preserve">
          <source>The remote heads to update from. This is relative to $GIT_DIR (e.g. &quot;HEAD&quot;, &quot;refs/heads/master&quot;). When unspecified, update from all heads the remote side has.</source>
          <target state="translated">Удаленные головки для обновления.Это относительно $GIT_DIR (например,&quot;HEAD&quot;,&quot;refs/heads/master&quot;).Если не указано,обновите информацию со всех головок,имеющихся на удаленной стороне.</target>
        </trans-unit>
        <trans-unit id="0419c5b470511fe246bdc207ab1f44978b5929c7" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential.</source>
          <target state="translated">Имя удаленного хоста для сетевой учетной записи.</target>
        </trans-unit>
        <trans-unit id="a7632b9807699f7e6cd146f3dd66e0428b068933" translate="yes" xml:space="preserve">
          <source>The remote ref that matches &amp;lt;src&amp;gt; is fetched, and if &amp;lt;dst&amp;gt; is not an empty string, an attempt is made to update the local ref that matches it.</source>
          <target state="translated">Выбирается удаленная ссылка, которая соответствует &amp;lt;src&amp;gt;, и если &amp;lt;dst&amp;gt; не является пустой строкой, делается попытка обновить локальную ссылку, которая соответствует ей.</target>
        </trans-unit>
        <trans-unit id="282ef7eedc5a5bdee9740e04ed8375ea205f3da3" translate="yes" xml:space="preserve">
          <source>The remote refs to update.</source>
          <target state="translated">Удаленные ссылки для обновления.</target>
        </trans-unit>
        <trans-unit id="1126548b6dd0a73d0e4b3cf8a47f765ced5296ec" translate="yes" xml:space="preserve">
          <source>The remote to push to by default. Overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for all branches, and is overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; for specific branches.</source>
          <target state="translated">Пульт, на который нужно нажать по умолчанию. Переопределяет &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; для всех ветвей и переопределяется &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; для определенных ветвей.</target>
        </trans-unit>
        <trans-unit id="69cc315a656a6408b19c28c1250214347094ab33" translate="yes" xml:space="preserve">
          <source>The replaced object and the replacement object must be of the same type. This restriction can be bypassed using &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">Заменяемый объект и замещающий объект должны быть одного типа. Это ограничение можно обойти с помощью &lt;code&gt;-f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ad56792b1c232c0733d7ad92a2a6edfcbfd7d1e" translate="yes" xml:space="preserve">
          <source>The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as &lt;code&gt;git diff&lt;/code&gt; or the &quot;pickaxe&quot; interface briefly mentioned in the following paragraph.</source>
          <target state="translated">В отчете ничего не говорится о строках, которые были удалены или заменены; вам нужно использовать такой инструмент, как &lt;code&gt;git diff&lt;/code&gt; или интерфейс &amp;laquo;кирки&amp;raquo;, кратко упомянутый в следующем абзаце.</target>
        </trans-unit>
        <trans-unit id="2c986c29f6ffa22f2a8c706bbb75b7aeb4461294" translate="yes" xml:space="preserve">
          <source>The repository URL to be pulled from.</source>
          <target state="translated">URL-адрес репозитория,из которого нужно вытащить.</target>
        </trans-unit>
        <trans-unit id="944d2d5ccd37faa608b4a3dce165543a5adf2fbf" translate="yes" xml:space="preserve">
          <source>The repository the action will be performed on.</source>
          <target state="translated">В репозитории будет произведено действие.</target>
        </trans-unit>
        <trans-unit id="0e7c4601cfd7634812fd5318d08d4f529fb59bef" translate="yes" xml:space="preserve">
          <source>The repository to get a tar archive from.</source>
          <target state="translated">Хранилище для получения архива смолы.</target>
        </trans-unit>
        <trans-unit id="bc81f7623489d466e462d3597d8dc6ebd3c462a1" translate="yes" xml:space="preserve">
          <source>The repository to sync from.</source>
          <target state="translated">Хранилище для синхронизации.</target>
        </trans-unit>
        <trans-unit id="3d7b45c15d44961366710f29c0592cfbaf8293a2" translate="yes" xml:space="preserve">
          <source>The repository to sync into.</source>
          <target state="translated">Репозиторий для синхронизации.</target>
        </trans-unit>
        <trans-unit id="85a32286326310d42bba4488de0fbceb84f9845b" translate="yes" xml:space="preserve">
          <source>The repository to update.</source>
          <target state="translated">Репозиторий для обновления.</target>
        </trans-unit>
        <trans-unit id="15ea4cb9c0b7ca59bf54604e4e274c258d2ab5d8" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header.</source>
          <target state="translated">Ответ &lt;code&gt;fetch&lt;/code&gt; разбивается на несколько разделов, разделенных пакетами-разделителями (0001), причем каждый раздел начинается с заголовка раздела.</target>
        </trans-unit>
        <trans-unit id="4f1a001f6b3f7c16917c0e0241e976b8717f870a" translate="yes" xml:space="preserve">
          <source>The rest of the documentation discusses &lt;code&gt;fsck.*&lt;/code&gt; for brevity, but the same applies for the corresponding &lt;code&gt;receive.fsck.*&lt;/code&gt; and &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt;. variables.</source>
          <target state="translated">В остальной части документации для краткости обсуждается &lt;code&gt;fsck.*&lt;/code&gt; , Но то же самое относится и к соответствующим &lt;code&gt;receive.fsck.*&lt;/code&gt; И &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt; . переменные.</target>
        </trans-unit>
        <trans-unit id="ac10b74ced74e00c661f52e9250a42f47fd6add4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;2&lt;/code&gt; is the best common ancestor of all commits.</source>
          <target state="translated">Результат &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; равен &lt;code&gt;2&lt;/code&gt; , потому что &lt;code&gt;2&lt;/code&gt; - лучший общий предок всех коммитов.</target>
        </trans-unit>
        <trans-unit id="1e8fa948e18ddfaa21178042cd566eaada7aae80" translate="yes" xml:space="preserve">
          <source>The result of comparison is passed from these commands to what is internally called &quot;diffcore&quot;, in a format similar to what is output when the -p option is not used. E.g.</source>
          <target state="translated">Результат сравнения передается из этих команд в то,что внутренне называется &quot;diffcore&quot;,в формате,аналогичном тому,что выводится,когда не используется опция -p.Например</target>
        </trans-unit>
        <trans-unit id="d6478eddd3e6be6e1f0703d8450a597d1ea3dfe6" translate="yes" xml:space="preserve">
          <source>The result of such a bisection would be that we would find that H is the first bad commit, when in fact it&amp;rsquo;s B. So that would be wrong!</source>
          <target state="translated">Результатом такого деления пополам было бы то, что мы обнаружили бы, что H - первая плохая фиксация, тогда как на самом деле это B. Так что это было бы неправильно!</target>
        </trans-unit>
        <trans-unit id="baad8b31b0f95aa1296c5c88ad34816424f2926e" translate="yes" xml:space="preserve">
          <source>The resulting directory proj.git contains a &quot;bare&quot; git repository&amp;mdash;​it is just the contents of the &lt;code&gt;.git&lt;/code&gt; directory, without any files checked out around it.</source>
          <target state="translated">Результирующий каталог proj.git содержит &amp;laquo;чистый&amp;raquo; репозиторий git - это просто содержимое каталога &lt;code&gt;.git&lt;/code&gt; без каких-либо извлеченных файлов вокруг него.</target>
        </trans-unit>
        <trans-unit id="31dc4b206e7be8ca9a78c4871cc58f03a5340e5b" translate="yes" xml:space="preserve">
          <source>The revision data is appended to the file if it already exists, for use when doing incremental imports.</source>
          <target state="translated">Данные о ревизиях добавляются к файлу,если он уже существует,для использования при инкрементном импорте.</target>
        </trans-unit>
        <trans-unit id="0ca811b30547ebe29846859e95a6c9147e8141b4" translate="yes" xml:space="preserve">
          <source>The rewrite rule guarantees that existing static files will be properly served, whereas any other URL will be passed to gitweb as PATH_INFO parameter.</source>
          <target state="translated">Правило перезаписи гарантирует,что существующие статические файлы будут корректно обслуживаться,в то время как любой другой URL будет передан gitweb в качестве параметра PATH_INFO.</target>
        </trans-unit>
        <trans-unit id="7511d9248c0671ec876d283606ae9df0bea2f6b2" translate="yes" xml:space="preserve">
          <source>The ripple effect of a &quot;hard case&quot; recovery is especially bad: &lt;code&gt;everyone&lt;/code&gt; downstream from &lt;code&gt;topic&lt;/code&gt; will now have to perform a &quot;hard case&quot; recovery too!</source>
          <target state="translated">Эффект пульсации восстановления в &amp;laquo;жестком&amp;raquo; случае особенно плох: &lt;code&gt;everyone&lt;/code&gt; ниже по течению от &lt;code&gt;topic&lt;/code&gt; , теперь придется выполнять восстановление &amp;laquo;в жестком&amp;raquo; случае!</target>
        </trans-unit>
        <trans-unit id="93d5c7537e241865d860131eb6d72edc95c9d772" translate="yes" xml:space="preserve">
          <source>The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; will try to read it from &lt;code&gt;CVS/Root&lt;/code&gt;. If no such file exists, it checks for the &lt;code&gt;CVSROOT&lt;/code&gt; environment variable.</source>
          <target state="translated">Корень архива CVS. Может быть локальным (простой путь) или удаленным; в настоящее время поддерживаются только методы доступа: local :,: ext: и: pserver:. Если не указан, &lt;code&gt;git cvsimport&lt;/code&gt; попытается прочитать его из &lt;code&gt;CVS/Root&lt;/code&gt; . Если такого файла не существует, он проверяет переменную среды &lt;code&gt;CVSROOT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df41fdf293aec02e3dee1ead27003284471a1181" translate="yes" xml:space="preserve">
          <source>The root of the tree can be represented by an empty string as &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Корень дерева может быть представлен пустой строкой как &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="557dc21e01559e09224bc25bcbd6a672b4e3d883" translate="yes" xml:space="preserve">
          <source>The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility.</source>
          <target state="translated">Немного задействовано правило определения того,какое удаленное ответвление необходимо слить после получения,чтобы не нарушить обратную совместимость.</target>
        </trans-unit>
        <trans-unit id="bbff5506f0bff9eed6d1a29f80ce8f838449bb56" translate="yes" xml:space="preserve">
          <source>The rules by which the pattern matches paths are the same as in &lt;code&gt;.gitignore&lt;/code&gt; files (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), with a few exceptions:</source>
          <target state="translated">Правила, по которым шаблон соответствует путям, такие же, как и в файлах &lt;code&gt;.gitignore&lt;/code&gt; (см. &lt;a href=&quot;gitignore&quot;&gt;Gitignore [5]&lt;/a&gt; ), за некоторыми исключениями:</target>
        </trans-unit>
        <trans-unit id="579e7c08387accae89723ba13e3ec53145837232" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;--merge&lt;/code&gt; option above, but changes the way the conflicting hunks are presented, overriding the &lt;code&gt;merge.conflictStyle&lt;/code&gt; configuration variable. Possible values are &quot;merge&quot; (default) and &quot;diff3&quot; (in addition to what is shown by &quot;merge&quot; style, shows the original contents).</source>
          <target state="translated">То же, что &lt;code&gt;--merge&lt;/code&gt; опция --merge выше, но изменяет способ представления конфликтующих &lt;code&gt;merge.conflictStyle&lt;/code&gt; , переопределяя переменную конфигурации merge.conflictStyle . Возможные значения: &amp;laquo;merge&amp;raquo; (по умолчанию) и &amp;laquo;diff3&amp;raquo; (в дополнение к тому, что показано стилем &amp;laquo;merge&amp;raquo;, показывает исходное содержимое).</target>
        </trans-unit>
        <trans-unit id="1a11cc7f94381fe2de07d484775d2914bf62d241" translate="yes" xml:space="preserve">
          <source>The same as the previous one:</source>
          <target state="translated">Так же,как и предыдущий:</target>
        </trans-unit>
        <trans-unit id="ebdfbbadd1b4e3e4d3c390aed297730072348592" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;pu&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;pu&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">Такой же процесс перемотки и восстановления может быть выполнен для &lt;code&gt;pu&lt;/code&gt; . Публичное объявление не требуется, поскольку &lt;code&gt;pu&lt;/code&gt; - это одноразовая ветка, как описано выше.</target>
        </trans-unit>
        <trans-unit id="30d931302d20c8d2d3f4d29cdb99720d08f56244" translate="yes" xml:space="preserve">
          <source>The same trailer as a v1 pack file:</source>
          <target state="translated">Тот же трейлер,что и файл пакета v1:</target>
        </trans-unit>
        <trans-unit id="ef6e4cd5de79a2002e4df69090fc16d7024fe532" translate="yes" xml:space="preserve">
          <source>The sample &lt;code&gt;prepare-commit-msg&lt;/code&gt; hook that comes with Git removes the help message found in the commented portion of the commit template.</source>
          <target state="translated">Образец ловушки &lt;code&gt;prepare-commit-msg&lt;/code&gt; , поставляемый с Git, удаляет справочное сообщение, обнаруженное в закомментированной части шаблона фиксации.</target>
        </trans-unit>
        <trans-unit id="0814a224cf6ffffca90b05b46ffd264f8d62f600" translate="yes" xml:space="preserve">
          <source>The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its &lt;code&gt;.sample&lt;/code&gt; suffix.</source>
          <target state="translated">По умолчанию все хуки сэмплов отключены. Чтобы включить один из примеров перехватчиков, переименуйте его, удалив суффикс &lt;code&gt;.sample&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee2f5fb52849fdcd69a62a399938c4c71ec4e36c" translate="yes" xml:space="preserve">
          <source>The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have &quot;version X&quot;, but they actually have &lt;code&gt;different&lt;/code&gt; &quot;X&quot;'s. So just call it &quot;X.1&quot; and be done with it.</source>
          <target state="translated">Вменяемая вещь. Просто признайте, что вы облажались, и используйте другое имя. Другие уже видели одно имя тега, и если вы сохраните то же имя, вы можете оказаться в ситуации, когда у двух людей есть &amp;laquo;версия X&amp;raquo;, но на самом деле у них &lt;code&gt;different&lt;/code&gt; &amp;laquo;X&amp;raquo;. Так что просто назовите его &amp;laquo;X.1&amp;raquo; и покончите с этим.</target>
        </trans-unit>
        <trans-unit id="16a78cd21b6c709f016f4a17d2a1069e970db97c" translate="yes" xml:space="preserve">
          <source>The script expects you to provide the key roots where it can start the import from an &lt;code&gt;initial import&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt; type of Arch commit. It will follow and import new branches within the provided roots.</source>
          <target state="translated">Сценарий ожидает, что вы предоставите ключевые корни, откуда он может начать импорт из &lt;code&gt;initial import&lt;/code&gt; или типа &lt;code&gt;tag&lt;/code&gt; фиксации Arch. Он будет следовать и импортировать новые ветви в предоставленные корни.</target>
        </trans-unit>
        <trans-unit id="793ca81ee99913a2e3edc7ca33209f79549422e8" translate="yes" xml:space="preserve">
          <source>The scriptlet sets &lt;code&gt;GIT_DIR&lt;/code&gt; and &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; shell variables, but does &lt;strong&gt;not&lt;/strong&gt; export them to the environment.</source>
          <target state="translated">Сценарий устанавливает переменные оболочки &lt;code&gt;GIT_DIR&lt;/code&gt; и &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; , но &lt;strong&gt;не&lt;/strong&gt; экспортирует их в среду.</target>
        </trans-unit>
        <trans-unit id="8b53f7beee61a37b0174ea389f5f36080ff3c1b7" translate="yes" xml:space="preserve">
          <source>The second .gitignore prevents Git from ignoring &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt;.</source>
          <target state="translated">Второй .gitignore не позволяет Git игнорировать &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc737587a80c0c07a4fffd3646c479ff0f86cddd" translate="yes" xml:space="preserve">
          <source>The second example demonstrates that you can abbreviate the object name to only the first several hexadecimal digits in most places.</source>
          <target state="translated">Второй пример демонстрирует,что в большинстве мест можно сократить имя объекта только до первых нескольких шестнадцатеричных цифр.</target>
        </trans-unit>
        <trans-unit id="2890a9def3fff903603dee47b68cd9b5af108707" translate="yes" xml:space="preserve">
          <source>The second format is what gets used when &lt;code&gt;--stage=all&lt;/code&gt;. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or &lt;code&gt;.&lt;/code&gt; if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.</source>
          <target state="translated">Второй формат используется, когда &lt;code&gt;--stage=all&lt;/code&gt; . В трех временных полях этапа (stage1temp, stage2temp, stage3temp) перечисляется имя временного файла, если в индексе или &lt;code&gt;.&lt;/code&gt; если нет выхода на сцену. Пути, которые имеют запись только стадии 0, всегда будут исключены из вывода.</target>
        </trans-unit>
        <trans-unit id="86b87f951d8d8be1a02da6e062a3489256945d73" translate="yes" xml:space="preserve">
          <source>The second parameter passed to the hook is the indicator for whether or not the index was updated and the skip-worktree bit could have changed. &quot;1&quot; meaning skip-worktree bits could have been updated and &quot;0&quot; meaning they were not.</source>
          <target state="translated">Второй параметр,переданный на крючок-это индикатор того,обновлялся ли индекс или нет,и мог ли измениться бит skip-worktree.&quot;1&quot; означает,что бит skip-worktree мог быть обновлен,а &quot;0&quot;-нет.</target>
        </trans-unit>
        <trans-unit id="b730007914036d9f0fb3ba6052d64853bae216ae" translate="yes" xml:space="preserve">
          <source>The second syntax (&quot;&lt;code&gt;git merge --abort&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:</source>
          <target state="translated">Второй синтаксис (&amp;laquo; &lt;code&gt;git merge --abort&lt;/code&gt; &amp;raquo;) может быть запущен только после того, как слияние привело к конфликтам. &lt;code&gt;git merge --abort&lt;/code&gt; прервет процесс слияния и попытается восстановить состояние до слияния. Однако, если при запуске слияния были незафиксированные изменения (и особенно если эти изменения были дополнительно изменены после начала слияния), &lt;code&gt;git merge --abort&lt;/code&gt; в некоторых случаях не сможет восстановить исходные (до слияния) изменения. Следовательно:</target>
        </trans-unit>
        <trans-unit id="1f7dcee78b5872602756cd0d868ad6253db301fe" translate="yes" xml:space="preserve">
          <source>The second transformation in the chain is diffcore-break, and is controlled by the -B option to the &lt;code&gt;git diff-*&lt;/code&gt; commands. This is used to detect a filepair that represents &quot;complete rewrite&quot; and break such filepair into two filepairs that represent delete and create. E.g. If the input contained this filepair:</source>
          <target state="translated">Второе преобразование в цепочке - это diffcore-break, которое управляется параметром -B команд &lt;code&gt;git diff-*&lt;/code&gt; . Это используется для обнаружения файловой пары, которая представляет собой &amp;laquo;полную перезапись&amp;raquo;, и разбивает такую ​​файловую пару на две файловые пары, которые представляют собой удаление и создание. Например, если вход содержит эту файловую пару:</target>
        </trans-unit>
        <trans-unit id="5aa738048a0181b9705365955bd04c18156f9d33" translate="yes" xml:space="preserve">
          <source>The section &lt;code&gt;submodule.foo.*&lt;/code&gt; in the &lt;code&gt;.gitmodules&lt;/code&gt; file gives additional hints to Git&amp;rsquo;s porcelain layer. For example, the &lt;code&gt;submodule.foo.url&lt;/code&gt; setting specifies where to obtain the submodule.</source>
          <target state="translated">Раздел &lt;code&gt;submodule.foo.*&lt;/code&gt; В &lt;code&gt;.gitmodules&lt;/code&gt; файле дает дополнительные подсказки фарфорового слоя Git и . Например, параметр &lt;code&gt;submodule.foo.url&lt;/code&gt; указывает, где получить подмодуль.</target>
        </trans-unit>
        <trans-unit id="addff8a92e5ddb901ae8a38330bc2dcce4be9fbb" translate="yes" xml:space="preserve">
          <source>The section or key is invalid (ret=1),</source>
          <target state="translated">Раздел или ключ недействительны (ret=1),</target>
        </trans-unit>
        <trans-unit id="463ba2454fad2719570e32271a038c3acce699a7" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any &quot;unshallow&quot; lines for anything which the client has not indicated was shallow as a part of its request.</source>
          <target state="translated">Сервер НЕ ДОЛЖЕН посылать какие-либо &quot;непустые&quot; строки для чего-либо,что клиент не указал в своем запросе как непустое.</target>
        </trans-unit>
        <trans-unit id="d868af4cbdec034778f61defdf53e9a4307fd341" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any refs which were not requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">Сервер НЕ ДОЛЖЕН отправлять какие-либо ссылки, которые не были запрошены с использованием строк &lt;code&gt;want-ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="446930d87bed0e82e29e329dd081708ba37057c2" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;agent=X&lt;/code&gt;) to notify the client that the server is running version &lt;code&gt;X&lt;/code&gt;. The client may optionally send its own agent string by including the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;Y&lt;/code&gt; (in the form &lt;code&gt;agent=Y&lt;/code&gt;) in its request to the server (but it MUST NOT do so if the server did not advertise the agent capability). The &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; strings may contain any printable ASCII characters except space (i.e., the byte range 32 &amp;lt; x &amp;lt; 127), and are typically of the form &quot;package/version&quot; (e.g., &quot;git/1.8.3.1&quot;). The agent strings are purely informative for statistics and debugging purposes, and MUST NOT be used to programmatically assume the presence or absence of particular features.</source>
          <target state="translated">Сервер может рекламировать &lt;code&gt;agent&lt;/code&gt; способность со значением &lt;code&gt;X&lt;/code&gt; (в форме &lt;code&gt;agent=X&lt;/code&gt; ) , чтобы уведомить клиента о том , что сервер работает под управлением версии &lt;code&gt;X&lt;/code&gt; . Клиент может дополнительно послать свою собственную строку агента, включив возможность &lt;code&gt;agent&lt;/code&gt; со значением &lt;code&gt;Y&lt;/code&gt; (в форме &lt;code&gt;agent=Y&lt;/code&gt; ) в свой запрос к серверу (но он НЕ ДОЛЖЕН делать это, если сервер не анонсировал возможности агента). &lt;code&gt;X&lt;/code&gt; и &lt;code&gt;Y&lt;/code&gt; Строки могут содержать любые печатаемые символы ASCII, кроме пробела (т. е. диапазон байтов 32 &amp;lt;x &amp;lt;127), и обычно имеют форму &amp;laquo;пакет / версия&amp;raquo; (например, &amp;laquo;git / 1.8.3.1&amp;raquo;). Строки агента являются чисто информативными для целей статистики и отладки и НЕ ДОЛЖНЫ использоваться для программного предположения о наличии или отсутствии определенных функций.</target>
        </trans-unit>
        <trans-unit id="5dbb8fc2dd2ef1317864e26b0a2f75da26a1d7f0" translate="yes" xml:space="preserve">
          <source>The server sends a &quot;shallow obj-id&quot; line for each commit whose parents will not be sent in the following packfile.</source>
          <target state="translated">Сервер посылает строку &quot;мелкий объект-ид&quot; для каждого коммита,чьи родители не будут отправлены в следующем пакете.</target>
        </trans-unit>
        <trans-unit id="15cbc52acb55c8a437e7a9fc2cb2ebb8c994afc3" translate="yes" xml:space="preserve">
          <source>The server sends an &quot;unshallow obj-id&quot; line for each commit which the client has indicated is shallow, but is no longer shallow as a result of the fetch (due to its parents being sent in the following packfile).</source>
          <target state="translated">Сервер посылает строку &quot;unshallow obj-id&quot; для каждого коммита,который клиент указал как неглубокий,но больше неглубокий в результате фетча (из-за того,что его родители были отправлены в следующем пакетном файле).</target>
        </trans-unit>
        <trans-unit id="3f482eecb5e3fca563243c0419eece540e0582ac" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;ACK obj-id&quot; for all of the object ids sent as have lines which are common.</source>
          <target state="translated">Сервер ответит &quot;ACK obj-id&quot; для всех присланных идентификаторов объектов,так как они имеют общие строки.</target>
        </trans-unit>
        <trans-unit id="543a974b0aa8c62d541ca2830198235b945cc003" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;NAK&quot; if none of the object ids sent as have lines were common.</source>
          <target state="translated">Сервер ответит &quot;NAK&quot;,если ни один из идентификаторов объектов,отправленных как имеющие строки,не был общим.</target>
        </trans-unit>
        <trans-unit id="568256da628f1737b5310a22de9a07629ce73e0d" translate="yes" xml:space="preserve">
          <source>The server will respond with a &quot;ready&quot; line indicating that the server has found an acceptable common base and is ready to make and send a packfile (which will be found in the packfile section of the same response)</source>
          <target state="translated">Сервер ответит строкой &quot;ready&quot;,указывая,что сервер нашел приемлемую общую базу и готов сделать и отправить пакетный файл (который будет найден в секции пакетного файла в том же ответе)</target>
        </trans-unit>
        <trans-unit id="69ff3eec8c55e5a8095ea13f51e31e429dc845d6" translate="yes" xml:space="preserve">
          <source>The server will send a ref listing (&quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;) for each reference requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">Сервер отправит список ссылок (&quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;) для каждой ссылки, запрошенной с использованием строк &lt;code&gt;want-ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afb7e2ac1ca268d29d3dabe65a1485bc3c99ebf1" translate="yes" xml:space="preserve">
          <source>The server will then check to ensure that the client&amp;rsquo;s request is comprised of a valid command as well as valid capabilities which were advertised. If the request is valid the server will then execute the command. A server MUST wait till it has received the client&amp;rsquo;s entire request before issuing a response. The format of the response is determined by the command being executed, but in all cases a flush-pkt indicates the end of the response.</source>
          <target state="translated">Затем сервер проверит, что запрос клиента состоит из действительной команды, а также допустимых возможностей, которые были объявлены. Если запрос действителен, сервер выполнит команду. Сервер ДОЛЖЕН дождаться получения всего запроса клиента, прежде чем выдать ответ. Формат ответа определяется выполняемой командой, но во всех случаях flush-pkt указывает на конец ответа.</target>
        </trans-unit>
        <trans-unit id="537b1e0777fad4eaaafbf4ccf5940ab37b1e2ed6" translate="yes" xml:space="preserve">
          <source>The shared index part, to be referenced by $GIT_DIR/index and other temporary index files. Only valid in split index mode.</source>
          <target state="translated">Часть общего индекса,на которую будут ссылаться $GIT_DIR/index и другие временные файлы индексов.Действительно только в режиме разделенного индекса.</target>
        </trans-unit>
        <trans-unit id="d11a14c0103fd18e1ebb96bcb7251e0f8abbce80" translate="yes" xml:space="preserve">
          <source>The shift magic first throws away the tree id and then the -p parameters. Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit.</source>
          <target state="translated">Магический сдвиг сначала выбрасывает id дерева,а затем -p параметры.Обратите внимание,что эта ручка правильно сливается! В случае,если Дарл совершил слияние между P1 и P2,оно будет правильно распространено,и все дочерние элементы слияния станут коммитами слияния с P1,P2 в качестве их родителей вместо коммита слияния.</target>
        </trans-unit>
        <trans-unit id="e33b2d8b27401f604cb70ad4d214df90a2abf20c" translate="yes" xml:space="preserve">
          <source>The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.</source>
          <target state="translated">Индекс схожести-это процент неизмененных линий,а индекс схожести-это процент измененных линий.Это округленное целое число,за которым следует знак процента.Таким образом,значение индекса сходства 100% зарезервировано для двух одинаковых файлов,в то время как 100%-ное отличие означает,что ни одна строка из старого файла не превратилась в новую.</target>
        </trans-unit>
        <trans-unit id="09f0c715250f8ac9e78727d6768d66502facff83" translate="yes" xml:space="preserve">
          <source>The simplest commit to find is the HEAD commit, which we can find from .git/HEAD:</source>
          <target state="translated">Самый простой коммит для поиска-это HEAD коммит,который мы можем найти в .git/HEAD:</target>
        </trans-unit>
        <trans-unit id="938f800e1b465bd0f07eb377492ba2456bfbed2c" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and ssh; to update the remote branch named &lt;code&gt;master&lt;/code&gt; with the latest state of your branch named &lt;code&gt;master&lt;/code&gt;, run</source>
          <target state="translated">Самый простой способ сделать это - использовать &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; и ssh; чтобы обновить удаленную ветку с именем &lt;code&gt;master&lt;/code&gt; с последним состоянием вашей ветки с именем &lt;code&gt;master&lt;/code&gt; , запустите</target>
        </trans-unit>
        <trans-unit id="a5eba655ac4b55a1106bdc6c6dbf2b0d1ad04c8a" translate="yes" xml:space="preserve">
          <source>The simplest way to mark a file as binary is to unset the diff attribute in the &lt;code&gt;.gitattributes&lt;/code&gt; file:</source>
          <target state="translated">Самый простой способ пометить файл как двоичный - &lt;code&gt;.gitattributes&lt;/code&gt; атрибут diff в файле .gitattributes :</target>
        </trans-unit>
        <trans-unit id="99bb329f9f9a76ae9c81982693e8d5911709e87c" translate="yes" xml:space="preserve">
          <source>The size of the object (the same as &lt;code&gt;git cat-file -s&lt;/code&gt; reports). Append &lt;code&gt;:disk&lt;/code&gt; to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">Размер объекта (как в &lt;code&gt;git cat-file -s&lt;/code&gt; reports). Добавьте &lt;code&gt;:disk&lt;/code&gt; , чтобы получить размер в байтах, который объект занимает на диске. См. Примечание о размерах на диске в разделе &lt;code&gt;CAVEATS&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="3527fa64b6fd749102c379b2fd96b0df5cd454cb" translate="yes" xml:space="preserve">
          <source>The size of the window used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no window size is given on the command line. Defaults to 10.</source>
          <target state="translated">Размер окна, используемого &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1],&lt;/a&gt; когда размер окна не указан в командной строке. По умолчанию 10.</target>
        </trans-unit>
        <trans-unit id="2372575566ae8c805d7580bdcbad6da1c4463611" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the object (the same as &lt;code&gt;cat-file -s&lt;/code&gt; reports).</source>
          <target state="translated">Размер объекта в байтах (такой же, как у отчетов &lt;code&gt;cat-file -s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="43c333a5a6bd3bca8b34d5163a7aa7b6d79d2d40" translate="yes" xml:space="preserve">
          <source>The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">Размер в байтах, который объект занимает на диске. См. Примечание о размерах на диске в разделе &lt;code&gt;CAVEATS&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="7d544171c06a9cb39c4059f830c0a8558d3922c9" translate="yes" xml:space="preserve">
          <source>The slash &lt;code&gt;/&lt;/code&gt; is used as the directory separator. Separators may occur at the beginning, middle or end of the &lt;code&gt;.gitignore&lt;/code&gt; search pattern.</source>
          <target state="translated">Косая черта &lt;code&gt;/&lt;/code&gt; используется как разделитель каталогов. Разделители могут &lt;code&gt;.gitignore&lt;/code&gt; в начале, середине или конце поискового шаблона .gitignore .</target>
        </trans-unit>
        <trans-unit id="e18b2266f1b1b9062e466bd05dd697dc8d44c68f" translate="yes" xml:space="preserve">
          <source>The smaller the changes in your commit, the most effective &quot;git bisect&quot; will be. And you will probably need &quot;git bisect&quot; less in the first place, as small changes are easier to review even if they are only reviewed by the committer.</source>
          <target state="translated">Чем меньше изменения в вашем коммите,тем более эффективным будет &quot;git-бисект&quot;.И вам,скорее всего,понадобится меньше &quot;git-биссектов&quot;,так как небольшие изменения легче просмотреть,даже если они просматриваются только коммиттером.</target>
        </trans-unit>
        <trans-unit id="0dab2fe7462a5d0c0b797d08e789dbaaf7bfa1df" translate="yes" xml:space="preserve">
          <source>The smart HTTP server, &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt;, will pass GIT_NAMESPACE through to the backend programs; see &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt; for sample configuration to expose repository namespaces as repositories.</source>
          <target state="translated">Интеллектуальный HTTP-сервер, &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt; , будет передавать GIT_NAMESPACE внутренним программам; см. &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt; для примера конфигурации для предоставления пространств имен репозиториев как репозиториев.</target>
        </trans-unit>
        <trans-unit id="9ee3be6f644f850e9ae409b580b74ced862493f8" translate="yes" xml:space="preserve">
          <source>The solution, of course, is to make a merge that we can undo: merge into a throw-away branch.</source>
          <target state="translated">Решение,конечно,состоит в том,чтобы произвести слияние,которое мы можем отменить:слияние в отбрасывающую ветку.</target>
        </trans-unit>
        <trans-unit id="8a1117f540255f9a5dcffa1baa25558f77657b0e" translate="yes" xml:space="preserve">
          <source>The special case of restarting an incremental import from the current branch value should be written as:</source>
          <target state="translated">Особый случай перезапуска инкрементального импорта из текущего значения ветки должен быть записан как:</target>
        </trans-unit>
        <trans-unit id="3599d1b8b89ee48d0b633dcff9041c57284c3251" translate="yes" xml:space="preserve">
          <source>The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see &lt;code&gt;git bisect skip&lt;/code&gt; above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable&amp;mdash;​these details do not matter, as they are normal errors in the script, as far as &lt;code&gt;bisect run&lt;/code&gt; is concerned).</source>
          <target state="translated">Если текущий исходный код не может быть протестирован, следует использовать специальный код выхода 125. Если сценарий завершается с этим кодом, текущая версия будет пропущена (см. &lt;code&gt;git bisect skip&lt;/code&gt; выше). 125 было выбрано как наивысшее разумное значение для использования для этой цели, потому что 126 и 127 используются оболочками POSIX для сигнализации о конкретном состоянии ошибки (127 - для команды не найдена, 126 - для команды найдена, но не исполняется - эти детали не имеет значение, поскольку это нормальные ошибки в скрипте, что касается выполнения &lt;code&gt;bisect run&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="60ac8fe2a99f998c150bb7d9adc8dfbeed95a10d" translate="yes" xml:space="preserve">
          <source>The special null SHA-1 (40 zeros) specifies that the branch is to be removed.</source>
          <target state="translated">Специальный ноль SHA-1 (40 нулей)указывает,что ветка должна быть удалена.</target>
        </trans-unit>
        <trans-unit id="a4c2fa6682338e4d7c45557107add1984be0213c" translate="yes" xml:space="preserve">
          <source>The special refspec &lt;code&gt;:&lt;/code&gt; (or &lt;code&gt;+:&lt;/code&gt; to allow non-fast-forward updates) directs Git to push &quot;matching&quot; branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.</source>
          <target state="translated">Специальный refspec &lt;code&gt;:&lt;/code&gt; (или &lt;code&gt;+:&lt;/code&gt; для разрешения обновлений без быстрой перемотки вперед) указывает Git нажимать &amp;laquo;соответствующие&amp;raquo; ветки: для каждой ветки, которая существует на локальной стороне, удаленная сторона обновляется, если ветка с таким же именем уже существует на удаленной стороне.</target>
        </trans-unit>
        <trans-unit id="f2f702d2704e1b64279419d712ca4460c3b7f78e" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;none&lt;/code&gt; can be used as the proxy command to specify that no proxy be used for a given domain pattern. This is useful for excluding servers inside a firewall from proxy use, while defaulting to a common proxy for external domains.</source>
          <target state="translated">Специальную строку &lt;code&gt;none&lt;/code&gt; можно использовать в качестве прокси-команды, чтобы указать, что прокси-сервер не будет использоваться для данного шаблона домена. Это полезно для исключения серверов внутри брандмауэра из использования прокси, при этом по умолчанию используется общий прокси для внешних доменов.</target>
        </trans-unit>
        <trans-unit id="65b859a3a4528b4a1eebafeebe9d2d28ac0eb085" translate="yes" xml:space="preserve">
          <source>The special symbol &quot;HEAD&quot; can always be used to refer to the current branch. In fact, Git uses a file named &lt;code&gt;HEAD&lt;/code&gt; in the &lt;code&gt;.git&lt;/code&gt; directory to remember which branch is current:</source>
          <target state="translated">Для обозначения текущей ветви всегда можно использовать специальный символ &amp;laquo;HEAD&amp;raquo;. Фактически, Git использует файл с именем &lt;code&gt;HEAD&lt;/code&gt; в каталоге &lt;code&gt;.git&lt;/code&gt; , чтобы запомнить текущую ветвь:</target>
        </trans-unit>
        <trans-unit id="54b91d851f1b23aa70b29c0e74d2c28879b6de30" translate="yes" xml:space="preserve">
          <source>The ssh and git protocols additionally support ~username expansion:</source>
          <target state="translated">Протоколы ssh и git дополнительно поддерживают расширение ~username:</target>
        </trans-unit>
        <trans-unit id="ac6c6d73b5f6b7c3cef28dfe32da61495601bd7c" translate="yes" xml:space="preserve">
          <source>The standard actions are:</source>
          <target state="translated">Стандартные действия:</target>
        </trans-unit>
        <trans-unit id="a72f515f06e2719cd062e161d9ed80a61b68c92f" translate="yes" xml:space="preserve">
          <source>The standard email format as described by RFC 2822, for example &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt;.</source>
          <target state="translated">Стандартный формат электронной почты, описанный в RFC 2822, например &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8128f4cfe82d86e129a0094608260664c3bb1ba3" translate="yes" xml:space="preserve">
          <source>The standard helper program to use with git-merge-index</source>
          <target state="translated">Стандартная вспомогательная программа для использования с git-merge-index</target>
        </trans-unit>
        <trans-unit id="4d34b021b617aa2bf3f93982ac428b041f085fbe" translate="yes" xml:space="preserve">
          <source>The starting point for the new branch. Specifying a &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of &lt;code&gt;--detach&lt;/code&gt;, allows you to inspect and detach from some other point.)</source>
          <target state="translated">Отправная точка для новой ветки. Указание &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; позволяет вам создать ветвь, основанную на какой-либо другой точке истории, отличной от той, на которую в настоящее время указывает HEAD. (Или, в случае &lt;code&gt;--detach&lt;/code&gt; , позволяет вам проверить и отсоединиться от какой-либо другой точки.)</target>
        </trans-unit>
        <trans-unit id="ca9ba47b83a1def4d8a6c769f2e642f061d5236a" translate="yes" xml:space="preserve">
          <source>The status of GPG verification of the push certificate, using the same mnemonic as used in &lt;code&gt;%G?&lt;/code&gt; format of &lt;code&gt;git log&lt;/code&gt; family of commands (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;).</source>
          <target state="translated">Статус проверки GPG push-сертификата с использованием той же мнемоники, что и в &lt;code&gt;%G?&lt;/code&gt; Формат &lt;code&gt;git log&lt;/code&gt; семейства команд (см &lt;a href=&quot;git-log&quot;&gt;ГИТ-журнал [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c902748a09ab505851b0b39809c60f3db2027be9" translate="yes" xml:space="preserve">
          <source>The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">Статус выборки выводится в табличной форме,при этом каждая строка представляет собой статус одного ссылка.Каждая строка имеет форму:</target>
        </trans-unit>
        <trans-unit id="7729563c964ef73ba71f39abfa320766ac0cea33" translate="yes" xml:space="preserve">
          <source>The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">Статус нажатия выводится в табличной форме,при этом каждая строка представляет собой статус одного ссылка.Каждая строка имеет форму:</target>
        </trans-unit>
        <trans-unit id="e939f21e3282d453b1398071feb25115360b90b4" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if --porcelain or --verbose option is used.</source>
          <target state="translated">Статус обновленных ссылок отображается только при использовании опции --porcelain или --verbose.</target>
        </trans-unit>
        <trans-unit id="0ebfa7ce02ec5605e425e0cd98062f5bbd8f2510" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if the --verbose option is used.</source>
          <target state="translated">Статус обновленных ссылок отображается только при использовании опции --verbose.</target>
        </trans-unit>
        <trans-unit id="a97643bd561fabe3d136679e4752cb73667ec062" translate="yes" xml:space="preserve">
          <source>The structured objects can further have their structure and connectivity to other objects verified. This is generally done with the &lt;code&gt;git fsck&lt;/code&gt; program, which generates a full dependency graph of all objects, and verifies their internal consistency (in addition to just verifying their superficial consistency through the hash).</source>
          <target state="translated">Структурированные объекты могут дополнительно проверить свою структуру и связь с другими объектами. Обычно это делается с помощью программы &lt;code&gt;git fsck&lt;/code&gt; , которая генерирует полный граф зависимостей всех объектов и проверяет их внутреннюю согласованность (в дополнение к простой проверке их поверхностной согласованности с помощью хеша).</target>
        </trans-unit>
        <trans-unit id="af4ab93b8907c3bc82033e90c4bc6eedaac09e1c" translate="yes" xml:space="preserve">
          <source>The submit process invokes the editor before each p4 change is submitted. If this setting is true, though, the editing step is skipped.</source>
          <target state="translated">Процесс отправки вызывает редактор перед отправкой каждого изменения в p4.Если эта настройка верна,шаг редактирования пропускается.</target>
        </trans-unit>
        <trans-unit id="72386229ffdfc0f6ba847ccdd7620fcafabeae30" translate="yes" xml:space="preserve">
          <source>The submodule directories are there, but they&amp;rsquo;re empty:</source>
          <target state="translated">Каталоги подмодулей есть, но они пусты:</target>
        </trans-unit>
        <trans-unit id="802b1c9a36cac97c548242e11fe5baa3275576f0" translate="yes" xml:space="preserve">
          <source>The submodule will never be considered modified (but will nonetheless show up in the output of status and commit when it has been staged).</source>
          <target state="translated">Субмодуль никогда не будет считаться изменённым (но,тем не менее,будет отображаться в выводе статуса и фиксироваться,когда он был инсценирован).</target>
        </trans-unit>
        <trans-unit id="7180d60887d97b6ca57dd91c2b86681f019ca631" translate="yes" xml:space="preserve">
          <source>The submodule&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file would come into play when running &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; in the superproject, as this would check if the submodule has any changes not published to any remote. The remotes are configured in the submodule as usual in the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/config&lt;/code&gt; подмодуля вступит в игру при запуске &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; в суперпроекте, так как это проверяет, есть ли в подмодуле какие-либо изменения, не опубликованные ни на каком удаленном компьютере. Пульты настраиваются в подмодуле, как обычно, в &lt;code&gt;$GIT_DIR/config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a87578b15befa74b2d27eca3216884ceb35493c" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{push}&lt;/code&gt; reports the branch &quot;where we would push to&quot; if &lt;code&gt;git push&lt;/code&gt; were run while &lt;code&gt;branchname&lt;/code&gt; was checked out (or the current &lt;code&gt;HEAD&lt;/code&gt; if no branchname is specified). Since our push destination is in a remote repository, of course, we report the local tracking branch that corresponds to that branch (i.e., something in &lt;code&gt;refs/remotes/&lt;/code&gt;).</source>
          <target state="translated">Суффикс &lt;code&gt;@{push}&lt;/code&gt; сообщает ветку, &quot;куда мы будем нажимать&quot;, если &lt;code&gt;git push&lt;/code&gt; был запущен, когда имя &lt;code&gt;branchname&lt;/code&gt; было извлечено (или текущий &lt;code&gt;HEAD&lt;/code&gt; , если имя ветки не указано). Поскольку наш пункт назначения push находится в удаленном репозитории, мы, конечно, сообщаем о локальной ветке отслеживания, которая соответствует этой ветке (то есть, что-то в &lt;code&gt;refs/remotes/&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c10fd9c6c93e1de11dbe32978aa15d853b4103fb" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{upstream}&lt;/code&gt; to a branchname (short form &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt;) refers to the branch that the branch specified by branchname is set to build on top of (configured with &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;). A missing branchname defaults to the current one. These suffixes are also accepted when spelled in uppercase, and they mean the same thing no matter the case.</source>
          <target state="translated">Суффикс &lt;code&gt;@{upstream}&lt;/code&gt; к имени ответвления (сокращенная форма &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt; ) относится к ветке, на которую устанавливается ветвь, указанная с помощью branchname (настроенная с помощью &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; и &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; ). Отсутствующее имя ветки по умолчанию соответствует текущему. Эти суффиксы также принимаются при написании прописными буквами и означают одно и то же в любом случае.</target>
        </trans-unit>
        <trans-unit id="35fca7d90e0c51050df5863335fd96cb674d847a" translate="yes" xml:space="preserve">
          <source>The symlink will either be absolute (beginning with a /), or relative to the tree root. For instance, if dir/link points to ../../foo, then &amp;lt;symlink&amp;gt; will be ../foo. &amp;lt;size&amp;gt; is the size of the symlink in bytes.</source>
          <target state="translated">Символическая ссылка будет либо абсолютной (начиная с /), либо относительно корня дерева. Например, если dir / link указывает на ../../foo, тогда &amp;lt;symlink&amp;gt; будет ../foo. &amp;lt;размер&amp;gt; - размер символической ссылки в байтах.</target>
        </trans-unit>
        <trans-unit id="1e32c77f2578ce3c979cd217827d9aa3c6897be9" translate="yes" xml:space="preserve">
          <source>The syntax is fairly flexible and permissive; whitespaces are mostly ignored. The &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; characters begin comments to the end of line, blank lines are ignored.</source>
          <target state="translated">Синтаксис довольно гибкий и разрешающий; пробелы в большинстве случаев игнорируются. &lt;code&gt;#&lt;/code&gt; И &lt;code&gt;;&lt;/code&gt; символы начинают комментарии до конца строки, пустые строки игнорируются.</target>
        </trans-unit>
        <trans-unit id="e9a240786337cb206c43c416821000b9a6721022" translate="yes" xml:space="preserve">
          <source>The syntax of the configuration files is that of Perl, since these files are handled by sourcing them as fragments of Perl code (the language that gitweb itself is written in). Variables are typically set using the &lt;code&gt;our&lt;/code&gt; qualifier (as in &quot;&lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt;&quot;) to avoid syntax errors if a new version of gitweb no longer uses a variable and therefore stops declaring it.</source>
          <target state="translated">Синтаксис файлов конфигурации такой же, как у Perl, так как эти файлы обрабатываются путем получения их как фрагментов кода Perl (язык, на котором написан сам gitweb). Переменные обычно устанавливаются с помощью квалификатора &lt;code&gt;our&lt;/code&gt; (как в &amp;laquo; &lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt; &amp;raquo;), чтобы избежать синтаксических ошибок, если новая версия gitweb больше не использует переменную и, следовательно, перестает ее объявлять.</target>
        </trans-unit>
        <trans-unit id="85d5722bf15562fb833fe3c8f580a92fe2e2d3db" translate="yes" xml:space="preserve">
          <source>The tables below show what happens when running:</source>
          <target state="translated">В таблицах ниже показано,что происходит во время работы:</target>
        </trans-unit>
        <trans-unit id="0ab961c529e0da6916842ede03d74fc7b0e0f90e" translate="yes" xml:space="preserve">
          <source>The tag &lt;code&gt;v2.6.18&lt;/code&gt; is short for &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt;.</source>
          <target state="translated">Тег &lt;code&gt;v2.6.18&lt;/code&gt; - это сокращение от &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5173af0305c1d6df2de24b7ea317c256f65109e" translate="yes" xml:space="preserve">
          <source>The template directory will be one of the following (in order):</source>
          <target state="translated">Каталог шаблонов будет одним из следующих (по порядку):</target>
        </trans-unit>
        <trans-unit id="45d4fdaf8fe9ac583ec50051c8f5eb8c944a1ec1" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the &lt;code&gt;--pickaxe-all&lt;/code&gt; option, it can be used to view the full &lt;a href=&quot;#def_changeset&quot;&gt;changeset&lt;/a&gt; that introduced or removed, say, a particular line of text. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">Термин &lt;a href=&quot;#def_pickaxe&quot;&gt;кирка&lt;/a&gt; относится к опции подпрограмм diffcore, которые помогают выбирать изменения, которые добавляют или удаляют заданную текстовую строку. С параметром &lt;code&gt;--pickaxe-all&lt;/code&gt; его можно использовать для просмотра полного &lt;a href=&quot;#def_changeset&quot;&gt;набора изменений,&lt;/a&gt; который ввел или удалил, скажем, определенную строку текста. См. &lt;a href=&quot;git-diff&quot;&gt;Git-diff [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2ba0595fa8d197d8c3640c03007e070ceba5b47" translate="yes" xml:space="preserve">
          <source>The text conversion is generally a one-way conversion; in this example, we lose the actual image contents and focus just on the text data. This means that diffs generated by textconv are &lt;em&gt;not&lt;/em&gt; suitable for applying. For this reason, only &lt;code&gt;git diff&lt;/code&gt; and the &lt;code&gt;git log&lt;/code&gt; family of commands (i.e., log, whatchanged, show) will perform text conversion. &lt;code&gt;git
format-patch&lt;/code&gt; will never generate this output. If you want to send somebody a text-converted diff of a binary file (e.g., because it quickly conveys the changes you have made), you should generate it separately and send it as a comment &lt;em&gt;in addition to&lt;/em&gt; the usual binary diff that you might send.</source>
          <target state="translated">Преобразование текста обычно является односторонним; в этом примере мы теряем фактическое содержимое изображения и фокусируемся только на текстовых данных. Это означает, что различия, созданные с помощью textconv, &lt;em&gt;не&lt;/em&gt; подходят для применения. По этой причине только &lt;code&gt;git diff&lt;/code&gt; и семейство команд &lt;code&gt;git log&lt;/code&gt; (например, log, whatchanged, show) будут выполнять преобразование текста. &lt;code&gt;git format-patch&lt;/code&gt; никогда не будет генерировать этот вывод. Если вы хотите отправить кому-то преобразованный текст двоичного файла (например, потому что он быстро передает сделанные вами изменения), вы должны сгенерировать его отдельно и отправить как комментарий &lt;em&gt;в дополнение к&lt;/em&gt; обычному двоичному файлу, который вы могли бы Отправить.</target>
        </trans-unit>
        <trans-unit id="eb234a21c48fd769b7576108683d04bf29f253cb" translate="yes" xml:space="preserve">
          <source>The third syntax (&quot;&lt;code&gt;git merge --continue&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts.</source>
          <target state="translated">Третий синтаксис (&amp;laquo; &lt;code&gt;git merge --continue&lt;/code&gt; &amp;raquo;) может быть запущен только после того, как слияние привело к конфликтам.</target>
        </trans-unit>
        <trans-unit id="a25be90a41e318ce76ddb9737f9c1a04e1e950e3" translate="yes" xml:space="preserve">
          <source>The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release.</source>
          <target state="translated">Предполагается,что время между первым выпуском rc и финальным выпуском будет использовано для тестирования rc-версий и борьбы с ошибками и особенно с регрессиями.И это время составляет более 80% времени цикла релиза.Но это еще не конец борьбы,так как,конечно,она продолжается и после релиза.</target>
        </trans-unit>
        <trans-unit id="75271c1b7d85cdfdc3bad04249d4464b9c292a44" translate="yes" xml:space="preserve">
          <source>The time of the change is specified by &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; using the date format that was selected by the --date-format=&amp;lt;fmt&amp;gt; command-line option. See &amp;ldquo;Date Formats&amp;rdquo; above for the set of supported formats, and their syntax.</source>
          <target state="translated">Время изменения указывается &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; с использованием формата даты, выбранного параметром командной строки --date-format = &amp;lt;fmt&amp;gt;. См. &amp;laquo;Форматы даты&amp;raquo; выше, чтобы узнать о поддерживаемых форматах и ​​их синтаксисе.</target>
        </trans-unit>
        <trans-unit id="05b9a4ac37ff05623171d65150ac27013efa2fa0" translate="yes" xml:space="preserve">
          <source>The time of the event is specified by &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer.</source>
          <target state="translated">Время события указывается в &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; как количество секунд с начала эпохи UNIX (полночь, 1 января 1970 г., UTC) и записывается как десятичное целое число ASCII.</target>
        </trans-unit>
        <trans-unit id="e85bdfa8e02113c7aa36696add629ec632f05440" translate="yes" xml:space="preserve">
          <source>The todo list presented by the deprecated &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; does not represent the topology of the revision graph (use &lt;code&gt;--rebase-merges&lt;/code&gt; instead). Editing commits and rewording their commit messages should work fine, but attempts to reorder commits tend to produce counterintuitive results. Use &lt;code&gt;--rebase-merges&lt;/code&gt; in such scenarios instead.</source>
          <target state="translated">Список &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; представленный устаревшим --preserve-merges --interactive , не представляет топологию графа ревизий ( вместо этого используйте &lt;code&gt;--rebase-merges&lt;/code&gt; ). Редактирование коммитов и изменение их сообщений о коммитах должно работать нормально, но попытки изменить порядок коммитов, как правило, дают нелогичные результаты. &lt;code&gt;--rebase-merges&lt;/code&gt; используйте --rebase-merges в таких сценариях.</target>
        </trans-unit>
        <trans-unit id="0f8166907df228eb9266d7566c3cde991d9d39bd" translate="yes" xml:space="preserve">
          <source>The total number of paths.</source>
          <target state="translated">Общее количество путей.</target>
        </trans-unit>
        <trans-unit id="46c0269533706ef03961ed4548e480cdcfd7a84a" translate="yes" xml:space="preserve">
          <source>The trailer records 20-byte SHA-1 checksum of all of the above.</source>
          <target state="translated">В прицепе записывается 20-байтовая контрольная сумма SHA-1.</target>
        </trans-unit>
        <trans-unit id="9380254df0eb0e126f55d72177d625190ab23928" translate="yes" xml:space="preserve">
          <source>The transmission of the packfile begins immediately after the section header</source>
          <target state="translated">Передача пакета начинается сразу после заголовка секции.</target>
        </trans-unit>
        <trans-unit id="de285c430d2e1f897693d7ccc23434e1a3a5c103" translate="yes" xml:space="preserve">
          <source>The tree object is the tree we examined first, and this commit is unusual in that it lacks any parent.</source>
          <target state="translated">Объектом дерева является дерево,которое мы рассмотрели первыми,и этот коммит необычен тем,что в нём нет ни одного родителя.</target>
        </trans-unit>
        <trans-unit id="9178b43dc9b2907a6afd7a3693f2c6894ec0ecd9" translate="yes" xml:space="preserve">
          <source>The tree of actual checked out files. The working tree normally contains the contents of the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; commit&amp;rsquo;s tree, plus any local changes that you have made but not yet committed.</source>
          <target state="translated">Дерево реально извлеченных файлов. Рабочее дерево обычно содержит содержимое дерева фиксации &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; , а также любые локальные изменения, которые вы сделали, но еще не зафиксировали.</target>
        </trans-unit>
        <trans-unit id="26b5c7d70f82997ceabb111adeeb911e4d89a340" translate="yes" xml:space="preserve">
          <source>The tree or commit to produce an archive for.</source>
          <target state="translated">Дерево или обязательство создать архив для.</target>
        </trans-unit>
        <trans-unit id="90f78952a054862b4ed6d79982e2eab2fc081a24" translate="yes" xml:space="preserve">
          <source>The twist is that if some file doesn&amp;rsquo;t match the index, we don&amp;rsquo;t have a backing store thing for it, and we use the magic &quot;all-zero&quot; sha1 to show that. So let&amp;rsquo;s say that you have edited &lt;code&gt;kernel/sched.c&lt;/code&gt;, but have not actually done a &lt;code&gt;git update-index&lt;/code&gt; on it yet - there is no &quot;object&quot; associated with the new state, and you get:</source>
          <target state="translated">Хитрость в том, что если какой-то файл не соответствует индексу, у нас нет для него резервного хранилища, и мы используем магический &amp;laquo;все-ноль&amp;raquo; sha1, чтобы показать это. Итак, предположим, что вы отредактировали &lt;code&gt;kernel/sched.c&lt;/code&gt; , но на самом деле еще не сделали для него &lt;code&gt;git update-index&lt;/code&gt; - нет &amp;laquo;объекта&amp;raquo;, связанного с новым состоянием, и вы получите:</target>
        </trans-unit>
        <trans-unit id="43d0ee9ad50c1c3c133c4c2ff3f216463ab119aa" translate="yes" xml:space="preserve">
          <source>The two options can be specified together to ask a command to work on both the index and the working tree.</source>
          <target state="translated">Эти две опции могут быть заданы вместе,чтобы запросить команду для работы как над индексом,так и над рабочим деревом.</target>
        </trans-unit>
        <trans-unit id="293c342524c5d665ec090c34f37c73d153be74d5" translate="yes" xml:space="preserve">
          <source>The type of the object (&lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;).</source>
          <target state="translated">Тип объекта ( &lt;code&gt;blob&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;commit&lt;/code&gt; , &lt;code&gt;tag&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="35ca6d49608b210b7cf8be4b86261fa4bd55e249" translate="yes" xml:space="preserve">
          <source>The type of the object (the same as &lt;code&gt;cat-file -t&lt;/code&gt; reports).</source>
          <target state="translated">Тип объекта (то же, что и &lt;code&gt;cat-file -t&lt;/code&gt; reports).</target>
        </trans-unit>
        <trans-unit id="4785efb96aaa5561500dccbb8420f79e52290b85" translate="yes" xml:space="preserve">
          <source>The underlying Git plumbing tools, such as &lt;code&gt;git ls-files&lt;/code&gt; and &lt;code&gt;git read-tree&lt;/code&gt;, read &lt;code&gt;gitignore&lt;/code&gt; patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git add&lt;/code&gt;, use patterns from the sources specified above.</source>
          <target state="translated">Базовые инструменты Git-сантехники, такие как &lt;code&gt;git ls-files&lt;/code&gt; и &lt;code&gt;git read-tree&lt;/code&gt; , читают шаблоны &lt;code&gt;gitignore&lt;/code&gt; , указанные с помощью параметров командной строки, или из файлов, указанных с помощью параметров командной строки. Инструменты Git более высокого уровня, такие как &lt;code&gt;git status&lt;/code&gt; и &lt;code&gt;git add&lt;/code&gt; , используют шаблоны из указанных выше источников.</target>
        </trans-unit>
        <trans-unit id="c7717dd458d0c51efaa12d77d8ac91e6b1b7952a" translate="yes" xml:space="preserve">
          <source>The unique identifier of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;. The object name is usually represented by a 40 character hexadecimal string. Also colloquially called &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;.</source>
          <target state="translated">Уникальный идентификатор &lt;a href=&quot;#def_object&quot;&gt;объекта&lt;/a&gt; . Имя объекта обычно представлено шестнадцатеричной строкой из 40 символов. Также в просторечии называется &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="190c2fffcaa0444f677f39ee7f8533684a0964b1" translate="yes" xml:space="preserve">
          <source>The unit of storage in Git. It is uniquely identified by the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; of its contents. Consequently, an object cannot be changed.</source>
          <target state="translated">Единица хранения в Git. Он однозначно идентифицируется &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; своего содержимого. Следовательно, объект нельзя изменить.</target>
        </trans-unit>
        <trans-unit id="39871fae2a5575ced5627a5aed0eb792e4c6cc2e" translate="yes" xml:space="preserve">
          <source>The untracked cache extension can be enabled by the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Расширение неотслеживаемого кеша можно включить с помощью переменной конфигурации &lt;code&gt;core.untrackedCache&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc7260429a75073116cdc4eb67dbd95326cbd29d" translate="yes" xml:space="preserve">
          <source>The upstream project is expected to have the commit named by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and the output asks it to integrate the changes you made since that commit, up to the commit named by &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, by visiting the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Ожидается, что в вышестоящем проекте фиксация будет названа &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; , а в выходных данных будет предложено интегрировать изменения, внесенные вами после этой фиксации, вплоть до фиксации, названной &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; , путем посещения репозитория с именем &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90c1df21766dd92e926e4168cc9d516f756c7832" translate="yes" xml:space="preserve">
          <source>The upstream reference is generally &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;, but can be overridden using the &lt;code&gt;--origin=&lt;/code&gt; command-line option.</source>
          <target state="translated">Ссылка на восходящий поток обычно - &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; , но ее можно переопределить с помощью параметра командной строки &lt;code&gt;--origin=&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26e6d639f86a47deca57ab3911edaae9c5141f38" translate="yes" xml:space="preserve">
          <source>The user wants to fast-forward to $M.</source>
          <target state="translated">Пользователь хочет перемотать назад на $M.</target>
        </trans-unit>
        <trans-unit id="6df61c6f9e257fdbf1ce4a60fb1d73b618d329ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s color.status configuration is not respected; color will always be off.</source>
          <target state="translated">Конфигурация пользователя color.status не соблюдается; цвет всегда будет выключен.</target>
        </trans-unit>
        <trans-unit id="ab6a20b222f27dba657bc91ae7970effd7a690ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.</source>
          <target state="translated">Конфигурация пользователя status.relativePaths не соблюдается; показанные пути всегда будут относиться к корню репозитория.</target>
        </trans-unit>
        <trans-unit id="20126eaca194f3ace1deaba2aaa4133e6326b674" translate="yes" xml:space="preserve">
          <source>The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit. Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function.</source>
          <target state="translated">Предоставляемые пользователем команды оболочки,скорее всего,будут включать в себя конвейер команд,что приведет к созданию множества процессов за один коммит.Создание и запуск другого процесса занимает много времени в разных операционных системах,но на любой платформе он очень медленный по сравнению с вызовом функции.</target>
        </trans-unit>
        <trans-unit id="b70cc2efdcbaf68bada34e0550746a0012d52bae" translate="yes" xml:space="preserve">
          <source>The username to use when logging in to the server.</source>
          <target state="translated">Имя пользователя,которое будет использоваться при входе на сервер.</target>
        </trans-unit>
        <trans-unit id="46c33e134557b27ccb1a85349808f80ba518bd84" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;add&lt;/code&gt; (this is the default) and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">Допустимые значения для этой опции: &lt;code&gt;add&lt;/code&gt; (это значение по умолчанию) и &lt;code&gt;doNothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a990c606d2e2e22a8f755a1f843b57ef2f5ef2" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (this is the default), &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">Допустимые значения для этой опции: &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (это значение по умолчанию), &lt;code&gt;addIfDifferent&lt;/code&gt; , &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; или &lt;code&gt;doNothing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="505e929c5c3b27eed17b03a2625718de5c7f7031" translate="yes" xml:space="preserve">
          <source>The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background) and attributes (as many as you want), separated by spaces.</source>
          <target state="translated">Значение для переменной,которая принимает цвет,представляет собой список цветов (максимум два,один для переднего плана и один для фона)и атрибутов (столько,сколько вам нужно),разделенных пробелами.</target>
        </trans-unit>
        <trans-unit id="e1d242fc18797a443a86ba553d48e3f3cae01e9a" translate="yes" xml:space="preserve">
          <source>The value for many variables that specify various sizes can be suffixed with &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;,&amp;hellip;​ to mean &quot;scale the number by 1024&quot;, &quot;by 1024x1024&quot;, etc.</source>
          <target state="translated">Значения многих переменных, которые определяют различные размеры, могут быть дополнены суффиксами &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;M&lt;/code&gt; ,&amp;hellip;, что означает &amp;laquo;масштабировать число на 1024&amp;raquo;, &amp;laquo;на 1024x1024&amp;raquo; и т. Д.</target>
        </trans-unit>
        <trans-unit id="f1dedc58ec3c676ad597a786553123421e517365" translate="yes" xml:space="preserve">
          <source>The value is a list of three values: a default time zone (for if the client hasn&amp;rsquo;t selected some other time zone and saved it in a cookie), a name of cookie where to store selected time zone, and a CSS class used to mark up dates for manipulation. If you want to turn this feature off, set &quot;default&quot; to empty list: &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Значение представляет собой список из трех значений: часовой пояс по умолчанию (если клиент не выбрал другой часовой пояс и не сохранил его в файле cookie), имя файла cookie, в котором следует сохранить выбранный часовой пояс, и используемый класс CSS. разметить даты для манипуляций. Если вы хотите отключить эту функцию, установите &amp;laquo;по умолчанию&amp;raquo; на пустой список: &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0462ada8e80b752f4ecad69fb2563ec0b8b930aa" translate="yes" xml:space="preserve">
          <source>The value of 'default' is a list of names of snapshot formats, defined in &lt;code&gt;%known_snapshot_formats&lt;/code&gt; hash, that you wish to offer. Supported formats include &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot; (gzip/bzip2/xz compressed tar archive) and &quot;zip&quot;; please consult gitweb sources for a definitive list. By default only &quot;tgz&quot; is offered.</source>
          <target state="translated">Значение 'default' - это список имён форматов моментальных снимков, определенных в &lt;code&gt;%known_snapshot_formats&lt;/code&gt; , которые вы хотите предложить. Поддерживаемые форматы включают &amp;laquo;tgz&amp;raquo;, &amp;laquo;tbz2&amp;raquo;, &amp;laquo;txz&amp;raquo; (сжатый tar-архив gzip / bzip2 / xz) и &amp;laquo;zip&amp;raquo;; пожалуйста, обратитесь к источникам gitweb для окончательного списка. По умолчанию предлагается только &amp;laquo;tgz&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="c34b53e9a12553098df9adad4c30762484ffde18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; must be a valid refname in Git and therefore may contain forward slashes. As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname, no quoting or escaping syntax is supported here.</source>
          <target state="translated">Значение &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; должно быть действительным ссылочным именем в Git и, следовательно, может содержать косые черты. Поскольку &lt;code&gt;LF&lt;/code&gt; недопустим в ссылочном имени Git, здесь не поддерживается синтаксис цитирования или экранирования.</target>
        </trans-unit>
        <trans-unit id="8b5a30f586808b1827fdb8f433a15c6c9d49f6ba" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; must be in canonical form. That is it must not:</source>
          <target state="translated">Значение &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; должно быть в канонической форме. То есть не должно:</target>
        </trans-unit>
        <trans-unit id="dfb2ec984e9987b1b930824861a3abbf3e4aa29f" translate="yes" xml:space="preserve">
          <source>The value of this attribute specifies the character encoding that should be used by GUI tools (e.g. &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; and &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;) to display the contents of the relevant file. Note that due to performance considerations &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; does not use this attribute unless you manually enable per-file encodings in its options.</source>
          <target state="translated">Значение этого атрибута указывает кодировку символов, которая должна использоваться инструментами графического интерфейса пользователя (например, &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; и &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; ) для отображения содержимого соответствующего файла. Обратите внимание, что из соображений производительности &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; не использует этот атрибут, если вы вручную не включите кодировку для каждого файла в его параметрах.</target>
        </trans-unit>
        <trans-unit id="4bdcd2a8dee01aee6c5f0f23e7e10ac25985aae6" translate="yes" xml:space="preserve">
          <source>The value of this key is the name of the promisor remote.</source>
          <target state="translated">Значение этого ключа-имя удаленного промоутера.</target>
        </trans-unit>
        <trans-unit id="49e3be97b83e2e2d47823db7b33592c5066364cc" translate="yes" xml:space="preserve">
          <source>The version parameter is used to specify the format version. This is optional and defaults to the original version &lt;code&gt;v1&lt;/code&gt; format.</source>
          <target state="translated">Параметр version используется для указания версии формата. Это необязательно, по умолчанию используется формат исходной версии &lt;code&gt;v1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a720bc9826a296e909d26ea1e1addd2076945090" translate="yes" xml:space="preserve">
          <source>The victim sends &quot;have&quot; lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn&amp;rsquo;t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to &quot;merge&quot; X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)</source>
          <target state="translated">Жертва отправляет строки &amp;laquo;иметь&amp;raquo;, объявляя идентификаторы имеющихся у нее объектов, которые явно не предназначены для совместного использования, но могут использоваться для оптимизации передачи, если они также есть у партнера. Злоумышленник выбирает объект с идентификатором X для кражи и отправляет ссылку на X, но не обязан отправлять содержимое X, поскольку оно уже есть у жертвы. Теперь жертва считает, что у злоумышленника есть X, и позже отправляет содержимое X обратно злоумышленнику. (Эту атаку клиенту проще всего выполнить на сервере, создав ссылку на X в пространстве имен, к которому у клиента есть доступ, а затем извлечет ее. Наиболее вероятный способ для сервера выполнить ее на клиенте - &quot; объединить &quot;X&quot; в общедоступную ветку и надеяться, что пользователь проделает дополнительную работу с этой веткой и отправит ее обратно на сервер, не заметив слияния.)</target>
        </trans-unit>
        <trans-unit id="bad569f9e07003c7e9ba90b91ff6d5e2d3ebab92" translate="yes" xml:space="preserve">
          <source>The virtual host configuration (in Apache configuration file) should look like this:</source>
          <target state="translated">Конфигурация виртуального хоста (в конфигурационном файле Apache)должна выглядеть следующим образом:</target>
        </trans-unit>
        <trans-unit id="6258db9fdd3beac891e6dcfd7dedb19764ce413e" translate="yes" xml:space="preserve">
          <source>The way &lt;code&gt;git update-index&lt;/code&gt; handles files it is told about can be modified using the various options:</source>
          <target state="translated">То, как &lt;code&gt;git update-index&lt;/code&gt; обрабатывает файлы, о которых говорится, можно изменить с помощью различных параметров:</target>
        </trans-unit>
        <trans-unit id="dc2adc08265063993fb836b81a622f1e26249d55" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">Веб-браузер можно указать с помощью переменной конфигурации &lt;code&gt;help.browser&lt;/code&gt; или &lt;code&gt;web.browser&lt;/code&gt; , если первая не задана. Если ни одна из этих переменных конфигурации не задана, вспомогательный сценарий &lt;code&gt;git web{litdd}browse&lt;/code&gt; (вызываемый командой &lt;code&gt;git help&lt;/code&gt; ) выберет подходящее значение по умолчанию. См. Git-web {litdd} browse [1] для получения дополнительной информации об этом.</target>
        </trans-unit>
        <trans-unit id="c38f40c77930468f76ac59e3f127231f37c11803" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">Веб-браузер, который следует использовать для просмотра страницы gitweb. Он будет передан вспомогательному сценарию &lt;code&gt;git web{litdd}browse&lt;/code&gt; вместе с URL-адресом экземпляра gitweb. См. Git-web {litdd} browse [1] для получения дополнительной информации об этом. В случае сбоя сценария URL-адрес будет выведен на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="c7492cc5fa9e9927a227312bd1f1ea85a3766cb5" translate="yes" xml:space="preserve">
          <source>The width (in characters) of the &quot;Description&quot; column of the projects list. Longer descriptions will be truncated (trying to cut at word boundary); the full description is available in the &lt;code&gt;title&lt;/code&gt; attribute (usually shown on mouseover). The default is 25, which might be too small if you use long project descriptions.</source>
          <target state="translated">Ширина (в символах) столбца &amp;laquo;Описание&amp;raquo; списка проектов. Более длинные описания будут обрезаны (при попытке обрезать границы слова); полное описание доступно в атрибуте &lt;code&gt;title&lt;/code&gt; (обычно отображается при наведении указателя мыши). Значение по умолчанию - 25, что может быть слишком мало, если вы используете длинные описания проектов.</target>
        </trans-unit>
        <trans-unit id="2a9553b8b798d28f6c8fd9f09980f5b7959498e9" translate="yes" xml:space="preserve">
          <source>The window size parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 250, which is a much more aggressive window size than the default &lt;code&gt;--window&lt;/code&gt; of 10.</source>
          <target state="translated">Параметр размера окна, используемый в алгоритме дельта-сжатия, используемом &lt;code&gt;git gc --aggressive&lt;/code&gt; . По умолчанию это 250, что является гораздо более агрессивным размером окна, чем значение по умолчанию &lt;code&gt;--window&lt;/code&gt; 10.</target>
        </trans-unit>
        <trans-unit id="046739930d5e8946cdceaf820a70c4ac9ebc8d51" translate="yes" xml:space="preserve">
          <source>The working directory then reflects the contents that the project had when it was tagged v2.6.13, and &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; shows two branches, with an asterisk marking the currently checked-out branch:</source>
          <target state="translated">Затем рабочий каталог отражает содержимое, которое было у проекта, когда он был помечен как v2.6.13, а &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; показывает две ветки, где звездочкой отмечена текущая извлеченная ветка:</target>
        </trans-unit>
        <trans-unit id="c76d23bfcb6d4a63fd96acda23f8bee068090518" translate="yes" xml:space="preserve">
          <source>The worktree list command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">Команда списка рабочего дерева имеет два выходных формата.Формат по умолчанию показывает детали в одной строке со столбцами.Например:</target>
        </trans-unit>
        <trans-unit id="ecaf7c5f30215b083ffbd406549425a7d1040c7d" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git merge topic&lt;/code&gt;&quot; will replay the changes made on the &lt;code&gt;topic&lt;/code&gt; branch since it diverged from &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt;, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">Затем &amp;laquo; &lt;code&gt;git merge topic&lt;/code&gt; &amp;raquo; воспроизведет изменения, внесенные в ветку &lt;code&gt;topic&lt;/code&gt; так как она отклонилась от &lt;code&gt;master&lt;/code&gt; (то есть &lt;code&gt;E&lt;/code&gt; ) до текущей фиксации ( &lt;code&gt;C&lt;/code&gt; ) поверх &lt;code&gt;master&lt;/code&gt; , и запишет результат в новую фиксацию вместе с именами два родительских коммита и сообщение журнала от пользователя с описанием изменений.</target>
        </trans-unit>
        <trans-unit id="f3bf49c80f1bf671798b336ee7a6337eb982b2bc" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git pull&lt;/code&gt;&quot; will fetch and replay the changes from the remote &lt;code&gt;master&lt;/code&gt; branch since it diverged from the local &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt; and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">Затем &amp;laquo; &lt;code&gt;git pull&lt;/code&gt; &amp;raquo; будет извлекать и воспроизводить изменения из удаленной &lt;code&gt;master&lt;/code&gt; ветки, поскольку она расходилась с локальным &lt;code&gt;master&lt;/code&gt; (то есть &lt;code&gt;E&lt;/code&gt; ) до его текущей фиксации ( &lt;code&gt;C&lt;/code&gt; ) поверх &lt;code&gt;master&lt;/code&gt; и записывает результат в новом коммите вместе с имена двух родительских коммитов и сообщение журнала от пользователя, описывающее изменения.</target>
        </trans-unit>
        <trans-unit id="44f92500b7ae9560ae64e2f2fc4f1af900d3ff26" translate="yes" xml:space="preserve">
          <source>Then &quot;git bisect&quot; will checkout a commit of its choosing and ask the user to test it, like this:</source>
          <target state="translated">Затем &quot;git-бисект&quot; извлечёт выбранный коммит и попросит пользователя протестировать его,вот так:</target>
        </trans-unit>
        <trans-unit id="e1ef052a3cd59f805d0ae45d1b9033a6a2faaa95" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;git bisect&lt;/code&gt; will respond with something like</source>
          <target state="translated">Тогда &lt;code&gt;git bisect&lt;/code&gt; ответит чем-то вроде</target>
        </trans-unit>
        <trans-unit id="307236a389d15c9e88cc574f3c2b3a0314992840" translate="yes" xml:space="preserve">
          <source>Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner.</source>
          <target state="translated">Затем скомпилируйте и протестируйте выбранную ревизию,а затем отметьте ревизию как хорошую или плохую обычным способом.</target>
        </trans-unit>
        <trans-unit id="876e252bd62eb2a97f748800c6625b2b00ccfdec" translate="yes" xml:space="preserve">
          <source>Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):</source>
          <target state="translated">Затем подтвердите,что ошибка сохраняется в репозитории,созданном из этого потока (многие ошибки не будут,так как они действительно зависят от точного содержимого репозитория):</target>
        </trans-unit>
        <trans-unit id="87463a5d117dae6022935ddfd68f09bfbb9b0943" translate="yes" xml:space="preserve">
          <source>Then create the following script to get list of project in the format suitable for GITWEB_LIST build configuration variable (or &lt;code&gt;$projects_list&lt;/code&gt; variable in gitweb config):</source>
          <target state="translated">Затем создайте следующий скрипт, чтобы получить список проектов в формате, подходящем для переменной конфигурации сборки GITWEB_LIST (или переменной &lt;code&gt;$projects_list&lt;/code&gt; в конфигурации gitweb):</target>
        </trans-unit>
        <trans-unit id="b5a742d8577423cd13ed5705b5290de27ff73949" translate="yes" xml:space="preserve">
          <source>Then fixup &quot;master&quot; with &lt;code&gt;git rebase&lt;/code&gt;. Do NOT use &lt;code&gt;git merge&lt;/code&gt; or your history will not be compatible with a future &lt;code&gt;dcommit&lt;/code&gt;!</source>
          <target state="translated">Затем исправьте &quot;master&quot; с помощью &lt;code&gt;git rebase&lt;/code&gt; . НЕ используйте &lt;code&gt;git merge&lt;/code&gt; , иначе ваша история не будет совместима с будущим &lt;code&gt;dcommit&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="78318329e21f0014f75ba54a708b1f46ad0d023c" translate="yes" xml:space="preserve">
          <source>Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed.</source>
          <target state="translated">Затем он сравнивает новое значение пропуска с предыдущим.Если пропущенное дерево превращается из множества в неустановленное,то оно добавляет соответствующий файл обратно.Если же оно перейдет из состояния &quot;Неустановлено&quot; в состояние &quot;Неустановлено&quot;,то этот файл будет удален.</target>
        </trans-unit>
        <trans-unit id="5e9c59419a3e5d8568740259a39319d49129c624" translate="yes" xml:space="preserve">
          <source>Then it examines &lt;code&gt;.gitattributes&lt;/code&gt; (which is in the parent directory), and finds that the first line matches, but &lt;code&gt;t/.gitattributes&lt;/code&gt; file already decided how &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes should be given to this path, so it leaves &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; unset. Attribute &lt;code&gt;baz&lt;/code&gt; is set.</source>
          <target state="translated">Затем он проверяет &lt;code&gt;.gitattributes&lt;/code&gt; (который находится в родительском каталоге) и обнаруживает, что первая строка совпадает, но файл &lt;code&gt;t/.gitattributes&lt;/code&gt; уже решил, как атрибуты &lt;code&gt;merge&lt;/code&gt; , &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; должны быть присвоены этому пути, поэтому он оставляет &lt;code&gt;foo&lt;/code&gt; и &lt;code&gt;bar&lt;/code&gt; снята с охраны. Атрибут &lt;code&gt;baz&lt;/code&gt; установлен.</target>
        </trans-unit>
        <trans-unit id="1100f313a3d209e54bf3bc725a364711886dbfc4" translate="yes" xml:space="preserve">
          <source>Then modify, reorder, or eliminate patches as needed before applying them again with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;:</source>
          <target state="translated">Затем измените, переупорядочьте или удалите исправления по мере необходимости, прежде чем применять их снова с помощью &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="cd43ef848f2d3c4afb2a44ae28c2a413397c1d96" translate="yes" xml:space="preserve">
          <source>Then provide your password via the pserver method, for example:</source>
          <target state="translated">Затем предоставьте свой пароль,например,методом pserver:</target>
        </trans-unit>
        <trans-unit id="a774f276f116b48d127c0c1418ef7aa2fe46b49b" translate="yes" xml:space="preserve">
          <source>Then simplify each commit &lt;code&gt;C&lt;/code&gt; to its replacement &lt;code&gt;C'&lt;/code&gt; in the final history according to the following rules:</source>
          <target state="translated">Затем упростите каждый коммит &lt;code&gt;C&lt;/code&gt; до его замены &lt;code&gt;C'&lt;/code&gt; в окончательной истории в соответствии со следующими правилами:</target>
        </trans-unit>
        <trans-unit id="2f5d7fdcf8fcb013dcf3c597507de91a5cb0f77d" translate="yes" xml:space="preserve">
          <source>Then simply fork your topic branches from the stable remotes as explained earlier.</source>
          <target state="translated">Затем просто вилка ветки вашей темы из стабильных пультов,как объяснялось ранее.</target>
        </trans-unit>
        <trans-unit id="b19a7b2e2b2e2252f0564256c9b87915d5db46d3" translate="yes" xml:space="preserve">
          <source>Then suppose you modify the last three commits:</source>
          <target state="translated">Тогда предположим,что вы модифицируете три последних коммита:</target>
        </trans-unit>
        <trans-unit id="e69e2e34d497710c4127a780d2a5ed5c7d7fac83" translate="yes" xml:space="preserve">
          <source>Then there are two ways to get a smaller repository. A safer way is to clone, that keeps your original intact.</source>
          <target state="translated">Тогда есть два способа получить репозиторий поменьше.Более безопасный способ-клонирование,которое сохранит ваш оригинал в целости и сохранности.</target>
        </trans-unit>
        <trans-unit id="5c871054b486e3acaf28dc409c1ab3e693b4fc90" translate="yes" xml:space="preserve">
          <source>Then this &lt;code&gt;git p4 clone&lt;/code&gt; command:</source>
          <target state="translated">Затем эта команда &lt;code&gt;git p4 clone&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="db9b57b987ef397bc0b191d278e31ed2d827cb0a" translate="yes" xml:space="preserve">
          <source>Then you can disable sparse checkout. Sparse checkout support in &lt;code&gt;git read-tree&lt;/code&gt; and similar commands is disabled by default. You need to turn &lt;code&gt;core.sparseCheckout&lt;/code&gt; on in order to have sparse checkout support.</source>
          <target state="translated">Затем вы можете отключить разреженную проверку. Поддержка разреженной проверки в &lt;code&gt;git read-tree&lt;/code&gt; и аналогичных командах по умолчанию отключена. Вам необходимо включить &lt;code&gt;core.sparseCheckout&lt;/code&gt; , чтобы иметь разреженную поддержку при оформлении заказа.</target>
        </trans-unit>
        <trans-unit id="87a33f516a8ffec885e906dbb29e388a5f30ada0" translate="yes" xml:space="preserve">
          <source>Then you can pull and merge, leaving &lt;code&gt;frotz.c&lt;/code&gt; and &lt;code&gt;filfre.c&lt;/code&gt; changes still in the working tree.</source>
          <target state="translated">Затем вы можете вытащить и объединить, оставив изменения &lt;code&gt;frotz.c&lt;/code&gt; и &lt;code&gt;filfre.c&lt;/code&gt; в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="fa280cd97c17d646b4ce0e60bbbcb27953b34fb3" translate="yes" xml:space="preserve">
          <source>Then you can push both the test and release trees using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;:</source>
          <target state="translated">Затем вы можете отправить деревья тестирования и выпуска с помощью &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9015e54306232b9477b76c544780cb6cb29e184c" translate="yes" xml:space="preserve">
          <source>Then you might want a &lt;code&gt;.mailmap&lt;/code&gt; file that looks like:</source>
          <target state="translated">Тогда вам может понадобиться файл &lt;code&gt;.mailmap&lt;/code&gt; , который выглядит так:</target>
        </trans-unit>
        <trans-unit id="bdefcc2b7f4d341c71ca424367a0164c209ac375" translate="yes" xml:space="preserve">
          <source>Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:</source>
          <target state="translated">Затем вы передаете file.bundle на целевую машину B.Поскольку этот пакет не требует извлечения любого существующего объекта,вы можете создать новое хранилище на машине B,клонируя из него:</target>
        </trans-unit>
        <trans-unit id="e826c3727c0c79aa7b30f2352881ef1c5a35f171" translate="yes" xml:space="preserve">
          <source>Then you would define a &quot;filter.indent.clean&quot; and &quot;filter.indent.smudge&quot; configuration in your .git/config to specify a pair of commands to modify the contents of C programs when the source files are checked in (&quot;clean&quot; is run) and checked out (no change is made because the command is &quot;cat&quot;).</source>
          <target state="translated">Затем вы определяете конфигурацию &quot;filter.indent.clean&quot; и &quot;filter.indent.smudge&quot; в вашем .git/config,чтобы указать пару команд для изменения содержимого программ на Си,когда проверяются исходные файлы (&quot;clean&quot; выполняется)и извлекаются (&quot;clean&quot; выполняется)(никаких изменений не производится,потому что команда &quot;cat&quot;).</target>
        </trans-unit>
        <trans-unit id="c6308f4c83137c8ddf705f0b33927bc3a2a2d3bf" translate="yes" xml:space="preserve">
          <source>Then, make that directory into a Git repository by running &lt;code&gt;git init&lt;/code&gt;, but this time, since its name is not the usual &lt;code&gt;.git&lt;/code&gt;, we do things slightly differently:</source>
          <target state="translated">Затем превратите этот каталог в репозиторий Git, запустив &lt;code&gt;git init&lt;/code&gt; , но на этот раз, поскольку его имя отличается от обычного &lt;code&gt;.git&lt;/code&gt; , мы делаем все немного иначе:</target>
        </trans-unit>
        <trans-unit id="4d45e0228f3dfbda52666260c02f45c435d7f13c" translate="yes" xml:space="preserve">
          <source>Then, use &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; and &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; instead of &lt;code&gt;git bisect good&lt;/code&gt; and &lt;code&gt;git bisect bad&lt;/code&gt; to mark commits.</source>
          <target state="translated">Затем используйте &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; и &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; вместо &lt;code&gt;git bisect good&lt;/code&gt; и &lt;code&gt;git bisect bad&lt;/code&gt; , чтобы отмечать коммиты.</target>
        </trans-unit>
        <trans-unit id="b100177b4f5d14520d5631ccbd2bc2ff52393e78" translate="yes" xml:space="preserve">
          <source>Then, you run this command:</source>
          <target state="translated">Затем,ты выполняешь эту команду:</target>
        </trans-unit>
        <trans-unit id="ebbdc2314a6104dc9178c4c9ed7835ad78f84727" translate="yes" xml:space="preserve">
          <source>Then, you would define a &quot;diff.tex.xfuncname&quot; configuration to specify a regular expression that matches a line that you would want to appear as the hunk header &quot;TEXT&quot;. Add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">Затем вы должны определить конфигурацию &amp;laquo;diff.tex.xfuncname&amp;raquo;, чтобы указать регулярное выражение, которое соответствует строке, которая должна отображаться как заголовок фрагмента &amp;laquo;TEXT&amp;raquo;. Добавьте раздел в свой файл &lt;code&gt;$GIT_DIR/config&lt;/code&gt; (или файл &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ) следующим образом:</target>
        </trans-unit>
        <trans-unit id="8d94c9456285c171a8f18dcac7b76fd1fccc9ff4" translate="yes" xml:space="preserve">
          <source>There are (number of parents + 1) &lt;code&gt;@&lt;/code&gt; characters in the chunk header for combined diff format.</source>
          <target state="translated">В заголовке блока для комбинированного формата сравнения есть (количество родителей + 1) символов &lt;code&gt;@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7e9cf96a6ce9ed5c513750352c4736c076b5145" translate="yes" xml:space="preserve">
          <source>There are CPP wrapper macros and ifdefs to hide most of these details. See &lt;code&gt;trace2.h&lt;/code&gt; for more details. The following discussion will only describe the simplified forms.</source>
          <target state="translated">Существуют макросы оболочки CPP и ifdef, чтобы скрыть большую часть этих деталей. См. &lt;code&gt;trace2.h&lt;/code&gt; для более подробной информации. Следующее обсуждение будет описывать только упрощенные формы.</target>
        </trans-unit>
        <trans-unit id="e4287f1e47cb2bfc1b9e5f25165aef43ceec9d6c" translate="yes" xml:space="preserve">
          <source>There are a few built-in low-level merge drivers defined that can be asked for via the &lt;code&gt;merge&lt;/code&gt; attribute.</source>
          <target state="translated">Определено несколько встроенных низкоуровневых драйверов слияния, которые можно запросить через атрибут &lt;code&gt;merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12f3989319ea3c0cba3d029a62ee2c306fd0616b" translate="yes" xml:space="preserve">
          <source>There are a few built-in patterns to make this easier, and &lt;code&gt;tex&lt;/code&gt; is one of them, so you do not have to write the above in your configuration file (you still need to enable this with the attribute mechanism, via &lt;code&gt;.gitattributes&lt;/code&gt;). The following built in patterns are available:</source>
          <target state="translated">Есть несколько встроенных шаблонов, чтобы упростить это, и &lt;code&gt;tex&lt;/code&gt; - один из них, поэтому вам не нужно записывать вышеуказанное в свой файл конфигурации (вам все равно нужно включить это с помощью механизма атрибутов через &lt;code&gt;.gitattributes&lt;/code&gt; ). Доступны следующие встроенные шаблоны:</target>
        </trans-unit>
        <trans-unit id="336d04ab3583042f88f12edf2d051324b94f62a0" translate="yes" xml:space="preserve">
          <source>There are a few issues to resolve before we can completely switch to Trace2.</source>
          <target state="translated">Есть несколько проблем,которые необходимо решить,прежде чем мы сможем полностью перейти на Trace2.</target>
        </trans-unit>
        <trans-unit id="f553cccafe9fdfa62552e6e1af4be573be245c47" translate="yes" xml:space="preserve">
          <source>There are a few special-purpose refs that do not begin with &lt;code&gt;refs/&lt;/code&gt;. The most notable example is &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Есть несколько специальных ссылок, которые не начинаются с &lt;code&gt;refs/&lt;/code&gt; . Самый яркий пример - &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9f53378dabd08666f7e5c5af2a717dbbd37e28" translate="yes" xml:space="preserve">
          <source>There are a number of factors which affect how much memory fast-import requires to perform an import. Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc. In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations.</source>
          <target state="translated">Существует ряд факторов,влияющих на то,какой объем памяти требуется для быстрого импорта.Как и в случае с критическими разделами ядра Git'а,при быстром импорте используются собственные аллокаторы памяти для амортизации любых накладных расходов,связанных с malloc'ом.На практике быстродействующий импорт,как правило,амортизирует любые накладные расходы,связанные с malloc,до 0 за счет использования больших блоков.</target>
        </trans-unit>
        <trans-unit id="e0b2b532209e8b05d8ee20f67e782301986fd65a" translate="yes" xml:space="preserve">
          <source>There are also cases where existing indexes written by git versions before 2.17 will reference directories that don&amp;rsquo;t exist anymore, potentially causing many &quot;could not open directory&quot; warnings to be printed on &quot;git status&quot;. These are new warnings for existing issues that were previously silently discarded.</source>
          <target state="translated">Также бывают случаи, когда существующие индексы, написанные версиями git до 2.17, будут ссылаться на каталоги, которые больше не существуют, что может привести к тому, что многие предупреждения &amp;laquo;не удалось открыть каталог&amp;raquo; будут напечатаны на &amp;laquo;git status&amp;raquo;. Это новые предупреждения о существующих проблемах, которые ранее игнорировались.</target>
        </trans-unit>
        <trans-unit id="aec0acb7fb7522f7c5da2df9b13975842cb9d1be" translate="yes" xml:space="preserve">
          <source>There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to &quot;undo&quot; the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree.</source>
          <target state="translated">Существуют также более сложные операции,которые могут быть выполнены.Но учтите,что поскольку патч применяется только к индексу,а не к рабочему дереву,то рабочее дерево окажется &quot;отменяющим&quot; изменение индекса.Например,введение в индекс новой строки,которая не находится ни в HEAD,ни в рабочем дереве,приведет к фиксации новой строки,но в рабочем дереве она будет выглядеть как &quot;отменяющая&quot; изменение индекса.</target>
        </trans-unit>
        <trans-unit id="a266660a35cd18470141c43d8a3ffa2b3074c06a" translate="yes" xml:space="preserve">
          <source>There are also other situations that cause dangling objects. For example, a &quot;dangling blob&quot; may arise because you did a &lt;code&gt;git add&lt;/code&gt; of a file, but then, before you actually committed it and made it part of the bigger picture, you changed something else in that file and committed that &lt;strong&gt;updated&lt;/strong&gt; thing&amp;mdash;​the old state that you added originally ends up not being pointed to by any commit or tree, so it&amp;rsquo;s now a dangling blob object.</source>
          <target state="translated">Есть и другие ситуации, в которых могут появиться болтающиеся предметы. Например, &amp;laquo;висячий blob&amp;raquo; может возникнуть из-за того, что вы выполнили &lt;code&gt;git add&lt;/code&gt; файла, но затем, прежде чем вы фактически зафиксировали его и сделали его частью более широкой картины, вы изменили что-то еще в этом файле и зафиксировали этот &lt;strong&gt;обновленный&lt;/strong&gt; элемент - Старое состояние, которое вы добавили изначально, заканчивается тем, что на него не указывает ни один коммит или дерево, поэтому теперь это висящий объект blob.</target>
        </trans-unit>
        <trans-unit id="232088d916b340ecad3098c72c2ebccbe30b76e5" translate="yes" xml:space="preserve">
          <source>There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:</source>
          <target state="translated">Есть также несколько операций,которых следует полностью избегать,так как они сделают невозможным применение патча:</target>
        </trans-unit>
        <trans-unit id="eeb0752be9462c9bd2e54575f2023419e06b3d3b" translate="yes" xml:space="preserve">
          <source>There are also ways to automate the bisecting process if you have a test script that can tell a good from a bad commit. See &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; for more information about this and other &lt;code&gt;git
bisect&lt;/code&gt; features.</source>
          <target state="translated">Есть также способы автоматизировать процесс деления пополам, если у вас есть тестовый сценарий, который может отличить хороший коммит от плохого. См. &lt;a href=&quot;git-bisect&quot;&gt;Git-bisect [1]&lt;/a&gt; для получения дополнительной информации об этой и других функциях &lt;code&gt;git bisect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="753d0dde7d0dbacd496fb113e3e96e5ea6d9494d" translate="yes" xml:space="preserve">
          <source>There are four different types of objects: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">Существует четыре различных типа объектов:&quot;капля&quot;,&quot;дерево&quot;,&quot;коммит&quot; и &quot;тег&quot;.</target>
        </trans-unit>
        <trans-unit id="a3d0232ce28c94288cf502f722ca216e09b8c5b1" translate="yes" xml:space="preserve">
          <source>There are implementations of Git that do not leave usable values in some fields (e.g. JGit); by excluding these fields from the comparison, the &lt;code&gt;minimal&lt;/code&gt; mode may help interoperability when the same repository is used by these other systems at the same time.</source>
          <target state="translated">Существуют реализации Git, которые не оставляют полезных значений в некоторых полях (например, JGit); исключая эти поля из сравнения, &lt;code&gt;minimal&lt;/code&gt; режим может способствовать взаимодействию, когда один и тот же репозиторий используется этими другими системами одновременно.</target>
        </trans-unit>
        <trans-unit id="ac26d523869587e187089ca0cfe8dfa88bde0428" translate="yes" xml:space="preserve">
          <source>There are many more; see the &quot;SPECIFYING REVISIONS&quot; section of the &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; man page for the complete list of ways to name revisions. Some examples:</source>
          <target state="translated">Есть еще много чего; см. раздел &amp;laquo; &lt;a href=&quot;gitrevisions&quot;&gt;УКАЗАНИЕ РЕДАКЦИЙ&amp;raquo;&lt;/a&gt; на странице руководства gitrevisions [7] для получения полного списка способов присвоения имен ревизиям. Некоторые примеры:</target>
        </trans-unit>
        <trans-unit id="caa64d4f477bb9cc6ae8b8763c8d93ec4bfb0cef" translate="yes" xml:space="preserve">
          <source>There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand. (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn&amp;rsquo;t have ever been functional since it&amp;rsquo;s missing some files.)</source>
          <target state="translated">Нет никаких средств, которые помогли бы пользователям найти, какой нежелательный мусор им следует удалить, а это означает, что у них гораздо больше шансов получить неполные или частичные очистки, которые иногда приводят к путанице и тратят время на попытки понять. (Например, люди, как правило, просто ищут большие файлы для удаления вместо больших каталогов или расширений, и как только они это сделают, то через некоторое время люди, использующие новый репозиторий, которые просматривают историю, заметят каталог артефактов сборки, в котором есть некоторые файлы но не другие, или кеш зависимостей (node_modules или аналогичный), которые никогда не могли быть функциональными, поскольку в нем отсутствуют некоторые файлы.)</target>
        </trans-unit>
        <trans-unit id="ce4a9f9a1026ea763732ff998a2bcfb7b60f26ca" translate="yes" xml:space="preserve">
          <source>There are no public Trace2 data structures.</source>
          <target state="translated">Общедоступных структур данных Trace2 нет.</target>
        </trans-unit>
        <trans-unit id="5a1dbdef2a9d4fcde2fec24ad984bfc7ec6f3aa2" translate="yes" xml:space="preserve">
          <source>There are numerous other tools, such as StGit, which exist for the purpose of maintaining a patch series. These are outside of the scope of this manual.</source>
          <target state="translated">Существует множество других инструментов,таких как StGit,которые существуют для поддержания серии патчей.Они выходят за рамки данного руководства.</target>
        </trans-unit>
        <trans-unit id="306721e74c73edf4b4a1c2554be600724c25d3f0" translate="yes" xml:space="preserve">
          <source>There are other estimates saying that 80% of the cost related to software is about maintenance &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">Есть и другие оценки, согласно которым 80% затрат на программное обеспечение приходится на обслуживание &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7eccee0caa41472aded0ea349d3d3fa4831b32ab" translate="yes" xml:space="preserve">
          <source>There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory.</source>
          <target state="translated">Есть и другие реальные примеры использования перехватчиков обновлений и постобновления,которые можно найти в каталоге Documentation/howto.</target>
        </trans-unit>
        <trans-unit id="ddc4304f0c733f93eaa36c71971b210be6c86baa" translate="yes" xml:space="preserve">
          <source>There are several built-in formats, and you can define additional formats by setting a pretty.&amp;lt;name&amp;gt; config option to either another format name, or a &lt;code&gt;format:&lt;/code&gt; string, as described below (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Here are the details of the built-in formats:</source>
          <target state="translated">Существует несколько встроенных форматов, и вы можете определить дополнительные форматы, установив для параметра конфигурации pretty. &amp;lt;name&amp;gt; либо другое имя формата, либо строку &lt;code&gt;format:&lt;/code&gt; , как описано ниже (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ). Вот подробности встроенных форматов:</target>
        </trans-unit>
        <trans-unit id="172e083c83bf7e6cbde177805c61722f6bdc0777" translate="yes" xml:space="preserve">
          <source>There are some numbers about bugs in general, like a NIST study in 2002 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; that said:</source>
          <target state="translated">Есть некоторые цифры об ошибках в целом, например, исследование NIST в 2002 году &lt;a href=&quot;#1&quot;&gt;[1], в&lt;/a&gt; котором говорилось:</target>
        </trans-unit>
        <trans-unit id="1a73feb2f257a54073e6e874ef78ceeefd47d29e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences how the backends behave.</source>
          <target state="translated">Есть некоторые тонкие различия в том,как ведут себя бэкенды.</target>
        </trans-unit>
        <trans-unit id="a41ebe77f2eb54fbd4f30714a2e14c8c1d436ea0" translate="yes" xml:space="preserve">
          <source>There are three commands with similar names: &lt;code&gt;git reset&lt;/code&gt;, &lt;code&gt;git restore&lt;/code&gt; and &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">Есть три команды с похожими именами: &lt;code&gt;git reset&lt;/code&gt; , &lt;code&gt;git restore&lt;/code&gt; и &lt;code&gt;git revert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27e17ed315eeb27fa67bd10d3870c4d2deb8a92d" translate="yes" xml:space="preserve">
          <source>There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches.</source>
          <target state="translated">Существует три различных подхода:используйте надстройку для отключения оберток,настройте Thunderbird так,чтобы не искажать патчи,или используйте внешний редактор,чтобы удержать Thunderbird от искажения патчей.</target>
        </trans-unit>
        <trans-unit id="8c553f5839a8296a42918c5ea6f6a2fcca19fa49" translate="yes" xml:space="preserve">
          <source>There are three main tools that can be used for this:</source>
          <target state="translated">Для этого можно использовать три основных инструмента:</target>
        </trans-unit>
        <trans-unit id="86e24f426735724adb9ab7ea59c461905251e8e9" translate="yes" xml:space="preserve">
          <source>There are three ways to specify which refs to update on the remote end.</source>
          <target state="translated">Есть три способа указать,какие ссылки обновлять на удаленном конце.</target>
        </trans-unit>
        <trans-unit id="5544b2d42620b4375dbc730230171fe04b9f972b" translate="yes" xml:space="preserve">
          <source>There are two different types of capabilities: normal capabilities, which can be used to convey information or alter the behavior of a request, and commands, which are the core actions that a client wants to perform (fetch, push, etc).</source>
          <target state="translated">Существует два различных типа возможностей:обычные возможности,которые могут быть использованы для передачи информации или изменения поведения запроса,и команды,которые являются основными действиями,которые клиент хочет выполнять (fetch,push и т.д.).</target>
        </trans-unit>
        <trans-unit id="c2015c03c4c8786233c499c7815e06c17100a16b" translate="yes" xml:space="preserve">
          <source>There are two formats accepted for patch files:</source>
          <target state="translated">Существует два формата файлов патчей:</target>
        </trans-unit>
        <trans-unit id="9b5e9b84c7e0cf0cc62bfad7ffc7f5a42847bbc1" translate="yes" xml:space="preserve">
          <source>There are two kinds of fixes, discussed in the following subsections:</source>
          <target state="translated">Существует два вида исправлений,которые рассматриваются в следующих подразделах:</target>
        </trans-unit>
        <trans-unit id="afe3df249e404830655fd820b0b8e96397ac9183" translate="yes" xml:space="preserve">
          <source>There are two main tools that can be used to include changes from one branch on another: &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; and &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;.</source>
          <target state="translated">Есть два основных инструмента, которые можно использовать для включения изменений из одной ветки в другую: &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; и &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1432c9def859812f2dcccb492cbe2b422538cffb" translate="yes" xml:space="preserve">
          <source>There are two ways to specify which commits to operate on.</source>
          <target state="translated">Есть два способа указать,над какими коммитами нужно работать.</target>
        </trans-unit>
        <trans-unit id="04a6eae6f43fc050171fa2270096884eaba0fee3" translate="yes" xml:space="preserve">
          <source>There is a difference between listing multiple &amp;lt;refspec&amp;gt; directly on &lt;em&gt;git pull&lt;/em&gt; command line and having multiple &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; entries in your configuration for a &amp;lt;repository&amp;gt; and running a &lt;em&gt;git pull&lt;/em&gt; command without any explicit &amp;lt;refspec&amp;gt; parameters. &amp;lt;refspec&amp;gt;s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, &lt;em&gt;git pull&lt;/em&gt; will create an Octopus merge. On the other hand, if you do not list any explicit &amp;lt;refspec&amp;gt; parameter on the command line, &lt;em&gt;git pull&lt;/em&gt; will fetch all the &amp;lt;refspec&amp;gt;s it finds in the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration and merge only the first &amp;lt;refspec&amp;gt; found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.</source>
          <target state="translated">Существует разница между перечислением нескольких &amp;lt;refspec&amp;gt; непосредственно в командной строке &lt;em&gt;git pull&lt;/em&gt; и наличием нескольких записей &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; в вашей конфигурации для &amp;lt;repository&amp;gt; и запуском команды &lt;em&gt;git pull&lt;/em&gt; без каких-либо явных параметров &amp;lt;refspec&amp;gt;. &amp;lt;refspec&amp;gt;, указанные явно в командной строке, всегда объединяются в текущую ветку после выборки. Другими словами, если вы укажете более одной удаленной ссылки, &lt;em&gt;git pull&lt;/em&gt; создаст слияние Octopus. С другой стороны, если вы не укажете какой-либо явный параметр &amp;lt;refspec&amp;gt; в командной строке, &lt;em&gt;git pull&lt;/em&gt; извлечет все &amp;lt;refspec&amp;gt;, которые он найдет на &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; конфигурации и объединить только первый найденный &amp;lt;refspec&amp;gt; в текущую ветку. Это связано с тем, что создание Octopus из удаленных ссылок выполняется редко, в то время как отслеживание нескольких удаленных головок за один раз путем получения более чем одной часто бывает полезно.</target>
        </trans-unit>
        <trans-unit id="08d27e369ae02f07111163548604defe0fd7ba02" translate="yes" xml:space="preserve">
          <source>There is a fourth official branch that is used slightly differently:</source>
          <target state="translated">Существует четвертый официальный филиал,который используется несколько иначе:</target>
        </trans-unit>
        <trans-unit id="3ab0818052937d36eff9b5a2767bc99b339b1151" translate="yes" xml:space="preserve">
          <source>There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor.</source>
          <target state="translated">Есть скрипт в contrib/thunderbird-patch-inline,который может помочь вам включить патчи с Thunderbird простым способом.Для его использования сделайте описанные выше шаги,а затем используйте скрипт в качестве внешнего редактора.</target>
        </trans-unit>
        <trans-unit id="1232149fc68bcd969b013f8dcdb8f804dc24a0d6" translate="yes" xml:space="preserve">
          <source>There is a tradeoff of course: merges require a more careful branch management. The following subsections discuss the important points.</source>
          <target state="translated">Конечно,есть и компромисс:слияния требуют более тщательного управления филиалами.В следующих подразделах обсуждаются важные моменты.</target>
        </trans-unit>
        <trans-unit id="dad64266cc32a47cdf74ec10317455f91f86159c" translate="yes" xml:space="preserve">
          <source>There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt;:</source>
          <target state="translated">Уже существует проект под названием BBChop, созданный Ealdwulf Wuffinga на Github, который делает что-то подобное с использованием теории байесовского поиска &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="72c8cb7314c2d9e687a4188f4607320887a3abaf" translate="yes" xml:space="preserve">
          <source>There is also a deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names.</source>
          <target state="translated">Также существует устаревший синтаксис &lt;code&gt;[section.subsection]&lt;/code&gt; . С помощью этого синтаксиса имя подраздела преобразуется в нижний регистр, а также сравнивается с учетом регистра. Эти имена подразделов подчиняются тем же ограничениям, что и имена разделов.</target>
        </trans-unit>
        <trans-unit id="562a7aac41f0a6a2b8bd94c80ba1df49ae8c2861" translate="yes" xml:space="preserve">
          <source>There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the &lt;code&gt;-&amp;gt;&lt;/code&gt; is omitted from rename entries and the field order is reversed (e.g &lt;code&gt;from -&amp;gt; to&lt;/code&gt; becomes &lt;code&gt;to from&lt;/code&gt;). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed.</source>
          <target state="translated">Также для машинного анализа рекомендуется альтернативный формат -z. В этом формате поле статуса такое же, но некоторые другие вещи меняются. Во-первых, в записях переименования опускается &lt;code&gt;-&amp;gt;&lt;/code&gt; , а порядок полей меняется на обратный (например, &lt;code&gt;from -&amp;gt; to&lt;/code&gt; становится &lt;code&gt;to from&lt;/code&gt; ). Во-вторых, за каждым именем файла следует NUL (ASCII 0), заменяющий пробел в качестве разделителя полей и завершающую новую строку (но пробел по-прежнему отделяет поле состояния от первого имени файла). В-третьих, имена файлов, содержащие специальные символы, специально не форматируются; кавычки или обратная косая черта не выполняется.</target>
        </trans-unit>
        <trans-unit id="23b53316aea0dd64f8f21ea0eae539235bf45a74" translate="yes" xml:space="preserve">
          <source>There is also an option to sort by versions, this can be done by using the fieldname &lt;code&gt;version:refname&lt;/code&gt; or its alias &lt;code&gt;v:refname&lt;/code&gt;.</source>
          <target state="translated">Также есть возможность сортировки по версиям, это можно сделать с помощью &lt;code&gt;version:refname&lt;/code&gt; или его псевдонима &lt;code&gt;v:refname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="490f0c7223e032436f3ed74187899d6766a21bb5" translate="yes" xml:space="preserve">
          <source>There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with &quot;git commit --amend&quot; to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run &quot;git push --force&quot; to overwrite it. In other words, &quot;git push --force&quot; is a method reserved for a case where you do mean to lose history.</source>
          <target state="translated">Есть еще одна распространенная ситуация,когда при попытке протолкнуть вы можете столкнуться с отказом от перемотки вперёд,и это возможно,даже когда вы протолкнули в репозиторий,в который никто больше не протолкнётся.После того,как вы сами протолкнули коммит A (на первой картинке в этом разделе),замените его на &quot;gith-коммит --amend&quot; для создания коммита B,и вы попытаетесь его вытолкнуть,потому что забыли,что вы уже протолкнули A.В таком случае,и только если вы уверены,что за это время никто не получил ваш предыдущий коммит A (и начал строиться на нём),вы можете запустить &quot;git push --force&quot;,чтобы перезаписать его.Другими словами,&quot;git push --force&quot;-это метод,зарезервированный для случая,когда вы действительно хотите потерять историю.</target>
        </trans-unit>
        <trans-unit id="76938def2c927fda8d1c815e17291d57380d4a8a" translate="yes" xml:space="preserve">
          <source>There is another tweak in the bisection algorithm that has not been described in the &quot;bisection algorithm&quot; above.</source>
          <target state="translated">Есть еще один нюанс в алгоритме биссекции,который не был описан выше в &quot;алгоритме биссекции&quot;.</target>
        </trans-unit>
        <trans-unit id="6cd697be600e420b39bb68cc6d967c4ceca70af4" translate="yes" xml:space="preserve">
          <source>There is no option for &lt;code&gt;git rm&lt;/code&gt; to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done.</source>
          <target state="translated">Для &lt;code&gt;git rm&lt;/code&gt; нет возможности удалить из индекса только те пути, которые исчезли из файловой системы. Однако, в зависимости от варианта использования, это можно сделать несколькими способами.</target>
        </trans-unit>
        <trans-unit id="60bcaa98facce6fa9b4916fcb4556840549eaf70" translate="yes" xml:space="preserve">
          <source>There is no other restriction on the replaced and replacement objects. Merge commits can be replaced by non-merge commits and vice versa.</source>
          <target state="translated">Других ограничений на замену и замену предметов нет.Объединительные коммиты могут быть заменены коммитами,не использующими коммиты и наоборот.</target>
        </trans-unit>
        <trans-unit id="5b920fe2651a1acef3f4de11b5f87d418bf37e32" translate="yes" xml:space="preserve">
          <source>There is now a new commit &lt;code&gt;e&lt;/code&gt;, but it is referenced only by &lt;code&gt;HEAD&lt;/code&gt;. We can of course add yet another commit in this state:</source>
          <target state="translated">Теперь есть новый коммит &lt;code&gt;e&lt;/code&gt; , но на него ссылается только &lt;code&gt;HEAD&lt;/code&gt; . Конечно, мы можем добавить еще одну фиксацию в этом состоянии:</target>
        </trans-unit>
        <trans-unit id="e84a3494173a3e4e1765afc114a7bb8588db5e4e" translate="yes" xml:space="preserve">
          <source>There is one special case not mentioned above, which is treated differently. Normally, a merge results in a merge commit, with two parents, one pointing at each of the two lines of development that were merged.</source>
          <target state="translated">Есть один особый случай,не упомянутый выше,к которому относятся по-разному.Обычно в результате слияния происходит коммит с двумя родителями,по одному,указывающему на каждую из двух линий развития,которые были объединены.</target>
        </trans-unit>
        <trans-unit id="9c233ac02212216497063926a3cd425b73c1b106" translate="yes" xml:space="preserve">
          <source>There may be other problems when using &lt;code&gt;git rev-list&lt;/code&gt; related to pending objects.</source>
          <target state="translated">При использовании &lt;code&gt;git rev-list&lt;/code&gt; могут возникнуть другие проблемы, связанные с ожидающими объектами.</target>
        </trans-unit>
        <trans-unit id="3cc97d3b58e95d007d294ed252208117b7ea36ad" translate="yes" xml:space="preserve">
          <source>There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok.</source>
          <target state="translated">В какой-то момент в списке рассылки ядра linux была дискуссия о том,можно ли всегда просить конечного пользователя сделать бисект,и были сделаны очень хорошие замечания,чтобы поддержать точку зрения,что это нормально.</target>
        </trans-unit>
        <trans-unit id="e31f2056d77b9761665b1e39804c963e7c7e3f73" translate="yes" xml:space="preserve">
          <source>Therefore if the refspec for the remote includes e.g. &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or you manually run e.g. &lt;code&gt;git fetch
--prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; it won&amp;rsquo;t be stale remote tracking branches that are deleted, but any local tag that doesn&amp;rsquo;t exist on the remote.</source>
          <target state="translated">Поэтому, если refspec для пульта дистанционного управления включает, например, &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; , или вы вручную запускаете, например, &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; он выиграл ' Это устаревшие удаленные ветки отслеживания, но любые локальные теги, которые не существуют на удаленном компьютере.</target>
        </trans-unit>
        <trans-unit id="22e33781a4f63d74c967572b3d2d5742f6f5b3cf" translate="yes" xml:space="preserve">
          <source>These are applied in sequence. The set of filepairs &lt;code&gt;git diff-*&lt;/code&gt; commands find are used as the input to diffcore-break, and the output from diffcore-break is used as the input to the next transformation. The final result is then passed to the output routine and generates either diff-raw format (see Output format sections of the manual for &lt;code&gt;git diff-*&lt;/code&gt; commands) or diff-patch format.</source>
          <target state="translated">Они применяются последовательно. Набор команд &lt;code&gt;git diff-*&lt;/code&gt; пар git diff- * find используется в качестве входных данных для diffcore-break, а выходные данные из diffcore-break используются в качестве входных данных для следующего преобразования. Конечный результат затем передается в процедуру вывода и генерирует либо формат diff-raw (см. Разделы руководства по формату вывода руководства для команд &lt;code&gt;git diff-*&lt;/code&gt; ), либо формат diff-patch.</target>
        </trans-unit>
        <trans-unit id="5e4c5d2d8cb413a7bc102a12d4b32266eb5dffbd" translate="yes" xml:space="preserve">
          <source>These are concerned with describing the specific Git command after the command line, config, and environment are inspected. e.g: &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt;, &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt;.</source>
          <target state="translated">Они связаны с описанием конкретной команды Git после проверки командной строки, конфигурации и среды. например: &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt; , &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd918e1aed68e545e545890a5d457bd39124acbb" translate="yes" xml:space="preserve">
          <source>These are concerned with recording performance data over regions or spans of code. e.g: &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt;.</source>
          <target state="translated">Они связаны с записью данных о производительности по регионам или промежуткам кода. например: &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10ea7c6e4b3ea51596f6b19ba236a57b5e812041" translate="yes" xml:space="preserve">
          <source>These are concerned with the lifetime of the overall git process. e.g: &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt;, &lt;code&gt;void trace2_initialize()&lt;/code&gt;, &lt;code&gt;int trace2_is_enabled()&lt;/code&gt;, &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt;.</source>
          <target state="translated">Они связаны со временем жизни всего процесса git. например: &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt; , &lt;code&gt;void trace2_initialize()&lt;/code&gt; , &lt;code&gt;int trace2_is_enabled()&lt;/code&gt; , &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dce3473c941e3b3b27a31ac8449a2f1991a75d0" translate="yes" xml:space="preserve">
          <source>These are concerned with the various spawned child processes, including shell scripts, git commands, editors, pagers, and hooks.</source>
          <target state="translated">Они связаны с различными порождёнными детскими процессами,включая сценарии оболочки,команды git'а,редакторы,пейджеры и крючки.</target>
        </trans-unit>
        <trans-unit id="64d6caf87f558c78a882445d71ea9cd47be32d78" translate="yes" xml:space="preserve">
          <source>These are internal helper commands used by other commands; end users typically do not use them directly.</source>
          <target state="translated">Это внутренние вспомогательные команды,используемые другими командами;конечные пользователи обычно не используют их напрямую.</target>
        </trans-unit>
        <trans-unit id="14e40973cf60a547a4fee511ff95c4f84a31a06f" translate="yes" xml:space="preserve">
          <source>These are only used with the &lt;code&gt;dcommit&lt;/code&gt; and &lt;code&gt;rebase&lt;/code&gt; commands.</source>
          <target state="translated">Они используются только с &lt;code&gt;dcommit&lt;/code&gt; и &lt;code&gt;rebase&lt;/code&gt; команд.</target>
        </trans-unit>
        <trans-unit id="1f4226446a769c76931ca392e2a09f31777b3654" translate="yes" xml:space="preserve">
          <source>These are optional command-line options for init. Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags). You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths. The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence.</source>
          <target state="translated">Это дополнительные опции командной строки для init.Каждый из этих флагов может указывать на относительный путь к хранилищу (--tags=project/tags)или полный url (--tags=https://foo.org/project/tags).Вы можете указать более одного параметра --tags и/или --branches в случае,если ваше хранилище Subversion помещает метки или ветки по нескольким путям.Опция --stdlayout-это короткий способ установки ствола,тегов,ответвлений в качестве относительных путей,который по умолчанию используется в Subversion.Если заданы и другие опции,то они имеют приоритет.</target>
        </trans-unit>
        <trans-unit id="ef89fe03d8c6b725e4e01a5ddca75169500d3912" translate="yes" xml:space="preserve">
          <source>These attributes affect how the contents stored in the repository are copied to the working tree files when commands such as &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; run. They also affect how Git stores the contents you prepare in the working tree in the repository upon &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">Эти атрибуты влияют на то, как содержимое, хранящееся в репозитории, копируется в файлы рабочего дерева при выполнении таких команд, как &lt;code&gt;git switch&lt;/code&gt; , &lt;code&gt;git checkout&lt;/code&gt; и &lt;code&gt;git merge&lt;/code&gt; . Они также влияют на то, как Git хранит подготовленное вами содержимое в рабочем дереве в репозитории после &lt;code&gt;git add&lt;/code&gt; и &lt;code&gt;git commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e36f59cc4fba5296689c97860f8ef3c808cbf54" translate="yes" xml:space="preserve">
          <source>These can be easily kept up to date using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">Их можно легко обновлять с помощью &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
