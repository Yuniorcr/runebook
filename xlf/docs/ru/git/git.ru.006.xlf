<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="ae19e2f586d76eb404950c906a0e28fc48bd4144" translate="yes" xml:space="preserve">
          <source>If the target branch in refs/remotes/p4-unshelved already exists, the old one will be renamed.</source>
          <target state="translated">Если целевая ветка в refs/remotes/p4-unshelved уже существует,то старая будет переименована.</target>
        </trans-unit>
        <trans-unit id="2f7883dbe6de00b83ac31c035cb47ace7f18b215" translate="yes" xml:space="preserve">
          <source>If the timestamp order of different files cross the revision order within the commit matching time window the order of commits may be wrong.</source>
          <target state="translated">Если порядок следования меток времени различных файлов пересекает порядок ревизий в пределах временного окна фиксации,то порядок фиксаций может быть неправильным.</target>
        </trans-unit>
        <trans-unit id="9e02bc5f839968fa2bd55c9715c548322d410f70" translate="yes" xml:space="preserve">
          <source>If the update is done via merge, the submodule conflicts are resolved and checked out.</source>
          <target state="translated">Если обновление выполняется через слияние,то конфликты подмодулей разрешаются и проверяются.</target>
        </trans-unit>
        <trans-unit id="e429444552f2f76afd93b7eab781098fd53d76ab" translate="yes" xml:space="preserve">
          <source>If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped. For example, running &lt;code&gt;git rebase master&lt;/code&gt; on the following history (in which &lt;code&gt;A'&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; introduce the same set of changes, but have different committer information):</source>
          <target state="translated">Если восходящая ветвь уже содержит внесенное вами изменение (например, потому что вы отправили по почте патч, который был применен в восходящем направлении), то эта фиксация будет пропущена. Например, запуск &lt;code&gt;git rebase master&lt;/code&gt; для следующей истории (в которой &lt;code&gt;A'&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; вводят один и тот же набор изменений, но имеют разную информацию о коммиттере):</target>
        </trans-unit>
        <trans-unit id="8dd2ebfbc7db6f2a970a9204f7e4fecacb05b440" translate="yes" xml:space="preserve">
          <source>If the user is driving it, then at each step of the search, the user will have to test the current commit and say if it is &quot;good&quot; or &quot;bad&quot; using the &quot;git bisect good&quot; or &quot;git bisect bad&quot; commands respectively that have been described above. For example:</source>
          <target state="translated">Если пользователь управляет коммитом,то на каждом шаге поиска он должен будет проверять текущий коммит и говорить,&quot;хороший&quot; или &quot;плохой&quot;,используя команды &quot;git bisect good&quot; или &quot;git bisect bad&quot; соответственно,которые были описаны выше.Например:</target>
        </trans-unit>
        <trans-unit id="6929af54c2109d01f0c27eda6b64b41906b00393" translate="yes" xml:space="preserve">
          <source>If the user provides a --tag-name-filter that maps multiple tags to the same name, no warning or error is provided; git-filter-branch simply overwrites each tag in some undocumented pre-defined order resulting in only one tag at the end. (A git-filter-branch regression test requires this surprising behavior.)</source>
          <target state="translated">Если пользователь предоставляет --tag-name-фильтр,который сопоставляет несколько тегов с одним и тем же именем,предупреждение или ошибка не выдаётся;git-фильтр просто перезаписывает каждый тег в некотором недокументированном предопределённом порядке,в результате чего в конце получается только один тег.(git-filter-branch регрессионный тест требует такого удивительного поведения).</target>
        </trans-unit>
        <trans-unit id="115afcefe8deea6713a6376b9b3612622ce5ff41" translate="yes" xml:space="preserve">
          <source>If the user running &lt;code&gt;git p4 submit&lt;/code&gt; does not exist in the p4 user map, &lt;code&gt;git p4&lt;/code&gt; exits. This option can be used to force submission regardless.</source>
          <target state="translated">Если пользователь, запустивший &lt;code&gt;git p4 submit&lt;/code&gt; , не существует в пользовательской карте &lt;code&gt;git p4&lt;/code&gt; , git p4 завершает работу. Этот параметр можно использовать для принудительной отправки в любом случае.</target>
        </trans-unit>
        <trans-unit id="4ce7fbc3c51757d8b6052ea0a42e4807120e305f" translate="yes" xml:space="preserve">
          <source>If the value is boolean, turns on or off pagination of the output of a particular Git subcommand when writing to a tty. Otherwise, turns on pagination for the subcommand using the pager specified by the value of &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt;. If &lt;code&gt;--paginate&lt;/code&gt; or &lt;code&gt;--no-pager&lt;/code&gt; is specified on the command line, it takes precedence over this option. To disable pagination for all commands, set &lt;code&gt;core.pager&lt;/code&gt; or &lt;code&gt;GIT_PAGER&lt;/code&gt; to &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">Если значение является логическим, включает или отключает разбиение на страницы вывода конкретной подкоманды Git при записи на tty. В противном случае включает разбивку на страницы для подкоманды с использованием пейджера, указанного значением &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt; . Если в командной строке указано &lt;code&gt;--paginate&lt;/code&gt; или --no &lt;code&gt;--no-pager&lt;/code&gt; , он имеет приоритет над этой опцией. Чтобы отключить разбиение на страницы для всех команд, установите &lt;code&gt;core.pager&lt;/code&gt; или &lt;code&gt;GIT_PAGER&lt;/code&gt; на &lt;code&gt;cat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d03e93ea222dab8f641cb8201b06b8ce56eb4397" translate="yes" xml:space="preserve">
          <source>If the variable is set to an integer value greater than 2 and lower than 10 (strictly) then Git will interpret this value as an open file descriptor and will try to write the trace messages into this file descriptor.</source>
          <target state="translated">Если переменная установлена в целое значение больше 2 и меньше 10 (строго),то Git будет интерпретировать это значение как открытый файловый дескриптор и попытается записать сообщения трассировки в этот файловый дескриптор.</target>
        </trans-unit>
        <trans-unit id="68e78b3aa184c7970e4ea72bcfa1c35c1841182d" translate="yes" xml:space="preserve">
          <source>If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:</source>
          <target state="translated">Если существует большое количество одноимённых удалённых репозиториев и вы хотите использовать для них другой формат (такой,что используемые вами URL будут переписаны в URL,которые работают),вы можете создать конфигурационный раздел формы:</target>
        </trans-unit>
        <trans-unit id="1add756b76a7c17e78b77f722a60e35881bd1c18" translate="yes" xml:space="preserve">
          <source>If there are conflicts, the user should edit the result and delete one of the alternatives. When &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, or &lt;code&gt;--union&lt;/code&gt; option is in effect, however, these conflicts are resolved favouring lines from &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt;, lines from &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt;, or lines from both respectively. The length of the conflict markers can be given with the &lt;code&gt;--marker-size&lt;/code&gt; option.</source>
          <target state="translated">Если есть конфликты, пользователь должен отредактировать результат и удалить одну из альтернатив. Когда &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; или &lt;code&gt;--union&lt;/code&gt; вариант в действительности, однако, эти конфликты решаются в пользу линии от &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; , строки из &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; или строки из обоих соответственно. Длину маркеров конфликта можно &lt;code&gt;--marker-size&lt;/code&gt; с помощью опции --marker-size .</target>
        </trans-unit>
        <trans-unit id="86762a48683c371a4cc7c3de1cb012419562ae87" translate="yes" xml:space="preserve">
          <source>If there are multiple branches, doing &lt;code&gt;git p4 sync&lt;/code&gt; will automatically use the &quot;BRANCH DETECTION&quot; algorithm to try to partition new changes into the right branch. This can be overridden with the &lt;code&gt;--branch&lt;/code&gt; option to specify just a single branch to update.</source>
          <target state="translated">Если есть несколько ветвей, выполнение &lt;code&gt;git p4 sync&lt;/code&gt; будет автоматически использовать алгоритм &amp;laquo;ОБНАРУЖЕНИЕ ВЕТВИ&amp;raquo;, чтобы попытаться разделить новые изменения на правую ветвь. Это можно &lt;code&gt;--branch&lt;/code&gt; с помощью параметра --branch, указав только одну ветвь для обновления.</target>
        </trans-unit>
        <trans-unit id="618accc0d1d550b6b8ec069f55b5b09af649e985" translate="yes" xml:space="preserve">
          <source>If there are multiple instances of the &lt;code&gt;credential.helper&lt;/code&gt; configuration variable, each helper will be tried in turn, and may provide a username, password, or nothing. Once Git has acquired both a username and a password, no more helpers will be tried.</source>
          <target state="translated">Если существует несколько экземпляров переменной конфигурации &lt;code&gt;credential.helper&lt;/code&gt; , каждый помощник будет опробован по очереди и может предоставить имя пользователя, пароль или ничего. Как только Git получит и имя пользователя, и пароль, больше никаких помощников не будет.</target>
        </trans-unit>
        <trans-unit id="af9d46d5bd3ac828de63ddb9d4effe59327aaa5a" translate="yes" xml:space="preserve">
          <source>If there are other repositories that you also use frequently, you can create similar configuration options to save typing; for example,</source>
          <target state="translated">Если есть другие репозитории,которые вы также часто используете,вы можете создать аналогичные опции конфигурации,чтобы сохранить набор текста;например,</target>
        </trans-unit>
        <trans-unit id="591918eb06b2723ac86bd0a089445e6e294cf8c5" translate="yes" xml:space="preserve">
          <source>If there exist packfiles in the pack directory not registered in the MIDX, then those packfiles are loaded into the &lt;code&gt;packed_git&lt;/code&gt; list and &lt;code&gt;packed_git_mru&lt;/code&gt; cache.</source>
          <target state="translated">Если существует packfiles в каталоге пакета не зарегистрирован в MIDX, то эта packfiles загружается в &lt;code&gt;packed_git&lt;/code&gt; список и &lt;code&gt;packed_git_mru&lt;/code&gt; кэш.</target>
        </trans-unit>
        <trans-unit id="03e18f44da1b610f354ea9baeb478307ccf925f8" translate="yes" xml:space="preserve">
          <source>If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular &lt;code&gt;.gitignore&lt;/code&gt; file itself. Otherwise the pattern may also match at any level below the &lt;code&gt;.gitignore&lt;/code&gt; level.</source>
          <target state="translated">Если есть разделитель в начале или в середине (или в обоих) шаблона, то шаблон относится к уровню каталога конкретного файла &lt;code&gt;.gitignore&lt;/code&gt; . В противном случае шаблон также может совпадать на любом уровне ниже уровня &lt;code&gt;.gitignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c5dbd4863767291eb0584c1211aa56213f1838" translate="yes" xml:space="preserve">
          <source>If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories.</source>
          <target state="translated">Если в конце детали есть разделитель,то деталь будет совпадать только с каталогами,в противном случае она может совпадать и с файлами,и с каталогами.</target>
        </trans-unit>
        <trans-unit id="7e5e3b6d9186f0b0d9ca9ea83f70b7fee637fea2" translate="yes" xml:space="preserve">
          <source>If there is a separator, then the key will be used instead of both the &amp;lt;token&amp;gt; and the default separator when adding the trailer.</source>
          <target state="translated">Если есть разделитель, то при добавлении трейлера будет использоваться ключ вместо &amp;lt;token&amp;gt; и разделителя по умолчанию.</target>
        </trans-unit>
        <trans-unit id="110096af5aaaf08aca8aad30cdfe6c3abec7eaf2" translate="yes" xml:space="preserve">
          <source>If there is no file or subtree at that path, &lt;code&gt;git fast-import&lt;/code&gt; will instead report</source>
          <target state="translated">Если на этом пути нет файла или поддерева, &lt;code&gt;git fast-import&lt;/code&gt; вместо этого сообщит</target>
        </trans-unit>
        <trans-unit id="1db0218c6ea3cc08d2d45a6158a3df08d714812b" translate="yes" xml:space="preserve">
          <source>If there is no parameter given by the user, use &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если пользователь не задан параметром, используйте вместо него &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08079a827cded7daddc3f36e473048d3482101ec" translate="yes" xml:space="preserve">
          <source>If there is only one &amp;lt;tree-ish&amp;gt; given, the commit is compared with its parents (see --stdin below).</source>
          <target state="translated">Если указан только один &amp;lt;tree-ish&amp;gt;, коммит сравнивается с его родительскими (см. --Stdin ниже).</target>
        </trans-unit>
        <trans-unit id="f3b2c7580e6489ea5e91cbe02a9f524e00ba7a5a" translate="yes" xml:space="preserve">
          <source>If there were more commits on the &lt;em&gt;master&lt;/em&gt; branch after the merge, the merge commit itself would not be shown by &lt;em&gt;git show-branch&lt;/em&gt; by default. You would need to provide &lt;code&gt;--sparse&lt;/code&gt; option to make the merge commit visible in this case.</source>
          <target state="translated">Если бы после слияния в &lt;em&gt;главной&lt;/em&gt; ветке было больше коммитов, по умолчанию &lt;em&gt;git show-branch&lt;/em&gt; не показывал бы сам коммит слияния . В этом случае вам нужно будет предоставить параметр &lt;code&gt;--sparse&lt;/code&gt; , чтобы сделать фиксацию слияния видимой.</target>
        </trans-unit>
        <trans-unit id="0ab64f384f8b476963c3f64ac176ef68ee6de9f2" translate="yes" xml:space="preserve">
          <source>If there were uncommitted worktree changes present when the merge started, &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">Если при запуске слияния присутствовали незафиксированные изменения рабочего дерева, &lt;code&gt;git merge --abort&lt;/code&gt; в некоторых случаях не сможет восстановить эти изменения. Поэтому рекомендуется всегда фиксировать или хранить ваши изменения перед запуском &lt;code&gt;git merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="967d5740c3c32e83504fdb7318f7465d81e3c6cb" translate="yes" xml:space="preserve">
          <source>If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the &quot;rest&quot; of the line) are output in place of the &lt;code&gt;%(rest)&lt;/code&gt; atom.</source>
          <target state="translated">Если этот атом используется в выходной строке, входные строки разделяются по первой границе пробела. Все символы перед этим пробелом считаются именем объекта; символы после этого первого пробела (т.е. &amp;laquo;остальная часть&amp;raquo; строки) выводятся вместо атома &lt;code&gt;%(rest)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b6208e01f164e5f8b5cfeffb592a9b059f78c4e" translate="yes" xml:space="preserve">
          <source>If this attribute is not set or has an invalid value, the value of the &lt;code&gt;gui.encoding&lt;/code&gt; configuration variable is used instead (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Если этот атрибут не установлен или имеет недопустимое значение, вместо него используется значение переменной конфигурации &lt;code&gt;gui.encoding&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d21856ae35021bd75d04c1b344656e77c3e714d8" translate="yes" xml:space="preserve">
          <source>If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the &amp;lsquo;GIT_EXTERNAL_DIFF&amp;rsquo; environment variable. The command is called with parameters as described under &quot;git Diffs&quot; in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. Note: if you want to use an external diff program only on a subset of your files, you might want to use &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; instead.</source>
          <target state="translated">Если эта переменная конфигурации установлена, генерация различий выполняется не с использованием внутреннего механизма сравнения, а с использованием данной команды. Может быть переопределено переменной окружения GIT_EXTERNAL_DIFF. Команда вызывается с параметрами, как описано в разделе &amp;laquo;git Diffs&amp;raquo; в &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; . Примечание: если вы хотите использовать внешнюю программу сравнения только с подмножеством ваших файлов, вы можете вместо этого использовать &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c67dbd9b5b9d0c250d594cf0e82ea55d38dac133" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &quot;1&quot;, then commands such as &lt;code&gt;git blame&lt;/code&gt; (in incremental mode), &lt;code&gt;git rev-list&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git check-attr&lt;/code&gt; and &lt;code&gt;git check-ignore&lt;/code&gt; will force a flush of the output stream after each record have been flushed. If this variable is set to &quot;0&quot;, the output of these commands will be done using completely buffered I/O. If this environment variable is not set, Git will choose buffered or record-oriented flushing based on whether stdout appears to be redirected to a file or not.</source>
          <target state="translated">Если для этой переменной среды установлено значение &amp;laquo;1&amp;raquo;, то такие команды, как &lt;code&gt;git blame&lt;/code&gt; (в инкрементном режиме), &lt;code&gt;git rev-list&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git check-attr&lt;/code&gt; и &lt;code&gt;git check-ignore&lt;/code&gt; , будут принудительно очищать выходной поток после каждого запись была сброшена. Если для этой переменной установлено значение &amp;laquo;0&amp;raquo;, вывод этих команд будет осуществляться с использованием полностью буферизованного ввода-вывода. Если эта переменная среды не задана, Git выберет буферизованную или ориентированную на запись очистку в зависимости от того, перенаправляется ли стандартный вывод в файл или нет.</target>
        </trans-unit>
        <trans-unit id="3c510f35b5c52541d7f8ff48371ed312cadc959c" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &lt;code&gt;0&lt;/code&gt;, git will not prompt on the terminal (e.g., when asking for HTTP authentication).</source>
          <target state="translated">Если для этой переменной среды установлено значение &lt;code&gt;0&lt;/code&gt; , git не будет запрашивать на терминале (например, при запросе HTTP-аутентификации).</target>
        </trans-unit>
        <trans-unit id="f0e0816f1f387058c1f2d75f7ff32a01f9295472" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, it overrides Git&amp;rsquo;s autodetection whether &lt;code&gt;GIT_SSH&lt;/code&gt;/&lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt;/&lt;code&gt;core.sshCommand&lt;/code&gt; refer to OpenSSH, plink or tortoiseplink. This variable overrides the config setting &lt;code&gt;ssh.variant&lt;/code&gt; that serves the same purpose.</source>
          <target state="translated">Если эта переменная среды установлена, она переопределяет автоматическое определение Git, относится ли &lt;code&gt;GIT_SSH&lt;/code&gt; / &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; / &lt;code&gt;core.sshCommand&lt;/code&gt; к OpenSSH, plink или tortoiseplink. Эта переменная переопределяет настройку конфигурации &lt;code&gt;ssh.variant&lt;/code&gt; , которая служит той же цели.</target>
        </trans-unit>
        <trans-unit id="81f782a4dbe0e346a4da365c1a6b3a9cbeb4a6e2" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, then Git commands which need to acquire passwords or passphrases (e.g. for HTTP or IMAP authentication) will call this program with a suitable prompt as command-line argument and read the password from its STDOUT. See also the &lt;code&gt;core.askPass&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Если эта переменная среды установлена, то команды Git, которым необходимо получить пароли или парольные фразы (например, для аутентификации HTTP или IMAP), будут вызывать эту программу с подходящей подсказкой в ​​качестве аргумента командной строки и считывать пароль из ее STDOUT. См. Также параметр &lt;code&gt;core.askPass&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="372352ecb2d8c55afffa99890c0eb497f2b1382d" translate="yes" xml:space="preserve">
          <source>If this feature is enabled, gitweb considers projects in subdirectories of project root (basename) to be forks of existing projects. For each project &lt;code&gt;$projname.git&lt;/code&gt;, projects in the &lt;code&gt;$projname/&lt;/code&gt; directory and its subdirectories will not be shown in the main projects list. Instead, a '+' mark is shown next to &lt;code&gt;$projname&lt;/code&gt;, which links to a &quot;forks&quot; view that lists all the forks (all projects in &lt;code&gt;$projname/&lt;/code&gt; subdirectory). Additionally a &quot;forks&quot; view for a project is linked from project summary page.</source>
          <target state="translated">Если эта функция включена, gitweb считает проекты в подкаталогах корневого каталога проекта (базовое имя) ветвями существующих проектов. Для каждого проекта &lt;code&gt;$projname.git&lt;/code&gt; проекты в &lt;code&gt;$projname/&lt;/code&gt; и его подкаталогах не будут отображаться в основном списке проектов. Вместо этого рядом с &lt;code&gt;$projname&lt;/code&gt; отображается знак &amp;laquo;+&amp;raquo; , который ссылается на представление &amp;laquo;вилок&amp;raquo;, в котором перечислены все вилки (все проекты в подкаталоге &lt;code&gt;$projname/&lt;/code&gt; ). Кроме того, на странице сводки проекта есть ссылка на представление &amp;laquo;вилок&amp;raquo; для проекта.</target>
        </trans-unit>
        <trans-unit id="728d51c620f0870eff1b0d62261ab6934369adf2" translate="yes" xml:space="preserve">
          <source>If this field has a true value then the given feature is overridable, which means that it can be configured (or enabled/disabled) on a per-repository basis.</source>
          <target state="translated">Если это поле имеет истинное значение,то данная функция является переопределяемой,что означает,что она может быть сконфигурирована (или включена/выключена)для каждого хранилища.</target>
        </trans-unit>
        <trans-unit id="582826e66f53339e6d7b4dc6a0d6a2edeb312487" translate="yes" xml:space="preserve">
          <source>If this file exists, $GIT_COMMON_DIR (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;) will be set to the path specified in this file if it is not explicitly set. If the specified path is relative, it is relative to $GIT_DIR. The repository with commondir is incomplete without the repository pointed by &quot;commondir&quot;.</source>
          <target state="translated">Если этот файл существует, $ GIT_COMMON_DIR (см. &lt;a href=&quot;git&quot;&gt;Git [1]&lt;/a&gt; ) будет установлен на путь, указанный в этом файле, если он не установлен явно. Если указанный путь относительный, он относительно $ GIT_DIR. Репозиторий с commondir будет неполным без репозитория, указанного с помощью commondir.</target>
        </trans-unit>
        <trans-unit id="1e44552a87aaa0e818702548719ba07ebc0f8696" translate="yes" xml:space="preserve">
          <source>If this file exists, the linked working tree may be on a portable device and not available. The presence of this file prevents &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; from being pruned either automatically or manually by &lt;code&gt;git worktree prune&lt;/code&gt;. The file may contain a string explaining why the repository is locked.</source>
          <target state="translated">Если этот файл существует, связанное рабочее дерево может быть на переносном устройстве и недоступно. Наличие этого файла предотвращает &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; автоматически или вручную с помощью &lt;code&gt;git worktree prune&lt;/code&gt; . Файл может содержать строку, объясняющую, почему репозиторий заблокирован.</target>
        </trans-unit>
        <trans-unit id="6849302064fdf0db00fe326dd1a92636c39a6d43" translate="yes" xml:space="preserve">
          <source>If this hook exits with a non-zero status, &lt;code&gt;git push&lt;/code&gt; will abort without pushing anything. Information about why the push is rejected may be sent to the user by writing to standard error.</source>
          <target state="translated">Если этот хук завершается с ненулевым статусом, &lt;code&gt;git push&lt;/code&gt; прерывается, ничего не нажимая. Информация о том, почему push отклонена, может быть отправлена ​​пользователю путем записи в стандартную ошибку.</target>
        </trans-unit>
        <trans-unit id="9e422a5c19027398b3db2e62a2dfa8c2a2031ac5" translate="yes" xml:space="preserve">
          <source>If this is reinitialization, the repository will be moved to the specified path.</source>
          <target state="translated">При повторной инициализации репозиторий будет перемещен по указанному пути.</target>
        </trans-unit>
        <trans-unit id="ae49e42c53a829e13a69befb7e448cbf7a3ab5aa" translate="yes" xml:space="preserve">
          <source>If this is set to code reference, it will be run once for each request. You can set parts of configuration that change per session this way. For example, one might use the following code in a gitweb configuration file</source>
          <target state="translated">Если установлено кодирование ссылки,то оно будет выполняться один раз для каждого запроса.Таким образом,вы можете установить части конфигурации,которые меняются за сессию.Например,в конфигурационном файле gitweb можно использовать следующий код</target>
        </trans-unit>
        <trans-unit id="2ecaf4f8ea5745cd5a451b94ab44dd28ff120dab" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show diffstat of the stash entry. Defaults to true. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">Если для него установлено значение true, команда &lt;code&gt;git stash show&lt;/code&gt; без параметра покажет diffstat записи тайника. По умолчанию true. См. Описание команды &lt;code&gt;show&lt;/code&gt; в &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee4998fa7e703962f55f3297f84fc3b952ae4a7f" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show the stash entry in patch form. Defaults to false. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">Если для него установлено значение true, команда &lt;code&gt;git stash show&lt;/code&gt; без параметра покажет запись тайника в форме патча. По умолчанию - false. См. Описание команды &lt;code&gt;show&lt;/code&gt; в &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e98f4c395c1b49b1de4c0111925dea856a6d079" translate="yes" xml:space="preserve">
          <source>If this is set, add emails found in Signed-off-by: or Cc: lines to the cc list. Default is the value of &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; configuration value; if that is unspecified, default to --signed-off-by-cc.</source>
          <target state="translated">Если это установлено, добавьте электронные письма, найденные в строках Signed-off-by: или Cc: в список cc. По умолчанию используется значение конфигурации &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; ; если это не указано, по умолчанию --signed-off-by-cc.</target>
        </trans-unit>
        <trans-unit id="6cf7f20765eaeb225b14832d24072d63179e161f" translate="yes" xml:space="preserve">
          <source>If this is set, do not add the From: address to the cc: list. Default is the value of &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; configuration value; if that is unspecified, default to --no-suppress-from.</source>
          <target state="translated">Если это установлено, не добавляйте адрес From: в список cc :. По умолчанию используется значение конфигурации &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; ; если это не указано, по умолчанию --no-suppress-from.</target>
        </trans-unit>
        <trans-unit id="048d4528d0951754849879e2b4b5802f6461c9fb" translate="yes" xml:space="preserve">
          <source>If this is set, each email will be sent as a reply to the previous email sent. If disabled with &quot;--no-chain-reply-to&quot;, all emails after the first will be sent as replies to the first email sent. When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; configuration variable can be used to enable it.</source>
          <target state="translated">Если это установлено, каждое электронное письмо будет отправляться как ответ на предыдущее отправленное письмо. Если отключено с помощью &amp;laquo;--no-chain-reply-to&amp;raquo;, все электронные письма после первого будут отправлены как ответы на первое отправленное письмо. При его использовании рекомендуется, чтобы первый предоставленный файл был обзором всей серии исправлений. По умолчанию отключено, но для его &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; можно использовать переменную конфигурации sendemail.chainReplyTo .</target>
        </trans-unit>
        <trans-unit id="b4073ff276c4f44294d676470e6aaaeb5a46458f" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of &lt;code&gt;sendemail.cccover&lt;/code&gt; configuration value; if that is unspecified, default to --no-cc-cover.</source>
          <target state="translated">Если это установлено, электронные письма, найденные в заголовках Cc: в первом патче серии (обычно сопроводительное письмо), добавляются в список cc для каждого набора адресов электронной почты. По умолчанию используется значение конфигурации &lt;code&gt;sendemail.cccover&lt;/code&gt; ; если это не указано, по умолчанию используется --no-cc-cover.</target>
        </trans-unit>
        <trans-unit id="c3505cfc9a16fb3a406321b32681f1c27b3f4828" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of &lt;code&gt;sendemail.tocover&lt;/code&gt; configuration value; if that is unspecified, default to --no-to-cover.</source>
          <target state="translated">Если это установлено, электронные письма, найденные в заголовках &amp;laquo;Кому:&amp;raquo; в первом патче серии (обычно сопроводительное письмо), добавляются в список &amp;laquo;Кому&amp;raquo; для каждого набора адресов электронной почты. По умолчанию используется значение конфигурации &lt;code&gt;sendemail.tocover&lt;/code&gt; ; если это не указано, по умолчанию используется --no-to-cover.</target>
        </trans-unit>
        <trans-unit id="bd074611e2ce23fe3651c7c21615bc5d5c90b653" translate="yes" xml:space="preserve">
          <source>If this is set, the In-Reply-To and References headers will be added to each email sent. Whether each mail refers to the previous email (&lt;code&gt;deep&lt;/code&gt; threading per &lt;code&gt;git format-patch&lt;/code&gt; wording) or to the first email (&lt;code&gt;shallow&lt;/code&gt; threading) is governed by &quot;--[no-]chain-reply-to&quot;.</source>
          <target state="translated">Если это установлено, заголовки In-Reply-To и References будут добавляться к каждому отправляемому электронному письму. Относится ли каждое письмо к предыдущему электронному письму ( &lt;code&gt;deep&lt;/code&gt; цепочка в соответствии с формулировкой &lt;code&gt;git format-patch&lt;/code&gt; ) или к первому электронному письму ( &lt;code&gt;shallow&lt;/code&gt; цепочка ответов) регулируется &amp;laquo;- [no-] chain-reply-to&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="83fefd231faf2237df4d2ca57ddb91f5733dd174" translate="yes" xml:space="preserve">
          <source>If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules.</source>
          <target state="translated">Если эта опция присутствует и в записи субмодулей в .git/config суперпроекта,то настройка там переопределит найденную в .gitmodules.</target>
        </trans-unit>
        <trans-unit id="b576cec09f399abde10801d9e3b482a3974a7942" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support partial clone and partial fetch object filtering.</source>
          <target state="translated">Если этот параметр установлен, &lt;code&gt;upload-pack&lt;/code&gt; будет поддерживать фильтрацию объектов частичного клонирования и частичной выборки.</target>
        </trans-unit>
        <trans-unit id="46df2747ed059ec465747bf23f6d93b6698f2ce3" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support the &lt;code&gt;ref-in-want&lt;/code&gt; feature of the protocol version 2 &lt;code&gt;fetch&lt;/code&gt; command. This feature is intended for the benefit of load-balanced servers which may not have the same view of what OIDs their refs point to due to replication delay.</source>
          <target state="translated">Если этот параметр установлен, &lt;code&gt;upload-pack&lt;/code&gt; будет поддерживать функцию &lt;code&gt;ref-in-want&lt;/code&gt; команды &lt;code&gt;fetch&lt;/code&gt; версии 2 протокола . Эта функция предназначена для серверов с балансировкой нагрузки, которые могут не иметь одинакового представления о том, на какие OID указывают их ссылки из-за задержки репликации.</target>
        </trans-unit>
        <trans-unit id="3691063a71adef86ec77db2886b5e8b672228551" translate="yes" xml:space="preserve">
          <source>If this option is set, when &lt;code&gt;upload-pack&lt;/code&gt; would run &lt;code&gt;git pack-objects&lt;/code&gt; to create a packfile for a client, it will run this shell command instead. The &lt;code&gt;pack-objects&lt;/code&gt; command and arguments it &lt;code&gt;would&lt;/code&gt; have run (including the &lt;code&gt;git pack-objects&lt;/code&gt; at the beginning) are appended to the shell command. The stdin and stdout of the hook are treated as if &lt;code&gt;pack-objects&lt;/code&gt; itself was run. I.e., &lt;code&gt;upload-pack&lt;/code&gt; will feed input intended for &lt;code&gt;pack-objects&lt;/code&gt; to the hook, and expects a completed packfile on stdout.</source>
          <target state="translated">Если этот параметр установлен, когда &lt;code&gt;upload-pack&lt;/code&gt; будет запускать &lt;code&gt;git pack-objects&lt;/code&gt; для создания файла пакета для клиента, вместо этого будет выполнена эта команда оболочки. Команда &lt;code&gt;pack-objects&lt;/code&gt; и аргументы, которые она &lt;code&gt;would&lt;/code&gt; была запустить (включая &lt;code&gt;git pack-objects&lt;/code&gt; в начале), добавляются к команде оболочки. Stdin и stdout хука обрабатываются так, как если бы был запущен сам &lt;code&gt;pack-objects&lt;/code&gt; . Т.е., &lt;code&gt;upload-pack&lt;/code&gt; будет передавать обработчику ввод, предназначенный для &lt;code&gt;pack-objects&lt;/code&gt; , и ожидает завершенный packfile на stdout.</target>
        </trans-unit>
        <trans-unit id="043d313af4e6bae8eb0dfe37d6ed595c4f6e4603" translate="yes" xml:space="preserve">
          <source>If this option is specified and &lt;code&gt;git svn&lt;/code&gt; encounters an SVN committer name that does not exist in the authors-file, &lt;code&gt;git svn&lt;/code&gt; will abort operation. The user will then have to add the appropriate entry. Re-running the previous &lt;code&gt;git svn&lt;/code&gt; command after the authors-file is modified should continue operation.</source>
          <target state="translated">Если эта опция указана и &lt;code&gt;git svn&lt;/code&gt; встречает имя коммиттера SVN, которого нет в файле авторов, &lt;code&gt;git svn&lt;/code&gt; прервет операцию. Затем пользователю нужно будет добавить соответствующую запись. Повторный запуск предыдущей команды &lt;code&gt;git svn&lt;/code&gt; после изменения файла авторов должен продолжить работу.</target>
        </trans-unit>
        <trans-unit id="68c99ad12996bd9192637a1c1520fb2b24def75b" translate="yes" xml:space="preserve">
          <source>If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument. The program is expected to return a single line of the form &quot;Name &amp;lt;email&amp;gt;&quot; or &quot;Name &amp;lt;&amp;gt;&quot;, which will be treated as if included in the authors file.</source>
          <target state="translated">Если указана эта опция, для каждого имени коммиттера SVN, которого нет в файле авторов, данный файл выполняется с именем коммиттера в качестве первого аргумента. Ожидается, что программа вернет одну строку в форме &amp;laquo;Имя &amp;lt;электронная почта&amp;gt;&amp;raquo; или &amp;laquo;Имя &amp;lt;&amp;gt;&amp;raquo;, которая будет обрабатываться так, как если бы она была включена в файл авторов.</target>
        </trans-unit>
        <trans-unit id="9706c1068d7b5bd67656b65aa296c50f3e651323" translate="yes" xml:space="preserve">
          <source>If this variable is not specified, it defaults to &lt;code&gt;normal&lt;/code&gt;. This variable can be overridden with the -u|--untracked-files option of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">Если эта переменная не указана, по умолчанию используется &lt;code&gt;normal&lt;/code&gt; . Эту переменную можно переопределить с помощью параметра -u | --untracked-files команд &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; и &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b0cae3fed40383cf5d614f1da46a2c524e4930e" translate="yes" xml:space="preserve">
          <source>If this variable is set to &quot;1&quot;, &quot;2&quot; or &quot;true&quot; (comparison is case insensitive), trace messages will be printed to stderr.</source>
          <target state="translated">Если эта переменная установлена в &quot;1&quot;,&quot;2&quot; или &quot;true&quot; (сравнение не чувствительно к регистру),то сообщения о трассировке будут распечатываться в stderr.</target>
        </trans-unit>
        <trans-unit id="c1357386502b4e540a41766c550326b57fc0ea56" translate="yes" xml:space="preserve">
          <source>If this variable is set to a path, non-worktree files that are normally in $GIT_DIR will be taken from this path instead. Worktree-specific files such as HEAD or index are taken from $GIT_DIR. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; and &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; for details. This variable has lower precedence than other path variables such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY&amp;hellip;​</source>
          <target state="translated">Если для этой переменной задан путь, файлы, не относящиеся к рабочему дереву, которые обычно находятся в $ GIT_DIR, будут взяты из этого пути. Файлы, относящиеся к рабочему дереву, такие как HEAD или index, берутся из $ GIT_DIR. См. Подробности в &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; и &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]&lt;/a&gt; . Эта переменная имеет более низкий приоритет, чем другие переменные пути, такие как GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="8249d2ab5516fac15cd6ed908f0ba3c1a12338b5" translate="yes" xml:space="preserve">
          <source>If this variable is set, &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command is in the same form as the &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; environment variable and is overridden when the environment variable is set.</source>
          <target state="translated">Если эта переменная установлена, &lt;code&gt;git fetch&lt;/code&gt; и &lt;code&gt;git push&lt;/code&gt; будут использовать указанную команду вместо &lt;code&gt;ssh&lt;/code&gt; , когда им нужно подключиться к удаленной системе. Команда имеет ту же форму, что и переменная среды &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; , и переопределяется при установке переменной среды.</target>
        </trans-unit>
        <trans-unit id="3af55b279f11e2f816fa42fab0cbda45b206e1ef" translate="yes" xml:space="preserve">
          <source>If timestamps of commits in the CVS repository are not stable enough to be used for ordering commits changes may show up in the wrong order.</source>
          <target state="translated">Если временные метки коммитов в CVS репозитории недостаточно стабильны для того,чтобы их можно было использовать для заказа изменений коммитов,то они могут отображаться в неправильном порядке.</target>
        </trans-unit>
        <trans-unit id="51615abc07df5f5fedb19397be1e475bae29e04c" translate="yes" xml:space="preserve">
          <source>If true (default), a single editor instance will be spawned to edit files you have to edit (patches when &lt;code&gt;--annotate&lt;/code&gt; is used, and the summary when &lt;code&gt;--compose&lt;/code&gt; is used). If false, files will be edited one after the other, spawning a new editor each time.</source>
          <target state="translated">Если true (по умолчанию), будет создан один экземпляр редактора для редактирования файлов, которые вы должны редактировать (патчи, когда используется &lt;code&gt;--annotate&lt;/code&gt; , и сводка, когда используется &lt;code&gt;--compose&lt;/code&gt; ). Если false, файлы будут редактироваться один за другим, каждый раз создавая новый редактор.</target>
        </trans-unit>
        <trans-unit id="6c99dc0ffc12cab74a91d9cd9821ddfe241990c4" translate="yes" xml:space="preserve">
          <source>If true prevents displaying information about repository owner.</source>
          <target state="translated">Если значение true предотвращает отображение информации о владельце репозитория.</target>
        </trans-unit>
        <trans-unit id="fad7b766b28596874c184072e4308f81cec3bb8e" translate="yes" xml:space="preserve">
          <source>If true the web server started by &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; will be bound to the local IP (127.0.0.1).</source>
          <target state="translated">Если true, веб-сервер, запущенный &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1],&lt;/a&gt; будет привязан к локальному IP (127.0.0.1).</target>
        </trans-unit>
        <trans-unit id="24fc21f99a5940a5b287a59503e7df044758b9be" translate="yes" xml:space="preserve">
          <source>If true this repository is assumed to be &lt;code&gt;bare&lt;/code&gt; and has no working directory associated with it. If this is the case a number of commands that require a working directory will be disabled, such as &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; or &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, этот репозиторий считается &lt;code&gt;bare&lt;/code&gt; и не имеет связанного с ним рабочего каталога. В этом случае ряд команд, которым требуется рабочий каталог, будут отключены, например, &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; или &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18d14681f32fdc08f62b0e7a189d6a89008757fd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;git gui blame&lt;/code&gt; uses &lt;code&gt;-C&lt;/code&gt; instead of &lt;code&gt;-C -C&lt;/code&gt; for original location detection. It makes blame significantly faster on huge repositories at the expense of less thorough copy detection.</source>
          <target state="translated">Если это правда, &lt;code&gt;git gui blame&lt;/code&gt; использует &lt;code&gt;-C&lt;/code&gt; вместо &lt;code&gt;-C -C&lt;/code&gt; для определения исходного местоположения. Это значительно ускоряет поиск виновных в огромных репозиториях за счет менее тщательного обнаружения копий.</target>
        </trans-unit>
        <trans-unit id="a4dc06197e1e60c2601c1eee394ecb56132cf3c4" translate="yes" xml:space="preserve">
          <source>If true, Git will avoid using lstat() calls to detect if files have changed by setting the &quot;assume-unchanged&quot; bit for those tracked files which it has updated identically in both the index and working tree.</source>
          <target state="translated">Если переменная имеет значение true,Git избежит использования вызовов lstat()для обнаружения изменений в файлах,установив бит &quot;assumee-unchanged&quot; для тех отслеживаемых файлов,которые он обновил идентично как в индексе,так и в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="f52d8aadd1ed60dd80b38e7a96aadc385cabb931" translate="yes" xml:space="preserve">
          <source>If true, Git will warn you if the ref name you passed it is ambiguous and might match multiple refs in the repository. True by default.</source>
          <target state="translated">Если переменная имеет значение true,Git предупредит вас,если имя ссылки,которую вы передали,неоднозначно и может совпадать с несколькими ссылками в репозитории.По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="b4f1cbcb9d6580097e1319f75786e1aefcc4a19a" translate="yes" xml:space="preserve">
          <source>If true, allow clients to use &lt;code&gt;git archive --remote&lt;/code&gt; to request any tree, whether reachable from the ref tips or not. See the discussion in the &quot;SECURITY&quot; section of &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for more details. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если true, разрешите клиентам использовать &lt;code&gt;git archive --remote&lt;/code&gt; для запроса любого дерева, независимо от того, доступно ли оно из подсказок или нет. См. Обсуждение в разделе &amp;laquo;БЕЗОПАСНОСТЬ&amp;raquo; в &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt; для получения более подробной информации. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9577d8134a35c2d555845d35ede1972ec309a7fc" translate="yes" xml:space="preserve">
          <source>If true, enable &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; for use by remote clients via &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt;. Defaults to false for user-defined formats, but true for the &quot;tar.gz&quot; and &quot;tgz&quot; formats.</source>
          <target state="translated">Если это правда, включите &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; для использования удаленными клиентами через &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt; . По умолчанию false для форматов, определяемых пользователем, но верно для форматов tar.gz и tgz.</target>
        </trans-unit>
        <trans-unit id="5f15956c2db32b4b1b45dac474661942b8aa7008" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, выборка будет автоматически вести себя так, как если бы в &lt;code&gt;--prune&lt;/code&gt; была указана опция --prune . См. Также &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; и раздел PRUNING в &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d985f4709f0d26edc0babef707e65f833d349aa" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec was provided when pruning, if not set already. This allows for setting both this option and &lt;code&gt;fetch.prune&lt;/code&gt; to maintain a 1=1 mapping to upstream refs. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, выборка будет автоматически вести себя так, как если бы &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec был предоставлен при сокращении, если он еще не установлен. Это позволяет установить как этот параметр, так и &lt;code&gt;fetch.prune&lt;/code&gt; , чтобы поддерживать отображение 1 = 1 для исходных ссылок . См. Также &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; и раздел PRUNING в &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2de6ae2b37da0c5dc299e33fe86fea1c6d9d4a0f" translate="yes" xml:space="preserve">
          <source>If true, git-am will call git-mailsplit for patches in mbox format with parameter &lt;code&gt;--keep-cr&lt;/code&gt;. In this case git-mailsplit will not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;. Can be overridden by giving &lt;code&gt;--no-keep-cr&lt;/code&gt; from the command line. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;, &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, git-am вызовет git-mailsplit для патчей в формате mbox с параметром &lt;code&gt;--keep-cr&lt;/code&gt; . В этом случае git-mailsplit не удалит &lt;code&gt;\r&lt;/code&gt; из строк, заканчивающихся на &lt;code&gt;\r\n&lt;/code&gt; . Можно изменить, указав &lt;code&gt;--no-keep-cr&lt;/code&gt; из командной строки. См. &lt;a href=&quot;git-am&quot;&gt;Git-am [1]&lt;/a&gt; , &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94bf962607289b1694c70432d3fab451c61737d" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--abbrev-commit&lt;/code&gt;. You may override this option with &lt;code&gt;--no-abbrev-commit&lt;/code&gt;.</source>
          <target state="translated">Если истинно, то &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; принимают значение &lt;code&gt;--abbrev-commit&lt;/code&gt; . Вы можете переопределить эту опцию с помощью &lt;code&gt;--no-abbrev-commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7c96ef3a79b38b8c56dee4db799ed4d172ce90c" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--show-signature&lt;/code&gt;.</source>
          <target state="translated">Если истина, то &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; предполагают &lt;code&gt;--show-signature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cb33eaf81fb27f3c3d3ba0e81d6670ba0d0bfaf" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--use-mailmap&lt;/code&gt;, otherwise assume &lt;code&gt;--no-use-mailmap&lt;/code&gt;. True by default.</source>
          <target state="translated">Если истинно, то &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; предполагают &lt;code&gt;--use-mailmap&lt;/code&gt; , иначе &lt;code&gt;--no-use-mailmap&lt;/code&gt; . По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="672cef13127670a717c7a3aa65681a15ad776d1b" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt; (and therefore &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;) act by default as if the --scissors option was provided on the command-line. When active, this features removes everything from the message body before a scissors line (i.e. consisting mainly of &quot;&amp;gt;8&quot;, &quot;8&amp;lt;&quot; and &quot;-&quot;).</source>
          <target state="translated">Если true, заставляет &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt; (и, следовательно, &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; ) действовать по умолчанию, как если бы в командной строке была указана опция --scissors. В активном состоянии эта функция удаляет все из тела сообщения до линии &amp;laquo;ножницы&amp;raquo; (т.е. состоящей в основном из &amp;laquo;&amp;gt; 8&amp;raquo;, &amp;laquo;8 &amp;lt;&amp;raquo; и &amp;laquo;-&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="d25b510a17b04a17cfbdc40d0999d1586f4d5f91" translate="yes" xml:space="preserve">
          <source>If true, makes Git check if converting &lt;code&gt;CRLF&lt;/code&gt; is reversible when end-of-line conversion is active. Git will verify if a command modifies a file in the work tree either directly or indirectly. For example, committing a file followed by checking out the same file should yield the original file in the work tree. If this is not the case for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;, Git will reject the file. The variable can be set to &quot;warn&quot;, in which case Git will only warn about an irreversible conversion but continue the operation.</source>
          <target state="translated">Если true, Git проверяет, является ли преобразование &lt;code&gt;CRLF&lt;/code&gt; обратимым, когда активно преобразование конца строки. Git проверит, изменяет ли команда файл в рабочем дереве прямо или косвенно. Например, фиксация файла с последующим извлечением того же файла должна привести к появлению исходного файла в дереве работы. Если это не так для текущей настройки &lt;code&gt;core.autocrlf&lt;/code&gt; , Git отклонит файл. Переменная может иметь значение &amp;laquo;предупреждать&amp;raquo;, и в этом случае Git будет предупреждать только о необратимом преобразовании, но продолжит операцию.</target>
        </trans-unit>
        <trans-unit id="3a6f979740fe111373346b7083b54b9e059af003" translate="yes" xml:space="preserve">
          <source>If true, omit the column with date of the most current commit on the projects list page. It can save a bit of I/O and a fork per repository.</source>
          <target state="translated">Если переменная имеет значение true,опустите колонку с датой последнего фиксации на странице списка проектов.Это может сохранить немного ввода/вывода и вилку для каждого репозитория.</target>
        </trans-unit>
        <trans-unit id="9e101a02df349b50a39b60288665a643391bcf24" translate="yes" xml:space="preserve">
          <source>If true, pushing to this remote will automatically behave as if the &lt;code&gt;--mirror&lt;/code&gt; option was given on the command line.</source>
          <target state="translated">Если true, нажатие на этот пульт будет автоматически вести себя так, как если бы в &lt;code&gt;--mirror&lt;/code&gt; была указана опция --mirror .</target>
        </trans-unit>
        <trans-unit id="561edb27b58ccdfdecb1aae75865de22935f3cd3" translate="yes" xml:space="preserve">
          <source>If true, some gitweb features are disabled to prevent content in repositories from launching cross-site scripting (XSS) attacks. Set this to true if you don&amp;rsquo;t trust the content of your repositories. False by default (set to 0).</source>
          <target state="translated">Если это правда, некоторые функции gitweb отключены, чтобы контент в репозиториях не запускал атаки межсайтового скриптинга (XSS). Установите значение true, если вы не доверяете содержимому своих репозиториев. По умолчанию false (установлено значение 0).</target>
        </trans-unit>
        <trans-unit id="698e5f4a0ab76eb97600c890fa9adac3c5e93fa4" translate="yes" xml:space="preserve">
          <source>If true, the initial commit will be shown as a big creation event. This is equivalent to a diff against an empty tree. Tools like &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; or &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;, which normally hide the root commit will now show it. True by default.</source>
          <target state="translated">Если true, начальная фиксация будет отображаться как большое событие создания. Это эквивалентно сравнению с пустым деревом. Такие инструменты, как &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; или &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; , которые обычно скрывают корневой коммит, теперь покажут его. По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="7f4771e5273a3a0e51423699c29e2caf790623f9" translate="yes" xml:space="preserve">
          <source>If true, the server will look up the end-of-line conversion attributes for files to determine the &lt;code&gt;-k&lt;/code&gt; modes to use. If the attributes force Git to treat a file as text, the &lt;code&gt;-k&lt;/code&gt; mode will be left blank so CVS clients will treat it as text. If they suppress text conversion, the file will be set with &lt;code&gt;-kb&lt;/code&gt; mode, which suppresses any newline munging the client might otherwise do. If the attributes do not allow the file type to be determined, then &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">Если это правда, сервер будет искать атрибуты преобразования конца строки для файлов, чтобы определить используемые режимы &lt;code&gt;-k&lt;/code&gt; . Если атрибуты заставляют Git обрабатывать файл как текст, режим &lt;code&gt;-k&lt;/code&gt; останется пустым, поэтому клиенты CVS будут рассматривать его как текст. Если они подавляют преобразование текста, для файла будет установлен режим &lt;code&gt;-kb&lt;/code&gt; , который подавляет любое изменение новой строки, которое клиент мог бы сделать иначе. Если атрибуты не позволяют определить тип файла, используется &lt;code&gt;gitcvs.allBinary&lt;/code&gt; . См. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36ac6e641c359be495ff334484c92173e0b7c3c8" translate="yes" xml:space="preserve">
          <source>If true, the split-index feature of the index will be used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">Если true, то будет использоваться функция индексации с разделением. См. &lt;a href=&quot;git-update-index&quot;&gt;Git-update-index [1]&lt;/a&gt; . По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="521397cd2bc3f328c7b75df2807813cd34103bfb" translate="yes" xml:space="preserve">
          <source>If true, then gc will rewrite the commit-graph file when &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; is run. When using &lt;code&gt;git gc --auto&lt;/code&gt; the commit-graph will be updated if housekeeping is required. Default is true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for details.</source>
          <target state="translated">Если true, то gc перепишет файл графика фиксации при запуске &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; . При использовании &lt;code&gt;git gc --auto&lt;/code&gt; график фиксации будет обновлен, если требуется обслуживание. По умолчанию верно. См. Подробности в &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="902fdcf00401d2e7de222ff42ce846a756cbb163" translate="yes" xml:space="preserve">
          <source>If true, then git will read the commit-graph file (if it exists) to parse the graph structure of commits. Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="translated">Если true, то git прочитает файл графика фиксации (если он существует), чтобы проанализировать структуру графика коммитов. По умолчанию true. См. &lt;a href=&quot;git-commit-graph&quot;&gt;Git-commit-graph [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="615bfb2827e0f7022b5822b60fa7f8c63365efe6" translate="yes" xml:space="preserve">
          <source>If true, this is equivalent to the --verify-signatures command line option. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">Если true, это эквивалентно параметру командной строки --verify-signatures. Подробнее см. &lt;a href=&quot;git-merge&quot;&gt;Git-merge [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ab6fd64e80cf040c0dbc59c3bda45e3cb1c29b3" translate="yes" xml:space="preserve">
          <source>If true, this remote will be skipped by default when updating using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or the &lt;code&gt;update&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, этот пульт будет пропущен по умолчанию при обновлении с помощью &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; или подкоманды &lt;code&gt;update&lt;/code&gt; &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="537153cdd9a230b7ef7748cee5c002a80aec5646" translate="yes" xml:space="preserve">
          <source>If we compute the following non optimal function on it:</source>
          <target state="translated">Если мы вычислим следующую неоптимальную функцию:</target>
        </trans-unit>
        <trans-unit id="b2bbf437e467ca2cfec5d122277b398062cce56a" translate="yes" xml:space="preserve">
          <source>If we examined all this history together in one repository, it will look like:</source>
          <target state="translated">Если мы рассмотрим всю эту историю вместе в одном репозитории,она будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="f77fa3523026c17c64002e6f77dd7e18ad8c7cf7" translate="yes" xml:space="preserve">
          <source>If we have moved away from commit &lt;code&gt;f&lt;/code&gt;, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which &lt;code&gt;HEAD&lt;/code&gt; referred, we can use either of these commands:</source>
          <target state="translated">Если мы отошли от коммита &lt;code&gt;f&lt;/code&gt; , мы должны сначала восстановить его имя объекта (обычно с помощью git reflog), а затем мы можем создать ссылку на него. Например, чтобы увидеть последние два коммита, на которые ссылается &lt;code&gt;HEAD&lt;/code&gt; , мы можем использовать любую из этих команд:</target>
        </trans-unit>
        <trans-unit id="1d5fb2a96e98dbf044763df4f4d84c289b1a7a1e" translate="yes" xml:space="preserve">
          <source>If we look at the way commits are created under the cover, we&amp;rsquo;ll see that there are more flexible ways creating commits.</source>
          <target state="translated">Если мы посмотрим, как создаются коммиты под обложкой, мы увидим, что есть более гибкие способы создания коммитов.</target>
        </trans-unit>
        <trans-unit id="2a7aed1833634138d2979858dc472c551054c3f5" translate="yes" xml:space="preserve">
          <source>If we need to talk about a particular commit, the character &quot;o&quot; may be replaced with another letter or number.</source>
          <target state="translated">Если нам нужно поговорить о конкретном коммите,то символ &quot;о&quot; может быть заменен другой буквой или цифрой.</target>
        </trans-unit>
        <trans-unit id="73117dc442919d58c7658111f0e65fc3ffc2d92d" translate="yes" xml:space="preserve">
          <source>If width is &lt;code&gt;0&lt;/code&gt; (zero) then indent the lines of the output without wrapping them.</source>
          <target state="translated">Если ширина равна &lt;code&gt;0&lt;/code&gt; (нулю), то отступите строки вывода, не оборачивая их.</target>
        </trans-unit>
        <trans-unit id="a0f8f4ea612137fd1324a3c99aa8cca8319d30d8" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;+&lt;/code&gt; (plus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">Если вы добавляете знак &lt;code&gt;+&lt;/code&gt; (плюс) после &lt;code&gt;%&lt;/code&gt; заполнителя, перевод строки вставляется непосредственно перед раскрытием, если и только если заполнитель расширяется до непустой строки.</target>
        </trans-unit>
        <trans-unit id="f83e564943919127dff3b2d8ad2099402ce321cb" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;-&lt;/code&gt; (minus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.</source>
          <target state="translated">Если вы добавляете &lt;code&gt;-&lt;/code&gt; (знак минус) после &lt;code&gt;%&lt;/code&gt; заполнителя, все последовательные переводы строки, непосредственно предшествующие раскрытию, удаляются тогда и только тогда, когда заполнитель расширяется до пустой строки.</target>
        </trans-unit>
        <trans-unit id="a78fb3b12f14b3649d1e2f03162a9771701e268a" translate="yes" xml:space="preserve">
          <source>If you add a ` ` (space) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">Если вы добавляете `` (пробел) после &lt;code&gt;%&lt;/code&gt; заполнителя, пробел вставляется непосредственно перед раскрытием, если и только если заполнитель расширяется до непустой строки.</target>
        </trans-unit>
        <trans-unit id="2c694abd299e141b455acf195b0e2c24045c8fb9" translate="yes" xml:space="preserve">
          <source>If you allow overriding for the snapshot feature, you can specify which snapshot formats are globally disabled. You can also add any command-line options you want (such as setting the compression level). For instance, you can disable Zip compressed snapshots and set &lt;strong&gt;gzip&lt;/strong&gt;(1) to run at level 6 by adding the following lines to your gitweb configuration file:</source>
          <target state="translated">Если вы разрешаете переопределение для функции моментального снимка, вы можете указать, какие форматы моментального снимка глобально отключены. Вы также можете добавить любые параметры командной строки, которые хотите (например, установить уровень сжатия). Например, вы можете отключить сжатые снимки Zip и настроить &lt;strong&gt;gzip&lt;/strong&gt; (1) для работы на уровне 6, добавив следующие строки в файл конфигурации gitweb:</target>
        </trans-unit>
        <trans-unit id="1eda80bb2b9aeb620d19886733f7a0a33613b07f" translate="yes" xml:space="preserve">
          <source>If you already use &lt;code&gt;mod_userdir&lt;/code&gt; in your virtual host or you don&amp;rsquo;t want to use the '~' as first character, just comment or remove the second rewrite rule, and uncomment one of the following according to what you want.</source>
          <target state="translated">Если вы уже используете &lt;code&gt;mod_userdir&lt;/code&gt; на своем виртуальном хосте или не хотите использовать '~' в качестве первого символа, просто прокомментируйте или удалите второе правило перезаписи и раскомментируйте одно из следующего в соответствии с тем, что вы хотите.</target>
        </trans-unit>
        <trans-unit id="28aab4433d981c882862a14d41ff2a1b6ecf68f5" translate="yes" xml:space="preserve">
          <source>If you also want to see complete diffs at each step, use</source>
          <target state="translated">Если вы также хотите видеть полные различия на каждом шаге,используйте</target>
        </trans-unit>
        <trans-unit id="cc8e02bd7d5fd8efba31a3f28960e44c003964ed" translate="yes" xml:space="preserve">
          <source>If you and the maintainer both have accounts on the same machine, then you can just pull changes from each other&amp;rsquo;s repositories directly; commands that accept repository URLs as arguments will also accept a local directory name:</source>
          <target state="translated">Если у вас и сопровождающего есть учетные записи на одном компьютере, вы можете просто получать изменения напрямую из репозиториев друг друга; Команды, которые принимают URL-адреса репозитория в качестве аргументов, также принимают имя локального каталога:</target>
        </trans-unit>
        <trans-unit id="41ebdd5e935074b399d696e8dc1f4204152e3f63" translate="yes" xml:space="preserve">
          <source>If you are a contributor that sends changes upstream in the form of emails, you should use topic branches as usual (see above). Then use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; to generate the corresponding emails (highly recommended over manually formatting them because it makes the maintainer&amp;rsquo;s life easier).</source>
          <target state="translated">Если вы являетесь участником, который отправляет изменения вверх по течению в форме электронных писем, вам следует использовать тематические ветки как обычно (см. Выше). Затем используйте &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; для создания соответствующих писем (настоятельно рекомендуется, а не форматировать их вручную, потому что это облегчает жизнь сопровождающему).</target>
        </trans-unit>
        <trans-unit id="f7586aada4dc4dabc26450bca6e988967f6c8334" translate="yes" xml:space="preserve">
          <source>If you are a maintainer and would like to merge other people&amp;rsquo;s topic branches to the integration branches, they will typically send a request to do so by mail. Such a request looks like</source>
          <target state="translated">Если вы сопровождаете и хотите объединить тематические ветки других людей с ветвями интеграции, они обычно отправляют запрос на это по почте. Такой запрос выглядит как</target>
        </trans-unit>
        <trans-unit id="6a4170b1f048a116a2a20a0123a6634648180f67" translate="yes" xml:space="preserve">
          <source>If you are coming from a CVS background, the style of cooperation suggested in the previous section may be new to you. You do not have to worry. Git supports the &quot;shared public repository&quot; style of cooperation you are probably more familiar with as well.</source>
          <target state="translated">Если вы пришли из CVS фона,стиль сотрудничества,предложенный в предыдущем разделе,может быть новым для вас.Вам не нужно беспокоиться.Git поддерживает стиль сотрудничества &quot;общий публичный репозиторий&quot;,с которым вы,вероятно,знакомы больше.</target>
        </trans-unit>
        <trans-unit id="d473d9569ed7194445a9c66a5a376371d037be9a" translate="yes" xml:space="preserve">
          <source>If you are creating a branch that you want to switch to immediately, it is easier to use the &quot;git switch&quot; command with its &lt;code&gt;-c&lt;/code&gt; option to do the same thing with a single command.</source>
          <target state="translated">Если вы создаете ветку, на которую хотите немедленно переключиться, проще использовать команду &amp;laquo;git switch&amp;raquo; с опцией &lt;code&gt;-c&lt;/code&gt; , чтобы сделать то же самое с одной командой.</target>
        </trans-unit>
        <trans-unit id="882d5e43cce8c196ac8e463999e712ea9e114942" translate="yes" xml:space="preserve">
          <source>If you are following somebody else&amp;rsquo;s tree, you are most likely using remote-tracking branches (eg. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;). You usually want the tags from the other end.</source>
          <target state="translated">Если вы следите за чужим деревом, вы, скорее всего, используете ветки удаленного отслеживания (например, &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; ). Обычно вам нужны теги с другого конца.</target>
        </trans-unit>
        <trans-unit id="0f51d0b61f348c2beb156a534ba33bcb5f141385" translate="yes" xml:space="preserve">
          <source>If you are going to offer CVS access via pserver, add a line in /etc/inetd.conf like</source>
          <target state="translated">Если вы собираетесь предложить доступ к CVS через pserver,добавьте строку в файле /etc/inetd.conf like</target>
        </trans-unit>
        <trans-unit id="e1c58ac4057b121c58f1f5681f07adc3f2f06c66" translate="yes" xml:space="preserve">
          <source>If you are instead primarily interested in using Git to fetch a project, for example, to test the latest version, you may prefer to start with the first two chapters of &lt;a href=&quot;user-manual&quot;&gt;The Git User&amp;rsquo;s Manual&lt;/a&gt;.</source>
          <target state="translated">Если вместо этого вы в первую очередь заинтересованы в использовании Git для получения проекта, например, для тестирования последней версии, вы можете предпочесть начать с первых двух глав &lt;a href=&quot;user-manual&quot;&gt;Руководства пользователя Git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ce35cf81da423ef90a67288a1d702b7e25d4c6b" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="translated">Если вас интересуют более подробные сведения о процессе просмотра изменений, просто взгляните на первую реализацию &lt;code&gt;cmd_log()&lt;/code&gt; ; вызовите &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; и прокрутите вниз до этой функции (обратите внимание, что вам больше не нужно вызывать &lt;code&gt;setup_pager()&lt;/code&gt; напрямую).</target>
        </trans-unit>
        <trans-unit id="a5b0f41c084141a75721908d0d5d7971792ac89f" translate="yes" xml:space="preserve">
          <source>If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use &lt;code&gt;git stash&lt;/code&gt; to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary.</source>
          <target state="translated">Если вы не совсем уверены в том, что промежуточные ревизии являются согласованными (они компилируются, проходят тестовый набор и т. Д.), Вам следует использовать &lt;code&gt;git stash&lt;/code&gt; , чтобы спрятать еще не зафиксированные изменения после каждого коммита, протестировать и изменить коммит, если исправлены необходимы.</target>
        </trans-unit>
        <trans-unit id="f188b17d328d7a9e1b61bcc0d2e0defbbf399561" translate="yes" xml:space="preserve">
          <source>If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too (and can also report changes to a submodule&amp;rsquo;s work tree).</source>
          <target state="translated">Если вас интересуют только изменения инициализированных в данный момент подмодулей относительно фиксации, записанной в индексе или HEAD, &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; и &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; также предоставят эту информацию (а также могут сообщить об изменениях в дерево работы подмодуля).</target>
        </trans-unit>
        <trans-unit id="9fb9a58a453e5ac1de19a98e53575241a40d1da0" translate="yes" xml:space="preserve">
          <source>If you are paranoid, running &lt;code&gt;git verify-pack&lt;/code&gt; command would detect if you have a corrupt pack, but do not worry too much. Our programs are always perfect ;-).</source>
          <target state="translated">Если вы параноик, запуск команды &lt;code&gt;git verify-pack&lt;/code&gt; определит, есть ли у вас поврежденный пакет, но не беспокойтесь слишком сильно. Наши программы всегда безупречны ;-).</target>
        </trans-unit>
        <trans-unit id="277e03057ecd44d387d6f501d21982d9ff59224b" translate="yes" xml:space="preserve">
          <source>If you are repacking very old imported data (e.g. older than the last year), consider expending some extra CPU time and supplying --window=50 (or higher) when you run &lt;code&gt;git repack&lt;/code&gt;. This will take longer, but will also produce a smaller packfile. You only need to expend the effort once, and everyone using your project will benefit from the smaller repository.</source>
          <target state="translated">Если вы переупаковываете очень старые импортированные данные (например, старше, чем в прошлом году), подумайте о том, чтобы потратить дополнительное время процессора и указать --window = 50 (или выше) при запуске &lt;code&gt;git repack&lt;/code&gt; . Это займет больше времени, но при этом будет создан пакетный файл меньшего размера. Вам нужно затратить усилия только один раз, и каждый, кто использует ваш проект, получит пользу от меньшего хранилища.</target>
        </trans-unit>
        <trans-unit id="c500814f6020ec6c3d1c5a9b455910ea7fc36da1" translate="yes" xml:space="preserve">
          <source>If you are using &quot;git bisect run&quot;, you can use the same manual fix up as above, and then start another &quot;git bisect run&quot; in the special branch. Or as the &quot;git bisect&quot; man page says, the script passed to &quot;git bisect run&quot; can apply a patch before it compiles and test the software &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;. The patch should turn a current untestable commits into a testable one. So the testing will result in &quot;good&quot; or &quot;bad&quot; and &quot;git bisect&quot; will be able to find the first bad commit. And the script should not forget to remove the patch once the testing is done before exiting from the script.</source>
          <target state="translated">Если вы используете &amp;laquo;git bisect run&amp;raquo;, вы можете использовать то же ручное исправление, что и выше, а затем запустить еще один &amp;laquo;git bisect run&amp;raquo; в специальной ветке. Или, как сказано на странице руководства &amp;laquo;git bisect&amp;raquo;, сценарий, переданный команде &amp;laquo;git bisect run&amp;raquo;, может применить патч до компиляции и тестирования программного обеспечения &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt; . Патч должен превратить текущие непроверяемые коммиты в проверяемые. Таким образом, результатом тестирования будет &amp;laquo;хорошо&amp;raquo; или &amp;laquo;плохо&amp;raquo;, а &amp;laquo;git bisect&amp;raquo; сможет найти первую плохую фиксацию. И сценарий не должен забывать удалить патч после завершения тестирования перед выходом из сценария.</target>
        </trans-unit>
        <trans-unit id="c6c0585fbbb0e19d850e67091effac179b4cf010" translate="yes" xml:space="preserve">
          <source>If you blow the index away entirely, you generally haven&amp;rsquo;t lost any information as long as you have the name of the tree that it described.</source>
          <target state="translated">Если вы полностью удалите индекс, вы, как правило, не потеряете никакой информации, если у вас есть имя дерева, которое он описывает.</target>
        </trans-unit>
        <trans-unit id="2d2eeeb68a563ca60a2c585f75afbad9b4a5940e" translate="yes" xml:space="preserve">
          <source>If you both have a test suite and use git bisect, then it becomes less important to check that all tests pass after each commit. Though of course it is probably a good idea to have some checks to avoid breaking too many things because it could make bisecting other bugs more difficult.</source>
          <target state="translated">Если у вас обоих есть тестовый набор и вы используете git-бисект,то становится менее важным проверить,что все тесты проходят после каждого коммита.Хотя,конечно,возможно,было бы неплохо иметь несколько проверок,чтобы не сломать слишком много вещей,потому что это может усложнить биссектрису других ошибок.</target>
        </trans-unit>
        <trans-unit id="7c966eb4fc191c72371d7ddd65b21062f03ccb57" translate="yes" xml:space="preserve">
          <source>If you can do that, you can now recreate the missing object with</source>
          <target state="translated">Если вы можете это сделать,то теперь вы можете воссоздать отсутствующий объект с помощью функции</target>
        </trans-unit>
        <trans-unit id="5c6e6ccfdc26bd491d9ed428be6d535f807a44d7" translate="yes" xml:space="preserve">
          <source>If you choose to wait for the repack, don&amp;rsquo;t try to run benchmarks or performance tests until repacking is completed. fast-import outputs suboptimal packfiles that are simply never seen in real use situations.</source>
          <target state="translated">Если вы решите дождаться переупаковки, не пытайтесь запускать тесты производительности или тесты производительности, пока переупаковка не будет завершена. fast-import выводит неоптимальные файлы пакетов, которые просто никогда не встречаются в реальных ситуациях использования.</target>
        </trans-unit>
        <trans-unit id="db9a66177c2b117d0740a2ed1a511dcc1bea6811" translate="yes" xml:space="preserve">
          <source>If you decide that you&amp;rsquo;d rather see version 2.6.17, you can modify the current branch to point at v2.6.17 instead, with</source>
          <target state="translated">Если вы решите, что предпочитаете версию 2.6.17, вы можете изменить текущую ветвь, указав вместо этого на v2.6.17, с помощью</target>
        </trans-unit>
        <trans-unit id="c943de9e92fabf055b174eed9b10ced62cf6d401" translate="yes" xml:space="preserve">
          <source>If you decide you want the history back, you can always create a new reference pointing to it, for example, a new branch:</source>
          <target state="translated">Если вы решили,что хотите вернуть историю,вы всегда можете создать новую ссылку на неё,например,новое ответвление:</target>
        </trans-unit>
        <trans-unit id="1f288af5e76ef5a4f231f5810c9960b284e03991" translate="yes" xml:space="preserve">
          <source>If you develop on a branch crazy-idea, then regret it, you can always delete the branch with</source>
          <target state="translated">Если вы развиваетесь на сумасшедшей ветке,то пожалеете об этом,вы всегда можете удалить ветку с помощью</target>
        </trans-unit>
        <trans-unit id="6d7822c644d713e2101d339a30a68a502f988e1b" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t specify the CVSROOT/CVS_SERVER directly in the checkout command, automatically saving it in your &lt;code&gt;CVS/Root&lt;/code&gt; files, then you need to set them explicitly in your environment. CVSROOT should be set as per normal, but the directory should point at the appropriate Git repo. As above, for SSH clients &lt;code&gt;not&lt;/code&gt; restricted to &lt;code&gt;git-shell&lt;/code&gt;, CVS_SERVER should be set to &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">Если вы не указали CVSROOT / CVS_SERVER непосредственно в команде checkout, автоматически сохранив его в ваших файлах &lt;code&gt;CVS/Root&lt;/code&gt; , то вам необходимо явно установить их в своей среде. CVSROOT должен быть установлен как обычно, но каталог должен указывать на соответствующий репозиторий Git. Как и выше, для клиентов SSH, &lt;code&gt;not&lt;/code&gt; ограниченных &lt;code&gt;git-shell&lt;/code&gt; , CVS_SERVER следует установить на &lt;code&gt;git-cvsserver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="467e5efa7fe7a25688df5c19177b2c4b9a971487" translate="yes" xml:space="preserve">
          <source>If you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:</source>
          <target state="translated">Если вы обнаружили ошибку при указании статуса ревизии,вы можете сохранить вывод этой команды в файл,отредактировать его,чтобы удалить неправильные записи,а затем выдать следующие команды,чтобы вернуться в исправленное состояние:</target>
        </trans-unit>
        <trans-unit id="fdb535b3114700ba9158b47e1cadbbb4ffee0391" translate="yes" xml:space="preserve">
          <source>If you do merge, note the following rule: &lt;code&gt;git svn dcommit&lt;/code&gt; will attempt to commit on top of the SVN commit named in</source>
          <target state="translated">Если вы выполняете слияние, обратите внимание на следующее правило: &lt;code&gt;git svn dcommit&lt;/code&gt; попытается выполнить фиксацию поверх фиксации SVN, указанной в</target>
        </trans-unit>
        <trans-unit id="d7d53a76c809507d4642710878a2561fe720cf02" translate="yes" xml:space="preserve">
          <source>If you do not have &lt;code&gt;mod_rewrite&lt;/code&gt; available to match against the query string, it is sufficient to just protect &lt;code&gt;git-receive-pack&lt;/code&gt; itself, like:</source>
          <target state="translated">Если у вас нет доступного &lt;code&gt;mod_rewrite&lt;/code&gt; для сопоставления со строкой запроса, достаточно просто защитить сам &lt;code&gt;git-receive-pack&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="61817ad83cf40051c64b68562493dd77ca2fe6f8" translate="yes" xml:space="preserve">
          <source>If you do not have this configuration variable, the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; is used instead.</source>
          <target state="translated">Если у вас нет этой переменной конфигурации, вместо &lt;code&gt;i18n.commitEncoding&lt;/code&gt; используется значение i18n.commitEncoding .</target>
        </trans-unit>
        <trans-unit id="14f3fbb24beba0c7fa85b6385a5b3979968f4593" translate="yes" xml:space="preserve">
          <source>If you do not know the encoding of a file, then you can use the &lt;code&gt;file&lt;/code&gt; command to guess the encoding:</source>
          <target state="translated">Если вы не знаете кодировку файла, вы можете использовать команду &lt;code&gt;file&lt;/code&gt; , чтобы угадать кодировку:</target>
        </trans-unit>
        <trans-unit id="371074e4db6e9a2527bbe63c09ef576231a57ee5" translate="yes" xml:space="preserve">
          <source>If you do not want this feature on your server just remove the second rewrite rule.</source>
          <target state="translated">Если вы не хотите,чтобы эта функция присутствовала на вашем сервере,просто удалите второе правило перезаписи.</target>
        </trans-unit>
        <trans-unit id="b68a865397b0b847cde7a3d94bca4e3b8a2b1c61" translate="yes" xml:space="preserve">
          <source>If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back.</source>
          <target state="translated">Если вы не хотите потерять свою работу (историю от X до B)или работу другого человека (историю от X до A),вам нужно сначала получить историю из репозитория,создать историю,содержащую изменения,сделанные обеими сторонами,и оттолкнуть результат назад.</target>
        </trans-unit>
        <trans-unit id="86c596eda084e162303624098fd515841984d889" translate="yes" xml:space="preserve">
          <source>If you do this, then you should make a public announcement indicating that &lt;code&gt;next&lt;/code&gt; was rewound and rebuilt.</source>
          <target state="translated">Если вы это сделаете, то вы должны сделать публичное объявление о том, что &lt;code&gt;next&lt;/code&gt; был перемотан и восстановлен.</target>
        </trans-unit>
        <trans-unit id="325a3c2222e4d4aaa5c937ccab45f34c95352c49" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to continue with that right away, a few other digressions that may be interesting at this point are:</source>
          <target state="translated">Если вы не хотите сразу же продолжать это, сделайте еще несколько интересных отступлений:</target>
        </trans-unit>
        <trans-unit id="bf36326b8dfc35954574299040bce7c304964cb4" translate="yes" xml:space="preserve">
          <source>If you enable PATH_INFO usage in gitweb by putting</source>
          <target state="translated">Если вы включите использование PATH_INFO в gitweb,поставив</target>
        </trans-unit>
        <trans-unit id="3e267e16654424679545d579a56c2fc25a567700" translate="yes" xml:space="preserve">
          <source>If you examine the file &lt;code&gt;.git/config&lt;/code&gt;, you will see that Git has added a new stanza:</source>
          <target state="translated">Если вы изучите файл &lt;code&gt;.git/config&lt;/code&gt; , вы увидите, что Git добавил новую строфу:</target>
        </trans-unit>
        <trans-unit id="adaf459f23d870ce117760016108b7b8ca67ba63" translate="yes" xml:space="preserve">
          <source>If you examine the resulting commit using gitk, you will see that it has two parents, one pointing to the top of the current branch, and one to the top of the other branch.</source>
          <target state="translated">Если вы изучите полученный коммит с помощью gitk,то увидите,что у него есть два родителя,один из которых указывает на вершину текущей ветки,а другой-на вершину другой ветки.</target>
        </trans-unit>
        <trans-unit id="f87315138be947ec0afa0ac1351920e4dfe2a0c2" translate="yes" xml:space="preserve">
          <source>If you find some reason to set this option to &lt;code&gt;false&lt;/code&gt;, other than one-off testing, you should report the behavior difference as a bug in Git (see &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; for details).</source>
          <target state="translated">Если вы найдете какую-либо причину для установки этого параметра в значение &lt;code&gt;false&lt;/code&gt; , кроме разового тестирования, вы должны сообщить о различии в поведении как об ошибке в Git ( подробности см. На &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bbcb62743d9f0aa650833d05c94c3e3db4eb4e0d" translate="yes" xml:space="preserve">
          <source>If you find you forked off the wrong branch and want to move it &quot;back in time&quot;, use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">Если вы обнаружили, что разветвлены не на той ветке, и хотите переместить ее &amp;laquo;назад во времени&amp;raquo;, используйте &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12cef549aa55079a651285c652b78bc4bc8af80c" translate="yes" xml:space="preserve">
          <source>If you find you need new features from the branch &lt;code&gt;other&lt;/code&gt; to continue working on your topic, merge &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;topic&lt;/code&gt;. (However, do not do this &quot;just habitually&quot;, see below.)</source>
          <target state="translated">Если вы обнаружите, что вам нужны новые функции из &lt;code&gt;other&lt;/code&gt; ветки, чтобы продолжить работу над своей темой, объедините &lt;code&gt;other&lt;/code&gt; с &lt;code&gt;topic&lt;/code&gt; . (Однако не делайте этого &amp;laquo;просто по привычке&amp;raquo;, см. Ниже.)</target>
        </trans-unit>
        <trans-unit id="c89cdceb268014744fee40998409a87331a70cef" translate="yes" xml:space="preserve">
          <source>If you followed the last paragraph, you will now have many small topic branches, and occasionally wonder how they interact. Perhaps the result of merging them does not even work? But on the other hand, we want to avoid merging them anywhere &quot;stable&quot; because such merges cannot easily be undone.</source>
          <target state="translated">Если вы следовали последнему параграфу,то теперь у вас будет много маленьких тематических ветвей,и время от времени вы будете задаваться вопросом,как они взаимодействуют.Может быть,результат их слияния даже не сработает? Но,с другой стороны,мы хотим избежать их слияния в любом &quot;стабильном&quot; месте,потому что такие слияния не могут быть легко отменены.</target>
        </trans-unit>
        <trans-unit id="f8ccc691fa447494e794dd8643eee96c05ab0ca5" translate="yes" xml:space="preserve">
          <source>If you get stuck and decide to just give up and throw the whole mess away, you can always return to the pre-merge state with</source>
          <target state="translated">Если ты застрянешь и решишь просто сдаться и выкинуть весь беспорядок,ты всегда можешь вернуться в состояние предварительной торговли с помощью</target>
        </trans-unit>
        <trans-unit id="8d7c02e3dd22e344be3301eb8a2278c07f5b614c" translate="yes" xml:space="preserve">
          <source>If you grasp the ideas in that initial commit, you should check out a more recent version and skim &lt;code&gt;cache.h&lt;/code&gt;, &lt;code&gt;object.h&lt;/code&gt; and &lt;code&gt;commit.h&lt;/code&gt;.</source>
          <target state="translated">Если вы уловили идеи этого первоначального коммита, вам следует проверить более свежую версию и просмотреть &lt;code&gt;cache.h&lt;/code&gt; , &lt;code&gt;object.h&lt;/code&gt; и &lt;code&gt;commit.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b91c4875b14e285ca788a5bd5edf75dfcd9633ab" translate="yes" xml:space="preserve">
          <source>If you have a clone of git.git itself, the output of &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; can show you the authors for specific parts of the project.</source>
          <target state="translated">Если у вас есть клон самого git.git, в выходных данных &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; и &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; можно увидеть авторов конкретных частей проекта.</target>
        </trans-unit>
        <trans-unit id="d76da65add1ab668fa52a438912f17a42719fc64" translate="yes" xml:space="preserve">
          <source>If you have a repository where all the branches of interest exist as subdirectories of a single depot path, you can use &lt;code&gt;--detect-branches&lt;/code&gt; when cloning or syncing to have &lt;code&gt;git p4&lt;/code&gt; automatically find subdirectories in p4, and to generate these as branches in Git.</source>
          <target state="translated">Если у вас есть репозиторий, в котором все интересующие ветви существуют как подкаталоги одного пути к депо, вы можете использовать &lt;code&gt;--detect-branches&lt;/code&gt; при клонировании или синхронизации, чтобы &lt;code&gt;git p4&lt;/code&gt; автоматически находил подкаталоги в p4 и генерировал их как ветки в Git ,</target>
        </trans-unit>
        <trans-unit id="0a6081c46922db10b6bc6f47a7f76b221a6196d2" translate="yes" xml:space="preserve">
          <source>If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:</source>
          <target state="translated">Если у вас есть скрипт,который может определить,хороший у вас исходный код или плохой,вы можете сделать бисекс,выпустив команду:</target>
        </trans-unit>
        <trans-unit id="863f4e57810f45268a83fecc8614e1be7d434564" translate="yes" xml:space="preserve">
          <source>If you have added attributes to a file that cause the canonical repository format for that file to change, such as adding a clean/smudge filter or text/eol/ident attributes, merging anything where the attribute is not in place would normally cause merge conflicts.</source>
          <target state="translated">Если вы добавили в файл атрибуты,которые приводят к изменению канонического формата хранилища этого файла,например,добавление фильтра чистоты/масла или атрибутов text/eol/ident,то слияние всего,где атрибут отсутствует,обычно приводит к конфликтам слияния.</target>
        </trans-unit>
        <trans-unit id="0176ab2e378e3df6f1e24b7af5113bcd1e2d5987" translate="yes" xml:space="preserve">
          <source>If you have an old Git that does not understand the version 2 &lt;code&gt;*.idx&lt;/code&gt; file, cloning or fetching over a non native protocol (e.g. &quot;http&quot;) that will copy both &lt;code&gt;*.pack&lt;/code&gt; file and corresponding &lt;code&gt;*.idx&lt;/code&gt; file from the other side may give you a repository that cannot be accessed with your older version of Git. If the &lt;code&gt;*.pack&lt;/code&gt; file is smaller than 2 GB, however, you can use &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt; on the *.pack file to regenerate the &lt;code&gt;*.idx&lt;/code&gt; file.</source>
          <target state="translated">Если у вас есть старый Git, который не понимает файл &lt;code&gt;*.idx&lt;/code&gt; версии 2 , клонирование или выборка по неродному протоколу (например, &amp;laquo;http&amp;raquo;), который скопирует как файл &lt;code&gt;*.pack&lt;/code&gt; ,так и соответствующий файл &lt;code&gt;*.idx&lt;/code&gt; с другой стороны может предоставить вам репозиторий, к которому нельзя получить доступ из вашей старой версии Git. Однако, &lt;code&gt;*.pack&lt;/code&gt; файл * .pack меньше 2 ГБ, вы можете использовать &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack [1]&lt;/a&gt; в файле * .pack для регенерации файла &lt;code&gt;*.idx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c4d7bfb0f77357b6cf0e14e83f75e3ad3892e2a" translate="yes" xml:space="preserve">
          <source>If you have an unfortunate branch that is named &lt;code&gt;hello.c&lt;/code&gt;, this step would be confused as an instruction to switch to that branch. You should instead write:</source>
          <target state="translated">Если у вас есть неудачная ветка с именем &lt;code&gt;hello.c&lt;/code&gt; , этот шаг можно спутать с инструкцией по переключению на эту ветку. Вместо этого вы должны написать:</target>
        </trans-unit>
        <trans-unit id="6748330dc78a7c7da8f6ed8d92c497a5f2638cdd" translate="yes" xml:space="preserve">
          <source>If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface.</source>
          <target state="translated">Если вы импортировали некоторые изменения из другой ВКС и хотите добавить теги для основных релизов вашей работы,полезно иметь возможность указать дату для встраивания внутри объекта тега;такие данные в объекте тега влияют,например,на порядок расположения тегов в gitweb-интерфейсе.</target>
        </trans-unit>
        <trans-unit id="d87d691ee6c65f8321e66034d85f79793605b8a9" translate="yes" xml:space="preserve">
          <source>If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">Если у вас есть локальные изменения в одном или нескольких файлах,которые отличаются между текущей веткой и веткой,в которую вы переключаетесь,команда отказывается переключать ветки,чтобы сохранить ваши изменения в контексте.Однако,с помощью этой опции выполняется трёхстороннее слияние между текущим ответвлением,содержимым вашего рабочего дерева и новым ответвлением,и вы будете находиться в новом ответвлении.</target>
        </trans-unit>
        <trans-unit id="8478bf298413f91bee793cf9d5101299eaa200bd" translate="yes" xml:space="preserve">
          <source>If you have multifactor authentication setup on your gmail account, you will need to generate an app-specific password for use with &lt;code&gt;git send-email&lt;/code&gt;. Visit &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt; to create it.</source>
          <target state="translated">Если в вашей учетной записи Gmail настроена многофакторная проверка подлинности, вам потребуется сгенерировать пароль для конкретного приложения для использования с &lt;code&gt;git send-email&lt;/code&gt; . Посетите &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords,&lt;/a&gt; чтобы создать его.</target>
        </trans-unit>
        <trans-unit id="a8709177c278b5c18333d173ba933d08e65c6841" translate="yes" xml:space="preserve">
          <source>If you have some initial content (say, a tarball):</source>
          <target state="translated">Если у вас есть какое-то начальное содержание (скажем,тарбол):</target>
        </trans-unit>
        <trans-unit id="495e5ec3bcea1de47c24c2073588d5c3b0cf061c" translate="yes" xml:space="preserve">
          <source>If you have these three &lt;code&gt;gitattributes&lt;/code&gt; file:</source>
          <target state="translated">Если у вас есть эти три файла &lt;code&gt;gitattributes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8c8ea948fec03c8051df6ee29e66dada48224b15" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes in your submodule working tree, &lt;code&gt;git
submodule update&lt;/code&gt; will not overwrite them. Instead, you get the usual warning about not being able switch from a dirty branch.</source>
          <target state="translated">Если в рабочем дереве вашего подмодуля есть незафиксированные изменения, &lt;code&gt;git submodule update&lt;/code&gt; не перезапишет их. Вместо этого вы получите обычное предупреждение о невозможности переключения с грязной ветки.</target>
        </trans-unit>
        <trans-unit id="4ccda3cb1e710a989feb173887174c1818fd9d4a" translate="yes" xml:space="preserve">
          <source>If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with &lt;code&gt;rm&lt;/code&gt; (as opposed to &lt;code&gt;git rm&lt;/code&gt;), use &lt;code&gt;git commit -a&lt;/code&gt;, as it will automatically notice and record all removals. You can also have a similar effect without committing by using &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">Если вы предполагаете, что ваша следующая фиксация должна записывать все модификации отслеживаемых файлов в рабочем дереве и записывать все удаления файлов, которые были удалены из рабочего дерева с помощью &lt;code&gt;rm&lt;/code&gt; (в отличие от &lt;code&gt;git rm&lt;/code&gt; ), используйте &lt;code&gt;git commit -a&lt;/code&gt; , поскольку он автоматически заметит и запишет все удаления. Вы также можете получить аналогичный эффект без фиксации, используя &lt;code&gt;git add -u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5223949abb561108f8606da60ebd3c3b78a9872c" translate="yes" xml:space="preserve">
          <source>If you intend to set up a shared public repository that all developers can read/write, or if you want to use &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;, then you probably want to make a bare clone of the imported repository, and use the clone as the shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Если вы намереваетесь создать общий публичный репозиторий, который могут читать / писать все разработчики, или если вы хотите использовать &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; , то вы, вероятно, захотите создать голый клон импортированного репозитория и использовать его как общий репозиторий. См. &lt;a href=&quot;gitcvs-migration&quot;&gt;Gitcvs-migration [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e8fe75eb0be8caf3b1c84cce78f8d98c5c3831c" translate="yes" xml:space="preserve">
          <source>If you just have a few changes, the simplest way to submit them may just be to send them as patches in email:</source>
          <target state="translated">Если у вас есть только несколько изменений,самый простой способ отправить их по электронной почте-это отправить их как патчи:</target>
        </trans-unit>
        <trans-unit id="c3509063d9c8d28fc350d64af9974d7f7ad07d9f" translate="yes" xml:space="preserve">
          <source>If you just need to use Git as a revision control system you may prefer to start with &quot;A Tutorial Introduction to Git&quot; (&lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;) or &lt;a href=&quot;user-manual&quot;&gt;the Git User Manual&lt;/a&gt;.</source>
          <target state="translated">Если вам просто нужно использовать Git в качестве системы контроля версий, вы можете предпочесть начать с &amp;laquo;Введение в Git&amp;raquo; ( &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; ) или &lt;a href=&quot;user-manual&quot;&gt;Руководства пользователя Git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a839fbf210e306e2136c31f2a968baa357075d1" translate="yes" xml:space="preserve">
          <source>If you just want to edit the commit message for a commit, replace the command &quot;pick&quot; with the command &quot;reword&quot;.</source>
          <target state="translated">Если вы просто хотите отредактировать сообщение о фиксации для фиксации,замените команду &quot;pick&quot; на команду &quot;reword&quot;.</target>
        </trans-unit>
        <trans-unit id="1a22bf44debddb2b1654740b48fdcb88c27e49eb" translate="yes" xml:space="preserve">
          <source>If you just want to get the newest copies of the integration branches, staying up to date is easy too:</source>
          <target state="translated">Если вы просто хотите получить новейшие копии интеграционных ветвей,оставаться в курсе событий тоже легко:</target>
        </trans-unit>
        <trans-unit id="5a13a90084d33cb33125eb2c50fff6e07ce8c0d9" translate="yes" xml:space="preserve">
          <source>If you just want to look at an old version of the file, without modifying the working directory, you can do that with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;:</source>
          <target state="translated">Если вы просто хотите просмотреть старую версию файла, не изменяя рабочий каталог, вы можете сделать это с помощью &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="68f30cb563d71e3909ec492d5d34c92facf1030b" translate="yes" xml:space="preserve">
          <source>If you just want to verify whether a given tagged version contains a given commit, you could use &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;:</source>
          <target state="translated">Если вы просто хотите проверить, содержит ли данная версия с тегами заданный коммит, вы можете использовать &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d8a6261ebe4a4d52d4d9a2234a54f319605d4abc" translate="yes" xml:space="preserve">
          <source>If you keep your primary branches immediately under &lt;code&gt;refs/heads&lt;/code&gt;, and topic branches in subdirectories of it, having the following in the configuration file may help:</source>
          <target state="translated">Если вы держите свои основные ветки сразу в &lt;code&gt;refs/heads&lt;/code&gt; , а тематические ветки в его подкаталогах, может помочь следующее в файле конфигурации:</target>
        </trans-unit>
        <trans-unit id="933889a0268ded50e3304543b4e7167783337a6d" translate="yes" xml:space="preserve">
          <source>If you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">Если вы заранее знаете более одной хорошей фиксации, вы можете сузить пространство пополам, указав все хорошие коммиты сразу после плохой фиксации при выполнении команды &lt;code&gt;bisect start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d0efb22e26170e5f6a2a2c939fcf419b948a8aa" translate="yes" xml:space="preserve">
          <source>If you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the basis, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command. Here are more examples:</source>
          <target state="translated">Если вы знаете, до какой фиксации предполагаемый репозиторий получателя должен иметь необходимые объекты, вы можете использовать эти знания для определения основы, давая точку отсечения для ограничения ревизий и объектов, которые входят в результирующий пакет. В предыдущем примере для этой цели использовался тег lastR2bundle, но вы можете использовать любые другие параметры, которые вы задали бы команде &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; . Вот еще примеры:</target>
        </trans-unit>
        <trans-unit id="6178dcf6380091f437345048b81ae6acd9e3fdb2" translate="yes" xml:space="preserve">
          <source>If you leave out the commit name, &lt;code&gt;git grep&lt;/code&gt; will search any of the files it manages in your current directory. So</source>
          <target state="translated">Если вы не укажете имя коммита, &lt;code&gt;git grep&lt;/code&gt; будет искать любой из файлов, которыми он управляет в вашем текущем каталоге. Так</target>
        </trans-unit>
        <trans-unit id="1d3a773743dd2af35a158be46f7bad29aaa6f592" translate="yes" xml:space="preserve">
          <source>If you like to live dangerously, you can replace &lt;strong&gt;all&lt;/strong&gt; core.gitproxy by a new one with</source>
          <target state="translated">Если вам нравится жить опасно, вы можете заменить &lt;strong&gt;весь&lt;/strong&gt; core.gitproxy на новый с</target>
        </trans-unit>
        <trans-unit id="9bff9b22c3bcd9cedd5449471391b1cdf79647bb" translate="yes" xml:space="preserve">
          <source>If you make a commit and then find a mistake immediately after that, you can recover from it with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">Если вы сделаете фиксацию, а затем сразу после этого обнаружите ошибку, вы можете исправить ее с помощью &lt;code&gt;git reset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de1cbbe8d26471b895b54a3d07b205ed1595e0f4" translate="yes" xml:space="preserve">
          <source>If you make a commit that you later wish you hadn&amp;rsquo;t, there are two fundamentally different ways to fix the problem:</source>
          <target state="translated">Если вы совершаете фиксацию, которую позже пожалели, что этого не делали, есть два принципиально разных способа решить проблему:</target>
        </trans-unit>
        <trans-unit id="99ec09f13fb1346102b0f372f091bd234e630539" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;pu&lt;/code&gt;.</source>
          <target state="translated">Если вы дадите (очень) понять, что эта ветка будет удалена сразу после тестирования, вы даже можете опубликовать эту ветку, например, чтобы дать тестировщикам возможность поработать с ней, или другим разработчикам шанс увидеть, незавершенная работа будет совместима. &lt;code&gt;git.git&lt;/code&gt; есть такая официальная ветка интеграции, которая называется &lt;code&gt;pu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d532db8eaaa16fed286ca601d3c879ce0db79d29" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git checkout&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="translated">Если вы примете решение запустить новую ветку в какой-то другой момент истории, кроме текущего &lt;code&gt;HEAD&lt;/code&gt; , вы можете сделать это, просто указав &lt;code&gt;git checkout&lt;/code&gt; , какой будет база для проверки. Другими словами, если у вас есть более ранний тег или ветка, вы просто выполните</target>
        </trans-unit>
        <trans-unit id="ef318d408cfc2262e9ecdfec6313bac5c50bc49a" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead.</source>
          <target state="translated">Если вы вручную перемещаете связанное рабочее дерево, вам необходимо обновить файл &lt;code&gt;gitdir&lt;/code&gt; в каталоге записи. Например, если связанное рабочее дерево перемещено в &lt;code&gt;/newpath/test-next&lt;/code&gt; , а его файл &lt;code&gt;.git&lt;/code&gt; указывает на &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; , обновите &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; вместо ссылки на &lt;code&gt;/newpath/test-next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb87bde3a880515ee52eb5a157ecf80cef103126" translate="yes" xml:space="preserve">
          <source>If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:</source>
          <target state="translated">Если вы по ошибке сбросили или очистили заначки,их невозможно восстановить с помощью обычных механизмов безопасности.Тем не менее,вы можете попробовать следующее заклинание,чтобы получить список тайников,которые все еще находятся в вашем репозитории,но больше недоступны:</target>
        </trans-unit>
        <trans-unit id="110b0b8058519e9efd87b798163b83180b4fd090" translate="yes" xml:space="preserve">
          <source>If you need to add &lt;code&gt;Acked-by&lt;/code&gt; lines to, say, the last 10 commits (none of which is a merge), use this command:</source>
          <target state="translated">Если вам нужно добавить &lt;code&gt;Acked-by&lt;/code&gt; , скажем, к последним 10 коммитам (ни одна из которых не является слиянием), используйте эту команду:</target>
        </trans-unit>
        <trans-unit id="a06310bf48a43d3f06d75e4fe748345a055d13a9" translate="yes" xml:space="preserve">
          <source>If you need to amend commits from deeper in your history, you can use &lt;a href=&quot;#interactive-rebase&quot;&gt;interactive rebase&amp;rsquo;s &lt;code&gt;edit&lt;/code&gt; instruction&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно изменить коммиты более глубоко в вашей истории, вы можете использовать &lt;a href=&quot;#interactive-rebase&quot;&gt;интерактивную инструкцию &lt;code&gt;edit&lt;/code&gt; rebase&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f26f13a2edb916f980bf0b233ef42611b499ae1c" translate="yes" xml:space="preserve">
          <source>If you need to make any further adjustments, do so now, and then add any newly modified content to the index. Finally, commit your changes with:</source>
          <target state="translated">Если вам необходимо внести дополнительные изменения,сделайте это сейчас,а затем добавьте любое новое измененное содержимое в индекс.Наконец,зафиксируйте свои изменения:</target>
        </trans-unit>
        <trans-unit id="b7346c069533043ab7106064793cec780b496e9d" translate="yes" xml:space="preserve">
          <source>If you need to pass multiple options, separate them with a comma.</source>
          <target state="translated">Если нужно передать несколько опций,разделите их запятой.</target>
        </trans-unit>
        <trans-unit id="809b912a9ed5d5a0eab31e3007d95029a30a63c6" translate="yes" xml:space="preserve">
          <source>If you need to reorder or edit a number of commits in a branch, it may be easier to use &lt;code&gt;git rebase -i&lt;/code&gt;, which allows you to reorder and squash commits, as well as marking them for individual editing during the rebase. See &lt;a href=&quot;#interactive-rebase&quot;&gt;Using interactive rebases&lt;/a&gt; for details, and &lt;a href=&quot;#reordering-patch-series&quot;&gt;Reordering or selecting from a patch series&lt;/a&gt; for alternatives.</source>
          <target state="translated">Если вам нужно изменить порядок или отредактировать несколько коммитов в ветке, может быть проще использовать &lt;code&gt;git rebase -i&lt;/code&gt; , который позволяет вам изменять порядок и сквошировать коммиты, а также отмечать их для индивидуального редактирования во время перебазирования. Подробности см. В &lt;a href=&quot;#interactive-rebase&quot;&gt;разделах &amp;laquo;Использование интерактивных перемещений&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;#reordering-patch-series&quot;&gt;Изменение порядка или выбор из серии исправлений&amp;raquo;&lt;/a&gt; для получения альтернатив.</target>
        </trans-unit>
        <trans-unit id="653cbb8173c66cbe6d9c641e8756d2055e0c1628" translate="yes" xml:space="preserve">
          <source>If you never pushed anything out, just re-tag it. Use &quot;-f&quot; to replace the old one. And you&amp;rsquo;re done.</source>
          <target state="translated">Если вы никогда ничего не выталкивали, просто пометьте его заново. Используйте &quot;-f&quot;, чтобы заменить старый. И вы сделали.</target>
        </trans-unit>
        <trans-unit id="e0169e9e6701b28da91f9800a1f0eacd543a0e6b" translate="yes" xml:space="preserve">
          <source>If you now continue development as usual, and eventually merge &lt;code&gt;topic&lt;/code&gt; to &lt;code&gt;subsystem&lt;/code&gt;, the commits from &lt;code&gt;subsystem&lt;/code&gt; will remain duplicated forever:</source>
          <target state="translated">Если вы теперь продолжите разработку как обычно и в конечном итоге объедините &lt;code&gt;topic&lt;/code&gt; с &lt;code&gt;subsystem&lt;/code&gt; , коммиты из &lt;code&gt;subsystem&lt;/code&gt; останутся дублированными навсегда:</target>
        </trans-unit>
        <trans-unit id="d9ba20830393f58c8170e264c4d66d9dd0605070" translate="yes" xml:space="preserve">
          <source>If you now run</source>
          <target state="translated">Если ты сейчас побежишь</target>
        </trans-unit>
        <trans-unit id="ee95c7e5ff1bbdc349787f30139d15eef70dff52" translate="yes" xml:space="preserve">
          <source>If you only want to remove the local checkout of a submodule from your work tree without committing the removal, use &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;deinit&lt;/code&gt; instead. Also see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details on submodule removal.</source>
          <target state="translated">Если вы хотите удалить только локальную проверку подмодуля из своего рабочего дерева, не выполняя удаление, используйте вместо этого &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;deinit&lt;/code&gt; . Также см. &lt;a href=&quot;gitsubmodules&quot;&gt;Gitsubmodules [7]&lt;/a&gt; для получения подробной информации об удалении подмодулей.</target>
        </trans-unit>
        <trans-unit id="de4ecb2fda4e4a17fa4230cd7b06e657b6ab1e40" translate="yes" xml:space="preserve">
          <source>If you plan to publish this repository to be accessed over http, you should do &lt;code&gt;mv my-git.git/hooks/post-update.sample
my-git.git/hooks/post-update&lt;/code&gt; at this point. This makes sure that every time you push into this repository, &lt;code&gt;git update-server-info&lt;/code&gt; is run.</source>
          <target state="translated">Если вы планируете опубликовать этот репозиторий для доступа через http, на этом этапе вам следует выполнить &lt;code&gt;mv my-git.git/hooks/post-update.sample my-git.git/hooks/post-update&lt;/code&gt; . Это гарантирует, что каждый раз, когда вы вставляете в этот репозиторий, запускается &lt;code&gt;git update-server-info&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dce58b5a972f1c023066ee29ac3c991fde1e2420" translate="yes" xml:space="preserve">
          <source>If you present all of your changes as a single patch (or commit), they may find that it is too much to digest all at once.</source>
          <target state="translated">Если вы представите все свои изменения как один патч (или коммит),они могут обнаружить,что это слишком много,чтобы переварить все сразу.</target>
        </trans-unit>
        <trans-unit id="6e4131986cf58f7abe3d9d87945a8e4a59143945" translate="yes" xml:space="preserve">
          <source>If you present them with the entire history of your work, complete with mistakes, corrections, and dead ends, they may be overwhelmed.</source>
          <target state="translated">Если вы преподнесете им всю историю своей работы,полную ошибок,исправлений и тупиков,они могут быть перегружены.</target>
        </trans-unit>
        <trans-unit id="21ee16e384bb8d43949dac71aebc6ab455b71a15" translate="yes" xml:space="preserve">
          <source>If you provide a &lt;code&gt;directory&lt;/code&gt;, the command is run inside it. If this directory does not exist, it will be created.</source>
          <target state="translated">Если вы указываете &lt;code&gt;directory&lt;/code&gt; , команда запускается внутри него. Если этот каталог не существует, он будет создан.</target>
        </trans-unit>
        <trans-unit id="e318df70fba90a3c817f7eb76621f705fc69949d" translate="yes" xml:space="preserve">
          <source>If you pushed your change to a branch whose name is different from the one you have locally, e.g.</source>
          <target state="translated">Если вы перешли на ветку,чьё имя отличается от имени,которое у вас есть локально,например</target>
        </trans-unit>
        <trans-unit id="f36c21fb05ddb2d8eeea70a503cb3c797b4a7baa" translate="yes" xml:space="preserve">
          <source>If you really don&amp;rsquo;t want to clone it, for whatever reasons, check the following points instead (in this order). This is a very destructive approach, so &lt;strong&gt;make a backup&lt;/strong&gt; or go back to cloning it. You have been warned.</source>
          <target state="translated">Если вы действительно не хотите клонировать его по каким-либо причинам, вместо этого проверьте следующие пункты (в этом порядке). Это очень разрушительный подход, поэтому &lt;strong&gt;сделайте резервную копию&lt;/strong&gt; или вернитесь к ее клонированию. Вы были предупреждены.</target>
        </trans-unit>
        <trans-unit id="3a0d5ef629f0a421a47e2200b4c6f6985f396b8e" translate="yes" xml:space="preserve">
          <source>If you really want to remove a submodule from the repository and commit that use &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; instead. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for removal options.</source>
          <target state="translated">Если вы действительно хотите удалить подмодуль из репозитория и зафиксировать его, используйте вместо этого &lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt; . См. &lt;a href=&quot;gitsubmodules&quot;&gt;Параметры&lt;/a&gt; удаления в gitsubmodules [7] .</target>
        </trans-unit>
        <trans-unit id="a5e65b5631472cf01bf2ff6d1fb37eb4b5d6b41d" translate="yes" xml:space="preserve">
          <source>If you really want to use &lt;code&gt;konqueror&lt;/code&gt;, then you can use something like the following:</source>
          <target state="translated">Если вы действительно хотите использовать &lt;code&gt;konqueror&lt;/code&gt; , вы можете использовать что-то вроде следующего:</target>
        </trans-unit>
        <trans-unit id="e3a8dad6f18366292640cec2d899866b39003a2b" translate="yes" xml:space="preserve">
          <source>If you receive such a patch series (as maintainer, or perhaps as a reader of the mailing list it was sent to), save the mails to files, create a new topic branch and use &lt;code&gt;git am&lt;/code&gt; to import the commits:</source>
          <target state="translated">Если вы получили такую ​​серию патчей (как сопровождающий или, возможно, как читатель списка рассылки, куда он был отправлен), сохраните письма в файлы, создайте новую ветку темы и используйте &lt;code&gt;git am&lt;/code&gt; для импорта коммитов:</target>
        </trans-unit>
        <trans-unit id="8122cfb5e210d22279775f15b8524f8a454a6069" translate="yes" xml:space="preserve">
          <source>If you receive the SHA-1 name of a blob from one source, and its contents from another (possibly untrusted) source, you can still trust that those contents are correct as long as the SHA-1 name agrees. This is because the SHA-1 is designed so that it is infeasible to find different contents that produce the same hash.</source>
          <target state="translated">Если вы получаете SHA-1 имя блоба из одного источника,а его содержимое-из другого (возможно,недоверенного)источника,вы все равно можете доверять,что это содержимое верно,при условии,что SHA-1 имя согласовано.Это связано с тем,что SHA-1 спроектирован таким образом,что невозможно найти различное содержимое,которое приводит к появлению одного и того же хэша.</target>
        </trans-unit>
        <trans-unit id="72b668cfa18e4e3a824ca9d20a1fa4e3cde95d1f" translate="yes" xml:space="preserve">
          <source>If you recognize such corruption early you can easily fix it by setting the conversion type explicitly in .gitattributes. Right after committing you still have the original file in your work tree and this file is not yet corrupted. You can explicitly tell Git that this file is binary and Git will handle the file appropriately.</source>
          <target state="translated">Если вы обнаружили такое повреждение на ранней стадии,вы можете легко исправить его,явно задав тип преобразования в .gitattributes.Сразу после фиксации у вас в рабочем дереве остался исходный файл,и этот файл ещё не повреждён.Вы можете явно указать Git'у,что этот файл является двоичным и Git'у будет обрабатывать его соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="6d44148625d48b9905fb64fc2d01c214d013573d" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git branch&lt;/code&gt; at this point, you&amp;rsquo;ll see that Git has temporarily moved you in &quot;(no branch)&quot;. HEAD is now detached from any branch and points directly to a commit (with commit id 65934) that is reachable from &quot;master&quot; but not from v2.6.18. Compile and test it, and see whether it crashes. Assume it does crash. Then:</source>
          <target state="translated">Если вы запустите &lt;code&gt;git branch&lt;/code&gt; на этом этапе, вы увидите, что Git временно переместил вас в &amp;laquo;(без ветки)&amp;raquo;. HEAD теперь отсоединен от любой ветки и указывает непосредственно на фиксацию (с идентификатором фиксации 65934), которая доступна из &amp;laquo;master&amp;raquo;, но не из v2.6.18. Скомпилируйте и протестируйте его и посмотрите, не вылетит ли он. Предположим, это действительно сбой. Затем:</target>
        </trans-unit>
        <trans-unit id="e4f37857c4f0244dcc0891e65a70e27a5bbdffad" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; later, the remote-tracking branches for the named &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; will be updated.</source>
          <target state="translated">Если вы запустите &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; позже, ветки удаленного отслеживания для названного &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; будут обновлены.</target>
        </trans-unit>
        <trans-unit id="086aebbf0140fb264a45c34927db290b089af7f6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git repack&lt;/code&gt; again at this point, it will say &quot;Nothing new to pack.&quot;. Once you continue your development and accumulate the changes, running &lt;code&gt;git repack&lt;/code&gt; again will create a new pack, that contains objects created since you packed your repository the last time. We recommend that you pack your project soon after the initial import (unless you are starting your project from scratch), and then run &lt;code&gt;git repack&lt;/code&gt; every once in a while, depending on how active your project is.</source>
          <target state="translated">Если вы снова запустите &lt;code&gt;git repack&lt;/code&gt; на этом этапе, он выдаст сообщение &amp;laquo;Ничего нового для упаковки&amp;raquo;. Как только вы продолжите разработку и накапливаете изменения, повторный запуск &lt;code&gt;git repack&lt;/code&gt; создаст новый пакет, содержащий объекты, созданные с момента последней упаковки вашего репозитория. Мы рекомендуем вам упаковать свой проект вскоре после первоначального импорта (если вы не начинаете свой проект с нуля), а затем запускать &lt;code&gt;git repack&lt;/code&gt; время от времени, в зависимости от того, насколько активен ваш проект.</target>
        </trans-unit>
        <trans-unit id="f6784580fd898de2457fa8e4a33fffee5347973c" translate="yes" xml:space="preserve">
          <source>If you simply want to have CRLF line endings in your working directory regardless of the repository you are working with, you can set the config variable &quot;core.autocrlf&quot; without using any attributes.</source>
          <target state="translated">Если вы просто хотите,чтобы CRLF-строки заканчивались в вашей рабочей директории независимо от того,с каким репозиторием вы работаете,вы можете установить конфигурационную переменную &quot;core.autocrlf&quot; без использования каких-либо атрибутов.</target>
        </trans-unit>
        <trans-unit id="7c25024f01247f9dfa8226991c206d71987ca030" translate="yes" xml:space="preserve">
          <source>If you suspect that any of these issues may apply to the repository you want to import, consider using cvs2git:</source>
          <target state="translated">Если вы подозреваете,что какая-либо из этих проблем может относиться к репозиторию,который вы хотите импортировать,подумайте об использовании cvs2git:</target>
        </trans-unit>
        <trans-unit id="d4145f8caae501b7db828bb5aa5f527a21b88535" translate="yes" xml:space="preserve">
          <source>If you think you have found a git bug, you can start by exporting an anonymized stream of the whole repository:</source>
          <target state="translated">Если вы думаете,что нашли ошибку в git'е,вы можете начать с экспорта анонимизированного потока всего репозитория:</target>
        </trans-unit>
        <trans-unit id="846aba2aee9d2174839c8e896f13afd75da487fc" translate="yes" xml:space="preserve">
          <source>If you tried a merge which resulted in complex conflicts and want to start over, you can recover with &lt;code&gt;git merge --abort&lt;/code&gt;.</source>
          <target state="translated">Если вы попытались выполнить слияние, которое привело к сложным конфликтам, и хотите начать все сначала, вы можете &lt;code&gt;git merge --abort&lt;/code&gt; восстановление с помощью git merge --abort .</target>
        </trans-unit>
        <trans-unit id="0e65bb746f0318eba11b3455708b3d4c243b8cb3" translate="yes" xml:space="preserve">
          <source>If you tried a pull which resulted in complex conflicts and would want to start over, you can recover with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">Если вы попытались выполнить извлечение, которое привело к сложным конфликтам, и вы хотите начать все сначала, вы можете &lt;code&gt;git reset&lt;/code&gt; восстановление с помощью git reset .</target>
        </trans-unit>
        <trans-unit id="a4f4230d5ba7e1273c96751869d78c8666680eb6" translate="yes" xml:space="preserve">
          <source>If you try and cheat and try to make git-filter-branch only work on files modified in a commit, then two things happen</source>
          <target state="translated">Если вы попытаетесь обмануть и заставить git-фильтр-отделение работать только с файлами,изменёнными в коммите,то произойдут две вещи</target>
        </trans-unit>
        <trans-unit id="8c2ff328d40e63aa92549620e7b30dc7bd79b356" translate="yes" xml:space="preserve">
          <source>If you use any of the options marked &quot;Turns off &lt;code&gt;apply&lt;/code&gt;&quot; above, &lt;code&gt;git apply&lt;/code&gt; reads and outputs the requested information without actually applying the patch. Give this flag after those flags to also apply the patch.</source>
          <target state="translated">Если вы используете любую из опций, помеченных выше &amp;laquo;Отключить &lt;code&gt;apply&lt;/code&gt; &amp;raquo;, &lt;code&gt;git apply&lt;/code&gt; читает и выводит запрошенную информацию без фактического применения патча. Установите этот флаг после этих флагов, чтобы также применить исправление.</target>
        </trans-unit>
        <trans-unit id="9ac6e5a034fc806d1c17415da5d8566070ff7060" translate="yes" xml:space="preserve">
          <source>If you use the rewrite rules from the example you &lt;strong&gt;might&lt;/strong&gt; also need something like the following in your gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; following example):</source>
          <target state="translated">Если вы используете правила перезаписи из примера, вам также &lt;strong&gt;может&lt;/strong&gt; понадобиться что-то вроде следующего в вашем файле конфигурации &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ( /etc/gitweb.conf в следующем примере):</target>
        </trans-unit>
        <trans-unit id="7b6c2f4a6c5d4d8aeea38b5e0c4e8e111c81122f" translate="yes" xml:space="preserve">
          <source>If you want a shared repository, you will need to make a bare clone of the imported directory, as described above. Then treat the imported directory as another development clone for purposes of merging incremental imports.</source>
          <target state="translated">Если вам нужен общий репозиторий,вам нужно сделать &quot;голый&quot; клон импортируемого каталога,как описано выше.Затем относитесь к импортируемой директории как к другому клону разработки для целей объединения инкрементальных импортов.</target>
        </trans-unit>
        <trans-unit id="f7444f839f8aa37b3a95b6650647c55221c170f1" translate="yes" xml:space="preserve">
          <source>If you want command input to still be interpreted as usual by &lt;code&gt;git rev-parse&lt;/code&gt; before the output is shell quoted, see the &lt;code&gt;--sq&lt;/code&gt; option.</source>
          <target state="translated">Если вы хотите, чтобы ввод команды по-прежнему интерпретировался как обычно с помощью &lt;code&gt;git rev-parse&lt;/code&gt; до того, как вывод будет заключен в кавычки оболочки, см. &lt;code&gt;--sq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54d050e248b6c4afcd2cdb81603440db07ba11e1" translate="yes" xml:space="preserve">
          <source>If you want to break the dependency of a repository cloned with &lt;code&gt;--shared&lt;/code&gt; on its source repository, you can simply run &lt;code&gt;git repack -a&lt;/code&gt; to copy all objects from the source repository into a pack in the cloned repository.</source>
          <target state="translated">Если вы хотите разорвать зависимость репозитория, клонированного с помощью &lt;code&gt;--shared&lt;/code&gt; , от его исходного репозитория, вы можете просто запустить &lt;code&gt;git repack -a&lt;/code&gt; , чтобы скопировать все объекты из исходного репозитория в пакет в клонированном репозитории.</target>
        </trans-unit>
        <trans-unit id="175eedbbcb252ccb8b65afc8343c53ee6468a326" translate="yes" xml:space="preserve">
          <source>If you want to check out &lt;code&gt;all&lt;/code&gt; C source files out of the index, you can say</source>
          <target state="translated">Если вы хотите извлечь &lt;code&gt;all&lt;/code&gt; исходные файлы C из индекса, вы можете сказать</target>
        </trans-unit>
        <trans-unit id="e8498bad4ba6680850d835a14e8199fc54c7601f" translate="yes" xml:space="preserve">
          <source>If you want to delete an entry for a multivar (like core.gitproxy above), you have to provide a regex matching the value of exactly one line.</source>
          <target state="translated">Если вы хотите удалить запись для мультивара (например,core.gitproxy выше),вы должны предоставить регекс,совпадающий со значением ровно одной строки.</target>
        </trans-unit>
        <trans-unit id="b6ce9e2807ee6d14a7a74a4824bf5e00e758331b" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--fsmonitor&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">Если вы хотите включить (или отключить) эту функцию, проще использовать &lt;code&gt;core.fsmonitor&lt;/code&gt; конфигурации core.fsmonitor (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ), чем использовать параметр &lt;code&gt;--fsmonitor&lt;/code&gt; для &lt;code&gt;git update-index&lt;/code&gt; в каждом репозитории, особенно если вы хотите сделать это во всех репозиториях, которые вы используете, потому что вы можете установить переменную конфигурации в вашем &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; только один раз, и она повлияет на все репозитории, которых вы касаетесь.</target>
        </trans-unit>
        <trans-unit id="fade353b5f9f7d0b204907810eaa983a2e094489" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--untracked-cache&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;) in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">Если вы хотите включить (или отключить) эту функцию, проще использовать &lt;code&gt;core.untrackedCache&lt;/code&gt; конфигурации core.untrackedCache (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ), чем использовать параметр &lt;code&gt;--untracked-cache&lt;/code&gt; для &lt;code&gt;git update-index&lt;/code&gt; в каждом репозитории, особенно если вы хотите сделать это во всех репозиториях, которые вы используете, потому что вы можете установить для переменной конфигурации значение &lt;code&gt;true&lt;/code&gt; (или &lt;code&gt;false&lt;/code&gt; ) в вашем &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; только один раз, и это повлияет на все репозитории, которых вы касаетесь.</target>
        </trans-unit>
        <trans-unit id="58323cdd8a68e6e1cc6d62c47524db6593349b87" translate="yes" xml:space="preserve">
          <source>If you want to ensure that text files that any contributor introduces to the repository have their line endings normalized, you can set the &lt;code&gt;text&lt;/code&gt; attribute to &quot;auto&quot; for &lt;code&gt;all&lt;/code&gt; files.</source>
          <target state="translated">Если вы хотите гарантировать, что текстовые файлы, которые любой участник вводит в репозиторий, имеют нормализованные окончания строк, вы можете установить для &lt;code&gt;text&lt;/code&gt; атрибута значение &amp;laquo;auto&amp;raquo; для &lt;code&gt;all&lt;/code&gt; файлов.</target>
        </trans-unit>
        <trans-unit id="46aa6af5bcc60a63656632720781ded6cb9a0464" translate="yes" xml:space="preserve">
          <source>If you want to fold two or more commits into one, replace the command &quot;pick&quot; for the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;. If the commits had different authors, the folded commit will be attributed to the author of the first commit. The suggested commit message for the folded commit is the concatenation of the commit messages of the first commit and of those with the &quot;squash&quot; command, but omits the commit messages of commits with the &quot;fixup&quot; command.</source>
          <target state="translated">Если вы хотите сложить два или более коммита в один,замените команду &quot;pick&quot; для второго и последующих коммитов на &quot;squash&quot; или &quot;fixup&quot;.Если у коммитов были разные авторы,то сложенный коммит будет приписан автору первого коммита.Предлагаемое сообщение о фиксации для сложенной фиксации-это объединение сообщений о фиксации первой фиксации и сообщений о фиксации команды &quot;squash&quot;,но опускает сообщения о фиксации фиксации командой &quot;fixup&quot;.</target>
        </trans-unit>
        <trans-unit id="a1fc176bf758306e3705a3dd88ad77db4fb55698" translate="yes" xml:space="preserve">
          <source>If you want to have one URL for both gitweb and your &lt;code&gt;http://&lt;/code&gt; repositories, you can configure Apache like this:</source>
          <target state="translated">Если вы хотите иметь один URL-адрес как для gitweb, так и для репозиториев &lt;code&gt;http://&lt;/code&gt; , вы можете настроить Apache следующим образом:</target>
        </trans-unit>
        <trans-unit id="23a694ff61b56e5a1054639701ce379b6eeb6564" translate="yes" xml:space="preserve">
          <source>If you want to know all the values for a multivar, do:</source>
          <target state="translated">Если вы хотите знать все значения для мультивара,сделайте это:</target>
        </trans-unit>
        <trans-unit id="be838b052e83d8fa0d4980781547923358bc58d3" translate="yes" xml:space="preserve">
          <source>If you want to make a change within a submodule and you have a detached head, then you should create or checkout a branch, make your changes, publish the change within the submodule, and then update the superproject to reference the new commit:</source>
          <target state="translated">Если вы хотите внести изменения внутри подмодуля и у вас есть отдельная голова,то вы должны создать или извлечь ветку,внести изменения,опубликовать изменения внутри подмодуля,а затем обновить суперпроект,чтобы сослаться на новый коммит:</target>
        </trans-unit>
        <trans-unit id="f02c3e1c88ba7fbd299965b88348f8af1bb2eec2" translate="yes" xml:space="preserve">
          <source>If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the &lt;code&gt;^{type}&lt;/code&gt; peeling operator to the parameter. For example, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; will make sure &lt;code&gt;$VAR&lt;/code&gt; names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that &lt;code&gt;$VAR&lt;/code&gt; names an existing object of any type, &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; can be used.</source>
          <target state="translated">Если вы хотите убедиться, что выходные данные действительно именуют объект в вашей базе данных объектов и / или могут использоваться в качестве объекта определенного типа, который вам нужен, вы можете добавить к параметру оператор отслаивания &lt;code&gt;^{type}&lt;/code&gt; . Например, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; будет гарантировать, что &lt;code&gt;$VAR&lt;/code&gt; назовет существующий объект, который является фиктивным (то есть фиксацией или аннотированным тегом, указывающим на фиксацию). Чтобы убедиться, что &lt;code&gt;$VAR&lt;/code&gt; дает имя существующему объекту любого типа, можно использовать &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="136531f3c928e37ad60b2649b3285deac4e99b46" translate="yes" xml:space="preserve">
          <source>If you want to refer to a git refspec that has characters that are not allowed by CVS, you have two options. First, it may just work to supply the git refspec directly to the appropriate CVS -r argument; some CVS clients don&amp;rsquo;t seem to do much sanity checking of the argument. Second, if that fails, you can use a special character escape mechanism that only uses characters that are valid in CVS tags. A sequence of 4 or 5 characters of the form (underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;), one or two characters, and dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;)) can encode various characters based on the one or two letters: &lt;code&gt;&quot;s&quot;&lt;/code&gt; for slash (&lt;code&gt;&quot;/&quot;&lt;/code&gt;), &lt;code&gt;&quot;p&quot;&lt;/code&gt; for period (&lt;code&gt;&quot;.&quot;&lt;/code&gt;), &lt;code&gt;&quot;u&quot;&lt;/code&gt; for underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), or two hexadecimal digits for any byte value at all (typically an ASCII number, or perhaps a part of a UTF-8 encoded character).</source>
          <target state="translated">Если вы хотите сослаться на git refspec, в котором есть символы, запрещенные CVS, у вас есть два варианта. Во-первых, можно просто передать git refspec напрямую в соответствующий аргумент CVS -r; некоторые клиенты CVS, кажется, не проводят тщательной проверки аргумента. Во-вторых, если это не удается, вы можете использовать специальный механизм escape-символов, который использует только те символы, которые допустимы в тегах CVS. Последовательность из 4 или 5 символов формы (подчеркивание ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ), тире ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), один или два символа и тире ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; )) может кодировать различные символы на основе одной или двух букв: &lt;code&gt;&quot;s&quot;&lt;/code&gt; для косой черты ( &lt;code&gt;&quot;/&quot;&lt;/code&gt; ), &lt;code&gt;&quot;p&quot;&lt;/code&gt; для точки ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; ), &lt;code&gt;&quot;u&quot;&lt;/code&gt; для подчеркивания ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ) или две шестнадцатеричные цифры для любого байтового значения (обычно это число ASCII или, возможно, часть символа в кодировке UTF-8).</target>
        </trans-unit>
        <trans-unit id="e8beaf63d7e0d62995b4c7a9252b3f2ea0574fab" translate="yes" xml:space="preserve">
          <source>If you want to replace many blobs, trees or commits that are part of a string of commits, you may just want to create a replacement string of commits and then only replace the commit at the tip of the target string of commits with the commit at the tip of the replacement string of commits.</source>
          <target state="translated">Если вы хотите заменить много блоков,деревьев или коммитов,которые являются частью строки коммитов,вы можете просто создать замену строки коммитов,а затем заменить только коммит по кончику целевой строки коммитов на коммит по кончику строки замены коммитов.</target>
        </trans-unit>
        <trans-unit id="44f075cf045ec7b6bbf9c6b54de29b3e2085d2d6" translate="yes" xml:space="preserve">
          <source>If you want to restore &lt;code&gt;all&lt;/code&gt; C source files to match the version in the index, you can say</source>
          <target state="translated">Если вы хотите восстановить &lt;code&gt;all&lt;/code&gt; исходные файлы C в соответствии с версией в индексе, вы можете сказать</target>
        </trans-unit>
        <trans-unit id="7bbbea69a50b6a93a6b75d0ba68d2bc45319d47b" translate="yes" xml:space="preserve">
          <source>If you want to rewrite URLs for push only, you can create a configuration section of the form:</source>
          <target state="translated">Если вы хотите переписать URL только для push,вы можете создать конфигурационный раздел формы:</target>
        </trans-unit>
        <trans-unit id="295a38729bbd2cc488fb271a44e4d101d6ee7a15" translate="yes" xml:space="preserve">
          <source>If you want to show differences between binary or specially-formatted blobs in your repository, you can choose to use either an external diff command, or to use textconv to convert them to a diff-able text format. Which method you choose depends on your exact situation.</source>
          <target state="translated">Если вы хотите показать различия между бинарными или специально отформатированными блоками в вашем репозитории,вы можете использовать либо внешнюю команду diff,либо текстовуюconv для их конвертирования в текстовый формат с поддержкой различий.Какой метод вы выберете,зависит от вашей конкретной ситуации.</target>
        </trans-unit>
        <trans-unit id="e3f3cfd8a6d2a1c0d741f6415c0be4ad8848457f" translate="yes" xml:space="preserve">
          <source>If you want to show other people your bisection process, you can get a log using for example:</source>
          <target state="translated">Если вы хотите показать другим людям свой процесс приготовления бисквитов,вы можете получить журнал,например,с помощью:</target>
        </trans-unit>
        <trans-unit id="07b554efbcde38cd3d8cb2b2cd3fe1b74a5f9d9d" translate="yes" xml:space="preserve">
          <source>If you want to start a disconnected history that records a set of paths that is totally different from the one of &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;, then you should clear the index and the working tree right after creating the orphan branch by running &lt;code&gt;git rm -rf .&lt;/code&gt; from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc.</source>
          <target state="translated">Если вы хотите запустить отключенную историю, в которой записывается набор путей, который полностью отличается от пути из &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; , вы должны очистить индекс и рабочее дерево сразу после создания сиротской ветки, запустив &lt;code&gt;git rm -rf .&lt;/code&gt; с верхнего уровня рабочего дерева. После этого вы будете готовы подготовить свои новые файлы, повторно заполнить рабочее дерево, скопировав их из другого места, распаковав архив и т. Д.</target>
        </trans-unit>
        <trans-unit id="5dc24ba332edd3d8bebaa76b808aacd296106da2" translate="yes" xml:space="preserve">
          <source>If you want to start a new branch from a remote branch of the same name:</source>
          <target state="translated">Если вы хотите запустить новое ответвление с удалённого филиала с тем же именем:</target>
        </trans-unit>
        <trans-unit id="b533f775f69c9c29e40e15bb405c24bc01b04dac" translate="yes" xml:space="preserve">
          <source>If you want to use gitweb with several project roots you can edit your Apache virtual host and gitweb configuration files in the following way.</source>
          <target state="translated">Если вы хотите использовать gitweb с несколькими корнями проектов,вы можете редактировать ваш виртуальный хост Apache и конфигурационные файлы gitweb следующим образом.</target>
        </trans-unit>
        <trans-unit id="cced0d77bb2b4a5861e7555078781fd81234d732" translate="yes" xml:space="preserve">
          <source>If you want to, you can use &lt;code&gt;git cat-file&lt;/code&gt; to look at those objects, but you&amp;rsquo;ll have to use the object name, not the filename of the object:</source>
          <target state="translated">Если вы хотите, вы можете использовать &lt;code&gt;git cat-file&lt;/code&gt; для просмотра этих объектов, но вам придется использовать имя объекта, а не имя файла объекта:</target>
        </trans-unit>
        <trans-unit id="9eff57ed3284da22d90930841774b80f0270e4be" translate="yes" xml:space="preserve">
          <source>If you wish the exclude patterns to affect only certain repositories (instead of every repository for a given project), you may instead put them in a file in your repository named &lt;code&gt;.git/info/exclude&lt;/code&gt;, or in any file specified by the &lt;code&gt;core.excludesFile&lt;/code&gt; configuration variable. Some Git commands can also take exclude patterns directly on the command line. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for the details.</source>
          <target state="translated">Если вы хотите, чтобы шаблоны исключения влияли только на определенные репозитории (вместо каждого репозитория для данного проекта), вы можете вместо этого поместить их в файл в вашем репозитории с именем &lt;code&gt;.git/info/exclude&lt;/code&gt; или в любой файл, указанный &lt;code&gt;core.excludesFile&lt;/code&gt; переменная конфигурации. Некоторые команды Git также могут принимать шаблоны исключения непосредственно в командной строке. См. Подробности в &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3a956a01313129dd0835296263e6883d7abec99" translate="yes" xml:space="preserve">
          <source>If you wish to affect only a single repository (i.e., to assign attributes to files that are particular to one user&amp;rsquo;s workflow for that repository), then attributes should be placed in the &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file. Attributes which should be version-controlled and distributed to other repositories (i.e., attributes of interest to all users) should go into &lt;code&gt;.gitattributes&lt;/code&gt; files. Attributes that should affect all repositories for a single user should be placed in a file specified by the &lt;code&gt;core.attributesFile&lt;/code&gt; configuration option (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Its default value is $XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/attributes is used instead. Attributes for all users on a system should be placed in the &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; file.</source>
          <target state="translated">Если вы хотите воздействовать только на один репозиторий (т. &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; атрибуты файлам, которые относятся к рабочему процессу одного пользователя для этого репозитория), тогда атрибуты должны быть помещены в файл $ GIT_DIR / info / attributes . Атрибуты, которые должны контролироваться по версиям и распространяться среди других репозиториев (т. &lt;code&gt;.gitattributes&lt;/code&gt; Атрибуты, представляющие интерес для всех пользователей), должны входить в файлы .gitattributes . Атрибуты, которые должны влиять на все репозитории для одного пользователя, должны быть помещены в файл, указанный в &lt;code&gt;core.attributesFile&lt;/code&gt; конфигурации core.attributesFile (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt;). Его значение по умолчанию - $ XDG_CONFIG_HOME / git / attributes. Если $ XDG_CONFIG_HOME не задан или пуст, вместо него используются атрибуты $ HOME / .config / git /. Атрибуты для всех пользователей системы должны быть помещены в файл &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bef77486a59978a04a1c46b2c068b3863595296" translate="yes" xml:space="preserve">
          <source>If you work with other people, you will need commands listed in the &lt;a href=&quot;#PARTICIPANT&quot;&gt;Individual Developer (Participant)&lt;/a&gt; section as well.</source>
          <target state="translated">Если вы работаете с другими людьми, вам также потребуются команды, перечисленные в разделе &amp;laquo; &lt;a href=&quot;#PARTICIPANT&quot;&gt;Индивидуальный разработчик (участник)&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4cb8198fe4b8e422fe561ded3cf681f52266950f" translate="yes" xml:space="preserve">
          <source>If you would like the daemon to exit early, forgetting all cached credentials before their timeout, you can issue an &lt;code&gt;exit&lt;/code&gt; action:</source>
          <target state="translated">Если вы хотите, чтобы демон завершил работу раньше, забыв все кэшированные учетные данные до их тайм-аута, вы можете выполнить действие &lt;code&gt;exit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6fb92003fb885c97541d201047e1ea900190bac9" translate="yes" xml:space="preserve">
          <source>If you would like to use your own terms instead of &quot;bad&quot;/&quot;good&quot; or &quot;new&quot;/&quot;old&quot;, you can choose any names you like (except existing bisect subcommands like &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, &amp;hellip;​) by starting the bisection using</source>
          <target state="translated">Если вы хотите использовать свои собственные термины вместо &amp;laquo;плохой&amp;raquo; / &amp;laquo;хороший&amp;raquo; или &amp;laquo;новый&amp;raquo; / &amp;laquo;старый&amp;raquo;, вы можете выбрать любые имена, которые вам нравятся (кроме существующих разделенных пополам подкоманд, таких как &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; ,&amp;hellip;), запустив деление пополам с использованием</target>
        </trans-unit>
        <trans-unit id="ac9785fae40224d0d9d1a9569429bd18f0ceb511" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re releasing a new version of a software project, you may want to simultaneously make a changelog to include in the release announcement.</source>
          <target state="translated">Если вы выпускаете новую версию программного проекта, вы можете одновременно сделать журнал изменений и включить его в объявление о выпуске.</target>
        </trans-unit>
        <trans-unit id="6cd2cc907ee3e17f5caea471b5027cb72158e075" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve been committing small enough changes, you may now have a good shot at reconstructing the contents of the in-between state 4b9458b.</source>
          <target state="translated">Если вы совершали достаточно небольшие изменения, теперь у вас есть хороший шанс восстановить содержимое промежуточного состояния 4b9458b.</target>
        </trans-unit>
        <trans-unit id="5516e4c9c575f8921939c0e95aa6e39fac3c93e0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve configured a web server that isn&amp;rsquo;t listed here for gitweb, please send in the instructions so they can be included in a future release.</source>
          <target state="translated">Если вы настроили для gitweb веб-сервер, которого здесь нет, отправьте инструкции, чтобы их можно было включить в будущий выпуск.</target>
        </trans-unit>
        <trans-unit id="2ca9c9b64a14bae5a21173833d4a0e06ad289f34" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve messed up the working tree, but haven&amp;rsquo;t yet committed your mistake, you can return the entire working tree to the last committed state with</source>
          <target state="translated">Если вы испортили рабочее дерево, но еще не совершили свою ошибку, вы можете вернуть все рабочее дерево в последнее зафиксированное состояние с помощью</target>
        </trans-unit>
        <trans-unit id="7bdd278937e1b543d6e4ef46f26f74578bcd1798" translate="yes" xml:space="preserve">
          <source>If your branch was based on &amp;lt;upstream&amp;gt; but &amp;lt;upstream&amp;gt; was rewound and your branch contains commits which were dropped, this option can be used with &lt;code&gt;--keep-base&lt;/code&gt; in order to drop those commits from your branch.</source>
          <target state="translated">Если ваша ветка была основана на &amp;lt;upstream&amp;gt;, но &amp;lt;upstream&amp;gt; была перемотана, и ваша ветка содержит коммиты, которые были отброшены, эту опцию можно использовать с &lt;code&gt;--keep-base&lt;/code&gt; , чтобы удалить эти коммиты из вашей ветки.</target>
        </trans-unit>
        <trans-unit id="862f720d820aceb82a46583ae7c2b519ed5f9115" translate="yes" xml:space="preserve">
          <source>If your editor or some other system is running &lt;code&gt;git fetch&lt;/code&gt; in the background for you a way to mitigate this is to simply set up another remote:</source>
          <target state="translated">Если ваш редактор или другая система запускает &lt;code&gt;git fetch&lt;/code&gt; в фоновом режиме, для вас способ смягчить это - просто настроить другой пульт:</target>
        </trans-unit>
        <trans-unit id="6fc3997d817725ac54010e2c723e5760c4e0b90b" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then those submodules will appear based on which you initialized with the &lt;code&gt;git submodule&lt;/code&gt; command. If your sparse-checkout patterns exclude an initialized submodule, then that submodule will still appear in your working directory.</source>
          <target state="translated">Если ваш репозиторий содержит один или несколько подмодулей, то эти подмодули появятся на основе того, что вы инициализировали с помощью команды &lt;code&gt;git submodule&lt;/code&gt; . Если ваши шаблоны разреженной проверки исключают инициализированный подмодуль, то этот подмодуль все равно появится в вашем рабочем каталоге.</target>
        </trans-unit>
        <trans-unit id="17a3911595f90d594aeea889e0f0755079e1efba" translate="yes" xml:space="preserve">
          <source>If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead.</source>
          <target state="translated">Если в середине бисектного сеанса вы знаете,что предлагаемая ревизия не подходит для тестирования (например,она не собирается и вы знаете,что сбой не имеет никакого отношения к ошибке,которую вы преследуете),вы можете вручную выбрать ближайшую фиксацию и протестировать её вместо неё.</target>
        </trans-unit>
        <trans-unit id="4eaf7ef623b220dfff5cf0aad12284c2791aab6b" translate="yes" xml:space="preserve">
          <source>Ignore carriage-return at the end of line when doing a comparison.</source>
          <target state="translated">Не обращайте внимания на возвращение в конце очереди при сравнении.</target>
        </trans-unit>
        <trans-unit id="14129ef50a9ff92ecf5a9d9520de0a5438b9b27c" translate="yes" xml:space="preserve">
          <source>Ignore case differences between the patterns and the files.</source>
          <target state="translated">Игнорируйте различия между шаблонами и файлами.</target>
        </trans-unit>
        <trans-unit id="93adbe048de005f652abeded323ffca0e07802f9" translate="yes" xml:space="preserve">
          <source>Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.</source>
          <target state="translated">Игнорируйте изменения в количестве белых пробелов.При этом игнорируются пробельные символы в конце строки,а все остальные последовательности одного или нескольких пробельных символов считаются эквивалентными.</target>
        </trans-unit>
        <trans-unit id="dceba3e490b99e465dabc6c0a6eb46378a762d2c" translate="yes" xml:space="preserve">
          <source>Ignore changes in whitespace at EOL.</source>
          <target state="translated">Игнорируйте изменения белого пробела на EOL.</target>
        </trans-unit>
        <trans-unit id="0e8a5619a2125f597eccb060c4d8cfcacf8da768" translate="yes" xml:space="preserve">
          <source>Ignore changes made by the revision when assigning blame, as if the change never happened. Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines. This option may be specified multiple times to ignore more than one revision. If the &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a &lt;code&gt;?&lt;/code&gt; in the blame output. If the &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Игнорируйте изменения, внесенные ревизией, при назначении вины, как будто изменения никогда не было. Строки, которые были изменены или добавлены игнорируемой фиксацией, будут возложены на предыдущую фиксацию, которая изменила эту строку или соседние строки. Этот параметр можно указывать несколько раз, чтобы игнорировать более одной ревизии. Если установлен &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; конфигурации blame.markIgnoredLines , то строки, которые были изменены игнорируемой фиксацией и отнесены к другой фиксации, будут отмечены знаком &lt;code&gt;?&lt;/code&gt; в виноватом выводе. Если установлена &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; конфигурации blame.markUnblamableLines , то те строки, затронутые проигнорированной фиксацией, которую мы не смогли отнести к другой ревизии, помечаются &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="847c383f096e8b2857c23f7df697a300205d1cde" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules in the diff generation. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using &quot;all&quot; hides all changes to submodules.</source>
          <target state="translated">Игнорировать изменения субмодулей при генерации различий. &amp;lt;when&amp;gt; может иметь значение &amp;laquo;нет&amp;raquo;, &amp;laquo;неотслеживаемый&amp;raquo;, &amp;laquo;грязный&amp;raquo; или &amp;laquo;все&amp;raquo;, что является значением по умолчанию. Использование &quot;none&quot; будет считать подмодуль измененным, если он содержит неотслеживаемые или измененные файлы или его HEAD отличается от фиксации, записанной в суперпроекте, и может использоваться для переопределения любых настроек параметра &lt;code&gt;ignore&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; или &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [ 5]&lt;/a&gt; . Когда используется &amp;laquo;неотслеживаемый&amp;raquo; субмодули, они не считаются грязными, если они содержат только неотслеживаемый контент (но они по-прежнему сканируются на наличие измененного контента). Использование &quot;dirty&quot; игнорирует все изменения в дереве работы подмодулей,показаны только изменения коммитов, хранящихся в суперпроекте (так было до версии 1.7.0). Использование &amp;laquo;all&amp;raquo; скрывает все изменения в подмодулях.</target>
        </trans-unit>
        <trans-unit id="0a92f8e585ade182f513a5692eb0bb44a7e837dd" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules when looking for changes. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using &quot;all&quot; hides all changes to submodules (and suppresses the output of submodule summaries when the config option &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set).</source>
          <target state="translated">При поиске изменений игнорируйте изменения в подмодулях. &amp;lt;when&amp;gt; может иметь значение &amp;laquo;нет&amp;raquo;, &amp;laquo;неотслеживаемый&amp;raquo;, &amp;laquo;грязный&amp;raquo; или &amp;laquo;все&amp;raquo;, что является значением по умолчанию. Использование &quot;none&quot; будет считать подмодуль измененным, если он содержит неотслеживаемые или измененные файлы или его HEAD отличается от фиксации, записанной в суперпроекте, и может использоваться для переопределения любых настроек параметра &lt;code&gt;ignore&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; или &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [ 5]&lt;/a&gt;, Когда используется &amp;laquo;неотслеживаемый&amp;raquo; субмодули, они не считаются грязными, если они содержат только неотслеживаемый контент (но они по-прежнему сканируются на наличие измененного контента). Использование &quot;dirty&quot; игнорирует все изменения в дереве работы подмодулей, отображаются только изменения коммитов, хранящихся в суперпроекте (такое поведение было до 1.7.0). Использование &amp;laquo;all&amp;raquo; скрывает все изменения в подмодулях (и подавляет вывод сводок по подмодулям, если установлен параметр конфигурации &lt;code&gt;status.submoduleSummary&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f616e5a6b317fb9674ab4a6ecd11655583864222" translate="yes" xml:space="preserve">
          <source>Ignore changes whose lines are all blank.</source>
          <target state="translated">Игнорируйте изменения,все линии которых пустые.</target>
        </trans-unit>
        <trans-unit id="6b93913a06aa23ba136e18a208983b558968a818" translate="yes" xml:space="preserve">
          <source>Ignore refs for branches or tags matching the Perl regular expression. A &quot;negative look-ahead assertion&quot; like &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; can be used to allow only certain refs.</source>
          <target state="translated">Игнорировать ссылки на ветки или теги, соответствующие регулярному выражению Perl. Утверждение &amp;laquo;отрицательного упреждающего просмотра&amp;raquo;, например &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; Можно использовать для разрешения только определенных ссылок.</target>
        </trans-unit>
        <trans-unit id="cca615474ea8523b5665d433104181e17b949af0" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in &lt;code&gt;file&lt;/code&gt;, which must be in the same format as an &lt;code&gt;fsck.skipList&lt;/code&gt;. This option may be repeated, and these files will be processed after any files specified with the &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; config option. An empty file name, &lt;code&gt;&quot;&quot;&lt;/code&gt;, will clear the list of revs from previously processed files.</source>
          <target state="translated">Игнорировать ревизии, перечисленные в &lt;code&gt;file&lt;/code&gt; , который должен быть в том же формате, что и &lt;code&gt;fsck.skipList&lt;/code&gt; . Этот параметр можно повторить, и эти файлы будут обрабатываться после любых файлов, указанных в &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; конфигурации blame.ignoreRevsFile . Пустое имя файла &lt;code&gt;&quot;&quot;&lt;/code&gt; очистит список версий из ранее обработанных файлов.</target>
        </trans-unit>
        <trans-unit id="0cee361918756e813fbfde1e81b931c608ea0bab" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in the file, one unabbreviated object name per line, in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. Whitespace and comments beginning with &lt;code&gt;#&lt;/code&gt; are ignored. This option may be repeated multiple times. Empty file names will reset the list of ignored revisions. This option will be handled before the command line option &lt;code&gt;--ignore-revs-file&lt;/code&gt;.</source>
          <target state="translated">Игнорировать ревизии, перечисленные в файле, по одному несокращенному имени объекта в строке в &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; . Пробелы и комментарии, начинающиеся с символа &lt;code&gt;#&lt;/code&gt; , игнорируются. Этот вариант может повторяться несколько раз. Пустые имена файлов приведут к сбросу списка игнорируемых ревизий. Этот параметр будет обрабатываться перед параметром командной строки &lt;code&gt;--ignore-revs-file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf2829d6b1d696605f65878628b97d7705cf8bc" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">Игнорируйте линии ножниц (см. &lt;a href=&quot;git-mailinfo&quot;&gt;Git-mailinfo [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2348d1bd6f42459d3ee1b173782de699bb2835d4" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines. Useful for overriding mailinfo.scissors settings.</source>
          <target state="translated">Игнорируй линии ножниц.Полезно для переопределения настроек mailinfo.scissors.</target>
        </trans-unit>
        <trans-unit id="b8c0493eeab50cd9f84c9bb7fb54695bfa5cd858" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.</source>
          <target state="translated">Игнорируйте пробелы при сравнении линий.Это игнорирует различия,даже если в одной строке есть пробелы,а в другой нет.</target>
        </trans-unit>
        <trans-unit id="f41139f9e81b5ab318787773cf3063813dbcefdd" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing the parent&amp;rsquo;s version and the child&amp;rsquo;s to find where the lines came from.</source>
          <target state="translated">Игнорируйте пробелы при сравнении родительской и дочерней версий, чтобы определить, откуда пришли строки.</target>
        </trans-unit>
        <trans-unit id="67259bef7d0f56e262c4cda325ae4b91dc800c88" translate="yes" xml:space="preserve">
          <source>Ignored files are not listed, unless &lt;code&gt;--ignored&lt;/code&gt; option is in effect, in which case &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;!!&lt;/code&gt;.</source>
          <target state="translated">Пропущенные файлы не указаны, если &lt;code&gt;--ignored&lt;/code&gt; опция не действует, и в этом случае &lt;code&gt;XY&lt;/code&gt; является &lt;code&gt;!!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="5a64e868764637ce6fa403b78bdbf74f10990fd5" translate="yes" xml:space="preserve">
          <source>Ignored items have the following format:</source>
          <target state="translated">Игнорируемые элементы имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="fe5aad4a58f02d9cd03afd86649692db9ed515bd" translate="yes" xml:space="preserve">
          <source>Ignores missing files during a --refresh</source>
          <target state="translated">Игнорирует отсутствующие файлы во время --refresh</target>
        </trans-unit>
        <trans-unit id="87a5b84b90eaf9c6a4ea4cf7776f8cdbe987e92e" translate="yes" xml:space="preserve">
          <source>Ignoring files</source>
          <target state="translated">Игнорирование файлов</target>
        </trans-unit>
        <trans-unit id="d83f269a97cfa5cb2870ace661718351e9ef1d6f" translate="yes" xml:space="preserve">
          <source>Imagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:</source>
          <target state="translated">Представьте себе,что в верхней части публичного коммита P,вы применили известные патчи X,Y и Z от кого-то другого,а затем построили свои три патча серии A,B,C,история была бы как:</target>
        </trans-unit>
        <trans-unit id="220433d0f0fcbc1334d4126616d73a1ad095f039" translate="yes" xml:space="preserve">
          <source>Imagine that you built your work on your &lt;code&gt;master&lt;/code&gt; branch on top of the &lt;code&gt;v1.0&lt;/code&gt; release, and want it to be integrated to the project. First you push that change to your public repository for others to see:</source>
          <target state="translated">Представьте, что вы построили свою работу над &lt;code&gt;master&lt;/code&gt; веткой поверх версии &lt;code&gt;v1.0&lt;/code&gt; и хотите, чтобы она была интегрирована в проект. Сначала вы отправляете это изменение в свой публичный репозиторий, чтобы другие могли его увидеть:</target>
        </trans-unit>
        <trans-unit id="d92dfaf42e4c06410357fc423fdf173e48ba5a6c" translate="yes" xml:space="preserve">
          <source>Imagine that you have to rebase what you have already published. You will have to bypass the &quot;must fast-forward&quot; rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with her commit, and blindly pushing with &lt;code&gt;--force&lt;/code&gt; will lose her work.</source>
          <target state="translated">Представьте, что вам нужно переустановить то, что вы уже опубликовали. Вам придется обойти правило &amp;laquo;перемотать вперед&amp;raquo;, чтобы заменить историю, которую вы изначально опубликовали, историей с измененной базой. Если кто-то другой построил вашу исходную историю, пока вы выполняете перебазирование, верхушка ветки на удаленном компьютере может продвигаться вперед вместе с ее фиксацией, и слепое нажатие с &lt;code&gt;--force&lt;/code&gt; потеряет ее работу.</target>
        </trans-unit>
        <trans-unit id="8a9ff0ad91f2190aebd8f7874a38eff49a81d587" translate="yes" xml:space="preserve">
          <source>Imagine this history:</source>
          <target state="translated">Представь себе эту историю:</target>
        </trans-unit>
        <trans-unit id="db144a77867a22b1db2aa0f495d3082ced7cfb54" translate="yes" xml:space="preserve">
          <source>Imitate &lt;code&gt;git clone&lt;/code&gt; but track only selected branches</source>
          <target state="translated">Имитировать &lt;code&gt;git clone&lt;/code&gt; , но отслеживать только выбранные ветки</target>
        </trans-unit>
        <trans-unit id="4a694f013e1a15bee19331c0c7b9e3ce34840db9" translate="yes" xml:space="preserve">
          <source>Imitate a CVS server. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Имитируйте сервер CVS. См. &lt;a href=&quot;git-cvsserver&quot;&gt;Git-cvsserver [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="f1c03dca591efe03ac168cd03c30c9d29e88acc3" translate="yes" xml:space="preserve">
          <source>Import Now, Repack Later</source>
          <target state="translated">Импортируйте сейчас,переупаковывайте позже</target>
        </trans-unit>
        <trans-unit id="b3e1462f677f3a661ca64753ac202708178b3a16" translate="yes" xml:space="preserve">
          <source>Import a GNU Arch repository into Git</source>
          <target state="translated">Импорт репозитория архива GNU в Git</target>
        </trans-unit>
        <trans-unit id="502aadd2b2c2382144812aea24a52e335147d4a4" translate="yes" xml:space="preserve">
          <source>Import all changes from both named depot paths into a single repository. Only files below these directories are included. There is not a subdirectory in Git for each &quot;proj1&quot; and &quot;proj2&quot;. You must use the &lt;code&gt;--destination&lt;/code&gt; option when specifying more than one depot path. The revision specifier must be specified identically on each depot path. If there are files in the depot paths with the same name, the path with the most recently updated version of the file is the one that appears in Git.</source>
          <target state="translated">Импортируйте все изменения из обоих названных путей депо в единый репозиторий. Включены только файлы ниже этих каталогов. В Git нет подкаталога для каждого &amp;laquo;proj1&amp;raquo; и &amp;laquo;proj2&amp;raquo;. Вы должны использовать опцию &lt;code&gt;--destination&lt;/code&gt; при указании более одного пути депо. Спецификатор ревизии должен быть указан идентично на каждом пути депо. Если в путях депо есть файлы с тем же именем, путь с самой последней обновленной версией файла - это тот, который отображается в Git.</target>
        </trans-unit>
        <trans-unit id="90051e560d673faccfb0bfe61644ca104b05b719" translate="yes" xml:space="preserve">
          <source>Import all commits, including recent ones. cvsimport by default skips commits that have a timestamp less than 10 minutes ago.</source>
          <target state="translated">Импорт всех коммитов,включая недавние.cvsimport по умолчанию пропускает коммиты,которые имеют временную метку менее 10 минут назад.</target>
        </trans-unit>
        <trans-unit id="3ffbc41d8e969bcf6a3014a353f6e7a2bfd3e3ba" translate="yes" xml:space="preserve">
          <source>Import at most &lt;code&gt;n&lt;/code&gt; changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use &lt;code&gt;@all&lt;/code&gt; as the revision specifier, but then to use &lt;code&gt;--max-changes 1000&lt;/code&gt; to import only the last 1000 revisions rather than the entire revision history.</source>
          <target state="translated">Импортируйте не более &lt;code&gt;n&lt;/code&gt; изменений, а не весь диапазон изменений, включенных в данный спецификатор ревизии. Типичным использованием будет использование &lt;code&gt;@all&lt;/code&gt; в качестве спецификатора ревизии, но затем использование &lt;code&gt;--max-changes 1000&lt;/code&gt; для импорта только последних 1000 ревизий, а не всей истории ревизий.</target>
        </trans-unit>
        <trans-unit id="a203d27ce8c09d6ab5f978bc976ed19c7da8bd29" translate="yes" xml:space="preserve">
          <source>Import changes into &amp;lt;ref&amp;gt; instead of refs/remotes/p4/master. If &amp;lt;ref&amp;gt; starts with refs/, it is used as is. Otherwise, if it does not start with p4/, that prefix is added.</source>
          <target state="translated">Импортируйте изменения в &amp;lt;ref&amp;gt; вместо refs / remotes / p4 / master. Если &amp;lt;ref&amp;gt; начинается с refs /, он используется как есть. В противном случае, если он не начинается с p4 /, этот префикс добавляется.</target>
        </trans-unit>
        <trans-unit id="3446130415616c26cfbd9b0cb3b27c636fdfb1f4" translate="yes" xml:space="preserve">
          <source>Import exactly the p4 change numbers listed in &lt;code&gt;file&lt;/code&gt;, one per line. Normally, &lt;code&gt;git p4&lt;/code&gt; inspects the current p4 repository state and detects the changes it should import.</source>
          <target state="translated">Импортируйте точно те номера изменений p4, которые указаны в &lt;code&gt;file&lt;/code&gt; , по одному в каждой строке. Обычно &lt;code&gt;git p4&lt;/code&gt; проверяет текущее состояние репозитория p4 и обнаруживает изменения, которые он должен импортировать.</target>
        </trans-unit>
        <trans-unit id="051514630860e82d8e6dfeb8000cb04203f0530f" translate="yes" xml:space="preserve">
          <source>Import from and submit to Perforce repositories</source>
          <target state="translated">Импорт из репозиториев Perforce и отправка в репозитории Perforce</target>
        </trans-unit>
        <trans-unit id="bc1da86269dd0fa043570d9e0331c263ee1c8e9b" translate="yes" xml:space="preserve">
          <source>Import labels from p4 into Git.</source>
          <target state="translated">Импортируйте этикетки из p4 в Git.</target>
        </trans-unit>
        <trans-unit id="01c4fe3eff92a8abc6c7acba932cff943343d8ce" translate="yes" xml:space="preserve">
          <source>Import one commit for each change in the history of that depot path.</source>
          <target state="translated">Импортируйте по одному коммиту за каждое изменение в истории этого депо.</target>
        </trans-unit>
        <trans-unit id="5fa6a825ca52ecc53990e4e3e6add862904fa4f4" translate="yes" xml:space="preserve">
          <source>Import one commit with all files in the &lt;code&gt;#head&lt;/code&gt; change under that tree.</source>
          <target state="translated">Импортируйте одну фиксацию со всеми файлами в изменении &lt;code&gt;#head&lt;/code&gt; под этим деревом.</target>
        </trans-unit>
        <trans-unit id="1a475e0c7f94606844ba9fa0d34742cd54c3d13c" translate="yes" xml:space="preserve">
          <source>Import only changes 1 through 6.</source>
          <target state="translated">Импорт изменяется только с 1 по 6.</target>
        </trans-unit>
        <trans-unit id="e9848e9219c243527c0682e352e98364329421b1" translate="yes" xml:space="preserve">
          <source>Import p4 labels into git, as per --import-labels.</source>
          <target state="translated">Импортируйте этикетки p4 в гит,согласно этикеткам --импорт.</target>
        </trans-unit>
        <trans-unit id="34d234038bf4e799d075c2933026167918f64329" translate="yes" xml:space="preserve">
          <source>Import p4 labels.</source>
          <target state="translated">Импортные этикетки р4.</target>
        </trans-unit>
        <trans-unit id="2f4ea105dee6a1ad94ce6623f490fbb875775ee0" translate="yes" xml:space="preserve">
          <source>Import-only: don&amp;rsquo;t perform a checkout after importing. This option ensures the working directory and index remain untouched and will not create them if they do not exist.</source>
          <target state="translated">Только импорт: не выполняйте проверку после импорта. Эта опция гарантирует, что рабочий каталог и индекс останутся нетронутыми и не создадут их, если они не существуют.</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="a64c4afd3bd1cef7955450469801cfbdf061341b" translate="yes" xml:space="preserve">
          <source>Important note! If you have any local changes in these branches, then this merge will create a commit object in the history (with no local changes Git will simply do a &quot;fast-forward&quot; merge). Many people dislike the &quot;noise&quot; that this creates in the Linux history, so you should avoid doing this capriciously in the &lt;code&gt;release&lt;/code&gt; branch, as these noisy commits will become part of the permanent history when you ask Linus to pull from the release branch.</source>
          <target state="translated">Важная заметка! Если у вас есть какие-либо локальные изменения в этих ветвях, то это слияние создаст объект фиксации в истории (без локальных изменений Git просто выполнит слияние с перемоткой вперед). Многим людям не нравится &amp;laquo;шум&amp;raquo;, который это создает в истории Linux, поэтому вам следует избегать делать это по прихоти в ветке &lt;code&gt;release&lt;/code&gt; , так как эти шумные коммиты станут частью постоянной истории, когда вы попросите Линуса вытащить из ветки выпуска.</target>
        </trans-unit>
        <trans-unit id="a87b614cdbaa5301ddda5b9a1cda5205ccdf1bbc" translate="yes" xml:space="preserve">
          <source>Importing a cvs archive</source>
          <target state="translated">Импорт cvs архива</target>
        </trans-unit>
        <trans-unit id="3e30801aed656938780d8d09defb05967bf70053" translate="yes" xml:space="preserve">
          <source>Importing a new project</source>
          <target state="translated">Импорт нового проекта</target>
        </trans-unit>
        <trans-unit id="7d3eb76e15d3e80f60fde0cbe9f4a9a66f1cc724" translate="yes" xml:space="preserve">
          <source>Importing or exporting patches:</source>
          <target state="translated">Импорт или экспорт патчей:</target>
        </trans-unit>
        <trans-unit id="8c866a3a4bff8b0052306000b7abfebb33a38b38" translate="yes" xml:space="preserve">
          <source>Importing patches to a project</source>
          <target state="translated">Импорт патчей в проект</target>
        </trans-unit>
        <trans-unit id="19051f1cf9bd70907beeecdf5147851f44537c38" translate="yes" xml:space="preserve">
          <source>Importing these tags as-is in Git is impossible without making at least one commit which &amp;ldquo;fixes up&amp;rdquo; the files to match the content of the tag. Use fast-import&amp;rsquo;s &lt;code&gt;reset&lt;/code&gt; command to reset a dummy branch outside of your normal branch space to the base commit for the tag, then commit one or more file fixup commits, and finally tag the dummy branch.</source>
          <target state="translated">Импорт этих тегов в Git &amp;laquo;как есть&amp;raquo; невозможен без выполнения хотя бы одной фиксации, которая &amp;laquo;исправляет&amp;raquo; файлы, чтобы они соответствовали содержимому тега. Используйте фаста-ИМПОРТ в &lt;code&gt;reset&lt;/code&gt; команды для сброса фиктивной ветви вне обычной ветви пространства к основанию фиксации для тега, а затем совершить один или несколько FixUp фиксаций файлов, и , наконец , помечать ветку фиктивной.</target>
        </trans-unit>
        <trans-unit id="ffa5110d0a0de3d5244ac22023669387afe15c4d" translate="yes" xml:space="preserve">
          <source>Imports a CVS repository into Git. It will either create a new repository, or incrementally import into an existing one.</source>
          <target state="translated">Импортирует CVS репозиторий в Git.Он либо создаст новый репозиторий,либо постепенно импортирует его в существующий.</target>
        </trans-unit>
        <trans-unit id="189a5fab4172fe96418112b3abf1f29736c5a78f" translate="yes" xml:space="preserve">
          <source>Imports a project from one or more GNU Arch repositories. It will follow branches and repositories within the namespaces defined by the &amp;lt;archive/branch&amp;gt; parameters supplied. If it cannot find the remote branch a merge comes from it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible (see discussion below).</source>
          <target state="translated">Импортирует проект из одного или нескольких репозиториев GNU Arch. Он будет следовать за ветвями и репозиториями в пространствах имен, определенных предоставленными параметрами &amp;lt;archive / branch&amp;gt;. Если он не может найти удаленную ветку, происходит слияние, она просто импортирует ее как обычную фиксацию. Если он сможет его найти, он помечает это как слияние, когда это возможно (см. Обсуждение ниже).</target>
        </trans-unit>
        <trans-unit id="0e7ba011d44c49f30a4b102d2d50cfa93397d28b" translate="yes" xml:space="preserve">
          <source>Imports the full contents of the head revision from the given p4 depot path into a single commit in the Git branch &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;.</source>
          <target state="translated">Импортирует полное содержимое головной ревизии из заданного пути депо p4 в одну фиксацию в ветке Git &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc75793944c924c387fa08f2263917093a9e6ee9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; jargon, &quot;cherry pick&quot; means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the &quot;git cherry-pick&quot; command to extract the change introduced by an existing &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; and to record it based on the tip of the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; as a new commit.</source>
          <target state="translated">На жаргоне &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; &amp;laquo;выбор вишни&amp;raquo; означает выбор подмножества изменений из серии изменений (обычно фиксация) и их запись как новая серия изменений поверх другой кодовой базы. В Git это выполняется командой &amp;laquo;git cherry-pick&amp;raquo;, чтобы извлечь изменение, внесенное существующей &lt;a href=&quot;#def_commit&quot;&gt;фиксацией,&lt;/a&gt; и записать его на основе кончика текущей &lt;a href=&quot;#def_branch&quot;&gt;ветки&lt;/a&gt; как новую фиксацию.</target>
        </trans-unit>
        <trans-unit id="5a7b7bab83d67b10ed8bbe7275df22f645616a7a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--parseopt&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like &lt;code&gt;getopt(1)&lt;/code&gt; does.</source>
          <target state="translated">В режиме &lt;code&gt;--parseopt&lt;/code&gt; &lt;code&gt;git rev-parse&lt;/code&gt; помогает настроить параметры, чтобы передать сценариям оболочки те же возможности, что и встроенные функции C. Он работает как нормализатор опций (например, разделяет совокупные значения отдельных переключателей), примерно как &lt;code&gt;getopt(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a61808962b5b6bb1a272b1dd2c4e90c87c42eb63" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--sq-quote&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; echoes on the standard output a single line suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt;. This line is made by normalizing the arguments following &lt;code&gt;--sq-quote&lt;/code&gt;. Nothing other than quoting the arguments is done.</source>
          <target state="translated">В &lt;code&gt;--sq-quote&lt;/code&gt; режиме, &lt;code&gt;git rev-parse&lt;/code&gt; эхо - сигналы на стандартный вывод одной линии подходит для &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; . Эта строка сделана путем нормализации аргументов, следующих за &lt;code&gt;--sq-quote&lt;/code&gt; . Ничего, кроме цитирования аргументов, не делается.</target>
        </trans-unit>
        <trans-unit id="02025b63af6480e186ac72d3a5a618d5536d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--stdin&lt;/code&gt; mode, take lines in the format</source>
          <target state="translated">В режиме &lt;code&gt;--stdin&lt;/code&gt; брать строки в формате</target>
        </trans-unit>
        <trans-unit id="46fb44ff2c3ae3502717728ebf0f15532f206b66" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; contains just &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">В &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;foo&lt;/code&gt; содержит только &amp;laquo;Foo&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0e95077ff33e18325bb9215a9cc5764269fc90de" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;dbDriver&lt;/code&gt; and &lt;code&gt;dbUser&lt;/code&gt; you can use the following variables:</source>
          <target state="translated">В &lt;code&gt;dbDriver&lt;/code&gt; и &lt;code&gt;dbUser&lt;/code&gt; вы можете использовать следующие переменные:</target>
        </trans-unit>
        <trans-unit id="6c351c60eb0e6d6c6a7b2ff86bb73c9f63bc0dc3" translate="yes" xml:space="preserve">
          <source>In Git 1.7.0 or later, to cancel a conflicting merge, use &lt;code&gt;git reset --merge&lt;/code&gt;. &lt;strong&gt;Warning&lt;/strong&gt;: In older versions of Git, running &lt;code&gt;git pull&lt;/code&gt; with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict.</source>
          <target state="translated">В Git 1.7.0 или новее, чтобы отменить конфликтующее слияние, используйте &lt;code&gt;git reset --merge&lt;/code&gt; . &lt;strong&gt;Предупреждение&lt;/strong&gt; : в более старых версиях Git запускать &lt;code&gt;git pull&lt;/code&gt; с незафиксированными изменениями не рекомендуется: хотя это возможно, это оставляет вас в состоянии, из которого может быть трудно выйти в случае конфликта.</target>
        </trans-unit>
        <trans-unit id="e5fbbb479d61fa23b446f30021dbc9109422a0ad" translate="yes" xml:space="preserve">
          <source>In Git like in many other Version Control Systems (VCS), the different states of the data that is managed by the system are called commits. And, as VCS are mostly used to manage software source code, sometimes &quot;interesting&quot; changes of behavior in the software are introduced in some commits.</source>
          <target state="translated">В Git'е,как и во многих других системах контроля версий (Version Control Systems-VCS),различные состояния данных,которыми управляет система,называются коммитами.И,поскольку VCS в основном используются для управления исходным кодом программ,иногда в некоторых коммитах вносятся &quot;интересные&quot; изменения в поведение программ.</target>
        </trans-unit>
        <trans-unit id="8b9196b57e8598c90aa9a79e64e11940ec4bed09" translate="yes" xml:space="preserve">
          <source>In Git&amp;rsquo;s context, synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">В контексте Git - синоним &lt;a href=&quot;#def_object_name&quot;&gt;имени объекта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="644d8f376b3ac284860f081b25e96334d4db2911" translate="yes" xml:space="preserve">
          <source>In Git, there are two kinds of tags, a &quot;light&quot; one, and an &quot;annotated tag&quot;.</source>
          <target state="translated">В Git'е есть два вида меток,&quot;легкий&quot; и &quot;аннотированный&quot;.</target>
        </trans-unit>
        <trans-unit id="1e877f57bcce771b4a2551649d22c402a8ae8603" translate="yes" xml:space="preserve">
          <source>In SVN, it is possible (though discouraged) to commit changes to a tag (because a tag is just a directory copy, thus technically the same as a branch). When cloning an SVN repository, &lt;code&gt;git svn&lt;/code&gt; cannot know if such a commit to a tag will happen in the future. Thus it acts conservatively and imports all SVN tags as branches, prefixing the tag name with &lt;code&gt;tags/&lt;/code&gt;.</source>
          <target state="translated">В SVN можно (хотя и не рекомендуется) фиксировать изменения в теге (потому что тег - это просто копия каталога, поэтому технически то же самое, что и ветвь). При клонировании репозитория SVN &lt;code&gt;git svn&lt;/code&gt; не может знать, произойдет ли такая фиксация тега в будущем. Таким образом, он действует консервативно и импортирует все теги SVN как ветки, добавляя к имени тега префикс &lt;code&gt;tags/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c215580302a5f52c2e27d45d0d7c1d84a4eccdbe" translate="yes" xml:space="preserve">
          <source>In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0</source>
          <target state="translated">В Thunderbird 2:Edit...Preferences...Composition,оберните обычные текстовые сообщения на 0</target>
        </trans-unit>
        <trans-unit id="f440374532f0b3d43494a1b042e56f8d4bce5f5d" translate="yes" xml:space="preserve">
          <source>In Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for &quot;mail.wrap_long_lines&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;. Also, search for &quot;mailnews.wraplength&quot; and set the value to 0.</source>
          <target state="translated">В Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Найдите &quot;mail.wrap_long_lines&quot;. Переключите его, чтобы убедиться, что установлено значение &lt;code&gt;false&lt;/code&gt; . Также найдите &quot;mailnews.wraplength&quot; и установите значение 0.</target>
        </trans-unit>
        <trans-unit id="17583a69f7262368825714769d6089546a690b45" translate="yes" xml:space="preserve">
          <source>In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.</source>
          <target state="translated">В быстром обновлении с А на Б набор коммитов,на котором построен первоначальный коммит А,является подмножеством коммитов,на которых построен новый коммит Б.Следовательно,он не теряет своей истории.</target>
        </trans-unit>
        <trans-unit id="3d5b5c31f19f75af08174ee7bc83bae8bb6f0e50" translate="yes" xml:space="preserve">
          <source>In a normal repository, this tends to work automatically. The objects are mostly reachable from the branches and tags, and that&amp;rsquo;s what clients fetch. Any deltas we find on the server are likely to be between objects the client has or will have.</source>
          <target state="translated">В обычном репозитории это обычно работает автоматически. Объекты в основном доступны из веток и тегов, и это то, что получают клиенты. Любые дельты, которые мы обнаруживаем на сервере, скорее всего, будут между объектами, которые есть или будут у клиента.</target>
        </trans-unit>
        <trans-unit id="566e8925a0c194716258bb9a397f522567172cf6" translate="yes" xml:space="preserve">
          <source>In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:</source>
          <target state="translated">В ситуации,когда тема состояла из трех коммитов,а мейнтейнер применил два из них,ситуация может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="ee8b5fc930f29435d4aa076d7196ceac4e277fb2" translate="yes" xml:space="preserve">
          <source>In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done (either merged to the &quot;release&quot; branch, or sent out and accepted upstream).</source>
          <target state="translated">В рабочем процессе,использующем относительно долгоживущие тематические ветки,разработчику иногда приходится разрешать одни и те же конфликты снова и снова до тех пор,пока тематические ветки не будут выполнены (либо слиты в ветку &quot;релиз&quot;,либо отправлены и приняты вверх по течению).</target>
        </trans-unit>
        <trans-unit id="f7c91952cc20e93e498fb039cc3dfb4469b10f04" translate="yes" xml:space="preserve">
          <source>In addition there are a number of other widely deployed hosting, browsing and reviewing solutions such as:</source>
          <target state="translated">Кроме того,существует ряд других широко распространенных решений для хостинга,просмотра и обзора,таких как:</target>
        </trans-unit>
        <trans-unit id="666628046a18a0e7af967b1de7c1a7d7baa813ae" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--full-index&lt;/code&gt;, output a binary diff that can be applied with &lt;code&gt;git-apply&lt;/code&gt;. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">В дополнение к &lt;code&gt;--full-index&lt;/code&gt; вывести двоичный файл diff, который можно применить с помощью &lt;code&gt;git-apply&lt;/code&gt; . Подразумевается &lt;code&gt;--patch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f6c767f6bc5922d93e508ae1661b26c77720a8f" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;-M&lt;/code&gt;, detect lines moved or copied from other files that were modified in the same commit. This is useful when you reorganize your program and move code around across files. When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit.</source>
          <target state="translated">В дополнение к &lt;code&gt;-M&lt;/code&gt; обнаруживать строки, перемещенные или скопированные из других файлов, которые были изменены в той же фиксации. Это полезно, когда вы реорганизуете свою программу и перемещаете код между файлами. Если этот параметр задан дважды, команда дополнительно ищет копии из других файлов в фиксации, создавшей файл. Когда эта опция указана три раза, команда дополнительно ищет копии из других файлов в любом коммите.</target>
        </trans-unit>
        <trans-unit id="1888d5f31940dfed593ca4ff2d62ba84db0ce760" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;.gitattributes&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/attributes&lt;/code&gt;, Git looks into this file for attributes (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). Path expansions are made the same way as for &lt;code&gt;core.excludesFile&lt;/code&gt;. Its default value is &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; is used instead.</source>
          <target state="translated">В дополнение к &lt;code&gt;.gitattributes&lt;/code&gt; (для каждого каталога) и &lt;code&gt;.git/info/attributes&lt;/code&gt; , Git просматривает этот файл на предмет атрибутов (см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; ). Расширения пути выполняются так же, как и для &lt;code&gt;core.excludesFile&lt;/code&gt; . Его значение по умолчанию - &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt; . Если &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; не задан или пуст, вместо него используются &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a80ff33db6a243344cb7df3dd9b8d8d41e916e5f" translate="yes" xml:space="preserve">
          <source>In addition to HEAD, there are several other special names for commits:</source>
          <target state="translated">В дополнение к HEAD,есть несколько других специальных имен для коммитов:</target>
        </trans-unit>
        <trans-unit id="3d952784176d6003ec5b2f9f790384bd9b8c8247" translate="yes" xml:space="preserve">
          <source>In addition to being the staging area for new commits, the index file is also populated from the object database when checking out a branch, and is used to hold the trees involved in a merge operation. See &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; and the relevant man pages for details.</source>
          <target state="translated">Помимо того, что индексный файл является промежуточной областью для новых коммитов, он также заполняется из базы данных объектов при извлечении ветви и используется для хранения деревьев, участвующих в операции слияния. См. &lt;a href=&quot;gitcore-tutorial&quot;&gt;Gitcore-tutorial [7]&lt;/a&gt; и соответствующие справочные страницы для подробностей.</target>
        </trans-unit>
        <trans-unit id="e26ec25b7f02c15aecd179e2dad4bd1f6afe8d5c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20.</source>
          <target state="translated">В дополнение к названиям ветвей,заполните сообщение журнала максимум указанным количеством однострочных описаний из реальных коммитов,которые сливаются.По умолчанию значением по умолчанию является false,а значением по умолчанию true является синоним 20.</target>
        </trans-unit>
        <trans-unit id="c5e07d7771d3e15091a04a68ed9a697dc979376c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from at most &amp;lt;n&amp;gt; actual commits that are being merged. See also &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg[1]&lt;/a&gt;.</source>
          <target state="translated">Помимо имен веток, заполните сообщение журнала однострочными описаниями максимум &amp;lt;n&amp;gt; фактических коммитов, которые объединяются. См. Также &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53e8184a4fded8ffd5d3887baaffe37015550f76" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged. At most &amp;lt;n&amp;gt; commits from each merge parent will be used (20 if &amp;lt;n&amp;gt; is omitted). This overrides the &lt;code&gt;merge.log&lt;/code&gt; configuration variable.</source>
          <target state="translated">Помимо имен веток, заполните сообщение журнала однострочными описаниями фактических объединяемых коммитов. Будет использовано не более &amp;lt;n&amp;gt; коммитов от каждого родителя слияния (20, если &amp;lt;n&amp;gt; опущено). Это переопределяет переменную конфигурации &lt;code&gt;merge.log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6235bcb46867554949f149e203ea63eff52ea516" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with the branch description text associated with them. Defaults to false.</source>
          <target state="translated">В дополнение к названиям филиалов,заполните сообщение журнала текстом описания филиала,связанным с ними.По умолчанию используется значение по умолчанию false.</target>
        </trans-unit>
        <trans-unit id="f62e3d2f843321847fb42ac94f40312c54d52ccf" translate="yes" xml:space="preserve">
          <source>In addition to labelling blobs and commits with mark ids, also label tags. This is useful in conjunction with &lt;code&gt;--export-marks&lt;/code&gt; and &lt;code&gt;--import-marks&lt;/code&gt;, and is also useful (and necessary) for exporting of nested tags. It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers.</source>
          <target state="translated">Помимо маркировки BLOB-объектов и коммитов с помощью идентификаторов меток, также метки меток. Это полезно в сочетании с &lt;code&gt;--export-marks&lt;/code&gt; и &lt;code&gt;--import-marks&lt;/code&gt; , а также полезно (и необходимо) для экспорта вложенных тегов. Это не повредит другим случаям и будет использоваться по умолчанию, но многие интерфейсы быстрого импорта не готовы принимать теги с идентификаторами меток.</target>
        </trans-unit>
        <trans-unit id="22782295e6ea8ee2d620246684c55c016d61141f" translate="yes" xml:space="preserve">
          <source>In addition to objects reachable from any of our references, keep objects reachable from listed &amp;lt;head&amp;gt;s.</source>
          <target state="translated">В дополнение к объектам, доступным по любой из наших ссылок, сохраните объекты доступными из перечисленных &amp;lt;head&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="99c28f63ba36fb0fcaa38897708f95d9a693e369" translate="yes" xml:space="preserve">
          <source>In addition to saving you keystrokes, &lt;code&gt;git pull&lt;/code&gt; also helps you by producing a default commit message documenting the branch and repository that you pulled from.</source>
          <target state="translated">Помимо сохранения нажатий клавиш, &lt;code&gt;git pull&lt;/code&gt; также помогает вам, создавая сообщение фиксации по умолчанию, документирующее ветку и репозиторий, из которых вы извлекли.</target>
        </trans-unit>
        <trans-unit id="7129d0d8ea665296c3d9391d29a173f1ab2fc5f1" translate="yes" xml:space="preserve">
          <source>In addition to searching in the tracked files in the working tree, search also in untracked files.</source>
          <target state="translated">Помимо поиска в отслеживаемых файлах в рабочем дереве,поиск осуществляется также в неотслеживаемых файлах.</target>
        </trans-unit>
        <trans-unit id="d5b7aa3ae2fa07bc2a7838db49f832f9fd332a95" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; markers, it uses another &lt;code&gt;|||||||&lt;/code&gt; marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original.</source>
          <target state="translated">Помимо &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; , он использует еще один &lt;code&gt;|||||||&lt;/code&gt; маркер, за которым следует исходный текст. Вы можете сказать, что оригинал просто констатировал факт, и ваша сторона просто уступила этому заявлению и сдалась, в то время как другая сторона пыталась иметь более позитивное отношение. Иногда можно получить лучшее разрешение, просмотрев оригинал.</target>
        </trans-unit>
        <trans-unit id="3a9ee73184ef3bce8e3d7aa50aca9c03ee962a97" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; listed on the command line, read them from the standard input. If a &lt;code&gt;--&lt;/code&gt; separator is seen, stop reading commits and start reading paths to limit the result.</source>
          <target state="translated">Помимо &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; , перечисленных в командной строке, прочтите их со стандартного ввода. Если &lt;code&gt;--&lt;/code&gt; разделитель видно, прекратить чтение фиксаций и начать читать пути , чтобы ограничить результат.</target>
        </trans-unit>
        <trans-unit id="e57f382f37af963780a48b9b24f281a677f73e3f" translate="yes" xml:space="preserve">
          <source>In addition to the above settings, you can change whether TREESAME affects inclusion:</source>
          <target state="translated">В дополнение к вышеперечисленным настройкам,вы можете изменить,влияет ли TREESAME на включение:</target>
        </trans-unit>
        <trans-unit id="15a1839e21183f6c87dd1989058c966575a3a5b3" translate="yes" xml:space="preserve">
          <source>In addition to the above two patterns, we also expect that all files in the root directory are included. If a recursive pattern is added, then all leading directories are added as parent patterns.</source>
          <target state="translated">В дополнение к двум вышеуказанным шаблонам,мы также ожидаем,что все файлы в корневой директории будут включены.Если добавляется рекурсивный шаблон,то все ведущие каталоги добавляются как родительские.</target>
        </trans-unit>
        <trans-unit id="5cdd7d140b9026d9dc5fc6d397fdc9a74057bb4e" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field.</source>
          <target state="translated">В дополнение к сказанному выше, для фиксации и тегов объектов, имена полей заголовка ( &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;parent&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; и &lt;code&gt;tag&lt;/code&gt; ) может быть использован для указания значения в поле заголовка.</target>
        </trans-unit>
        <trans-unit id="4a3a21fa25ba67eb3d7f9da7f4344fe1b071989c" translate="yes" xml:space="preserve">
          <source>In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of &lt;code&gt;git diff --cached&lt;/code&gt;). If &lt;code&gt;-v&lt;/code&gt; is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of &lt;code&gt;git diff&lt;/code&gt;).</source>
          <target state="translated">В дополнение к именам файлов, которые были изменены, также отображаются текстовые изменения, которые должны быть зафиксированы (например, как результат &lt;code&gt;git diff --cached&lt;/code&gt; ). Если &lt;code&gt;-v&lt;/code&gt; указано дважды, то также отображаются изменения в рабочем дереве, которые еще не были подготовлены (например, как результат &lt;code&gt;git diff&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d2884340103002807461c187c73c074fbbd3657" translate="yes" xml:space="preserve">
          <source>In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref. Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote.</source>
          <target state="translated">В дополнение к объекту,на который он указывает,показать ссылку,на которую он указывает,когда показывает символическую ссылку.В настоящее время загружаемый пакет показывает только симреф HEAD,так что он будет единственным,показываемым ls-remote.</target>
        </trans-unit>
        <trans-unit id="6c7a07603f44cd9719a4b680d9f7256b9473029e" translate="yes" xml:space="preserve">
          <source>In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out.</source>
          <target state="translated">В дополнение к патчам сгенерируйте файл сопроводительного письма,содержащий описание ветки,шорт-лог и общий дифстат.Вы можете заполнить описание в файле перед отправкой.</target>
        </trans-unit>
        <trans-unit id="102ba20e10a0928862b597a4b85d8411aa7a16cb" translate="yes" xml:space="preserve">
          <source>In addition to the text-based messages available in &lt;code&gt;GIT_TRACE2&lt;/code&gt;, this setting writes a column-based format for understanding nesting regions. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">В дополнение к текстовым сообщениям, доступным в &lt;code&gt;GIT_TRACE2&lt;/code&gt; , этот параметр записывает формат на основе столбцов для понимания областей вложенности. См. &lt;code&gt;GIT_TRACE2&lt;/code&gt; для доступных опций вывода трассировки и &lt;a href=&quot;api-trace2&quot;&gt;документацию Trace2&lt;/a&gt; для полной информации.</target>
        </trans-unit>
        <trans-unit id="547bdce4dd37bfda9e1c54bdf493ad3c6de08ff9" translate="yes" xml:space="preserve">
          <source>In addition, any unrecognized string that has a &lt;code&gt;%&lt;/code&gt; in it is interpreted as if it has &lt;code&gt;tformat:&lt;/code&gt; in front of it. For example, these two are equivalent:</source>
          <target state="translated">Кроме того, любая нераспознанная строка, в которой есть &lt;code&gt;%&lt;/code&gt; , интерпретируется так, как если бы &lt;code&gt;tformat:&lt;/code&gt; ней был tformat : . Например, эти два эквивалента:</target>
        </trans-unit>
        <trans-unit id="bc74e38407c657e1d62a835de829f2a0637ff932" translate="yes" xml:space="preserve">
          <source>In addition, if the variable is set to &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt;, Git will try to open the path as a Unix Domain Socket. The socket type can be either &lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;dgram&lt;/code&gt;.</source>
          <target state="translated">Кроме того, если для переменной задано значение &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt; , Git попытается открыть путь как сокет домена Unix. Тип сокета может быть либо &lt;code&gt;stream&lt;/code&gt; либо &lt;code&gt;dgram&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdc73bece50193400c9954e5c33b0d5db46ea312" translate="yes" xml:space="preserve">
          <source>In addition, some Git commands (such as &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; and &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;) can also take revision parameters which denote other objects than commits, e.g. blobs (&quot;files&quot;) or trees (&quot;directories of files&quot;).</source>
          <target state="translated">Кроме того, некоторые команды Git (такие как &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; ) также могут принимать параметры ревизии, которые обозначают другие объекты, кроме коммитов, например капли (&amp;laquo;файлы&amp;raquo;) или деревья (&amp;laquo;каталоги файлов&amp;raquo; ).</target>
        </trans-unit>
        <trans-unit id="9c0114752cc3965279675b92f9d509a7719a899c" translate="yes" xml:space="preserve">
          <source>In addition, the date part is accepted in the following formats: &lt;code&gt;YYYY.MM.DD&lt;/code&gt;, &lt;code&gt;MM/DD/YYYY&lt;/code&gt; and &lt;code&gt;DD.MM.YYYY&lt;/code&gt;.</source>
          <target state="translated">Кроме того, часть даты принимается в следующих форматах: &lt;code&gt;YYYY.MM.DD&lt;/code&gt; , &lt;code&gt;MM/DD/YYYY&lt;/code&gt; и &lt;code&gt;DD.MM.YYYY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b090b5874a4f9cb2a75963ffefe67f7cff33a14b" translate="yes" xml:space="preserve">
          <source>In addition, the following pairs of options are incompatible:</source>
          <target state="translated">Кроме того,следующие пары опционов несовместимы:</target>
        </trans-unit>
        <trans-unit id="c9eac4f7a75d08c8d5ecd2f93cae76dbdd2c65fb" translate="yes" xml:space="preserve">
          <source>In addition, there are a number of optional keys:</source>
          <target state="translated">Кроме того,имеется ряд дополнительных клавиш:</target>
        </trans-unit>
        <trans-unit id="3170175bde47695f8d16d1aa859fc39830538d4d" translate="yes" xml:space="preserve">
          <source>In all &quot;keep index&quot; cases, the index entry stays as in the original index file. If the entry is not up to date, &lt;code&gt;git read-tree&lt;/code&gt; keeps the copy in the work tree intact when operating under the -u flag.</source>
          <target state="translated">Во всех случаях &amp;laquo;сохранить индекс&amp;raquo; запись индекса остается такой же, как в исходном индексном файле. Если запись устарела, &lt;code&gt;git read-tree&lt;/code&gt; сохраняет копию в рабочем дереве нетронутой при работе с флагом -u.</target>
        </trans-unit>
        <trans-unit id="518e45973547d44ae8b0cf643cea7c8e1439a6f7" translate="yes" xml:space="preserve">
          <source>In all of these cases, the commands themselves first optionally limit the two sets of files by any pathspecs given on their command-lines, and compare corresponding paths in the two resulting sets of files.</source>
          <target state="translated">Во всех этих случаях сами команды сначала опционально ограничивают два набора файлов любыми указанными в их командных строках путями,а затем сравнивают соответствующие пути в двух результирующих наборах файлов.</target>
        </trans-unit>
        <trans-unit id="a976d8376129a573bbe9b45628bf2bdf5e1fe7e1" translate="yes" xml:space="preserve">
          <source>In an environment that restricts the users' access only to git commands over the wire, this hook can be used to implement access control without relying on filesystem ownership and group membership. See &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt; for how you might use the login shell to restrict the user&amp;rsquo;s access to only git commands.</source>
          <target state="translated">В среде, которая ограничивает доступ пользователей только к командам git по сети, этот хук можно использовать для реализации контроля доступа, не полагаясь на владение файловой системой и членство в группе. См. &lt;a href=&quot;git-shell&quot;&gt;Git-shell [1],&lt;/a&gt; чтобы узнать, как можно использовать оболочку входа в систему, чтобы ограничить доступ пользователя только командами git.</target>
        </trans-unit>
        <trans-unit id="9220471bbc29ec41ed13c216a79cb80f852ef698" translate="yes" xml:space="preserve">
          <source>In any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error. It returns an empty string instead.</source>
          <target state="translated">В любом случае,имя поля,которое ссылается на поле,неприменимое к объекту,на который ссылается ссылка,не вызывает ошибки.Вместо этого оно возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="55cc553818c07e93d42b2d9a9da22e8f0487ba9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">В обоих форматах &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; - любое из выражений спецификации фиксации, также принимаемых &lt;code&gt;from&lt;/code&gt; (см. Выше).</target>
        </trans-unit>
        <trans-unit id="9838d0f6a0615e5345bacba941fa3a7ae58fc03e" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is the type of file entry, specified in octal. Git only supports the following modes:</source>
          <target state="translated">В обоих форматах &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; - это тип записи файла, указанный в восьмеричном формате. Git поддерживает только следующие режимы:</target>
        </trans-unit>
        <trans-unit id="e124f640b7099c2dfc555e83763a437b341aea9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is the complete path of the file to be added (if not already existing) or modified (if already existing).</source>
          <target state="translated">В обоих форматах &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; - это полный путь к файлу, который нужно добавить (если он еще не существует) или изменить (если уже существует).</target>
        </trans-unit>
        <trans-unit id="e22465a192b99fdb8a38ceb6e2163b1bb2a55eaa" translate="yes" xml:space="preserve">
          <source>In both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line. The temporary file names are always safe strings; they will never contain directory separators or whitespace characters. The path field is always relative to the current directory and the temporary file names are always relative to the top level directory.</source>
          <target state="translated">В обоих форматах RS (разделитель записей)по умолчанию является новой строкой,но будет нулевым байтом,если в командной строке был передан -z.Имена временных файлов всегда являются безопасными строками;они никогда не будут содержать разделители каталогов или пробельные символы.Поле пути всегда относительно текущего каталога,а имена временных файлов всегда относительно каталога верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="bbdfd88cae7c8d5fe4027454edb7c9f3a518f214" translate="yes" xml:space="preserve">
          <source>In both rename and copy detection, the same &quot;extent of changes&quot; algorithm used in diffcore-break is used to determine if two files are &quot;similar enough&quot;, and can be customized to use a similarity score different from the default of 50% by giving a number after the &quot;-M&quot; or &quot;-C&quot; option (e.g. &quot;-M8&quot; to tell it to use 8/10 = 80%).</source>
          <target state="translated">Как при переименовании,так и при обнаружении копирования,один и тот же алгоритм &quot;степени изменений&quot;,используемый в diffcore-break,используется для определения того,являются ли два файла &quot;достаточно похожими&quot;,и может быть настроен на использование оценки схожести,отличной от значения по умолчанию в 50%,путем указания числа после опции &quot;-M&quot; или &quot;-C&quot; (например,&quot;-M8&quot;,чтобы сказать ему использовать 8/10=80%).</target>
        </trans-unit>
        <trans-unit id="cef1680a7a27c73f800aa2ae728f37bb9ebeed5c" translate="yes" xml:space="preserve">
          <source>In case &amp;lt;old&amp;gt; and &amp;lt;new&amp;gt; are the same, and &amp;lt;old&amp;gt; is a file under &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; or &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;, the remote is converted to the configuration file format.</source>
          <target state="translated">В случае, если &amp;lt;old&amp;gt; и &amp;lt;new&amp;gt; совпадают, а &amp;lt;old&amp;gt; - это файл в &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; или &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; , пульт преобразуется в формат файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="3736cf7c9e88d8830feeb4facce5d47bac7822e0" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items user.name and user.email, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="translated">Если (некоторые из) эти переменные среды не заданы, информация берется из элементов конфигурации user.name и user.email, или, если нет, из переменной среды EMAIL, или, если она не задана, из системного пользователя имя и имя хоста, используемое для исходящей почты (берется из &lt;code&gt;/etc/mailname&lt;/code&gt; и возвращается к полному имени хоста, если этот файл не существует).</target>
        </trans-unit>
        <trans-unit id="fab172a52a0d96a15d352f159439993a534e8fe5" translate="yes" xml:space="preserve">
          <source>In case of conflict, &lt;code&gt;git rebase&lt;/code&gt; will stop at the first problematic commit and leave conflict markers in the tree. You can use &lt;code&gt;git diff&lt;/code&gt; to locate the markers (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with</source>
          <target state="translated">В случае конфликта &lt;code&gt;git rebase&lt;/code&gt; остановится при первой проблемной фиксации и оставит маркеры конфликта в дереве. Вы можете использовать &lt;code&gt;git diff&lt;/code&gt; , чтобы найти маркеры (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;) и внести изменения, чтобы разрешить конфликт. Для каждого файла, который вы редактируете, вам нужно сообщить Git, что конфликт разрешен, обычно это делается с помощью</target>
        </trans-unit>
        <trans-unit id="8de3ddb587a19db9387af113a7f3cb72b19328d0" translate="yes" xml:space="preserve">
          <source>In case of failure in the output of &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt;, show directions on how to proceed from the current state.</source>
          <target state="translated">В случае сбоя в выводе &lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt; , покажите инструкции, как действовать из текущего состояния.</target>
        </trans-unit>
        <trans-unit id="1ca6e2b22c66fb3bb4920e7b16e070cab433e13d" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content as well as any future content for the lifetime of the Git process, then it is expected to respond with an &quot;abort&quot; status at any point in the protocol.</source>
          <target state="translated">В случае,если фильтр не может или не хочет обрабатывать содержимое,а также любое будущее содержимое на протяжении всего срока действия Git-процесса,ожидается,что в любой момент в протоколе он будет отвечать со статусом &quot;abort&quot;.</target>
        </trans-unit>
        <trans-unit id="a44b155f3278323b322b1edffc06fec805c87137" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content, it is expected to respond with an &quot;error&quot; status.</source>
          <target state="translated">В случае,если фильтр не может или не хочет обрабатывать содержимое,ожидается,что он ответит со статусом &quot;ошибка&quot;.</target>
        </trans-unit>
        <trans-unit id="063d2c577358a9002bf9810cc43ec764ca0682e1" translate="yes" xml:space="preserve">
          <source>In command synopses, the word &quot;tree-ish&quot; is sometimes used to designate such an argument.</source>
          <target state="translated">В командных синопсах слово &quot;tree-ish&quot; иногда используется для обозначения такого аргумента.</target>
        </trans-unit>
        <trans-unit id="0cb56babf143d18da14e8d5b38b880de0eb432ae" translate="yes" xml:space="preserve">
          <source>In compact output mode, specified with configuration variable fetch.output, if either entire &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; is found in the other string, it will be substituted with &lt;code&gt;*&lt;/code&gt; in the other string. For example, &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; becomes &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt;.</source>
          <target state="translated">В компактном режиме вывода, заданном с помощью переменной конфигурации fetch.output, если в другой строке находится либо весь &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; , либо &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; , он будет заменен на &lt;code&gt;*&lt;/code&gt; в другой строке. Например, &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; становится &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a206b483cbd4faf3ff1c681d69d041ba456195" translate="yes" xml:space="preserve">
          <source>In contrast to a regular interactive rebase, there are &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; commands in addition to &lt;code&gt;pick&lt;/code&gt; ones.</source>
          <target state="translated">В отличие от обычного интерактивного перебазирования, в дополнение к командам &lt;code&gt;pick&lt;/code&gt; есть команды &lt;code&gt;label&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; и &lt;code&gt;merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a91f8ccdcda758152dfb84f7e032555a6abd0478" translate="yes" xml:space="preserve">
          <source>In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:</source>
          <target state="translated">Напротив,непередаваемое обновление потеряет историю.Например,предположим,что вы и кто-то другой запустили один и тот же коммит X,и вы построили историю,ведущую к коммиту B,в то время как другой человек построил историю,ведущую к коммиту A.История выглядит так:</target>
        </trans-unit>
        <trans-unit id="07b2f985753911580a2527f5513df7870e7e2eaf" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has 10\^5 files and 10\^5 commits, but each commit only modifies 5 files, then git-filter-branch will make you do 10\^10 modifications, despite only having (at most) 5*10^5 unique blobs.</source>
          <target state="translated">При редактировании файлов git-фильтр по замыслу проверяет каждый коммит в том виде,в каком он существовал в исходном репо.Если в вашем репо есть 10\^5 файлов и 10\^5 коммитов,но каждый коммит модифицирует только 5 файлов,то git-фильтр заставит вас делать модификации 10\^10,несмотря на то,что у вас есть только (максимум)5*10^5 уникальных блоков.</target>
        </trans-unit>
        <trans-unit id="a532459a44f155e770ddc46e416638b81292d839" translate="yes" xml:space="preserve">
          <source>In either format, values can be specified in any form that Git recognizes as an object name. Commands in any other format or a repeated &amp;lt;ref&amp;gt; produce an error. Command meanings are:</source>
          <target state="translated">В любом формате значения могут быть указаны в любой форме, которую Git распознает как имя объекта. Команды в любом другом формате или повторение &amp;lt;ref&amp;gt; вызывают ошибку. Значения команд:</target>
        </trans-unit>
        <trans-unit id="9c49e183be0df7128f7b7d238522888866505455" translate="yes" xml:space="preserve">
          <source>In fact development teams often maintain both a development branch and a maintenance branch, and it would be quite easy for them if &quot;git bisect&quot; just worked when they want to bisect a regression on the development branch that is not on the maintenance branch. They should be able to start bisecting using:</source>
          <target state="translated">На самом деле,команды разработчиков часто содержат и ветку разработки,и ветку обслуживания,и для них было бы довольно легко,если бы &quot;git-биссект&quot; просто работал,когда они хотят разбить биссектрису на ветку разработки,которой нет в ветке обслуживания.Они должны иметь возможность начать использовать биссектрису:</target>
        </trans-unit>
        <trans-unit id="49c9270dc1d07096e092a06d8107784ae1248f61" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s invaluable because there are bugs i would never even &lt;code&gt;try&lt;/code&gt; to debug if it wasn&amp;rsquo;t for git bisect. In the past there were bug patterns that were immediately hopeless for me to debug - at best i could send the crash/bug signature to lkml and hope that someone else can think of something.</source>
          <target state="translated">На самом деле это бесценно, потому что есть ошибки, которые я бы даже не &lt;code&gt;try&lt;/code&gt; отлаживать, если бы не git bisect. В прошлом были шаблоны ошибок, отладить которые мне сразу было безнадежно - в лучшем случае я мог отправить сигнатуру сбоя / ошибки в lkml и надеяться, что кто-то еще что-нибудь придумает.</target>
        </trans-unit>
        <trans-unit id="4d0defa9e6e327fdaa3580beb798bb05e9bb4ad4" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s this last feature that &quot;sold&quot; it to the Git community, so it is now in the &quot;master&quot; branch of Git&amp;rsquo;s Git repository and it should be released in Git 1.6.5 in October or November 2009.</source>
          <target state="translated">Фактически, именно эта последняя функция &amp;laquo;продала&amp;raquo; ее сообществу Git, поэтому теперь она находится в &amp;laquo;главной&amp;raquo; ветви репозитория Git Git и должна быть выпущена в Git 1.6.5 в октябре или ноябре 2009 года.</target>
        </trans-unit>
        <trans-unit id="a503332ebe0b76ca226cc7fab9355da1cbc846ca" translate="yes" xml:space="preserve">
          <source>In fact people are specially interested in commits that introduce a &quot;bad&quot; behavior, called a bug or a regression. They are interested in these commits because a commit (hopefully) contains a very small set of source code changes. And it&amp;rsquo;s much easier to understand and properly fix a problem when you only need to check a very small set of changes, than when you don&amp;rsquo;t know where look in the first place.</source>
          <target state="translated">На самом деле людей особенно интересуют коммиты, которые приводят к &amp;laquo;плохому&amp;raquo; поведению, называемому ошибкой или регрессом. Они заинтересованы в этих коммитах, потому что коммит (надеюсь) содержит очень небольшой набор изменений исходного кода. И гораздо легче понять и правильно исправить проблему, когда вам нужно проверить только очень небольшой набор изменений, чем когда вы не знаете, куда смотреть в первую очередь.</target>
        </trans-unit>
        <trans-unit id="ef62eb9471b68497e696b504f306bae12d5b62ac" translate="yes" xml:space="preserve">
          <source>In fact the problem is that big software often has many different configuration options and that each test case should pass for each configuration after each commit. So if you have for each release: N configurations, M commits and T test cases, you should perform:</source>
          <target state="translated">На самом деле проблема заключается в том,что большое программное обеспечение часто имеет много различных вариантов конфигурации,и что каждый тестовый случай должен пройти для каждой конфигурации после каждого коммита.Поэтому,если у вас есть для каждого релиза:N конфигураций,M коммитов и T тестовых примеров,вы должны выполнить:</target>
        </trans-unit>
        <trans-unit id="99977c45d37760acd8d4612dba46dd63b60c39cd" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git bisect&lt;/code&gt; can be used to find the commit that changed &lt;strong&gt;any&lt;/strong&gt; property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark&amp;rsquo;s performance to improve. To support this more general usage, the terms &quot;old&quot; and &quot;new&quot; can be used in place of &quot;good&quot; and &quot;bad&quot;, or you can choose your own terms. See section &quot;Alternate terms&quot; below for more information.</source>
          <target state="translated">Фактически, &lt;code&gt;git bisect&lt;/code&gt; можно использовать для поиска фиксации, которая изменила &lt;strong&gt;любое&lt;/strong&gt; свойство вашего проекта; например, фиксация, исправившая ошибку, или фиксация, которая привела к повышению производительности теста. Чтобы поддержать это более общее использование, термины &amp;laquo;старый&amp;raquo; и &amp;laquo;новый&amp;raquo; могут использоваться вместо &amp;laquo;хорошего&amp;raquo; и &amp;laquo;плохого&amp;raquo;, или вы можете выбрать свои собственные термины. См. Раздел &amp;laquo;Альтернативные условия&amp;raquo; ниже для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7071f9821fe5bdd2a61f333d551d92b1d1a7cc62" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git diff-index --cached&lt;/code&gt;&lt;strong&gt;should&lt;/strong&gt; always be entirely equivalent to actually doing a &lt;code&gt;git write-tree&lt;/code&gt; and comparing that. Except this one is much nicer for the case where you just want to check where you are.</source>
          <target state="translated">Фактически, &lt;code&gt;git diff-index --cached&lt;/code&gt; всегда &lt;strong&gt;должен&lt;/strong&gt; быть полностью эквивалентен фактическому созданию &lt;code&gt;git write-tree&lt;/code&gt; и его сравнению. За исключением того, что этот гораздо лучше для случая, когда вы просто хотите проверить, где вы находитесь.</target>
        </trans-unit>
        <trans-unit id="4ed30cb15a7bebad154936439885b3df49088a74" translate="yes" xml:space="preserve">
          <source>In fact, as you did that, if you now look into your object directory, you&amp;rsquo;ll notice that Git will have added two new objects to the object database. If you did exactly the steps above, you should now be able to do</source>
          <target state="translated">Фактически, когда вы это сделали, если вы теперь заглянете в свой каталог объектов, вы заметите, что Git добавит два новых объекта в базу данных объектов. Если вы выполнили точно указанные выше действия, теперь вы сможете</target>
        </trans-unit>
        <trans-unit id="c9492aea4e59a8249b05f0197902254019664286" translate="yes" xml:space="preserve">
          <source>In fact, if you have &lt;code&gt;master&lt;/code&gt; checked out, then this branch has been configured by &lt;code&gt;git clone&lt;/code&gt; to get changes from the HEAD branch of the origin repository. So often you can accomplish the above with just a simple</source>
          <target state="translated">Фактически, если у вас есть &lt;code&gt;master&lt;/code&gt; , то эта ветка была настроена с помощью &lt;code&gt;git clone&lt;/code&gt; для получения изменений из ветки HEAD исходного репозитория. Очень часто вы можете выполнить вышеперечисленное с помощью простого</target>
        </trans-unit>
        <trans-unit id="c5bd224f8ecefe700eae1705d4f2a63ae227649f" translate="yes" xml:space="preserve">
          <source>In fact, in &lt;a href=&quot;#git-concepts&quot;&gt;Git concepts&lt;/a&gt; we shall see that everything stored in Git history, including file data and directory contents, is stored in an object with a name that is a hash of its contents.</source>
          <target state="translated">Фактически, в &lt;a href=&quot;#git-concepts&quot;&gt;концепциях Git&lt;/a&gt; мы увидим, что все, что хранится в истории Git, включая данные файлов и содержимое каталогов, хранится в объекте с именем, которое является хешем его содержимого.</target>
        </trans-unit>
        <trans-unit id="9ce4601e5a5f52f186df099525d9504862a821c8" translate="yes" xml:space="preserve">
          <source>In fact, together with the &lt;code&gt;git rev-list&lt;/code&gt; program (which generates a list of revisions), &lt;code&gt;git diff-tree&lt;/code&gt; ends up being a veritable fount of changes. You can emulate &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git log -p&lt;/code&gt;, etc. with a trivial script that pipes the output of &lt;code&gt;git rev-list&lt;/code&gt; to &lt;code&gt;git diff-tree --stdin&lt;/code&gt;, which was exactly how early versions of &lt;code&gt;git log&lt;/code&gt; were implemented.</source>
          <target state="translated">Фактически, вместе с программой &lt;code&gt;git rev-list&lt;/code&gt; (которая генерирует список ревизий) &lt;code&gt;git diff-tree&lt;/code&gt; оказывается настоящим кладезем изменений. Вы можете эмулировать &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git log -p&lt;/code&gt; и т. Д. С помощью тривиального скрипта, который &lt;code&gt;git diff-tree --stdin&lt;/code&gt; вывод &lt;code&gt;git rev-list&lt;/code&gt; в git diff-tree --stdin , как и были реализованы ранние версии &lt;code&gt;git log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da9de14a63db6e5a8e5a19a81e9a6160f95eb222" translate="yes" xml:space="preserve">
          <source>In fact, we can perform all the normal Git operations. But, let&amp;rsquo;s look at what happens when we then checkout &lt;code&gt;master&lt;/code&gt;:</source>
          <target state="translated">Фактически, мы можем выполнять все обычные операции Git. Но давайте посмотрим, что происходит, когда мы затем проверяем &lt;code&gt;master&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="728d90294e037628a986d3380572564cc895d389" translate="yes" xml:space="preserve">
          <source>In future versions we may learn to support patterns containing \0 for more search backends, until then we&amp;rsquo;ll die when the pattern type in question doesn&amp;rsquo;t support them.</source>
          <target state="translated">В будущих версиях мы можем научиться поддерживать шаблоны, содержащие \ 0, для дополнительных механизмов поиска, до тех пор мы умрем, когда рассматриваемый тип шаблона их не поддерживает.</target>
        </trans-unit>
        <trans-unit id="674a2666658c40a25d4cd65b3ea28af975f1fa97" translate="yes" xml:space="preserve">
          <source>In general a client can request to speak protocol v2 by sending &lt;code&gt;version=2&lt;/code&gt; through the respective side-channel for the transport being used which inevitably sets &lt;code&gt;GIT_PROTOCOL&lt;/code&gt;. More information can be found in &lt;code&gt;pack-protocol.txt&lt;/code&gt; and &lt;code&gt;http-protocol.txt&lt;/code&gt;. In all cases the response from the server is the capability advertisement.</source>
          <target state="translated">Как правило, клиент может запросить передачу по протоколу v2, отправив &lt;code&gt;version=2&lt;/code&gt; через соответствующий побочный канал для используемого транспорта, который неизбежно устанавливает &lt;code&gt;GIT_PROTOCOL&lt;/code&gt; . Дополнительную информацию можно найти в &lt;code&gt;pack-protocol.txt&lt;/code&gt; и &lt;code&gt;http-protocol.txt&lt;/code&gt; . Во всех случаях ответ сервера является объявлением о возможности.</target>
        </trans-unit>
        <trans-unit id="1aaa12db7c29bdac4538baf95940db6bed82a0b8" translate="yes" xml:space="preserve">
          <source>In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.</source>
          <target state="translated">В общем,URL содержат информацию о транспортном протоколе,адресе удаленного сервера и пути к хранилищу.В зависимости от транспортного протокола часть этой информации может отсутствовать.</target>
        </trans-unit>
        <trans-unit id="811906db3a55c059a1cd7d72b959827c93f94a02" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &quot;refs/&quot; are shared. Pseudo refs are ones like HEAD which are directly under GIT_DIR instead of inside GIT_DIR/refs. There is one exception to this: refs inside refs/bisect and refs/worktree is not shared.</source>
          <target state="translated">В общем случае,все псевдо-ссылки относятся к одному рабочему дереву,и все ссылки,начинающиеся с &quot;refs/&quot;,являются общими.Псевдо-справки похожи на HEAD,которые находятся непосредственно под GIT_DIR,а не внутри GIT_DIR/refs.Есть одно исключение:ссылки внутри refs/bisect и refs/worktree не разделяются.</target>
        </trans-unit>
        <trans-unit id="e394e7bf320940c252fcc858f73aeff38e0e3c05" translate="yes" xml:space="preserve">
          <source>In general, it is better to enumerate existing objects with problems with &lt;code&gt;fsck.skipList&lt;/code&gt;, instead of listing the kind of breakages these problematic objects share to be ignored, as doing the latter will allow new instances of the same breakages go unnoticed.</source>
          <target state="translated">В общем, лучше перечислить существующие объекты с проблемами с помощью &lt;code&gt;fsck.skipList&lt;/code&gt; , вместо того, чтобы перечислять виды поломок, которые разделяются этими проблемными объектами, которые следует игнорировать, поскольку выполнение последнего позволит новым экземплярам тех же поломок остаться незамеченными.</target>
        </trans-unit>
        <trans-unit id="7dc03507399a3b4938c051e86309da2b5ba01f5b" translate="yes" xml:space="preserve">
          <source>In general, the interrogate commands do not touch the files in the working tree.</source>
          <target state="translated">В общем случае команды опроса не затрагивают файлы в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="0830c69bce9b1a4ab3ff9dbb3ca0e63e381af048" translate="yes" xml:space="preserve">
          <source>In general, using</source>
          <target state="translated">В общем,используя</target>
        </trans-unit>
        <trans-unit id="37034b2d8b34e79ca4767d593d59ca39d0651fd5" translate="yes" xml:space="preserve">
          <source>In here all submodules except &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob) are active. &lt;code&gt;foo&lt;/code&gt; due to its own active flag and all the others due to the submodule active pathspec, which specifies that any submodule starting with &lt;code&gt;b&lt;/code&gt; except &lt;code&gt;baz&lt;/code&gt; are also active, regardless of the presence of the .url field.</source>
          <target state="translated">Здесь активны все подмодули, кроме &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob). &lt;code&gt;foo&lt;/code&gt; из-за его собственного активного флага, а все остальные из-за активного pathspec подмодуля, который указывает, что любой подмодуль, начинающийся с &lt;code&gt;b&lt;/code&gt; , кроме &lt;code&gt;baz&lt;/code&gt; , также активен, независимо от наличия поля .url.</target>
        </trans-unit>
        <trans-unit id="f129c819372eb3b42173e4b2d9e114ef285b7635" translate="yes" xml:space="preserve">
          <source>In interactive commands, allow the user to provide one-letter input with a single key (i.e., without hitting enter). Currently this is used by the &lt;code&gt;--patch&lt;/code&gt; mode of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;, &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, and &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. Note that this setting is silently ignored if portable keystroke input is not available; requires the Perl module Term::ReadKey.</source>
          <target state="translated">В интерактивных командах разрешите пользователю вводить однобуквенные символы с помощью одной клавиши (т. Е. Без нажатия клавиши ввода). В настоящее время это используется в режиме &lt;code&gt;--patch&lt;/code&gt; для &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; , &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; , &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; , &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; , &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; и &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; . Обратите внимание, что этот параметр автоматически игнорируется, если переносимый ввод нажатием клавиш недоступен; требуется Perl-модуль Term :: ReadKey.</target>
        </trans-unit>
        <trans-unit id="1d1c8ed607ef3eefbb04beacb314688e02741550" translate="yes" xml:space="preserve">
          <source>In interactive mode, you can mark commits with the action &quot;edit&quot;. However, this does not necessarily mean that &lt;code&gt;git rebase&lt;/code&gt; expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:</source>
          <target state="translated">В интерактивном режиме вы можете пометить коммиты с помощью действия &amp;laquo;изменить&amp;raquo;. Однако это не обязательно означает, что &lt;code&gt;git rebase&lt;/code&gt; ожидает, что результатом этого редактирования будет ровно один коммит. Действительно, вы можете отменить коммит или добавить другие коммиты. Это можно использовать для разделения коммита на две части:</target>
        </trans-unit>
        <trans-unit id="15b1add937944ed893f52c8ec0293a4127b76c00" translate="yes" xml:space="preserve">
          <source>In its first form, the command provides the content or the type of an object in the repository. The type is required unless &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; is used to find the object type, or &lt;code&gt;-s&lt;/code&gt; is used to find the object size, or &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; is used (which imply type &quot;blob&quot;).</source>
          <target state="translated">В своей первой форме команда предоставляет содержимое или тип объекта в репозитории. Тип является обязательным, если для поиска типа объекта не используется &lt;code&gt;-t&lt;/code&gt; или &lt;code&gt;-p&lt;/code&gt; , или &lt;code&gt;-s&lt;/code&gt; используется для определения размера объекта, или используется &lt;code&gt;--textconv&lt;/code&gt; или &lt;code&gt;--filters&lt;/code&gt; (что подразумевает тип &quot;blob&quot;).</target>
        </trans-unit>
        <trans-unit id="1ce9842f8f482fa7cd77bb4bd4603b72b75e4e0b" translate="yes" xml:space="preserve">
          <source>In its most compact form, this instruction only takes up one byte (0x80) with both offset and size omitted, which will have default values zero. There is another exception: size zero is automatically converted to 0x10000.</source>
          <target state="translated">В самом компактном виде эта инструкция занимает всего один байт (0x80),при этом опущены как смещение,так и размер,которые будут иметь значения по умолчанию равные нулю.Есть еще одно исключение:размер нуля автоматически конвертируется в 0x10000.</target>
        </trans-unit>
        <trans-unit id="70413e1dbdf33a9cdd6044f089c7e374f7b737c4" translate="yes" xml:space="preserve">
          <source>In mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; &lt;code&gt;1&lt;/code&gt; is matched to &lt;code&gt;C&lt;/code&gt; at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:</source>
          <target state="translated">С математической точки зрения, мы ищем своего рода двустороннее сопоставление с минимальной стоимостью; &lt;code&gt;1&lt;/code&gt; сопоставляется с &lt;code&gt;C&lt;/code&gt; за некоторую плату и т. Д. Базовый граф фактически является полным двудольным графом; Стоимость, которую мы связываем с каждым ребром, - это размер разницы между патчами двух коммитов. Чтобы объяснить также новые коммиты, мы вводим фиктивные узлы с обеих сторон:</target>
        </trans-unit>
        <trans-unit id="abc4a2c282027431dbb87981bf40f5240785d9ef" translate="yes" xml:space="preserve">
          <source>In modern git, you can say this in a more direct way:</source>
          <target state="translated">В современном git'е можно сказать это более прямолинейно:</target>
        </trans-unit>
        <trans-unit id="1cd9dc714cc1317fe8fea12649b27b5eeab6e568" translate="yes" xml:space="preserve">
          <source>In most cases, this means the attributes given in the input will be repeated in the output, but Git may also modify the credential description, for example by removing the &lt;code&gt;path&lt;/code&gt; attribute when the protocol is HTTP(s) and &lt;code&gt;credential.useHttpPath&lt;/code&gt; is false.</source>
          <target state="translated">В большинстве случаев это означает, что атрибуты, указанные во входных данных, будут повторяться в выходных данных, но Git может также изменить описание учетных данных, например, удалив атрибут &lt;code&gt;path&lt;/code&gt; когда протоколом является HTTP (s) и &lt;code&gt;credential.useHttpPath&lt;/code&gt; имеет значение false.</target>
        </trans-unit>
        <trans-unit id="c12479d09bff69f421dbf9e45fddc92269d1f574" translate="yes" xml:space="preserve">
          <source>In most cases, users should run &lt;em&gt;git gc&lt;/em&gt;, which calls &lt;em&gt;git prune&lt;/em&gt;. See the section &quot;NOTES&quot;, below.</source>
          <target state="translated">В большинстве случаев пользователям следует запустить &lt;em&gt;git gc&lt;/em&gt; , который вызывает &lt;em&gt;git prune&lt;/em&gt; . См. Раздел &amp;laquo;ПРИМЕЧАНИЯ&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="6d4e8e52070be526725731839d6ade7553803d5e" translate="yes" xml:space="preserve">
          <source>In most cases, users will not need to call &lt;code&gt;git prune&lt;/code&gt; directly, but should instead call &lt;code&gt;git gc&lt;/code&gt;, which handles pruning along with many other housekeeping tasks.</source>
          <target state="translated">В большинстве случаев пользователям не нужно вызывать &lt;code&gt;git prune&lt;/code&gt; напрямую, вместо этого следует вызывать &lt;code&gt;git gc&lt;/code&gt; , который выполняет обрезку вместе со многими другими служебными задачами.</target>
        </trans-unit>
        <trans-unit id="fa1d2a97ebd3bb9e2d938b11b92fc4a8e0c826fa" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees, some refs are local. One example is HEAD is different for all working trees. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="translated">В нескольких рабочих деревьях некоторые ссылки могут быть разделены между всеми рабочими деревьями,некоторые ссылки являются локальными.Одним из примеров является HEAD,который отличается для всех рабочих деревьев.Этот раздел о правилах совместного использования и о том,как получить доступ к ссылкам одного рабочего дерева из другого.</target>
        </trans-unit>
        <trans-unit id="fef9e754382e4f5002bb7f83483631df5de227e1" translate="yes" xml:space="preserve">
          <source>In older Git versions it could be easily forgotten to commit new or modified files in a submodule, which silently leads to similar problems as not pushing the submodule changes. Starting with Git 1.7.0 both &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git diff&lt;/code&gt; in the superproject show submodules as modified when they contain new or modified files to protect against accidentally committing such a state. &lt;code&gt;git
diff&lt;/code&gt; will also add a &lt;code&gt;-dirty&lt;/code&gt; to the work tree side when generating patch output or used with the &lt;code&gt;--submodule&lt;/code&gt; option:</source>
          <target state="translated">В более старых версиях Git можно легко забыть о фиксации новых или измененных файлов в подмодуле, что незаметно приводит к таким же проблемам, как отказ от внесения изменений в подмодуль. Начиная с Git 1.7.0 и &lt;code&gt;git status&lt;/code&gt; , и &lt;code&gt;git diff&lt;/code&gt; в суперпроекте показывают подмодули как измененные, если они содержат новые или измененные файлы, для защиты от случайной фиксации такого состояния. &lt;code&gt;git diff&lt;/code&gt; также добавит &lt;code&gt;-dirty&lt;/code&gt; на сторону рабочего дерева при генерации вывода патча или использовании с параметром &lt;code&gt;--submodule&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cea51be0687534aeac695491ce11f4552163d8c9" translate="yes" xml:space="preserve">
          <source>In order to allow extensions that add extra data to the MIDX, we organize the body into &quot;chunks&quot; and provide a lookup table at the beginning of the body. The header includes certain length values, such as the number of packs, the number of base MIDX files, hash lengths and types.</source>
          <target state="translated">Для того,чтобы разрешить расширения,которые добавляют дополнительные данные в MIDX,мы организуем кузов в &quot;куски&quot; и предоставляем таблицу поиска в начале кузова.В заголовке указываются определенные значения длины,такие как количество пакетов,количество базовых MIDX-файлов,длины и типы хэшей.</target>
        </trans-unit>
        <trans-unit id="f6b8f2c2e89120a466dd40e221531b6adf7a10b9" translate="yes" xml:space="preserve">
          <source>In order to determine what URL to use to fetch from, the value of the configuration &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; is consulted and if there is not any such variable, the value on the &lt;code&gt;URL:&lt;/code&gt; line in &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">Чтобы определить, какой URL-адрес использовать для выборки, &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; значение конфигурации remote. &amp;lt;origin&amp;gt; .url, и, если такой переменной нет, значение в строке &lt;code&gt;URL:&lt;/code&gt; в &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="1bb65c849d69cb9e41866b99d141938531c8bf39" translate="yes" xml:space="preserve">
          <source>In order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; are consulted, and if there aren&amp;rsquo;t any, &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is consulted and its &lt;code&gt;Pull:&lt;/code&gt; lines are used. In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:</source>
          <target state="translated">Чтобы определить, какие удаленные ветки следует извлекать (и при необходимости сохранять в ветвях удаленного отслеживания), когда команда запускается без каких-либо параметров refspec в командной строке, проверяются значения переменной конфигурации &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; , и если их нет, &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; и используются его строки &lt;code&gt;Pull:&lt;/code&gt; . В дополнение к форматам refspec, описанным в разделе OPTIONS, вы можете иметь подстановку refspec, которая выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b571757e7fe93a92c37f6bdbb5b1d110de433e8f" translate="yes" xml:space="preserve">
          <source>In order to ensure a current tracking branch state, &lt;code&gt;update --remote&lt;/code&gt; fetches the submodule&amp;rsquo;s remote repository before calculating the SHA-1. If you don&amp;rsquo;t want to fetch, you should use &lt;code&gt;submodule update
--remote --no-fetch&lt;/code&gt;.</source>
          <target state="translated">Чтобы гарантировать текущее состояние ветви отслеживания, &lt;code&gt;update --remote&lt;/code&gt; извлекает удаленный репозиторий подмодуля перед вычислением SHA-1. Если вы не хотите получать, вы должны использовать &lt;code&gt;submodule update --remote --no-fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ecc869f1231e06aba76a745114504d0b9155917" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on &quot;worktreeConfig&quot; extension, e.g.:</source>
          <target state="translated">Для того чтобы иметь конфигурацию,специфичную для рабочих деревьев,можно включить расширение &quot;worktreeConfig&quot;,например:</target>
        </trans-unit>
        <trans-unit id="eb76ce16c3a3c52ec0347fc95609ba6324ad6c16" translate="yes" xml:space="preserve">
          <source>In order to protect the privacy of objects that have been removed from history but may not yet have been pruned, &lt;code&gt;git-upload-archive&lt;/code&gt; avoids serving archives for commits and trees that are not reachable from the repository&amp;rsquo;s refs. However, because calculating object reachability is computationally expensive, &lt;code&gt;git-upload-archive&lt;/code&gt; implements a stricter but easier-to-check set of rules:</source>
          <target state="translated">Чтобы защитить конфиденциальность объектов, которые были удалены из истории, но, возможно, еще не были обрезаны, &lt;code&gt;git-upload-archive&lt;/code&gt; избегает обслуживания архивов для коммитов и деревьев, которые недоступны из ссылок репозитория. Однако, поскольку вычисление достижимости объекта требует больших вычислительных ресурсов, &lt;code&gt;git-upload-archive&lt;/code&gt; реализует более строгий, но более простой для проверки набор правил:</target>
        </trans-unit>
        <trans-unit id="17696fe6311cd47e2efc1108f911bdeb8c2c0989" translate="yes" xml:space="preserve">
          <source>In order to set &quot;assume unchanged&quot; bit, use &lt;code&gt;--assume-unchanged&lt;/code&gt; option. To unset, use &lt;code&gt;--no-assume-unchanged&lt;/code&gt;. To see which files have the &quot;assume unchanged&quot; bit set, use &lt;code&gt;git ls-files -v&lt;/code&gt; (see &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt;).</source>
          <target state="translated">Чтобы установить бит &amp;laquo;считать неизменным&amp;raquo;, используйте параметр &lt;code&gt;--assume-unchanged&lt;/code&gt; . Чтобы отключить, используйте &lt;code&gt;--no-assume-unchanged&lt;/code&gt; . Чтобы увидеть, в каких файлах установлен бит &amp;laquo;считать неизменным&amp;raquo;, используйте &lt;code&gt;git ls-files -v&lt;/code&gt; (см. &lt;a href=&quot;git-ls-files&quot;&gt;Git-ls-files [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="267b1e8e9ade7b3919e26586bb280b53787cfd98" translate="yes" xml:space="preserve">
          <source>In other messages Andreas says that they also use the &quot;best practices&quot; described above: small logical commits, topic branches, no evil merge,&amp;hellip;​ These practices all improve the bisectability of the commit graph, by making it easier and more useful to bisect.</source>
          <target state="translated">В других сообщениях Андреас говорит, что они также используют &amp;laquo;лучшие практики&amp;raquo;, описанные выше: небольшие логические коммиты, тематические ветки, отсутствие злого слияния,&amp;hellip; Все эти методы улучшают делимость графа коммитов пополам, делая его проще и полезнее. ,</target>
        </trans-unit>
        <trans-unit id="cbba08cd602a94910294469b1bfe69221cf43d34" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;--merge&lt;/code&gt; does something like a &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt;, but carries forward unmerged index entries.</source>
          <target state="translated">Другими словами, &lt;code&gt;--merge&lt;/code&gt; делает что-то вроде &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt; , но переносит не объединенные записи индекса.</target>
        </trans-unit>
        <trans-unit id="2c3347c08edbf67732cb77724b9990f6671bac50" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-files&lt;/code&gt; always shows us the difference between what is recorded in the index, and what is currently in the working tree. That&amp;rsquo;s very useful.</source>
          <target state="translated">Другими словами, &lt;code&gt;git diff-files&lt;/code&gt; всегда показывает нам разницу между тем, что записано в индексе, и тем, что в настоящее время находится в рабочем дереве. Это очень полезно.</target>
        </trans-unit>
        <trans-unit id="7466e77eb24cbec56937901c0950f635d6a29d08" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-index&lt;/code&gt; normally compares a tree against the working tree, but when given the &lt;code&gt;--cached&lt;/code&gt; flag, it is told to instead compare against just the index cache contents, and ignore the current working tree state entirely. Since we just wrote the index file to HEAD, doing &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; should thus return an empty set of differences, and that&amp;rsquo;s exactly what it does.</source>
          <target state="translated">Другими словами, &lt;code&gt;git diff-index&lt;/code&gt; обычно сравнивает дерево с рабочим деревом, но когда ему &lt;code&gt;--cached&lt;/code&gt; флаг --cached , ему предлагается вместо этого сравнивать только с содержимым индексного кеша и полностью игнорировать текущее рабочее состояние дерева. Поскольку мы только что записали индексный файл в HEAD, выполнение &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; должно вернуть пустой набор различий, и это именно то, что он делает.</target>
        </trans-unit>
        <trans-unit id="8c2ef787b7de3a9f3b5df9786c452fde9692465e" translate="yes" xml:space="preserve">
          <source>In other words, there is no need to worry about what exists only in the working tree. When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact. When they &lt;strong&gt;do&lt;/strong&gt; interfere, the merge does not even start (&lt;code&gt;git read-tree&lt;/code&gt; complains loudly and fails without modifying anything). In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again.</source>
          <target state="translated">Другими словами, не нужно беспокоиться о том, что существует только в рабочем дереве. Когда у вас есть локальные изменения в части проекта, которая не участвует в слиянии, ваши изменения не мешают слиянию и остаются неизменными. Когда они &lt;strong&gt;действительно&lt;/strong&gt; мешают, слияние , даже не запускается ( &lt;code&gt;git read-tree&lt;/code&gt; жалуется громко и не без изменения ничего). В таком случае вы можете просто продолжить делать то, что вы делали в середине, и когда ваше рабочее дерево будет готово (то есть вы закончили незавершенную работу), повторите попытку слияния.</target>
        </trans-unit>
        <trans-unit id="5a674f35b2eda0a90a7f397ea7dadc5a212b7275" translate="yes" xml:space="preserve">
          <source>In other words, while a &quot;tree&quot; represents a particular directory state of a working directory, a &quot;commit&quot; represents that state in time, and explains how we got there.</source>
          <target state="translated">Другими словами,в то время как &quot;дерево&quot; представляет определенное состояние каталога рабочего каталога,&quot;коммит&quot; представляет это состояние во времени и объясняет,как мы туда попали.</target>
        </trans-unit>
        <trans-unit id="857191c898a7fbefd37c145d86f76b0005dd57eb" translate="yes" xml:space="preserve">
          <source>In other words, you can easily validate a whole archive by just sending out a single email that tells the people the name (SHA-1 hash) of the top commit, and digitally sign that email using something like GPG/PGP.</source>
          <target state="translated">Другими словами,вы можете легко проверить весь архив,просто отправив одно письмо,в котором людям сообщается имя (SHA-1 хэш)верхнего коммита,и в цифровом виде подписать это письмо с помощью чего-нибудь вроде GPG/PGP.</target>
        </trans-unit>
        <trans-unit id="e52122aac7e01b0550d02d6bfc5c4fbaa85b48ac" translate="yes" xml:space="preserve">
          <source>In our example of only two files, we did not have unchanged files so only &lt;code&gt;example&lt;/code&gt; resulted in collapsing. But in real-life large projects, when only a small number of files change in one commit, this &lt;code&gt;collapsing&lt;/code&gt; tends to trivially merge most of the paths fairly quickly, leaving only a handful of real changes in non-zero stages.</source>
          <target state="translated">В нашем примере с двумя файлами у нас не было неизмененных файлов, поэтому только &lt;code&gt;example&lt;/code&gt; привел к сворачиванию. Но в реальных крупных проектах, когда за одну фиксацию изменяется только небольшое количество файлов, это &lt;code&gt;collapsing&lt;/code&gt; имеет тенденцию к тривиальному слиянию большинства путей довольно быстро, оставляя лишь несколько реальных изменений на ненулевых стадиях.</target>
        </trans-unit>
        <trans-unit id="a3569415a118c16e9c5d7e18e58096bbd8336f98" translate="yes" xml:space="preserve">
          <source>In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with the updated master and topic branch, as long as the recorded resolution is still applicable.</source>
          <target state="translated">В нашем примере,когда вы выполняете тестовое слияние,записывается ручное разрешение,и оно будет использовано повторно при фактическом слиянии позже с обновленной основной и тематической веткой,если записанное разрешение все еще применимо.</target>
        </trans-unit>
        <trans-unit id="8e5ca17ff33890ba6e129c741e431196f019fa29" translate="yes" xml:space="preserve">
          <source>In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the &lt;code&gt;--source&lt;/code&gt; tree are removed, to make them match &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; exactly. The default is no-overlay mode.</source>
          <target state="translated">В режиме наложения команда никогда не удаляет файлы при восстановлении. В режиме без наложения отслеживаемые файлы, которые не отображаются в дереве &lt;code&gt;--source&lt;/code&gt; , удаляются, чтобы они точно соответствовали &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; . По умолчанию используется режим без наложения.</target>
        </trans-unit>
        <trans-unit id="5b1c0d5c1dcebbb2369ea9f003ec30402ee8a395" translate="yes" xml:space="preserve">
          <source>In particular, let&amp;rsquo;s not even check in the two files into Git yet, we&amp;rsquo;ll start off by adding another line to &lt;code&gt;hello&lt;/code&gt; first:</source>
          <target state="translated">В частности, давайте пока даже не проверяем эти два файла в Git, мы начнем с добавления еще одной строки в &lt;code&gt;hello&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d0e454374a9a3ee3d6a441cd0674139a3f061022" translate="yes" xml:space="preserve">
          <source>In particular, the &lt;code&gt;refs&lt;/code&gt; subdirectory will contain two other subdirectories, named &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;tags&lt;/code&gt; respectively. They do exactly what their names imply: they contain references to any number of different &lt;code&gt;heads&lt;/code&gt; of development (aka &lt;code&gt;branches&lt;/code&gt;), and to any &lt;code&gt;tags&lt;/code&gt; that you have created to name specific versions in your repository.</source>
          <target state="translated">В частности, подкаталог &lt;code&gt;refs&lt;/code&gt; будет содержать два других подкаталога с именами &lt;code&gt;heads&lt;/code&gt; и &lt;code&gt;tags&lt;/code&gt; соответственно. Они делают в точности то, что подразумевают их имена: они содержат ссылки на любое количество различных &lt;code&gt;heads&lt;/code&gt; разработки (также называемых &lt;code&gt;branches&lt;/code&gt; ) и на любые &lt;code&gt;tags&lt;/code&gt; которые вы создали для именования конкретных версий в вашем репозитории.</target>
        </trans-unit>
        <trans-unit id="2037a0a7d55894c0e552cd3905604e14aef5f5cc" translate="yes" xml:space="preserve">
          <source>In practice, you can interleave and repeat steps 1 and 2 as many times as you want: in order to keep track of what you want committed at step 3, Git maintains a snapshot of the tree&amp;rsquo;s contents in a special staging area called &quot;the index.&quot;</source>
          <target state="translated">На практике вы можете чередовать и повторять шаги 1 и 2 столько раз, сколько захотите: чтобы отслеживать то, что вы хотите зафиксировать на шаге 3, Git поддерживает моментальный снимок содержимого дерева в специальной промежуточной области, называемой &amp;laquo;индексом&amp;raquo;. &amp;laquo;.</target>
        </trans-unit>
        <trans-unit id="f0e4ad3997791ffc68facd5c602055afb63229a5" translate="yes" xml:space="preserve">
          <source>In principle, a note is a regular Git blob, and any kind of (non-)format is accepted. You can binary-safely create notes from arbitrary files using &lt;code&gt;git hash-object&lt;/code&gt;:</source>
          <target state="translated">В принципе, заметка - это обычный Git blob, и допускается любой (не) формат. Вы можете безопасно создавать заметки из произвольных файлов с помощью &lt;code&gt;git hash-object&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4601fb728bee4aeccfe338414983070eaafe0d7b" translate="yes" xml:space="preserve">
          <source>In protocol v2 communication is command oriented. When first contacting a server a list of capabilities will advertised. Some of these capabilities will be commands which a client can request be executed. Once a command has completed, a client can reuse the connection and request that other commands be executed.</source>
          <target state="translated">В протоколе v2 коммуникация ориентирована на команды.При первом обращении к серверу будет объявлен список возможностей.Некоторые из этих возможностей будут представлять собой команды,которые клиент может запросить для выполнения.После выполнения команды клиент может повторно использовать соединение и запросить выполнение других команд.</target>
        </trans-unit>
        <trans-unit id="f1e89ddf0408f3e3f9aa71b3da7906ab579cf106" translate="yes" xml:space="preserve">
          <source>In protocol v2 these special packets will have the following semantics:</source>
          <target state="translated">В протоколе v2 эти специальные пакеты будут иметь следующую семантику:</target>
        </trans-unit>
        <trans-unit id="0b2a25ba5b09240510379a9523ee7fbbaeebe9c6" translate="yes" xml:space="preserve">
          <source>In some cases it is possible that the new head will &lt;strong&gt;not&lt;/strong&gt; actually be a descendant of the old head. For example, the developer may have realized she made a serious mistake, and decided to backtrack, resulting in a situation like:</source>
          <target state="translated">В некоторых случаях возможно, что новая голова &lt;strong&gt;не&lt;/strong&gt; будет потомком старой головы. Например, разработчик мог понять, что допустил серьезную ошибку, и решил отступить, что привело к такой ситуации:</target>
        </trans-unit>
        <trans-unit id="013d925394580efad8fc98d09cd78b65808be1a0" translate="yes" xml:space="preserve">
          <source>In some cases like for kernel development it can be worth developing complex scripts to be able to fully automate bisecting.</source>
          <target state="translated">В некоторых случаях,как и при разработке ядра,может быть стоит разработать сложные скрипты,чтобы иметь возможность полностью автоматизировать биссектрису.</target>
        </trans-unit>
        <trans-unit id="0a49ce3de43e8ee8d78f327f1f504c6a86228a99" translate="yes" xml:space="preserve">
          <source>In some situations the reflog may not be able to save you. For example, suppose you delete a branch, then realize you need the history it contained. The reflog is also deleted; however, if you have not yet pruned the repository, then you may still be able to find the lost commits in the dangling objects that &lt;code&gt;git fsck&lt;/code&gt; reports. See &lt;a href=&quot;#dangling-objects&quot;&gt;Dangling objects&lt;/a&gt; for the details.</source>
          <target state="translated">В некоторых ситуациях рефлог не может вас спасти. Например, предположим, что вы удаляете ветку, а затем понимаете, что вам нужна содержащаяся в ней история. Также удаляется рефлог; однако, если вы еще не удалили репозиторий, вы все равно сможете найти потерянные коммиты в висячих объектах, о которых сообщает &lt;code&gt;git fsck&lt;/code&gt; . См. &lt;a href=&quot;#dangling-objects&quot;&gt;Подробности в&lt;/a&gt; разделе &amp;laquo; Висячие предметы&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="4f2c24901ef5f6fa3a7b78ff609de06af9cfd2f7" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; would update only entries matched by &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; and sparse patterns in &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt;. This option ignores the sparse patterns and adds back any files in &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В режиме разреженной проверки &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; будет обновлять только записи, соответствующие &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; и разреженные шаблоны в &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; . Эта опция игнорирует разреженные шаблоны и добавляет обратно все файлы в &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91e2068ee07240a386da6a01584d7cb7bf48667f" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, by default is to only update entries matched by &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В режиме разреженной проверки по умолчанию обновляются только записи, соответствующие &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; , и разреженные шаблоны в $ GIT_DIR / info / sparse-checkout. Эта опция игнорирует разреженные шаблоны и безоговорочно восстанавливает любые файлы в &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9805e95abc4cc7297991de78ec147328f379f9f9" translate="yes" xml:space="preserve">
          <source>In such a case, &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; would return the parent of B0 in the above picture, but B0^..D is &lt;strong&gt;not&lt;/strong&gt; the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1).</source>
          <target state="translated">В таком случае &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; вернет родительский элемент B0 на приведенном выше рисунке, но B0 ^ .. D - это &lt;strong&gt;не&lt;/strong&gt; диапазон коммитов, которые вы хотели бы воспроизвести поверх B (он включает B0, что не то, что вы написали; это фиксация, которую отвергла другая сторона, когда она переместила свой конец с B0 на B1).</target>
        </trans-unit>
        <trans-unit id="38c59b4cda1fb890b6373e0ee120752a69f46faf" translate="yes" xml:space="preserve">
          <source>In such a case, you can &quot;unwrap&quot; the tag yourself before feeding it to &lt;code&gt;git merge&lt;/code&gt;, or pass &lt;code&gt;--ff-only&lt;/code&gt; when you do not have any work on your own. e.g.</source>
          <target state="translated">В таком случае вы можете &amp;laquo;развернуть&amp;raquo; тег самостоятельно, прежде чем передать его в &lt;code&gt;git merge&lt;/code&gt; , или передать &lt;code&gt;--ff-only&lt;/code&gt; , если у вас нет собственной работы. например</target>
        </trans-unit>
        <trans-unit id="122c6a9f6232138a6047defa817d1eec04cb3f10" translate="yes" xml:space="preserve">
          <source>In such a case, you do not want to automatically follow the other person&amp;rsquo;s tags.</source>
          <target state="translated">В таком случае вы не хотите автоматически следить за тегами другого человека.</target>
        </trans-unit>
        <trans-unit id="14b066e7c220e701d278a048087bd2ff212888b8" translate="yes" xml:space="preserve">
          <source>In such cases it can be very confusing to use the terms &quot;good&quot; and &quot;bad&quot; to refer to &quot;the state before the change&quot; and &quot;the state after the change&quot;. So instead, you can use the terms &quot;old&quot; and &quot;new&quot;, respectively, in place of &quot;good&quot; and &quot;bad&quot;. (But note that you cannot mix &quot;good&quot; and &quot;bad&quot; with &quot;old&quot; and &quot;new&quot; in a single session.)</source>
          <target state="translated">В таких случаях использование терминов &quot;хороший&quot; и &quot;плохой&quot; для обозначения &quot;состояния до изменения&quot; и &quot;состояния после изменения&quot; может быть очень запутанным.Поэтому вместо &quot;хорошего&quot; и &quot;плохого&quot; можно использовать термины &quot;старое&quot; и &quot;новое&quot; соответственно.(Но обратите внимание,что вы не можете смешивать &quot;хорошее&quot; и &quot;плохое&quot; со &quot;старым&quot; и &quot;новым&quot; в одном сеансе).</target>
        </trans-unit>
        <trans-unit id="abac94a936763ce45a21b8291dbe11f8fcd73ae6" translate="yes" xml:space="preserve">
          <source>In such cases, git-cherry shows a concise summary of what has yet to be applied:</source>
          <target state="translated">В таких случаях гит-вишня показывает краткое резюме того,что еще предстоит применить:</target>
        </trans-unit>
        <trans-unit id="46cccce64f7cd9f50066dd3d9623630b5fee1925" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;git pull&lt;/code&gt; can do the fetch and merge in one go, as follows.</source>
          <target state="translated">В этом случае &lt;code&gt;git pull&lt;/code&gt; может выполнить выборку и слияние за один раз, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="724c7d4dfedb54b8a53a948ec5bdabaee78995fb" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream. So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="translated">В этом случае исправить легко, потому что &lt;code&gt;git rebase&lt;/code&gt; знает, что нужно пропустить изменения, которые уже присутствуют в новом апстриме. Итак, если вы скажете (при условии, что вы по &lt;code&gt;topic&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2f5cdfecd5b61a82b453fde83701ee64b8d8237" translate="yes" xml:space="preserve">
          <source>In that case, you can still force Git to update to the new head, as described in the following section. However, note that in the situation above this may mean losing the commits labeled &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, unless you&amp;rsquo;ve already created a reference of your own pointing to them.</source>
          <target state="translated">В этом случае вы все равно можете принудительно обновить Git до нового заголовка, как описано в следующем разделе. Однако обратите внимание, что в приведенной выше ситуации это может означать потерю коммитов с метками &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , если вы уже не создали собственную ссылку, указывающую на них.</target>
        </trans-unit>
        <trans-unit id="23201c1eda40e4016771870c9d54dd5324857456" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;git push&lt;/code&gt; command above we specify the name of the remote branch to update (&lt;code&gt;master&lt;/code&gt;). If we leave that out, &lt;code&gt;git push&lt;/code&gt; tries to update any branches in the remote repository that have the same name as a branch in the local repository. So the last &lt;code&gt;push&lt;/code&gt; can be done with either of:</source>
          <target state="translated">В приведенной выше команде &lt;code&gt;git push&lt;/code&gt; мы указываем имя удаленной ветки для обновления ( &lt;code&gt;master&lt;/code&gt; ). Если мы оставим это без &lt;code&gt;git push&lt;/code&gt; , git push попытается обновить любые ветки в удаленном репозитории, которые имеют то же имя, что и ветка в локальном репозитории. Таким образом, последний &lt;code&gt;push&lt;/code&gt; может быть выполнен одним из следующих способов:</target>
        </trans-unit>
        <trans-unit id="090c003198124abd0a59f9db99cb23a0a9d08a0d" translate="yes" xml:space="preserve">
          <source>In the above config only the submodule &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are active, &lt;code&gt;bar&lt;/code&gt; due to (1) and &lt;code&gt;baz&lt;/code&gt; due to (3). &lt;code&gt;foo&lt;/code&gt; is inactive because (1) takes precedence over (3)</source>
          <target state="translated">В приведенной выше конфигурации активны только субмодуль &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; из-за (1) и &lt;code&gt;baz&lt;/code&gt; из-за (3). &lt;code&gt;foo&lt;/code&gt; неактивен, потому что (1) имеет приоритет над (3)</target>
        </trans-unit>
        <trans-unit id="f2615d435cf358760e53af78267e9744a2a4cd7e" translate="yes" xml:space="preserve">
          <source>In the above example output, the function signature was changed from both files (hence two &lt;code&gt;-&lt;/code&gt; removals from both file1 and file2, plus &lt;code&gt;++&lt;/code&gt; to mean one line that was added does not appear in either file1 or file2). Also eight other lines are the same from file1 but do not appear in file2 (hence prefixed with &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">В выходных данных приведенного выше примера подпись функции была изменена из обоих файлов (следовательно, два &lt;code&gt;-&lt;/code&gt; удаления из файла1 и файла2, плюс &lt;code&gt;++&lt;/code&gt; , что означает, что одна добавленная строка не отображается ни в файле1, ни в файле2). Также восемь других строк совпадают с файлом file1, но не отображаются в file2 (следовательно, имеют префикс &lt;code&gt;+&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="236d1518399c3b158b7b503f699f9dfd06244979" translate="yes" xml:space="preserve">
          <source>In the above example we have N = 8, so this will give:</source>
          <target state="translated">В приведенном выше примере мы имеем N=8,так что это даст:</target>
        </trans-unit>
        <trans-unit id="4faa5ab35bd05c089c7f00cb50d40bc6a34dd151" translate="yes" xml:space="preserve">
          <source>In the case where the input consists entirely of whitespace characters, no output will be produced.</source>
          <target state="translated">В случае,если ввод полностью состоит из пробельных символов,выводиться не будет.</target>
        </trans-unit>
        <trans-unit id="6722ed28b0a968c96593a6b207713cd0f24f7d3a" translate="yes" xml:space="preserve">
          <source>In the check-in codepath, the worktree file is first converted with &lt;code&gt;filter&lt;/code&gt; driver (if specified and corresponding driver defined), then the result is processed with &lt;code&gt;ident&lt;/code&gt; (if specified), and then finally with &lt;code&gt;text&lt;/code&gt; (again, if specified and applicable).</source>
          <target state="translated">В кодовом пути регистрации файл рабочего дерева сначала преобразуется с помощью драйвера &lt;code&gt;filter&lt;/code&gt; (если он указан и соответствующий драйвер определен), затем результат обрабатывается с помощью &lt;code&gt;ident&lt;/code&gt; (если указан), а затем, наконец, с помощью &lt;code&gt;text&lt;/code&gt; (снова, если указано и применимо) ,</target>
        </trans-unit>
        <trans-unit id="41a87794ee334f48f97053e2010dfe2b224b3e78" translate="yes" xml:space="preserve">
          <source>In the check-out codepath, the blob content is first converted with &lt;code&gt;text&lt;/code&gt;, and then &lt;code&gt;ident&lt;/code&gt; and fed to &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">В кодовом пути извлечения содержимое большого двоичного объекта сначала преобразуется в &lt;code&gt;text&lt;/code&gt; , а затем &lt;code&gt;ident&lt;/code&gt; и передается для &lt;code&gt;filter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="113fa915b38684bf235e931affc2401ec6de4a63" translate="yes" xml:space="preserve">
          <source>In the cone mode case, the &lt;code&gt;git sparse-checkout list&lt;/code&gt; subcommand will list the directories that define the recursive patterns. For the example sparse-checkout file above, the output is as follows:</source>
          <target state="translated">В случае режима конуса подкоманда &lt;code&gt;git sparse-checkout list&lt;/code&gt; перечислит каталоги, которые определяют рекурсивные шаблоны. Для приведенного выше примера файла разреженной проверки результат будет следующим:</target>
        </trans-unit>
        <trans-unit id="50d1a515997c60c54243bae252639aa03db105b6" translate="yes" xml:space="preserve">
          <source>In the default overlay mode, &lt;code&gt;git checkout&lt;/code&gt; never removes files from the index or the working tree. When specifying &lt;code&gt;--no-overlay&lt;/code&gt;, files that appear in the index and working tree, but not in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; are removed, to make them match &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; exactly.</source>
          <target state="translated">В режиме наложения по умолчанию &lt;code&gt;git checkout&lt;/code&gt; никогда не удаляет файлы из индекса или рабочего дерева. При указании &lt;code&gt;--no-overlay&lt;/code&gt; файлы, которые появляются в индексном и рабочем дереве, но не в &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; , удаляются, чтобы они точно соответствовали &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdd96542ff31058533f7beb40eadd124991c8c5" translate="yes" xml:space="preserve">
          <source>In the early days, Git (in the tradition of UNIX) was a bunch of programs which were extremely simple, and which you used in scripts, piping the output of one into another. This turned out to be good for initial development, since it was easier to test new things. However, recently many of these parts have become builtins, and some of the core has been &quot;libified&quot;, i.e. put into libgit.a for performance, portability reasons, and to avoid code duplication.</source>
          <target state="translated">В ранние времена Git (в традиции UNIX)представлял собой кучу программ,которые были чрезвычайно просты,и которые вы использовали в скриптах,объединяя выходные данные друг в друга.Это оказалось хорошо для начальной разработки,так как было проще тестировать новые вещи.Однако в последнее время многие из этих частей превратились в сборки,а часть ядра была &quot;освобождена&quot;,т.е.помещена в libgit.a по соображениям производительности,переносимости и во избежание дублирования кода.</target>
        </trans-unit>
        <trans-unit id="5c0100c9df6abb7d7f1348c7fe307c535cc01a6e" translate="yes" xml:space="preserve">
          <source>In the examples, the following &lt;code&gt;.gitattributes&lt;/code&gt; file is used:</source>
          <target state="translated">В примерах используется следующий файл &lt;code&gt;.gitattributes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cc3fe53f7a76d1235b536b2f3e4aace1aeafd632" translate="yes" xml:space="preserve">
          <source>In the external editor window, read in the patch file and exit the editor normally.</source>
          <target state="translated">В окне внешнего редактора прочитайте в файле патча и выйдите из редактора в обычном режиме.</target>
        </trans-unit>
        <trans-unit id="8ef2e6de3f32f727ff12807f3683863dc57cb535" translate="yes" xml:space="preserve">
          <source>In the first form, it renames &amp;lt;source&amp;gt;, which must exist and be either a file, symlink or directory, to &amp;lt;destination&amp;gt;. In the second form, the last argument has to be an existing directory; the given sources will be moved into this directory.</source>
          <target state="translated">В первой форме он переименовывает &amp;lt;source&amp;gt;, который должен существовать и быть либо файлом, либо символической ссылкой, либо каталогом, в &amp;lt;destination&amp;gt;. Во второй форме последним аргументом должен быть существующий каталог; указанные источники будут перемещены в этот каталог.</target>
        </trans-unit>
        <trans-unit id="76aeefd352a6b656fb05dc49a2aa92d1acbe97ce" translate="yes" xml:space="preserve">
          <source>In the first three forms, copy entries from &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; to the index. In the last form, set the current branch head (&lt;code&gt;HEAD&lt;/code&gt;) to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, optionally modifying index and working tree to match. The &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;HEAD&lt;/code&gt; in all forms.</source>
          <target state="translated">В первых трех формах скопируйте записи из &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; в индекс. В последней форме установите для заголовка текущей ветки ( &lt;code&gt;HEAD&lt;/code&gt; ) значение &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; , при необходимости изменив индекс и рабочее дерево для соответствия. &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; по умолчанию для &lt;code&gt;HEAD&lt;/code&gt; во всех формах.</target>
        </trans-unit>
        <trans-unit id="ef10a113d8afc34781099a24e1e343890650a1e1" translate="yes" xml:space="preserve">
          <source>In the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a &quot;Report a bug&quot; button. The output of &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; may look like this:</source>
          <target state="translated">В следующем примере разработчик работает над тематической веткой, которая реорганизует способ определения кнопок, и над другой тематической веткой, которая использует этот рефакторинг для реализации кнопки &amp;laquo;Сообщить об ошибке&amp;raquo;. Вывод &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="e8d35f4a27576cd3ee599047c232398088d285ec" translate="yes" xml:space="preserve">
          <source>In the following, we list all defined capabilities and for each we list which commands a helper with that capability must provide.</source>
          <target state="translated">Далее мы перечисляем все определенные возможности,и для каждой из них мы указываем,какие команды должен предоставить помощник с этой возможностью.</target>
        </trans-unit>
        <trans-unit id="c56abbab61e08007b56db2739d2660b32ff3baf6" translate="yes" xml:space="preserve">
          <source>In the following, we say that commit X is &quot;reachable&quot; from commit Y if commit X is an ancestor of commit Y. Equivalently, you could say that Y is a descendant of X, or that there is a chain of parents leading from commit Y to commit X.</source>
          <target state="translated">Далее мы говорим,что коммит X &quot;достижим&quot; от коммита Y,если коммит X является предком коммита Y.Аналогично можно сказать,что Y является потомком X,или что существует цепочка родителей,ведущая от коммита Y к коммиту X.</target>
        </trans-unit>
        <trans-unit id="2ab0015fa4bf468aa51dfb7b06e67d10a59ee05a" translate="yes" xml:space="preserve">
          <source>In the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file &lt;code&gt;foo&lt;/code&gt; in this commit graph:</source>
          <target state="translated">В дальнейшем мы всегда будем ссылаться на один и тот же пример истории, чтобы проиллюстрировать различия между настройками упрощения. Мы предполагаем, что вы фильтруете файл &lt;code&gt;foo&lt;/code&gt; в этом графе фиксации:</target>
        </trans-unit>
        <trans-unit id="1a1825758e9c1b0f3cada9dea61b97f18e404ba1" translate="yes" xml:space="preserve">
          <source>In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to &lt;code&gt;branch2&lt;/code&gt; (i.e. &lt;code&gt;git switch -c branch2 start&lt;/code&gt;), but nobody is perfect.</source>
          <target state="translated">В идеальном мире вы могли бы понять, что предыдущая фиксация не относилась к новой теме, когда вы создали и переключились на &lt;code&gt;branch2&lt;/code&gt; (т.е. &lt;code&gt;git switch -c branch2 start&lt;/code&gt; ), но никто не идеален.</target>
        </trans-unit>
        <trans-unit id="d370a0f8ed20ae4cd4e933b9beff011b3187e6ad" translate="yes" xml:space="preserve">
          <source>In the long form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by an open parenthesis &lt;code&gt;(&lt;/code&gt;, a comma-separated list of zero or more &quot;magic words&quot;, and a close parentheses &lt;code&gt;)&lt;/code&gt;, and the remainder is the pattern to match against the path.</source>
          <target state="translated">В длинной форме за ведущим двоеточием &lt;code&gt;:&lt;/code&gt; следует открытая скобка &lt;code&gt;(&lt;/code&gt; разделенный запятыми список из нуля или более &amp;laquo;волшебных слов&amp;raquo; и закрывающих скобок &lt;code&gt;)&lt;/code&gt; , а оставшаяся часть представляет собой образец для сопоставления пути.</target>
        </trans-unit>
        <trans-unit id="ecbb466c633c8f376663d1974093b0b801e94fbc" translate="yes" xml:space="preserve">
          <source>In the main Thunderbird window, &lt;code&gt;before&lt;/code&gt; you open the compose window for the patch, use Tools&amp;rarr;about:config to set the following to the indicated values:</source>
          <target state="translated">В главном окне Thunderbird, &lt;code&gt;before&lt;/code&gt; чем открывать окно создания патча, используйте Инструменты &amp;rarr; about: config, чтобы установить следующие значения на указанные значения:</target>
        </trans-unit>
        <trans-unit id="3f70c7e45d5c392e715fb2023b23a65e5f20b82a" translate="yes" xml:space="preserve">
          <source>In the output from &lt;code&gt;git show-branch&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt; should have everything &lt;code&gt;ko/master&lt;/code&gt; has, and &lt;code&gt;next&lt;/code&gt; should have everything &lt;code&gt;ko/next&lt;/code&gt; has, etc.</source>
          <target state="translated">В выходе из &lt;code&gt;git show-branch&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; должен иметь все &lt;code&gt;ko/master&lt;/code&gt; имеет, а &lt;code&gt;next&lt;/code&gt; должен иметь все &lt;code&gt;ko/next&lt;/code&gt; есть и т.д.</target>
        </trans-unit>
        <trans-unit id="9fb474287214ed4886618f1399ff63bbd11f6810" translate="yes" xml:space="preserve">
          <source>In the pager (&lt;code&gt;less&lt;/code&gt;), just search for &quot;bundle&quot;, go a few lines back, and see that it is in commit 18449ab0. Now just copy this object name, and paste it into the command line</source>
          <target state="translated">В пейджере ( &lt;code&gt;less&lt;/code&gt; ) просто найдите &amp;laquo;bundle&amp;raquo;, вернитесь на несколько строк назад и увидите, что он находится в фиксации 18449ab0. Теперь просто скопируйте это имя объекта и вставьте его в командную строку.</target>
        </trans-unit>
        <trans-unit id="5fc7016d20b7cd82938bb283d4d8443cc61835c8" translate="yes" xml:space="preserve">
          <source>In the past, &lt;code&gt;.git/HEAD&lt;/code&gt; was a symbolic link pointing at &lt;code&gt;refs/heads/master&lt;/code&gt;. When we wanted to switch to another branch, we did &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt;, and when we wanted to find out which branch we are on, we did &lt;code&gt;readlink .git/HEAD&lt;/code&gt;. But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default.</source>
          <target state="translated">В прошлом &lt;code&gt;.git/HEAD&lt;/code&gt; был символической ссылкой, указывающей на &lt;code&gt;refs/heads/master&lt;/code&gt; . Когда мы хотели переключиться на другую ветку, мы сделали &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt; , а когда мы хотели узнать, в какой ветке мы находимся, мы &lt;code&gt;readlink .git/HEAD&lt;/code&gt; . Но символические ссылки не полностью переносимы, поэтому теперь они устарели, а символические ссылки (как описано выше) используются по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8dfab80b468101639bf9d627830b7559e865891a" translate="yes" xml:space="preserve">
          <source>In the previous example, when updating an existing branch, &lt;code&gt;git fetch&lt;/code&gt; checks to make sure that the most recent commit on the remote branch is a descendant of the most recent commit on your copy of the branch before updating your copy of the branch to point at the new commit. Git calls this process a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;.</source>
          <target state="translated">В предыдущем примере при обновлении существующей ветки &lt;code&gt;git fetch&lt;/code&gt; проверяет, является ли последняя фиксация в удаленной ветке потомком самой последней фиксации в вашей копии ветки перед обновлением вашей копии ветки, чтобы она указывала на новый коммит. Git называет этот процесс &lt;a href=&quot;#fast-forwards&quot;&gt;перемоткой вперед&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39fc6243d8461e10163ad54b5cc61dfd9c9ca8f0" translate="yes" xml:space="preserve">
          <source>In the process of undoing a previous bad change, you may find it useful to check out an older version of a particular file using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;. The command</source>
          <target state="translated">В процессе отмены предыдущего плохого изменения вам может быть полезно проверить старую версию конкретного файла с помощью &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; . Команда</target>
        </trans-unit>
        <trans-unit id="ce5a30d6d89274fe8c4b93a655981ad3cb2875fa" translate="yes" xml:space="preserve">
          <source>In the process, it may discover conflicts. In that case it will stop and allow you to fix the conflicts; after fixing conflicts, use &lt;code&gt;git add&lt;/code&gt; to update the index with those contents, and then, instead of running &lt;code&gt;git commit&lt;/code&gt;, just run</source>
          <target state="translated">В процессе могут обнаруживаться конфликты. В этом случае он остановится и позволит вам исправить конфликты; после устранения конфликтов используйте &lt;code&gt;git add&lt;/code&gt; для обновления индекса этим содержимым, а затем вместо запуска &lt;code&gt;git commit&lt;/code&gt; просто запустите</target>
        </trans-unit>
        <trans-unit id="ecd16080120d9546efe5335b66c01332d8bc5340" translate="yes" xml:space="preserve">
          <source>In the second form, a list of objects (separated by linefeeds) is provided on stdin, and the SHA-1, type, and size of each object is printed on stdout. The output format can be overridden using the optional &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; argument. If either &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; was specified, the input is expected to list the object names followed by the path name, separated by a single whitespace, so that the appropriate drivers can be determined.</source>
          <target state="translated">Во второй форме список объектов (разделенных переводом строки) предоставляется на stdin, а SHA-1, тип и размер каждого объекта печатаются на stdout. Формат вывода можно переопределить с помощью необязательного аргумента &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; . Если &lt;code&gt;--textconv&lt;/code&gt; или &lt;code&gt;--filters&lt;/code&gt; , ожидается, что на входе будут перечислены имена объектов, за которыми следует имя пути, разделенные одним пробелом, чтобы можно было определить соответствующие драйверы.</target>
        </trans-unit>
        <trans-unit id="909b0b19015ead3714bd1690a7877da1cf97f4fa" translate="yes" xml:space="preserve">
          <source>In the short-format, the status of each path is shown as one of these forms</source>
          <target state="translated">В коротком формате,статус каждого пути отображается как одна из этих форм.</target>
        </trans-unit>
        <trans-unit id="abe3a521aeac4a8adcc3faf0711763fbfd40b505" translate="yes" xml:space="preserve">
          <source>In the simple form, each line in the file consists of the canonical real name of an author, whitespace, and an email address used in the commit (enclosed by &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;) to map to the name. For example:</source>
          <target state="translated">В простой форме каждая строка в файле состоит из канонического настоящего имени автора, пробела и адреса электронной почты, используемого в фиксации (заключенного в &lt;code&gt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&lt;/code&gt; ) для сопоставления с именем. Например:</target>
        </trans-unit>
        <trans-unit id="eecf34aeaad64fff7ea38378d33edc5335145626" translate="yes" xml:space="preserve">
          <source>In these cases you can tell Git the encoding of a file in the working directory with the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If a file with this attribute is added to Git, then Git re-encodes the content from the specified encoding to UTF-8. Finally, Git stores the UTF-8 encoded content in its internal data structure (called &quot;the index&quot;). On checkout the content is re-encoded back to the specified encoding.</source>
          <target state="translated">В этих случаях вы можете указать Git кодировку файла в рабочем каталоге с помощью атрибута &lt;code&gt;working-tree-encoding&lt;/code&gt; . Если файл с этим атрибутом добавляется в Git, то Git перекодирует содержимое из указанной кодировки в UTF-8. Наконец, Git хранит содержимое в кодировке UTF-8 в своей внутренней структуре данных (называемой &amp;laquo;индексом&amp;raquo;). При оформлении заказа содержимое перекодируется обратно в указанную кодировку.</target>
        </trans-unit>
        <trans-unit id="5322604525a9aed1b9bf470c8d7df77aa5a14cc1" translate="yes" xml:space="preserve">
          <source>In these tables, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; are some different states of a file. For example, the first line of the first table means that if a file is in state &lt;code&gt;A&lt;/code&gt; in the working tree, in state &lt;code&gt;B&lt;/code&gt; in the index, in state &lt;code&gt;C&lt;/code&gt; in &lt;code&gt;HEAD&lt;/code&gt; and in state &lt;code&gt;D&lt;/code&gt; in the target, then &lt;code&gt;git reset --soft
target&lt;/code&gt; will leave the file in the working tree in state &lt;code&gt;A&lt;/code&gt; and in the index in state &lt;code&gt;B&lt;/code&gt;. It resets (i.e. moves) the &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch, if you are on one) to &lt;code&gt;target&lt;/code&gt; (which has the file in state &lt;code&gt;D&lt;/code&gt;).</source>
          <target state="translated">В этих таблицах &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;D&lt;/code&gt; - это различные состояния файла. Например, первая строка первой таблицы означает, что если файл находится в состоянии &lt;code&gt;A&lt;/code&gt; в рабочем дереве, в состоянии &lt;code&gt;B&lt;/code&gt; в индексе, в состоянии &lt;code&gt;C&lt;/code&gt; в &lt;code&gt;HEAD&lt;/code&gt; и в состоянии &lt;code&gt;D&lt;/code&gt; в цели, то &lt;code&gt;git reset --soft target&lt;/code&gt; будет оставить файл в рабочем дереве в государственном &lt;code&gt;A&lt;/code&gt; и в индексе в государственном &lt;code&gt;B&lt;/code&gt; . Он сбрасывает (т. Е. &lt;code&gt;HEAD&lt;/code&gt; ) ГОЛОВУ (т. Е. Кончик текущей ветки, если вы на ней) к &lt;code&gt;target&lt;/code&gt; (которая имеет файл в состоянии &lt;code&gt;D&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31d8ef3e97391069cf0655f41499162005f123c2" translate="yes" xml:space="preserve">
          <source>In these two shorthand notations, you can omit one end and let it default to HEAD. For example, &lt;code&gt;origin..&lt;/code&gt; is a shorthand for &lt;code&gt;origin..HEAD&lt;/code&gt; and asks &quot;What did I do since I forked from the origin branch?&quot; Similarly, &lt;code&gt;..origin&lt;/code&gt; is a shorthand for &lt;code&gt;HEAD..origin&lt;/code&gt; and asks &quot;What did the origin do since I forked from them?&quot; Note that &lt;code&gt;..&lt;/code&gt; would mean &lt;code&gt;HEAD..HEAD&lt;/code&gt; which is an empty range that is both reachable and unreachable from HEAD.</source>
          <target state="translated">В этих двух сокращенных обозначениях вы можете опустить один конец и оставить по умолчанию HEAD. Например, &lt;code&gt;origin..&lt;/code&gt; является сокращением от &lt;code&gt;origin..HEAD&lt;/code&gt; и спрашивает: &amp;laquo;Что я сделал, поскольку я разветвился из исходной ветки?&amp;raquo; Точно так же &lt;code&gt;..origin&lt;/code&gt; является сокращением от &lt;code&gt;HEAD..origin&lt;/code&gt; и спрашивает: &quot;Что сделал origin, после того как я его разветвил?&quot; Обратите внимание, что &lt;code&gt;..&lt;/code&gt; будет означать &lt;code&gt;HEAD..HEAD&lt;/code&gt; , который представляет собой пустой диапазон, который одновременно доступен и недоступен из HEAD.</target>
        </trans-unit>
        <trans-unit id="fda0649080e4ad73be213a95d0150567b39a9905" translate="yes" xml:space="preserve">
          <source>In this case Git will attempt to undo the old change while leaving intact any changes made since then. If more recent changes overlap with the changes to be reverted, then you will be asked to fix conflicts manually, just as in the case of &lt;a href=&quot;#resolving-a-merge&quot;&gt;resolving a merge&lt;/a&gt;.</source>
          <target state="translated">В этом случае Git попытается отменить старое изменение, оставив нетронутыми все изменения, сделанные с тех пор. Если более поздние изменения совпадают с изменениями, которые необходимо отменить, вам будет предложено исправить конфликты вручную, как и в случае &lt;a href=&quot;#resolving-a-merge&quot;&gt;разрешения слияния&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7e31e9f418486f831893dd264d133713a86e996" translate="yes" xml:space="preserve">
          <source>In this case if you are bisecting manually, what you can do is create a special branch that starts just before the BBC. The first commit in this branch should be the BBC with the BFC squashed into it. And the other commits in the branch should be the commits between BBC and BFC rebased on the first commit of the branch and then the commit after BFC also rebased on.</source>
          <target state="translated">В этом случае,если вы делаете биссектрису вручную,то что вы можете сделать,так это создать специальную ветку,которая начинается непосредственно перед BBC.Первый коммит в этой ветке должен быть BBC с раздавленным BFC.А другие коммиты в этой ветке должны быть коммитами между BBC и BFC,отскочившими от первого коммита в этой ветке,а затем коммитом после BFC,также отскочившим от него.</target>
        </trans-unit>
        <trans-unit id="717fbe628e5024a7ab31b6335fd291caf38b26b3" translate="yes" xml:space="preserve">
          <source>In this case this creates a totally new commit that is not related to anything else. Normally you do this only &lt;strong&gt;once&lt;/strong&gt; for a project ever, and all later commits will be parented on top of an earlier commit.</source>
          <target state="translated">В этом случае создается совершенно новый коммит, не связанный ни с чем. Обычно вы делаете это только &lt;strong&gt;один раз&lt;/strong&gt; для проекта, и все последующие коммиты будут созданы поверх более раннего коммита.</target>
        </trans-unit>
        <trans-unit id="8d602afd53dc502b1f39532e44b808e7e4006de6" translate="yes" xml:space="preserve">
          <source>In this case we say that the HEAD is &quot;detached&quot;.</source>
          <target state="translated">В данном случае мы говорим,что Голова &quot;отделена&quot;.</target>
        </trans-unit>
        <trans-unit id="84d70e62f46cda65cca1be0dfe61a185714e74d6" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;git fetch&lt;/code&gt; will fail, and print out a warning.</source>
          <target state="translated">В этом случае &lt;code&gt;git fetch&lt;/code&gt; завершится ошибкой и выведет предупреждение.</target>
        </trans-unit>
        <trans-unit id="ec2a36fb392a8671d4d7ad6f96adda81069f0cb4" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; command makes sure that no local change is lost as the result of this &quot;merge&quot;. Here are the &quot;carry forward&quot; rules, where &quot;I&quot; denotes the index, &quot;clean&quot; means that index and work tree coincide, and &quot;exists&quot;/&quot;nothing&quot; refer to the presence of a path in the specified commit:</source>
          <target state="translated">В этом случае команда &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; гарантирует, что никакие локальные изменения не будут потеряны в результате этого &amp;laquo;слияния&amp;raquo;. Вот правила &amp;laquo;переноса&amp;raquo;, где &amp;laquo;I&amp;raquo; обозначает индекс, &amp;laquo;чистый&amp;raquo; означает, что индекс и рабочее дерево совпадают, а &amp;laquo;существует&amp;raquo; / &amp;laquo;ничего&amp;raquo; относится к наличию пути в указанной фиксации:</target>
        </trans-unit>
        <trans-unit id="53de38de1c4937be3492ea2adad08075be0660b2" translate="yes" xml:space="preserve">
          <source>In this case, though, Git may not eventually be able to tell the first bad one between some first skipped commits and a later bad commit.</source>
          <target state="translated">В этом случае,однако,Git может оказаться не в состоянии отличить первый плохой коммит от первого пропущенного и последующего плохого.</target>
        </trans-unit>
        <trans-unit id="cc3568a850f36cf3d79c68cf0d9db0591ec5b81e" translate="yes" xml:space="preserve">
          <source>In this case, when &lt;code&gt;git bisect run&lt;/code&gt; finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by &lt;code&gt;git pack objects&lt;/code&gt;.</source>
          <target state="translated">В этом случае, когда &lt;code&gt;git bisect run&lt;/code&gt; завершается, bisect / bad будет относиться к фиксации, у которой есть хотя бы один родитель, чей график достижимости полностью проходим в том смысле, который требуется для &lt;code&gt;git pack objects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="052b0bf9d817f9d1efdbc01c640d54d8fda7ad16" translate="yes" xml:space="preserve">
          <source>In this example preload_index() was executed by the &lt;code&gt;main&lt;/code&gt; thread and started the &lt;code&gt;preload&lt;/code&gt; region. Seven threads, named &lt;code&gt;th01:preload_thread&lt;/code&gt; through &lt;code&gt;th07:preload_thread&lt;/code&gt;, were started. Events from each thread are atomically appended to the shared target stream as they occur so they may appear in random order with respect other threads. Finally, the main thread waits for the threads to finish and leaves the region.</source>
          <target state="translated">В этом примере preload_index () была выполнена &lt;code&gt;main&lt;/code&gt; потоком и запустила область &lt;code&gt;preload&lt;/code&gt; . Было &lt;code&gt;th01:preload_thread&lt;/code&gt; семь потоков с именами от th01: preload_thread до &lt;code&gt;th07:preload_thread&lt;/code&gt; . События из каждого потока атомарно добавляются к общему целевому потоку по мере их возникновения, поэтому они могут появляться в случайном порядке относительно других потоков. Наконец, основной поток ожидает завершения потоков и покидает область.</target>
        </trans-unit>
        <trans-unit id="8e1c791b90ef2153c52f59ff823e2b7a9d806696" translate="yes" xml:space="preserve">
          <source>In this example, &quot;origin&quot; is called a remote repository, or &quot;remote&quot; for short. The branches of this repository are called &quot;remote branches&quot; from our point of view. The remote-tracking branches listed above were created based on the remote branches at clone time and will be updated by &lt;code&gt;git fetch&lt;/code&gt; (hence &lt;code&gt;git pull&lt;/code&gt;) and &lt;code&gt;git push&lt;/code&gt;. See &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;Updating a repository with git fetch&lt;/a&gt; for details.</source>
          <target state="translated">В этом примере &amp;laquo;origin&amp;raquo; называется удаленным репозиторием, или для краткости &amp;laquo;удаленным&amp;raquo;. Ветви этого репозитория с нашей точки зрения называются &amp;laquo;удаленными ветвями&amp;raquo;. Перечисленные выше ветки удаленного отслеживания были созданы на основе удаленных ветвей во время клонирования и будут обновляться с помощью &lt;code&gt;git fetch&lt;/code&gt; (следовательно, &lt;code&gt;git pull&lt;/code&gt; ) и &lt;code&gt;git push&lt;/code&gt; . Подробнее см. &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;Обновление репозитория с помощью git fetch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="888891869abe63aa603e61303e6b4eda4f092540" translate="yes" xml:space="preserve">
          <source>In this example, scanning for untracked files ran from +0.012568 to +0.027149 (since the process started) and took 0.014581 seconds.</source>
          <target state="translated">В данном примере сканирование на наличие неотслеживаемых файлов выполнялось с +0.012568 до +0.027149 (с момента запуска процесса)и заняло 0.014581 секунды.</target>
        </trans-unit>
        <trans-unit id="06524b5c41784cbbacde83bd5045f27a411dfe64" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;ko&lt;/code&gt; shorthand points at the Git maintainer&amp;rsquo;s repository at kernel.org, and looks like this:</source>
          <target state="translated">В этом примере сокращение &lt;code&gt;ko&lt;/code&gt; указывает на репозиторий разработчика Git на kernel.org и выглядит так:</target>
        </trans-unit>
        <trans-unit id="f509bc56ecf3e22348180170f4391a6c5749bec9" translate="yes" xml:space="preserve">
          <source>In this example, the preload region took 0.009122 seconds. The 7 threads took between 0.006069 and 0.008947 seconds to work on their portion of the index. Thread &quot;th01&quot; worked on 508 items at offset 0. Thread &quot;th02&quot; worked on 508 items at offset 2032. Thread &quot;th04&quot; worked on 508 items at offset 508.</source>
          <target state="translated">В данном примере область предварительной загрузки заняла 0,009122 секунды.Работа 7 потоков над своей частью индекса заняла от 0.006069 до 0.008947 секунд.Нить &quot;th01&quot; работала на 508 элементах при смещении 0.Нить &quot;th02&quot; работала на 508 элементах при смещении 2032.Нитка &quot;th04&quot; работала над 508 позициями в офсете 508.</target>
        </trans-unit>
        <trans-unit id="24b2f8c33beed03671571687642648d3c34d3255" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host IP address supported. Repositories can still be accessed by hostname though, assuming they correspond to these IP addresses.</source>
          <target state="translated">В этом примере каталог &lt;code&gt;/pub&lt;/code&gt; корневого уровня будет содержать подкаталог для каждого поддерживаемого IP-адреса виртуального хоста. Однако доступ к репозиториям можно получить по имени хоста, если они соответствуют этим IP-адресам.</target>
        </trans-unit>
        <trans-unit id="1b3657f6aff85ab6f6a5a7f723164213b6e98109" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host name supported. Further, both hosts advertise repositories simply as &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt;. For pre-1.4.0 clients, a symlink from &lt;code&gt;/software&lt;/code&gt; into the appropriate default repository could be made as well.</source>
          <target state="translated">В этом примере каталог &lt;code&gt;/pub&lt;/code&gt; корневого уровня будет содержать подкаталог для каждого поддерживаемого имени виртуального хоста. Кроме того, оба хоста рекламируют репозитории просто как &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt; . Для клиентов до версии 1.4.0 также может быть сделана символическая ссылка из &lt;code&gt;/software&lt;/code&gt; в соответствующий репозиторий по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4f73381570064f6ad92295b54ae4d9111ba415e0" translate="yes" xml:space="preserve">
          <source>In this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well its diff.</source>
          <target state="translated">В данном примере есть 3 старых и 3 новых коммита,в которых разработчик удалил 3-й,добавил новый перед первыми двумя и изменил сообщение о коммите 2-го коммита,а также его отличие.</target>
        </trans-unit>
        <trans-unit id="5f85b35b8b6aae26894cfdfbe33e3822a8120573" translate="yes" xml:space="preserve">
          <source>In this example, we passed &quot;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&quot; as parameter to &quot;git bisect run&quot;. This means that at each step, the grep command we passed will be launched. And if it exits with code 0 (that means success) then git bisect will mark the current state as &quot;good&quot;. If it exits with code 1 (or any code between 1 and 127 included, except the special code 125), then the current state will be marked as &quot;bad&quot;.</source>
          <target state="translated">В этом примере мы передали &amp;laquo;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&amp;raquo; в качестве параметра для &amp;laquo;git bisect run&amp;raquo;. Это означает, что на каждом шаге будет запускаться переданная нами команда grep. И если он завершится с кодом 0 (что означает успех), то git bisect пометит текущее состояние как &amp;laquo;хорошее&amp;raquo;. Если он завершается с кодом 1 (или любым кодом от 1 до 127, кроме специального кода 125), то текущее состояние будет помечено как &amp;laquo;плохое&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="eee8776c9677f60ee6e97b993bed2ed1a91281bf" translate="yes" xml:space="preserve">
          <source>In this format, each line is output after a header; the header at the minimum has the first line which has:</source>
          <target state="translated">В этом формате каждая строка выводится после заголовка;в заголовке,как минимум,есть первая строка:</target>
        </trans-unit>
        <trans-unit id="991df4351922c60c45e086aff27d9273fe47de49" translate="yes" xml:space="preserve">
          <source>In this format, use 40 &quot;0&quot; to specify a zero value, and use the empty string to specify a missing value.</source>
          <target state="translated">В этом формате используйте 40 &quot;0&quot; для указания нулевого значения,а пустую строку-для указания недостающего значения.</target>
        </trans-unit>
        <trans-unit id="b4a37ae142e5dfb709dfd08bf26fc04d26f39f66" translate="yes" xml:space="preserve">
          <source>In this mode, specific configuration stays in the path pointed by &lt;code&gt;git
rev-parse --git-path config.worktree&lt;/code&gt;. You can add or update configuration in this file with &lt;code&gt;git config --worktree&lt;/code&gt;. Older Git versions will refuse to access repositories with this extension.</source>
          <target state="translated">В этом режиме конкретная конфигурация остается в пути, указанном &lt;code&gt;git rev-parse --git-path config.worktree&lt;/code&gt; . Вы можете добавить или обновить конфигурацию в этом файле с помощью &lt;code&gt;git config --worktree&lt;/code&gt; . Более старые версии Git откажутся от доступа к репозиториям с этим расширением.</target>
        </trans-unit>
        <trans-unit id="26cf2860c6712d39e5cbcd807f1756d9308dfdb3" translate="yes" xml:space="preserve">
          <source>In this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.&amp;lt;SHA-1&amp;gt;. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged.</source>
          <target state="translated">В этом режиме индекс разделяется на два файла: $ GIT_DIR / index и $ GIT_DIR / sharedindex. &amp;lt;SHA-1&amp;gt;. Изменения накапливаются в $ GIT_DIR / index, разделенном индексе, в то время как файл общего индекса содержит все записи индекса и остается неизменным.</target>
        </trans-unit>
        <trans-unit id="ffc9d6f506ae4dc0ef8e821987c60f58237503b7" translate="yes" xml:space="preserve">
          <source>In this mode, the server will not request authentication until the client actually starts the object negotiation phase of the push, rather than during the initial contact. For this reason, you must also enable the &lt;code&gt;http.receivepack&lt;/code&gt; config option in any repositories that should accept a push. The default behavior, if &lt;code&gt;http.receivepack&lt;/code&gt; is not set, is to reject any pushes by unauthenticated users; the initial request will therefore report &lt;code&gt;403 Forbidden&lt;/code&gt; to the client, without even giving an opportunity for authentication.</source>
          <target state="translated">В этом режиме сервер не будет запрашивать аутентификацию до тех пор, пока клиент не начнет фазу согласования объекта push, а не во время первоначального контакта. По этой причине вы также должны включить &lt;code&gt;http.receivepack&lt;/code&gt; конфигурации http.receivepack во всех репозиториях, которые должны принимать push. Поведение по умолчанию, если &lt;code&gt;http.receivepack&lt;/code&gt; не задано, заключается в отклонении любых запросов от неаутентифицированных пользователей; Таким образом, первоначальный запрос будет сообщать клиенту &lt;code&gt;403 Forbidden&lt;/code&gt; , даже не предоставляя возможности для аутентификации.</target>
        </trans-unit>
        <trans-unit id="427d8f8d92a71761648b972f0beb3c2aad83aaaa" translate="yes" xml:space="preserve">
          <source>In this more general usage, you provide &lt;code&gt;git bisect&lt;/code&gt; with a &quot;new&quot; commit that has some property and an &quot;old&quot; commit that doesn&amp;rsquo;t have that property. Each time &lt;code&gt;git bisect&lt;/code&gt; checks out a commit, you test if that commit has the property. If it does, mark the commit as &quot;new&quot;; otherwise, mark it as &quot;old&quot;. When the bisection is done, &lt;code&gt;git bisect&lt;/code&gt; will report which commit introduced the property.</source>
          <target state="translated">В этом более общем использовании вы предоставляете &lt;code&gt;git bisect&lt;/code&gt; &amp;laquo;новый&amp;raquo; коммит, у которого есть какое-то свойство, и &amp;laquo;старый&amp;raquo; коммит, у которого этого свойства нет. Каждый раз, когда &lt;code&gt;git bisect&lt;/code&gt; проверяет фиксацию, вы проверяете, есть ли у этой фиксации свойство. Если это так, отметьте фиксацию как &amp;laquo;новую&amp;raquo;; в противном случае отметьте его как &amp;laquo;старый&amp;raquo;. Когда деление пополам выполнено, &lt;code&gt;git bisect&lt;/code&gt; сообщит, какой коммит ввел свойство.</target>
        </trans-unit>
        <trans-unit id="e6da0601a9e7aee317ec7d6d594e01f938b779c4" translate="yes" xml:space="preserve">
          <source>In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. This option prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">В необычных сценариях вы не сможете создавать файлы больше определенного размера в вашей файловой системе, и этот параметр можно использовать, чтобы указать команде разделить выходной файл пакета на несколько независимых файлов пакетов, каждый из которых не превышает заданный размер. Размер может быть дополнен суффиксами &amp;laquo;k&amp;raquo;, &amp;laquo;m&amp;raquo; или &amp;laquo;g&amp;raquo;. Минимальный допустимый размер ограничен 1 МиБ. Эта опция предотвращает создание растрового индекса. По умолчанию не ограничено, если не установлена ​​переменная конфигурации &lt;code&gt;pack.packSizeLimit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6119784d7cd9e9e9f521473e212223da8f242e" translate="yes" xml:space="preserve">
          <source>In versions of Git before 2.23.0 patterns containing \0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \0 and &lt;code&gt;--ignore-case&lt;/code&gt;.</source>
          <target state="translated">В версиях Git до 2.23.0 шаблоны, содержащие \ 0, будут считаться исправленными. Это никогда не было задокументировано, также были странные и недокументированные взаимодействия между, например, не-ASCII шаблонами, содержащими \ 0 и &lt;code&gt;--ignore-case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5da95a93eebb0b267da3b6f30d0296fee9bbc09f" translate="yes" xml:space="preserve">
          <source>Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit or 64 bit systems, respectively), plus the length of the branch name (typically under 200 bytes), per branch. fast-import will easily handle as many as 10,000 inactive branches in under 2 MiB of memory.</source>
          <target state="translated">Неактивные ветки хранятся в структуре,которая использует 96 или 120 байт (32-битные или 64-битные системы,соответственно),плюс длина имени ветки (обычно менее 200 байт),на каждую ветку.Быстрый импорт легко справится с 10 000 неактивных ветвей в памяти менее 2 Мбайт.</target>
        </trans-unit>
        <trans-unit id="40bf5b4a4e7b04d6908a8f7645b8e99e811e42d8" translate="yes" xml:space="preserve">
          <source>Include Some Progress Messages</source>
          <target state="translated">Включить некоторые сообщения о достигнутом прогрессе</target>
        </trans-unit>
        <trans-unit id="d1a7a0c5683de418c5f98fc4beae70e15874a175" translate="yes" xml:space="preserve">
          <source>Include a line &amp;ldquo;log size &amp;lt;number&amp;gt;&amp;rdquo; in the output for each commit, where &amp;lt;number&amp;gt; is the length of that commit&amp;rsquo;s message in bytes. Intended to speed up tools that read log messages from &lt;code&gt;git log&lt;/code&gt; output by allowing them to allocate space in advance.</source>
          <target state="translated">Включите строку &amp;laquo;размер журнала &amp;lt;число&amp;gt;&amp;raquo; в вывод для каждой фиксации, где &amp;lt;число&amp;gt; - длина сообщения этого фиксации в байтах. Предназначен для ускорения работы инструментов, которые читают сообщения журнала из вывода &lt;code&gt;git log&lt;/code&gt; , позволяя им заранее выделять место.</target>
        </trans-unit>
        <trans-unit id="af14d11414c6ac75b39c95b283e5bcf0f4ccb002" translate="yes" xml:space="preserve">
          <source>Include additional statistics at the end of blame output.</source>
          <target state="translated">Включите дополнительную статистику в конце вывода вины.</target>
        </trans-unit>
        <trans-unit id="47c5e0ca752d4a1deb14e562052c4b503ef081b0" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">Включите коммиты, доступные из &amp;lt;rev&amp;gt; (т.е. &amp;lt;rev&amp;gt; и его предков).</target>
        </trans-unit>
        <trans-unit id="9605f416b0921199291f14b56df68cc8fe57350a" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev2&amp;gt; but exclude those that are reachable from &amp;lt;rev1&amp;gt;. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Включите коммиты, доступные из &amp;lt;rev2&amp;gt;, но исключите те, которые доступны из &amp;lt;rev1&amp;gt;. Если &amp;lt;rev1&amp;gt; или &amp;lt;rev2&amp;gt; опущены, по умолчанию используется &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce2adffe692042c194b87264e9afec51300d7f42" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; but exclude those that are reachable from both. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Включите коммиты, которые доступны из &amp;lt;rev1&amp;gt; или &amp;lt;rev2&amp;gt;, но исключите те, которые доступны из обоих. Если &amp;lt;rev1&amp;gt; или &amp;lt;rev2&amp;gt; опущены, по умолчанию используется &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1236fce64f1fb93f2ef7dcc7912c2d79c1d22c1" translate="yes" xml:space="preserve">
          <source>Include cross-references to the glossary, where appropriate.</source>
          <target state="translated">При необходимости включите перекрестные ссылки на глоссарий.</target>
        </trans-unit>
        <trans-unit id="ac12c15729a8f56d7cafe2e8c1b0d7927d0e53f1" translate="yes" xml:space="preserve">
          <source>Include debugging information related to the movement of lines between files (see &lt;code&gt;-C&lt;/code&gt;) and lines moved within a file (see &lt;code&gt;-M&lt;/code&gt;). The first number listed is the score. This is the number of alphanumeric characters detected as having been moved between or within files. This must be above a certain threshold for &lt;code&gt;git blame&lt;/code&gt; to consider those lines of code to have been moved.</source>
          <target state="translated">Включите отладочную информацию, связанную с перемещением строк между файлами (см. &lt;code&gt;-C&lt;/code&gt; ) и строками, перемещаемыми внутри файла (см. &lt;code&gt;-M&lt;/code&gt; ). Первое число в списке - это счет. Это количество буквенно-цифровых символов, обнаруженных как перемещенные между файлами или внутри файлов. Это должно быть выше определенного порога, чтобы &lt;code&gt;git blame&lt;/code&gt; мог считать эти строки кода перемещенными.</target>
        </trans-unit>
        <trans-unit id="eac52c02432a2a159a563ec983012928139e33b8" translate="yes" xml:space="preserve">
          <source>Include objects in &lt;code&gt;.keep&lt;/code&gt; files when repacking. Note that we still do not delete &lt;code&gt;.keep&lt;/code&gt; packs after &lt;code&gt;pack-objects&lt;/code&gt; finishes. This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches. This option is generally only useful if you are writing bitmaps with &lt;code&gt;-b&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;, as it ensures that the bitmapped packfile has the necessary objects.</source>
          <target state="translated">Включите объекты в файлы &lt;code&gt;.keep&lt;/code&gt; при переупаковке. Обратите внимание, что мы по-прежнему не удаляем пакеты &lt;code&gt;.keep&lt;/code&gt; после завершения работы с &lt;code&gt;pack-objects&lt;/code&gt; . Это означает, что мы можем дублировать объекты, но это делает этот параметр безопасным для использования при одновременных отправках или выборках. Этот параметр обычно полезен только в том случае, если вы пишете растровые изображения с помощью &lt;code&gt;-b&lt;/code&gt; или &lt;code&gt;repack.writeBitmaps&lt;/code&gt; , поскольку он гарантирует, что растровый файл пакета содержит необходимые объекты.</target>
        </trans-unit>
        <trans-unit id="3b3acf7c7b624670bc98269d1db58c312d8f1ad9" translate="yes" xml:space="preserve">
          <source>Include patch text in the output.</source>
          <target state="translated">Включите текст патча в выходной сигнал.</target>
        </trans-unit>
        <trans-unit id="7f58d83c9ac95ca37a657dfc92f2d025971598c2" translate="yes" xml:space="preserve">
          <source>Include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status.</source>
          <target state="translated">Включите вывод &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; в шаблон сообщения фиксации при использовании редактора для подготовки сообщения фиксации. По умолчанию включено, но может использоваться для переопределения переменной конфигурации commit.status.</target>
        </trans-unit>
        <trans-unit id="798a42403927f2977bd316b8bb1bba46f3e2c944" translate="yes" xml:space="preserve">
          <source>Include unasked-for annotated tags if the object they reference was included in the resulting packfile. This can be useful to send new tags to native Git clients.</source>
          <target state="translated">Включать незапрошенные аннотированные теги,если объект,на который они ссылаются,был включен в результирующий файл пакета.Это может быть полезно для отправки новых тегов родным клиентам Git'а.</target>
        </trans-unit>
        <trans-unit id="c5f574d342fa2383147936f6ccc821ddf1edb5ef" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to add a new file or change the content of an existing file. This command has two different means of specifying the content of the file.</source>
          <target state="translated">Включен в команду &lt;code&gt;commit&lt;/code&gt; для добавления нового файла или изменения содержимого существующего файла. У этой команды есть два разных способа определения содержимого файла.</target>
        </trans-unit>
        <trans-unit id="8dfee16c07e63cf25f2958c656ce64f423b1c0b9" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove a file or recursively delete an entire directory from the branch. If the file or directory removal makes its parent directory empty, the parent directory will be automatically removed too. This cascades up the tree until the first non-empty directory or the root is reached.</source>
          <target state="translated">Включен в команду &lt;code&gt;commit&lt;/code&gt; для удаления файла или рекурсивного удаления всего каталога из ветки. Если при удалении файла или каталога его родительский каталог становится пустым, родительский каталог также будет автоматически удален. Это каскадирует дерево до тех пор, пока не будет достигнут первый непустой каталог или корень.</target>
        </trans-unit>
        <trans-unit id="87d365412b703101b1d281d9e93e3f278251dd0d" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove all files (and also all directories) from the branch. This command resets the internal branch structure to have no files in it, allowing the frontend to subsequently add all interesting files from scratch.</source>
          <target state="translated">Включен в команду &lt;code&gt;commit&lt;/code&gt; для удаления всех файлов (а также всех каталогов) из ветки. Эта команда сбрасывает внутреннюю структуру ветвей, чтобы в ней не было файлов, позволяя веб-интерфейсу впоследствии добавлять все интересные файлы с нуля.</target>
        </trans-unit>
        <trans-unit id="28dccd9788a09aa2f373fa8c25c3b39e9406a080" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt;&lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; command to add a new note annotating a &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; or change this annotation contents. Internally it is similar to filemodify 100644 on &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; path (maybe split into subdirectories). It&amp;rsquo;s not advised to use any other commands to write to the &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; tree except &lt;code&gt;filedeleteall&lt;/code&gt; to delete all existing notes in this tree. This command has two different means of specifying the content of the note.</source>
          <target state="translated">Включен в команду &lt;code&gt;commit&lt;/code&gt; &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; для добавления новой заметки, аннотирующей &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , или для изменения содержимого этой аннотации. Внутренне это похоже на filemodify 100644 на пути &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; (может быть разделен на подкаталоги). Не рекомендуется использовать какие-либо другие команды для записи в дерево &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; , кроме &lt;code&gt;filedeleteall&lt;/code&gt; , чтобы удалить все существующие заметки в этом дереве. У этой команды есть два разных средства для определения содержания заметки.</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="de153f024523e4c2c467ece94c841922a681ecff" translate="yes" xml:space="preserve">
          <source>Includes one additional ancestor commit. The additional ancestry link does not change the way the tree state is built at this commit. If the &lt;code&gt;from&lt;/code&gt; command is omitted when creating a new branch, the first &lt;code&gt;merge&lt;/code&gt; commit will be the first ancestor of the current commit, and the branch will start out with no files. An unlimited number of &lt;code&gt;merge&lt;/code&gt; commands per commit are permitted by fast-import, thereby establishing an n-way merge.</source>
          <target state="translated">Включает одну дополнительную фиксацию предка. Дополнительная ссылка на предков не меняет способ построения состояния дерева при этой фиксации. Если команда &lt;code&gt;from&lt;/code&gt; опущена при создании новой ветки, первая фиксация &lt;code&gt;merge&lt;/code&gt; будет первым предком текущей фиксации, а ветвь начнется без файлов. Неограниченное количество команд &lt;code&gt;merge&lt;/code&gt; на одну фиксацию разрешено с помощью быстрого импорта, тем самым устанавливая n-стороннее слияние.</target>
        </trans-unit>
        <trans-unit id="8623cf320c015aba351966293c038ddef6f53905" translate="yes" xml:space="preserve">
          <source>Incompatible options</source>
          <target state="translated">Несовместимые опции</target>
        </trans-unit>
        <trans-unit id="9020a39adcad5a9de717e37976fa2cef184a1df6" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch. In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">Включает изменения из удаленного репозитория в текущую ветку. В режиме по умолчанию &lt;code&gt;git pull&lt;/code&gt; является сокращением для &lt;code&gt;git fetch&lt;/code&gt; , за которым следует &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d61077e89adde5af7a04457989a77b3c48490ae" translate="yes" xml:space="preserve">
          <source>Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by &lt;code&gt;git pull&lt;/code&gt; to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.</source>
          <target state="translated">Включает изменения из названных коммитов (с тех пор, как их история расходится с текущей веткой) в текущую ветку. Эта команда используется &lt;code&gt;git pull&lt;/code&gt; для включения изменений из другого репозитория и может использоваться вручную для объединения изменений из одной ветки в другую.</target>
        </trans-unit>
        <trans-unit id="709702f7f984cb3913cdb163bc5d2fe003c81b05" translate="yes" xml:space="preserve">
          <source>Incremental output</source>
          <target state="translated">Инкрементальный выход</target>
        </trans-unit>
        <trans-unit id="571937052d91a812bc84d435a3200a79bb1a0ee1" translate="yes" xml:space="preserve">
          <source>Indeed untestable commits are often untestable because a breakage was introduced at one time, and that breakage was fixed only after many other commits were introduced.</source>
          <target state="translated">Действительно,неопровержимые коммиты часто бывают неопровержимыми,так как поломка была введена в одно время,и эта поломка была исправлена только после того,как были введены многие другие коммиты.</target>
        </trans-unit>
        <trans-unit id="78699f384a94184571a61ab6b2f36f5cdf341b61" translate="yes" xml:space="preserve">
          <source>Indicate that only the objects wanted need to be fetched, not their dependents.</source>
          <target state="translated">Укажите,что нужны только те объекты,которые вы хотите получить,а не их иждивенцы.</target>
        </trans-unit>
        <trans-unit id="d063c49b2950871e5e846c69f89ed3fa8315be66" translate="yes" xml:space="preserve">
          <source>Indicate that these objects are being fetched from a promisor.</source>
          <target state="translated">Укажите,что эти объекты извлекаются из промоутера.</target>
        </trans-unit>
        <trans-unit id="d4b8f31320c23f43d173d656edb4ca6c63551ac5" translate="yes" xml:space="preserve">
          <source>Indicates a blob object name.</source>
          <target state="translated">Указывает имя объекта-объекта-объекта-объекта.</target>
        </trans-unit>
        <trans-unit id="6d441ed12cf0b86c55591d731de178963fe6c1ee" translate="yes" xml:space="preserve">
          <source>Indicates a commit object name.</source>
          <target state="translated">Обозначает имя объекта коммита.</target>
        </trans-unit>
        <trans-unit id="e89d58f77c5643f4921d84ac3c1216b6dc569e02" translate="yes" xml:space="preserve">
          <source>Indicates a commit or tag object name. A command that takes a &amp;lt;commit-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;commit&amp;gt; object but automatically dereferences &amp;lt;tag&amp;gt; objects that point at a &amp;lt;commit&amp;gt;.</source>
          <target state="translated">Указывает имя объекта фиксации или тега. Команда, которая принимает аргумент &amp;lt;commit-ish&amp;gt;, в конечном итоге хочет работать с объектом &amp;lt;commit&amp;gt;, но автоматически разыменовывает объекты &amp;lt;tag&amp;gt;, которые указывают на &amp;lt;commit&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="31963740af1f01e0807009b4b0a81e30ade64f1a" translate="yes" xml:space="preserve">
          <source>Indicates a filename - almost always relative to the root of the tree structure &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; describes.</source>
          <target state="translated">Указывает имя файла - почти всегда относительно корня древовидной структуры, &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; описывает GIT_INDEX_FILE .</target>
        </trans-unit>
        <trans-unit id="c59be5c9a5ab736a07e28f031fa629ea1cac80d9" translate="yes" xml:space="preserve">
          <source>Indicates a tree object name.</source>
          <target state="translated">Указывает имя объекта дерева.</target>
        </trans-unit>
        <trans-unit id="0236f6573fabb077368d656582f35373ba9e33e6" translate="yes" xml:space="preserve">
          <source>Indicates a tree, commit or tag object name. A command that takes a &amp;lt;tree-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;tree&amp;gt; object but automatically dereferences &amp;lt;commit&amp;gt; and &amp;lt;tag&amp;gt; objects that point at a &amp;lt;tree&amp;gt;.</source>
          <target state="translated">Указывает имя объекта дерева, фиксации или тега. Команда, которая принимает аргумент &amp;lt;tree-ish&amp;gt;, в конечном итоге хочет работать с объектом &amp;lt;tree&amp;gt;, но автоматически разыменовывает объекты &amp;lt;commit&amp;gt; и &amp;lt;tag&amp;gt;, которые указывают на &amp;lt;tree&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="73ecb0013f5389f15738299d7b0ca5b5c29b261f" translate="yes" xml:space="preserve">
          <source>Indicates that an object type is required. Currently one of: &lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, or &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">Указывает, что требуется тип объекта. В настоящее время одно из: &lt;code&gt;blob&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;commit&lt;/code&gt; или &lt;code&gt;tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db4dbaff6f210d92fcd8a0947f8ffe2ad6166cf6" translate="yes" xml:space="preserve">
          <source>Indicates the object name for any type of object.</source>
          <target state="translated">Указывает имя объекта для любого типа объекта.</target>
        </trans-unit>
        <trans-unit id="c66f56b69efd11f38dd2949f22030f51d42bccb8" translate="yes" xml:space="preserve">
          <source>Individual developer (participant)</source>
          <target state="translated">Индивидуальный разработчик (участник)</target>
        </trans-unit>
        <trans-unit id="dc704b04bf6fc4b099b66d2f7d86d56e0d061d7a" translate="yes" xml:space="preserve">
          <source>Individual developer (standalone)</source>
          <target state="translated">Индивидуальный разработчик (автономный)</target>
        </trans-unit>
        <trans-unit id="a964b0aa320ab2176eba7cb0319b97ea34b340ac" translate="yes" xml:space="preserve">
          <source>Individually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.</source>
          <target state="translated">Индивидуально проигрывайте все отложенные коммиты вместо того,чтобы быстро переадресовывать их на те,которые остались неизменными.Это гарантирует,что вся история ветви rebased будет состоять из новых коммитов.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="9bceb94c72e397fee5b7ad78b8c9312ee6319e43" translate="yes" xml:space="preserve">
          <source>Information about what is to be pushed is provided on the hook&amp;rsquo;s standard input with lines of the form:</source>
          <target state="translated">Информация о том, что должно быть отправлено, предоставляется на стандартном вводе ловушки со строками формы:</target>
        </trans-unit>
        <trans-unit id="43d35f7b76c469225469fd7a04662a08053d1e63" translate="yes" xml:space="preserve">
          <source>Initial client request</source>
          <target state="translated">Первоначальный запрос клиента</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="1b499097655f7a7af4711e162d7e54be3deca803" translate="yes" xml:space="preserve">
          <source>Initialization happens in &lt;code&gt;main()&lt;/code&gt;. Behind the scenes, an &lt;code&gt;atexit&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt; handler are registered.</source>
          <target state="translated">Инициализация происходит в &lt;code&gt;main()&lt;/code&gt; . За кадром регистрируются &lt;code&gt;atexit&lt;/code&gt; и обработчик &lt;code&gt;signal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42e32f1c6a8cf663f45361425590d312db136ea3" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout</source>
          <target state="translated">Инициализировать и модифицировать разреженную проверку</target>
        </trans-unit>
        <trans-unit id="5be83bd5256f93987e394207f3c5233baf2d713e" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout configuration, which reduces the checkout to a set of paths given by a list of patterns.</source>
          <target state="translated">Инициализируйте и модифицируйте конфигурацию разреженной проверки,которая сводит проверку к набору путей,заданных списком деталей.</target>
        </trans-unit>
        <trans-unit id="825b58a6f65001fb659dd3ff519bf4df985a29aa" translate="yes" xml:space="preserve">
          <source>Initialize the sparse-checkout file so the working directory starts with only the files in the root of the repository. The sparse-checkout file can be modified to grow the working directory as needed.</source>
          <target state="translated">Инициализируйте разреженный файл проверки так,чтобы рабочий каталог начинался только с файлов в корневом каталоге репозитория.Файл разреженной проверки может быть модифицирован для увеличения рабочего каталога по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="9e0eca47ea83eb468f0ac7fe2e029fd23bbe773e" translate="yes" xml:space="preserve">
          <source>Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting &lt;code&gt;submodule.$name.url&lt;/code&gt; in .git/config. It uses the same setting from &lt;code&gt;.gitmodules&lt;/code&gt; as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream.</source>
          <target state="translated">Инициализируйте подмодули, записанные в индексе (которые были добавлены и зафиксированы где-то еще), установив &lt;code&gt;submodule.$name.url&lt;/code&gt; в .git / config. Он использует те же настройки из &lt;code&gt;.gitmodules&lt;/code&gt; в качестве шаблона. Если URL-адрес относительный, он будет разрешен с использованием удаленного по умолчанию. Если удаленного по умолчанию нет, текущий репозиторий будет считаться вышестоящим.</target>
        </trans-unit>
        <trans-unit id="52f8f7589ec2fc901a83216cac5106872728a87d" translate="yes" xml:space="preserve">
          <source>Initialize, update or inspect submodules</source>
          <target state="translated">Инициализировать,обновлять или инспектировать субмодули</target>
        </trans-unit>
        <trans-unit id="0d880d50dc463cd4220f01bcf54c48c1f2d57098" translate="yes" xml:space="preserve">
          <source>Initializes an empty Git repository with additional metadata directories for &lt;code&gt;git svn&lt;/code&gt;. The Subversion URL may be specified as a command-line argument, or as full URL arguments to -T/-t/-b. Optionally, the target directory to operate on can be specified as a second argument. Normally this command initializes the current directory.</source>
          <target state="translated">Инициализирует пустой репозиторий Git с дополнительными каталогами метаданных для &lt;code&gt;git svn&lt;/code&gt; . URL Subversion может быть указан как аргумент командной строки или как аргументы полного URL-адреса для -T / -t / -b. При желании целевой каталог для работы может быть указан в качестве второго аргумента. Обычно эта команда инициализирует текущий каталог.</target>
        </trans-unit>
        <trans-unit id="01c2c8357a87e8a6148f1dd9a9c884aae5e4de53" translate="yes" xml:space="preserve">
          <source>Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.</source>
          <target state="translated">Изначально игнорируйте любые пробелы в определении перемещения,затем группируйте блоки перемещенного кода только в блок,если изменение пробела на строку одинаково.Это несовместимо с другими режимами.</target>
        </trans-unit>
        <trans-unit id="229b7991e581f774e065f13c78dfa8719c8c393f" translate="yes" xml:space="preserve">
          <source>Inline data format</source>
          <target state="translated">Формат данных Inline</target>
        </trans-unit>
        <trans-unit id="7c7935726f449ea7185a4fe42a9ddf2d1c53a2e4" translate="yes" xml:space="preserve">
          <source>Input Format</source>
          <target state="translated">Формат ввода</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">Входной формат</target>
        </trans-unit>
        <trans-unit id="789cc08a97020bab893e17ca6133192d1f9f1dac" translate="yes" xml:space="preserve">
          <source>Input is of the &quot;mboxrd&quot; format and &quot;^&amp;gt;+From &quot; line escaping is reversed.</source>
          <target state="translated">Входные данные имеют формат &amp;laquo;mboxrd&amp;raquo;, а экранирование строки &amp;laquo;^&amp;gt; + From&amp;raquo; перевернуто.</target>
        </trans-unit>
        <trans-unit id="26242e7bd97bd8eebf44f9f25f143aed3a9bdc4d" translate="yes" xml:space="preserve">
          <source>Input/output format</source>
          <target state="translated">формат ввода/вывода</target>
        </trans-unit>
        <trans-unit id="4038e1c7ebc07b210c228498bd5816f54233b768" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;progress&lt;/code&gt; statements every &amp;lt;n&amp;gt; objects, to be shown by &lt;code&gt;git fast-import&lt;/code&gt; during import.</source>
          <target state="translated">Вставляйте операторы &lt;code&gt;progress&lt;/code&gt; каждые &amp;lt;n&amp;gt; объекты, которые будут отображаться с помощью &lt;code&gt;git fast-import&lt;/code&gt; во время импорта.</target>
        </trans-unit>
        <trans-unit id="39c559793b49987eea00aba844e216707b6e7dcc" translate="yes" xml:space="preserve">
          <source>Insert custom links to the action bar of all project pages. This allows you to link to third-party scripts integrating into gitweb.</source>
          <target state="translated">Вставьте пользовательские ссылки на панель действий всех страниц проекта.Это позволит вам ссылаться на сторонние скрипты,интегрирующиеся в gitweb.</target>
        </trans-unit>
        <trans-unit id="ce8fd02283c353dc3cacd2d3e6c1eab64a1913a3" translate="yes" xml:space="preserve">
          <source>Inside double quotes, double quote &lt;code&gt;&quot;&lt;/code&gt; and backslash &lt;code&gt;\&lt;/code&gt; characters must be escaped: use &lt;code&gt;\&quot;&lt;/code&gt; for &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; for &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">Внутри двойных кавычек, двойных кавычек &lt;code&gt;&quot;&lt;/code&gt; и обратной косой черты &lt;code&gt;\&lt;/code&gt; символы должны быть экранированы: использование &lt;code&gt;\&quot;&lt;/code&gt; для &lt;code&gt;&quot;&lt;/code&gt; и &lt;code&gt;\\&lt;/code&gt; для &lt;code&gt;\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab67c68674bb4a9f1f690fac98c95aa9c2e1e750" translate="yes" xml:space="preserve">
          <source>Inspecting changes</source>
          <target state="translated">Проверка изменений</target>
        </trans-unit>
        <trans-unit id="ecf21e44dd8609734c0bc387cabc376ab485d9f8" translate="yes" xml:space="preserve">
          <source>Inspection and Comparison</source>
          <target state="translated">Проверка и сравнение</target>
        </trans-unit>
        <trans-unit id="e0c3f2780ee983978068137722cf2d423843d21f" translate="yes" xml:space="preserve">
          <source>Inspects, updates and manages submodules.</source>
          <target state="translated">Проверяет,обновляет и управляет субмодулями.</target>
        </trans-unit>
        <trans-unit id="d9fb6eb12bbc11fdad6f18ee5bfa79361ddad72b" translate="yes" xml:space="preserve">
          <source>Install the Toggle Word Wrap add-on that is available from &lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt; It adds a menu entry &quot;Enable Word Wrap&quot; in the composer&amp;rsquo;s &quot;Options&quot; menu that you can tick off. Now you can compose the message as you otherwise do (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), but you have to insert line breaks manually in any text that you type.</source>
          <target state="translated">Установите надстройку Toggle Word Wrap, доступную по &lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;адресу https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/.&lt;/a&gt; Он добавляет пункт меню &amp;laquo;Включить перенос слов&amp;raquo; в меню &amp;laquo;Параметры&amp;raquo; композитора, который можно поставить галочку. Теперь вы можете составить сообщение, как и раньше (вырезать + вставить, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; и т. Д.), Но вам придется вручную вставлять разрывы строк в любой набираемый текст.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="7fad939655efbad1612ce7f4867922684d56913b" translate="yes" xml:space="preserve">
          <source>Instantly browse your working repository in gitweb</source>
          <target state="translated">Мгновенный просмотр вашего рабочего репозитория в gitweb</target>
        </trans-unit>
        <trans-unit id="53c902fb07156c6117155b6a0b0738c7ca12a6bf" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;git bisect visualize&lt;/code&gt; and then &lt;code&gt;git reset --hard
fb47ddb2db&lt;/code&gt;, you might just want to tell Git that you want to skip the current commit:</source>
          <target state="translated">Вместо &lt;code&gt;git bisect visualize&lt;/code&gt; , а затем &lt;code&gt;git reset --hard fb47ddb2db&lt;/code&gt; , вы можете просто сказать Git, что хотите пропустить текущий коммит:</target>
        </trans-unit>
        <trans-unit id="483617d942bddc8b6c044cd054e06089960e1981" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; expects lines on stdin in the format</source>
          <target state="translated">Вместо идентификатора фиксации в командной строке (чего в данном случае не ожидается) &lt;code&gt;git http-fetch&lt;/code&gt; ожидает строки на стандартном вводе в формате</target>
        </trans-unit>
        <trans-unit id="978fdd37a8d1d967862cc9e916d011571d6998cf" translate="yes" xml:space="preserve">
          <source>Instead of an absolute timestamp relative timestamps work as well, e.g. 2.weeks.ago is valid to address anything older than 2 weeks.</source>
          <target state="translated">Вместо абсолютных временных меток работает также относительная временная метка,например,2 недели назад,чтобы обратиться к чему-нибудь старше 2 недель.</target>
        </trans-unit>
        <trans-unit id="ad6345e758058b67dc8e001b3a11fe48b9b5f52b" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames and mode changes. Turns off &quot;apply&quot;.</source>
          <target state="translated">Вместо применения патча выводите сжатое обобщение информации,полученной из расширенных заголовков git'а,таких как творения,переименования и изменения режима работы.Отключает &quot;применение&quot;.</target>
        </trans-unit>
        <trans-unit id="5429abc21a21a789987424e6c0ab7612e06a85eb" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output diffstat for the input. Turns off &quot;apply&quot;.</source>
          <target state="translated">Вместо того,чтобы применить патч,выводите дифстат для входа.Отключает &quot;применить&quot;.</target>
        </trans-unit>
        <trans-unit id="881bf52883e6605d5234b3f22aaf3b7b4afc6968" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors. Turns off &quot;apply&quot;.</source>
          <target state="translated">Вместо применения патча посмотрите,применим ли патч к текущему рабочему дереву и/или файлу индекса и обнаруживает ли он ошибки.Отключает &quot;применение&quot;.</target>
        </trans-unit>
        <trans-unit id="6e355f85b13671d925fde0c740a0dbae977bb0bc" translate="yes" xml:space="preserve">
          <source>Instead of basing a new branch on current HEAD (the default), use:</source>
          <target state="translated">Вместо того,чтобы основывать новую ветку на текущем HEAD (по умолчанию),используйте:</target>
        </trans-unit>
        <trans-unit id="54f9cd044bb973ffe696d82cb4d71b8b1fd61c38" translate="yes" xml:space="preserve">
          <source>Instead of calling cvsps, read the provided cvsps output file. Useful for debugging or when cvsps is being handled outside cvsimport.</source>
          <target state="translated">Вместо того,чтобы вызывать cvsps,прочтите предоставленный выходной файл cvsps.Полезен для отладки или когда cvsps обрабатывается вне cvsimport.</target>
        </trans-unit>
        <trans-unit id="bb5ec3e62f50f37c713576e81a7468472cf1721e" translate="yes" xml:space="preserve">
          <source>Instead of checking out unmerged entries, copy out the files from named stage. &amp;lt;number&amp;gt; must be between 1 and 3. Note: --stage=all automatically implies --temp.</source>
          <target state="translated">Вместо того, чтобы проверять не объединенные записи, скопируйте файлы из именованной сцены. &amp;lt;число&amp;gt; должно быть от 1 до 3. Примечание: --stage = all автоматически подразумевает --temp.</target>
        </trans-unit>
        <trans-unit id="15d18d5e837d77d2ad93145197274038afcfa944" translate="yes" xml:space="preserve">
          <source>Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:</source>
          <target state="translated">Вместо того,чтобы выбирать ближайший коммит самостоятельно,вы можете попросить Git сделать это за вас,выпустив команду:</target>
        </trans-unit>
        <trans-unit id="071c6c805d6df82b0ae0937a6e3d6e7d94979975" translate="yes" xml:space="preserve">
          <source>Instead of comparing with the tip of &quot;test&quot; branch, compare with the tip of the current branch, but limit the comparison to the file &quot;test&quot;.</source>
          <target state="translated">Вместо сравнения с кончиком &quot;тестовой&quot; ветки сравните с кончиком текущей ветки,но ограничьте сравнение файлом &quot;test&quot;.</target>
        </trans-unit>
        <trans-unit id="17207c6e7e5006477485c406ccec2ab95d9a0907" translate="yes" xml:space="preserve">
          <source>Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to &amp;lt;n&amp;gt; candidates. Increasing &amp;lt;n&amp;gt; above 10 will take slightly longer but may produce a more accurate result. An &amp;lt;n&amp;gt; of 0 will cause only exact matches to be output.</source>
          <target state="translated">Вместо того, чтобы рассматривать только 10 самых последних тегов в качестве кандидатов для описания входной фиксации, рассмотрите до &amp;lt;n&amp;gt; кандидатов. Увеличение &amp;lt;n&amp;gt; выше 10 займет немного больше времени, но может дать более точный результат. Если &amp;lt;n&amp;gt; = 0, будут выводиться только точные совпадения.</target>
        </trans-unit>
        <trans-unit id="3d51a8a573b601f04a9b432f10be7818f6056cab" translate="yes" xml:space="preserve">
          <source>Instead of copying the files to the working directory write the content to temporary files. The temporary name associations will be written to stdout.</source>
          <target state="translated">Вместо того,чтобы копировать файлы в рабочую директорию,записывайте их содержимое во временные файлы.Ассоциации временных имен будут записываться в stdout.</target>
        </trans-unit>
        <trans-unit id="aece37f2a7e1b433117b2533e4c10ff1af967895" translate="yes" xml:space="preserve">
          <source>Instead of explicitly specifying which refs to update, update all heads that locally exist.</source>
          <target state="translated">Вместо того,чтобы явно указывать,какие ссылки обновлять,обновите все головки,которые существуют локально.</target>
        </trans-unit>
        <trans-unit id="c9dd00560176cb59ca6811a38f98f0a00cea59a2" translate="yes" xml:space="preserve">
          <source>Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags.</source>
          <target state="translated">Вместо того,чтобы найти метку,которая предшествует коммиту,найдите метку,которая приходит после коммита,и,таким образом,содержит ее.Автоматически подразумевает --теги.</target>
        </trans-unit>
        <trans-unit id="c3bcf62d531bd115333abb263736c08fc67412f8" translate="yes" xml:space="preserve">
          <source>Instead of having gitweb find repositories by scanning filesystem starting from $projectroot, you can provide a pre-generated list of visible projects by setting &lt;code&gt;$projects_list&lt;/code&gt; to point to a plain text file with a list of projects (with some additional info).</source>
          <target state="translated">Вместо того, чтобы использовать gitweb для поиска репозиториев путем сканирования файловой системы, начиная с $ projectroot, вы можете предоставить предварительно сгенерированный список видимых проектов, установив &lt;code&gt;$projects_list&lt;/code&gt; для указания на простой текстовый файл со списком проектов (с некоторой дополнительной информацией).</target>
        </trans-unit>
        <trans-unit id="b8a426e0ceafe99f9ee69973b04f605e2dee7cb4" translate="yes" xml:space="preserve">
          <source>Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack. Especially useful when packing a repository that is used for private development. Use with &lt;code&gt;-d&lt;/code&gt;. This will clean up the objects that &lt;code&gt;git prune&lt;/code&gt; leaves behind, but &lt;code&gt;git fsck --full --dangling&lt;/code&gt; shows as dangling.</source>
          <target state="translated">Вместо того, чтобы постепенно упаковывать распакованные объекты, упакуйте все, на что есть ссылки, в один пакет. Особенно полезно при упаковке репозитория, который используется для частной разработки. Используйте с &lt;code&gt;-d&lt;/code&gt; . Это очистит объекты, которые оставляет после себя &lt;code&gt;git prune&lt;/code&gt; , но &lt;code&gt;git fsck --full --dangling&lt;/code&gt; отображается как висячий .</target>
        </trans-unit>
        <trans-unit id="f1ffab5966e331d53c3cb8a3d86f241f936c7bef" translate="yes" xml:space="preserve">
          <source>Instead of initializing the repository as a directory to either &lt;code&gt;$GIT_DIR&lt;/code&gt; or &lt;code&gt;./.git/&lt;/code&gt;, create a text file there containing the path to the actual repository. This file acts as filesystem-agnostic Git symbolic link to the repository.</source>
          <target state="translated">Вместо того, чтобы инициализировать репозиторий как каталог для &lt;code&gt;$GIT_DIR&lt;/code&gt; или &lt;code&gt;./.git/&lt;/code&gt; , создайте там текстовый файл, содержащий путь к фактическому репозиторию. Этот файл действует как не зависящая от файловой системы символическая ссылка Git на репозиторий.</target>
        </trans-unit>
        <trans-unit id="f0ef88b9adcd939e8a3f3a231e5d0c4737f1545c" translate="yes" xml:space="preserve">
          <source>Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines.</source>
          <target state="translated">Вместо того,чтобы оставлять конфликты в файле,разрешайте конфликты в пользу нашей (или их,или обеих)стороны строк.</target>
        </trans-unit>
        <trans-unit id="ca8be3d7e71d110990923e82a424a61c61fcfea3" translate="yes" xml:space="preserve">
          <source>Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for details.</source>
          <target state="translated">Вместо создания tar-архива из локального репозитория, получите tar-архив из удаленного репозитория. Обратите внимание, что удаленный репозиторий может накладывать ограничения на то, какие выражения sha1 могут быть разрешены в &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; . Подробнее см. &lt;a href=&quot;git-upload-archive&quot;&gt;Git-upload-archive [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f9313c2b37d59bfbfa07ff3336c61ac5f242846" translate="yes" xml:space="preserve">
          <source>Instead of multiple service names, multiple commands will be supported by a single service</source>
          <target state="translated">Вместо нескольких имен сервисов,несколько команд будут поддерживаться одним сервисом.</target>
        </trans-unit>
        <trans-unit id="9913e3351ae1177f0328b10cfa41d1a78100d839" translate="yes" xml:space="preserve">
          <source>Instead of naming each ref to push, specifies that all refs under &lt;code&gt;refs/&lt;/code&gt; (which includes but is not limited to &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/remotes/&lt;/code&gt;, and &lt;code&gt;refs/tags/&lt;/code&gt;) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; is set.</source>
          <target state="translated">Вместо того, чтобы именовать каждую ссылку для отправки, указывает, что все ссылки в &lt;code&gt;refs/&lt;/code&gt; (которые включают, но не ограничиваются, &lt;code&gt;refs/heads/&lt;/code&gt; , &lt;code&gt;refs/remotes/&lt;/code&gt; и &lt;code&gt;refs/tags/&lt;/code&gt; ) зеркалируются в удаленном репозитории. Недавно созданные локальные ссылки будут отправлены на удаленный конец, локально обновленные ссылки будут принудительно обновлены на удаленном конце, а удаленные ссылки будут удалены с удаленного конца. Это значение по умолчанию, если установлен параметр конфигурации &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9634150ab7e71bf3eb3f2b25ec8ede96c11d4e06" translate="yes" xml:space="preserve">
          <source>Instead of naming the commits using the path to reach them from heads (e.g. &quot;master~2&quot; to mean the grandparent of &quot;master&quot;), name them with the unique prefix of their object names.</source>
          <target state="translated">Вместо того,чтобы называть коммиты,используя путь к ним от голов (например,&quot;master~2&quot; в значении дедушки &quot;master&quot;),назовите их уникальным префиксом имен объектов.</target>
        </trans-unit>
        <trans-unit id="17b0b1c8040238e6478f5b3afd0b8cbc3b08f080" translate="yes" xml:space="preserve">
          <source>Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree.</source>
          <target state="translated">Вместо того,чтобы размещать клонированный репозиторий там,где он должен быть,поместите клонированный репозиторий в указанную директорию,а затем сделайте туда символическую ссылку на файловую систему-диагностику Git'а.В результате Git-репозиторий можно отделить от рабочего дерева.</target>
        </trans-unit>
        <trans-unit id="22fb130092ca941fcb14aff3909ae71b595afba3" translate="yes" xml:space="preserve">
          <source>Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository&amp;rsquo;s HEAD, point to &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; branch instead. In a non-bare repository, this is the branch that will be checked out. &lt;code&gt;--branch&lt;/code&gt; can also take tags and detaches the HEAD at that commit in the resulting repository.</source>
          <target state="translated">Вместо того, чтобы указывать вновь созданный HEAD на ветку, на которую указывает HEAD клонированного репозитория, укажите вместо этого на ветку &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; . В репозитории non-bare это ветка, которая будет извлечена. &lt;code&gt;--branch&lt;/code&gt; также может принимать теги и отделять HEAD от этого коммита в полученном репозитории.</target>
        </trans-unit>
        <trans-unit id="33ebce829b735e00e4c7bea8b4f644ee8c315aa6" translate="yes" xml:space="preserve">
          <source>Instead of printing both the SHA-1 and the name, print only the name. If given with --tags the usual tag prefix of &quot;tags/&quot; is also omitted from the name, matching the output of &lt;code&gt;git-describe&lt;/code&gt; more closely.</source>
          <target state="translated">Вместо того, чтобы печатать и SHA-1, и имя, напечатайте только имя. Если указано с --tags, обычный префикс тега &amp;laquo;tags /&amp;raquo; также опускается из имени, что более точно соответствует выходным данным &lt;code&gt;git-describe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="064cb6e81b93b30bcf346d10dc97336e618d6fae" translate="yes" xml:space="preserve">
          <source>Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of &lt;code&gt;git show-branch --independent&lt;/code&gt;.</source>
          <target state="translated">Вместо того, чтобы печатать базы слияния, выведите минимальное подмножество предоставленных коммитов с теми же предками. Другими словами, среди предоставленных коммитов перечислите те, которые не могут быть достигнуты ни с одной другой. Это имитирует поведение &lt;code&gt;git show-branch --independent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a77a1e8325cae4bfdfe406c89eaae3fe4ca07d52" translate="yes" xml:space="preserve">
          <source>Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; be specified. Note that the objects are visited in order sorted by their hashes.</source>
          <target state="translated">Вместо чтения списка объектов на стандартном вводе выполните запрошенную пакетную операцию для всех объектов в репозитории и любых альтернативных хранилищ объектов (а не только для доступных объектов). Требуется &lt;code&gt;--batch&lt;/code&gt; или &lt;code&gt;--batch-check&lt;/code&gt; . Обратите внимание, что объекты посещаются в порядке сортировки по их хешам.</target>
        </trans-unit>
        <trans-unit id="d4a14000f7e28706a0e6c2e4729bb02543a4d281" translate="yes" xml:space="preserve">
          <source>Instead of reading tree object(s) into the index, just empty it.</source>
          <target state="translated">Вместо того,чтобы читать объект(ы)дерева в индекс,просто опустошите его.</target>
        </trans-unit>
        <trans-unit id="5828d05fd5c0a35f4392daf67536f9a77ece2b90" translate="yes" xml:space="preserve">
          <source>Instead of running &lt;code&gt;git repack&lt;/code&gt; you can also run &lt;code&gt;git gc
--aggressive&lt;/code&gt;, which will also optimize other things after an import (e.g. pack loose refs). As noted in the &quot;AGGRESSIVE&quot; section in &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; the &lt;code&gt;--aggressive&lt;/code&gt; option will find new deltas with the &lt;code&gt;-f&lt;/code&gt; option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. For the reasons elaborated on above using &lt;code&gt;--aggressive&lt;/code&gt; after a fast-import is one of the few cases where it&amp;rsquo;s known to be worthwhile.</source>
          <target state="translated">Вместо запуска &lt;code&gt;git repack&lt;/code&gt; вы также можете запустить &lt;code&gt;git gc --aggressive&lt;/code&gt; , который также оптимизирует другие вещи после импорта (например, упаковывать свободные ссылки). Как отмечалось в разделе &amp;laquo;АГРЕССИВНЫЙ&amp;raquo; в &lt;a href=&quot;git-gc&quot;&gt;git-gc [1],&lt;/a&gt; параметр &lt;code&gt;--aggressive&lt;/code&gt; найдет новые дельты с параметром &lt;code&gt;-f&lt;/code&gt; для &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; . По причинам, изложенным выше, использование &lt;code&gt;--aggressive&lt;/code&gt; после быстрого импорта - один из немногих случаев, когда это целесообразно.</target>
        </trans-unit>
        <trans-unit id="27d7e1d82cdbf4a022b1041bc3a4b5c02db03622" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known diff tools, &lt;code&gt;git difftool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">Вместо запуска одного из известных инструментов сравнения, &lt;code&gt;git difftool&lt;/code&gt; можно настроить для запуска альтернативной программы, указав вызываемую командную строку в переменной конфигурации &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6ec50c9a1e350ef9a3f4f762c317cd2d6e8233" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known merge tool programs, &lt;code&gt;git mergetool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">Вместо запуска одной из известных инструментальных программ слияния &lt;code&gt;git mergetool&lt;/code&gt; можно настроить для запуска альтернативной программы, указав командную строку для вызова в переменной конфигурации &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09dffc4d1650e5ccccc05b0bf19a3e3e59eb7116" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs in the given trees.</source>
          <target state="translated">Вместо того,чтобы искать отслеживаемые файлы в рабочем дереве,найдите капли в данных деревьях.</target>
        </trans-unit>
        <trans-unit id="31ae83b44368ffd8feca3b205d3db8ea7d6a3c5c" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs registered in the index file.</source>
          <target state="translated">Вместо того,чтобы искать отслеживаемые файлы в рабочем дереве,используйте поисковые блоки,зарегистрированные в индексном файле.</target>
        </trans-unit>
        <trans-unit id="55e6c9aa38dceb73a0632da59bc95f69bdfc3cb4" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with &lt;code&gt;git diff&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; is a synonym for &lt;code&gt;--files-with-matches&lt;/code&gt;.</source>
          <target state="translated">Вместо отображения каждой совпадающей строки показывайте только имена файлов, которые содержат (или не содержат) совпадения. Для лучшей совместимости с &lt;code&gt;git diff&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; является синонимом &lt;code&gt;--files-with-matches&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1fdcf67f0afaa931922f6239ba4fdd53758ce0d" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show the number of lines that match.</source>
          <target state="translated">Вместо того,чтобы показывать каждую совпаденную строку,покажите количество совпадающих строк.</target>
        </trans-unit>
        <trans-unit id="9ddb49ffe2885e9ce52c33a63e80e23af2a075a9" translate="yes" xml:space="preserve">
          <source>Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt; handles the case of three or more commits.</source>
          <target state="translated">Вместо того, чтобы показывать список коммитов, определите возможные базы слияния для указанных коммитов. Все базы слияния будут содержаться во всех указанных коммитах. Это отличается от того, как &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; обрабатывает случай трех или более коммитов.</target>
        </trans-unit>
        <trans-unit id="6ba3d7561fe60e77ce239084badd1d1856e50d97" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal commit object name, show only a partial prefix. Non default number of digits can be specified with &quot;--abbrev=&amp;lt;n&amp;gt;&quot; (which also modifies diff output, if it is displayed).</source>
          <target state="translated">Вместо того, чтобы показывать полное 40-байтовое шестнадцатеричное имя объекта фиксации, показывайте только частичный префикс. Количество цифр не по умолчанию может быть указано с помощью &quot;--abbrev = &amp;lt;n&amp;gt;&quot; (который также изменяет вывод diff, если он отображается).</target>
        </trans-unit>
        <trans-unit id="7d6a3b8755cc865088fd97c8d79f6b68eb4292bc" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object lines, show only a partial prefix. Non default number of digits can be specified with --abbrev=&amp;lt;n&amp;gt;.</source>
          <target state="translated">Вместо того, чтобы показывать полные 40-байтовые шестнадцатеричные строки объекта, показывайте только частичный префикс. Количество цифр не по умолчанию можно указать с помощью --abbrev = &amp;lt;n&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="dcd3315e868be633e341c6b1fc6b217d4459f224" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. This is independent of the &lt;code&gt;--full-index&lt;/code&gt; option above, which controls the diff-patch output format. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вместо того, чтобы показывать полное 40-байтовое шестнадцатеричное имя объекта в выходных данных в формате diff-raw и в строках заголовка diff-tree, показывайте только частичный префикс. Это не зависит от указанной &lt;code&gt;--full-index&lt;/code&gt; опции --full-index , которая управляет выходным форматом diff-patch. Количество цифр не по умолчанию можно указать с помощью &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ac504d3062e8b5bad74846fd627b7807bedc4f2" translate="yes" xml:space="preserve">
          <source>Instead of showing the path names relative to the current working directory, show the full path names.</source>
          <target state="translated">Вместо того,чтобы показывать имена путей относительно текущей рабочей директории,показывайте полные имена путей.</target>
        </trans-unit>
        <trans-unit id="5f0ed09aafafab46ef0c48e35d2b30851c21ae6a" translate="yes" xml:space="preserve">
          <source>Instead of staging files after each individual change, you can tell &lt;code&gt;git commit&lt;/code&gt; to notice the changes to the files whose contents are tracked in your working tree and do corresponding &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you. That is, this example does the same as the earlier example if there is no other change in your working tree:</source>
          <target state="translated">Вместо того, чтобы размещать файлы после каждого отдельного изменения, вы можете указать &lt;code&gt;git commit&lt;/code&gt; замечать изменения в файлах, содержимое которых отслеживается в вашем рабочем дереве, и выполнять для вас соответствующие &lt;code&gt;git add&lt;/code&gt; и &lt;code&gt;git rm&lt;/code&gt; . То есть этот пример делает то же самое, что и предыдущий, если в вашем рабочем дереве нет других изменений:</target>
        </trans-unit>
        <trans-unit id="a675a0b8f5c03b948f0d18f87a17852f45d21abd" translate="yes" xml:space="preserve">
          <source>Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges.</source>
          <target state="translated">Вместо того,чтобы останавливаться на первом неудачном слиянии,делайте все это одним выстрелом-продолжайте слияние даже тогда,когда предыдущие слияния возвращали ошибки,и возвращайте код ошибки только после всех слияний.</target>
        </trans-unit>
        <trans-unit id="de32bccd3ddde71a98cffd2de1232e1c99dfd513" translate="yes" xml:space="preserve">
          <source>Instead of submitting create a series of shelved changelists. After creating each shelve, the relevant files are reverted/deleted. If you have multiple commits pending multiple shelves will be created.</source>
          <target state="translated">Вместо того,чтобы подавать заявки,создайте серию полочных сменщиков.После создания каждой полки соответствующие файлы возвращаются/удаляются.Если у вас есть несколько коммитов в ожидании создания нескольких полок,будут созданы несколько полок.</target>
        </trans-unit>
        <trans-unit id="140c71a8b471c44c130e5b1eee8b0237e8238e05" translate="yes" xml:space="preserve">
          <source>Instead of taking list of paths from the command line, read list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.</source>
          <target state="translated">Вместо того,чтобы брать список путей из командной строки,читайте список путей со стандартного входа.По умолчанию пути разделены LF (т.е.один путь на строку).</target>
        </trans-unit>
        <trans-unit id="f4ba2e4e1080efba3c28ca42286f9295fb7a6889" translate="yes" xml:space="preserve">
          <source>Instead of the commit subject, use some other information to describe each commit. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can be any string accepted by the &lt;code&gt;--format&lt;/code&gt; option of &lt;code&gt;git log&lt;/code&gt;, such as &lt;code&gt;* [%h] %s&lt;/code&gt;. (See the &quot;PRETTY FORMATS&quot; section of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.)</source>
          <target state="translated">Вместо темы коммита используйте другую информацию для описания каждого коммита. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; может быть любой строкой, принятой параметром &lt;code&gt;--format&lt;/code&gt; журнала &lt;code&gt;git log&lt;/code&gt; , например &lt;code&gt;* [%h] %s&lt;/code&gt; . (См. Раздел &amp;laquo;ПРИЯТНЫЕ ФОРМАТЫ&amp;raquo; в &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a4e872330a2ee34ffbac6bb806a9bf43b1d76b3c" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object size identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">Вместо содержимого покажите размер объекта, обозначенный &amp;lt;object&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="f066e23ab4bd2d63e94325b4a2a048945fb424e1" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object type identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">Вместо содержимого покажите тип объекта, обозначенный &amp;lt;object&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="01b660ce7f25b8747605b72657d7e3925704df33" translate="yes" xml:space="preserve">
          <source>Instead of the default &quot;symref&quot; format for HEAD and other symbolic reference files, use symbolic links. This is sometimes needed to work with old scripts that expect HEAD to be a symbolic link.</source>
          <target state="translated">Вместо формата &quot;symref&quot; по умолчанию для HEAD и других символических файлов ссылок используйте символические ссылки.Иногда это необходимо для работы со старыми сценариями,которые ожидают,что HEAD будет символической ссылкой.</target>
        </trans-unit>
        <trans-unit id="f146d5682a8b5a97d10d05b37274aa1ba3a49c07" translate="yes" xml:space="preserve">
          <source>Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames.</source>
          <target state="translated">Вместо 4-х цифр по умолчанию с ведущими нулями,для генерируемых имён файлов может быть задана различная точность.</target>
        </trans-unit>
        <trans-unit id="e1d28ba0f9256454e559ca46e186461c224089ef" translate="yes" xml:space="preserve">
          <source>Instead of the first handful of characters, show the full pre- and post-image blob object names on the &quot;index&quot; line when generating patch format output.</source>
          <target state="translated">Вместо первой горстки символов при генерации вывода в формате патча показывайте полные имена объектов до и после изображения в строке &quot;индекс&quot;.</target>
        </trans-unit>
        <trans-unit id="e3b6588aa8ce45f7528fa4adfa5f41dc47858a56" translate="yes" xml:space="preserve">
          <source>Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note, this only includes the alias name and not its expanded email addresses. See &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; for more information about aliases.</source>
          <target state="translated">Вместо обычной операции выгрузите сокращенные имена псевдонимов из настроенных файлов псевдонимов, по одному на строку в алфавитном порядке. Обратите внимание, это включает только псевдоним, но не его расширенные адреса электронной почты. См. &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; для получения дополнительной информации о псевдонимах.</target>
        </trans-unit>
        <trans-unit id="77a59d82290cfd961dc9ff35f15683facfa89709" translate="yes" xml:space="preserve">
          <source>Instead of the standard &lt;code&gt;[PATCH]&lt;/code&gt; prefix in the subject line, instead use &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt;. This allows for useful naming of a patch series, and can be combined with the &lt;code&gt;--numbered&lt;/code&gt; option.</source>
          <target state="translated">Вместо стандартного префикса &lt;code&gt;[PATCH]&lt;/code&gt; в строке темы используйте &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt; . Это позволяет использовать &lt;code&gt;--numbered&lt;/code&gt; именование серии патчей и может быть объединено с параметром --numbered .</target>
        </trans-unit>
        <trans-unit id="440b20677cca3bad5d5589368544d09ff6997de8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, you can also choose just to update one branch at a time, and to store it locally under an arbitrary name:</source>
          <target state="translated">Вместо использования &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; вы также можете выбрать обновление по одной ветке за раз и хранить ее локально под произвольным именем:</target>
        </trans-unit>
        <trans-unit id="c80da0469d96c6db5cfae1c5b4b2cc65c570bdb0" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;.patch&lt;/code&gt; as the suffix for generated filenames, use specified suffix. A common alternative is &lt;code&gt;--suffix=.txt&lt;/code&gt;. Leaving this empty will remove the &lt;code&gt;.patch&lt;/code&gt; suffix.</source>
          <target state="translated">Вместо использования &lt;code&gt;.patch&lt;/code&gt; в качестве суффикса для сгенерированных имен файлов используйте указанный суффикс. Распространенной альтернативой является &lt;code&gt;--suffix=.txt&lt;/code&gt; . Если оставить это поле &lt;code&gt;.patch&lt;/code&gt; суффикс .patch будет удален .</target>
        </trans-unit>
        <trans-unit id="f82d2e94f21038afaa9f1d66d3a9a0e365538f7c" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any ref found in &lt;code&gt;refs/&lt;/code&gt; namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag.</source>
          <target state="translated">Вместо использования только аннотированных тегов используйте любую ссылку, найденную в &lt;code&gt;refs/&lt;/code&gt; namespace. Этот параметр позволяет сопоставить любую известную ветвь, ветку удаленного отслеживания или облегченный тег.</target>
        </trans-unit>
        <trans-unit id="1177311a3949b6b80d45daef7bf2616b79441b65" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any tag found in &lt;code&gt;refs/tags&lt;/code&gt; namespace. This option enables matching a lightweight (non-annotated) tag.</source>
          <target state="translated">Вместо использования только аннотированных тегов используйте любой тег из пространства имен &lt;code&gt;refs/tags&lt;/code&gt; . Этот параметр позволяет сопоставить легкий (не аннотированный) тег.</target>
        </trans-unit>
        <trans-unit id="fa50874379be0d623d79d8af182cc42f83a49b1c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt; digits, or as many digits as needed to form a unique object name. An &amp;lt;n&amp;gt; of 0 will suppress long format, only showing the closest tag.</source>
          <target state="translated">Вместо использования 7 шестнадцатеричных цифр по умолчанию в качестве сокращенного имени объекта используйте цифры &amp;lt;n&amp;gt; или столько цифр, сколько необходимо для формирования уникального имени объекта. Значение 0 для &amp;lt;n&amp;gt; подавляет длинный формат, показывая только ближайший тег.</target>
        </trans-unit>
        <trans-unit id="183487409af3884cbc9c819c550a69752622875c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt;+1 digits. Note that 1 column is used for a caret to mark the boundary commit.</source>
          <target state="translated">Вместо использования по умолчанию 7 + 1 шестнадцатеричных цифр в качестве сокращенного имени объекта используйте цифры &amp;lt;n&amp;gt; +1. Обратите внимание, что для обозначения фиксации границы используется 1 столбец.</target>
        </trans-unit>
        <trans-unit id="ee5547b5d72f6d52e84d0986cad360b6f68e956a" translate="yes" xml:space="preserve">
          <source>Instead of using the remote name &lt;code&gt;origin&lt;/code&gt; to keep track of the upstream repository, use &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вместо того чтобы использовать имя удаленного &lt;code&gt;origin&lt;/code&gt; , чтобы отслеживать вверх по течению хранилища, используйте &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acaf18a5ec5cac3fd2f3b3d56ba27133d9e16abf" translate="yes" xml:space="preserve">
          <source>Instead of using the tip of the current branch, compare with the tip of &quot;test&quot; branch.</source>
          <target state="translated">Вместо того,чтобы использовать кончик текущей ветки,сравните с кончиком &quot;тестовой&quot; ветки.</target>
        </trans-unit>
        <trans-unit id="0e0bb2a4d944b8f5531055e279607820e676a94b" translate="yes" xml:space="preserve">
          <source>Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, &lt;code&gt;^commit&lt;/code&gt;, &lt;code&gt;commit1..commit2&lt;/code&gt;, and &lt;code&gt;commit1...commit2&lt;/code&gt; notations cannot be used).</source>
          <target state="translated">Вместо того, чтобы идти по цепочке предков фиксации, переместите записи рефлога от самой последней к более старой. Когда используется этот параметр, вы не можете указать коммиты для исключения (то есть нотации &lt;code&gt;^commit&lt;/code&gt; , &lt;code&gt;commit1..commit2&lt;/code&gt; и &lt;code&gt;commit1...commit2&lt;/code&gt; использовать нельзя).</target>
        </trans-unit>
        <trans-unit id="00c411b0a21221afdc6e21c624bf253d7212e3a9" translate="yes" xml:space="preserve">
          <source>Instead of writing the results out to &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt;, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in.</source>
          <target state="translated">Вместо того, чтобы записывать результаты в &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt; , запишите результирующий индекс в названный файл. Пока команда работает, исходный индексный файл блокируется тем же механизмом, что и обычно. Файл должен иметь возможность переименовать (2) во временный файл, который создается рядом с обычным индексным файлом; обычно это означает, что он должен находиться в той же файловой системе, что и сам индексный файл, и вам необходимо разрешение на запись в каталоги, в которых находятся индексный файл и выходной файл индекса.</target>
        </trans-unit>
        <trans-unit id="ef06396aed739ff032fb1ddeda938ad4cf5e4280" translate="yes" xml:space="preserve">
          <source>Instruct Git to avoid trying to guess defaults for &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;user.name&lt;/code&gt;, and instead retrieve the values only from the configuration. For example, if you have multiple email addresses and would like to use a different one for each repository, then with this configuration option set to &lt;code&gt;true&lt;/code&gt; in the global config along with a name, Git will prompt you to set up an email before making new commits in a newly cloned repository. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;user.email&lt;/code&gt; Git, чтобы он не пытался угадывать значения по умолчанию для user.email и &lt;code&gt;user.name&lt;/code&gt; , а вместо этого извлекал значения только из конфигурации. Например, если у вас есть несколько адресов электронной почты и вы хотите использовать разные адреса для каждого репозитория, то с этой опцией конфигурации, установленной в значение &lt;code&gt;true&lt;/code&gt; в глобальной конфигурации вместе с именем, Git предложит вам настроить электронную почту перед созданием нового фиксируется в недавно клонированном репозитории. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a592acd9f11ad3bff77a1878bfa756913e7df3fe" translate="yes" xml:space="preserve">
          <source>Instruction to add new data</source>
          <target state="translated">Инструкция по добавлению новых данных</target>
        </trans-unit>
        <trans-unit id="c222c271406b6a5c2fcfc84ba72b7981aee6b09e" translate="yes" xml:space="preserve">
          <source>Instruction to copy from base object</source>
          <target state="translated">Инструкция по копированию с базового объекта</target>
        </trans-unit>
        <trans-unit id="6131d2bc98a67fbf2df419d53c2a5951a56eb747" translate="yes" xml:space="preserve">
          <source>Instructs the remote helper that any subsequent input is part of a fast-import stream (generated by &lt;code&gt;git fast-export&lt;/code&gt;) containing objects which should be pushed to the remote.</source>
          <target state="translated">Указывает удаленному помощнику, что любой последующий ввод является частью потока быстрого импорта (сгенерированного &lt;code&gt;git fast-export&lt;/code&gt; ), содержащего объекты, которые должны быть отправлены на удаленный.</target>
        </trans-unit>
        <trans-unit id="563eacc97631ea8eeadfe6b54ffbd63455326490" translate="yes" xml:space="preserve">
          <source>Integer. Specifies desired depth of nested regions in the event output. Regions deeper than this value will be omitted. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; environment variable. Defaults to 2.</source>
          <target state="translated">Integer. Задает желаемую глубину вложенных областей в выходных данных события. Области глубже этого значения будут опущены. Может быть переопределено переменной среды &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; . По умолчанию 2.</target>
        </trans-unit>
        <trans-unit id="f3e0144605c9578fc597fd7ff39de75aab2afefe" translate="yes" xml:space="preserve">
          <source>Integer. When writing trace files to a target directory, do not write additional traces if we would exceed this many files. Instead, write a sentinel file that will block further tracing to this directory. Defaults to 0, which disables this check.</source>
          <target state="translated">Целостный.При записи файлов трасс в целевую директорию не записывайте дополнительные трассы,если мы превысим это количество файлов.Вместо этого запишите файл sendinel,который будет блокировать дальнейшую трассировку в эту директорию.По умолчанию 0,что отключает эту проверку.</target>
        </trans-unit>
        <trans-unit id="a6768cae9c51930f13c302375f3385c6c77b2104" translate="yes" xml:space="preserve">
          <source>Integrator</source>
          <target state="translated">Integrator</target>
        </trans-unit>
        <trans-unit id="e30f6e398ba3d7dd3d6ee2f7d0d8940d3116f2a5" translate="yes" xml:space="preserve">
          <source>Interacting with Others</source>
          <target state="translated">Взаимодействие с другими</target>
        </trans-unit>
        <trans-unit id="e9854d76872b55831675241f09e80f37f1939cea" translate="yes" xml:space="preserve">
          <source>Interaction between checkin/checkout attributes</source>
          <target state="translated">Взаимодействие между атрибутами проверки/отправки</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">Интерактивный режим</target>
        </trans-unit>
        <trans-unit id="fb0ea93fbb85b738df0bd31fcf1bc9eb5468d22b" translate="yes" xml:space="preserve">
          <source>Interactive use</source>
          <target state="translated">Интерактивное использование</target>
        </trans-unit>
        <trans-unit id="94db97a8381d05a800daa18ce0818d37326de61f" translate="yes" xml:space="preserve">
          <source>Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.</source>
          <target state="translated">Интерактивно выбирайте куски патча между индексом и рабочим деревом и добавляйте их в индекс.Это дает пользователю возможность просмотреть разницу перед добавлением измененного содержимого в индекс.</target>
        </trans-unit>
        <trans-unit id="942e3b50f8575a931a7b62b4970978b40b59bcee" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; was specified, the index).</source>
          <target state="translated">В интерактивном режиме выберите блоки в разнице между &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (или индексом, если он не указан) и рабочим деревом. Выбранные блоки затем применяются в обратном порядке к рабочему дереву (и, если был указан &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; , индекс).</target>
        </trans-unit>
        <trans-unit id="6b61a0bfaba36c21326a6cc1d8076250bbb8f781" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the index and &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (defaults to &lt;code&gt;HEAD&lt;/code&gt;). The chosen hunks are applied in reverse to the index.</source>
          <target state="translated">В интерактивном режиме выберите блоки в разнице между индексом и &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (по умолчанию &lt;code&gt;HEAD&lt;/code&gt; ). Выбранные блоки применяются в обратном порядке к индексу.</target>
        </trans-unit>
        <trans-unit id="11c4e8d4b31fcec1faa8b21ab916ae6d7ecd6196" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the restore source and the restore location. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">В интерактивном режиме выберите блоки в разнице между источником восстановления и местом восстановления. См. Раздел &amp;laquo;Интерактивный режим&amp;raquo; в &lt;a href=&quot;git-add&quot;&gt;git-add [1],&lt;/a&gt; чтобы узнать, как работать в режиме &lt;code&gt;--patch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37d460e42c18dd6a2f67dd6cfcf736b2dc4e3735" translate="yes" xml:space="preserve">
          <source>Internal detail of implementation. What is important is that if this field is not present then per-repository override for given feature is not supported.</source>
          <target state="translated">Внутренние детали реализации.Важно то,что если это поле отсутствует,то переопределение на репозиторий для данной функции не поддерживается.</target>
        </trans-unit>
        <trans-unit id="fcd742802f00593c0aa9a5d67d6ee0045ea54dd6" translate="yes" xml:space="preserve">
          <source>Internal helper commands</source>
          <target state="translated">Внутренние команды помощника</target>
        </trans-unit>
        <trans-unit id="99089329f972015329c6ab2c5f20f49ab1b0fb2e" translate="yes" xml:space="preserve">
          <source>Internal variable identifying the repository format and layout version.</source>
          <target state="translated">Внутренняя переменная,определяющая формат хранилища и версию макета.</target>
        </trans-unit>
        <trans-unit id="d2a9fe262eee692f1042088fcd5412df8b02ed0e" translate="yes" xml:space="preserve">
          <source>Internal variable which enables various workarounds to enable Git to work better on filesystems that are not case sensitive, like APFS, HFS+, FAT, NTFS, etc. For example, if a directory listing finds &quot;makefile&quot; when Git expects &quot;Makefile&quot;, Git will assume it is really the same file, and continue to remember it as &quot;Makefile&quot;.</source>
          <target state="translated">Внутренняя переменная,позволяющая использовать различные обходные пути,чтобы Git мог лучше работать на файловых системах,не чувствительных к регистру,таких как APFS,HFS+,FAT,NTFS и др.Например,если список каталогов найдёт &quot;makefile&quot;,когда Git ожидает &quot;Makefile&quot;,то он будет считать,что это действительно тот же самый файл,и продолжать запоминать его как &quot;Makefile&quot;.</target>
        </trans-unit>
        <trans-unit id="fd5dd045ecadbef7edb9976d5bf76d5e7548b5a7" translate="yes" xml:space="preserve">
          <source>Interpret &amp;lt;refname&amp;gt; as a reference name pattern for a refspec (as used with remote repositories). If this option is enabled, &amp;lt;refname&amp;gt; is allowed to contain a single &lt;code&gt;*&lt;/code&gt; in the refspec (e.g., &lt;code&gt;foo/bar*/baz&lt;/code&gt; or &lt;code&gt;foo/bar*baz/&lt;/code&gt; but not &lt;code&gt;foo/bar*/baz*&lt;/code&gt;).</source>
          <target state="translated">Интерпретируйте &amp;lt;refname&amp;gt; как шаблон ссылочного имени для refspec (как используется с удаленными репозиториями). Если эта опция включена, &amp;lt;refname&amp;gt; может содержать одиночный &lt;code&gt;*&lt;/code&gt; в refspec (например, &lt;code&gt;foo/bar*/baz&lt;/code&gt; или &lt;code&gt;foo/bar*baz/&lt;/code&gt; но не &lt;code&gt;foo/bar*/baz*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="670ef7722a61e3342fef6602c3dc04b50457ccb3" translate="yes" xml:space="preserve">
          <source>Interpret all preceding arguments as attributes and all following arguments as path names.</source>
          <target state="translated">Интерпретируйте все предыдущие аргументы как атрибуты,а все последующие аргументы как имена путей.</target>
        </trans-unit>
        <trans-unit id="c75cadb4ae816991e0dd6b40f2cda63b6ea63eb7" translate="yes" xml:space="preserve">
          <source>Interrogation commands</source>
          <target state="translated">Допросные команды</target>
        </trans-unit>
        <trans-unit id="f1e6fa1e2ddb5fcd808e3092148f74242800360f" translate="yes" xml:space="preserve">
          <source>Interrogators:</source>
          <target state="translated">Interrogators:</target>
        </trans-unit>
        <trans-unit id="8b0b6bf2544da29702a138cd7dd487472490ccff" translate="yes" xml:space="preserve">
          <source>Interrupt transfer after &amp;lt;n&amp;gt; seconds of inactivity.</source>
          <target state="translated">Прерывание передачи после &amp;lt;n&amp;gt; секунд бездействия.</target>
        </trans-unit>
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">Прерывистый рабочий процесс</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">Введение в &quot;гит-бисект&quot;</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">Интуитивность здесь не цель.Повторяемость-это цель.Причина поведения &quot;отсутствие аргументов означает отсутствие работы&quot; заключается в том,что из сценариев вы должны уметь делать:</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">Вызовите текстовый редактор (см. GIT_EDITOR в &lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt; ), чтобы отредактировать вводное сообщение для серии патчей.</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">Вызов редактора перед совершением успешного механического слияния для дальнейшего редактирования автоматически созданного сообщения слияния, чтобы пользователь мог объяснить и обосновать слияние. Параметр &lt;code&gt;--no-edit&lt;/code&gt; может использоваться для принятия автоматически сгенерированного сообщения (обычно это не рекомендуется).</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">Вызов редактора перед совершением успешного механического слияния для дальнейшего редактирования автоматически созданного сообщения слияния, чтобы пользователь мог объяснить и обосновать слияние. Параметр &lt;code&gt;--no-edit&lt;/code&gt; может использоваться для принятия автоматически сгенерированного сообщения (обычно это не рекомендуется). Параметр &lt;code&gt;--edit&lt;/code&gt; (или &lt;code&gt;-e&lt;/code&gt; ) по-прежнему полезен, если вы даете черновик сообщения с параметром &lt;code&gt;-m&lt;/code&gt; из командной строки и хотите отредактировать его в редакторе.</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">Вызвать перехватчик sendemail-validate, если он присутствует (см. &lt;a href=&quot;githooks&quot;&gt;Githooks [5]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">Вызывается &lt;code&gt;git archive --remote&lt;/code&gt; и отправляет сгенерированный архив на другой конец по протоколу Git.</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">Вызывается &lt;code&gt;git fetch-pack&lt;/code&gt; , узнает, какие объекты отсутствуют на другой стороне, и отправляет их после упаковки.</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">Вызывается &lt;code&gt;git send-pack&lt;/code&gt; и обновляет репозиторий информацией, полученной с удаленного конца.</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">Вызывает &lt;code&gt;git-receive-pack&lt;/code&gt; в возможно удаленном репозитории и обновляет его из текущего репозитория, отправляя именованные ссылки.</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">Вызывает &lt;code&gt;git-upload-pack&lt;/code&gt; в возможно удаленном репозитории и просит его отправить объекты, отсутствующие в этом репозитории, для обновления названных заголовков. Список доступных локально коммитов определяется путем сканирования локальных ссылок / иерархии и отправляется в &lt;code&gt;git-upload-pack&lt;/code&gt; , запущенный на другом конце.</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">Вызов &lt;code&gt;git add -e&lt;/code&gt; или выбор &lt;code&gt;e&lt;/code&gt; в интерактивном селекторе фрагментов откроет патч в вашем редакторе; после выхода из редактора результат применяется к индексу. Вы можете вносить произвольные изменения в патч, но учтите, что некоторые изменения могут привести к запутанным результатам или даже привести к тому, что патч не может быть применен. Если вы хотите полностью прервать операцию (т.е. не добавлять в индекс ничего нового), просто удалите все строки патча. В списке ниже описаны некоторые общие вещи, которые вы можете увидеть в патче, и какие операции редактирования имеют для них смысл.</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">Привлечение специалистов по контролю качества и,по возможности,конечных пользователей.</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">Это синоним &lt;code&gt;zebra&lt;/code&gt; . В будущем это может измениться на более разумный режим.</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">Используется как предлагаемое имя при создании новых веток с помощью &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">Острова настраиваются с помощью параметра &lt;code&gt;pack.island&lt;/code&gt; , который можно указывать несколько раз. Каждое значение - это регулярные выражения с привязкой к левой стороне, соответствующие ссылочным именам. Например:</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">О проблемах, связанных с безопасностью, следует сообщать в частном порядке в список рассылки Git Security &amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;.</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">Выдача &lt;code&gt;filedeleteall&lt;/code&gt; с последующей необходимым &lt;code&gt;filemodify&lt;/code&gt; команд , чтобы установить правильное содержание будет производить те же результаты, посылая только необходимое &lt;code&gt;filemodify&lt;/code&gt; и &lt;code&gt;filedelete&lt;/code&gt; команды. &lt;code&gt;filedeleteall&lt;/code&gt; подход , однако , может потребоваться быстро импортировать , чтобы использовать немного больше памяти на активной ветви (менее 1 МиБ даже самых крупных проектов); поэтому интерфейсы, которые могут легко получить только затронутые пути для фиксации, рекомендуется делать это.</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">Он добавляет путь клонирования подмодуля в файл &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; и добавляет этот файл в индекс, готовый к фиксации .</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">Он добавляет текущий идентификатор фиксации подмодуля в индекс, готовый к фиксации.</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">Это влияет на то, как изменение, которое сводится к полной перезаписи файла, не как серия удалений и вставок, смешанных вместе с очень несколькими строками, которые совпадают текстуально как контекст, а как однократное удаление всего старого, за которым следует однократная вставка всего нового, и число &lt;code&gt;m&lt;/code&gt; управляет этим аспектом опции -B (по умолчанию 60%). &lt;code&gt;-B/70%&lt;/code&gt; указывает, что в результате должно оставаться менее 30% оригинала, чтобы Git считал его полной перезаписью (т.е. в противном случае полученный патч будет серией удалений и вставок, смешанных с контекстными строками).</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">Это также позволяет файлу &quot;ref&quot; быть символическим указателем на другой файл ref,начиная с четырехбайтовой последовательности заголовков &quot;ref:&quot;.</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">Он также может быть полезен в скриптах,переданных в &quot;git-бисект run&quot; на &quot;exit 255&quot;,если обнаружена какая-то очень аномальная ситуация.</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">Ввод одних и тех же учетных данных может быть обременительным.Git предоставляет два способа уменьшить это раздражение:</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">Он может быть использован для проверки текущего рабочего дерева и отказа от коммита,если не пройдёт определённого теста.</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">Он может эффективно представлять информацию о конфликтах слияний между различными объектами деревьев,позволяя ассоциировать каждое имя пути с достаточной информацией о задействованных деревьях,чтобы вы могли создать трехстороннее слияние между ними.</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">Он не может показывать более 29 ветвей и коммитов одновременно.</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">Он клонирует подмодуль из &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; в заданный &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; в текущем каталоге и по умолчанию проверяет главную ветвь.</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">Его также можно использовать для регистрации старого ... нового статуса. Однако он не знает всего набора ветвей, поэтому при наивном использовании он в конечном итоге будет запускать одно электронное письмо на ссылку. &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;После приема&lt;/em&gt;&lt;/a&gt; крюка больше подходит для этого.</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">По умолчанию это &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; , который окрашивает все, что старше одного года, синим, последние изменения между месяцем и годом сохраняются белым, а линии, введенные в течение последнего месяца, окрашены в красный цвет.</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">Он делает все возможное,чтобы сделать безопасную вещь,он будет проверять,что файлы остаются неизменными и актуальными в CVS checkout,и он не будет автокомммитироваться по умолчанию.</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">Он делает это,сохраняя некоторые дополнительные данные для каждой записи (например,последнее измененное время).Эти данные не отображаются выше и не хранятся в созданном объекте дерева,но могут быть использованы для быстрого определения того,какие файлы в рабочей директории отличаются от тех,что хранились в индексе,и,таким образом,избавляют Git'а от необходимости считывать все данные из таких файлов для поиска изменений.</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">Это позволяет git работать вместе с монитором файловой системы (см. Раздел &amp;laquo;fsmonitor-watchman&amp;raquo; в &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; ), который может сообщить ему, какие файлы были изменены. Это позволяет git избегать использования lstat () каждого файла для поиска измененных файлов.</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">Ожидается, что он будет иметь дело только с одним проектом. Если он увидит ветви с разными корнями, он откажется бежать. В этом случае отредактируйте параметры &amp;lt;archive / branch&amp;gt;, чтобы четко определить объем импорта.</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">Это помогает разделить эти функции на группы для целей обсуждения.</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">Это &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; , где &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; - это количество секунд с начала эпохи UNIX. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; - положительное или отрицательное смещение от UTC. Например, CET (который на 1 час опережает UTC) составляет &lt;code&gt;+0100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">Можно включать файлы,которые на самом деле не изменились.Все изменения,включая вновь созданные и удаленные файлы,должны быть включены.При переименовании файлов следует включать как старое,так и новое имя.</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">Хорошо бы представиться Git'у с вашим именем и публичным адресом электронной почты перед тем,как делать какие-либо операции.Самый простой способ это сделать:</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">Это приблизительный эквивалент:</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">Также это хорошая идея при использовании любой ВКС,чтобы иметь только одно небольшое логическое изменение в каждом коммите.</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Также разрешено, чтобы ссылка на заметку указывала непосредственно на объект дерева, и в этом случае историю заметок можно прочитать с помощью &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">Также можно получить подмножество веток или тегов,используя разделенный запятыми список имен внутри фигурных скобок.Например:</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">Также возможно ввести совершенно новые коммиты слияния с нуля, добавив команду вида &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; . Эта форма будет генерировать предварительное сообщение о фиксации и всегда открывать редактор, позволяющий пользователю редактировать его. Это может быть полезно, например, когда выясняется, что тематическая ветка касается более чем одной проблемы и хочет быть разделена на две или даже более тематических веток. Рассмотрим этот список дел:</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">Также возможно предоставить настоящий CVS-доступ к репозиторию Git, чтобы разработчики по-прежнему могли использовать CVS; подробнее см. &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">Также можно заменить коммиты на более ранний этап истории, но это более сложная тема, которую следует оставить для &lt;a href=&quot;#cleaning-up-history&quot;&gt;другой главы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">Он также запускается после &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; , если не используется параметр &lt;code&gt;--no-checkout&lt;/code&gt; ( &lt;code&gt;-n&lt;/code&gt; ). Первым параметром, передаваемым ловушке, является null-ref, вторым - ref нового HEAD, а флаг всегда равен 1. Аналогично для &lt;code&gt;git worktree add&lt;/code&gt; , если не используется &lt;code&gt;--no-checkout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">Это ошибка, если &amp;lt;dst&amp;gt; соответствует более чем одной удаленной ссылке.</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">Это ошибка, если &amp;lt;src&amp;gt; не соответствует точно одному из локальных ссылок.</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">Ошибкой является указание ссылки,которая не проходит проверку &quot;git check-reformat&quot;.Дублированные значения фильтруются.</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">Предполагается,что любые процедуры рукопожатия уже были завершены (например,отправка служебного запроса на git://)до того,как был запущен этот помощник.</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">В настоящее время возможно воссоздать коммиты слияния только с использованием стратегии &lt;code&gt;recursive&lt;/code&gt; слияния; Различные стратегии слияния можно использовать только с помощью явных команд &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">Предполагается,что содержимое объекта коммита,который вы создали,следуя приведённому выше примеру,генерирует SHA-1 хэш,отличный от приведённого выше,так как объект коммита записывает время,когда он был создан,и имя человека,выполняющего коммит.</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">За ним следуют одна или несколько расширенных строк заголовка (в этом примере показано слияние с двумя родителями):</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">За ней следуют одна или несколько расширенных строк заголовка:</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">За ним следует двухстрочный заголовок из файла/в файл.</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">Он очень функциональный.Однако,не все методы реализованы,а для тех методов,которые реализованы,реализованы не все коммутаторы.</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">Важно понимать, что на данный момент ничто не относится к фиксации &lt;code&gt;f&lt;/code&gt; . В конечном итоге фиксация &lt;code&gt;f&lt;/code&gt; (и по расширению фиксация &lt;code&gt;e&lt;/code&gt; ) будет удалена стандартным процессом сборки мусора Git, если мы не создадим ссылку до того, как это произойдет. Если мы еще не отошли от коммита &lt;code&gt;f&lt;/code&gt; , любой из них создаст ссылку на него:</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">Вполне вероятно, что время от времени вы будете получать данные из одного и того же удаленного репозитория. Вкратце, вы можете сохранить URL удаленного репозитория в файле конфигурации локального репозитория следующим образом:</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">Скорее всего,вы будете работать над несколькими вещами одновременно.С Git'ом легко управлять этими более или менее независимыми задачами,используя ветки.</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">Новым разработчикам не всегда легко разобраться в исходном коде Git. Этот раздел дает вам небольшое руководство, чтобы показать, с чего начать.</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">Не рекомендуется использовать эту функцию, если вы собираетесь позже снова экспортировать изменения обратно в CVS с помощью &lt;code&gt;git cvsexportcommit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">Очевидно,что не стоит делать коммиты с изменениями,которые сознательно ломают вещи,даже если некоторые другие коммиты позже исправят поломку.</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">Возможно, что ошибка слияния помешает этому процессу стать полностью автоматическим. Вам нужно будет устранить любой такой сбой слияния и запустить &lt;code&gt;git rebase --continue&lt;/code&gt; . Другой вариант - обойти фиксацию, вызвавшую сбой слияния, с помощью &lt;code&gt;git rebase --skip&lt;/code&gt; . Чтобы проверить исходный &amp;lt;branch&amp;gt; и удалить рабочие файлы .git / rebase-apply, используйте вместо этого команду &lt;code&gt;git rebase --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">Эти старые репозитории форм можно построить вручную.</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">Можно отключить использование заменяющих ссылок для любой команды с помощью параметра &lt;code&gt;--no-replace-objects&lt;/code&gt; сразу после &lt;code&gt;git&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">Ему предшествует заголовок &quot;git diff&quot;,который выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">Ему предшествует заголовок &quot;git diff&quot;, который выглядит следующим образом (при использовании параметра &lt;code&gt;-c&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">Это чисто оптимизация производительности,изначально предназначенная для MacOS X,где рекурсивный обход каталогов происходит медленно.Gitweb следует по символическим ссылкам,но обнаруживает циклы,игнорируя любые дубликаты файлов и каталогов.</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">Рекомендуется всегда кодировать &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; с использованием UTF-8.</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">Безопаснее, если оба &lt;code&gt;test.sh&lt;/code&gt; и &lt;code&gt;check_test_case.sh&lt;/code&gt; находятся вне репозитория, чтобы предотвратить взаимодействие между процессами bisect, make и test и скриптами.</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">Иногда бывает полезно иметь возможность проверить фиксацию, которая не находится на вершине какой-либо именованной ветки, или даже создать новую фиксацию, на которую не ссылается именованная ветвь. Давайте посмотрим, что происходит, когда мы проверяем фиксацию &lt;code&gt;b&lt;/code&gt; (здесь мы показываем два способа сделать это):</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">Вы по-прежнему обязаны убедиться, что электронное сообщение, отправленное вашей почтовой программой, соответствует стандартам вашего проекта. Многие проекты не любят прикреплять патчи. Некоторые почтовые агенты будут преобразовывать исправления (например, переносить строки, отправлять их как format = flowed) таким образом, чтобы они не работали. Вы получите сердитое пламя, высмеивающее вас, если вы не отметите это.</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">Маловероятно, что здесь возникнут какие-либо конфликты ... но они могут быть, если вы потратите некоторое время на этот шаг и также загрузите новые версии из апстрима.</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">Пользователь должен убедиться, что заголовок In-Reply-To уже не существует, когда &lt;code&gt;git send-email&lt;/code&gt; просит добавить его (особенно обратите внимание, что &lt;code&gt;git format-patch&lt;/code&gt; может быть настроен для выполнения самой потоковой передачи). Невыполнение этого требования может не привести к ожидаемому результату в MUA получателя.</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">Это полезно, когда вы ищете точный блок кода (например, структуру) и хотите узнать историю этого блока с момента его появления: используйте эту функцию итеративно, чтобы передать интересный блок в прообразе обратно в &lt;code&gt;-S&lt;/code&gt; , и продолжайте, пока не получите самую первую версию блока.</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">Очень важно,чтобы используемая база находилась в месте назначения.Нормально ошибиться на стороне предостережения,вызывая файл пакета для того чтобы содержать объекты уже в месте назначения,так как они игнорируются при распаковке на месте назначения.</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">Вполне возможно, что люди, работающие в сети, могут захотеть обмениваться тегами внутри своей группы, но в этом рабочем процессе они, скорее всего, отслеживают прогресс друг друга, имея ветки удаленного отслеживания. Опять же, эвристика автоматического отслеживания таких тегов - это хорошо.</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">Он должен быть читабельным для того,чтобы,от начала и до конца,кто-то умный,обладающий базовыми знаниями о командной строке UNIX,но не обладающий какими-либо специальными знаниями о Git'е.При необходимости следует особо упомянуть любые другие предпосылки по мере их возникновения.</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">Следует подчеркнуть, что эта иерархия носит чисто &lt;strong&gt;неформальный характер&lt;/strong&gt; . В Git нет ничего фундаментального, что навязывало бы &amp;laquo;цепочку потока исправлений&amp;raquo;, которую подразумевает эта иерархия. Вам не нужно использовать только один удаленный репозиторий.</target>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">Он показывает, что foo.png имеет отличия от HEAD (но он является двоичным, поэтому количество строк не может быть показано), и нет разницы между индексированной копией и версией рабочего дерева (если бы версия рабочего дерева также была другой, &lt;code&gt;binary&lt;/code&gt; был бы показан вместо &lt;code&gt;nothing&lt;/code&gt; ). В другой файл, git-add {litdd} interactive.perl, добавлено 403 строки и удалено 35 строк, если вы фиксируете то, что находится в индексе, но рабочий файл дерева имеет дальнейшие изменения (одно добавление и одно удаление).</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">Потребуется переменное количество параметров,каждый из которых является именем ссылки,которая была фактически обновлена.</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">Он принимает на стандартный ввод спецификацию параметров для синтаксического анализа и понимания и выводит на стандартный вывод строку, подходящую для &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; , чтобы заменить аргументы нормализованными. В случае ошибки он выводит использование в стандартном потоке ошибок и завершает работу с кодом 129.</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">Требуется от одного до трех параметров. Первый - это имя файла, содержащего сообщение журнала фиксации. Второй является источником сообщения фиксации и может быть: &lt;code&gt;message&lt;/code&gt; (если была указана опция &lt;code&gt;-m&lt;/code&gt; или &lt;code&gt;-F&lt;/code&gt; ); &lt;code&gt;template&lt;/code&gt; (если была указана опция &lt;code&gt;-t&lt;/code&gt; или задана опция конфигурации &lt;code&gt;commit.template&lt;/code&gt; ); &lt;code&gt;merge&lt;/code&gt; (если фиксация является слиянием или существует файл &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; ); &lt;code&gt;squash&lt;/code&gt; (если существует файл &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; ); или &lt;code&gt;commit&lt;/code&gt; , за которой следует фиксация SHA-1 (если &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; или &lt;code&gt;--amend&lt;/code&gt; был дан вариант).</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">Он сообщает вам, что было выполнено &amp;laquo;автоматическое объединение&amp;raquo;, которое не удалось из-за конфликтов в &lt;code&gt;hello&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">Раньше считалось, что команда по умолчанию выполняла &lt;code&gt;-x&lt;/code&gt; ,как описано выше, а &lt;code&gt;-r&lt;/code&gt; должна была отключить ее. Теперь по умолчанию не используется &lt;code&gt;-x&lt;/code&gt; , поэтому эта опция не работает.</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">Он использует многозначные элементы конфигурации &lt;code&gt;showbranch.default&lt;/code&gt; , если в командной строке не заданы &amp;lt;rev&amp;gt; или &amp;lt;glob&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">Он проверяет, что в каталоге есть волшебный файл &quot;git-daemon-export-ok&quot;, и откажется экспортировать любой каталог Git, который не был явно отмечен для экспорта таким образом (если не &lt;code&gt;--export-all&lt;/code&gt; параметр --export-all ). Если вы передаете некоторые пути к каталогам в качестве аргументов &lt;code&gt;git daemon&lt;/code&gt; , вы можете дополнительно ограничить предложения до белого списка, состоящего из них.</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">Он проверяет, что в каталоге есть волшебный файл &quot;git-daemon-export-ok&quot;, и откажется экспортировать любой каталог Git, который не был явно отмечен для экспорта таким образом (если не &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; переменная среды GIT_HTTP_EXPORT_ALL ).</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">Это был крайний инструмент. Я бы лучше потратил дни на просмотр вывода printk, чем на ручное деление заплаток &lt;code&gt;patch bisection&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">Будет полезно иметь Git-репозиторий для экспериментов,пока вы читаете это руководство.</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">Также возможен сбой принудительной отправки, когда другие люди имеют право на отправку в тот же репозиторий. В этом случае правильное решение - повторить отправку после первого обновления вашей работы: либо путем вытягивания, либо путем выборки с последующей перебазированием; см. &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;следующий раздел&lt;/a&gt; и &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">Особенно поучительно смотреть на объекты &quot;фиксации&quot;, поскольку они, как правило, маленькие и не требуют пояснений. В частности, если вы следуете соглашению о том, что имя верхнего коммита в &lt;code&gt;.git/HEAD&lt;/code&gt; , вы можете сделать</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">Слишком легко случайно перепутать старую и новую историю. Это все еще возможно с любым инструментом, но git-filter-branch почти приглашает его. Если повезет, единственным недостатком будет разочарование пользователей из-за того, что они не знают, как уменьшить размер своего репо и удалить старые вещи. Если не повезло, они объединяют старую и новую историю и в итоге получают несколько &amp;laquo;копий&amp;raquo; каждой фиксации, некоторые из которых содержат нежелательные или конфиденциальные файлы, а другие - нет. Это происходит несколькими способами:</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; небезопасно, если вы внесли и зафиксировали изменения в подмодуле, не проверив сначала ветку. Они будут тихо перезаписаны:</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">Можно поместить любой тип объекта в любое пространство имен за пределами &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; . В случае тегов и коммитов они будут обрабатываться, как если бы они были коммитами внутри &lt;code&gt;refs/heads/*&lt;/code&gt; , чтобы определить, разрешено ли обновление.</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">Вероятно, не стоит использовать эту опцию в данном репозитории, не выполняя для него специальные тесты производительности. Это занимает гораздо больше времени, и итоговая оптимизация пространства / дельты может того стоить, а может и не стоить. Не использовать это вообще - верный компромисс для большинства пользователей и их репозиториев.</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">Разумно, например, настроить &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; в &lt;code&gt;~/.gitconfig&lt;/code&gt; , чтобы теги удалялись каждый раз при &lt;code&gt;git fetch --prune&lt;/code&gt; , не выполняя каждый вызов &lt;code&gt;git fetch&lt;/code&gt; без &lt;code&gt;--prune&lt;/code&gt; с ошибкой.</target>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">Обычно гораздо чаще происходит слияние с кем-то другим, чем слияние со своими собственными ветвями, поэтому стоит отметить, что Git также делает это очень простым, и на самом деле это не так уж отличается от &lt;code&gt;git merge&lt;/code&gt; . Фактически, удаленное слияние заканчивается не чем иным, как &amp;laquo;извлечением работы из удаленного репозитория во временный тег&amp;raquo; с последующим &lt;code&gt;git merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">Перебрать все ссылки, соответствующие &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; , и показать их в соответствии с заданным &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; после сортировки в соответствии с заданным набором &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; . Если задано &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; , остановитесь после показа такого количества ссылок. Интерполированные значения в &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; могут быть дополнительно заключены в кавычки как строковые литералы на указанном главном языке, что позволяет их прямую оценку на этом языке.</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">Присоедините вместе две или более истории развития</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">Так же, как файловая система &lt;code&gt;.&lt;/code&gt; (точка) относится к текущему каталогу с использованием &lt;code&gt;.&lt;/code&gt; поскольку имя репозитория в Git (точечный репозиторий) является относительным путем и означает ваш текущий репозиторий.</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">Просто выполнение &lt;code&gt;git checkout-index&lt;/code&gt; ничего не делает. Вы, наверное, имели в виду &lt;code&gt;git checkout-index -a&lt;/code&gt; . И если вы хотите заставить его, вам нужно &lt;code&gt;git checkout-index -f -a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">На всякий случай, если вы делаете что-то экзотическое, следует отметить, что все &amp;lt;commit&amp;gt; в приведенном выше описании, за исключением двух последних форм, в которых используются обозначения &amp;laquo;..&amp;raquo;, могут быть любыми &amp;lt;tree&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">Так же, как и &lt;code&gt;push&lt;/code&gt; , пакетная последовательность из одного или нескольких &lt;code&gt;import&lt;/code&gt; заканчивается пустой строкой. Для каждого пакета &lt;code&gt;import&lt;/code&gt; удаленный помощник должен создавать поток быстрого импорта, завершаемый командой &lt;code&gt;done&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">Просто не забудьте отключить перенос строк в почтовом клиенте (веб-интерфейс GMail будет переносить строки независимо от того, что, поэтому вам нужно использовать настоящий клиент IMAP).</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">Ведите список репозиториев,с которыми вы регулярно работаете:</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">Сохранять изменения в рабочем дереве во время отбрасывания некоторых предыдущих коммитов</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">Продолжайте скачивать пакет.</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">Имейте в виду , что &lt;code&gt;*&lt;/code&gt; (звездочка) подстановочные местного исх (справа из &lt;code&gt;:&lt;/code&gt; ) &lt;strong&gt;должен&lt;/strong&gt; быть самый дальний правый компонент пути; однако удаленный подстановочный знак может быть где угодно, если он является независимым компонентом пути (окруженным &lt;code&gt;/&lt;/code&gt; или EOL). Этот тип конфигурации не создается автоматически программой &lt;code&gt;init&lt;/code&gt; и должен вводиться вручную с помощью текстового редактора или с помощью &lt;code&gt;git config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">Продолжайте повторять процесс: скомпилируйте дерево, протестируйте его и, в зависимости от того, хорошее оно или плохое, запустите &lt;code&gt;git bisect good&lt;/code&gt; или &lt;code&gt;git bisect bad&lt;/code&gt; , чтобы запросить следующую фиксацию, требующую тестирования.</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">Хранить коммиты,которые ничего не меняют от своих родителей в результате.</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">Сохраните текущее содержимое индекса и прочитайте содержимое именованного дерева в каталоге &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; . Команда откажется перезаписывать записи, которые уже существовали в исходном индексном файле.</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">Держите версию из вашей ветки в рабочем дереве,но оставьте путь в конфликтном состоянии,чтобы пользователь мог его разобрать.</target>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">После создания оставьте рабочее дерево заблокированным. Это эквивалент &lt;code&gt;git worktree lock&lt;/code&gt; после &lt;code&gt;git worktree add&lt;/code&gt; , но без состояния гонки.</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">Храните недоступные предметы в свободной форме. Это означает &lt;code&gt;--revs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">Продолжайте работать в вашем первичном репозитории.Ваши изменения включают в себя изменения в вашем собственном репозитории,исправления,которые вы получаете по электронной почте,и слияния,возникающие в результате переноса &quot;публичных&quot; репозиториев вашего &quot;ведущего проекта&quot; и,возможно,ваших &quot;мейнтейнеров подсистемы&quot;.</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">Продолжайте работать в вашем первичном репозитории.Ваши изменения включают в себя изменения в вашем собственном репозитории,исправления,которые вы получаете по электронной почте,и слияния,возникающие в результате переноса &quot;публичных&quot; репозиториев ваших &quot;мейнтейнеров подсистемы&quot;.</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">Поддержание серии патчей в актуальном состоянии с использованием git-ребейза.</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">Kill ключевые слова: будет извлекать файлы с &lt;code&gt;-kk&lt;/code&gt; из архива CVS, чтобы избежать шумных наборов изменений. Настоятельно рекомендуется, но по умолчанию отключено, чтобы сохранить совместимость с ранее импортированными деревьями.</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">Ярлык для &amp;laquo;домашней ссылки&amp;raquo; вверху всех страниц, ведущий к &lt;code&gt;$home_link&lt;/code&gt; (обычно это главная страница gitweb, которая содержит список проектов). Он используется в качестве первого компонента &amp;laquo;цепочки навигации&amp;raquo; gitweb: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; . Может быть установлено во время сборки с &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; переменной GITWEB_HOME_LINK_STR . По умолчанию это &amp;laquo;проекты&amp;raquo;, так как эта ссылка ведет к списку проектов. Другой популярный вариант - установить его по имени сайта. Обратите внимание, что он обрабатывается как необработанный HTML, поэтому его не следует устанавливать из ненадежных источников.</target>
        </trans-unit>
        <trans-unit id="19b52717c24503e82535f1da97544e03ef42f759" translate="yes" xml:space="preserve">
          <source>Large projects are often composed of smaller, self-contained modules. For example, an embedded Linux distribution&amp;rsquo;s source tree would include every piece of software in the distribution with some local modifications; a movie player might need to build against a specific, known-working version of a decompression library; several independent programs might all share the same build scripts.</source>
          <target state="translated">Большие проекты часто состоят из небольших автономных модулей. Например, дерево исходных кодов встроенного дистрибутива Linux будет включать все программы в дистрибутиве с некоторыми локальными модификациями; проигрывателю фильмов может потребоваться сборка на основе конкретной, заведомо работающей версии библиотеки декомпрессии; несколько независимых программ могут использовать одни и те же сценарии сборки.</target>
        </trans-unit>
        <trans-unit id="eebf4c31734b36e391dbec8f9bdc861cf73858fc" translate="yes" xml:space="preserve">
          <source>Later, Bob can update his repo with Alice&amp;rsquo;s latest changes using</source>
          <target state="translated">Позже Боб может обновить свое репо последними изменениями Алисы, используя</target>
        </trans-unit>
        <trans-unit id="b67e320eff785b446a82207f60f64bae4d9398b2" translate="yes" xml:space="preserve">
          <source>Later, you can see whether your changes have been applied by saying (still on &lt;code&gt;topic&lt;/code&gt;):</source>
          <target state="translated">Позже вы сможете увидеть, были ли применены ваши изменения, сказав (все еще по &lt;code&gt;topic&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0c480c6f24e2582817904a3ca717bfe059eaf9ba" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;Re:&lt;/code&gt;, &lt;code&gt;re:&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">Ведущий &lt;code&gt;Re:&lt;/code&gt; , &lt;code&gt;re:&lt;/code&gt; и &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cba31f4e857a58fc5d56324b4f5b7ba501d5431" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace are ignored.</source>
          <target state="translated">Ведущие и отстающие пробелы игнорируются.</target>
        </trans-unit>
        <trans-unit id="9400d93a0e4bf560ae2ff2a8521028a1c12485de" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace.</source>
          <target state="translated">Ведущий и отстающий белый пробел.</target>
        </trans-unit>
        <trans-unit id="b0ca289dea1d9e545043917d0313a90afe03b7b2" translate="yes" xml:space="preserve">
          <source>Leading bracketed strings (between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, usually &lt;code&gt;[PATCH]&lt;/code&gt;).</source>
          <target state="translated">Ведущие строки в квадратных скобках (между &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; , обычно &lt;code&gt;[PATCH]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c5fae931542a3559bb8c0d5b861a24e60a1ac67c" translate="yes" xml:space="preserve">
          <source>Left-, middle-, or right-align the content between %(align:&amp;hellip;​) and %(end). The &quot;align:&quot; is followed by &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; and &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; in any order separated by a comma, where the &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; is either left, right or middle, default being left and &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; is the total length of the content with alignment. For brevity, the &quot;width=&quot; and/or &quot;position=&quot; prefixes may be omitted, and bare &amp;lt;width&amp;gt; and &amp;lt;position&amp;gt; used instead. For instance, &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt;. If the contents length is more than the width then no alignment is performed. If used with &lt;code&gt;--quote&lt;/code&gt; everything in between %(align:&amp;hellip;​) and %(end) is quoted, but if nested then only the topmost level performs quoting.</source>
          <target state="translated">Выровняйте содержимое по левому, среднему или правому краю между% (align:&amp;hellip;) и% (end). За &quot;align:&quot; следуют &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; и &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; в любом порядке, разделенные запятой, где &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; - левый, правый или средний, по умолчанию - left, а &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; - общее длина содержимого с выравниванием. Для краткости префиксы &amp;laquo;width =&amp;raquo; и / или &amp;laquo;position =&amp;raquo; могут быть опущены, и вместо них используются пустые &amp;lt;width&amp;gt; и &amp;lt;position&amp;gt;. Например, &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt; . Если длина содержимого больше ширины, выравнивание не выполняется. При использовании с &lt;code&gt;--quote&lt;/code&gt; все между% (align:&amp;hellip;) и% (end) цитируется,но если они вложены, то цитирование выполняется только на самом верхнем уровне.</target>
        </trans-unit>
        <trans-unit id="4913da5c2a93f28cfca5df10654d75686a764062" translate="yes" xml:space="preserve">
          <source>Legacy alias for &lt;code&gt;--smtp-encryption ssl&lt;/code&gt;.</source>
          <target state="translated">Устаревший псевдоним для &lt;code&gt;--smtp-encryption ssl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c79d7d578b1dfedd061424fe06d7bbd7bf7860a" translate="yes" xml:space="preserve">
          <source>Legacy monitoring operations are not supported (edit, watch and related). Exports and tagging (tags and branches) are not supported at this stage.</source>
          <target state="translated">Операции мониторинга наследия не поддерживаются (редактирование,просмотр и связанные с ними).Экспорт и маркировка (теги и ветки)на данном этапе не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="efdb524a0ef0e2256e12ca50686b4d8bc222c208" translate="yes" xml:space="preserve">
          <source>Lesson three is: study the code. Really, it is the best way to learn about the organization of Git (after you know the basic concepts).</source>
          <target state="translated">Урок третий:изучить код.Действительно,это лучший способ узнать об организации Git'а (после того,как вы познакомитесь с основными понятиями).</target>
        </trans-unit>
        <trans-unit id="893b35eb2ef36c307a5615060033f2510cf02d9b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also suppose that we have a cleaned up graph like one after step 1) in the bisection algorithm above. This means that we can measure the information we get in terms of number of commit we can remove from the graph..</source>
          <target state="translated">Давайте также предположим, что у нас есть очищенный граф, подобный тому, что был после шага 1) в приведенном выше алгоритме деления пополам. Это означает, что мы можем измерить информацию, которую мы получаем, с точки зрения количества коммитов, которые мы можем удалить с графика.</target>
        </trans-unit>
        <trans-unit id="c8d0e17bfd7a63329a6082665d278b7fb499b0b6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s skip over the obvious details; the only really interesting part here is the call to &lt;code&gt;get_sha1()&lt;/code&gt;. It tries to interpret &lt;code&gt;argv[2]&lt;/code&gt; as an object name, and if it refers to an object which is present in the current repository, it writes the resulting SHA-1 into the variable &lt;code&gt;sha1&lt;/code&gt;.</source>
          <target state="translated">Давайте пропустим очевидные детали; единственная действительно интересная часть здесь - это вызов &lt;code&gt;get_sha1()&lt;/code&gt; . Он пытается интерпретировать &lt;code&gt;argv[2]&lt;/code&gt; как имя объекта, и если он ссылается на объект, который присутствует в текущем репозитории, он записывает полученный SHA-1 в переменную &lt;code&gt;sha1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc9abf37f1be76cb29eb48ded27f1fe2938a8b22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project and create a small amount of history:</source>
          <target state="translated">Давайте начнем новый проект и создадим небольшую историю:</target>
        </trans-unit>
        <trans-unit id="f0d62f9783a955198cc607ca11b36e935a346c02" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the following graph as an example:</source>
          <target state="translated">Возьмем для примера следующий график:</target>
        </trans-unit>
        <trans-unit id="1c0b60e2ec5a47fbbf8d5055a8c4fd552a20bdbd" translate="yes" xml:space="preserve">
          <source>Lets you rewrite Git revision history by rewriting the branches mentioned in the &amp;lt;rev-list options&amp;gt;, applying custom filters on each revision. Those filters can modify each tree (e.g. removing a file or running a perl rewrite on all files) or information about each commit. Otherwise, all information (including original commit times or merge information) will be preserved.</source>
          <target state="translated">Позволяет вам переписать историю ревизий Git, переписав ветви, упомянутые в &amp;lt;rev-list options&amp;gt;, применяя настраиваемые фильтры к каждой ревизии. Эти фильтры могут изменять каждое дерево (например, удалять файл или выполнять перезапись Perl для всех файлов) или информацию о каждой фиксации. В противном случае вся информация (включая исходное время фиксации или информацию о слиянии) будет сохранена.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="c20b9e30add4d8fcb9e944c3a79357b0eb58faf9" translate="yes" xml:space="preserve">
          <source>Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;.</source>
          <target state="translated">Как и --allow-empty, эта команда в первую очередь предназначена для использования скриптами внешнего интерфейса SCM. Он позволяет вам создать фиксацию с пустым сообщением фиксации без использования команд, таких как &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f6f49e5a6f1778648e9730643fd43474f2dbc13" translate="yes" xml:space="preserve">
          <source>Like --get-all, but interprets the name as a regular expression and writes out the key names. Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not.</source>
          <target state="translated">Подобно --get-all,но интерпретирует имя как регулярное выражение и записывает ключевые имена.Подгонка регулярных выражений в настоящее время чувствительна к регистру и осуществляется против канонизированной версии ключа,в которой имена секций и переменных выражены в нижнем регистре,а имена подразделов-нет.</target>
        </trans-unit>
        <trans-unit id="f93e6625e77c19d6664d2e45faf25a33780dbe37" translate="yes" xml:space="preserve">
          <source>Like --import-marks but instead of erroring out, silently skips the file if it does not exist.</source>
          <target state="translated">Как и --import-mark,но вместо того,чтобы выдать ошибку,молча пропускает файл,если он не существует.</target>
        </trans-unit>
        <trans-unit id="0eda32196b28e34b5200ae38915b28d72ba0802b" translate="yes" xml:space="preserve">
          <source>Like --import-marks except in two respects: first, only one &quot;feature import-marks&quot; or &quot;feature import-marks-if-exists&quot; command is allowed per stream; second, an --import-marks= or --import-marks-if-exists command-line option overrides any of these &quot;feature&quot; commands in the stream; third, &quot;feature import-marks-if-exists&quot; like a corresponding command-line option silently skips a nonexistent file.</source>
          <target state="translated">Подобно --import-marks,за исключением двух аспектов:во-первых,в потоке разрешена только одна команда &quot;import-mark&quot; или &quot;feature import-mark-if-exists&quot;;во-вторых,опция командной строки --import-marks=или --import-mark-if-exists переопределяет любую из этих команд &quot;feature&quot; в потоке;в-третьих,опция &quot;feature import-marks-if-exists&quot;,подобно соответствующей опции командной строки,беззвучно пропускает несуществующий файл.</target>
        </trans-unit>
        <trans-unit id="ea166a12e166b75ad46458f975797a03647dc62d" translate="yes" xml:space="preserve">
          <source>Like --keep create a .keep file before moving the index into its final destination, but rather than creating an empty file place &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; followed by an LF into the .keep file. The &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; message can later be searched for within all .keep files to locate any which have outlived their usefulness.</source>
          <target state="translated">Подобно --keep создать файл .keep перед перемещением индекса в его конечное место назначения, но вместо того, чтобы создавать пустое место файла &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; , за которым следует LF в файле .keep. Сообщение &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; позже можно будет найти во всех файлах .keep, чтобы найти те, которые утратили свою полезность.</target>
        </trans-unit>
        <trans-unit id="da58772c0d323657b31dd0d6c68daa01b72022dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--cherry-pick&lt;/code&gt; (see below) but mark equivalent commits with &lt;code&gt;=&lt;/code&gt; rather than omitting them, and inequivalent ones with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">Подобно &lt;code&gt;--cherry-pick&lt;/code&gt; (см. Ниже), но эквивалентные коммиты помечаются знаком &lt;code&gt;=&lt;/code&gt; , а не опускаются, а неэквивалентные - знаком &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b014ee75198b1ce501d5b1546fe06cd49ddd23" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--git-dir&lt;/code&gt;, but its output is always the canonicalized absolute path.</source>
          <target state="translated">Подобно &lt;code&gt;--git-dir&lt;/code&gt; , но его вывод всегда является канонизированным абсолютным путем.</target>
        </trans-unit>
        <trans-unit id="af1d4315bb510027eb7e61b588f2b477e26e55d4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--refresh&lt;/code&gt;, but checks stat information unconditionally, without regard to the &quot;assume unchanged&quot; setting.</source>
          <target state="translated">&lt;code&gt;--refresh&lt;/code&gt; , что и --refresh , но проверяет статистическую информацию безоговорочно, без учета настройки &amp;laquo;предполагать неизменность&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="649d7b810a2269259a3e3571033e0da598ccd04e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the commit message.</source>
          <target state="translated">Как &lt;code&gt;-C&lt;/code&gt; , но с &lt;code&gt;-c&lt;/code&gt; вызывается редактор, чтобы пользователь мог дальше редактировать сообщение фиксации.</target>
        </trans-unit>
        <trans-unit id="72f500fc1c4bd05ad014fbedf9cd9b9fb51f168b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the note message.</source>
          <target state="translated">Подобно &lt;code&gt;-C&lt;/code&gt; , но с &lt;code&gt;-c&lt;/code&gt; вызывается редактор, чтобы пользователь мог дальше редактировать сообщение заметки.</target>
        </trans-unit>
        <trans-unit id="5f2734a31de3aa99c55dc536f672e3afeacd6e67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; this variable has corresponding &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variants.</source>
          <target state="translated">Как и &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ,у этой переменной есть соответствующие &lt;code&gt;receive.fsck.skipList&lt;/code&gt; и &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f4973bf138d30d1fbff518822c72869393d6ab3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, imports handled by fast-import are safe to run alongside parallel &lt;code&gt;git repack -a -d&lt;/code&gt; or &lt;code&gt;git gc&lt;/code&gt; invocations, or any other Git operation (including &lt;code&gt;git prune&lt;/code&gt;, as loose objects are never used by fast-import).</source>
          <target state="translated">Подобно &lt;code&gt;git push&lt;/code&gt; или &lt;code&gt;git fetch&lt;/code&gt; , импорт, обрабатываемый fast-import, можно безопасно запускать вместе с параллельными &lt;code&gt;git repack -a -d&lt;/code&gt; или &lt;code&gt;git gc&lt;/code&gt; , или любой другой операцией Git (включая &lt;code&gt;git prune&lt;/code&gt; , поскольку свободные объекты никогда не используются быстрым импортом ).</target>
        </trans-unit>
        <trans-unit id="c7a0caab42cb430b8f7eb62e2b9ee91196438e5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git rebase&lt;/code&gt;; this requires that the working tree be clean and have no uncommitted changes.</source>
          <target state="translated">Как &lt;code&gt;git rebase&lt;/code&gt; ; для этого необходимо, чтобы рабочее дерево было чистым и не содержало незафиксированных изменений.</target>
        </trans-unit>
        <trans-unit id="94b902a35ff412729993e3558dc74f40d9a138f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;mailmap.file&lt;/code&gt;, but consider the value as a reference to a blob in the repository. If both &lt;code&gt;mailmap.file&lt;/code&gt; and &lt;code&gt;mailmap.blob&lt;/code&gt; are given, both are parsed, with entries from &lt;code&gt;mailmap.file&lt;/code&gt; taking precedence. In a bare repository, this defaults to &lt;code&gt;HEAD:.mailmap&lt;/code&gt;. In a non-bare repository, it defaults to empty.</source>
          <target state="translated">Как &lt;code&gt;mailmap.file&lt;/code&gt; , но рассматривайте значение как ссылку на большой двоичный объект в репозитории. Если &lt;code&gt;mailmap.file&lt;/code&gt; и mailmap.file, и &lt;code&gt;mailmap.blob&lt;/code&gt; , анализируются оба, причем записи из &lt;code&gt;mailmap.file&lt;/code&gt; имеют приоритет. В &lt;code&gt;HEAD:.mailmap&lt;/code&gt; репозитории по умолчанию используется HEAD: .mailmap . В репозитории, отличном от чистого, по умолчанию он пуст.</target>
        </trans-unit>
        <trans-unit id="e5b79d6b46ed0bad865e7c66642f5df5197bbc3e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pop&lt;/code&gt;, but do not remove the state from the stash list. Unlike &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; may be any commit that looks like a commit created by &lt;code&gt;stash push&lt;/code&gt; or &lt;code&gt;stash create&lt;/code&gt;.</source>
          <target state="translated">Как &lt;code&gt;pop&lt;/code&gt; , но не удаляйте состояние из списка тайников. В отличие от &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; может быть любой фиксацией, которая выглядит как фиксация, созданная с помощью &lt;code&gt;stash push&lt;/code&gt; или &lt;code&gt;stash create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b42cf6e877b403442b6c5e230e0a3121abfa79f2" translate="yes" xml:space="preserve">
          <source>Like get, but returns all values for a multi-valued key.</source>
          <target state="translated">Например,get,но возвращает все значения для многозначного ключа.</target>
        </trans-unit>
        <trans-unit id="73701f369b01fba26e9d0bb68ef652b62a8e8ce1" translate="yes" xml:space="preserve">
          <source>Like host.example:foo/repo, but use /home/foo/.ssh/somekey as keypair and user as user on remote side. This avoids needing to edit .ssh/config.</source>
          <target state="translated">Как и host.example:foo/repo,но используйте /home/foo/.ssh/somekey в качестве пары ключей и пользователя в качестве пользователя на удаленной стороне.Это позволяет избежать необходимости редактирования .ssh/config.</target>
        </trans-unit>
        <trans-unit id="6a22ef6226883a7823ee7468ab3e5221cd1b0fcc" translate="yes" xml:space="preserve">
          <source>Like many programs that switch user id, the daemon does not reset environment variables such as &lt;code&gt;$HOME&lt;/code&gt; when it runs git programs, e.g. &lt;code&gt;upload-pack&lt;/code&gt; and &lt;code&gt;receive-pack&lt;/code&gt;. When using this option, you may also want to set and export &lt;code&gt;HOME&lt;/code&gt; to point at the home directory of &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; before starting the daemon, and make sure any Git configuration files in that directory are readable by &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Как и многие программы, которые переключают идентификатор пользователя, демон не сбрасывает переменные среды, такие как &lt;code&gt;$HOME&lt;/code&gt; при запуске программ git, например, &lt;code&gt;upload-pack&lt;/code&gt; и &lt;code&gt;receive-pack&lt;/code&gt; . При использовании этой опции вы также можете настроить и экспортировать &lt;code&gt;HOME&lt;/code&gt; , чтобы он указывал на домашний каталог &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; перед запуском демона, и убедитесь, что все файлы конфигурации Git в этом каталоге доступны для чтения &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="955d6409ae367c03bad138119c6bf959eda46b3c" translate="yes" xml:space="preserve">
          <source>Likewise, when the &lt;code&gt;LV&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;-c&lt;/code&gt;. You can override this setting by exporting &lt;code&gt;LV&lt;/code&gt; with another value or setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;lv +c&lt;/code&gt;.</source>
          <target state="translated">Точно так же, когда переменная среды &lt;code&gt;LV&lt;/code&gt; не установлена, Git устанавливает для нее значение &lt;code&gt;-c&lt;/code&gt; . Вы можете переопределить этот параметр, экспортировав &lt;code&gt;LV&lt;/code&gt; с другим значением или установив для &lt;code&gt;core.pager&lt;/code&gt; значение &lt;code&gt;lv +c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da647d41a556bd9f858a9fb821a95fe4fa6d0849" translate="yes" xml:space="preserve">
          <source>Limit commits to the ones touching files in the given paths. Note, to avoid ambiguity with respect to revision names use &quot;--&quot; to separate the paths from any preceding options.</source>
          <target state="translated">Ограничить фиксации теми,кто касается файлов в заданных путях.Обратите внимание,чтобы избежать двусмысленности в отношении имен ревизий,используйте &quot;--&quot;,чтобы отделить пути от любых предыдущих опций.</target>
        </trans-unit>
        <trans-unit id="a8f6287e3aa57458fad3449d202e28c228d6d460" translate="yes" xml:space="preserve">
          <source>Limit diff output to named subtrees.</source>
          <target state="translated">Предельный вывод дифференциальных значений для именованных поддеревьев.</target>
        </trans-unit>
        <trans-unit id="73ea1d1481ae126a39e8d8a25424a40b0120067c" translate="yes" xml:space="preserve">
          <source>Limit fetching to ancestor-chains not longer than n. &lt;code&gt;git-upload-pack&lt;/code&gt; treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long.</source>
          <target state="translated">Ограничьте выборку цепочек предков не длиннее n. &lt;code&gt;git-upload-pack&lt;/code&gt; рассматривает специальную глубину 2147483647 как бесконечную, даже если существует такая длинная цепочка предков.</target>
        </trans-unit>
        <trans-unit id="3548328e70b776f579a206b5e26f3a2cdd3bf54c" translate="yes" xml:space="preserve">
          <source>Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a &lt;code&gt;shallow&lt;/code&gt; repository created by &lt;code&gt;git clone&lt;/code&gt; with &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; option (see &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.</source>
          <target state="translated">Ограничьте выборку указанным количеством коммитов из конца истории каждой удаленной ветки. При загрузке в &lt;code&gt;shallow&lt;/code&gt; репозиторий, созданный &lt;code&gt;git clone&lt;/code&gt; с параметром &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; (см. &lt;a href=&quot;git-clone&quot;&gt;Git-clone [1]&lt;/a&gt; ), углубите или сократите историю до указанного числа коммитов. Теги для углубленных коммитов не извлекаются.</target>
        </trans-unit>
        <trans-unit id="406e704b5fa6637d1092aef900d6bea100f59424" translate="yes" xml:space="preserve">
          <source>Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; is added to the included commits (if it exists) and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; are added to the excluded commits (if they exist). Thus, supposing there are no refs in &lt;code&gt;refs/bisect/&lt;/code&gt;, if</source>
          <target state="translated">Ограничьте вывод одним объектом фиксации, который находится примерно на полпути между включенными и исключенными фиксациями. Обратите внимание, что плохие ссылки &lt;code&gt;refs/bisect/bad&lt;/code&gt; добавляются к включенным коммитам (если они существуют), а хорошие ссылки пополам &lt;code&gt;refs/bisect/good-*&lt;/code&gt; добавляются к исключенным коммитам (если они существуют). Таким образом, предположим, что в &lt;code&gt;refs/bisect/&lt;/code&gt; нет ссылок , если</target>
        </trans-unit>
        <trans-unit id="2b149769f0e9e62c7755e40f7d9c9b100ff198f3" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones that match all given &lt;code&gt;--grep&lt;/code&gt;, instead of ones that match at least one.</source>
          <target state="translated">Ограничьте вывод &lt;code&gt;--grep&lt;/code&gt; теми, которые соответствуют всем заданным --grep , вместо тех, которые соответствуют хотя бы одному.</target>
        </trans-unit>
        <trans-unit id="119c553a83e823fd710ae4f2da2e455c4cb090b7" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression). With more than one &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose author matches any of the given patterns are chosen (similarly for multiple &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Ограничьте вывод коммитов теми, у которых строки заголовка автора / коммиттера соответствуют указанному шаблону (регулярному выражению). С более чем одним &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt; выбираются коммиты, автор которых соответствует любому из заданных шаблонов (аналогично для нескольких &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd1c85bc38b39ba5aff2bee57d4deea0c60fd712" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that do not match the pattern specified with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Ограничьте вывод &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; сообщениями с сообщениями журнала, которые не соответствуют шаблону, указанному с помощью --grep = &amp;lt;pattern&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="bd9eadb3ad8dfb9ffb371dc1589fe6576ab540f4" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that matches the specified pattern (regular expression). With more than one &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose message matches any of the given patterns are chosen (but see &lt;code&gt;--all-match&lt;/code&gt;).</source>
          <target state="translated">Ограничьте вывод коммитов теми, в которых сообщение журнала соответствует указанному шаблону (регулярному выражению). С более чем одним &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; выбираются коммиты, сообщение которых соответствует любому из заданных шаблонов (но см. &lt;code&gt;--all-match&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1b86714045e4612b85a2fa8cf22123bd3513cb6" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one &lt;code&gt;--grep-reflog&lt;/code&gt;, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless &lt;code&gt;--walk-reflogs&lt;/code&gt; is in use.</source>
          <target state="translated">Ограничьте вывод коммитов теми, у которых есть записи журнала ссылок, соответствующие указанному шаблону (регулярному выражению). С более чем одним &lt;code&gt;--grep-reflog&lt;/code&gt; выбираются коммиты, сообщение reflog которых соответствует любому из заданных шаблонов. Использование этой опции будет &lt;code&gt;--walk-reflogs&lt;/code&gt; если не используется --walk-reflogs .</target>
        </trans-unit>
        <trans-unit id="2b5d877818bdb0956a66e366504390cf3fe65b29" translate="yes" xml:space="preserve">
          <source>Limit the commits output to specified time range.</source>
          <target state="translated">Ограничить вывод фиксации заданным промежутком времени.</target>
        </trans-unit>
        <trans-unit id="d8dbf5f629bd3296e9ab1177de95e69729e1d54b" translate="yes" xml:space="preserve">
          <source>Limit the displayed commits to those directly on the ancestry chain between the &amp;ldquo;from&amp;rdquo; and &amp;ldquo;to&amp;rdquo; commits in the given commit range. I.e. only display commits that are ancestor of the &amp;ldquo;to&amp;rdquo; commit and descendants of the &amp;ldquo;from&amp;rdquo; commit.</source>
          <target state="translated">Ограничьте отображаемые коммиты теми, которые находятся непосредственно в цепочке предков между коммитами &amp;laquo;от&amp;raquo; и &amp;laquo;до&amp;raquo; в заданном диапазоне фиксации. Т.е. отображать только те коммиты, которые являются предком коммита &amp;laquo;до&amp;raquo; и потомками коммита &amp;laquo;от&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ed8c2d4ed1408e7d7da83719bcf77ad7b5896ff9" translate="yes" xml:space="preserve">
          <source>Limit the number of commits imported. Workaround for cases where cvsimport leaks memory.</source>
          <target state="translated">Ограничить количество импортируемых коммитов.Обходной путь для случаев,когда cvsimport утечка памяти.</target>
        </trans-unit>
        <trans-unit id="1adada65b7a03da88bf0748c36055d961c64b07a" translate="yes" xml:space="preserve">
          <source>Limit the number of commits to output.</source>
          <target state="translated">Ограничить количество коммитов для вывода.</target>
        </trans-unit>
        <trans-unit id="38e02fe4379a543b3e47180cba4d6468bec3e601" translate="yes" xml:space="preserve">
          <source>Limit the revisions to show. This can be either a single revision meaning show from the given revision and back, or it can be a range in the form &quot;&lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;&quot; to show all revisions between &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; and back to &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;. Note, more advanced revision selection can be applied. For a more complete list of ways to spell object names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Ограничьте количество отображаемых ревизий. Это может быть либо одна ревизия, означающая показ от данной ревизии и обратно, либо это может быть диапазон в форме &amp;laquo; &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; &amp;raquo;, чтобы показать все ревизии между &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; и обратно до &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; . Обратите внимание, что можно применить более расширенный выбор редакции. Более полный список способов &lt;a href=&quot;gitrevisions&quot;&gt;написания&lt;/a&gt; имен объектов см. В gitrevisions [7] .</target>
        </trans-unit>
        <trans-unit id="674ff0df4160db3404d979762630ae612e98f156" translate="yes" xml:space="preserve">
          <source>Limit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch.</source>
          <target state="translated">Ограничить ширину части графика в выводе --stat.Если установлено,применяется ко всем командам,генерирующим вывод --stat,кроме формата-patch.</target>
        </trans-unit>
        <trans-unit id="29e45322508b52ceb051971d532eab460b3dc7d7" translate="yes" xml:space="preserve">
          <source>Limit to &quot;refs/heads&quot; and &quot;refs/tags&quot;, respectively. These options are not mutually exclusive; when given both, references stored in &quot;refs/heads&quot; and &quot;refs/tags&quot; are displayed.</source>
          <target state="translated">Ограничение на &quot;ссылки/заголовки&quot; и &quot;ссылки/метки&quot; соответственно.Эти опции не являются взаимоисключающими;при указании обоих вариантов отображаются ссылки,хранящиеся в &quot;ссылках/заголовках&quot; и &quot;ссылках/метках&quot; соответственно.</target>
        </trans-unit>
        <trans-unit id="66b9fb961da3804ca95085a20ace37a86529e6f7" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.</source>
          <target state="translated">Ограничение только ссылками / заголовками и ссылками / тегами соответственно. Эти варианты &lt;code&gt;not&lt;/code&gt; исключают друг друга; если заданы оба параметра, отображаются ссылки, хранящиеся в refs / Heads и refs / tags.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="e8bb22d887f5d59400be2b36a39e61d714bda7bc" translate="yes" xml:space="preserve">
          <source>Limiting the diff output</source>
          <target state="translated">Ограничение диффузионного выхода</target>
        </trans-unit>
        <trans-unit id="b7748eb338af2086cdad1f6af364c3481df64676" translate="yes" xml:space="preserve">
          <source>Limits the number of commits to show to 3.</source>
          <target state="translated">Ограничивает количество показываемых коммитов до 3.</target>
        </trans-unit>
        <trans-unit id="efd756293dbb86969a7022bf4157b3145d6076f3" translate="yes" xml:space="preserve">
          <source>Limits the paths affected by the operation.</source>
          <target state="translated">Ограничивает пути,на которые влияет работа.</target>
        </trans-unit>
        <trans-unit id="8375cb461aa1ace8d2ffdda18edb87b333f2f4d1" translate="yes" xml:space="preserve">
          <source>Line numbers count from 1.</source>
          <target state="translated">Номер строки отсчитывается от 1.</target>
        </trans-unit>
        <trans-unit id="3d9326a0fc6538daba3b0f3096cf5c416812b52b" translate="yes" xml:space="preserve">
          <source>Lines starting with a hash (&quot;&lt;code&gt;#&lt;/code&gt;&quot;) are ignored, so they can be used for comments. Add a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) to the beginning of the pattern if it starts with a hash.</source>
          <target state="translated">Строки, начинающиеся с решетки (&quot; &lt;code&gt;#&lt;/code&gt; &quot;), игнорируются, поэтому их можно использовать для комментариев. Добавьте обратную косую черту (&quot; &lt;code&gt;\&lt;/code&gt; &quot;) в начало шаблона, если он начинается с хеша.</target>
        </trans-unit>
        <trans-unit id="8e28fd820953d60830c4b1106307e2e0b6872452" translate="yes" xml:space="preserve">
          <source>Linewrap the output by wrapping each line at &lt;code&gt;width&lt;/code&gt;. The first line of each entry is indented by &lt;code&gt;indent1&lt;/code&gt; spaces, and the second and subsequent lines are indented by &lt;code&gt;indent2&lt;/code&gt; spaces. &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;indent1&lt;/code&gt;, and &lt;code&gt;indent2&lt;/code&gt; default to 76, 6 and 9 respectively.</source>
          <target state="translated">Оберните вывод строкой, обернув каждую строку по &lt;code&gt;width&lt;/code&gt; . Первая строка каждой записи имеет отступ пробелов &lt;code&gt;indent1&lt;/code&gt; , а вторая и последующие строки - пробелами &lt;code&gt;indent2&lt;/code&gt; . &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;indent1&lt;/code&gt; и &lt;code&gt;indent2&lt;/code&gt; по умолчанию равны 76, 6 и 9 соответственно.</target>
        </trans-unit>
        <trans-unit id="1d1f6a47e210ac264339f2e30472d9fdf4025a54" translate="yes" xml:space="preserve">
          <source>Links and their targets</source>
          <target state="translated">Связи и их цели</target>
        </trans-unit>
        <trans-unit id="7177342122325630102d4a83723d13417535ac19" translate="yes" xml:space="preserve">
          <source>Linus Torvalds originally designed Git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of Git.</source>
          <target state="translated">Линус Торвальдс изначально проектировал Git как файловую систему пользовательского пространства,т.е.инфраструктуру для хранения файлов и каталогов.Это обеспечило эффективность и скорость работы Git'а.</target>
        </trans-unit>
        <trans-unit id="9f9879c2ed0b6b8dfd5d9b1ecb4faa0c5584d26d" translate="yes" xml:space="preserve">
          <source>Linus Torvalds, for example, makes new kernel releases by tagging them, then running:</source>
          <target state="translated">Линус Торвальдс (Linus Torvalds),например,делает новые релизы ядра,пометив их метками,а затем запустив:</target>
        </trans-unit>
        <trans-unit id="c215fd74e10e91e4728dc7ef559cf830d21a3457" translate="yes" xml:space="preserve">
          <source>Linus&amp;rsquo;s tree will be stored in the remote-tracking branch named origin/master, and can be updated using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;; you can track other public trees using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; to set up a &quot;remote&quot; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; to keep them up to date; see &lt;a href=&quot;#repositories-and-branches&quot;&gt;Repositories and Branches&lt;/a&gt;.</source>
          <target state="translated">Дерево Линуса будет храниться в ветке удаленного отслеживания с именем origin / master и может быть обновлено с помощью &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; ; вы можете отслеживать другие общедоступные деревья, используя &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; для настройки &amp;laquo;удаленного&amp;raquo; и &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1],&lt;/a&gt; чтобы поддерживать их в актуальном состоянии; см. &lt;a href=&quot;#repositories-and-branches&quot;&gt;Репозитории и Филиалы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a79bad3bb798b3bdc01c2a7bbb2df04a2b261bb" translate="yes" xml:space="preserve">
          <source>List (array reference) of feature parameters (if there are any), used also to toggle (enable or disable) given feature.</source>
          <target state="translated">Список (ссылка на массив)параметров объекта (если таковой имеется),используемый также для переключения (включения или выключения)данного объекта.</target>
        </trans-unit>
        <trans-unit id="7ee03188f58cdb7509c4f88e1a300f564da6d9fa" translate="yes" xml:space="preserve">
          <source>List all attributes that are associated with the specified paths. If this option is used, then &lt;code&gt;unspecified&lt;/code&gt; attributes will not be included in the output.</source>
          <target state="translated">Список всех атрибутов, связанных с указанными путями. Если используется эта опция, то &lt;code&gt;unspecified&lt;/code&gt; атрибуты не будут включены в вывод.</target>
        </trans-unit>
        <trans-unit id="250839942391006b259bdb87bdef885727a6f6a9" translate="yes" xml:space="preserve">
          <source>List all available configuration variables. This is a short summary of the list in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Перечислите все доступные переменные конфигурации. Это краткое изложение списка в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12ac07106316dd6381b9d3b75b7cd7d028c9fa93" translate="yes" xml:space="preserve">
          <source>List all commits reachable from all refs</source>
          <target state="translated">Перечислить все коммиты,до которых можно добраться из всех рефери</target>
        </trans-unit>
        <trans-unit id="dca598d76b2fd502e68ee09810f65324e1da32ae" translate="yes" xml:space="preserve">
          <source>List all tags (lightweight and annotated) in given repository.</source>
          <target state="translated">Перечислите все теги (легкие и аннотированные)в данном репозитории.</target>
        </trans-unit>
        <trans-unit id="df1447e22cac81b01f2aee49d9517212423de9a9" translate="yes" xml:space="preserve">
          <source>List all variables set in config file, along with their values.</source>
          <target state="translated">Перечислите все переменные,установленные в конфигурационном файле,вместе с их значениями.</target>
        </trans-unit>
        <trans-unit id="aa1b92c795a51cb41c1ee54087151d51eda95116" translate="yes" xml:space="preserve">
          <source>List both remote-tracking branches and local branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match optional pattern(s).</source>
          <target state="translated">Перечислите как ветки удаленного отслеживания, так и локальные ветки. Комбинируйте с &lt;code&gt;--list&lt;/code&gt; для сопоставления необязательных шаблонов.</target>
        </trans-unit>
        <trans-unit id="670ea777adabe92ea2a21ddec9e8062878d9ce68" translate="yes" xml:space="preserve">
          <source>List branches. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git
branch --list 'maint-*'&lt;/code&gt;, list only the branches that match the pattern(s).</source>
          <target state="translated">Список веток. С необязательным &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; , например, &lt;code&gt;git branch --list 'maint-*'&lt;/code&gt; , вывести список только тех ветвей, которые соответствуют шаблону (ам).</target>
        </trans-unit>
        <trans-unit id="ecd6ee4f3b1cdf8c4e62426b401b6921926e6641" translate="yes" xml:space="preserve">
          <source>List commands by group. This is an internal/experimental option and may change or be removed in the future. Supported groups are: builtins, parseopt (builtin commands that use parse-options), main (all commands in libexec directory), others (all other commands in &lt;code&gt;$PATH&lt;/code&gt; that have git- prefix), list-&amp;lt;category&amp;gt; (see categories in command-list.txt), nohelpers (exclude helper commands), alias and config (retrieve command list from config variable completion.commands)</source>
          <target state="translated">Список команд по группам. Это внутренний / экспериментальный вариант, который может быть изменен или удален в будущем. Поддерживаемые группы: builtins, parseopt (встроенные команды, использующие параметры синтаксического анализа), main (все команды в каталоге libexec), другие (все другие команды в &lt;code&gt;$PATH&lt;/code&gt; с префиксом git-), list- &amp;lt;category&amp;gt; (см. Категории в command-list.txt), nohelpers (исключить вспомогательные команды), псевдоним и конфигурация (получить список команд из переменной конфигурации completed.commands)</target>
        </trans-unit>
        <trans-unit id="238ed7681a7fd585fe1d585aba4d3e4521202ffa" translate="yes" xml:space="preserve">
          <source>List commits that are reachable by following the &lt;code&gt;parent&lt;/code&gt; links from the given commit(s), but exclude commits that are reachable from the one(s) given with a &lt;code&gt;^&lt;/code&gt; in front of them. The output is given in reverse chronological order by default.</source>
          <target state="translated">Перечислить коммиты, которые доступны по &lt;code&gt;parent&lt;/code&gt; ссылкам из данного коммита (й), но исключить коммиты, доступные из коммитов, указанных с символом &lt;code&gt;^&lt;/code&gt; перед ними. По умолчанию выходные данные отображаются в обратном хронологическом порядке.</target>
        </trans-unit>
        <trans-unit id="adfacb775267bd93896cdbdf525c103ac26c16d4" translate="yes" xml:space="preserve">
          <source>List details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include if the worktree is bare, the revision currently checked out, and the branch currently checked out (or &lt;code&gt;detached HEAD&lt;/code&gt; if none).</source>
          <target state="translated">Перечислите детали каждого рабочего дерева. Сначала указывается главное рабочее дерево, за ним следует каждое из связанных рабочих деревьев. Детали вывода включают в себя, является ли рабочее дерево пустым, текущая проверенная ревизия и ветвь, которая в настоящее время проверена (или &lt;code&gt;detached HEAD&lt;/code&gt; если ее нет).</target>
        </trans-unit>
        <trans-unit id="1481dab663abae987b5437270fc0152b6258984f" translate="yes" xml:space="preserve">
          <source>List of Git base URLs. These URLs are used to generate URLs describing from where to fetch a project, which are shown on project summary page. The full fetch URL is &quot;&lt;code&gt;$git_base_url/$project&lt;/code&gt;&quot;, for each element of this list. You can set up multiple base URLs (for example one for &lt;code&gt;git://&lt;/code&gt; protocol, and one for &lt;code&gt;http://&lt;/code&gt; protocol).</source>
          <target state="translated">Список базовых URL-адресов Git. Эти URL-адреса используются для генерации URL-адресов, описывающих, откуда можно получить проект, которые отображаются на странице сводки проекта. Полный URL-адрес выборки - &amp;laquo; &lt;code&gt;$git_base_url/$project&lt;/code&gt; &amp;raquo; для каждого элемента этого списка. Вы можете настроить несколько базовых URL-адресов (например, один для протокола &lt;code&gt;git://&lt;/code&gt; и один для протокола &lt;code&gt;http://&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e9453e698a4a15232ec2c038afd4c298aede850c" translate="yes" xml:space="preserve">
          <source>List of URIs of stylesheets (relative to the base URI of a page). You might specify more than one stylesheet, for example to use &quot;gitweb.css&quot; as base with site specific modifications in a separate stylesheet to make it easier to upgrade gitweb. For example, you can add a &lt;code&gt;site&lt;/code&gt; stylesheet by putting</source>
          <target state="translated">Список URI таблиц стилей (относительно базового URI страницы). Вы можете указать более одной таблицы стилей, например, использовать &amp;laquo;gitweb.css&amp;raquo; в качестве основы с изменениями для конкретного сайта в отдельной таблице стилей, чтобы упростить обновление gitweb. Например, вы можете добавить таблицу стилей &lt;code&gt;site&lt;/code&gt; , поместив</target>
        </trans-unit>
        <trans-unit id="d9ab3387c39e123d7aac2edb253dcdba7080f753" translate="yes" xml:space="preserve">
          <source>List of additional directories under &quot;refs&quot; which are going to be used as branch refs. For example if you have a gerrit setup where all branches under refs/heads/ are official, push-after-review ones and branches under refs/sandbox/, refs/wip and refs/other are user ones where permissions are much wider, then you might want to set this variable as follows:</source>
          <target state="translated">Список дополнительных каталогов под &quot;ссылками&quot;,которые будут использоваться в качестве ссылок на ветки.Например,если у вас есть настройка gerrit,в которой все ветки под refs/heads/являются официальными,push-после просмотра-официальными,а ветки под refs/sandbox/,refs/wip и refs/другие-пользовательскими,где права гораздо шире,то вы можете захотеть установить эту переменную следующим образом:</target>
        </trans-unit>
        <trans-unit id="c919f43c88ec5761218ece7f29ac150fc5c1298f" translate="yes" xml:space="preserve">
          <source>List of branches to be imported when branch detection is enabled. Each entry should be a pair of branch names separated by a colon (:). This example declares that both branchA and branchB were created from main:</source>
          <target state="translated">Список веток,которые необходимо импортировать при включенном обнаружении веток.Каждая запись должна быть парой имён ветвей,разделенных двоеточием (:).В этом примере декларируется,что и branchA и branchB были созданы из основного:</target>
        </trans-unit>
        <trans-unit id="3d6057539fc43b4e5580b21aa940b705e61341be" translate="yes" xml:space="preserve">
          <source>List of p4 labels to ignore. This is built automatically as unimportable labels are discovered.</source>
          <target state="translated">Список лейблов p4,которые нужно игнорировать.Он строится автоматически по мере обнаружения неимоверных меток.</target>
        </trans-unit>
        <trans-unit id="ed979d0137e2b09484f09056901ac3efce874117" translate="yes" xml:space="preserve">
          <source>List only commits on the respective side of a symmetric difference, i.e. only those which would be marked &lt;code&gt;&amp;lt;&lt;/code&gt; resp. &lt;code&gt;&amp;gt;&lt;/code&gt; by &lt;code&gt;--left-right&lt;/code&gt;.</source>
          <target state="translated">List фиксируется только на соответствующей стороне симметричной разницы, т.е. только те, которые были бы помечены &lt;code&gt;&amp;lt;&lt;/code&gt; соответственно. &lt;code&gt;&amp;gt;&lt;/code&gt; По &lt;code&gt;--left-right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db38d2130aa4774e0a5e01e813cbe87b286b5c58" translate="yes" xml:space="preserve">
          <source>List only filenames (instead of the &quot;long&quot; output), one per line.</source>
          <target state="translated">Прослушивайте только имена файлов (вместо &quot;длинного&quot; вывода),по одному на строку.</target>
        </trans-unit>
        <trans-unit id="ca0ba00456e1892ce61ce3c77aa65cb5194d4e6c" translate="yes" xml:space="preserve">
          <source>List or delete (if used with -d) the remote-tracking branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match the optional pattern(s).</source>
          <target state="translated">Перечислить или удалить (если используется с -d) ветки удаленного отслеживания. Комбинируйте с &lt;code&gt;--list&lt;/code&gt; для соответствия необязательному шаблону (ам).</target>
        </trans-unit>
        <trans-unit id="22eb51b821276ed4742fd46da8d914f3eb506ca1" translate="yes" xml:space="preserve">
          <source>List output format</source>
          <target state="translated">Формат вывода списка</target>
        </trans-unit>
        <trans-unit id="961866b18d2006e9e2f1c57af615530c0dcb0176" translate="yes" xml:space="preserve">
          <source>List references in a local repository</source>
          <target state="translated">Перечислить ссылки в локальном репозитории</target>
        </trans-unit>
        <trans-unit id="7a309b311eeb5429dbbc4c270383e0c9240ea7dd" translate="yes" xml:space="preserve">
          <source>List references in a remote repository</source>
          <target state="translated">Перечислить ссылки в удаленном репозитории</target>
        </trans-unit>
        <trans-unit id="c3c4b04779710ca49a121ec3b626bb207fe0cc86" translate="yes" xml:space="preserve">
          <source>List replace refs for objects that match the given pattern (or all if no pattern is given). Typing &quot;git replace&quot; without arguments, also lists all replace refs.</source>
          <target state="translated">Список заменяет ссылки на объекты,которые соответствуют заданному шаблону (или все,если шаблон не указан).При вводе &quot;git replace&quot; без аргументов,также перечисляются все заменяющие ссылки.</target>
        </trans-unit>
        <trans-unit id="dd864736379915e26071e39557a37c9a699c5cd9" translate="yes" xml:space="preserve">
          <source>List some tags in a table with unequal column widths:</source>
          <target state="translated">Перечислите некоторые теги в таблице с неравной шириной столбцов:</target>
        </trans-unit>
        <trans-unit id="c3a7e0023c585da8fc00add926f4e7fe3e4bed2d" translate="yes" xml:space="preserve">
          <source>List tags. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git tag --list
'v-*'&lt;/code&gt;, list only the tags that match the pattern(s).</source>
          <target state="translated">Список тегов. С необязательным &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; , например, &lt;code&gt;git tag --list 'v-*'&lt;/code&gt; , перечислить только теги, соответствующие шаблону (ам).</target>
        </trans-unit>
        <trans-unit id="42f93b25d56793afc3463e924a37b81b3e45f73d" translate="yes" xml:space="preserve">
          <source>List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.</source>
          <target state="translated">Перечислите переменные окружения GIT_*,которые являются локальными для репозитория (например,GIT_DIR или GIT_WORK_TREE,но не GIT_EDITOR).Перечисляются только имена переменных,а не их значения,даже если они установлены.</target>
        </trans-unit>
        <trans-unit id="dc410162c15e0c2fc959648b2d515436ff66231c" translate="yes" xml:space="preserve">
          <source>List the contents of a tree object</source>
          <target state="translated">Перечислить содержимое объекта дерева</target>
        </trans-unit>
        <trans-unit id="c77a61ab930b102983b7633429f2e1c89c8a648a" translate="yes" xml:space="preserve">
          <source>List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format &quot;&amp;lt;note object&amp;gt; &amp;lt;annotated object&amp;gt;&quot;). This is the default subcommand if no subcommand is given.</source>
          <target state="translated">Перечислите объект заметок для данного объекта. Если объект не указан, покажите список всех объектов примечания и объектов, которые они аннотируют (в формате &amp;laquo;&amp;lt;объект примечания&amp;gt; &amp;lt;аннотированный объект&amp;gt;&amp;raquo;). Это подкоманда по умолчанию, если подкоманда не задана.</target>
        </trans-unit>
        <trans-unit id="160440cac4234691b237108179766c8ac388a3dd" translate="yes" xml:space="preserve">
          <source>List the stash entries that you currently have. Each &lt;code&gt;stash entry&lt;/code&gt; is listed with its name (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the latest entry, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on.</source>
          <target state="translated">Перечислите записи в тайнике, которые у вас есть. Каждая &lt;code&gt;stash entry&lt;/code&gt; указывается с ее именем (например, &lt;code&gt;stash@{0}&lt;/code&gt; - это последняя запись, &lt;code&gt;stash@{1}&lt;/code&gt; - предыдущая и т. Д.), Именем ветки, которая была текущей на момент создания записи, и краткое описание фиксации, на которой была основана запись.</target>
        </trans-unit>
        <trans-unit id="0928a18c981cee8dd1bbd962ad11b79b09b49f73" translate="yes" xml:space="preserve">
          <source>List, create, or delete branches</source>
          <target state="translated">Составить список,создать или удалить ветки</target>
        </trans-unit>
        <trans-unit id="7d888e358c6ef40ec2a0a8a674979b45cd6d1cf4" translate="yes" xml:space="preserve">
          <source>Listed below are options that control the formatting of diff output. Some of them are specific to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, however other diff options may be given. See &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for more options.</source>
          <target state="translated">Ниже перечислены параметры, управляющие форматированием вывода diff. Некоторые из них относятся к &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; , однако могут быть указаны другие параметры сравнения. Дополнительные параметры см. В &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3248fa00aea630b8bbaf0b4709f9f26882639bdc" translate="yes" xml:space="preserve">
          <source>Listen on a specific IP address or hostname. IP addresses can be either an IPv4 address or an IPv6 address if supported. If IPv6 is not supported, then --listen=hostname is also not supported and --listen must be given an IPv4 address. Can be given more than once. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">Слушайте определенный IP-адрес или имя хоста. IP-адреса могут быть либо адресом IPv4, либо адресом IPv6, если он поддерживается. Если IPv6 не поддерживается, то --listen = hostname также не поддерживается, и --listen должен иметь адрес IPv4. Можно давать более одного раза. Несовместимо с параметром &lt;code&gt;--inetd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f53ff7586b49256325ec58801bfe143f18e21e3" translate="yes" xml:space="preserve">
          <source>Listen on an alternative port. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">Слушайте альтернативный порт. Несовместимо с параметром &lt;code&gt;--inetd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e35805a9773260286dfbc09d02caaf5994dc0ce" translate="yes" xml:space="preserve">
          <source>Listing a single attribute:</source>
          <target state="translated">Перечисляет один атрибут:</target>
        </trans-unit>
        <trans-unit id="69751d90f1fec1736a7673316bf3b759c5271c7d" translate="yes" xml:space="preserve">
          <source>Listing all attributes for a file:</source>
          <target state="translated">Перечисление всех атрибутов для файла:</target>
        </trans-unit>
        <trans-unit id="e231fe1cc3d8844bfddb76169e22179c8767ce9e" translate="yes" xml:space="preserve">
          <source>Listing an attribute for multiple files:</source>
          <target state="translated">Перечисление атрибута для нескольких файлов:</target>
        </trans-unit>
        <trans-unit id="d1d9eec0e1bd38bd76cb67feb04b08b5d78c11bd" translate="yes" xml:space="preserve">
          <source>Listing branches from a specific remote</source>
          <target state="translated">Включение филиалов в список с определенного пульта дистанционного управления</target>
        </trans-unit>
        <trans-unit id="14162152c45d26fb9527c9f0660bef886294e5bf" translate="yes" xml:space="preserve">
          <source>Listing multiple attributes for a file:</source>
          <target state="translated">Перечисление нескольких атрибутов для файла:</target>
        </trans-unit>
        <trans-unit id="540f872616da666be00fd2f7f78a7ae984c11b9a" translate="yes" xml:space="preserve">
          <source>Lists all local or all remote-tracking branches in given repository.</source>
          <target state="translated">Списки всех локальных или всех удаленных отслеживаемых ветвей в данном репозитории.</target>
        </trans-unit>
        <trans-unit id="b5500d120a9a13cb3af42448653e0cde10752de4" translate="yes" xml:space="preserve">
          <source>Lists commit objects in reverse chronological order</source>
          <target state="translated">Списки фиксируют объекты в обратном хронологическом порядке</target>
        </trans-unit>
        <trans-unit id="6385084e9b2c3e78376900259ba28376e3a28618" translate="yes" xml:space="preserve">
          <source>Lists the available Git repositories. This is the default command if no repository is specified in the URL.</source>
          <target state="translated">Перечисляет доступные Git-репозитории.Это команда по умолчанию,если в URL не указан ни один репозиторий.</target>
        </trans-unit>
        <trans-unit id="9438685d87876d6c82356bf9b864c1c6136c1266" translate="yes" xml:space="preserve">
          <source>Lists the capabilities of the helper, one per line, ending with a blank line. Each capability may be preceded with &lt;code&gt;*&lt;/code&gt;, which marks them mandatory for Git versions using the remote helper to understand. Any unknown mandatory capability is a fatal error.</source>
          <target state="translated">Перечисляет возможности помощника, по одной в строке, заканчивая пустой строкой. Каждой возможности может предшествовать символ &lt;code&gt;*&lt;/code&gt; , который отмечает их обязательность для версий Git, использующих удаленный помощник для понимания. Любая неизвестная обязательная возможность является фатальной ошибкой.</target>
        </trans-unit>
        <trans-unit id="8c594a1bf48edecf6065890a7f89cc7fa404495f" translate="yes" xml:space="preserve">
          <source>Lists the contents of a given tree object, like what &quot;/bin/ls -a&quot; does in the current working directory. Note that:</source>
          <target state="translated">Перечисляет содержимое заданного объекта дерева,например,что делает &quot;/bin/ls -a&quot; в текущей рабочей директории.Обратите внимание на это:</target>
        </trans-unit>
        <trans-unit id="9cc5eb61d77cd46774cb42ac22301b7d413d58c5" translate="yes" xml:space="preserve">
          <source>Lists the properties stored in the Subversion repository about a given file or directory. Use -r/--revision to refer to a specific Subversion revision.</source>
          <target state="translated">Перечисляет свойства,хранящиеся в репозитории Subversion о данном файле или каталоге.Используйте -r/-ревизию для ссылки на конкретную ревизию Subversion.</target>
        </trans-unit>
        <trans-unit id="11c5aa2ca7f7c3e091142bb69f047bf1ca338d7f" translate="yes" xml:space="preserve">
          <source>Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out.</source>
          <target state="translated">Перечисляет ссылки,определенные в связке.Если за списком следует список ссылок,то распечатываются только те ссылки,которые соответствуют приведенным.</target>
        </trans-unit>
        <trans-unit id="cb27642bee7df675e576f1467eabd36ebf236a0c" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="translated">Перечисляет ссылки, по одной в строке, в формате &amp;laquo;&amp;lt;значение&amp;gt; &amp;lt;имя&amp;gt; [&amp;lt;атрибут&amp;gt;&amp;hellip;]&amp;raquo;. Значение может быть шестнадцатеричным хешем sha1, &quot;@ &amp;lt;dest&amp;gt;&quot; для символьной ссылки или &quot;?&quot; чтобы указать, что помощник не может получить значение ref. После имени следует список атрибутов, разделенных пробелами; нераспознанные атрибуты игнорируются. Список заканчивается пустой строкой.</target>
        </trans-unit>
        <trans-unit id="8cf165480241df10f979b6b7157595e5407c755f" translate="yes" xml:space="preserve">
          <source>Literal percent sign.</source>
          <target state="translated">Буквальный знак процента.</target>
        </trans-unit>
        <trans-unit id="c9b025ce8a30fb92786ef26cc44501e09df585de" translate="yes" xml:space="preserve">
          <source>Literal space in command or argument.</source>
          <target state="translated">Буквальное пространство в команде или аргументе.</target>
        </trans-unit>
        <trans-unit id="3e47004eca06847317d03882ea01098236feca24" translate="yes" xml:space="preserve">
          <source>Loads annotations as described above and automatically scrolls the view to center on line &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">Загружает аннотации, как описано выше, и автоматически прокручивает вид до центра строки &lt;code&gt;100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f638d2718f9a7fa3228a4c22ea27ab0cb7ce0ed8" translate="yes" xml:space="preserve">
          <source>Local directory</source>
          <target state="translated">локальная директория</target>
        </trans-unit>
        <trans-unit id="83cd95e5e26d810cf34fa10fd02190221225a995" translate="yes" xml:space="preserve">
          <source>Locate a good region of the object graph in a damaged repository</source>
          <target state="translated">Найти хорошую область объектного графика в поврежденном репозитории.</target>
        </trans-unit>
        <trans-unit id="c6b89ef8cfe5b4e0d5f71a9018f7c23272508e1d" translate="yes" xml:space="preserve">
          <source>Location of repositories</source>
          <target state="translated">Расположение репозиториев</target>
        </trans-unit>
        <trans-unit id="a8464429b3dd8a54d4c3a8d0aaf7809c3b93d077" translate="yes" xml:space="preserve">
          <source>Locations of Marks Files</source>
          <target state="translated">Места расположения маркерных файлов</target>
        </trans-unit>
        <trans-unit id="747742f75a08750185466d70d49a66f609262970" translate="yes" xml:space="preserve">
          <source>Locations of the common system-wide configuration file, the fallback system-wide configuration file and the per-instance configuration file are defined at compile time using build-time Makefile configuration variables, respectively &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt;.</source>
          <target state="translated">Расположение общего общесистемного файла конфигурации, резервного общесистемного файла конфигурации и файла конфигурации для каждого экземпляра определяется во время компиляции с использованием переменных конфигурации Makefile времени сборки, соответственно &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; и &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8e7c6671e74ff8d9e440b7a275b6b3047a92bf" translate="yes" xml:space="preserve">
          <source>Log details about the incoming connections and requested files.</source>
          <target state="translated">Подробная информация о входящих соединениях и запрошенных файлах.</target>
        </trans-unit>
        <trans-unit id="c1bbca864796e717c6563546ee8bb0273fbae9ac" translate="yes" xml:space="preserve">
          <source>Logging updates</source>
          <target state="translated">Обновления журнала</target>
        </trans-unit>
        <trans-unit id="e76f4d6fb1700b21a7cf7fc7a62d7a34c7014ae2" translate="yes" xml:space="preserve">
          <source>Long Running Filter Process</source>
          <target state="translated">Длительно работающий процесс фильтрации</target>
        </trans-unit>
        <trans-unit id="555712d9829e6328a9b7d5ec70facbda745fb9b3" translate="yes" xml:space="preserve">
          <source>Look at the diffs from each branch. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; will show diffs first for the &lt;code&gt;HEAD&lt;/code&gt; version and then the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">Посмотрите различия в каждой ветке. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; сначала покажет различия для версии &lt;code&gt;HEAD&lt;/code&gt; , а затем для версии &lt;code&gt;MERGE_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a326ab540e0d9536d53dbc94d57cb0c25e24d9a1" translate="yes" xml:space="preserve">
          <source>Look at the diffs. &lt;code&gt;git diff&lt;/code&gt; will show a three-way diff, highlighting changes from both the &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;MERGE_HEAD&lt;/code&gt; versions.</source>
          <target state="translated">Посмотрите на различия. &lt;code&gt;git diff&lt;/code&gt; покажет трехстороннее различие, выделив изменения в версиях &lt;code&gt;HEAD&lt;/code&gt; и &lt;code&gt;MERGE_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8c63749f2ae2fa24fa7ef48c360ef59f66a1f48" translate="yes" xml:space="preserve">
          <source>Look at the originals. &lt;code&gt;git show :1:filename&lt;/code&gt; shows the common ancestor, &lt;code&gt;git show :2:filename&lt;/code&gt; shows the &lt;code&gt;HEAD&lt;/code&gt; version, and &lt;code&gt;git show :3:filename&lt;/code&gt; shows the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">Посмотрите на оригиналы. &lt;code&gt;git show :1:filename&lt;/code&gt; показывает общего предка, &lt;code&gt;git show :2:filename&lt;/code&gt; показывает версию &lt;code&gt;HEAD&lt;/code&gt; , а &lt;code&gt;git show :3:filename&lt;/code&gt; показывает версию &lt;code&gt;MERGE_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a423d84e076a3272fdc685127299ea63ea761ac" translate="yes" xml:space="preserve">
          <source>Look for a fix instead of a regression in the code</source>
          <target state="translated">Ищите исправление вместо регрессии в коде.</target>
        </trans-unit>
        <trans-unit id="4ab23275475ac09a44d78ac861e7af3c95082023" translate="yes" xml:space="preserve">
          <source>Look for attributes in .gitattributes files in the working tree as well (see &lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt;).</source>
          <target state="translated">Также ищите атрибуты в файлах .gitattributes в рабочем дереве (см. &lt;a href=&quot;#ATTRIBUTES&quot;&gt;АТРИБУТЫ&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e41023ffb67a9b868c13a5cdc624ea0d794092d" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified object. Similar to &lt;code&gt;-S&lt;/code&gt;, just the argument is different in that it doesn&amp;rsquo;t search for a specific string but for a specific object id.</source>
          <target state="translated">Ищите различия, которые изменяют количество вхождений указанного объекта. Подобно &lt;code&gt;-S&lt;/code&gt; , только аргумент отличается тем, что он ищет не конкретную строку, а конкретный идентификатор объекта.</target>
        </trans-unit>
        <trans-unit id="a838d092d782360d96378f1e4ff8a0b5fffd060f" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">Ищите различия, которые изменяют количество вхождений указанной строки (т. Е. Добавления / удаления) в файле. Предназначен для использования скриптером.</target>
        </trans-unit>
        <trans-unit id="b8df136f2384d637ef409fc2baddd2b9dce73992" translate="yes" xml:space="preserve">
          <source>Look for differences whose patch text contains added/removed lines that match &amp;lt;regex&amp;gt;.</source>
          <target state="translated">Ищите отличия, текст патча которых содержит добавленные / удаленные строки, соответствующие &amp;lt;regex&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="4cef9adbc5be0f5f01b5c2739071b69091cb4a32" translate="yes" xml:space="preserve">
          <source>Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines.</source>
          <target state="translated">Ищите заданные шаблоны в отслеживаемых файлах в рабочем дереве,капли,зарегистрированные в индексном файле,или капли в заданных объектах дерева.Шаблоны-это списки одного или нескольких поисковых выражений,разделенных символами новой строки.Пустая строка в качестве поискового выражения соответствует всем строкам.</target>
        </trans-unit>
        <trans-unit id="07448c29252081320f670b2265de0e9cba50a292" translate="yes" xml:space="preserve">
          <source>Look up layout mode using configuration variable column.&amp;lt;name&amp;gt; and column.ui.</source>
          <target state="translated">Найдите режим макета, используя переменную конфигурации column. &amp;lt;name&amp;gt; и column.ui.</target>
        </trans-unit>
        <trans-unit id="b62eefc27e1aeffa75b2d4761547bc2b8bc497bd" translate="yes" xml:space="preserve">
          <source>Looks at the current index and checks to see if merges or updates are needed by checking stat() information.</source>
          <target state="translated">Смотрит на текущий индекс и проверяет,нужны ли слияния или обновления,проверяя информацию stat().</target>
        </trans-unit>
        <trans-unit id="4b7876b6a8ad520457ce71bfe745148e3c567edb" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;solution&lt;/code&gt;, excluding files in &lt;code&gt;Documentation&lt;/code&gt;.</source>
          <target state="translated">Ищет &lt;code&gt;solution&lt;/code&gt; , исключая файлы в &lt;code&gt;Documentation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f3233017974f60253fdf12d744b51a535433787" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;time_t&lt;/code&gt; in all tracked .c and .h files in the working directory and its subdirectories.</source>
          <target state="translated">Ищет &lt;code&gt;time_t&lt;/code&gt; во всех отслеживаемых файлах .c и .h в рабочем каталоге и его подкаталогах.</target>
        </trans-unit>
        <trans-unit id="558837c842e106c2ed3e4e9a131c3a7442c122b9" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;#define&lt;/code&gt; and either &lt;code&gt;MAX_PATH&lt;/code&gt; or &lt;code&gt;PATH_MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MAX_PATH&lt;/code&gt; строку с &lt;code&gt;#define&lt;/code&gt; и MAX_PATH или &lt;code&gt;PATH_MAX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="432adcaf916374b14ccc5f4491d7cd8a1e3d3e44" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;NODE&lt;/code&gt; or &lt;code&gt;Unexpected&lt;/code&gt; in files that have lines that match both.</source>
          <target state="translated">Ищет строку с &lt;code&gt;NODE&lt;/code&gt; или &lt;code&gt;Unexpected&lt;/code&gt; в файлах, в которых есть строки, соответствующие обоим.</target>
        </trans-unit>
        <trans-unit id="b11d66d44e8db145700e0edb6375620b652f740a" translate="yes" xml:space="preserve">
          <source>Low-level commands (plumbing)</source>
          <target state="translated">Команды низкого уровня (водопровод)</target>
        </trans-unit>
        <trans-unit id="0ffc3dae4e51a700bf1ca804b93845e0102810f8" translate="yes" xml:space="preserve">
          <source>Low-level git operations</source>
          <target state="translated">Низкоуровневые операции с гитами</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="5d487fc78e43a0306fd5f718aec828744ee6e786" translate="yes" xml:space="preserve">
          <source>M: modification of the contents or mode of a file</source>
          <target state="translated">М:изменение содержимого или режима файла</target>
        </trans-unit>
        <trans-unit id="0f48f030cf13414eeafe91359c3c62bf97314f35" translate="yes" xml:space="preserve">
          <source>Magic Options</source>
          <target state="translated">Волшебные варианты</target>
        </trans-unit>
        <trans-unit id="7d828d176880cf3ec5ec8010d93f54010eebda7b" translate="yes" xml:space="preserve">
          <source>Maildir splitting relies upon filenames being sorted to output patches in the correct order.</source>
          <target state="translated">Разделение Мейлдир основывается на сортировке имен файлов для вывода патчей в правильном порядке.</target>
        </trans-unit>
        <trans-unit id="57a6217babf3a984d54a72505b0f2a4f3e1be542" translate="yes" xml:space="preserve">
          <source>Main porcelain commands</source>
          <target state="translated">Главные фарфоровые команды</target>
        </trans-unit>
        <trans-unit id="46b62a0f964fab2f018eee342e7b4db44adbc685" translate="yes" xml:space="preserve">
          <source>Maintaining topic branches for a Linux subsystem maintainer</source>
          <target state="translated">Ведение тематических ветвей для сопровождающего подсистемы Linux</target>
        </trans-unit>
        <trans-unit id="52f0f393e457cb924c234a7254a4daec3a0cbf32" translate="yes" xml:space="preserve">
          <source>Maintenance branch management after a feature release</source>
          <target state="translated">Управление филиалами обслуживания после выпуска функции</target>
        </trans-unit>
        <trans-unit id="319909b05c9210e6ff8b8a19f69dc9189ee2cca4" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git gc --auto&lt;/code&gt; return immediately and run in background if the system supports it. Default is true.</source>
          <target state="translated">Сделайте так, чтобы &lt;code&gt;git gc --auto&lt;/code&gt; возвращался немедленно и запускался в фоновом режиме, если система это поддерживает. По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="77c42361d50b9bdea29b692160b9eae95cceb52e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git show-ref&lt;/code&gt; act as a filter that reads refs from stdin of the form &quot;&lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt;&quot; and performs the following actions on each: (1) strip &quot;^{}&quot; at the end of line if any; (2) ignore if pattern is provided and does not head-match refname; (3) warn if refname is not a well-formed refname and skip; (4) ignore if refname is a ref that exists in the local repository; (5) otherwise output the line.</source>
          <target state="translated">Сделайте &lt;code&gt;git show-ref&lt;/code&gt; фильтром, который считывает ссылки со стандартного ввода в форме &quot; &lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt; &quot; И выполняет следующие действия с каждым : (1) убрать &quot;^ {}&quot; в конце строки, если есть; (2) игнорировать, если указан шаблон и не соответствует заголовку refname; (3) предупреждать, если имя ссылки не является правильно сформированным именем ссылки, и пропускать; (4) игнорировать, если refname является ссылкой, которая существует в локальном репозитории; (5) в противном случае выведите строку.</target>
        </trans-unit>
        <trans-unit id="51befbcaeb5eba297db1a634b8802a7f0078cead" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git svn&lt;/code&gt; less verbose. Specify a second time to make it even less verbose.</source>
          <target state="translated">Сделайте &lt;code&gt;git svn&lt;/code&gt; менее подробным. Укажите второй раз, чтобы сделать его еще менее подробным.</target>
        </trans-unit>
        <trans-unit id="2da3bd3f8069e8e437af583aecc3a384c81edd34" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;bare&lt;/code&gt; Git repository. That is, instead of creating &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; and placing the administrative files in &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt;, make the &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; itself the &lt;code&gt;$GIT_DIR&lt;/code&gt;. This obviously implies the &lt;code&gt;--no-checkout&lt;/code&gt; because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to &lt;code&gt;refs/remotes/origin/&lt;/code&gt;. When this option is used, neither remote-tracking branches nor the related configuration variables are created.</source>
          <target state="translated">Сделать &lt;code&gt;bare&lt;/code&gt; репозиторий. То есть, вместо того чтобы создавать &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; и размещения административных файлов в &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt; , сделать &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; сам по &lt;code&gt;$GIT_DIR&lt;/code&gt; . Это, очевидно, подразумевает &lt;code&gt;--no-checkout&lt;/code&gt; , потому что некуда проверить рабочее дерево. Кроме того, главы веток на удаленном компьютере копируются непосредственно в соответствующие локальные главы веток, не отображая их в &lt;code&gt;refs/remotes/origin/&lt;/code&gt; . При использовании этой опции не создаются ни ветви удаленного отслеживания, ни соответствующие переменные конфигурации.</target>
        </trans-unit>
        <trans-unit id="6ca024f41825508ff37398849dd7bbbd184e78e6" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the default e-mail address&amp;rsquo;s key. The default behavior of tag GPG-signing is controlled by &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable if it exists, or disabled otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Сделайте тег, подписанный GPG, используя ключ адреса электронной почты по умолчанию. Поведение по умолчанию для подписи тега GPG контролируется &lt;code&gt;tag.gpgSign&lt;/code&gt; конфигурации tag.gpgSign, если она существует, или отключена в противном случае. См. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5a6f6bd2dfbdab5f143e86ea9155fad4e43a30c" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the given key.</source>
          <target state="translated">Сделайте тег,подписанный GPG,используя данный ключ.</target>
        </trans-unit>
        <trans-unit id="99f2296af5452e1eec1986dbc7a0151a5ba6b1fc" translate="yes" xml:space="preserve">
          <source>Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of &lt;code&gt;git commit&lt;/code&gt; if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with &lt;code&gt;--amend&lt;/code&gt;, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with &lt;code&gt;--allow-empty&lt;/code&gt; paths are also not required, and an empty commit will be created.</source>
          <target state="translated">Сделайте фиксацию, взяв обновленное содержимое рабочего дерева из путей, указанных в командной строке, игнорируя любое содержимое, которое было размещено для других путей. Это режим работы &lt;code&gt;git commit&lt;/code&gt; по умолчанию, если в командной строке указаны какие-либо пути, и в этом случае этот параметр можно опустить. Если этот параметр указан вместе с параметром &lt;code&gt;--amend&lt;/code&gt; , то пути указывать не нужно, которые можно использовать для внесения поправок в последнюю фиксацию без фиксации уже внесенных изменений. При использовании вместе с &lt;code&gt;--allow-empty&lt;/code&gt; пути также не требуются, и будет создана пустая фиксация.</target>
        </trans-unit>
        <trans-unit id="2e9bf6a1a9ac175346438fe9d4c19601601a0ebd" translate="yes" xml:space="preserve">
          <source>Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below).</source>
          <target state="translated">Составьте список коммитов,которые скоро будут возвращены.Позвольте пользователю отредактировать этот список перед перебазированием.Этот режим также может быть использован для разделения коммитов (см.ниже SPLITTING COMMITS).</target>
        </trans-unit>
        <trans-unit id="f382849103310ffba0e3d31128dfababfd915957" translate="yes" xml:space="preserve">
          <source>Make a local clone that borrows from the current directory, without checking things out:</source>
          <target state="translated">Сделайте локальный клон,который заимствует из текущего каталога,не проверяя вещи:</target>
        </trans-unit>
        <trans-unit id="d7a3e91b3667d18f363db6d6cc32c0afec1ed1d5" translate="yes" xml:space="preserve">
          <source>Make a side branch for every topic (feature, bugfix, &amp;hellip;​). Fork it off at the oldest integration branch that you will eventually want to merge it into.</source>
          <target state="translated">Сделайте боковую ветку для каждой темы (функция, исправление,&amp;hellip;). Разветвите его в самой старой ветке интеграции, с которой вы в конечном итоге захотите объединить ее.</target>
        </trans-unit>
        <trans-unit id="89db797c5d89c53349b8d88ec549bb720f48d1f7" translate="yes" xml:space="preserve">
          <source>Make an unsigned, annotated tag object</source>
          <target state="translated">Сделать неподписанный,аннотированный тег объекта</target>
        </trans-unit>
        <trans-unit id="f88ecf2f4eb0c5509c792cd2c61ea44a524baf96" translate="yes" xml:space="preserve">
          <source>Make corrections to working tree files.</source>
          <target state="translated">Внести исправления в рабочие файлы дерева.</target>
        </trans-unit>
        <trans-unit id="79ee7beb56d7493ce335c85dd0a8333674bff17b" translate="yes" xml:space="preserve">
          <source>Make git-send-email less verbose. One line per email should be all that is output.</source>
          <target state="translated">Сделать гит-сенд-эмейл менее многословным.Одна строка на электронную почту должна быть всем,что выводится.</target>
        </trans-unit>
        <trans-unit id="ff429cc18c1dac972928cb3da6e4d06bbfe2d8ec" translate="yes" xml:space="preserve">
          <source>Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.</source>
          <target state="translated">Сделайте один коммит и вернитесь в оболочку,когда она будет завершена.Эта команда возвращает ненулевой код выхода,если окно было закрыто каким-либо другим способом,кроме как с помощью коммита.</target>
        </trans-unit>
        <trans-unit id="31ca9c9bf3eab94aff99250728fe74f77977b844" translate="yes" xml:space="preserve">
          <source>Make sure Git knows who to blame:</source>
          <target state="translated">Убедись,что Гит знает,кого винить:</target>
        </trans-unit>
        <trans-unit id="cf12b54cc8063982ae2c9b96588de4f236c9e743" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;.</source>
          <target state="translated">Убедитесь, что все коммиты подмодулей, используемые отправляемыми ревизиями, доступны в ветви удаленного отслеживания. Если установлено значение &lt;code&gt;check&lt;/code&gt; , Git проверит, что все коммиты подмодуля, измененные в отправляемых ревизиях, доступны по крайней мере на одном удаленном подмодуле. Если какие-либо коммиты отсутствуют, push будет прерван и завершится с ненулевым статусом. Если значение задано &lt;code&gt;on-demand&lt;/code&gt; то все подмодули, которые изменились в ревизиях, которые нужно отправить, будут отправлены. Если по запросу не удалось отправить все необходимые изменения, он также будет прерван и выйдет с ненулевым статусом. Если значение равно &amp;laquo; &lt;code&gt;no&lt;/code&gt; то поведение по умолчанию - игнорирование подмодулей при нажатии - сохраняется. Вы можете переопределить эту конфигурацию во время отправки, указав &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70b6629c434b51e7d9186d1fc6fe97c1a3725440" translate="yes" xml:space="preserve">
          <source>Make sure committers have a umask of at most 027, so that the directories they create are writable and searchable by other group members.</source>
          <target state="translated">Убедитесь,что у коммиттеров есть маска не более 027,чтобы создаваемые ими каталоги были доступны для записи и поиска другими членами группы.</target>
        </trans-unit>
        <trans-unit id="4b35196a3d616941ad0c8a125c3a9f25e1bdc376" translate="yes" xml:space="preserve">
          <source>Make sure this directory is available for others you want your changes to be pulled via the transport of your choice. Also you need to make sure that you have the &lt;code&gt;git-receive-pack&lt;/code&gt; program on the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">Убедитесь, что этот каталог доступен для других, вы хотите, чтобы ваши изменения были извлечены с помощью выбранного вами транспорта. Также вам нужно убедиться, что у вас есть программа &lt;code&gt;git-receive-pack&lt;/code&gt; в &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6631b9ca24ae751d7ee25163002526a066325c25" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given &amp;lt;message id&amp;gt;, which avoids breaking threads to provide a new patch series.</source>
          <target state="translated">Сделайте так, чтобы первое письмо (или все сообщения с &lt;code&gt;--no-thread&lt;/code&gt; ) отображалось как ответ на заданный &amp;lt;идентификатор сообщения&amp;gt;, что позволяет избежать прерывания потоков для предоставления новой серии исправлений.</target>
        </trans-unit>
        <trans-unit id="5a1ce0ecb5c94a2505e8bfd1950281f48170d98f" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given Message-Id, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; setting.</source>
          <target state="translated">Сделать так, чтобы первое сообщение (или все сообщения с &lt;code&gt;--no-thread&lt;/code&gt; ) отображалось как ответ на заданный идентификатор сообщения, что позволяет избежать прерывания потоков для предоставления новой серии исправлений. Второе и последующие электронные письма будут отправлены как ответы в соответствии &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; настройкой - [no-] chain-reply-to .</target>
        </trans-unit>
        <trans-unit id="b064d6e8766baf86355fa160624701d28d48e0eb" translate="yes" xml:space="preserve">
          <source>Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.</source>
          <target state="translated">Выход из программы с кодами,аналогичными diff(1).То есть она выходит с 1,если были различия,а 0 означает отсутствие различий.</target>
        </trans-unit>
        <trans-unit id="033698ff1d93839c9dc26bb7039e879974408d51" translate="yes" xml:space="preserve">
          <source>Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is &lt;code&gt;0022&lt;/code&gt;, using &lt;code&gt;group&lt;/code&gt; will not remove read privileges from other (non-group) users). See &lt;code&gt;0xxx&lt;/code&gt; for how to exactly specify the repository permissions.</source>
          <target state="translated">Сделайте группу репозитория доступной для записи (и g + sx, поскольку группа git может не быть основной группой для всех пользователей). Это используется для ослабления разрешений в противном случае безопасного значения umask (2). Обратите внимание, что umask по-прежнему применяется к другим битам разрешений (например, если umask равен &lt;code&gt;0022&lt;/code&gt; , использование &lt;code&gt;group&lt;/code&gt; не приведет к удалению привилегий чтения у других (не входящих в группу) пользователей). См. &lt;code&gt;0xxx&lt;/code&gt; , чтобы узнать, как точно указать разрешения для репозитория.</target>
        </trans-unit>
        <trans-unit id="daa563a54f59f3d95749377d0e4af4c611fecd18" translate="yes" xml:space="preserve">
          <source>Making a change</source>
          <target state="translated">Изменение</target>
        </trans-unit>
        <trans-unit id="9aef7fbf27451a8c36fe7bf7a109aea9540e01ca" translate="yes" xml:space="preserve">
          <source>Making changes</source>
          <target state="translated">Внесение изменений</target>
        </trans-unit>
        <trans-unit id="992a7beb5615876037da9b0e5b4a3e7c21af51d8" translate="yes" xml:space="preserve">
          <source>Making some changes to the working directory using your favorite editor.</source>
          <target state="translated">Внесение некоторых изменений в рабочий каталог с помощью любимого редактора.</target>
        </trans-unit>
        <trans-unit id="bf4919466a0f70dfd02acc3627e75ad16a05f620" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees</source>
          <target state="translated">Управление несколькими рабочими деревьями</target>
        </trans-unit>
        <trans-unit id="6ec4a25401fa228522c7be97da233480069758e8" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees attached to the same repository.</source>
          <target state="translated">Управлять несколькими рабочими деревьями,прикрепленными к одному и тому же репозиторию.</target>
        </trans-unit>
        <trans-unit id="5f089a6eb7f251a9a2fe0a3f833141f8db37c3ff" translate="yes" xml:space="preserve">
          <source>Manage reflog information</source>
          <target state="translated">Управление информацией рефлога</target>
        </trans-unit>
        <trans-unit id="021ab6f7ef8793b1b816ea4bdd5e727ce06994e0" translate="yes" xml:space="preserve">
          <source>Manage set of tracked repositories</source>
          <target state="translated">Управление набором отслеживаемых репозиториев</target>
        </trans-unit>
        <trans-unit id="65f908ba554d3d8c75571c008e2b6e59e8585d63" translate="yes" xml:space="preserve">
          <source>Manage the serialized commit-graph file.</source>
          <target state="translated">Управление сериализованным файлом коммит-графика.</target>
        </trans-unit>
        <trans-unit id="4a3e0eed31d02104159aa0bed6d5acb0e05768b8" translate="yes" xml:space="preserve">
          <source>Manage the set of repositories (&quot;remotes&quot;) whose branches you track.</source>
          <target state="translated">Управляйте набором репозиториев (&quot;пультов&quot;),ветки которых вы отслеживаете.</target>
        </trans-unit>
        <trans-unit id="3507e0027b822825db37aad1b6a1e0779dcd0d96" translate="yes" xml:space="preserve">
          <source>Managing branches</source>
          <target state="translated">Управляющие филиалы</target>
        </trans-unit>
        <trans-unit id="279735249dbe3dcc024592a529bd9cb39b1b8496" translate="yes" xml:space="preserve">
          <source>Manipulate the notes tree in &amp;lt;ref&amp;gt;. This overrides &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; and the &quot;core.notesRef&quot; configuration. The ref specifies the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">Управляйте деревом заметок в &amp;lt;ref&amp;gt;. Это отменяет &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; и конфигурацию core.notesRef. Ссылка указывает полное имя ссылки, когда она начинается с &lt;code&gt;refs/notes/&lt;/code&gt; ; когда он начинается с &lt;code&gt;notes/&lt;/code&gt; , &lt;code&gt;refs/&lt;/code&gt; и в противном случае &lt;code&gt;refs/notes/&lt;/code&gt; имеет префикс, чтобы сформировать полное имя ссылки.</target>
        </trans-unit>
        <trans-unit id="ad0e6ab545d99b4fca1e842f2d64e34b5bf6ca91" translate="yes" xml:space="preserve">
          <source>Manipulating branches</source>
          <target state="translated">Манипулирующие ветви</target>
        </trans-unit>
        <trans-unit id="e163593ceb018ccfe91e5474069f8880c01bf32f" translate="yes" xml:space="preserve">
          <source>Manipulation commands</source>
          <target state="translated">Команды манипулирования</target>
        </trans-unit>
        <trans-unit id="a4c79f29e9d9d5fa1534359d2910523c3bd41716" translate="yes" xml:space="preserve">
          <source>Manipulators:</source>
          <target state="translated">Manipulators:</target>
        </trans-unit>
        <trans-unit id="2d6fc489721f7990b3e0a46d8dbd0fae7613420d" translate="yes" xml:space="preserve">
          <source>Many (most?) public remote repositories will not contain any of the checked out files or even an index file, and will &lt;strong&gt;only&lt;/strong&gt; contain the actual core Git files. Such a repository usually doesn&amp;rsquo;t even have the &lt;code&gt;.git&lt;/code&gt; subdirectory, but has all the Git files directly in the repository.</source>
          <target state="translated">Многие (большинство?) Общедоступных удаленных репозиториев не будут содержать никаких извлеченных файлов или даже индексного файла, а будут содержать &lt;strong&gt;только&lt;/strong&gt; фактические файлы ядра Git. В таком репозитории обычно даже нет подкаталога &lt;code&gt;.git&lt;/code&gt; , но все файлы Git находятся непосредственно в репозитории.</target>
        </trans-unit>
        <trans-unit id="23a4d8d6b8951ee492fd478361a461e34445c192" translate="yes" xml:space="preserve">
          <source>Many Git commands also take sets of commits, which can be specified in a number of ways. Here are some examples with &lt;code&gt;git log&lt;/code&gt;:</source>
          <target state="translated">Многие команды Git также принимают наборы коммитов, которые можно указать разными способами. Вот несколько примеров с &lt;code&gt;git log&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb5f624f4f524730b1dad471a4cc62df1265c105" translate="yes" xml:space="preserve">
          <source>Many Git commands take revision parameters as arguments. Depending on the command, they denote a specific commit or, for commands which walk the revision graph (such as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;), all commits which are reachable from that commit. For commands that walk the revision graph one can also specify a range of revisions explicitly.</source>
          <target state="translated">Многие команды Git принимают параметры редакции в качестве аргументов. В зависимости от команды они обозначают конкретную фиксацию или, для команд, которые проходят по графу ревизий (например, &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; ), все коммиты, доступные из этой фиксации. Для команд, которые проходят по графу ревизий, можно также явно указать диапазон ревизий.</target>
        </trans-unit>
        <trans-unit id="8eadff7d5c23284bf3e40779cca1324c9880e38b" translate="yes" xml:space="preserve">
          <source>Many Git porcelainish commands take mixture of flags (i.e. parameters that begin with a dash &lt;code&gt;-&lt;/code&gt;) and parameters meant for the underlying &lt;code&gt;git rev-list&lt;/code&gt; command they use internally and flags and parameters for the other commands they use downstream of &lt;code&gt;git rev-list&lt;/code&gt;. This command is used to distinguish between them.</source>
          <target state="translated">Многие фарфоровые команды Git принимают сочетание флагов (т.е. параметров, начинающихся с тире &lt;code&gt;-&lt;/code&gt; ) и параметров, предназначенных для базовой команды &lt;code&gt;git rev-list&lt;/code&gt; ,которую они используют внутри, а также флагов и параметров для других команд, которые они используют ниже по течению от &lt;code&gt;git rev-list&lt;/code&gt; . Эта команда используется, чтобы различать их.</target>
        </trans-unit>
        <trans-unit id="07f9a7fabb84ff55c93b5220c84bc1016373588c" translate="yes" xml:space="preserve">
          <source>Many command-line options can be provided as part of the fast-import stream itself by using the &lt;code&gt;feature&lt;/code&gt; or &lt;code&gt;option&lt;/code&gt; commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line. This currently impacts only the &lt;code&gt;export-marks&lt;/code&gt;, &lt;code&gt;import-marks&lt;/code&gt;, and &lt;code&gt;import-marks-if-exists&lt;/code&gt; feature commands.</source>
          <target state="translated">Многие параметры командной строки могут быть предоставлены как часть самого потока быстрого импорта с помощью команд &lt;code&gt;feature&lt;/code&gt; или &lt;code&gt;option&lt;/code&gt; . Однако некоторые из этих параметров небезопасны (например, разрешение быстрого импорта для доступа к файловой системе за пределами репозитория). По умолчанию эти параметры отключены, но их можно разрешить, указав этот параметр в командной строке. В настоящее время это влияет только на команды функций &lt;code&gt;export-marks&lt;/code&gt; , &lt;code&gt;import-marks&lt;/code&gt; и &lt;code&gt;import-marks-if-exists&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b810424b3fea997d54a1c6f50a7ffa7b2bdf31cc" translate="yes" xml:space="preserve">
          <source>Many commands allow wildcards in paths, but you need to protect them from getting globbed by the shell. These two mean different things:</source>
          <target state="translated">Многие команды позволяют использовать подстановочные знаки на дорожках,но необходимо защитить их от засорения оболочкой.Эти две вещи означают разные вещи:</target>
        </trans-unit>
        <trans-unit id="f769735173b4b17536b3bddf331e35fc94c1f6c2" translate="yes" xml:space="preserve">
          <source>Many commands take revisions (most often &quot;commits&quot;, but sometimes &quot;tree-ish&quot;, depending on the context and command) and paths as their arguments. Here are the rules:</source>
          <target state="translated">Многие команды принимают в качестве аргументов ревизии (чаще всего &quot;коммиты&quot;,но иногда &quot;древовидные&quot;,в зависимости от контекста и команды)и пути.Вот правила:</target>
        </trans-unit>
        <trans-unit id="51a04d163df59d3e4e585f46784dd69c625e4feb" translate="yes" xml:space="preserve">
          <source>Many commands that can work on files in the working tree and/or in the index can take &lt;code&gt;--cached&lt;/code&gt; and/or &lt;code&gt;--index&lt;/code&gt; options. Sometimes people incorrectly think that, because the index was originally called cache, these two are synonyms. They are &lt;strong&gt;not&lt;/strong&gt; &amp;mdash; these two options mean very different things.</source>
          <target state="translated">Многие команды, которые могут работать с файлами в рабочем дереве и / или в индексе, могут принимать параметры &lt;code&gt;--cached&lt;/code&gt; и / или &lt;code&gt;--index&lt;/code&gt; . Иногда люди ошибочно думают, что, поскольку индекс изначально назывался кешем, эти два слова являются синонимами. Это &lt;strong&gt;не так&lt;/strong&gt; - эти два варианта означают очень разные вещи.</target>
        </trans-unit>
        <trans-unit id="41a419d79cd72b9d54b27ecee9672655c35e91cc" translate="yes" xml:space="preserve">
          <source>Many gitweb features can be enabled (or disabled) and configured using the &lt;code&gt;%feature&lt;/code&gt; hash. Names of gitweb features are keys of this hash.</source>
          <target state="translated">Многие функции gitweb можно включить (или отключить) и настроить с помощью хэша &lt;code&gt;%feature&lt;/code&gt; . Имена функций gitweb являются ключами этого хэша.</target>
        </trans-unit>
        <trans-unit id="919a2ac82af6ff1bc82b2171d1abca264db10f6e" translate="yes" xml:space="preserve">
          <source>Many installations of sshd do not invoke your shell as the login shell when you directly run programs; what this means is that if your login shell is &lt;em&gt;bash&lt;/em&gt;, only &lt;code&gt;.bashrc&lt;/code&gt; is read and not &lt;code&gt;.bash_profile&lt;/code&gt;. As a workaround, make sure &lt;code&gt;.bashrc&lt;/code&gt; sets up &lt;code&gt;$PATH&lt;/code&gt; so that you can run &lt;em&gt;git-receive-pack&lt;/em&gt; program.</source>
          <target state="translated">Многие установки sshd не вызывают вашу оболочку как оболочку входа в систему, когда вы напрямую запускаете программы; это означает, что если ваша оболочка входа - &lt;em&gt;bash&lt;/em&gt; , читается только &lt;code&gt;.bashrc&lt;/code&gt; , а не &lt;code&gt;.bash_profile&lt;/code&gt; . В качестве обходного пути убедитесь, что &lt;code&gt;.bashrc&lt;/code&gt; устанавливает &lt;code&gt;$PATH&lt;/code&gt; чтобы вы могли запустить программу &lt;em&gt;git-receive-pack&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b683891958210e2ee979b3e8c7ad10f12997dda2" translate="yes" xml:space="preserve">
          <source>Many mailers if not set up properly will corrupt whitespace. Here are two common types of corruption:</source>
          <target state="translated">Многие почтовые программы при неправильной настройке повреждают пробельные символы.Вот два распространённых типа коррупции:</target>
        </trans-unit>
        <trans-unit id="193dde6b7f3a20700543ed6450f24935f7b33dfa" translate="yes" xml:space="preserve">
          <source>Many of the higher-level commands were originally implemented as shell scripts using a smaller core of low-level Git commands. These can still be useful when doing unusual things with Git, or just as a way to understand its inner workings.</source>
          <target state="translated">Многие команды более высокого уровня были изначально реализованы в виде скриптов оболочки,использующих меньшее ядро низкоуровневых команд Git'а.Они всё ещё могут быть полезны при работе с Git'ом,или просто как способ понять его внутреннюю работу.</target>
        </trans-unit>
        <trans-unit id="3d6c28c55f8170d273c49f3e427a981c665cf6ea" translate="yes" xml:space="preserve">
          <source>Many operations in Git depend on your filesystem to have an efficient &lt;code&gt;lstat(2)&lt;/code&gt; implementation, so that &lt;code&gt;st_mtime&lt;/code&gt; information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file. Unfortunately, some filesystems have inefficient &lt;code&gt;lstat(2)&lt;/code&gt;. If your filesystem is one of them, you can set &quot;assume unchanged&quot; bit to paths you have not changed to cause Git not to do this check. Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed &amp;mdash; it makes Git to omit any checking and assume it has &lt;strong&gt;not&lt;/strong&gt; changed. When you make changes to working tree files, you have to explicitly tell Git about it by dropping &quot;assume unchanged&quot; bit, either before or after you modify them.</source>
          <target state="translated">Многие операции в Git зависят от вашей файловой системы, чтобы иметь эффективную реализацию &lt;code&gt;lstat(2)&lt;/code&gt; , поэтому информацию &lt;code&gt;st_mtime&lt;/code&gt; для рабочих файлов дерева можно дешево проверить, чтобы увидеть, изменилось ли содержимое файла по сравнению с версией, записанной в индексном файле. К сожалению, в некоторых файловых системах &lt;code&gt;lstat(2)&lt;/code&gt; неэффективен . Если ваша файловая система является одной из них, вы можете установить бит &amp;laquo;считать неизменным&amp;raquo; для путей, которые вы не изменили, чтобы Git не выполнял эту проверку. Обратите внимание, что установка этого бита в пути не означает, что Git проверит содержимое файла, чтобы узнать, не изменилось ли оно - это заставляет Git пропускать любую проверку и предполагать, что это &lt;strong&gt;не так.&lt;/strong&gt;изменилось. Когда вы вносите изменения в файлы рабочего дерева, вы должны явно сообщить об этом Git, отбросив бит &amp;laquo;считать неизменным&amp;raquo; до или после их изменения.</target>
        </trans-unit>
        <trans-unit id="a799d1cceae5d3b6566df7c502b0ed31229cf195" translate="yes" xml:space="preserve">
          <source>Many revision control systems provide an &lt;code&gt;add&lt;/code&gt; command that tells the system to start tracking changes to a new file. Git&amp;rsquo;s &lt;code&gt;add&lt;/code&gt; command does something simpler and more powerful: &lt;code&gt;git add&lt;/code&gt; is used both for new and newly modified files, and in both cases it takes a snapshot of the given files and stages that content in the index, ready for inclusion in the next commit.</source>
          <target state="translated">Многие системы контроля версий предоставляют команду &lt;code&gt;add&lt;/code&gt; которая сообщает системе, что нужно начать отслеживание изменений в новом файле. Команда Git &lt;code&gt;add&lt;/code&gt; делает что-то более простое и мощное: &lt;code&gt;git add&lt;/code&gt; используется как для новых, так и для вновь измененных файлов, и в обоих случаях он делает снимок данных файлов и помещает это содержимое в индекс, готовое для включения в следующую фиксацию.</target>
        </trans-unit>
        <trans-unit id="f4ad3aa56684a237b2a48778413d62e45b68868b" translate="yes" xml:space="preserve">
          <source>Many tags. Will create a tag for every commit, reflecting the commit name in the Arch repository.</source>
          <target state="translated">Много меток.Создает метку для каждого коммита,отражающую имя коммита в репозитории Архива.</target>
        </trans-unit>
        <trans-unit id="6b4939f173ca46ae5e70f2a578215c85acafb3ce" translate="yes" xml:space="preserve">
          <source>Many thanks to Ingo Molnar for giving me very useful information that appears in this paper, for commenting on this paper, for his suggestions to improve &quot;git bisect&quot; and for evangelizing &quot;git bisect&quot; on the linux kernel mailing lists.</source>
          <target state="translated">Большое спасибо Инго Молнару за то,что дал мне очень полезную информацию,которая появилась в этой статье,за комментарии к этой статье,за его предложения по улучшению &quot;git-бисекта&quot; и за евангелизацию &quot;git-бисекта&quot; в списках рассылки ядра linux.</target>
        </trans-unit>
        <trans-unit id="5bd4feea472ac1f81e9eed337015c1647da376b9" translate="yes" xml:space="preserve">
          <source>Many thanks to Junio Hamano for his help in reviewing this paper, for reviewing the patches I sent to the Git mailing list, for discussing some ideas and helping me improve them, for improving &quot;git bisect&quot; a lot and for his awesome work in maintaining and developing Git.</source>
          <target state="translated">Большое спасибо Хунио Хамано за его помощь в рецензировании этой статьи,за рецензию на патчи,которые я отправил в список рассылки Git'а,за обсуждение некоторых идей и помощь в их улучшении,за то,что он много улучшил &quot;git-бисект&quot; и за его потрясающую работу по поддержке и развитию Git'а.</target>
        </trans-unit>
        <trans-unit id="a308e878405ccac0452dc3a943e6c4f471d0d0f3" translate="yes" xml:space="preserve">
          <source>Many thanks to Linus Torvalds for inventing, developing and evangelizing &quot;git bisect&quot;, Git and Linux.</source>
          <target state="translated">Большое спасибо Линусу Торвальдсу за изобретение,разработку и евангелизацию &quot;git-бисекта&quot;,Git и Linux.</target>
        </trans-unit>
        <trans-unit id="64e052904657c30a32be467111b38e2db70890d3" translate="yes" xml:space="preserve">
          <source>Many thanks to the Linux-Kongress program committee for choosing the author to given a talk and for publishing this paper.</source>
          <target state="translated">Большое спасибо программному комитету Linux-Kongress за выбор автора для выступления и за публикацию этой статьи.</target>
        </trans-unit>
        <trans-unit id="a813e2d801820a3507d225cfe410c73c1e3814a5" translate="yes" xml:space="preserve">
          <source>Many thanks to the many other great people who helped one way or another when I worked on Git, especially to Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour.</source>
          <target state="translated">Большое спасибо многим другим великим людям,которые так или иначе помогали мне,когда я работал над Git,особенно Андреасу Эрикссону,Иоганнесу Шинделину,Х.Питеру Анвину,Дэниэлу Баркалоу,Биллу Лиру,Джону Хоули,Шону О.Пирсу,Джеффу Кингу,Сэму Вилайну,Джону Сеймуру.</target>
        </trans-unit>
        <trans-unit id="970bd5edbccf4926f346f36ced29b782ff134b0f" translate="yes" xml:space="preserve">
          <source>Many things can then be done very naturally:</source>
          <target state="translated">Тогда многие вещи можно делать очень естественно:</target>
        </trans-unit>
        <trans-unit id="08ed471839ae0d35cbf114cdc8b4fb025451ea78" translate="yes" xml:space="preserve">
          <source>Map a P4 user to a name and email address in Git. Use a string with the following format to create a mapping:</source>
          <target state="translated">Свяжите пользователя P4 с именем и адресом электронной почты в Git'е.Для создания карты используйте строку следующего формата:</target>
        </trans-unit>
        <trans-unit id="84e3b6902de1ae94c28d951dff280df12bc818fa" translate="yes" xml:space="preserve">
          <source>Mapping authors</source>
          <target state="translated">Авторы карт</target>
        </trans-unit>
        <trans-unit id="ecca08ad6644372b493b29196801e0262451ee0a" translate="yes" xml:space="preserve">
          <source>Mapping between Subversion revision numbers and Git commit names. In a repository where the noMetadata option is not set, this can be rebuilt from the git-svn-id: lines that are at the end of every commit (see the &lt;code&gt;svn.noMetadata&lt;/code&gt; section above for details).</source>
          <target state="translated">Сопоставление номеров ревизий Subversion и имен коммитов Git. В репозитории, где параметр noMetadata не установлен, его можно перестроить из строк git-svn-id: в конце каждой фиксации (подробности см. &lt;code&gt;svn.noMetadata&lt;/code&gt; разделе svn.noMetadata выше).</target>
        </trans-unit>
        <trans-unit id="f80c6e32aadbd525747e2562fb58002684c64ae1" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we attributed to another commit with a &lt;code&gt;?&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">Отметьте строки, которые были изменены проигнорированной ревизией, которую мы приписали другой фиксации, знаком &lt;code&gt;?&lt;/code&gt; в выводе &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a93a83bc77d4e299bb423ede0b0e7523360c05" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we could not attribute to another commit with a &lt;code&gt;*&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">Отметьте строки, которые были изменены проигнорированной ревизией, которую мы не могли отнести к другой фиксации, знаком &lt;code&gt;*&lt;/code&gt; в выводе &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ffa04a5e9e510ce8e8a9af22652c96cb5f2a2455" translate="yes" xml:space="preserve">
          <source>Mark the commit you want to split with the action &quot;edit&quot;.</source>
          <target state="translated">Отметьте коммит,который вы хотите разделить,действием &quot;редактировать&quot;.</target>
        </trans-unit>
        <trans-unit id="9ad05336158823a7d5e9d2740631e3ed3e7b77cc" translate="yes" xml:space="preserve">
          <source>Mark the series as the &amp;lt;n&amp;gt;-th iteration of the topic. The output filenames have &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; prepended to them, and the subject prefix (&quot;PATCH&quot; by default, but configurable via the &lt;code&gt;--subject-prefix&lt;/code&gt; option) has ` v&amp;lt;n&amp;gt;` appended to it. E.g. &lt;code&gt;--reroll-count=4&lt;/code&gt; may produce &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; file that has &quot;Subject: [PATCH v4 1/20] Add makefile&quot; in it.</source>
          <target state="translated">Отметьте серию как &amp;lt;n&amp;gt; -ю итерацию темы. К выходным именам файлов добавляется &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; , а к префиксу темы (по умолчанию &quot;PATCH&quot;, но можно настроить с помощью параметра &lt;code&gt;--subject-prefix&lt;/code&gt; ) добавлено `v &amp;lt;n&amp;gt;`. Например, &lt;code&gt;--reroll-count=4&lt;/code&gt; может создать &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; , содержащий &amp;laquo;Тема: [PATCH v4 1/20] Добавить makefile&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="eb02cc756d5e31341021dd6b9e08120c18cfff12" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with &lt;code&gt;&amp;lt;&lt;/code&gt; and those from the right with &lt;code&gt;&amp;gt;&lt;/code&gt;. If combined with &lt;code&gt;--boundary&lt;/code&gt;, those commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">Отметьте, с какой стороны симметричной разницы доступна фиксация. Коммиты с левой стороны имеют префикс &lt;code&gt;&amp;lt;&lt;/code&gt; , а коммиты справа - &lt;code&gt;&amp;gt;&lt;/code&gt; . В сочетании с &lt;code&gt;--boundary&lt;/code&gt; эти коммиты имеют префикс &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf65e398a783b020004a05bc4b12965bd321675" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with a &lt;code&gt;&amp;lt;&lt;/code&gt; symbol and those from the right with a &lt;code&gt;&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">Отметьте, с какой стороны симметричной разницы доступна фиксация. Коммиты с левой стороны имеют префикс &lt;code&gt;&amp;lt;&lt;/code&gt; символа, а коммиты справа - с символом &lt;code&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d120d1dcfa9af04a37a29923ad102f9ac75edbe0" translate="yes" xml:space="preserve">
          <source>Marking files as binary</source>
          <target state="translated">Файлы с маркировкой как двоичные</target>
        </trans-unit>
        <trans-unit id="3549e52dba075c1ca63de7856965a26fd121848f" translate="yes" xml:space="preserve">
          <source>Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes, depending on pointer size) per mark. Although the array is sparse, frontends are still strongly encouraged to use marks between 1 and n, where n is the total number of marks required for this import.</source>
          <target state="translated">Марки хранятся в разреженном массиве,используя 1 указатель (4 байта или 8 байт,в зависимости от размера указателя)на марку.Несмотря на то,что массив разрежен,на фронтах все же настоятельно рекомендуется использовать метки от 1 до n,где n-это общее количество меток,требуемое для данного импорта.</target>
        </trans-unit>
        <trans-unit id="c020b534de76a3110681e8b3a1131c198a04e4dd" translate="yes" xml:space="preserve">
          <source>Marks must be declared (via &lt;code&gt;mark&lt;/code&gt;) before they can be used.</source>
          <target state="translated">Знаки должны быть заявлены (через &lt;code&gt;mark&lt;/code&gt; ), прежде чем они могут быть использованы.</target>
        </trans-unit>
        <trans-unit id="e23875af098ed58ac7ddbf626ebbfd55b3530c2d" translate="yes" xml:space="preserve">
          <source>Marks the end of the stream. This command is optional unless the &lt;code&gt;done&lt;/code&gt; feature was requested using the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command.</source>
          <target state="translated">Обозначает конец потока. Эта команда является необязательной, если только функция &lt;code&gt;done&lt;/code&gt; не была запрошена с помощью &lt;code&gt;--done&lt;/code&gt; командной строки --done или команды &lt;code&gt;feature done&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd5e3d7525f7c72ed149669f4682e8cf2613e2e" translate="yes" xml:space="preserve">
          <source>Match paths exactly (i.e. don&amp;rsquo;t allow &quot;/foo/repo&quot; when the real path is &quot;/foo/repo.git&quot; or &quot;/foo/repo/.git&quot;) and don&amp;rsquo;t do user-relative paths. &lt;code&gt;git daemon&lt;/code&gt; will refuse to start when this option is enabled and no whitelist is specified.</source>
          <target state="translated">Точное соответствие путей (т.е. не разрешать &quot;/ foo / repo&quot;, когда реальный путь - &quot;/foo/repo.git&quot; или &quot;/foo/repo/.git&quot;) и не использовать пути, относящиеся к пользователю. &lt;code&gt;git daemon&lt;/code&gt; откажется запускаться, если этот параметр включен и белый список не указан.</target>
        </trans-unit>
        <trans-unit id="1c5cb990d5ea569aee72e359a127ac5dd4a253ea" translate="yes" xml:space="preserve">
          <source>Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character).</source>
          <target state="translated">Подходит образец только на границе слова (либо начинается в начале строки,либо перед ним стоит несловной символ;заканчивается в конце строки или за ним следует несловной символ).</target>
        </trans-unit>
        <trans-unit id="ca182a2e7bbbd5ec9c62eec976529a0aa078540e" translate="yes" xml:space="preserve">
          <source>Match the regular expression limiting patterns without regard to letter case.</source>
          <target state="translated">Выберите регулярное выражение,ограничивающее шаблон,безотносительно регистра букв.</target>
        </trans-unit>
        <trans-unit id="1452c4b1c4eed7c80174fb8c82a8ed6f95d98c4d" translate="yes" xml:space="preserve">
          <source>Maximum delta depth, for blob and tree deltification. Default is 50.</source>
          <target state="translated">Максимальная глубина дельты,для отслоения капель и деревьев.По умолчанию 50.</target>
        </trans-unit>
        <trans-unit id="384f40abc20254795ab29a564353f53402412c1e" translate="yes" xml:space="preserve">
          <source>Maximum number of branches to maintain active at once. See &amp;ldquo;Memory Utilization&amp;rdquo; below for details. Default is 5.</source>
          <target state="translated">Максимальное количество ветвей, которые нужно поддерживать активными одновременно. Подробнее см. &amp;laquo;Использование памяти&amp;raquo; ниже. По умолчанию 5.</target>
        </trans-unit>
        <trans-unit id="5ba691ad2489c6a98bfddfb725c399a5433235ec" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to map simultaneously into memory from pack files. If Git needs to access more than this many bytes at once to complete an operation it will unmap existing regions to reclaim virtual address space within the process.</source>
          <target state="translated">Максимальное количество байт для одновременного отображения в память из пакетных файлов.Если для выполнения операции Git'у потребуется доступ к более чем этому количеству байт одновременно,то он распаковывает существующие регионы для восстановления виртуального адресного пространства в процессе работы.</target>
        </trans-unit>
        <trans-unit id="015780ae5eaf5a16460a6c6f6a47f9fd68665f6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="translated">Максимальное количество байтов,которое может быть зарезервировано для кэширования базовых объектов,на которые могут ссылаться несколько расслоенных объектов.Храня все распакованные базовые объекты в кэше,Git может избежать распаковки и распаковки часто используемых базовых объектов несколько раз.</target>
        </trans-unit>
        <trans-unit id="9639a9871e3fa301072f34b62bd6d8d1df5dfde8" translate="yes" xml:space="preserve">
          <source>Maximum number of concurrent clients, defaults to 32. Set it to zero for no limit.</source>
          <target state="translated">Максимальное количество одновременных клиентов,по умолчанию 32.Установите ноль без ограничения.</target>
        </trans-unit>
        <trans-unit id="3fca64028c3b9d66663fb33bbabf381bdeaeb020" translate="yes" xml:space="preserve">
          <source>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB, which is sufficient for most requests.</source>
          <target state="translated">Максимальный размер в байтах буфера,используемого умными HTTP-транспортами при POSTing данных в удаленную систему.Для запросов размером больше этого буфера,HTTP/1.1 и Transfer-Encoding:используется chunked,чтобы избежать локального создания массивного пакетного файла.По умолчанию 1 Мб,что достаточно для большинства запросов.</target>
        </trans-unit>
        <trans-unit id="d63005f2c2b8f8c3239933e10d80e78d75fee39e" translate="yes" xml:space="preserve">
          <source>Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes. The default is 512m (512 MiB). Some importers may wish to lower this on systems with constrained memory.</source>
          <target state="translated">Максимальный размер блока,который быстро импортируется,будет пытаться создать дельту для,выраженную в байтах.По умолчанию 512 м (512 Мб).Некоторые импортеры могут захотеть снизить его на системах с ограниченной памятью.</target>
        </trans-unit>
        <trans-unit id="d3dd84835c1a4e2de21619e12a6eaaff0c2d1fd8" translate="yes" xml:space="preserve">
          <source>Maximum size of each output pack file. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">Максимальный размер каждого файла выходного пакета. Размер может быть дополнен суффиксами &amp;laquo;k&amp;raquo;, &amp;laquo;m&amp;raquo; или &amp;laquo;g&amp;raquo;. Минимальный допустимый размер ограничен 1 МиБ. Если указано, может быть создано несколько файлов пакетов, что также предотвращает создание индекса битовой карты. По умолчанию не ограничено, если не установлена ​​переменная конфигурации &lt;code&gt;pack.packSizeLimit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8685db9c67d15fcb99750ad6a0c6f6dc3e27c92" translate="yes" xml:space="preserve">
          <source>Maximum size of each output packfile. The default is unlimited.</source>
          <target state="translated">Максимальный размер каждого выходного файла пакета.По умолчанию неограничен.</target>
        </trans-unit>
        <trans-unit id="ecff084a0c01e319db62c5b088c7a98c5cc26a2a" translate="yes" xml:space="preserve">
          <source>May be an unabbreviated ref name or a glob and may be specified multiple times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">Может быть сокращенным именем ссылки или глобусом и может быть указано несколько раз.Предупреждение будет выдано для тех ссылок,которые не существуют,но глобус,не совпадающий ни с одним из ссылок,будет молча игнорироваться.</target>
        </trans-unit>
        <trans-unit id="706c83c32d28c2f1cb1aaafc37be7356f71e7631" translate="yes" xml:space="preserve">
          <source>May be set to a boolean value, or the string &lt;code&gt;if-asked&lt;/code&gt;. A true value causes all pushes to be GPG signed, as if &lt;code&gt;--signed&lt;/code&gt; is passed to &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. The string &lt;code&gt;if-asked&lt;/code&gt; causes pushes to be signed if the server supports it, as if &lt;code&gt;--signed=if-asked&lt;/code&gt; is passed to &lt;code&gt;git push&lt;/code&gt;. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option.</source>
          <target state="translated">Может быть задано логическое значение или строка, &lt;code&gt;if-asked&lt;/code&gt; потребуется . Истинное значение приводит к тому, что все &lt;code&gt;--signed&lt;/code&gt; подписываются GPG, как если бы --signed передается в &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; . Строка &lt;code&gt;if-asked&lt;/code&gt; вызывает подписание &lt;code&gt;--signed=if-asked&lt;/code&gt; сервер поддерживает это, как если бы --signed = if-ask передано в &lt;code&gt;git push&lt;/code&gt; . Ложное значение может переопределить значение из конфигурационного файла с более низким приоритетом. Явный флаг командной строки всегда отменяет этот параметр конфигурации.</target>
        </trans-unit>
        <trans-unit id="8555af2d5095b661ce8d37e9e0375fb4c8ea77d6" translate="yes" xml:space="preserve">
          <source>May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If &lt;code&gt;check&lt;/code&gt; is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If &lt;code&gt;on-demand&lt;/code&gt; is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If &lt;code&gt;only&lt;/code&gt; is used all submodules will be recursively pushed while the superproject is left unpushed. A value of &lt;code&gt;no&lt;/code&gt; or using &lt;code&gt;--no-recurse-submodules&lt;/code&gt; can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.</source>
          <target state="translated">Может использоваться, чтобы убедиться, что все коммиты подмодулей, используемые отправляемыми ревизиями, доступны в ветке удаленного отслеживания. Если используется &lt;code&gt;check&lt;/code&gt; Git проверит, что все коммиты подмодуля, которые были изменены в отправляемых ревизиях, доступны по крайней мере на одном удаленном из подмодуля. Если какие-либо коммиты отсутствуют, push будет прерван и завершится с ненулевым статусом. Если используется &lt;code&gt;on-demand&lt;/code&gt; все подмодули, которые были изменены в отправляемых ревизиях, будут отправлены. Если по запросу не удалось отправить все необходимые изменения, он также будет прерван и выйдет с ненулевым статусом. Если используется &lt;code&gt;only&lt;/code&gt; все подмодули будут рекурсивно проталкиваться, в то время как суперпроект не будет выталкиваться. Значение &lt;code&gt;no&lt;/code&gt; или using &lt;code&gt;--no-recurse-submodules&lt;/code&gt; может использоваться для переопределения переменной конфигурации push.recurseSubmodules, когда рекурсия подмодуля не требуется.</target>
        </trans-unit>
        <trans-unit id="8be2a61b9ad007dcdaebc339c9660a293e37ceee" translate="yes" xml:space="preserve">
          <source>Mbox file to split. If not given, the mbox is read from the standard input.</source>
          <target state="translated">Файл из коробки разделить.Если он не задан,то mbox считывается со стандартного входа.</target>
        </trans-unit>
        <trans-unit id="1ce7743133ea15a3c11834ae295610d6b0aca98e" translate="yes" xml:space="preserve">
          <source>Memory utilization</source>
          <target state="translated">Использование памяти</target>
        </trans-unit>
        <trans-unit id="94804378bc64156caa1411beabf938d0cc1f334a" translate="yes" xml:space="preserve">
          <source>Merge a topic branch into the current branch, which resulted in a fast-forward.</source>
          <target state="translated">Объединить тематическую ветку в текущую,что привело к быстрой перемотке вперёд.</target>
        </trans-unit>
        <trans-unit id="aa4cb5d8e33b071846e0985dfd9e8a73b7ff3b77" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;maint&lt;/code&gt; into the current branch, but do not make a new commit automatically:</source>
          <target state="translated">Объединить &lt;code&gt;maint&lt;/code&gt; ветки с текущей веткой, но не делать новую фиксацию автоматически:</target>
        </trans-unit>
        <trans-unit id="36c2108053218bb1c9bd1daf5d80ef9e2b56153b" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;obsolete&lt;/code&gt; into the current branch, using &lt;code&gt;ours&lt;/code&gt; merge strategy:</source>
          <target state="translated">Слить &lt;code&gt;obsolete&lt;/code&gt; ветку с текущей веткой, используя &lt;code&gt;ours&lt;/code&gt; стратегию слияния:</target>
        </trans-unit>
        <trans-unit id="2340cae4ab971b09adab3732a6eccbc0f94439af" translate="yes" xml:space="preserve">
          <source>Merge branches &lt;code&gt;fixes&lt;/code&gt; and &lt;code&gt;enhancements&lt;/code&gt; on top of the current branch, making an octopus merge:</source>
          <target state="translated">&lt;code&gt;fixes&lt;/code&gt; и &lt;code&gt;enhancements&lt;/code&gt; слияния ветвей поверх текущей ветки, в результате чего слияние осьминога:</target>
        </trans-unit>
        <trans-unit id="3b3fe151c69070e113efe45497e8fbe34f98eda0" translate="yes" xml:space="preserve">
          <source>Merge into the current branch the remote branch &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">Слить с текущей веткой удаленную ветку &lt;code&gt;next&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c5d9976d41384cd800a73252d5887846f7995334" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS</source>
          <target state="translated">Объединить один патч в CVS</target>
        </trans-unit>
        <trans-unit id="ebf628d17763f2d1db5244a9d541825468f6e3f2" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo</source>
          <target state="translated">Объедините один патч в CVS (опции -c и -w).Рабочий каталог находится внутри Git Repo</target>
        </trans-unit>
        <trans-unit id="374bc1e6ce1c863c36094e824049bd53454731f0" translate="yes" xml:space="preserve">
          <source>Merge pending patches into CVS automatically &amp;mdash; only if you really know what you are doing</source>
          <target state="translated">Автоматически объединять ожидающие исправления в CVS - только если вы действительно знаете, что делаете</target>
        </trans-unit>
        <trans-unit id="1ecf516cb34751fcee31d345dc521d62850b1084" translate="yes" xml:space="preserve">
          <source>Merge strategies</source>
          <target state="translated">Слияние стратегий</target>
        </trans-unit>
        <trans-unit id="6455bb1c3dd50961d850d4ec4f8b22adf354885c" translate="yes" xml:space="preserve">
          <source>Merge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called &quot;remote&quot;) since the merge-base (if any) into the current notes ref (called &quot;local&quot;).</source>
          <target state="translated">Соедините данные сноски с текущими сносками.При этом будет сделана попытка объединить изменения,внесенные указанным номером ссылки (называемым &quot;удаленным&quot;)с момента объединения базы (если таковая имеется)в текущий номер ссылки (называемый &quot;локальный&quot;).</target>
        </trans-unit>
        <trans-unit id="06a4a977ae422fbb370e91879e13703bae28bf9d" translate="yes" xml:space="preserve">
          <source>Merge tracking</source>
          <target state="translated">Отслеживание слияния</target>
        </trans-unit>
        <trans-unit id="af8c9dbb2cf6a08b436fada56eb16ee91017d8ce" translate="yes" xml:space="preserve">
          <source>Merge workflow</source>
          <target state="translated">Объединить рабочий процесс</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="c4dada76f0f6e7dcbd827c4ba6bada46b3c6714c" translate="yes" xml:space="preserve">
          <source>Merges (to be discussed later), as well as operations such as &lt;code&gt;git reset&lt;/code&gt;, which change the currently checked-out commit, generally set ORIG_HEAD to the value HEAD had before the current operation.</source>
          <target state="translated">Слияния (будут обсуждены позже), а также такие операции, как &lt;code&gt;git reset&lt;/code&gt; , которые изменяют текущий извлеченный коммит, обычно устанавливают ORIG_HEAD в значение, которое HEAD имело перед текущей операцией.</target>
        </trans-unit>
        <trans-unit id="376269fe69e269c1639bc7c223893145d88653cf" translate="yes" xml:space="preserve">
          <source>Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in</source>
          <target state="translated">Слияния всегда включены.Однако их родительский список переписывается:Вдоль каждого родителя убираются коммиты,которые не включены сами по себе.Это приводит к тому,что</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
