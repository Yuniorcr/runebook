<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="c5ab965e580c550a049049c227e584f98537d08f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m&lt;/code&gt; is specified, &lt;code&gt;git read-tree&lt;/code&gt; can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided.</source>
          <target state="translated">Если указан &lt;code&gt;-m&lt;/code&gt; , &lt;code&gt;git read-tree&lt;/code&gt; может выполнять 3 вида слияния, слияние одного дерева, если задано только 1 дерево, слияние с ускоренной перемоткой вперед с 2 деревьями или 3-стороннее слияние, если предоставлено 3 или более деревьев ,</target>
        </trans-unit>
        <trans-unit id="1f1322547f9936fb21adaa0927130bdfd594f82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--non-matching&lt;/code&gt; are specified, non-matching pathnames will also be output, in which case all fields in each output record except for &amp;lt;pathname&amp;gt; will be empty. This can be useful when running non-interactively, so that files can be incrementally streamed to STDIN of a long-running check-ignore process, and for each of these files, STDOUT will indicate whether that file matched a pattern or not. (Without this option, it would be impossible to tell whether the absence of output for a given file meant that it didn&amp;rsquo;t match any pattern, or that the output hadn&amp;rsquo;t been generated yet.)</source>
          <target state="translated">Если &lt;code&gt;--non-matching&lt;/code&gt; &lt;code&gt;-n&lt;/code&gt; или --non-matching, несоответствующие имена путей также будут выведены, и в этом случае все поля в каждой выходной записи, кроме &amp;lt;pathname&amp;gt;, будут пустыми. Это может быть полезно при работе в неинтерактивном режиме, чтобы файлы можно было постепенно передавать в STDIN длительного процесса проверки-игнорирования, и для каждого из этих файлов STDOUT будет указывать, соответствует ли этот файл шаблону или нет. (Без этой опции было бы невозможно определить, означает ли отсутствие вывода для данного файла, что он не соответствует какому-либо шаблону, или что вывод еще не был создан.)</target>
        </trans-unit>
        <trans-unit id="bedfa7472b5b880935d5dde5c2d6b7df2dd5534d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-o&lt;/code&gt; is specified, output files are created in &amp;lt;dir&amp;gt;. Otherwise they are created in the current working directory. The default path can be set with the &lt;code&gt;format.outputDirectory&lt;/code&gt; configuration option. The &lt;code&gt;-o&lt;/code&gt; option takes precedence over &lt;code&gt;format.outputDirectory&lt;/code&gt;. To store patches in the current working directory even when &lt;code&gt;format.outputDirectory&lt;/code&gt; points elsewhere, use &lt;code&gt;-o .&lt;/code&gt;. All directory components will be created.</source>
          <target state="translated">Если указан &lt;code&gt;-o&lt;/code&gt; , выходные файлы создаются в &amp;lt;dir&amp;gt;. В противном случае они создаются в текущем рабочем каталоге. Путь по умолчанию можно задать с помощью &lt;code&gt;format.outputDirectory&lt;/code&gt; конфигурации format.outputDirectory . Параметр &lt;code&gt;-o&lt;/code&gt; имеет приоритет над &lt;code&gt;format.outputDirectory&lt;/code&gt; . Чтобы сохранить исправления в текущем рабочем каталоге, даже если &lt;code&gt;format.outputDirectory&lt;/code&gt; указывает на другое место, используйте &lt;code&gt;-o .&lt;/code&gt; , Все компоненты каталога будут созданы.</target>
        </trans-unit>
        <trans-unit id="bbc0034ea645324d7719670d640dccda6b5513e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-p&lt;/code&gt; is specified, the contents of &amp;lt;object&amp;gt; are pretty-printed.</source>
          <target state="translated">Если указан параметр &lt;code&gt;-p&lt;/code&gt; , содержимое &amp;lt;object&amp;gt; печатается красиво.</target>
        </trans-unit>
        <trans-unit id="49cafb1f81b012710180fa1719861bbc315bac4f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-s&lt;/code&gt; is specified, the size of the &amp;lt;object&amp;gt; in bytes.</source>
          <target state="translated">Если указан &lt;code&gt;-s&lt;/code&gt; , размер &amp;lt;объекта&amp;gt; в байтах.</target>
        </trans-unit>
        <trans-unit id="859275c6340e08abbb3b87a577dd1f75bdf60296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-t&lt;/code&gt; is specified, one of the &amp;lt;type&amp;gt;.</source>
          <target state="translated">Если указан &lt;code&gt;-t&lt;/code&gt; , один из &amp;lt;тип&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="77cb52b6f5e5f8b68fe5657e97a4dba5f22808fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-v&lt;/code&gt; is specified, the script reports what it is doing.</source>
          <target state="translated">Если указано &lt;code&gt;-v&lt;/code&gt; , сценарий сообщает, что он делает.</target>
        </trans-unit>
        <trans-unit id="f7c94cac86b7d031a538f6e54d51ce5da54af947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-z&lt;/code&gt; is specified, the pathnames in the output are delimited by the null character; if &lt;code&gt;--verbose&lt;/code&gt; is also specified then null characters are also used instead of colons and hard tabs:</source>
          <target state="translated">Если указан &lt;code&gt;-z&lt;/code&gt; , пути в выводе разделяются нулевым символом; если также указан &lt;code&gt;--verbose&lt;/code&gt; , то вместо двоеточий и жестких вкладок также используются нулевые символы:</target>
        </trans-unit>
        <trans-unit id="df5ef035453e7c733a2a29435ee6b85f1b9c7b00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:&amp;lt;funcname&amp;gt;&lt;/code&gt; is given in place of &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, it is a regular expression that denotes the range from the first funcname line that matches &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt;, up to the next funcname line. &lt;code&gt;:&amp;lt;funcname&amp;gt;&lt;/code&gt; searches from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. &lt;code&gt;^:&amp;lt;funcname&amp;gt;&lt;/code&gt; searches from the start of file. The function names are determined in the same way as &lt;code&gt;git diff&lt;/code&gt; works out patch hunk headers (see &lt;code&gt;Defining a custom hunk-header&lt;/code&gt; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b1b9cb08e8013285c455de408ae4d63672e927" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.normalBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">Если &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; или &lt;code&gt;trace2.normalBrief&lt;/code&gt; - истина, &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;filename&lt;/code&gt; и поля &lt;code&gt;line&lt;/code&gt; опускаются.</target>
        </trans-unit>
        <trans-unit id="2e9a7edfc47ae5456f77e7777204d6f377e2ee4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.eventBrief&lt;/code&gt; is true, the &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; fields are omitted from all events and the &lt;code&gt;time&lt;/code&gt; field is only present on the &quot;start&quot; and &quot;atexit&quot; events.</source>
          <target state="translated">Если &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; или &lt;code&gt;trace2.eventBrief&lt;/code&gt; имеет значение true, поля &lt;code&gt;file&lt;/code&gt; и &lt;code&gt;line&lt;/code&gt; включаются во все события, а поле &lt;code&gt;time&lt;/code&gt; присутствует только в событиях &amp;laquo;start&amp;raquo; и &amp;laquo;atexit&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1f02cbb9b13595b2ae6e45bc6f6b5fd9cfaab0a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.perfBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">Если &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; или &lt;code&gt;trace2.perfBrief&lt;/code&gt; истинно, поля &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; и &lt;code&gt;line&lt;/code&gt; указываются.</target>
        </trans-unit>
        <trans-unit id="ac54e4f3ca84b268e2b102a57942d2590e1ed97e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration for the current branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; exists, that is the name of the branch at the remote site that is merged.</source>
          <target state="translated">Если конфигурация &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; для текущей ветви &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; существует, это имя ветви на удаленном сайте, которая объединяется.</target>
        </trans-unit>
        <trans-unit id="0bbbd298acfcfe77553aeabe5dcce9895508b92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.ignoreCase=true&lt;/code&gt;, then the pattern-matching algorithm will use a case-insensitive check. This corrects for case mismatched filenames in the &lt;code&gt;git sparse-checkout set&lt;/code&gt; command to reflect the expected cone in the working directory.</source>
          <target state="translated">Если &lt;code&gt;core.ignoreCase=true&lt;/code&gt; , тогда алгоритм сопоставления с образцом будет использовать проверку без учета регистра. Это исправляет несоответствие регистра имен файлов в команде &lt;code&gt;git sparse-checkout set&lt;/code&gt; , чтобы отразить ожидаемый конус в рабочем каталоге.</target>
        </trans-unit>
        <trans-unit id="e0b5d0106d1c8675cc37e497ff6608e05f8526d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.safecrlf&lt;/code&gt; is set to &quot;true&quot; or &quot;warn&quot;, Git verifies if the conversion is reversible for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;. For &quot;true&quot;, Git rejects irreversible conversions; for &quot;warn&quot;, Git only prints a warning but accepts an irreversible conversion. The safety triggers to prevent such a conversion done to the files in the work tree, but there are a few exceptions. Even though&amp;hellip;​</source>
          <target state="translated">Если для &lt;code&gt;core.safecrlf&lt;/code&gt; задано значение &amp;laquo;true&amp;raquo; или &amp;laquo;warn&amp;raquo;, Git проверяет, является ли преобразование обратимым для текущего параметра &lt;code&gt;core.autocrlf&lt;/code&gt; . Для &quot;истины&quot; Git отклоняет необратимые преобразования; для предупреждения Git только выводит предупреждение, но принимает необратимое преобразование. Триггеры безопасности, предотвращающие такое преобразование файлов в дереве работ, но есть несколько исключений. Хотя&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a8fd82d7f01c8cd14090b39826adb8859d4c03b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt;, then Git will parse the sparse-checkout file expecting patterns of these types. Git will warn if the patterns do not match. If the patterns do match the expected format, then Git will use faster hash- based algorithms to compute inclusion in the sparse-checkout.</source>
          <target state="translated">Если &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt; , то Git проанализирует файл разреженной проверки, ожидая шаблонов этих типов. Git предупредит, если шаблоны не совпадают. Если шаблоны действительно соответствуют ожидаемому формату, то Git будет использовать более быстрые алгоритмы на основе хешей для вычисления включения в разреженную проверку.</target>
        </trans-unit>
        <trans-unit id="9f2eb1f9e30347412b91990fde6d0d3118015f0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;credential.helper&lt;/code&gt; is configured to the empty string, this resets the helper list to empty (so you may override a helper set by a lower-priority config file by configuring the empty-string helper, followed by whatever set of helpers you would like).</source>
          <target state="translated">Если &lt;code&gt;credential.helper&lt;/code&gt; настроен на пустую строку, это сбрасывает список помощников до пустого (так что вы можете переопределить помощник, установленный файлом конфигурации с более низким приоритетом, настроив помощник с пустой строкой, за которым следует любой набор помощников, который вы хотите ).</target>
        </trans-unit>
        <trans-unit id="6f6bc24ce4d9cb03fd023baafceb347acba1bf38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will not treat the initial commit as a big creation event. Any root commits in &lt;code&gt;git log -p&lt;/code&gt; output would be shown without a diff attached. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; и связанные команды не будут рассматривать начальную фиксацию как большое событие создания. Любые коммиты root в выводе &lt;code&gt;git log -p&lt;/code&gt; будут показаны без прикрепленного diff. По умолчанию это &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="176a2b5b60655848aad57cb4f6f5216b8fca3bab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git merge-index&lt;/code&gt; is called with multiple &amp;lt;file&amp;gt;s (or -a) then it processes them in turn only stopping if merge returns a non-zero exit code.</source>
          <target state="translated">Если &lt;code&gt;git merge-index&lt;/code&gt; вызывается с несколькими &amp;lt;file&amp;gt; (или -a), он обрабатывает их, в свою очередь, останавливаясь, только если слияние возвращает ненулевой код выхода.</target>
        </trans-unit>
        <trans-unit id="806256aa8b91febcc951ef689b4cdbc521c56b19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git svn&lt;/code&gt; is configured to fetch branches (and --follow-branches is in effect), it sometimes creates multiple Git branches for one SVN branch, where the additional branches have names of the form &lt;code&gt;branchname@nnn&lt;/code&gt; (with nnn an SVN revision number). These additional branches are created if &lt;code&gt;git svn&lt;/code&gt; cannot find a parent commit for the first commit in an SVN branch, to connect the branch to the history of the other branches.</source>
          <target state="translated">Если &lt;code&gt;git svn&lt;/code&gt; настроен на выборку ветвей (и действует --follow-branch), он иногда создает несколько веток Git для одной ветки SVN, где дополнительные ветки имеют имена в форме имя &lt;code&gt;branchname@nnn&lt;/code&gt; (где nnn - номер версии SVN. ). Эти дополнительные ветки создаются, если &lt;code&gt;git svn&lt;/code&gt; не может найти родительский коммит для первого коммита в ветке SVN, чтобы связать ветвь с историей других ветвей.</target>
        </trans-unit>
        <trans-unit id="ea83fb8f1cd42b6f4ec377884889f8ee539b7922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;our&lt;/code&gt; version introduces whitespace changes but &lt;code&gt;their&lt;/code&gt; version includes a substantial change, &lt;code&gt;their&lt;/code&gt; version is used;</source>
          <target state="translated">Если &lt;code&gt;our&lt;/code&gt; версия вносит изменения в пробелы, но &lt;code&gt;their&lt;/code&gt; версия включает существенные изменения, используется &lt;code&gt;their&lt;/code&gt; версия;</target>
        </trans-unit>
        <trans-unit id="a540055d45818789fbb8422bbf0d3790f08d9718" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repack.packKeptObjects&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then any pack-files with an associated &lt;code&gt;.keep&lt;/code&gt; file will not be selected for the batch to repack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3c5f8b5c3f8823d3bb0bf75c68202ef91e0068" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled for the long format and a summary of commits for modified submodules will be shown (see --summary-limit option of &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;). Please note that the summary output from the status command will be suppressed for all submodules when &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; is set to &lt;code&gt;all&lt;/code&gt; or only for those submodules where &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt;. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command line option or the &lt;code&gt;git submodule summary&lt;/code&gt; command, which shows a similar output but does not honor these settings.</source>
          <target state="translated">Если для &lt;code&gt;status.submoduleSummary&lt;/code&gt; установлено ненулевое число или значение true (идентично -1 или неограниченному числу), сводка подмодуля будет включена для длинного формата и будет показана сводка коммитов для измененных подмодулей (см. --Summary -limit опция &lt;a href=&quot;git-submodule&quot;&gt;git-&lt;/a&gt; submodule [1] ). Обратите внимание, что итоговый вывод команды status будет подавлен для всех подмодулей, если для &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; установлено значение &lt;code&gt;all&lt;/code&gt; или только для тех подмодулей, где &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt; . Чтобы также просмотреть сводку для проигнорированных подмодулей, вы можете использовать параметр командной строки --ignore-submodules = dirty или &lt;code&gt;git submodule summary&lt;/code&gt; команда, которая показывает аналогичный вывод, но не учитывает эти настройки.</target>
        </trans-unit>
        <trans-unit id="9e9c3270ca55bc57874ba3c8e582e2598d79892a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subsystem&lt;/code&gt; is rebased against &lt;code&gt;master&lt;/code&gt;, the following happens:</source>
          <target state="translated">Если &lt;code&gt;subsystem&lt;/code&gt; переустанавливается на &lt;code&gt;master&lt;/code&gt; , происходит следующее:</target>
        </trans-unit>
        <trans-unit id="601fb7e577607a9227812e9cbf0586e6f099c5c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;their&lt;/code&gt; version only introduces whitespace changes to a line, &lt;code&gt;our&lt;/code&gt; version is used;</source>
          <target state="translated">Если &lt;code&gt;their&lt;/code&gt; версия вводит только изменения пробелов в строке, используется &lt;code&gt;our&lt;/code&gt; версия;</target>
        </trans-unit>
        <trans-unit id="8afd53e5e6b34e88bd67e48774d4e9aa34d681c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will act as if the &lt;code&gt;--show-signature&lt;/code&gt; option was passed to them.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; и связанные команды будут действовать так, как если бы им была передана опция &lt;code&gt;--show-signature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30fb3a857bee5620305914164cd0d4800cd1bf39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; will act as if the &lt;code&gt;--follow&lt;/code&gt; option was used when a single &amp;lt;path&amp;gt; is given. This has the same limitations as &lt;code&gt;--follow&lt;/code&gt;, i.e. it cannot be used to follow multiple files and does not work well on non-linear history.</source>
          <target state="translated">Если &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; будет действовать так, как если бы &lt;code&gt;--follow&lt;/code&gt; опция --follow, когда задан единственный &amp;lt;path&amp;gt;. Он имеет те же ограничения, что и &lt;code&gt;--follow&lt;/code&gt; , то есть он не может использоваться для отслеживания нескольких файлов и плохо работает с нелинейной историей.</target>
        </trans-unit>
        <trans-unit id="1ee512d5daa33e9512f53b0ef8141d045d9eb4b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, indicate that the caller wants hash algorithm information to be passed back from the remote. This mode is used when fetching refs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e427e8f5bde6693ff553f72c72fbaf5c9a84e60f" translate="yes" xml:space="preserve">
          <source>If Alice wants to visualize what Bob did since their histories forked she can issue the following command:</source>
          <target state="translated">Если Элис хочет визуализировать,что Боб делал с момента вилки их истории,она может выдать следующую команду:</target>
        </trans-unit>
        <trans-unit id="38d81a70b720705355c01f2f151a0b608b67e1f5" translate="yes" xml:space="preserve">
          <source>If Bob later decides to work from a different host, he can still perform clones and pulls using the ssh protocol:</source>
          <target state="translated">Если Боб позже решит работать с другого хоста,он все равно может выполнять клоны и тянуть,используя протокол ssh:</target>
        </trans-unit>
        <trans-unit id="f8402010ea4f934676f08474104de477d81e1176" translate="yes" xml:space="preserve">
          <source>If I make a change on two branches but revert it on one, why does the merge of those branches include the change?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906533644a5e321915983ba584ed131ee5f02be3" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;bad&quot;, then we know that its descendants are all &quot;bad&quot;, so we want to say that:</source>
          <target state="translated">Если Х будет признан &quot;плохим&quot;,то мы знаем,что все его потомки &quot;плохие&quot;,поэтому мы хотим это сказать:</target>
        </trans-unit>
        <trans-unit id="585173cb924da5e21521ae8038b0882b2bd9054d" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;good&quot;, then we know that its ancestors are all &quot;good&quot;, so we want to say that:</source>
          <target state="translated">Если Икс окажется &quot;хорошим&quot;,то мы знаем,что его предки все &quot;хорошие&quot;,поэтому мы хотим это сказать:</target>
        </trans-unit>
        <trans-unit id="5b8abb6b4933866023868019ddfccc59a8fddfdf" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, it is used as a shell wildcard to restrict the output to matching branches. If multiple patterns are given, a branch is shown if it matches any of the patterns.</source>
          <target state="translated">Если задан &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; , он используется как подстановочный знак оболочки, чтобы ограничить вывод соответствующими ветвями. Если дано несколько шаблонов, отображается ветвь, если она соответствует любому из шаблонов.</target>
        </trans-unit>
        <trans-unit id="9af8e725fef48828fa7bc334de43f0ec2851ec0b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;merge&lt;/code&gt; command fails for any reason other than merge conflicts (i.e. when the merge operation did not even start), it is rescheduled immediately.</source>
          <target state="translated">Если команда &lt;code&gt;merge&lt;/code&gt; не выполняется по какой-либо причине, кроме конфликтов слияния (т. Е. Когда операция слияния даже не началась), она немедленно переносится.</target>
        </trans-unit>
        <trans-unit id="78142494afa000f59dc94a96d37bd84306c42e5e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;no-interactive-login&lt;/code&gt; command exists, then it is run and the interactive shell is aborted.</source>
          <target state="translated">Если существует команда &lt;code&gt;no-interactive-login&lt;/code&gt; , она запускается, и интерактивная оболочка прерывается.</target>
        </trans-unit>
        <trans-unit id="7f80f5447bc118a0311c9425234560dac2c0a613" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pattern&lt;/code&gt; is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;), it is turned into a prefix match by appending &lt;code&gt;/*&lt;/code&gt;.</source>
          <target state="translated">Если задан &lt;code&gt;pattern&lt;/code&gt; , отображаются только ссылки, соответствующие данному глобу оболочки. Если в шаблоне нет символа подстановки ( &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; Или &lt;code&gt;[&lt;/code&gt; ), он преобразуется в совпадение по префиксу путем добавления &lt;code&gt;/*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="744bace39aac155f24f5426e32b134c34f641c3b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; can also be run interactively (with no arguments). If a &lt;code&gt;help&lt;/code&gt; command is present in the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, it is run to provide the user with an overview of allowed actions. Then a &quot;git&amp;gt; &quot; prompt is presented at which one can enter any of the commands from the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, or &lt;code&gt;exit&lt;/code&gt; to close the connection.</source>
          <target state="translated">Если присутствует каталог &lt;code&gt;~/git-shell-commands&lt;/code&gt; , &lt;code&gt;git shell&lt;/code&gt; также можно запускать в интерактивном режиме (без аргументов). Если в каталоге &lt;code&gt;git-shell-commands&lt;/code&gt; присутствует команда &lt;code&gt;help&lt;/code&gt; , она запускается, чтобы предоставить пользователю обзор разрешенных действий. Затем отображается приглашение &amp;laquo;git&amp;gt;&amp;raquo;, в котором можно ввести любую из команд из каталога &lt;code&gt;git-shell-commands&lt;/code&gt; или &lt;code&gt;exit&lt;/code&gt; чтобы закрыть соединение.</target>
        </trans-unit>
        <trans-unit id="aa403bcc24255cf8941b29ab4148b7eee12a6185" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; will also handle other, custom commands by running &quot;&lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt;&quot; from the user&amp;rsquo;s home directory.</source>
          <target state="translated">Если присутствует каталог &lt;code&gt;~/git-shell-commands&lt;/code&gt; , &lt;code&gt;git shell&lt;/code&gt; также будет обрабатывать другие пользовательские команды, запустив &quot; &lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt; &quot; из домашнего каталога пользователя.</target>
        </trans-unit>
        <trans-unit id="106b7929c0261fff657b2746b76dd80d35492e74" translate="yes" xml:space="preserve">
          <source>If a Git client that does not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute adds a new file &lt;code&gt;bar.ps1&lt;/code&gt;, then &lt;code&gt;bar.ps1&lt;/code&gt; will be stored &quot;as-is&quot; internally (in this example probably as UTF-16). A client with &lt;code&gt;working-tree-encoding&lt;/code&gt; support will interpret the internal contents as UTF-8 and try to convert it to UTF-16 on checkout. That operation will fail and cause an error.</source>
          <target state="translated">Если клиент Git, который не поддерживает атрибут &lt;code&gt;working-tree-encoding&lt;/code&gt; добавляет новый файл &lt;code&gt;bar.ps1&lt;/code&gt; , тогда &lt;code&gt;bar.ps1&lt;/code&gt; будет сохранен внутри &amp;laquo;как есть&amp;raquo; (в этом примере, вероятно, как UTF-16). Клиент с поддержкой &lt;code&gt;working-tree-encoding&lt;/code&gt; будет интерпретировать внутреннее содержимое как UTF-8 и пытаться преобразовать его в UTF-16 при оформлении заказа. Эта операция завершится неудачно и вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="84278502dbc74a9c4cc8dd831a2c5f189f159ac0" translate="yes" xml:space="preserve">
          <source>If a Git repository includes branches &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt;, these will be fetched and consulted first during a &lt;code&gt;git p4 sync&lt;/code&gt;. Since importing directly from p4 is considerably slower than pulling changes from a Git remote, this can be useful in a multi-developer environment.</source>
          <target state="translated">Если репозиторий Git включает ветки &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt; , они будут извлечены и просмотрены в первую очередь во время &lt;code&gt;git p4 sync&lt;/code&gt; . Поскольку импорт напрямую из p4 происходит значительно медленнее, чем извлечение изменений из удаленного Git, это может быть полезно в среде с несколькими разработчиками.</target>
        </trans-unit>
        <trans-unit id="af291be12b7b5a290c76485729b6b8f4918ca983" translate="yes" xml:space="preserve">
          <source>If a command, or a guide, is given, a manual page for that command or guide is brought up. The &lt;code&gt;man&lt;/code&gt; program is used by default for this purpose, but this can be overridden by other options or configuration variables.</source>
          <target state="translated">Если дана команда или руководство, открывается страница руководства для этой команды или руководства. По умолчанию для этой цели используется программа &lt;code&gt;man&lt;/code&gt; , но это может быть отменено другими параметрами или переменными конфигурации.</target>
        </trans-unit>
        <trans-unit id="72743ffe0426b38cdd1755e732e28a11a9ff3a78" translate="yes" xml:space="preserve">
          <source>If a commit being cherry picked duplicates a commit already in the current history, it will become empty. By default these redundant commits cause &lt;code&gt;cherry-pick&lt;/code&gt; to stop so the user can examine the commit. This option overrides that behavior and creates an empty commit object. Implies &lt;code&gt;--allow-empty&lt;/code&gt;.</source>
          <target state="translated">Если выбранный коммит дублирует коммит, уже имеющийся в текущей истории, он станет пустым. По умолчанию эти избыточные коммиты вызывают остановку &lt;code&gt;cherry-pick&lt;/code&gt; чтобы пользователь мог изучить фиксацию. Этот параметр переопределяет такое поведение и создает пустой объект фиксации. Подразумевает &lt;code&gt;--allow-empty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b42bbbaf339d6cf05d45edbdf2ada972df70aa1" translate="yes" xml:space="preserve">
          <source>If a diff tool is not specified, &lt;code&gt;git difftool&lt;/code&gt; will use the configuration variable &lt;code&gt;diff.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;diff.tool&lt;/code&gt; is not set, &lt;code&gt;git difftool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">Если инструмент сравнения не указан, &lt;code&gt;git difftool&lt;/code&gt; будет использовать переменную конфигурации &lt;code&gt;diff.tool&lt;/code&gt; . Если конфигурационная переменная &lt;code&gt;diff.tool&lt;/code&gt; не задана, &lt;code&gt;git difftool&lt;/code&gt; выберет подходящее значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="a8ee98dcb134f1a2c8067ffe5665347c4c70f9e4" translate="yes" xml:space="preserve">
          <source>If a fatal error occurs, the program writes the error message to stderr and exits. The caller should expect that a suitable error message has been printed if the child closes the connection without completing a valid response for the current command.</source>
          <target state="translated">При возникновении фатальной ошибки программа записывает сообщение об ошибке в stderr и выходит из программы.Звонящий должен ожидать,что будет напечатано подходящее сообщение об ошибке,если дочерний процессор закроет соединение,не завершив действительный ответ на текущую команду.</target>
        </trans-unit>
        <trans-unit id="571d71cd29e09f41d5c855a2a419d634cc0eecce" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;must&lt;/code&gt; succeed in order to make the stored contents usable, you can declare that the filter is &lt;code&gt;required&lt;/code&gt;, in the configuration:</source>
          <target state="translated">Если фильтр &lt;code&gt;must&lt;/code&gt; успешным, чтобы сохраненное содержимое можно было использовать, вы можете объявить, что фильтр &lt;code&gt;required&lt;/code&gt; , в конфигурации:</target>
        </trans-unit>
        <trans-unit id="22e70bb4ff6d3a3dd5464ffc106fa14107a4c8dc" translate="yes" xml:space="preserve">
          <source>If a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; path and then connect the git directory and its working directory by setting the &lt;code&gt;core.worktree&lt;/code&gt; and adding a .git file pointing to the git directory embedded in the superprojects git directory.</source>
          <target state="translated">Если каталог git подмодуля находится внутри подмодуля, переместите каталог git подмодуля в путь &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; его суперпроекта, а затем подключите каталог git и его рабочий каталог, установив &lt;code&gt;core.worktree&lt;/code&gt; и добавив указатель на файл .git в каталог git, встроенный в каталог git суперпроектов.</target>
        </trans-unit>
        <trans-unit id="7b7f1fa74f78e5b674bbee244bef979691bc168d" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;, Git prefers &lt;code&gt;fetch&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">Если помощник объявляет &lt;code&gt;connect&lt;/code&gt; , Git будет использовать его, если это возможно, и вернется к другой возможности, если помощник запросит это при подключении (см. Команду &lt;code&gt;connect&lt;/code&gt; разделе КОМАНДЫ). При выборе между &lt;code&gt;fetch&lt;/code&gt; и &lt;code&gt;import&lt;/code&gt; Git предпочитает &lt;code&gt;fetch&lt;/code&gt; . Другие интерфейсы могут иметь другой порядок предпочтений.</target>
        </trans-unit>
        <trans-unit id="148562d25b0603b8eee662bc94ef7dd269783449" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;, Git prefers &lt;code&gt;push&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">Если помощник объявляет &lt;code&gt;connect&lt;/code&gt; , Git будет использовать его, если это возможно, и вернется к другой возможности, если помощник запросит это при подключении (см. Команду &lt;code&gt;connect&lt;/code&gt; разделе КОМАНДЫ). При выборе между &lt;code&gt;push&lt;/code&gt; и &lt;code&gt;export&lt;/code&gt; Git предпочитает &lt;code&gt;push&lt;/code&gt; . Другие интерфейсы могут иметь другой порядок предпочтений.</target>
        </trans-unit>
        <trans-unit id="fa7f2d8c2e0ee7753a285dedc0954f30b43daa88" translate="yes" xml:space="preserve">
          <source>If a helper fails to perform the requested operation or needs to notify the user of a potential issue, it may write to stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2388ab5f8918a49ad2647c3d1835f78b1fd11f78" translate="yes" xml:space="preserve">
          <source>If a helper outputs a &lt;code&gt;quit&lt;/code&gt; attribute with a value of &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, no further helpers will be consulted, nor will the user be prompted (if no credential has been provided, the operation will then fail).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79eaf960175c04b54e3507607c968b768d5dc83c" translate="yes" xml:space="preserve">
          <source>If a helper receives any other operation, it should silently ignore the request. This leaves room for future operations to be added (older helpers will just ignore the new requests).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8d1c4561ad329297670b7c11b5cea0c040fa93" translate="yes" xml:space="preserve">
          <source>If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the &quot;patience diff&quot; algorithm internally.</source>
          <target state="translated">Если строка существует как в источнике,так и в пункте назначения,существует только один раз,и начинается с этого текста,данный алгоритм пытается предотвратить ее появление в виде удаления или добавления в выходных данных.Внутри он использует алгоритм &quot;терпения diff&quot;.</target>
        </trans-unit>
        <trans-unit id="03800f18f812afe9c365f3cd10e3618c12ca274e" translate="yes" xml:space="preserve">
          <source>If a linked working tree is stored on a portable device or network share which is not always mounted, you can prevent its administrative files from being pruned by issuing the &lt;code&gt;git worktree lock&lt;/code&gt; command, optionally specifying &lt;code&gt;--reason&lt;/code&gt; to explain why the working tree is locked.</source>
          <target state="translated">Если связанное рабочее дерево хранится на переносном устройстве или сетевом ресурсе, который не всегда подключен, вы можете предотвратить &lt;code&gt;git worktree lock&lt;/code&gt; его административных файлов, выполнив команду git worktree lock , необязательно указав &lt;code&gt;--reason&lt;/code&gt; , чтобы объяснить, почему рабочее дерево заблокировано ,</target>
        </trans-unit>
        <trans-unit id="055300f804a90741eca19d86c43f3b133b4438b5" translate="yes" xml:space="preserve">
          <source>If a merge resolution program is not specified, &lt;code&gt;git mergetool&lt;/code&gt; will use the configuration variable &lt;code&gt;merge.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;merge.tool&lt;/code&gt; is not set, &lt;code&gt;git mergetool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">Если программа разрешения слияния не указана, &lt;code&gt;git mergetool&lt;/code&gt; будет использовать конфигурационную переменную &lt;code&gt;merge.tool&lt;/code&gt; . Если переменная конфигурации &lt;code&gt;merge.tool&lt;/code&gt; не установлена, &lt;code&gt;git mergetool&lt;/code&gt; выберет подходящее значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1ea5bcda19ff920edc6797065824126354674b5b" translate="yes" xml:space="preserve">
          <source>If a name is specified on stdin that cannot be resolved to an object in the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">Если в stdin указано имя, которое не может быть преобразовано в объект в репозитории, то &lt;code&gt;cat-file&lt;/code&gt; проигнорирует любой пользовательский формат и напечатает:</target>
        </trans-unit>
        <trans-unit id="b64d6e7bd6f81b6c41d97bf3465e33dac59a1923" translate="yes" xml:space="preserve">
          <source>If a name is specified that might refer to more than one object (an ambiguous short sha), then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">Если указано имя, которое может относиться к более чем одному объекту (неоднозначное короткое sha), то &lt;code&gt;cat-file&lt;/code&gt; проигнорирует любой настраиваемый формат и напечатает:</target>
        </trans-unit>
        <trans-unit id="6e4b893bbe0d833def4e5b2195c3efca0abfc652" translate="yes" xml:space="preserve">
          <source>If a namespace is in use, the namespace prefix is stripped from each reference before it is matched against &lt;code&gt;transfer.hiderefs&lt;/code&gt; patterns. For example, if &lt;code&gt;refs/heads/master&lt;/code&gt; is specified in &lt;code&gt;transfer.hideRefs&lt;/code&gt; and the current namespace is &lt;code&gt;foo&lt;/code&gt;, then &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; is omitted from the advertisements but &lt;code&gt;refs/heads/master&lt;/code&gt; and &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; are still advertised as so-called &quot;have&quot; lines. In order to match refs before stripping, add a &lt;code&gt;^&lt;/code&gt; in front of the ref name. If you combine &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt; must be specified first.</source>
          <target state="translated">Если используется пространство имен, префикс пространства имен удаляется из каждой ссылки, прежде чем он будет сопоставлен с шаблонами &lt;code&gt;transfer.hiderefs&lt;/code&gt; . Например, если &lt;code&gt;refs/heads/master&lt;/code&gt; указан в &lt;code&gt;transfer.hideRefs&lt;/code&gt; , а текущее пространство имен - &lt;code&gt;foo&lt;/code&gt; , то &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; не указывается в рекламе, но &lt;code&gt;refs/heads/master&lt;/code&gt; и &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; по-прежнему рекламируются как так называемые строки &quot;иметь&quot;. Чтобы сопоставить ссылки перед удалением, добавьте &lt;code&gt;^&lt;/code&gt; перед именем ссылки. Если совместить &lt;code&gt;!&lt;/code&gt; и &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; должен быть указан первым.</target>
        </trans-unit>
        <trans-unit id="01a3979b0db1ea5ddb68d8d2296f1a14d4a19443" translate="yes" xml:space="preserve">
          <source>If a positive depth is requested, the server will compute the set of commits which are no deeper than the desired depth.</source>
          <target state="translated">Если запрашивается положительная глубина,то сервер вычисляет набор коммитов,которые не глубже желаемой глубины.</target>
        </trans-unit>
        <trans-unit id="1af76a23a450746535be3f72c4b4bca12a2092d2" translate="yes" xml:space="preserve">
          <source>If a push would not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt; of the remote branch, then it will fail with an error like:</source>
          <target state="translated">Если push не приведет к &lt;a href=&quot;#fast-forwards&quot;&gt;быстрой перемотке&lt;/a&gt; удаленной ветки вперед , то он завершится с ошибкой, например:</target>
        </trans-unit>
        <trans-unit id="74746f4cd8d12a2fd7c6b3eb595d0f3e0b5c16c7" translate="yes" xml:space="preserve">
          <source>If a reflog entry&amp;rsquo;s predecessor is pruned, adjust its &quot;old&quot; SHA-1 to be equal to the &quot;new&quot; SHA-1 field of the entry that now precedes it.</source>
          <target state="translated">Если предшественник записи рефлога удаляется, настройте его &amp;laquo;старый&amp;raquo; SHA-1, чтобы он был равен полю &amp;laquo;нового&amp;raquo; SHA-1 записи, которая теперь предшествует ему.</target>
        </trans-unit>
        <trans-unit id="335f210edb83cade21599987ff0ffeaab940885d" translate="yes" xml:space="preserve">
          <source>If a refspec is prefixed by &lt;code&gt;^&lt;/code&gt;, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a &amp;lt;src&amp;gt; and do not specify a &amp;lt;dst&amp;gt;. Fully spelled out hex object names are also not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6545e25a03004b7b80ff7680d7d52c75ae528db2" translate="yes" xml:space="preserve">
          <source>If a specified file is in the index but is missing then it&amp;rsquo;s removed. Default behavior is to ignore removed file.</source>
          <target state="translated">Если указанный файл есть в индексе, но отсутствует, он удаляется. По умолчанию удаленный файл игнорируется.</target>
        </trans-unit>
        <trans-unit id="0b6d50904501e60c5730f3fc1689dbda57685832" translate="yes" xml:space="preserve">
          <source>If a specified file isn&amp;rsquo;t in the index already then it&amp;rsquo;s added. Default behaviour is to ignore new files.</source>
          <target state="translated">Если указанного файла еще нет в индексе, он добавляется. По умолчанию новые файлы игнорируются.</target>
        </trans-unit>
        <trans-unit id="a14dea6ce44fe61b94cf6eca48f584619dca6981" translate="yes" xml:space="preserve">
          <source>If a subject is not found in the patch description the patch name is preserved as the 1 line subject in the Git description.</source>
          <target state="translated">Если объект не найден в описании патча,имя патча сохраняется как 1-строчный объект в описании Git'а.</target>
        </trans-unit>
        <trans-unit id="511834d1553ad3d02aefac42a3d932c821a68c9a" translate="yes" xml:space="preserve">
          <source>If a version-1 repository specifies any &lt;code&gt;extensions.*&lt;/code&gt; keys that the running git has not implemented, the operation MUST NOT proceed. Similarly, if the value of any known key is not understood by the implementation, the operation MUST NOT proceed.</source>
          <target state="translated">Если в репозитории версии 1 указаны какие-либо ключи &lt;code&gt;extensions.*&lt;/code&gt; , Которые запущенный git не реализовал, операция НЕ ДОЛЖНА продолжаться. Точно так же, если значение какого-либо известного ключа не понимается реализацией, операция НЕ ДОЛЖНА продолжаться.</target>
        </trans-unit>
        <trans-unit id="7fc57bcdf92fac8f6a715a452b985f9026a5a582" translate="yes" xml:space="preserve">
          <source>If a whole directory is classified as &quot;other&quot;, show just its name (with a trailing slash) and not its whole contents.</source>
          <target state="translated">Если весь каталог классифицируется как &quot;другой&quot;,показывайте только его имя (с трейлинговой косой чертой),а не все его содержимое.</target>
        </trans-unit>
        <trans-unit id="9069929e0dad6127e4d7686101bafb1ad2a53dfd" translate="yes" xml:space="preserve">
          <source>If a working tree is deleted without using &lt;code&gt;git worktree remove&lt;/code&gt;, then its associated administrative files, which reside in the repository (see &quot;DETAILS&quot; below), will eventually be removed automatically (see &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;), or you can run &lt;code&gt;git worktree prune&lt;/code&gt; in the main or any linked working tree to clean up any stale administrative files.</source>
          <target state="translated">Если рабочее дерево удаляется без использования &lt;code&gt;git worktree remove&lt;/code&gt; , то связанные с ним административные файлы, которые находятся в репозитории (см. &amp;laquo;ДЕТАЛИ&amp;raquo; ниже), в конечном итоге будут удалены автоматически (см. &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; ), или вы можете запустить &lt;code&gt;git worktree prune&lt;/code&gt; в основном или любом связанном рабочем дереве, чтобы очистить все устаревшие административные файлы.</target>
        </trans-unit>
        <trans-unit id="601f99371e1781bbcc6e4fbcb70987193e9cb892" translate="yes" xml:space="preserve">
          <source>If a working tree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted. Optionally, specify a reason for the lock with &lt;code&gt;--reason&lt;/code&gt;.</source>
          <target state="translated">Если рабочее дерево находится на переносном устройстве или сетевом ресурсе, который не всегда подключен, заблокируйте его, чтобы предотвратить автоматическое удаление административных файлов. Это также предотвращает его перемещение или удаление. При желании укажите причину блокировки с помощью &lt;code&gt;--reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c89355d42dbc93622cf0025bcf122df76b472f1" translate="yes" xml:space="preserve">
          <source>If advertised, indicates that any number of server specific options can be included in a request. This is done by sending each option as a &quot;server-option=&amp;lt;option&amp;gt;&quot; capability line in the capability-list section of a request.</source>
          <target state="translated">Если объявлено, означает, что в запрос может быть включено любое количество специфических для сервера опций. Это делается путем отправки каждой опции в виде строки возможности &quot;server-option = &amp;lt;option&amp;gt;&quot; в разделе списка возможностей запроса.</target>
        </trans-unit>
        <trans-unit id="c768073bebd10b960d1a77545805ba6684f69c55" translate="yes" xml:space="preserve">
          <source>If after this parent rewriting, &lt;code&gt;C'&lt;/code&gt; is a root or merge commit (has zero or &amp;gt;1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.</source>
          <target state="translated">Если после этой родительской перезаписи &lt;code&gt;C'&lt;/code&gt; является корневой фиксацией или фиксацией слияния (имеет ноль или&amp;gt; 1 родителей), пограничной фиксацией или! TREESAME, она остается. В противном случае он заменяется единственным родительским элементом.</target>
        </trans-unit>
        <trans-unit id="331241d5d1136bad0fab6978a8eab7a815b255e9" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;ref&amp;gt;s can be locked with matching &amp;lt;oldvalue&amp;gt;s simultaneously, all modifications are performed. Otherwise, no modifications are performed. Note that while each individual &amp;lt;ref&amp;gt; is updated or deleted atomically, a concurrent reader may still see a subset of the modifications.</source>
          <target state="translated">Если все &amp;lt;ref&amp;gt; s могут быть заблокированы совпадающими &amp;lt;oldvalue&amp;gt; s одновременно, все модификации выполняются. В противном случае никаких изменений не производится. Обратите внимание, что хотя каждый отдельный &amp;lt;ref&amp;gt; обновляется или удаляется атомарно, одновременный читатель может все еще видеть подмножество изменений.</target>
        </trans-unit>
        <trans-unit id="f2745e08ed788856c12f02ca7a5befc54f3c9443" translate="yes" xml:space="preserve">
          <source>If all named commits are already ancestors of &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; will exit early with the message &quot;Already up to date.&quot;</source>
          <target state="translated">Если все названные коммиты уже являются предками &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;git merge&lt;/code&gt; выйдет раньше с сообщением &amp;laquo;Уже обновлено&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="cf6cb5a66ab4b3c3c33160d1bdddf3e27a51bd6e" translate="yes" xml:space="preserve">
          <source>If all you really want to do is to remove from the index the files that are no longer present in the working tree (perhaps because your working tree is dirty so that you cannot use &lt;code&gt;git commit -a&lt;/code&gt;), use the following command:</source>
          <target state="translated">Если все, что вы действительно хотите сделать, это удалить из индекса файлы, которых больше нет в рабочем дереве (возможно, из-за того, что ваше рабочее дерево грязное и вы не можете использовать &lt;code&gt;git commit -a&lt;/code&gt; ), используйте следующую команду:</target>
        </trans-unit>
        <trans-unit id="232e0a33b39a8eedbea0de34207896fce9d5da1b" translate="yes" xml:space="preserve">
          <source>If an SVN revision has a property, &quot;svm:headrev&quot;, it is likely that the revision was created by SVN::Mirror (also used by SVK). The property contains a repository UUID and a revision. We want to make it look like we are mirroring the original URL, so introduce a helper function that returns the original identity URL and UUID, and use it when generating metadata in commit messages.</source>
          <target state="translated">Если ревизия SVN имеет свойство &quot;svm:headrev&quot;,вероятно,что ревизия была создана SVN::Mirror (также используется SVK).Свойство содержит UUID репозитория и ревизию.Мы хотим,чтобы оно выглядело так,как будто мы зеркалируем исходный URL,так что введите функцию помощника,которая возвращает исходный идентификационный URL и UUID,и используйте его при генерации метаданных в сообщениях о фиксации.</target>
        </trans-unit>
        <trans-unit id="8ec6058ea575ab09ff2743fac6f67664b17c975f" translate="yes" xml:space="preserve">
          <source>If an alias is given, git shows the definition of the alias on standard output. To get the manual page for the aliased command, use &lt;code&gt;git COMMAND --help&lt;/code&gt;.</source>
          <target state="translated">Если указан псевдоним, git показывает определение псевдонима в стандартном выводе. Чтобы получить страницу руководства для команды с псевдонимом, используйте &lt;code&gt;git COMMAND --help&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06b64f77884080bf4b8a1b3580804b4fc90c62bc" translate="yes" xml:space="preserve">
          <source>If an exact match was not found, &lt;code&gt;git describe&lt;/code&gt; will walk back through the commit history to locate an ancestor commit which has been tagged. The ancestor&amp;rsquo;s tag will be output along with an abbreviation of the input commit-ish&amp;rsquo;s SHA-1. If &lt;code&gt;--first-parent&lt;/code&gt; was specified then the walk will only consider the first parent of each commit.</source>
          <target state="translated">Если точное совпадение не найдено, &lt;code&gt;git describe&lt;/code&gt; description вернется к истории коммитов, чтобы найти пометку предка. Тег предка будет выводиться вместе с аббревиатурой SHA-1 входного коммита. Если был указан &lt;code&gt;--first-parent&lt;/code&gt; , тогда обход будет рассматривать только первого родителя каждой фиксации.</target>
        </trans-unit>
        <trans-unit id="98c6f5f40e2b8ae0667cb14d2e8af19ba85f9e07" translate="yes" xml:space="preserve">
          <source>If an existing replace ref for the same object exists, it will be overwritten (instead of failing).</source>
          <target state="translated">Если существующая ссылка на замену для того же самого объекта существует,то она будет перезаписана (вместо неудачной).</target>
        </trans-unit>
        <trans-unit id="046c10da2487af8c5911472dad4ec66653003b0a" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;file&amp;gt; does not appear in the index, treat this as an error (return 1).</source>
          <target state="translated">Если какой-либо &amp;lt;файл&amp;gt; не появляется в индексе, это считается ошибкой (возврат 1).</target>
        </trans-unit>
        <trans-unit id="cedba844ab10a6fe9ad00a9dbc9501b2421d985c" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;git -C &amp;lt;repo&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt; subprocess returns a non-zero exit code, then the &lt;code&gt;git for-each-repo&lt;/code&gt; process returns that exit code without running more subprocesses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c329c54100c9f229f2bd1af9a36354df219a33" translate="yes" xml:space="preserve">
          <source>If any evaluation of &amp;lt;command&amp;gt; returns a non-zero exit status, the whole operation will be aborted.</source>
          <target state="translated">Если какая-либо оценка &amp;lt;command&amp;gt; возвращает ненулевой статус выхода, вся операция будет прервана.</target>
        </trans-unit>
        <trans-unit id="939ada40ab0c594838b538aaf9b14ce39d17200d" translate="yes" xml:space="preserve">
          <source>If any file doesn&amp;rsquo;t begin with a From line, assume it is a single mail message instead of signaling error.</source>
          <target state="translated">Если какой-либо файл не начинается со строки &amp;laquo;От&amp;raquo;, предположите, что это одно почтовое сообщение, а не сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="824867a2502f9c0cf53ed6a13fd4b286bb82c4ed" translate="yes" xml:space="preserve">
          <source>If any files that should not be normalized show up in &lt;code&gt;git status&lt;/code&gt;, unset their &lt;code&gt;text&lt;/code&gt; attribute before running &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">Если какие-либо файлы, которые не следует нормализовать, отображаются в &lt;code&gt;git status&lt;/code&gt; , отключите их &lt;code&gt;text&lt;/code&gt; атрибут перед запуском &lt;code&gt;git add -u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c34b6095a9c49861d2acc43610b57c3a4a36934" translate="yes" xml:space="preserve">
          <source>If any files were ever &quot;cvs import&quot;ed more than once (e.g., import of more than one vendor release) the HEAD contains the wrong content.</source>
          <target state="translated">Если какие-либо файлы когда-либо &quot;импортировались&quot; cvs более одного раза (например,импорт более чем одной версии производителя),HEAD содержит неверное содержимое.</target>
        </trans-unit>
        <trans-unit id="8a184d41ad4c8629ad4f2bce24803b0c9fa2c0bb" translate="yes" xml:space="preserve">
          <source>If any of the remote changes overlap with local uncommitted changes, the merge will be automatically canceled and the work tree untouched. It is generally best to get any local changes in working order before pulling or stash them away with &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">Если какое-либо из удаленных изменений перекрывается с локальными незафиксированными изменениями, слияние будет автоматически отменено, а дерево работы останется без изменений. Как правило, лучше всего получить какие-либо локальные изменения в рабочем состоянии, прежде чем извлекать или спрятать их с помощью &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27aabdb37af0432fadcd5ffecc44449505cac9be" translate="yes" xml:space="preserve">
          <source>If any optional &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; arguments are given, only those paths are affected.</source>
          <target state="translated">Если заданы необязательные аргументы &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; , затрагиваются только эти пути.</target>
        </trans-unit>
        <trans-unit id="d20da8878e924b8ea99ba5928199985d6eb45c5b" translate="yes" xml:space="preserve">
          <source>If at least one of the specified mechanisms matches the ones advertised by the SMTP server and if it is supported by the utilized SASL library, the mechanism is used for authentication. If neither &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; nor &lt;code&gt;--smtp-auth&lt;/code&gt; is specified, all mechanisms supported by the SASL library can be used. The special value &lt;code&gt;none&lt;/code&gt; maybe specified to completely disable authentication independently of &lt;code&gt;--smtp-user&lt;/code&gt;</source>
          <target state="translated">Если хотя бы один из указанных механизмов совпадает с механизмами, объявленными сервером SMTP, и если он поддерживается используемой библиотекой SASL, этот механизм используется для аутентификации. Если ни &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; , ни &lt;code&gt;--smtp-auth&lt;/code&gt; не указаны, можно использовать все механизмы, поддерживаемые библиотекой SASL. Специальное значение &lt;code&gt;none&lt;/code&gt; может быть указано для полного отключения аутентификации независимо от &lt;code&gt;--smtp-user&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48ca5fe331a67872cf3424cd090943cee3b1214a" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or a pseudoref like HEAD or ORIG_HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66be204c5192d97175dc2e5a6cea91a845a9494" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or the symbolic ref HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="translated">Если параметр конфигурации &amp;laquo;core.logAllRefUpdates&amp;raquo; имеет значение &amp;laquo;истина&amp;raquo; и ссылка находится под &amp;laquo;refs / heads /&amp;raquo;, &amp;laquo;refs / remotes /&amp;raquo;, &amp;laquo;refs / notes /&amp;raquo; или символической ref HEAD; или существует файл &amp;laquo;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&amp;raquo;, тогда &lt;code&gt;git update-ref&lt;/code&gt; добавит строку в файл журнала &amp;laquo;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&amp;raquo; (разыменование всех символических ссылок перед созданием имени журнала), описывающую изменение значения реф. Строки журнала имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="bb79d7b0840991ebe429aab3a3410932b975f32c" translate="yes" xml:space="preserve">
          <source>If conflicts arise and a strategy for automatically resolving conflicting notes (see the &quot;NOTES MERGE STRATEGIES&quot; section) is not given, the &quot;manual&quot; resolver is used. This resolver checks out the conflicting notes in a special worktree (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to manually resolve the conflicts there. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">Если возникают конфликты и не указана стратегия автоматического разрешения конфликтующих примечаний (см. Раздел &amp;laquo;СТРАТЕГИИ ОБЪЕДИНЕНИЯ ЗАПИСЕЙ&amp;raquo;), используется &amp;laquo;ручной&amp;raquo; преобразователь. Этот преобразователь проверяет конфликтующие заметки в специальном рабочем дереве ( &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ) и инструктирует пользователя вручную разрешить конфликты там. Когда это будет сделано, пользователь может либо завершить слияние с помощью &lt;code&gt;git notes merge --commit&lt;/code&gt; , либо прервать слияние с помощью &lt;code&gt;git notes merge --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02a69db3092fb7486e9bff9ff76c98958fe4d57" translate="yes" xml:space="preserve">
          <source>If core.commitGraph is true, the commit-graph file will also be inspected using &lt;code&gt;git commit-graph verify&lt;/code&gt;. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;.</source>
          <target state="translated">Если core.commitGraph имеет значение true, файл commit-graph также будет проверяться с помощью &lt;code&gt;git commit-graph verify&lt;/code&gt; . См. &lt;a href=&quot;git-commit-graph&quot;&gt;Git-commit-graph [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8280fdd5ec3fb25317b497d70f747c3177f7ef0e" translate="yes" xml:space="preserve">
          <source>If disabled with &quot;--no-thread&quot;, those headers will not be added (unless specified with --in-reply-to). Default is the value of the &lt;code&gt;sendemail.thread&lt;/code&gt; configuration value; if that is unspecified, default to --thread.</source>
          <target state="translated">Если отключено с помощью &amp;laquo;--no-thread&amp;raquo;, эти заголовки не будут добавлены (если не указано с помощью --in-reply-to). По умолчанию это значение конфигурации &lt;code&gt;sendemail.thread&lt;/code&gt; ; если это не указано, по умолчанию --thread.</target>
        </trans-unit>
        <trans-unit id="f00c2d7bc0317e9cad287fad199ae73edff4a848" translate="yes" xml:space="preserve">
          <source>If either &amp;lt;upstream&amp;gt; or --root is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="translated">Если в командной строке задано либо &amp;lt;upstream&amp;gt;, либо --root, то по умолчанию используется &lt;code&gt;--no-fork-point&lt;/code&gt; , иначе &lt;code&gt;--fork-point&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4729a11522c55d49b0e7c329a8805975c4198d9" translate="yes" xml:space="preserve">
          <source>If either of these environment variables is set then &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command-line parameters passed to the configured command are determined by the ssh variant. See &lt;code&gt;ssh.variant&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">Если установлена ​​одна из этих переменных среды, тогда &lt;code&gt;git fetch&lt;/code&gt; и &lt;code&gt;git push&lt;/code&gt; будут использовать указанную команду вместо &lt;code&gt;ssh&lt;/code&gt; , когда им нужно подключиться к удаленной системе. Параметры командной строки, передаваемые настроенной команде, определяются вариантом ssh. См. &lt;code&gt;ssh.variant&lt;/code&gt; параметре ssh.variant в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3669ee4e6fd1ff3473f59b85f73b98bc8093a5f0" translate="yes" xml:space="preserve">
          <source>If enabled the helper should automatically fetch annotated tag objects if the object the tag points at was transferred during the fetch command. If the tag is not fetched by the helper a second fetch command will usually be sent to ask for the tag specifically. Some helpers may be able to use this option to avoid a second network connection.</source>
          <target state="translated">Если включено,то помощник должен автоматически получать аннотированные объекты тегов,если объект,на который указывает тег,был передан при выполнении команды Fetch.Если тэг не был получен помощником,то обычно посылается вторая команда fetch,которая запрашивает именно этот тэг.Некоторые помощники могут использовать эту опцию,чтобы избежать второго сетевого соединения.</target>
        </trans-unit>
        <trans-unit id="27acfa87cdb69a824b9bae48206b42168ffde848" translate="yes" xml:space="preserve">
          <source>If enabled, &lt;code&gt;git p4 submit&lt;/code&gt; will attempt to cleanup RCS keywords ($Header$, etc). These would otherwise cause merge conflicts and prevent the submit going ahead. This option should be considered experimental at present.</source>
          <target state="translated">Если этот параметр включен, &lt;code&gt;git p4 submit&lt;/code&gt; попытается очистить ключевые слова RCS ($ Header $ и т. Д.). В противном случае это могло бы вызвать конфликты слияния и помешать выполнению отправки. В настоящее время этот вариант следует считать экспериментальным.</target>
        </trans-unit>
        <trans-unit id="551059a87916480f640c4e8b1f0ae5467d5d2b16" translate="yes" xml:space="preserve">
          <source>If everything fails, or if no viewer is configured, the viewer specified in the &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; environment variable will be tried. If that fails too, the &lt;code&gt;man&lt;/code&gt; program will be tried anyway.</source>
          <target state="translated">Если что-то не удается или если программа просмотра не настроена, будет использована программа просмотра, указанная в &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; среды GIT_MAN_VIEWER . Если и это не удастся, программа &lt;code&gt;man&lt;/code&gt; все равно будет проверена.</target>
        </trans-unit>
        <trans-unit id="dc951917b8a4344a8f095e91594828b8eb0d132d" translate="yes" xml:space="preserve">
          <source>If explicit refspecs were given on the command line of &lt;code&gt;git pull&lt;/code&gt;, they are all merged.</source>
          <target state="translated">Если в командной строке &lt;code&gt;git pull&lt;/code&gt; были указаны явные refspecs , они все объединяются.</target>
        </trans-unit>
        <trans-unit id="9f9421c37df0f080e8411a466937f35ec8c1d1a5" translate="yes" xml:space="preserve">
          <source>If false, symbolic links are checked out as small plain files that contain the link text. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; will not change the recorded type to regular file. Useful on filesystems like FAT that do not support symbolic links.</source>
          <target state="translated">Если false, символические ссылки извлекаются как небольшие простые файлы, содержащие текст ссылки. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; и &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; не изменят записанный тип на обычный файл. Полезно для файловых систем, таких как FAT, которые не поддерживают символические ссылки.</target>
        </trans-unit>
        <trans-unit id="8463a48927d35802080dff1be147345270adfa9a" translate="yes" xml:space="preserve">
          <source>If false, the ctime differences between the index and the working tree are ignored; useful when the inode change time is regularly modified by something outside Git (file system crawlers and some backup systems). See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. True by default.</source>
          <target state="translated">Если false, различия ctime между индексом и рабочим деревом игнорируются; полезно, когда время изменения inode регулярно изменяется чем-то вне Git (поисковыми роботами файловой системы и некоторыми системами резервного копирования). См. &lt;a href=&quot;git-update-index&quot;&gt;Git-update-index [1]&lt;/a&gt; . По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="c3b2c82ffccecb89175e5c1911567eb5a6cff2f5" translate="yes" xml:space="preserve">
          <source>If fast-import is supplied invalid input it will terminate with a non-zero exit status and create a crash report in the top level of the Git repository it was importing into. Crash reports contain a snapshot of the internal fast-import state as well as the most recent commands that lead up to the crash.</source>
          <target state="translated">Если быстренький импорт поступил с неверными данными,он завершится со статусом ненулевого выхода и создаст отчёт о сбое на верхнем уровне Git-репозитория,в который он импортировал.Отчёты о сбоях содержат снимки внутреннего состояния быстрого импорта,а также самые последние команды,которые привели к сбою.</target>
        </trans-unit>
        <trans-unit id="b4b929406272978e9913bc69bd98a25fedb2b075" translate="yes" xml:space="preserve">
          <source>If generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see &lt;code&gt;--follow&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file&amp;rsquo;s size). For example, &lt;code&gt;-M90%&lt;/code&gt; means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn&amp;rsquo;t changed. Without a &lt;code&gt;%&lt;/code&gt; sign, the number is to be read as a fraction, with a decimal point before it. I.e., &lt;code&gt;-M5&lt;/code&gt; becomes 0.5, and is thus the same as &lt;code&gt;-M50%&lt;/code&gt;. Similarly, &lt;code&gt;-M05&lt;/code&gt; is the same as &lt;code&gt;-M5%&lt;/code&gt;. To limit detection to exact renames, use &lt;code&gt;-M100%&lt;/code&gt;. The default similarity index is 50%.</source>
          <target state="translated">При генерации различий обнаруживайте и сообщайте о переименовании для каждой фиксации. Чтобы узнать о переименовании файлов при просмотре истории, см. &lt;code&gt;--follow&lt;/code&gt; . Если указано &lt;code&gt;n&lt;/code&gt; , это порог индекса сходства (т.е. количества добавлений / удалений по сравнению с размером файла). Например, &lt;code&gt;-M90%&lt;/code&gt; означает, что Git должен рассматривать пару удаления / добавления как переименование, если более 90% файла не изменилось. Без знака &lt;code&gt;%&lt;/code&gt; число следует читать как дробь с десятичной точкой перед ним. &lt;code&gt;-M5&lt;/code&gt; есть -M5 становится 0,5 и, таким образом, совпадает с &lt;code&gt;-M50%&lt;/code&gt; . Точно так же &lt;code&gt;-M05&lt;/code&gt; совпадает с &lt;code&gt;-M5%&lt;/code&gt; . Чтобы ограничить обнаружение точным переименованием, используйте &lt;code&gt;-M100%&lt;/code&gt; , Индекс сходства по умолчанию - 50%.</target>
        </trans-unit>
        <trans-unit id="adbe5b777a6e949c23db17b38ebf1735d572ece1" translate="yes" xml:space="preserve">
          <source>If git detects typos and can identify exactly one valid command similar to the error, git will automatically run the intended command after waiting a duration of time defined by this configuration value in deciseconds (0.1 sec). If this value is 0, the suggested corrections will be shown, but not executed. If it is a negative integer, or &quot;immediate&quot;, the suggested command is run immediately. If &quot;never&quot;, suggestions are not shown at all. The default value is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf34c88ee2af8f797d0000ddc97681383ffc8ba" translate="yes" xml:space="preserve">
          <source>If git fetch fails because the new head of a branch is not a descendant of the old head, you may force the update with:</source>
          <target state="translated">Если git-поиск не удаётся из-за того,что новая голова ветки не является потомком старой,вы можете форсировать обновление:</target>
        </trans-unit>
        <trans-unit id="e083719ea272a39b1421c558e4392c556db2e4ef" translate="yes" xml:space="preserve">
          <source>If given &lt;code&gt;--thread&lt;/code&gt;, &lt;code&gt;git-format-patch&lt;/code&gt; will generate &lt;code&gt;In-Reply-To&lt;/code&gt; and &lt;code&gt;References&lt;/code&gt; headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a &lt;code&gt;Message-Id&lt;/code&gt; header to reference.</source>
          <target state="translated">Если задано &lt;code&gt;--thread&lt;/code&gt; , &lt;code&gt;git-format-patch&lt;/code&gt; будет генерировать заголовки &lt;code&gt;In-Reply-To&lt;/code&gt; и &lt;code&gt;References&lt;/code&gt; , чтобы второе и последующие сообщения с исправлениями отображались как ответы на первое письмо; это также генерирует заголовок &lt;code&gt;Message-Id&lt;/code&gt; для ссылки.</target>
        </trans-unit>
        <trans-unit id="b8bcbf4a83fcf4f75c98a2212241bdcbc1331a73" translate="yes" xml:space="preserve">
          <source>If given, limit the search to paths matching at least one pattern. Both leading paths match and glob(7) patterns are supported.</source>
          <target state="translated">Если задано,ограничьте поиск только траекториями,совпадающими хотя бы с одним образцом.Поддерживаются оба ведущих пути,совпадающие с шаблонами глобуса(7).</target>
        </trans-unit>
        <trans-unit id="0f1d3c019382d162e2080cbdc28ed58b9e3bfa0a" translate="yes" xml:space="preserve">
          <source>If given, strings that substitute &lt;code&gt;%(fieldname)&lt;/code&gt; placeholders are quoted as string literals suitable for the specified host language. This is meant to produce a scriptlet that can directly be `eval`ed.</source>
          <target state="translated">Если указано, строки, которые заменяют заполнители &lt;code&gt;%(fieldname)&lt;/code&gt; заключаются в кавычки как строковые литералы, подходящие для указанного основного языка. Это предназначено для создания скриптлета, который может быть непосредственно обработан `eval`.</target>
        </trans-unit>
        <trans-unit id="fbaedaa3bd6d3e9940a1f51ae6f8f8f02a814640" translate="yes" xml:space="preserve">
          <source>If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.</source>
          <target state="translated">Если история линейная и HEAD является родоначальником следующего,обновите рабочее дерево и предваряйте указатель HEAD,чтобы он соответствовал следующему.В противном случае,применяйте изменения,внесённые теми коммитами,которые находятся в следующей,но не HEAD,к текущей ветке,создавая новый коммит для каждого нового изменения.</target>
        </trans-unit>
        <trans-unit id="c5f1ba7eca8a5dae95e4277b8eb6e331cbac924e" translate="yes" xml:space="preserve">
          <source>If it does not apply correctly, there can be various reasons.</source>
          <target state="translated">Если он применяется неправильно,могут быть различные причины.</target>
        </trans-unit>
        <trans-unit id="50113fb63d9da87174eb94266585c5426270510c" translate="yes" xml:space="preserve">
          <source>If it does not support the requested operation (e.g., a read-only store), it should silently ignore the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527b079607be5b2a4ead185d633224b57d83444a" translate="yes" xml:space="preserve">
          <source>If it exits with non-zero status, then the working tree will not be committed after applying the patch.</source>
          <target state="translated">Если он выходит с ненулевым статусом,то после применения патча рабочее дерево не будет зафиксировано.</target>
        </trans-unit>
        <trans-unit id="769efb2c6e10769ef0506d8fb6e30821bd41e6ea" translate="yes" xml:space="preserve">
          <source>If it happens that one merge base is bad, then the bisection process is stopped with a message like:</source>
          <target state="translated">Если случается,что одна база слияния плохая,то бисекционный процесс останавливается с сообщением типа:</target>
        </trans-unit>
        <trans-unit id="d7b7066e9f3ba640d6b7d345ddda270a80c2a559" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;after&lt;/code&gt;, then each new trailer will appear just after the last trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">Если это будет &lt;code&gt;after&lt;/code&gt; , то каждый новый трейлер будет появляться сразу после последнего трейлера с тем же &amp;lt;token&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="f2bafbae3498cf1dc8b7c4f581b63d0bfa115d9a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;before&lt;/code&gt;, then each new trailer will appear just before the first trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">Если это &lt;code&gt;before&lt;/code&gt; , то каждый новый трейлер будет появляться непосредственно перед первым трейлером с тем же &amp;lt;token&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="76425e0a50de1913b3cc7557f216714041d9e64a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;end&lt;/code&gt;, then each new trailer will appear at the end of the existing trailers.</source>
          <target state="translated">Если это &lt;code&gt;end&lt;/code&gt; , то каждый новый трейлер будет появляться в конце существующих трейлеров.</target>
        </trans-unit>
        <trans-unit id="df34e468f7176e0de86a55be70b61c5f69c7697c" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;start&lt;/code&gt;, then each new trailer will appear at the start, instead of the end, of the existing trailers.</source>
          <target state="translated">Если это &lt;code&gt;start&lt;/code&gt; , то каждый новый трейлер будет появляться в начале, а не в конце существующих трейлеров.</target>
        </trans-unit>
        <trans-unit id="4def1637480df26c3310f2a04dde58c55a8e6a6e" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-fetch-pack will check all fetched objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">Если установлено значение true, git-fetch-pack проверит все извлеченные объекты. Смотрите &lt;code&gt;transfer.fsckObjects&lt;/code&gt; , что проверено. По умолчанию - false. Если не установлен, вместо него используется значение &lt;code&gt;transfer.fsckObjects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c85a90553a06232b5ee8a2aebb2a31cb696c1660" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-receive-pack will check all received objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">Если установлено значение true, git-receive-pack проверит все полученные объекты. Смотрите &lt;code&gt;transfer.fsckObjects&lt;/code&gt; , что проверено. По умолчанию - false. Если не установлен, вместо него используется значение &lt;code&gt;transfer.fsckObjects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f046c10bd7462cc956529dcbe0a86de2200086ed" translate="yes" xml:space="preserve">
          <source>If it turns out whatever you have done is worth keeping, you can always create a new name for it (without switching away):</source>
          <target state="translated">Если выяснится,что все,что вы сделали,стоит сохранить,вы всегда можете создать для него новое имя (не меняя его):</target>
        </trans-unit>
        <trans-unit id="4d0ff556eb63bcc0fd849ad26a1310c3a4323d31" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s not set, filesystem directory&amp;rsquo;s owner is used (via GECOS field, i.e. real name field from &lt;strong&gt;getpwuid&lt;/strong&gt;(3)) if &lt;code&gt;$projects_list&lt;/code&gt; is unset (gitweb scans &lt;code&gt;$projectroot&lt;/code&gt; for repositories); if &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of repositories, then project owner defaults to value from this file for given repository.</source>
          <target state="translated">Если он не установлен, используется владелец каталога файловой системы (через поле GECOS, т.е. поле реального имени из &lt;strong&gt;getpwuid&lt;/strong&gt; (3)), если &lt;code&gt;$projects_list&lt;/code&gt; не задано (gitweb сканирует &lt;code&gt;$projectroot&lt;/code&gt; предмет репозиториев); если &lt;code&gt;$projects_list&lt;/code&gt; указывает на файл со списком репозиториев, то владелец проекта по умолчанию использует значение из этого файла для данного репозитория.</target>
        </trans-unit>
        <trans-unit id="1cadf23ffce6eccc7a87c304031ef4b8e4d3adc6" translate="yes" xml:space="preserve">
          <source>If large offsets are required, we use another list of large offsets similar to version 2 pack-indexes.</source>
          <target state="translated">Если требуются большие смещения,мы используем другой список больших смещений,аналогичный пакету-индексам версии 2.</target>
        </trans-unit>
        <trans-unit id="960d179c1e161024bf740912a06839844c1002e6" translate="yes" xml:space="preserve">
          <source>If left to accumulate, these stale references might make performance worse on big and busy repos that have a lot of branch churn, and e.g. make the output of commands like &lt;code&gt;git branch -a --contains
&amp;lt;commit&amp;gt;&lt;/code&gt; needlessly verbose, as well as impacting anything else that&amp;rsquo;ll work with the complete set of known references.</source>
          <target state="translated">Если их оставить для накопления, эти устаревшие ссылки могут ухудшить производительность в больших и загруженных репозиториях, которые имеют много оттока ветвей, и, например, сделать вывод таких команд, как &lt;code&gt;git branch -a --contains &amp;lt;commit&amp;gt;&lt;/code&gt; излишне подробным, а также повлиять на все остальное, что будет работать с полным набором известных ссылок.</target>
        </trans-unit>
        <trans-unit id="703f6583148f1f4b148dcc92cca37187812e5840" translate="yes" xml:space="preserve">
          <source>If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; that name the branches at the remote named by &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; are consulted, and then they are mapped via &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; to their corresponding remote-tracking branches, and the tips of these tracking branches are merged.</source>
          <target state="translated">Если слияние вызывается без аргумента фиксации, объедините восходящие ветви, настроенные для текущей ветви, используя их последние наблюдаемые значения, хранящиеся в их ветвях удаленного отслеживания. Значения &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; которые называют ветки на удаленном компьютере, названном &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; , консультируются, а затем они отображаются через &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; на соответствующие удаленные- ветви отслеживания, и кончики этих ветвей отслеживания объединяются.</target>
        </trans-unit>
        <trans-unit id="115451ca901f83782dcbbcd683a49aed658e9f54" translate="yes" xml:space="preserve">
          <source>If more than one --branches (or --tags) option was given to the &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; command, you must provide the location of the branch (or tag) you wish to create in the SVN repository. &amp;lt;path&amp;gt; specifies which path to use to create the branch or tag and should match the pattern on the left-hand side of one of the configured branches or tags refspecs. You can see these refspecs with the commands</source>
          <target state="translated">Если команде &lt;code&gt;init&lt;/code&gt; или &lt;code&gt;clone&lt;/code&gt; задано более одной опции --branches (или --tags) , вы должны указать расположение ветки (или тега), которую вы хотите создать в репозитории SVN. &amp;lt;path&amp;gt; указывает, какой путь использовать для создания ветки или тега, и должен соответствовать шаблону в левой части одной из настроенных ветвей или тегов refspecs. Вы можете увидеть эти refspecs с помощью команд</target>
        </trans-unit>
        <trans-unit id="720d1ff370baad05fcb8565540994e450819ec63" translate="yes" xml:space="preserve">
          <source>If more than one suffixes match the same tagname, then that tagname will be sorted according to the suffix which starts at the earliest position in the tagname. If more than one different matching suffixes start at that earliest position, then that tagname will be sorted according to the longest of those suffixes. The sorting order between different suffixes is undefined if they are in multiple config files.</source>
          <target state="translated">Если несколько суффиксов совпадают с одним и тем же именем,то это имя будет отсортировано в соответствии с суффиксом,который начинается на самой ранней позиции в имени.Если более одного подходящего суффикса начинаются в этой самой ранней позиции,то это тигнаме будет отсортировано согласно самому длинному из этих суффиксов.Порядок сортировки между различными суффиксами не определен,если они находятся в нескольких конфигурационных файлах.</target>
        </trans-unit>
        <trans-unit id="e3ac1856f1f0f57064ddb5057de6638c24881f47" translate="yes" xml:space="preserve">
          <source>If multiple tags were found during the walk then the tag which has the fewest commits different from the input commit-ish will be selected and output. Here fewest commits different is defined as the number of commits which would be shown by &lt;code&gt;git log tag..input&lt;/code&gt; will be the smallest number of commits possible.</source>
          <target state="translated">Если во время обхода было обнаружено несколько тегов, то будет выбран и выведен тег, который имеет наименьшее количество фиксаций, отличных от входной фиксации. Здесь наименьшее количество различных &lt;code&gt;git log tag..input&lt;/code&gt; определяется как количество коммитов, которое будет отображаться тегом git log. Input будет наименьшим возможным количеством коммитов .</target>
        </trans-unit>
        <trans-unit id="a7822ac9c32ce308a5503a1fdd5fe89ff6cb69d3" translate="yes" xml:space="preserve">
          <source>If neither of the above exist then &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; is created and used by default. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is not set it defaults to &lt;code&gt;$HOME/.config&lt;/code&gt; in all cases.</source>
          <target state="translated">Если &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; из вышеперечисленного не существует, то по умолчанию создается и используется $ XDG_CONFIG_HOME / git / gitk . Если &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; не установлен, по умолчанию во всех случаях используется &lt;code&gt;$HOME/.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd81c5109f07b879105adf39e250a5f3aca1a356" translate="yes" xml:space="preserve">
          <source>If neither was used, but &lt;code&gt;--date&lt;/code&gt; was given on the command line, show the timestamp in the format requested by &lt;code&gt;--date&lt;/code&gt;.</source>
          <target state="translated">Если ни один из них не использовался, но в командной строке &lt;code&gt;--date&lt;/code&gt; , отобразить метку времени в формате, запрошенном параметром &lt;code&gt;--date&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3bb0635e00afaf46918027a40807c06a70ce207" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-A&lt;/code&gt; option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">Если при использовании опции &lt;code&gt;-A&lt;/code&gt; не указан &amp;lt;pathspec&amp;gt; , обновляются все файлы во всем рабочем дереве (старые версии Git использовались для ограничения обновления текущим каталогом и его подкаталогами).</target>
        </trans-unit>
        <trans-unit id="4b6e9bfea0c02571aea512af96edfe88c9715f04" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-u&lt;/code&gt; option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">Если при использовании параметра &lt;code&gt;-u&lt;/code&gt; не указан &amp;lt;pathspec&amp;gt; , обновляются все отслеживаемые файлы во всем рабочем дереве (старые версии Git использовались для ограничения обновления текущим каталогом и его подкаталогами).</target>
        </trans-unit>
        <trans-unit id="4b6d20762b018937bfcb3d137cde943022a33140" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;.</source>
          <target state="translated">Если не &lt;code&gt;--decorate-refs&lt;/code&gt; вид, будто все ссылки включены. Для каждого кандидата не используйте его для украшения, если он соответствует каким-либо шаблонам, заданным для &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; , или если он не соответствует ни одному из шаблонов, заданных для &lt;code&gt;--decorate-refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7cc86d2479ae0db7a8477b9df1f3902cf870395" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;. The &lt;code&gt;log.excludeDecoration&lt;/code&gt; config option allows excluding refs from the decorations, but an explicit &lt;code&gt;--decorate-refs&lt;/code&gt; pattern will override a match in &lt;code&gt;log.excludeDecoration&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2ed2d5d960c224ec529b5f6156261c52081093" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-b&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-b&lt;/code&gt; in such a case.</source>
          <target state="translated">Если не задана опция &lt;code&gt;-b&lt;/code&gt; , имя новой ветки будет получено из ветки удаленного отслеживания, просмотрев локальную часть refspec, настроенную для соответствующего удаленного устройства, а затем удалив начальную часть до &quot;* &amp;raquo;. Это говорит нам использовать &lt;code&gt;hack&lt;/code&gt; в качестве локальной ветки при ответвлении от &lt;code&gt;origin/hack&lt;/code&gt; (или &lt;code&gt;remotes/origin/hack&lt;/code&gt; , или даже &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; ). Если данное имя не имеет косой черты или указанное выше угадывание приводит к пустому имени, угадывание прерывается. В таком случае вы можете явно указать имя с помощью &lt;code&gt;-b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b362c22d46cf3c9ce26cb952c31ebfa05896260" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-c&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-c&lt;/code&gt; in such a case.</source>
          <target state="translated">Если не задана опция &lt;code&gt;-c&lt;/code&gt; , имя новой ветки будет получено из ветки удаленного отслеживания путем просмотра локальной части refspec, настроенной для соответствующего удаленного устройства, а затем удаления начальной части до &quot;* &amp;raquo;. Это говорит нам использовать &lt;code&gt;hack&lt;/code&gt; в качестве локальной ветки при ответвлении от &lt;code&gt;origin/hack&lt;/code&gt; (или &lt;code&gt;remotes/origin/hack&lt;/code&gt; , или даже &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; ). Если данное имя не имеет косой черты или указанное выше угадывание приводит к пустому имени, угадывание прерывается. В таком случае вы можете явно указать имя с помощью &lt;code&gt;-c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5eb9ed53cf409691a2adb1a958e7a2a354184a7" translate="yes" xml:space="preserve">
          <source>If no branch is specified and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; is used, then &lt;code&gt;git worktree add&lt;/code&gt; defaults to creating a new branch from HEAD. If &lt;code&gt;worktree.guessRemote&lt;/code&gt; is set to true, &lt;code&gt;worktree add&lt;/code&gt; tries to find a remote-tracking branch whose name uniquely matches the new branch name. If such a branch exists, it is checked out and set as &quot;upstream&quot; for the new branch. If no such match can be found, it falls back to creating a new branch from the current HEAD.</source>
          <target state="translated">Если ветка не указана и не используются ни &lt;code&gt;-b&lt;/code&gt; , ни &lt;code&gt;-B&lt;/code&gt; , ни &lt;code&gt;--detach&lt;/code&gt; , то &lt;code&gt;git worktree add&lt;/code&gt; значения по умолчанию для создания новой ветки из HEAD. Если &lt;code&gt;worktree.guessRemote&lt;/code&gt; имеет значение true, &lt;code&gt;worktree add&lt;/code&gt; пытается найти ветвь удаленного отслеживания, имя которой однозначно совпадает с именем новой ветки. Если такая ветка существует, она проверяется и устанавливается как &amp;laquo;восходящая&amp;raquo; для новой ветки. Если такое совпадение не может быть найдено, он возвращается к созданию новой ветви из текущего HEAD.</target>
        </trans-unit>
        <trans-unit id="cd840721ca4f2ba5f348ba0cdeddc96e7d47ba2a" translate="yes" xml:space="preserve">
          <source>If no command-line option is passed, the &lt;code&gt;help.format&lt;/code&gt; configuration variable will be checked. The following values are supported for this variable; they make &lt;code&gt;git help&lt;/code&gt; behave as their corresponding command- line option:</source>
          <target state="translated">Если параметр командной строки не передан, будет проверена переменная конфигурации &lt;code&gt;help.format&lt;/code&gt; . Для этой переменной поддерживаются следующие значения; они заставляют &lt;code&gt;git help&lt;/code&gt; работать как соответствующий параметр командной строки:</target>
        </trans-unit>
        <trans-unit id="48f09dc10a5152e65a114506d3daba225636a70e" translate="yes" xml:space="preserve">
          <source>If no commit ID is found, &lt;code&gt;git get-tar-commit-id&lt;/code&gt; quietly exists with a return code of 1. This can happen if the archive had not been created using &lt;code&gt;git archive&lt;/code&gt; or if the first parameter of &lt;code&gt;git archive&lt;/code&gt; had been a tree ID instead of a commit ID or tag.</source>
          <target state="translated">Если идентификатор фиксации не найден, &lt;code&gt;git get-tar-commit-id&lt;/code&gt; спокойно существует с кодом возврата 1. Это может произойти, если архив не был создан с помощью &lt;code&gt;git archive&lt;/code&gt; или если первым параметром &lt;code&gt;git archive&lt;/code&gt; был идентификатор дерева. вместо идентификатора фиксации или тега.</target>
        </trans-unit>
        <trans-unit id="daf3aead6a5bfcff96ae9ec0da48e9d2be49b75e" translate="yes" xml:space="preserve">
          <source>If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page.</source>
          <target state="translated">Если фиксация из командной строки не задана,слить удалённые отслеживаемые ветки,которые текущая ветка настроена на использование в качестве восходящей.См.также раздел конфигурации на этой странице руководства.</target>
        </trans-unit>
        <trans-unit id="7188b50eb220f479115e7bb7b4e8a6b937273e6f" translate="yes" xml:space="preserve">
          <source>If no format is specified, the default format is &lt;code&gt;%(objectname)
%(objecttype) %(objectsize)&lt;/code&gt;.</source>
          <target state="translated">Если формат не указан, по умолчанию используется формат &lt;code&gt;%(objectname) %(objecttype) %(objectsize)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e72375796417844d20df5e1c264d965559c3c0c9" translate="yes" xml:space="preserve">
          <source>If no further options are given, all reading options will read all of these files that are available. If the global or the system-wide configuration file are not available they will be ignored. If the repository configuration file is not available or readable, &lt;code&gt;git config&lt;/code&gt; will exit with a non-zero error code. However, in neither case will an error message be issued.</source>
          <target state="translated">Если другие параметры не указаны, все параметры чтения будут читать все доступные файлы. Если глобальный или общесистемный файл конфигурации недоступен, они будут проигнорированы. Если файл конфигурации репозитория недоступен или недоступен для чтения, &lt;code&gt;git config&lt;/code&gt; завершит работу с ненулевым кодом ошибки. Однако ни в том, ни в другом случае сообщение об ошибке не выводится.</target>
        </trans-unit>
        <trans-unit id="542c100edd4ea5b59ab171a7795bc617673af483" translate="yes" xml:space="preserve">
          <source>If no objects are given, &lt;code&gt;git fsck&lt;/code&gt; defaults to using the index file, all SHA-1 references in &lt;code&gt;refs&lt;/code&gt; namespace, and all reflogs (unless --no-reflogs is given) as heads.</source>
          <target state="translated">Если объекты не указаны, &lt;code&gt;git fsck&lt;/code&gt; по умолчанию использует индексный файл, все ссылки SHA-1 в пространстве имен &lt;code&gt;refs&lt;/code&gt; и все рефлоги (если не указан --no-reflogs) в качестве заголовков.</target>
        </trans-unit>
        <trans-unit id="3ac71fd77839914951c054588c999a4a8ef138ac" translate="yes" xml:space="preserve">
          <source>If no revisions are passed on the command line and either standard input is not a terminal or there is no current branch, &lt;code&gt;git shortlog&lt;/code&gt; will output a summary of the log read from standard input, without reference to the current repository.</source>
          <target state="translated">Если в командной строке не передаются никакие ревизии и либо стандартный ввод не является терминалом, либо отсутствует текущая ветвь, &lt;code&gt;git shortlog&lt;/code&gt; выведет сводку журнала, прочитанного из стандартного ввода, без ссылки на текущий репозиторий.</target>
        </trans-unit>
        <trans-unit id="abf7234009b8e35c90eeb194fcd9fd8cfced1763" translate="yes" xml:space="preserve">
          <source>If no username is set for a network authentication, use this username by default. See credential.&amp;lt;context&amp;gt;.* below, and &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt;.</source>
          <target state="translated">Если для сетевой аутентификации не задано имя пользователя, используйте это имя пользователя по умолчанию. См. &lt;a href=&quot;gitcredentials&quot;&gt;Учетные&lt;/a&gt; данные. &amp;lt;context&amp;gt;. * Ниже и gitcredentials [7] .</target>
        </trans-unit>
        <trans-unit id="68bd2465b7813ae05686685c60e9c1221c412754" translate="yes" xml:space="preserve">
          <source>If non-zero, all packs larger than this limit are kept when &lt;code&gt;git gc&lt;/code&gt; is run. This is very similar to &lt;code&gt;--keep-base-pack&lt;/code&gt; except that all packs that meet the threshold are kept, not just the base pack. Defaults to zero. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">Если ненулевое значение, все пакеты, превышающие этот предел, сохраняются при запуске &lt;code&gt;git gc&lt;/code&gt; . Это очень похоже на &lt;code&gt;--keep-base-pack&lt;/code&gt; , за исключением того, что сохраняются все пакеты, соответствующие пороговому значению, а не только базовый пакет. По умолчанию равно нулю. Поддерживаются общие суффиксы единиц измерения &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; или &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35c0dd1514e6236cb81ffc0d16969826106d45e0" translate="yes" xml:space="preserve">
          <source>If non-zero, all packs larger than this limit are kept when &lt;code&gt;git gc&lt;/code&gt; is run. This is very similar to &lt;code&gt;--keep-largest-pack&lt;/code&gt; except that all packs that meet the threshold are kept, not just the largest pack. Defaults to zero. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f929e50dc4409c5d26df44de311be2ffed8079" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;--stdin&lt;/code&gt;, &lt;code&gt;--all&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; is used, the first argument will be treated as an attribute and the rest of the arguments as pathnames.</source>
          <target state="translated">Если ни один из параметров &lt;code&gt;--stdin&lt;/code&gt; , &lt;code&gt;--all&lt;/code&gt; или &lt;code&gt;--&lt;/code&gt; не используется, первый аргумент будет рассматриваться как атрибут, а остальные аргументы - как пути.</target>
        </trans-unit>
        <trans-unit id="af13390230f0ed2d9d7a8cd452e31841984f2fea" translate="yes" xml:space="preserve">
          <source>If not set (default), it means that this feature is disabled.</source>
          <target state="translated">Если эта функция не установлена (по умолчанию),это означает,что она отключена.</target>
        </trans-unit>
        <trans-unit id="ffeb0befbf6f99dd0616072c3aff8f91a09da3dd" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are four files where &lt;code&gt;git config&lt;/code&gt; will search for configuration options:</source>
          <target state="translated">Если не задано явно с помощью &lt;code&gt;--file&lt;/code&gt; , есть четыре файла, в которых &lt;code&gt;git config&lt;/code&gt; будет искать параметры конфигурации:</target>
        </trans-unit>
        <trans-unit id="42b0a7358d3a7018936abd1faefcf6d947a2a30c" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are two files where git-credential-store will search for credentials in order of precedence:</source>
          <target state="translated">Если не задано явно с помощью &lt;code&gt;--file&lt;/code&gt; , есть два файла, в которых git-credential-store будет искать учетные данные в порядке приоритета:</target>
        </trans-unit>
        <trans-unit id="7dcc101d67cdfa1a1e655970a079699595239b44" translate="yes" xml:space="preserve">
          <source>If not set in the environment, the list of notes to copy depends on the &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; and &lt;code&gt;notes.rewriteRef&lt;/code&gt; settings.</source>
          <target state="translated">Если не задан в среде, список копируемых заметок зависит от параметров &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; и &lt;code&gt;notes.rewriteRef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="324a704070b71849b1d4e1ca6f933c2b17a7a16e" translate="yes" xml:space="preserve">
          <source>If not specified, the contents are restored from &lt;code&gt;HEAD&lt;/code&gt; if &lt;code&gt;--staged&lt;/code&gt; is given, otherwise from the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f85a49fbdf8e068a215ef9d6f0bd6bbfeb7a4e" translate="yes" xml:space="preserve">
          <source>If not specified, the default restore source for the working tree is the index, and the default restore source for the index is &lt;code&gt;HEAD&lt;/code&gt;. When both &lt;code&gt;--staged&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; are specified, &lt;code&gt;--source&lt;/code&gt; must also be specified.</source>
          <target state="translated">Если не указано иное, источником восстановления по умолчанию для рабочего дерева является индекс, а источником восстановления по умолчанию для индекса является &lt;code&gt;HEAD&lt;/code&gt; . Если &lt;code&gt;--staged&lt;/code&gt; и &lt;code&gt;--worktree&lt;/code&gt; , и &lt;code&gt;--source&lt;/code&gt; необходимо также указать --source .</target>
        </trans-unit>
        <trans-unit id="56d3a4f46f938bb42b1fca6d786b8e7fc54bbe14" translate="yes" xml:space="preserve">
          <source>If nothing matches, &lt;code&gt;git show-ref&lt;/code&gt; will return an error code of 1, and in the case of verification, it will show an error message.</source>
          <target state="translated">Если ничего не подходит, &lt;code&gt;git show-ref&lt;/code&gt; вернет код ошибки 1, а в случае проверки покажет сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="b1f5a8844fabfc412b2762d5d95a3c4d967624ca" translate="yes" xml:space="preserve">
          <source>If one of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is passed, the command creates a &lt;code&gt;tag&lt;/code&gt; object, and requires a tag message. Unless &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given, an editor is started for the user to type in the tag message.</source>
          <target state="translated">Если передается один из &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; или &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; , команда создает объект &lt;code&gt;tag&lt;/code&gt; и требует сообщения тега. Если не указано &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; или &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; , запускается редактор, чтобы пользователь мог ввести сообщение тега.</target>
        </trans-unit>
        <trans-unit id="2202ccf1357459c2102fac8580d0b9c370cb2843" translate="yes" xml:space="preserve">
          <source>If one or more &amp;lt;file&amp;gt; parameters are given, the merge tool program will be run to resolve differences on each file (skipping those without conflicts). Specifying a directory will include all unresolved files in that path. If no &amp;lt;file&amp;gt; names are specified, &lt;code&gt;git mergetool&lt;/code&gt; will run the merge tool program on every file with merge conflicts.</source>
          <target state="translated">Если указан один или несколько параметров &amp;lt;file&amp;gt;, программа инструмента слияния будет запущена для устранения различий в каждом файле (пропуская те, которые не содержат конфликтов). Указание каталога будет включать все неразрешенные файлы в этом пути. Если имена &amp;lt;file&amp;gt; не указаны, &lt;code&gt;git mergetool&lt;/code&gt; запустит программу инструмента слияния для каждого файла с конфликтами слияния.</target>
        </trans-unit>
        <trans-unit id="ce7c35e9da7a7a12641957ffb2984ef7917b0e3e" translate="yes" xml:space="preserve">
          <source>If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash.</source>
          <target state="translated">Если приведен один или более шаблонов,то показываются только ссылки,совпадающие по крайней мере с одним шаблоном,либо с помощью fnmatch(3),либо буквально,в последнем случае совпадающие полностью или от начала до косой черты.</target>
        </trans-unit>
        <trans-unit id="d335af2a37a580d9863e5a06bbfa0d646026268f" translate="yes" xml:space="preserve">
          <source>If one wishes to use the ref &lt;code&gt;ref/notes/true&lt;/code&gt;, please use that literal instead.</source>
          <target state="translated">Если кто-то желает использовать ref &lt;code&gt;ref/notes/true&lt;/code&gt; , используйте вместо этого этот литерал.</target>
        </trans-unit>
        <trans-unit id="c90c8ad16602dc9d2f205c9d917c69aa3c723c01" translate="yes" xml:space="preserve">
          <source>If only &amp;lt;infd&amp;gt; is given, it is assumed to be a bidirectional socket connected to remote Git server (git-upload-pack, git-receive-pack or git-upload-archive). If both &amp;lt;infd&amp;gt; and &amp;lt;outfd&amp;gt; are given, they are assumed to be pipes connected to a remote Git server (&amp;lt;infd&amp;gt; being the inbound pipe and &amp;lt;outfd&amp;gt; being the outbound pipe.</source>
          <target state="translated">Если указан только &amp;lt;infd&amp;gt;, предполагается, что это двунаправленный сокет, подключенный к удаленному серверу Git (git-upload-pack, git-receive-pack или git-upload-archive). Если заданы и &amp;lt;infd&amp;gt;, и &amp;lt;outfd&amp;gt;, предполагается, что они являются каналами, подключенными к удаленному серверу Git (&amp;lt;infd&amp;gt; является входящим каналом, а &amp;lt;outfd&amp;gt; - исходящим каналом.</target>
        </trans-unit>
        <trans-unit id="ce722a3060a9ef1801cda4fdb7cc3661d10ec67c" translate="yes" xml:space="preserve">
          <source>If only 1 tree is specified, &lt;code&gt;git read-tree&lt;/code&gt; operates as if the user did not specify &lt;code&gt;-m&lt;/code&gt;, except that if the original index has an entry for a given pathname, and the contents of the path match with the tree being read, the stat info from the index is used. (In other words, the index&amp;rsquo;s stat()s take precedence over the merged tree&amp;rsquo;s).</source>
          <target state="translated">Если указано только 1 дерево, &lt;code&gt;git read-tree&lt;/code&gt; работает так, как если бы пользователь не указал &lt;code&gt;-m&lt;/code&gt; , за исключением того, что если в исходном индексе есть запись для данного имени пути, и содержимое пути совпадает с читаемым деревом, Статистическая информация из индекса используется. (Другими словами, stat () индекса имеют приоритет над объединенным деревом).</target>
        </trans-unit>
        <trans-unit id="ed44ceba40face622ee83aefe1801bafac3f799c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;check-connectivity&lt;/code&gt; is requested, the helper must output &lt;code&gt;connectivity-ok&lt;/code&gt; if the clone is self-contained and connected.</source>
          <target state="translated">Если запрошена опция &lt;code&gt;check-connectivity&lt;/code&gt; , помощник должен вывести &lt;code&gt;connectivity-ok&lt;/code&gt; если клон является самодостаточным и подключен.</target>
        </trans-unit>
        <trans-unit id="d94f0028bb24f94910f79bf2b787bad6af3cf852" translate="yes" xml:space="preserve">
          <source>If other people are pulling from your repository over dumb transport protocols (HTTP), you need to keep this repository &lt;code&gt;dumb transport friendly&lt;/code&gt;. After &lt;code&gt;git init&lt;/code&gt;, &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; copied from the standard templates would contain a call to &lt;code&gt;git update-server-info&lt;/code&gt; but you need to manually enable the hook with &lt;code&gt;mv post-update.sample post-update&lt;/code&gt;. This makes sure &lt;code&gt;git update-server-info&lt;/code&gt; keeps the necessary files up to date.</source>
          <target state="translated">Если другие люди извлекают данные из вашего репозитория по немым транспортным протоколам (HTTP), вам необходимо сохранить этот репозиторий &lt;code&gt;dumb transport friendly&lt;/code&gt; . После &lt;code&gt;git init&lt;/code&gt; , &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; скопированный из стандартных шаблонов, будет содержать вызов &lt;code&gt;git update-server-info&lt;/code&gt; , но вам нужно вручную включить ловушку с &lt;code&gt;mv post-update.sample post-update&lt;/code&gt; . Это гарантирует, что &lt;code&gt;git update-server-info&lt;/code&gt; поддерживает необходимые файлы в актуальном состоянии.</target>
        </trans-unit>
        <trans-unit id="e17148a8f3d2ab81971460344696589bc00ec7fe" translate="yes" xml:space="preserve">
          <source>If provided, the results are limited to a subset of files matching one of the provided pathspecs.</source>
          <target state="translated">Если они предоставляются,то результаты ограничиваются подмножеством файлов,соответствующих одному из предоставленных pathspecs.</target>
        </trans-unit>
        <trans-unit id="c6bf36e1017847984a394e553be49b7f1e0149c6" translate="yes" xml:space="preserve">
          <source>If separate &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; commands are used in a &lt;code&gt;commit&lt;/code&gt; the timestamps may not match, as the system clock will be polled twice (once for each command). The only way to ensure that both author and committer identity information has the same timestamp is to omit &lt;code&gt;author&lt;/code&gt; (thus copying from &lt;code&gt;committer&lt;/code&gt;) or to use a date format other than &lt;code&gt;now&lt;/code&gt;.</source>
          <target state="translated">Если отдельный &lt;code&gt;author&lt;/code&gt; и &lt;code&gt;committer&lt;/code&gt; команда используется в &lt;code&gt;commit&lt;/code&gt; метка время , может не совпадать, так как системные часы будут опрошены дважды (один раз для каждой команды). Единственный способ гарантировать, что идентификационная информация автора и коммиттера имеет одну и ту же временную метку, - это опустить &lt;code&gt;author&lt;/code&gt; (таким образом, скопировать из &lt;code&gt;committer&lt;/code&gt; ) или использовать формат даты, отличный от &lt;code&gt;now&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="866d5a5839fdc5ae41f48af4bbd37789bc250691" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;--base=auto&lt;/code&gt; in cmdline, it will track base commit automatically, the base commit will be the merge base of tip commit of the remote-tracking branch and revision-range specified in cmdline. For a local branch, you need to track a remote branch by &lt;code&gt;git branch
--set-upstream-to&lt;/code&gt; before using this option.</source>
          <target state="translated">Если установить &lt;code&gt;--base=auto&lt;/code&gt; в cmdline, он будет отслеживать базовую фиксацию автоматически, базовая фиксация будет базой слияния фиксации подсказки ветки удаленного отслеживания и диапазона ревизий, указанного в cmdline. Для локальной ветки вам необходимо отследить удаленную ветку с помощью &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; прежде чем использовать эту опцию.</target>
        </trans-unit>
        <trans-unit id="c4e55e2ff9b8cf62b34b50d7d6b4a09bd94fb5d9" translate="yes" xml:space="preserve">
          <source>If set to &quot;auto&quot;, &lt;code&gt;git-commit&lt;/code&gt; would select a character that is not the beginning character of any line in existing commit messages.</source>
          <target state="translated">Если установлено значение &amp;laquo;auto&amp;raquo;, &lt;code&gt;git-commit&lt;/code&gt; выберет символ, который не является начальным символом какой-либо строки в существующих сообщениях фиксации.</target>
        </trans-unit>
        <trans-unit id="26543a57c821840599fb24538b1a26d2383ded69" translate="yes" xml:space="preserve">
          <source>If set to &quot;true&quot;, it is equivalent to specifying &lt;code&gt;--force-if-includes&lt;/code&gt; as an option to &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; in the command line. Adding &lt;code&gt;--no-force-if-includes&lt;/code&gt; at the time of push overrides this configuration setting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb1da898d09757c537ab553b3fe27d9de1953ee" translate="yes" xml:space="preserve">
          <source>If set to &quot;warn&quot;, git rebase -i will print a warning if some commits are removed (e.g. a line was deleted), however the rebase will still proceed. If set to &quot;error&quot;, it will print the previous warning and stop the rebase, &lt;code&gt;git rebase --edit-todo&lt;/code&gt; can then be used to correct the error. If set to &quot;ignore&quot;, no checking is done. To drop a commit without warning or error, use the &lt;code&gt;drop&lt;/code&gt; command in the todo list. Defaults to &quot;ignore&quot;.</source>
          <target state="translated">Если установлено значение &amp;laquo;warn&amp;raquo;, git rebase -i будет выводить предупреждение, если некоторые коммиты удалены (например, была удалена строка), однако перебазирование все равно продолжится. Если установлено значение &amp;laquo;error&amp;raquo;, он напечатает предыдущее предупреждение и остановит перебазирование, затем можно использовать &lt;code&gt;git rebase --edit-todo&lt;/code&gt; для исправления ошибки. Если установлено &amp;laquo;игнорировать&amp;raquo;, проверка не выполняется. Чтобы удалить фиксацию без предупреждения или ошибки, используйте команду &lt;code&gt;drop&lt;/code&gt; в списке задач. По умолчанию &amp;laquo;игнорировать&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ac8b0270c3c47d08febdcf04811ec5325e6bcef3" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;0&lt;/code&gt;, Git will complete any requested operation without performing any optional sub-operations that require taking a lock. For example, this will prevent &lt;code&gt;git status&lt;/code&gt; from refreshing the index as a side effect. This is useful for processes running in the background which do not want to cause lock contention with other operations on the repository. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;0&lt;/code&gt; , Git завершит любую запрошенную операцию без выполнения каких-либо дополнительных подопераций, требующих блокировки. Например, это предотвратит обновление индекса &lt;code&gt;git status&lt;/code&gt; в качестве побочного эффекта. Это полезно для процессов, работающих в фоновом режиме, которые не хотят вызывать конфликт блокировок с другими операциями в репозитории. По умолчанию &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d1e5156e1d430a4750260179109e036962ca85d" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;1&lt;/code&gt;, include broken or badly named refs when iterating over lists of refs. In a normal, non-corrupted repository, this does nothing. However, enabling it may help git to detect and abort some operations in the presence of broken refs. Git sets this variable automatically when performing destructive operations like &lt;a href=&quot;git-prune&quot;&gt;git-prune[1]&lt;/a&gt;. You should not need to set it yourself unless you want to be paranoid about making sure an operation has touched every ref (e.g., because you are cloning a repository to make a backup).</source>
          <target state="translated">Если установлено в &lt;code&gt;1&lt;/code&gt; , включать неработающие или плохо названные ссылки при итерации по спискам ссылок. В нормальном, неповрежденном репозитории это ничего не делает. Однако его включение может помочь git обнаруживать и прерывать некоторые операции при наличии неработающих ссылок. Git устанавливает эту переменную автоматически при выполнении деструктивных операций, таких как &lt;a href=&quot;git-prune&quot;&gt;git-prune [1]&lt;/a&gt; . Вам не нужно устанавливать его самостоятельно, если вы не хотите быть параноиком в отношении того, чтобы операция коснулась каждой ссылки (например, потому что вы клонируете репозиторий для создания резервной копии).</target>
        </trans-unit>
        <trans-unit id="721e268a3bbca2372f644ef6baf34d6bc14a8b54" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, behave as if the &lt;code&gt;--no-replace-objects&lt;/code&gt; option was given on the command line. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; and &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for more information.</source>
          <target state="translated">Если установлено значение &lt;code&gt;false&lt;/code&gt; , вести себя так, как если бы в командной строке была указана опция &lt;code&gt;--no-replace-objects&lt;/code&gt; . См. &lt;a href=&quot;git&quot;&gt;Git [1]&lt;/a&gt; и &lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="0f2d027bcde6fa30d6f1d075f8f588cf0e958fbb" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git diff&lt;/code&gt; does not show changes outside of the directory and show pathnames relative to the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c80e3d63d134dccb3136c655fb06b3aa0219fb0" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;yes&lt;/code&gt;, print an ellipsis following an (abbreviated) SHA-1 value. This affects indications of detached HEADs (&lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;) and the raw diff output (&lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;). Printing an ellipsis in the cases mentioned is no longer considered adequate and support for it is likely to be removed in the foreseeable future (along with the variable).</source>
          <target state="translated">Если установлено значение &amp;laquo; &lt;code&gt;yes&lt;/code&gt; , выведите многоточие после (сокращенного) значения SHA-1. Это влияет на индикацию отсоединенных HEAD ( &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; ) и необработанный вывод diff ( &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; ). Вывод многоточия в упомянутых случаях больше не считается адекватным, и его поддержка, вероятно, будет удалена в обозримом будущем (вместе с переменной).</target>
        </trans-unit>
        <trans-unit id="03e97ab625ba0ca85ff94dae74e07745d32e9ba5" translate="yes" xml:space="preserve">
          <source>If set to a colon-separated list of protocols, behave as if &lt;code&gt;protocol.allow&lt;/code&gt; is set to &lt;code&gt;never&lt;/code&gt;, and each of the listed protocols has &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; set to &lt;code&gt;always&lt;/code&gt; (overriding any existing configuration). In other words, any protocol not mentioned will be disallowed (i.e., this is a whitelist, not a blacklist). See the description of &lt;code&gt;protocol.allow&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">Если задан список протоколов, разделенных двоеточиями, вести себя так, как если бы для параметра &lt;code&gt;protocol.allow&lt;/code&gt; задано значение &lt;code&gt;never&lt;/code&gt; , и для каждого из перечисленных протоколов параметр &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; установлен в значение &lt;code&gt;always&lt;/code&gt; (отменяет любую существующую конфигурацию). Другими словами, любой протокол, не упомянутый, будет запрещен (т.е. это белый список, а не черный список). См. Описание &lt;code&gt;protocol.allow&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="3efcc8bea067f2176f4b0bb44941378607e1ec05" translate="yes" xml:space="preserve">
          <source>If set to an algorithm, indicate that the caller wants to interact with the remote side using that algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d02bbac09e65cccb0fb85d779cd5ffdc25f0fea6" translate="yes" xml:space="preserve">
          <source>If set to either a valid &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; or a true value, moved lines in a diff are colored differently, for details of valid modes see &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. If simply set to true the default color mode will be used. When set to false, moved lines are not colored.</source>
          <target state="translated">Если установлено действительное значение &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; или истинное значение, перемещенные строки в diff окрашиваются по-разному, подробности о допустимых режимах см. &lt;code&gt;--color-moved&lt;/code&gt; в &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; . Если просто установить значение true, будет использоваться цветовой режим по умолчанию. Если установлено значение false, перемещенные линии не окрашиваются.</target>
        </trans-unit>
        <trans-unit id="d2017527381afe3327ef07745ea82e7ee1e2ae55" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--autosquash&lt;/code&gt; option by default.</source>
          <target state="translated">Если установлено значение true, по умолчанию &lt;code&gt;--autosquash&lt;/code&gt; опция --autosquash .</target>
        </trans-unit>
        <trans-unit id="7630a0d058d7490b6c2c7394afc94b9292f8389f" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--follow-tags&lt;/code&gt; option by default. You may override this configuration at time of push by specifying &lt;code&gt;--no-follow-tags&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение true, по умолчанию включается &lt;code&gt;--follow-tags&lt;/code&gt; . Вы можете переопределить эту конфигурацию во время отправки, указав &lt;code&gt;--no-follow-tags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64fe3b4eafd82bc5365512adbc156f5096a46d37" translate="yes" xml:space="preserve">
          <source>If set to true or &quot;refuse&quot;, git-receive-pack will deny a ref update to the currently checked out branch of a non-bare repository. Such a push is potentially dangerous because it brings the HEAD out of sync with the index and working tree. If set to &quot;warn&quot;, print a warning of such a push to stderr, but allow the push to proceed. If set to false or &quot;ignore&quot;, allow such pushes with no message. Defaults to &quot;refuse&quot;.</source>
          <target state="translated">Если установлено значение true или &quot;отказаться&quot;,git-receptive-pack будет отказывать в обновлении ref в текущей извлечённой ветке небогатого репозитория.Такой толчок потенциально опасен,поскольку он выводит HEAD из синхронизации с индексом и рабочим деревом.Если установлено значение &quot;warning&quot;,выведите предупреждение о таком толчке в stderr,но позвольте толчку продолжить.Если установлено значение &quot;false&quot; или &quot;ignore&quot;,разрешите такие толчки без сообщения.По умолчанию-&quot;отказаться&quot;.</target>
        </trans-unit>
        <trans-unit id="d09a3b8e56d92fdf26b71ac7a66610897ebf56ec" translate="yes" xml:space="preserve">
          <source>If set to true, .git/shallow can be updated when new refs require new shallow roots. Otherwise those refs are rejected.</source>
          <target state="translated">Если установлено значение true,то .git/shallow может обновляться,когда новые ссылки требуют новых неглубоких корней.В противном случае эти ссылки будут отклонены.</target>
        </trans-unit>
        <trans-unit id="54bb951308d4910fbcee8b759c22be8fe1cad2d9" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will display the number of entries currently stashed away. Defaults to false.</source>
          <target state="translated">Если установлено значение true, &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; будет отображать количество записей, спрятанных в данный момент. По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="3713c634b09bf65bc394c012cee94ba42c596b9c" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will insert a comment prefix before each output line (starting with &lt;code&gt;core.commentChar&lt;/code&gt;, i.e. &lt;code&gt;#&lt;/code&gt; by default). This was the behavior of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in Git 1.8.4 and previous. Defaults to false.</source>
          <target state="translated">Если установлено значение true, &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; будет вставлять префикс комментария перед каждой строкой вывода (начиная с &lt;code&gt;core.commentChar&lt;/code&gt; , т.е. &lt;code&gt;#&lt;/code&gt; по умолчанию). Это было поведение &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; в Git 1.8.4 и ранее. По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="9b89821396e7eac11e5ad2faf8d7540e7c67829b" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;code&gt;git rebase&lt;/code&gt; will use abbreviated command names in the todo list resulting in something like this:</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;git rebase&lt;/code&gt; будет использовать сокращенные имена команд в списке задач, что приведет к примерно следующему:</target>
        </trans-unit>
        <trans-unit id="a871da2391e5e77cb10a7b13bd4e3a7269114ee0" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would be considered equivalent to &lt;code&gt;.git&lt;/code&gt; on an HFS+ filesystem. Defaults to &lt;code&gt;true&lt;/code&gt; on Mac OS, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">Если установлено значение true, не разрешать проверку путей, которые будут считаться эквивалентными &lt;code&gt;.git&lt;/code&gt; в файловой системе HFS +. По умолчанию &lt;code&gt;true&lt;/code&gt; в Mac OS и &lt;code&gt;false&lt;/code&gt; в других местах.</target>
        </trans-unit>
        <trans-unit id="0b91b7e4dfffb3891da9de8dba8ed2d19154ae38" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would cause problems with the NTFS filesystem, e.g. conflict with 8.3 &quot;short&quot; names. Defaults to &lt;code&gt;true&lt;/code&gt; on Windows, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">Если установлено значение true, не разрешать проверку путей, которые могут вызвать проблемы с файловой системой NTFS, например, конфликт с &amp;laquo;короткими&amp;raquo; именами 8.3. По умолчанию в Windows установлено значение &lt;code&gt;true&lt;/code&gt; , в других - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54ccdbeca4965b6fc3cb17a6075d84092d7309ba" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--extended-regexp&lt;/code&gt; option by default. This option is ignored when the &lt;code&gt;grep.patternType&lt;/code&gt; option is set to a value other than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение true, по умолчанию &lt;code&gt;--extended-regexp&lt;/code&gt; опция --extended-regexp . Этот параметр игнорируется, если для параметра &lt;code&gt;grep.patternType&lt;/code&gt; установлено значение, отличное от &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30887a5524c263667737b125eed1b7397b4d3c85" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--full-name&lt;/code&gt; option by default.</source>
          <target state="translated">Если установлено значение true, по умолчанию &lt;code&gt;--full-name&lt;/code&gt; опция --full-name .</target>
        </trans-unit>
        <trans-unit id="a770bd77a59ee1eda1723cd39df7104106a40a38" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;-n&lt;/code&gt; option by default.</source>
          <target state="translated">Если установлено значение true, по умолчанию включена опция &lt;code&gt;-n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ae1bc4fce8b6029e6cbb4c5d0167ebeeaacf37d" translate="yes" xml:space="preserve">
          <source>If set to true, enable the &lt;code&gt;--column&lt;/code&gt; option by default.</source>
          <target state="translated">Если установлено значение true, по умолчанию включите параметр &lt;code&gt;--column&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f2144fe2d27e9e20f68c9036ebab8459a790815" translate="yes" xml:space="preserve">
          <source>If set to true, fall back to git grep --no-index if git grep is executed outside of a git repository. Defaults to false.</source>
          <target state="translated">Если установлено в true,вернитесь к git grep --no-index,если git grep выполняется за пределами git-репозитория.По умолчанию равно false.</target>
        </trans-unit>
        <trans-unit id="25ad8c4a959eb80b90f95ddbc01fcd1f2b16d26e" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the currently checked out branch of a non-bare repository.</source>
          <target state="translated">Если установлено значение true,git-receive-pack будет отрицать обновление ref,которое удаляет текущую извлечённую ветку небогатого репозитория.</target>
        </trans-unit>
        <trans-unit id="f7f0fff426d74ea17456c56eae07f347498018a4" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the ref. Use this to prevent such a ref deletion via a push.</source>
          <target state="translated">Если установлено значение true,то git-receive-pack будет отказывать в обновлении ссылки,которое удаляет ссылку.Используйте эту опцию,чтобы предотвратить такое удаление ссылки при нажатии.</target>
        </trans-unit>
        <trans-unit id="bc6468d5687d1713aadc8dfe39af8a6b8a9b584c" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update which is not a fast-forward. Use this to prevent such an update via a push, even if that push is forced. This configuration variable is set when initializing a shared repository.</source>
          <target state="translated">Если установлено значение true,то git-receive-pack будет отказывать в обновлении ref,которое не является быстрым перемотчиком.Используйте эту опцию,чтобы предотвратить такое обновление с помощью нажатия,даже если оно происходит принудительно.Эта конфигурационная переменная устанавливается при инициализации общего репозитория.</target>
        </trans-unit>
        <trans-unit id="aa5f05e34699c4bff5b25fced7ce1653e77528d2" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will run git-update-server-info after receiving data from git-push and updating refs.</source>
          <target state="translated">Если установлено в true,то git-receive-pack будет запускать git-update-серверную информацию после получения данных от git-push и обновления ссылок.</target>
        </trans-unit>
        <trans-unit id="875b965a1988574b490477056983b56357db9a5f" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--delta-islands&lt;/code&gt; was passed. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;git repack&lt;/code&gt; действует так, как если &lt;code&gt;--delta-islands&lt;/code&gt; был передан параметр --delta-Islands . По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a3fff86e688774493783e955a40569a2b6cd00b" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--pack-kept-objects&lt;/code&gt; was passed. See &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;false&lt;/code&gt; normally, but &lt;code&gt;true&lt;/code&gt; if a bitmap index is being written (either via &lt;code&gt;--write-bitmap-index&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;).</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;git repack&lt;/code&gt; действует так, как если бы был &lt;code&gt;--pack-kept-objects&lt;/code&gt; . Подробнее см. &lt;a href=&quot;git-repack&quot;&gt;Git-repack [1]&lt;/a&gt; . По умолчанию обычно имеет значение &lt;code&gt;false&lt;/code&gt; , но &lt;code&gt;true&lt;/code&gt; если записывается индекс растрового изображения (либо через &lt;code&gt;--write-bitmap-index&lt;/code&gt; , либо через &lt;code&gt;repack.writeBitmaps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4685adbf82f5fe84483ac0a4116dbb7a4fa6307" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; does not show any source or destination prefix.</source>
          <target state="translated">Если установлено, &lt;code&gt;git diff&lt;/code&gt; не показывает префиксы источника или назначения.</target>
        </trans-unit>
        <trans-unit id="407c23ddaf3ebfe9c20e0dd5ae2fc627eb8b4502" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; uses a prefix pair that is different from the standard &quot;a/&quot; and &quot;b/&quot; depending on what is being compared. When this configuration is in effect, reverse diff output also swaps the order of the prefixes:</source>
          <target state="translated">Если установлено, &lt;code&gt;git diff&lt;/code&gt; использует пару префиксов, отличную от стандартных &amp;laquo;a /&amp;raquo; и &amp;laquo;b /&amp;raquo;, в зависимости от того, что сравнивается. Когда действует эта конфигурация, вывод обратного сравнения также меняет порядок префиксов:</target>
        </trans-unit>
        <trans-unit id="ce70dfc2b2921383247fcc52103661d4583ff009" translate="yes" xml:space="preserve">
          <source>If set, by default &quot;git config&quot; reads from both &quot;config&quot; and &quot;config.worktree&quot; file from GIT_DIR in that order. In multiple working directory mode, &quot;config&quot; file is shared while &quot;config.worktree&quot; is per-working directory (i.e., it&amp;rsquo;s in GIT_COMMON_DIR/worktrees/&amp;lt;id&amp;gt;/config.worktree)</source>
          <target state="translated">Если установлено, по умолчанию &amp;laquo;git config&amp;raquo; читает файлы &amp;laquo;config&amp;raquo; и &amp;laquo;config.worktree&amp;raquo; из GIT_DIR в указанном порядке. В режиме нескольких рабочих каталогов используется общий доступ к файлу &amp;laquo;config&amp;raquo;, а &amp;laquo;config.worktree&amp;raquo; - к рабочему каталогу (т.е. он находится в GIT_COMMON_DIR / worktrees / &amp;lt;id&amp;gt; /config.worktree)</target>
        </trans-unit>
        <trans-unit id="8558e4c58eead00c8757e7213c096b3a4293d44c" translate="yes" xml:space="preserve">
          <source>If set, clients will attempt to communicate with a server using the specified protocol version. If the server does not support it, communication falls back to version 0. If unset, the default is &lt;code&gt;2&lt;/code&gt;. Supported versions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b176f794890668142b94887636cc924076126a16" translate="yes" xml:space="preserve">
          <source>If set, keywords at the start of the line are highlighted. The keywords are &quot;error&quot;, &quot;warning&quot;, &quot;hint&quot; and &quot;success&quot;, and are matched case-insensitively. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;). If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">Если установлено, ключевые слова в начале строки подсвечиваются. Ключевые слова: &amp;laquo;ошибка&amp;raquo;, &amp;laquo;предупреждение&amp;raquo;, &amp;laquo;подсказка&amp;raquo; и &amp;laquo;успех&amp;raquo;, при поиске без учета регистра. Может иметь значение &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (или &lt;code&gt;never&lt;/code&gt; ) или &lt;code&gt;auto&lt;/code&gt; (или &lt;code&gt;true&lt;/code&gt; ). Если не задано, используется значение &lt;code&gt;color.ui&lt;/code&gt; ( по умолчанию &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b183dd8c0ffee365fe58a6a334a19fb15f9512f0" translate="yes" xml:space="preserve">
          <source>If set, prints debugging information about various reads/writes.</source>
          <target state="translated">Если установлено,печатает отладочную информацию о различных чтениях/записях.</target>
        </trans-unit>
        <trans-unit id="b8c5d5bfb05b8eec245d869376183965da454ecd" translate="yes" xml:space="preserve">
          <source>If set, provide a user defined default policy for all protocols which don&amp;rsquo;t explicitly have a policy (&lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt;). By default, if unset, known-safe protocols (http, https, git, ssh, file) have a default policy of &lt;code&gt;always&lt;/code&gt;, known-dangerous protocols (ext) have a default policy of &lt;code&gt;never&lt;/code&gt;, and all other protocols have a default policy of &lt;code&gt;user&lt;/code&gt;. Supported policies:</source>
          <target state="translated">Если установлено, &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; определяемую пользователем политику по умолчанию для всех протоколов, которые явно не имеют политики ( протокол. &amp;lt;Имя&amp;gt;. Разрешить ). По умолчанию, если не установлено, известные безопасные протоколы (http, https, git, ssh, file) имеют политику по умолчанию &lt;code&gt;always&lt;/code&gt; , известные опасные протоколы (ext) имеют политику по умолчанию &lt;code&gt;never&lt;/code&gt; , а все другие протоколы имеют политику по умолчанию. от &lt;code&gt;user&lt;/code&gt; . Поддерживаемые политики:</target>
        </trans-unit>
        <trans-unit id="8d4a6e984ec5e0aad11e32a678cf60da360c5f1c" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server option to use. Default value can be specified by the &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; configuration option.</source>
          <target state="translated">Если установлено, задает параметр исходящего SMTP-сервера. Значение по умолчанию можно указать в &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; конфигурации sendemail.smtpServerOption .</target>
        </trans-unit>
        <trans-unit id="0fab27431c274f5a81ff1327c3c271e3371074f0" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server to use (e.g. &lt;code&gt;smtp.example.com&lt;/code&gt; or a raw IP address). Alternatively it can specify a full pathname of a sendmail-like program instead; the program must support the &lt;code&gt;-i&lt;/code&gt; option. Default value can be specified by the &lt;code&gt;sendemail.smtpServer&lt;/code&gt; configuration option; the built-in default is to search for &lt;code&gt;sendmail&lt;/code&gt; in &lt;code&gt;/usr/sbin&lt;/code&gt;, &lt;code&gt;/usr/lib&lt;/code&gt; and $PATH if such program is available, falling back to &lt;code&gt;localhost&lt;/code&gt; otherwise.</source>
          <target state="translated">Если установлено, указывает исходящий SMTP-сервер для использования (например, &lt;code&gt;smtp.example.com&lt;/code&gt; или необработанный IP-адрес). В качестве альтернативы он может вместо этого указать полный путь к программе, подобной sendmail; программа должна поддерживать параметр &lt;code&gt;-i&lt;/code&gt; . Значение по умолчанию может быть указано в &lt;code&gt;sendemail.smtpServer&lt;/code&gt; конфигурации sendemail.smtpServer ; встроенное значение по умолчанию - поиск &lt;code&gt;sendmail&lt;/code&gt; в &lt;code&gt;/usr/sbin&lt;/code&gt; , &lt;code&gt;/usr/lib&lt;/code&gt; и $ PATH, если такая программа доступна, в противном случае - &lt;code&gt;localhost&lt;/code&gt; к localhost .</target>
        </trans-unit>
        <trans-unit id="95132676994fa7152c54abc8928412e3414f6991" translate="yes" xml:space="preserve">
          <source>If set, store cookies received during requests to the file specified by http.cookieFile. Has no effect if http.cookieFile is unset.</source>
          <target state="translated">Если установлено,сохранять куки-файлы,полученные во время запросов к файлу,указанному в http.cookieFile.Не действует,если http.cookieFile не установлен.</target>
        </trans-unit>
        <trans-unit id="9802dde85fc0323285bb8c0402ffcc333cf47ed2" translate="yes" xml:space="preserve">
          <source>If set, the value of this variable is used as a command which will identify all files that may have changed since the requested date/time. This information is used to speed up git by avoiding unnecessary processing of files that have not changed. See the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">Если установлено, значение этой переменной используется как команда, которая идентифицирует все файлы, которые могли быть изменены с запрошенной даты / времени. Эта информация используется для ускорения работы git за счет исключения ненужной обработки файлов, которые не изменились. См. Раздел &lt;a href=&quot;githooks&quot;&gt;githooks [5],&lt;/a&gt; посвященный fsmonitor-watchman .</target>
        </trans-unit>
        <trans-unit id="9612a7f8efdd3501a24381e7aae358082b8ef892" translate="yes" xml:space="preserve">
          <source>If some &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; arguments are also passed on the command line, when a &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; is configured, the command will also be executed for each of these arguments. And the &amp;lt;value&amp;gt; part of these arguments, if any, will be used to replace the &lt;code&gt;$ARG&lt;/code&gt; string in the command.</source>
          <target state="translated">Если некоторые аргументы &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; также передаются в командной строке при настройке команды &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; , Команда также будет выполняться для каждого из этих аргументов. И часть &amp;lt;value&amp;gt; этих аргументов, если таковая имеется, будет использоваться для замены строки &lt;code&gt;$ARG&lt;/code&gt; в команде.</target>
        </trans-unit>
        <trans-unit id="00679e1f1be4cb3b83ae3531e0f65d104df1ba84" translate="yes" xml:space="preserve">
          <source>If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable &lt;code&gt;add.ignoreErrors&lt;/code&gt; can be set to true to make this the default behaviour.</source>
          <target state="translated">Если некоторые файлы не могут быть добавлены из-за ошибок их индексации, не прерывайте операцию, а продолжайте добавлять другие. Команда все равно должна завершиться с ненулевым статусом. Для переменной конфигурации &lt;code&gt;add.ignoreErrors&lt;/code&gt; можно задать значение true, чтобы сделать это поведением по умолчанию.</target>
        </trans-unit>
        <trans-unit id="02424da36361565abc928c3cd12899bb91686b1d" translate="yes" xml:space="preserve">
          <source>If some of the merge bases are skipped, then the bisection process continues, but the following message is printed for each skipped merge base:</source>
          <target state="translated">Если некоторые базы слияния пропущены,то биссектриса продолжается,но для каждой пропущенной базы слияния выводится следующее сообщение:</target>
        </trans-unit>
        <trans-unit id="c23bec329e1ab3f8ab844a76b3b2aad8e4c54310" translate="yes" xml:space="preserve">
          <source>If somebody got a release tag from you, you cannot just change the tag for them by updating your own one. This is a big security issue, in that people MUST be able to trust their tag-names. If you really want to do the insane thing, you need to just fess up to it, and tell people that you messed up. You can do that by making a very public announcement saying:</source>
          <target state="translated">Если кто-то получил от вас тэг релиза,вы не можете просто поменять тэг на него,обновив свой собственный.Это большая проблема безопасности,в том,что люди ДОЛЖНЫ доверять своим тегам.Если вы действительно хотите сделать безумную вещь,вам нужно просто признаться в этом и сказать людям,что вы облажались.Ты можешь сделать это,сделав очень публичное заявление:</target>
        </trans-unit>
        <trans-unit id="9c1822b09998ebb74d19f39d240afd93e64789bf" translate="yes" xml:space="preserve">
          <source>If someone else administers the server, they should tell you what directory to put the repository in, and what &lt;code&gt;git://&lt;/code&gt; URL it will appear at. You can then skip to the section &quot;&lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;Pushing changes to a public repository&lt;/a&gt;&quot;, below.</source>
          <target state="translated">Если кто-то другой администрирует сервер, он должен сообщить вам, в какой каталог поместить репозиторий и по какому адресу &lt;code&gt;git://&lt;/code&gt; он будет отображаться. Затем вы можете перейти к разделу &amp;laquo; &lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;Размещение изменений в общедоступном репозитории&lt;/a&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="4199717fddcec6935af08019e365f779fa359364" translate="yes" xml:space="preserve">
          <source>If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files.</source>
          <target state="translated">Если указано дважды,дополнительно покажите унифицированное различие между тем,что будет зафиксировано,и файлами рабочего дерева,т.е.неуправляемые изменения отслеживаемых файлов.</target>
        </trans-unit>
        <trans-unit id="fcf7bcff6fb66a8267ebcd9b00a7e09f8cfe6596" translate="yes" xml:space="preserve">
          <source>If that version is broken, type</source>
          <target state="translated">Если эта версия нарушена,введите</target>
        </trans-unit>
        <trans-unit id="c26c727c738ef7a0a9fa459f5d8c7e2c7478ba23" translate="yes" xml:space="preserve">
          <source>If the &quot;pattern&quot; URL does include a path component, then this too must match exactly: the context &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; will match a config entry for &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; (in addition to matching the config entry for &lt;code&gt;https://example.com&lt;/code&gt;) but will not match a config entry for &lt;code&gt;https://example.com/bar&lt;/code&gt;.</source>
          <target state="translated">Если &quot;шаблонный&quot; URL действительно включает компонент пути, то он тоже должен точно соответствовать: контекст &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; будет соответствовать записи конфигурации для &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; (помимо соответствия записи конфигурации для &lt;code&gt;https://example.com&lt;/code&gt; ), но не будет соответствовать записи конфигурации для &lt;code&gt;https://example.com/bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4d8f312459b1b390b1c7f9b1bd219e73052861c" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;value&amp;gt; part of any trailer contains only whitespace, the whole trailer will be removed from the resulting message. This applies to existing trailers as well as new trailers.</source>
          <target state="translated">Если часть &amp;lt;value&amp;gt; любого трейлера содержит только пробелы, весь трейлер будет удален из результирующего сообщения. Это касается как существующих, так и новых прицепов.</target>
        </trans-unit>
        <trans-unit id="b64722d374d9ba94f59d4b75e0b20b3d04a38c9e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of &lt;code&gt;./.git&lt;/code&gt; for the base of the repository.</source>
          <target state="translated">Если &lt;code&gt;$GIT_DIR&lt;/code&gt; переменная среды $ GIT_DIR, то она указывает путь, который следует использовать вместо &lt;code&gt;./.git&lt;/code&gt; для базы репозитория.</target>
        </trans-unit>
        <trans-unit id="010f47d5eb5a20440d8f9779a052d1045e200486" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--anonymize&lt;/code&gt; option is given, git will attempt to remove all identifying information from the repository while still retaining enough of the original tree and history patterns to reproduce some bugs. The goal is that a git bug which is found on a private repository will persist in the anonymized repository, and the latter can be shared with git developers to help solve the bug.</source>
          <target state="translated">Если &lt;code&gt;--anonymize&lt;/code&gt; опция --anonymize , git попытается удалить всю идентифицирующую информацию из репозитория, сохраняя при этом достаточное количество исходного дерева и шаблонов истории для воспроизведения некоторых ошибок. Цель состоит в том, чтобы ошибка git, обнаруженная в частном репозитории, сохранялась в анонимном репозитории, и последним можно было поделиться с разработчиками git, чтобы помочь решить ошибку.</target>
        </trans-unit>
        <trans-unit id="c4c6f80eebbd991a705883e3a7ddf7805d5a2ad9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--autosquash&lt;/code&gt; option is enabled by default using the configuration variable &lt;code&gt;rebase.autoSquash&lt;/code&gt;, this option can be used to override and disable this setting.</source>
          <target state="translated">Если параметр &lt;code&gt;--autosquash&lt;/code&gt; включен по умолчанию с использованием переменной конфигурации &lt;code&gt;rebase.autoSquash&lt;/code&gt; , этот параметр можно использовать для переопределения и отключения этого параметра.</target>
        </trans-unit>
        <trans-unit id="0cf1db99e3ec777fa9fc759a96b9df8702668643" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command is in use, the &lt;code&gt;done&lt;/code&gt; command is mandatory and marks the end of the stream.</source>
          <target state="translated">Если используется &lt;code&gt;--done&lt;/code&gt; командной строки --done или &lt;code&gt;feature done&lt;/code&gt; команда &lt;code&gt;done&lt;/code&gt; является обязательной и отмечает конец потока.</target>
        </trans-unit>
        <trans-unit id="a0c52682314428d0b2cfaeb79c7cb6ca41bbd107" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--include-untracked&lt;/code&gt; option is used, all untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;, leaving the working directory in a very clean state. If the &lt;code&gt;--all&lt;/code&gt; option is used instead then the ignored files are stashed and cleaned in addition to the untracked files.</source>
          <target state="translated">Если &lt;code&gt;--include-untracked&lt;/code&gt; параметр --include-untracked , все неотслеживаемые файлы также сохраняются, а затем очищаются с помощью &lt;code&gt;git clean&lt;/code&gt; , оставляя рабочий каталог в очень чистом состоянии. Если вместо этого используется параметр &lt;code&gt;--all&lt;/code&gt; , игнорируемые файлы сохраняются и очищаются в дополнение к неотслеживаемым файлам.</target>
        </trans-unit>
        <trans-unit id="bbfa929c9630d94c6f050152effe58514108dc44" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--index&lt;/code&gt; option is used, then tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">Если &lt;code&gt;--index&lt;/code&gt; опция --index , то пытается восстановить не только изменения рабочего дерева, но и индекса. Однако это может потерпеть неудачу, если у вас есть конфликты (которые хранятся в индексе, поэтому вы больше не можете применять изменения, как они были изначально).</target>
        </trans-unit>
        <trans-unit id="f3433648ddba23324bfe890535ea8fba49406cc9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--keep-index&lt;/code&gt; option is used, all changes already added to the index are left intact.</source>
          <target state="translated">Если используется опция &lt;code&gt;--keep-index&lt;/code&gt; , все изменения, уже добавленные в индекс, остаются без изменений.</target>
        </trans-unit>
        <trans-unit id="f0b71e8c338c336264145f9c00a25064d3a5d745" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--multiple&lt;/code&gt; option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings &lt;code&gt;fetch.parallel&lt;/code&gt; and &lt;code&gt;submodule.fetchJobs&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Если была &lt;code&gt;--multiple&lt;/code&gt; опция --multiple , разные пульты будут извлекаться параллельно. Если выбрано несколько подмодулей, они будут выбраны параллельно. Для того, чтобы управлять ими независимо друг от друга, используют параметры конфигурации &lt;code&gt;fetch.parallel&lt;/code&gt; и &lt;code&gt;submodule.fetchJobs&lt;/code&gt; (см &lt;a href=&quot;git-config&quot;&gt;ГИТ-конфигурации [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="86926b76e3db734e6c786d5fed43f678b858b280" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set, &lt;code&gt;git log&lt;/code&gt; is used instead. You can also give command-line options such as &lt;code&gt;-p&lt;/code&gt; and &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">Если переменная среды &lt;code&gt;DISPLAY&lt;/code&gt; не задана, вместо &lt;code&gt;git log&lt;/code&gt; используется журнал git . Вы также можете &lt;code&gt;--stat&lt;/code&gt; параметры командной строки, такие как &lt;code&gt;-p&lt;/code&gt; и --stat .</target>
        </trans-unit>
        <trans-unit id="d759f2e991e02f3a71fd36511a7699e5f49db70c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_ASKPASS&lt;/code&gt; environment variable is set, the program specified by the variable is invoked. A suitable prompt is provided to the program on the command line, and the user&amp;rsquo;s input is read from its standard output.</source>
          <target state="translated">Если &lt;code&gt;GIT_ASKPASS&lt;/code&gt; переменная среды GIT_ASKPASS, вызывается программа, указанная в этой переменной. Подходящая подсказка предоставляется программе в командной строке, а ввод пользователя считывается из стандартного вывода.</target>
        </trans-unit>
        <trans-unit id="4b682e3beccdc952b131cf46cc2adb457e7b0390" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of the default &lt;code&gt;.git&lt;/code&gt; for the base of the repository. The &lt;code&gt;--git-dir&lt;/code&gt; command-line option also sets this value.</source>
          <target state="translated">Если &lt;code&gt;GIT_DIR&lt;/code&gt; переменная среды GIT_DIR, она указывает путь, который будет использоваться вместо стандартного &lt;code&gt;.git&lt;/code&gt; для базы репозитория. &lt;code&gt;--git-dir&lt;/code&gt; параметр командной строки также устанавливает это значение.</target>
        </trans-unit>
        <trans-unit id="643cae995a607334b36d06d83fbe3fb662a8bb45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;done&lt;/code&gt; feature is not in use, treated as if EOF was read. This can be used to tell fast-import to finish early.</source>
          <target state="translated">Если функция &lt;code&gt;done&lt;/code&gt; не используется, обрабатывается так, как если бы EOF был прочитан. Это можно использовать, чтобы сообщить о досрочном завершении быстрого импорта.</target>
        </trans-unit>
        <trans-unit id="18aa9d79f5a644e72e69f66c98e1e834c977b6b0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;filter&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">Если функция &lt;code&gt;filter&lt;/code&gt; объявляется, в запрос клиента может быть включен следующий аргумент:</target>
        </trans-unit>
        <trans-unit id="338c6269ff70e3588bd2606af346bee907c22325" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;git credential&lt;/code&gt; knew about the password, this step may not have involved the user actually typing this password (the user may have typed a password to unlock the keychain instead, or no user interaction was done if the keychain was already unlocked) before it returned &lt;code&gt;password=secr3t&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;git credential&lt;/code&gt; знали о пароле, этот шаг мог не вовлекать пользователя, фактически вводящего этот пароль (вместо этого пользователь мог ввести пароль, чтобы разблокировать связку ключей, или никакое взаимодействие с пользователем не было выполнено, если связка ключей уже была разблокирована) до этого вернулся &lt;code&gt;password=secr3t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="042e7419aeefb97aea8089e7aef725093dfeada4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;packfile-uris&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;packfile-uris&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e7bad5825e1ca0d0f2641273cfd194a2b47fe7f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref-in-want&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;wanted-refs&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">Если объявляется функция &lt;code&gt;ref-in-want&lt;/code&gt; , в запрос клиента может быть включен следующий аргумент, а также возможное добавление раздела &lt;code&gt;wanted-refs&lt;/code&gt; в ответ сервера, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="8ee9fffd993cfbf2d4a66bab484646e0aab5c31d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shallow&lt;/code&gt; feature is advertised the following arguments can be included in the clients request as well as the potential addition of the &lt;code&gt;shallow-info&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">Если объявляется &lt;code&gt;shallow&lt;/code&gt; функция, в запрос клиента могут быть включены следующие аргументы, а также возможное добавление раздела &lt;code&gt;shallow-info&lt;/code&gt; в ответ сервера, как описано ниже.</target>
        </trans-unit>
        <trans-unit id="cc56c6c35649e4cbd1848d389261cbadfd34e234" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sideband-all&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">Если объявляется функция &lt;code&gt;sideband-all&lt;/code&gt; , в запрос клиента может быть включен следующий аргумент:</target>
        </trans-unit>
        <trans-unit id="5221b8fce1b302181f6152b9a7b516c793a8424a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;text&lt;/code&gt; attribute is unspecified, Git uses the &lt;code&gt;core.autocrlf&lt;/code&gt; configuration variable to determine if the file should be converted.</source>
          <target state="translated">Если &lt;code&gt;text&lt;/code&gt; атрибут не &lt;code&gt;core.autocrlf&lt;/code&gt; , Git использует переменную конфигурации core.autocrlf, чтобы определить, следует ли преобразовать файл.</target>
        </trans-unit>
        <trans-unit id="501d792e8a9528e67beb280aae4c4f6b3a3116f1" translate="yes" xml:space="preserve">
          <source>If the Git configuration variable clean.requireForce is not set to false, &lt;code&gt;git clean&lt;/code&gt; will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.</source>
          <target state="translated">Если для переменной конфигурации Git clean.requireForce не задано значение false, &lt;code&gt;git clean&lt;/code&gt; откажется удалять файлы или каталоги, если не задано -f или -i. Git откажется изменять неотслеживаемые вложенные репозитории git (каталоги с подкаталогом .git), если не указан второй -f.</target>
        </trans-unit>
        <trans-unit id="1a08af52d1bb96063df69a1ba9c6458415ca2e42" translate="yes" xml:space="preserve">
          <source>If the HTTP transfer speed is less than &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; for longer than &lt;code&gt;http.lowSpeedTime&lt;/code&gt; seconds, the transfer is aborted. Can be overridden by the &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; and &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; environment variables.</source>
          <target state="translated">Если скорость передачи HTTP меньше &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; дольше &lt;code&gt;http.lowSpeedTime&lt;/code&gt; секунд, передача прерывается. Может быть переопределено переменными среды &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; и &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c44d5cf7886c82987c35de787d30a82008f591b" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt; or &lt;code&gt;reject&lt;/code&gt;, no output should be emitted.</source>
          <target state="translated">Если действие &lt;code&gt;approve&lt;/code&gt; или &lt;code&gt;reject&lt;/code&gt; , вывод не должен выводиться.</target>
        </trans-unit>
        <trans-unit id="a7a299c18f6719e8e8b963c0bc834abd5de39626" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may store the credential for later use.</source>
          <target state="translated">Если действие &lt;code&gt;approve&lt;/code&gt; , git-credential отправит описание любым настроенным помощникам по учетным данным, которые могут хранить учетные данные для дальнейшего использования.</target>
        </trans-unit>
        <trans-unit id="7fc4d66ebd944d4cf73c3d3a8712c0dec288c62f" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;fill&lt;/code&gt;, git-credential will attempt to add &quot;username&quot; and &quot;password&quot; attributes to the description by reading config files, by contacting any configured credential helpers, or by prompting the user. The username and password attributes of the credential description are then printed to stdout together with the attributes already provided.</source>
          <target state="translated">Если действие &lt;code&gt;fill&lt;/code&gt; , git-credential попытается добавить атрибуты &amp;laquo;имя пользователя&amp;raquo; и &amp;laquo;пароль&amp;raquo; к описанию, прочитав файлы конфигурации, связавшись с любыми настроенными помощниками по учетным данным или запросив пользователя. Атрибуты имени пользователя и пароля описания учетных данных затем выводятся на стандартный вывод вместе с уже предоставленными атрибутами.</target>
        </trans-unit>
        <trans-unit id="194451718843bfcaf463de902599c24ff69e0de0" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;reject&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may erase any stored credential matching the description.</source>
          <target state="translated">Если действие &lt;code&gt;reject&lt;/code&gt; , git-credential отправит описание любым настроенным помощникам по учетным данным, которые могут стереть любые сохраненные учетные данные, соответствующие описанию.</target>
        </trans-unit>
        <trans-unit id="d8fc44b68b56d1ac1b923c6197e4ad961f9ec579" translate="yes" xml:space="preserve">
          <source>If the alias expansion is prefixed with an exclamation point, it will be treated as a shell command. For example, defining &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt;, the invocation &lt;code&gt;git new&lt;/code&gt; is equivalent to running the shell command &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt;. Note that shell commands will be executed from the top-level directory of a repository, which may not necessarily be the current directory. &lt;code&gt;GIT_PREFIX&lt;/code&gt; is set as returned by running &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; from the original current directory. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">Если перед расширением псевдонима стоит восклицательный знак, оно будет рассматриваться как команда оболочки. Например, при определении &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt; вызов &lt;code&gt;git new&lt;/code&gt; эквивалентен запуску команды оболочки &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt; . Обратите внимание, что команды оболочки будут выполняться из каталога верхнего уровня репозитория, который не обязательно может быть текущим каталогом. &lt;code&gt;GIT_PREFIX&lt;/code&gt; устанавливается как возвращенный запуском &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; из исходного текущего каталога. См. &lt;a href=&quot;git-rev-parse&quot;&gt;Git-rev-parse [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81bb3cca543b16e19f5e2adb35c917e85fde2f7d" translate="yes" xml:space="preserve">
          <source>If the amount of memory estimated for &lt;code&gt;git repack&lt;/code&gt; to run smoothly is not available and &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is not set, the largest pack will also be excluded (this is the equivalent of running &lt;code&gt;git gc&lt;/code&gt; with &lt;code&gt;--keep-base-pack&lt;/code&gt;).</source>
          <target state="translated">Если объем памяти, оцениваемый для бесперебойной работы &lt;code&gt;git repack&lt;/code&gt; , недоступен и &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; не установлен, самый большой пакет также будет исключен (это эквивалент запуска &lt;code&gt;git gc&lt;/code&gt; с &lt;code&gt;--keep-base-pack&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c5b81516d1884721f5397be7b419616ee5761da" translate="yes" xml:space="preserve">
          <source>If the amount of memory estimated for &lt;code&gt;git repack&lt;/code&gt; to run smoothly is not available and &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is not set, the largest pack will also be excluded (this is the equivalent of running &lt;code&gt;git gc&lt;/code&gt; with &lt;code&gt;--keep-largest-pack&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ae5c748411e761b0bfb160798c17e5330bf010" translate="yes" xml:space="preserve">
          <source>If the anonymized repository shows the bug, it may be worth sharing &lt;code&gt;anon-stream&lt;/code&gt; along with a regular bug report. Note that the anonymized stream compresses very well, so gzipping it is encouraged. If you want to examine the stream to see that it does not contain any private data, you can peruse it directly before sending. You may also want to try:</source>
          <target state="translated">Если анонимный репозиторий показывает ошибку, возможно, стоит поделиться &lt;code&gt;anon-stream&lt;/code&gt; вместе с обычным отчетом об ошибке. Обратите внимание, что анонимный поток сжимается очень хорошо, поэтому рекомендуется его сжатие. Если вы хотите проверить поток, чтобы убедиться, что он не содержит личных данных, вы можете просмотреть его непосредственно перед отправкой. Вы также можете попробовать:</target>
        </trans-unit>
        <trans-unit id="723ec66f7929012c8a6ac732a23c4db7a105b505" translate="yes" xml:space="preserve">
          <source>If the attribute &lt;code&gt;export-subst&lt;/code&gt; is set for a file then Git will expand several placeholders when adding this file to an archive. The expansion depends on the availability of a commit ID, i.e., if &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; has been given a tree instead of a commit or a tag then no replacement will be done. The placeholders are the same as those for the option &lt;code&gt;--pretty=format:&lt;/code&gt; of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, except that they need to be wrapped like this: &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; in the file. E.g. the string &lt;code&gt;$Format:%H$&lt;/code&gt; will be replaced by the commit hash.</source>
          <target state="translated">Если для файла установлен атрибут &lt;code&gt;export-subst&lt;/code&gt; , Git расширит несколько заполнителей при добавлении этого файла в архив. Расширение зависит от наличия идентификатора фиксации, т. &lt;a href=&quot;git-archive&quot;&gt;Е.&lt;/a&gt; Если git-archive [1] было дано дерево вместо фиксации или тега, то замены не будет. Заполнители такие же, как и для параметра &lt;code&gt;--pretty=format:&lt;/code&gt; в &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , за исключением того, что их нужно обернуть следующим образом: &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; в файле. Например, строка &lt;code&gt;$Format:%H$&lt;/code&gt; будет заменена хешем фиксации.</target>
        </trans-unit>
        <trans-unit id="bd056a8735e1abbf79ce6a360a1a80c3f28cbbd6" translate="yes" xml:space="preserve">
          <source>If the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">Если для файла установлен атрибут export-subst, Git расширит несколько заполнителей при добавлении этого файла в архив. Подробнее см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da80064c2ffb4013d75c1676828faa86849266b6" translate="yes" xml:space="preserve">
          <source>If the bisection process is driven manually, you can use &quot;git bisect skip&quot; to do the same thing. (In fact the special exit code 125 makes &quot;git bisect run&quot; use &quot;git bisect skip&quot; in the background.)</source>
          <target state="translated">Если бисектный процесс управляется вручную,вы можете использовать &quot;git-бисектный пропуск&quot;,чтобы сделать то же самое.(Фактически,специальный код выхода 125 заставляет &quot;git-бисектный прогон&quot; использовать &quot;git-бисектный пропуск&quot; в фоновом режиме).</target>
        </trans-unit>
        <trans-unit id="92ad120c671c36b884538f372611cf38d29a6827" translate="yes" xml:space="preserve">
          <source>If the branch exists in multiple remotes and one of them is named by the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable, we&amp;rsquo;ll use that one for the purposes of disambiguation, even if the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; isn&amp;rsquo;t unique across all remotes. Set it to e.g. &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; to always checkout remote branches from there if &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is ambiguous but exists on the &lt;code&gt;origin&lt;/code&gt; remote. See also &lt;code&gt;checkout.defaultRemote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Если ветвь существует на нескольких пультах и ​​один из них назван переменной конфигурации &lt;code&gt;checkout.defaultRemote&lt;/code&gt; , мы будем использовать ее для устранения неоднозначности, даже если &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; не уникален для всех пультов. Установите его , например , &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; , чтобы всегда контроль удаленных филиалов оттуда , если &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; неоднозначен , но существует на &lt;code&gt;origin&lt;/code&gt; удаленной. См. Также &lt;code&gt;checkout.defaultRemote&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c39c5c03f65f2a5b7cc29c6c30fb330e225795da" translate="yes" xml:space="preserve">
          <source>If the changes are independent enough, Git will automatically complete the merge and commit the result (or reuse an existing commit in case of &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;, see below). On the other hand, if there are conflicts&amp;mdash;​for example, if the same file is modified in two different ways in the remote branch and the local branch&amp;mdash;​then you are warned; the output may look something like this:</source>
          <target state="translated">Если изменения достаточно независимы, Git автоматически завершит слияние и зафиксирует результат (или повторно использует существующую фиксацию в случае &lt;a href=&quot;#fast-forwards&quot;&gt;быстрой перемотки вперед&lt;/a&gt; , см. Ниже). С другой стороны, если есть конфликты - например, если один и тот же файл изменен двумя разными способами в удаленной и локальной ветвях, - вы будете предупреждены; вывод может выглядеть примерно так:</target>
        </trans-unit>
        <trans-unit id="288f48e57898c3a0706dea1db36d760600650737" translate="yes" xml:space="preserve">
          <source>If the changes don&amp;rsquo;t conflict, you&amp;rsquo;re done. If there are conflicts, markers will be left in the problematic files showing the conflict;</source>
          <target state="translated">Если изменения не противоречат друг другу, все готово. Если есть конфликты, в проблемных файлах будут оставлены маркеры, показывающие конфликт;</target>
        </trans-unit>
        <trans-unit id="0c9dca535f00f8f010f3f51cbdf5a64ba071ad26" translate="yes" xml:space="preserve">
          <source>If the checkout is done via rebase, local submodule commits are rebased as well.</source>
          <target state="translated">Если извлечение осуществляется через ребейзинг,локальные коммиты субмодулей также ребейзингуются.</target>
        </trans-unit>
        <trans-unit id="da1ce847fd50c0ebce51907161b2297389c68a97" translate="yes" xml:space="preserve">
          <source>If the command contains the &lt;code&gt;$ARG&lt;/code&gt; string, this string will be replaced with the &amp;lt;value&amp;gt; part of an existing trailer with the same &amp;lt;token&amp;gt;, if any, before the command is launched.</source>
          <target state="translated">Если команда содержит строку &lt;code&gt;$ARG&lt;/code&gt; , эта строка будет заменена частью &amp;lt;value&amp;gt; существующего трейлера с тем же &amp;lt;token&amp;gt;, если таковой имеется, перед запуском команды.</target>
        </trans-unit>
        <trans-unit id="d68b3a0db25981cb416126191f5f7a8b40a5795b" translate="yes" xml:space="preserve">
          <source>If the commit is a merge commit, you must tell &lt;code&gt;git cvsexportcommit&lt;/code&gt; what parent the changeset should be done against.</source>
          <target state="translated">Если фиксация - это фиксация слияния, вы должны указать &lt;code&gt;git cvsexportcommit&lt;/code&gt; ,для какого родителя следует применить набор изменений.</target>
        </trans-unit>
        <trans-unit id="50eff6c32d5b1376396b813f799767464152ed15" translate="yes" xml:space="preserve">
          <source>If the commit is a merge, and if the pretty-format is not &lt;code&gt;oneline&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; or &lt;code&gt;raw&lt;/code&gt;, an additional line is inserted before the &lt;code&gt;Author:&lt;/code&gt; line. This line begins with &quot;Merge: &quot; and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the &lt;strong&gt;direct&lt;/strong&gt; parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.</source>
          <target state="translated">Если фиксация является слиянием, и если красивый формат не является &lt;code&gt;oneline&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; или &lt;code&gt;raw&lt;/code&gt; , перед строкой &lt;code&gt;Author:&lt;/code&gt; вставляется дополнительная строка. Эта строка начинается с &amp;laquo;Merge:&amp;raquo;, и хеши наследственных коммитов печатаются через пробел. Обратите внимание, что перечисленные коммиты не обязательно могут быть списком &lt;strong&gt;прямых&lt;/strong&gt; родительских коммитов, если вы ограничили свой просмотр истории: например, если вас интересуют только изменения, связанные с определенным каталогом или файлом.</target>
        </trans-unit>
        <trans-unit id="fb562926c30c7dcdbad03cee2dab579f6b030079" translate="yes" xml:space="preserve">
          <source>If the commit is done directly by using &lt;code&gt;git&lt;/code&gt; (as opposed to using &lt;code&gt;git-cvsserver&lt;/code&gt;) the update will need to happen on the next repository access by &lt;code&gt;git-cvsserver&lt;/code&gt;, independent of access method and requested operation.</source>
          <target state="translated">Если фиксация выполняется напрямую с помощью &lt;code&gt;git&lt;/code&gt; (в отличие от использования &lt;code&gt;git-cvsserver&lt;/code&gt; ), обновление должно произойти при следующем доступе к репозиторию с помощью &lt;code&gt;git-cvsserver&lt;/code&gt; , независимо от метода доступа и запрошенной операции.</target>
        </trans-unit>
        <trans-unit id="f829bbddf6f6f452756492321328ac75e498d9d9" translate="yes" xml:space="preserve">
          <source>If the config option &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; is true, these rules are ignored, and clients may use arbitrary sha1 expressions. This is useful if you do not care about the privacy of unreachable objects, or if your object database is already publicly available for access via non-smart-http.</source>
          <target state="translated">Если параметр конфигурации &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; имеет значение true, эти правила игнорируются, и клиенты могут использовать произвольные выражения sha1. Это полезно, если вы не заботитесь о конфиденциальности недоступных объектов или если ваша база данных объектов уже общедоступна для доступа через не-smart-http.</target>
        </trans-unit>
        <trans-unit id="a1bf5bff98f507f37d5394622406355fb10d8518" translate="yes" xml:space="preserve">
          <source>If the config variable &lt;code&gt;status.relativePaths&lt;/code&gt; is set to false, then all paths shown are relative to the repository root, not to the current directory.</source>
          <target state="translated">Если для переменной конфигурации &lt;code&gt;status.relativePaths&lt;/code&gt; установлено значение false, тогда все показанные пути относятся к корню репозитория, а не к текущему каталогу.</target>
        </trans-unit>
        <trans-unit id="15abc3d7884a27f6ef940ec31e7ff01ecc03f9f0" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3ff15aa0e04d429d03e9f6131934c58fa371f6" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">Если переменная конфигурации &lt;code&gt;instaweb.browser&lt;/code&gt; не задана, &lt;code&gt;web.browser&lt;/code&gt; будет использоваться web.browser , если он определен. См. Git-web {litdd} browse [1] для получения дополнительной информации об этом.</target>
        </trans-unit>
        <trans-unit id="63b229ee2ee5c7c387585f3ec858739b37c09980" translate="yes" xml:space="preserve">
          <source>If the current HEAD is the same as the parent of the cherry-pick&amp;rsquo;ed commit, then a fast forward to this commit will be performed.</source>
          <target state="translated">Если текущий HEAD совпадает с родительским элементом выбранной фиксации, будет выполнена перемотка вперед к этой фиксации.</target>
        </trans-unit>
        <trans-unit id="7ca0a51612928d164dbfccc37787084c17e98850" translate="yes" xml:space="preserve">
          <source>If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; will prompt the user to indicate the success of the resolution after the custom tool has exited.</source>
          <target state="translated">Если пользовательский инструмент слияния правильно указывает на успешное разрешение слияния своим кодом выхода, то для переменной конфигурации &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; можно задать значение &lt;code&gt;true&lt;/code&gt; . В противном случае &lt;code&gt;git mergetool&lt;/code&gt; предложит пользователю указать успешное выполнение разрешения после выхода из настраиваемого инструмента.</target>
        </trans-unit>
        <trans-unit id="36390d22499feba94308c3d2a6c08dfbe3009ec3" translate="yes" xml:space="preserve">
          <source>If the exit status is non-zero, &lt;code&gt;git commit&lt;/code&gt; will abort.</source>
          <target state="translated">Если статус выхода не равен нулю, &lt;code&gt;git commit&lt;/code&gt; будет прерван.</target>
        </trans-unit>
        <trans-unit id="ffb6fc6e4737a7b7be769bd191cc211dd325235f" translate="yes" xml:space="preserve">
          <source>If the file &lt;code&gt;.mailmap&lt;/code&gt; exists at the toplevel of the repository, or at the location pointed to by the mailmap.file or mailmap.blob configuration options, it is used to map author and committer names and email addresses to canonical real names and email addresses.</source>
          <target state="translated">Если файл &lt;code&gt;.mailmap&lt;/code&gt; существует на верхнем уровне репозитория или в месте, указанном параметрами конфигурации mailmap.file или mailmap.blob, он используется для сопоставления имен авторов и коммиттеров и адресов электронной почты с каноническими реальными именами и адресами электронной почты. ,</target>
        </trans-unit>
        <trans-unit id="7142e4ddc34f82f593252b78cfae14d3292c9524" translate="yes" xml:space="preserve">
          <source>If the file gc.log exists, then &lt;code&gt;git gc --auto&lt;/code&gt; will print its content and exit with status zero instead of running unless that file is more than &lt;code&gt;gc.logExpiry&lt;/code&gt; old. Default is &quot;1.day&quot;. See &lt;code&gt;gc.pruneExpire&lt;/code&gt; for more ways to specify its value.</source>
          <target state="translated">Если файл gc.log существует, то &lt;code&gt;git gc --auto&lt;/code&gt; распечатает его содержимое и завершит работу с нулевым статусом вместо запуска, если этот файл не старше &lt;code&gt;gc.logExpiry&lt;/code&gt; . По умолчанию - &amp;laquo;1 день&amp;raquo;. См. &lt;code&gt;gc.pruneExpire&lt;/code&gt; для получения дополнительных сведений о том, как указать его значение.</target>
        </trans-unit>
        <trans-unit id="7333f3457fce187a5640d74385a1bbc89a0c5a97" translate="yes" xml:space="preserve">
          <source>If the filter command (a string value) is defined via &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; then Git can process all blobs with a single filter invocation for the entire life of a single Git command. This is achieved by using the long-running process protocol (described in technical/long-running-process-protocol.txt).</source>
          <target state="translated">Если команда фильтра (строковое значение) определяется с помощью &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; , то Git может обрабатывать все большие двоичные объекты с помощью одного вызова фильтра в течение всего срока действия одной команды Git. Это достигается за счет использования протокола длительного процесса (описанного в техническом / long-running-process-protocol.txt).</target>
        </trans-unit>
        <trans-unit id="edaaa7b77ca9e9ee284b92c3f4abf94dbe583827" translate="yes" xml:space="preserve">
          <source>If the filter dies during the communication or does not adhere to the protocol then Git will stop the filter process and restart it with the next file that needs to be processed. Depending on the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag Git will interpret that as error.</source>
          <target state="translated">Если фильтр умирает во время связи или не соблюдает протокол, Git остановит процесс фильтрации и перезапустит его со следующим файлом, который необходимо обработать. В зависимости от &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag, Git интерпретирует это как ошибку.</target>
        </trans-unit>
        <trans-unit id="5e14f4a25e8ac87108268501a2fbb6eaeaabe84f" translate="yes" xml:space="preserve">
          <source>If the filter experiences an error during processing, then it can send the status &quot;error&quot; after the content was (partially or completely) sent.</source>
          <target state="translated">Если во время обработки фильтр испытывает ошибку,то он может отправить статус &quot;ошибка&quot; после того,как содержимое было (частично или полностью)отправлено.</target>
        </trans-unit>
        <trans-unit id="4bace70b57e96bff11ceac069e6098423752b6f8" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability then it must support the &quot;list_available_blobs&quot; command. If Git sends this command, then the filter is expected to return a list of pathnames representing blobs that have been delayed earlier and are now available. The list must be terminated with a flush packet followed by a &quot;success&quot; status that is also terminated with a flush packet. If no blobs for the delayed paths are available, yet, then the filter is expected to block the response until at least one blob becomes available. The filter can tell Git that it has no more delayed blobs by sending an empty list. As soon as the filter responds with an empty list, Git stops asking. All blobs that Git has not received at this point are considered missing and will result in an error.</source>
          <target state="translated">Если фильтр поддерживает возможность &quot;задержки&quot;,то он должен поддерживать команду &quot;list_available_blobs&quot;.Если Git посылает эту команду,то фильтр должен возвращать список патнамов,представляющих блобы,которые были задержаны ранее и теперь доступны.Список должен быть завершён флеш-пакетом,за которым следует статус &quot;успешно&quot;,также завершённый флеш-пакетом.Если еще нет блобов для отложенных путей,то фильтр должен заблокировать ответ до тех пор,пока,по крайней мере,один блок не станет доступен.Фильтр может сообщить Git'у,что у него больше нет блоков с задержкой,отправив пустой список.Как только фильтр отвечает пустым списком,Git перестаёт спрашивать.Все капли,которые Git на данный момент не получил,считаются пропущенными и влекут за собой ошибку.</target>
        </trans-unit>
        <trans-unit id="03052ebbe356e67d3f76578abb0f90e9da0b94ac" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability, then Git can send the flag &quot;can-delay&quot; after the filter command and pathname. This flag denotes that the filter can delay filtering the current blob (e.g. to compensate network latencies) by responding with no content but with the status &quot;delayed&quot; and a flush packet.</source>
          <target state="translated">Если фильтр поддерживает возможность &quot;задержки&quot;,то Git может посылать флаг &quot;can-delay&quot; после команды и патнама фильтра.Этот флаг означает,что фильтр может задерживать фильтрацию текущего блока (например,для компенсации сетевых задержек),отвечая без содержания,но со статусом &quot;задержан&quot; и флеш-пакетом.</target>
        </trans-unit>
        <trans-unit id="13eec1f811a3745751e3462b5df9eab594af45cb" translate="yes" xml:space="preserve">
          <source>If the format is set to &quot;auto:foo&quot; and the pager is in use, format &quot;foo&quot; will be the used for the date format. Otherwise &quot;default&quot; will be used.</source>
          <target state="translated">Если формат установлен на &quot;auto:foo&quot; и пейджер используется,то для формата даты будет использоваться формат &quot;foo&quot;.В противном случае будет использоваться формат &quot;по умолчанию&quot;.</target>
        </trans-unit>
        <trans-unit id="7402fa03babc6cbdcbdc9c0c2d38f35b3f77eedb" translate="yes" xml:space="preserve">
          <source>If the given object refers to a blob, it will be described as &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt;, such that the blob can be found at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, which itself describes the first commit in which this blob occurs in a reverse revision walk from HEAD.</source>
          <target state="translated">Если данный объект ссылается на большой двоичный объект, он будет описан как &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt; , так что этот большой двоичный объект можно найти в &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; в &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , который сам описывает первую фиксацию в что этот blob происходит в обратном пересмотре от HEAD.</target>
        </trans-unit>
        <trans-unit id="5e980dfa1f5a4a3edafff4113df2abbd7d17f577" translate="yes" xml:space="preserve">
          <source>If the helper string begins with &quot;!&quot;, it is considered a shell snippet, and everything after the &quot;!&quot; becomes the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228c738194bda1bc3c409314b8269609d7c41e0b" translate="yes" xml:space="preserve">
          <source>If the hook exits with non-zero status, none of the refs will be updated. If the hook exits with zero, updating of individual refs can still be prevented by the &lt;a href=&quot;#update&quot;&gt;&lt;em&gt;update&lt;/em&gt;&lt;/a&gt; hook.</source>
          <target state="translated">Если ловушка завершается с ненулевым статусом, ни одна из ссылок не будет обновлена. Если ловушка завершается с нулем, обновление отдельных ссылок все еще может быть предотвращено ловушкой &lt;a href=&quot;#update&quot;&gt;&lt;em&gt;обновления&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8439515eb9b2d0e08bb52156ea070a5b55f21477" translate="yes" xml:space="preserve">
          <source>If the ignore-paths configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">Если установлен ключ конфигурации игнорирования путей,а также указана опция командной строки,то будут использоваться оба регулярных выражения.</target>
        </trans-unit>
        <trans-unit id="e545fa5704075d5dfeae5601c6d9858dfebf0464" translate="yes" xml:space="preserve">
          <source>If the ignore-refs configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">Если установлен ключ конфигурации ignore-refs,а также указана опция командной строки,то будут использоваться оба регулярных выражения.</target>
        </trans-unit>
        <trans-unit id="f1e0ea5f0e79a32b5a2b025af2eaf1eb5f6a9a8a" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify a working tree. For example if you only have two working trees, at &lt;code&gt;/abc/def/ghi&lt;/code&gt; and &lt;code&gt;/abc/def/ggg&lt;/code&gt;, then &lt;code&gt;ghi&lt;/code&gt; or &lt;code&gt;def/ghi&lt;/code&gt; is enough to point to the former working tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368e2e291b26f0dca547e5b1c9de986c75896687" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify worktrees. For example if you only have two working trees, at &quot;/abc/def/ghi&quot; and &quot;/abc/def/ggg&quot;, then &quot;ghi&quot; or &quot;def/ghi&quot; is enough to point to the former working tree.</source>
          <target state="translated">Если последние компоненты пути в пути рабочего дерева уникальны среди рабочих деревьев, его можно использовать для идентификации рабочих деревьев. Например, если у вас есть только два рабочих дерева, в &amp;laquo;/ abc / def / ghi&amp;raquo; и &amp;laquo;/ abc / def / ggg&amp;raquo;, тогда &amp;laquo;ghi&amp;raquo; или &amp;laquo;def / ghi&amp;raquo; достаточно, чтобы указать на предыдущее рабочее дерево.</target>
        </trans-unit>
        <trans-unit id="a77fa7a1d051613196a1695412c9a05d33f69ded" translate="yes" xml:space="preserve">
          <source>If the local offset is not available in the source material, use &amp;ldquo;+0000&amp;rdquo;, or the most common local offset. For example many organizations have a CVS repository which has only ever been accessed by users who are located in the same location and time zone. In this case a reasonable offset from UTC could be assumed.</source>
          <target state="translated">Если локальное смещение недоступно в исходном материале, используйте &amp;laquo;+0000&amp;raquo; или наиболее распространенное локальное смещение. Например, у многих организаций есть репозиторий CVS, к которому когда-либо обращались только пользователи, находящиеся в том же месте и часовом поясе. В этом случае можно было бы предположить разумное смещение от UTC.</target>
        </trans-unit>
        <trans-unit id="178f63f22948e35272dd2355f9864ebc5b092dbe" translate="yes" xml:space="preserve">
          <source>If the maintainer tells you that your patch no longer applies to the current upstream, you will have to rebase your topic (you cannot use a merge because you cannot format-patch merges):</source>
          <target state="translated">Если сопровождающий сообщит вам,что ваш патч больше не применяется к текущему восходящему потоку,вам придётся перебазировать вашу тему (вы не можете использовать слияние,потому что вы не можете отформатировать слияние патчей):</target>
        </trans-unit>
        <trans-unit id="9b0ae610cbbc854a9104beb55038f8e674b12699" translate="yes" xml:space="preserve">
          <source>If the merge cannot be carried out automatically, the conflicts need to be resolved and the result committed separately (see &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;). At that point, this hook will not be executed, but the &lt;code&gt;pre-commit&lt;/code&gt; hook will, if it is enabled.</source>
          <target state="translated">Если слияние не может быть выполнено автоматически, необходимо разрешить конфликты и зафиксировать результат отдельно (см. &lt;a href=&quot;git-merge&quot;&gt;Git-merge [1]&lt;/a&gt; ). В этот момент эта ловушка не будет выполнена, но ловушка &lt;code&gt;pre-commit&lt;/code&gt; будет выполняться, если она включена.</target>
        </trans-unit>
        <trans-unit id="e1f358924aaa72264d85ec0ddf7ef92dd8191058" translate="yes" xml:space="preserve">
          <source>If the merge fails because it is not a fast-forward, then it is possible some fixes on &lt;code&gt;maint&lt;/code&gt; were missed in the feature release. This will not happen if the content of the branches was verified as described in the previous section.</source>
          <target state="translated">Если слияние не удается, потому что это не перемотка вперед, возможно, некоторые исправления на &lt;code&gt;maint&lt;/code&gt; были пропущены в выпуске функции. Этого не произойдет, если содержимое веток было проверено, как описано в предыдущем разделе.</target>
        </trans-unit>
        <trans-unit id="39e28c0246f221ccbae77af3a33cb0a2f4910f1f" translate="yes" xml:space="preserve">
          <source>If the number of objects fetched over the Git native transfer is below this limit, then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">Если количество объектов, полученных с помощью собственной передачи Git, ниже этого предела, то объекты будут распакованы в свободные объектные файлы. Однако если количество полученных объектов равно или превышает этот предел, то полученный пакет будет сохранен как пакет после добавления любых недостающих дельта-баз. Сохранение пакета из push может ускорить выполнение операции push, особенно в медленных файловых системах. Если не задан, вместо него используется значение &lt;code&gt;transfer.unpackLimit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba1c0757ead2b007fd4bc7bc8fe3299d5f283bd7" translate="yes" xml:space="preserve">
          <source>If the number of objects imported by &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; is below this limit, then the objects will be unpacked into loose object files. However if the number of imported objects equals or exceeds this limit then the pack will be stored as a pack. Storing the pack from a fast-import can make the import operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">Если количество объектов, импортированных с помощью &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt; , ниже этого предела, то объекты будут распакованы в отдельные объектные файлы. Однако, если количество импортированных объектов равно этому пределу или превышает его, пакет будет сохранен как пакет. Сохранение пакета из быстрого импорта может ускорить выполнение операции импорта, особенно в медленных файловых системах. Если не задан, вместо него используется значение &lt;code&gt;transfer.unpackLimit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66dbfca32684aa415437926e2128b562d1010471" translate="yes" xml:space="preserve">
          <source>If the number of objects received in a push is below this limit then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">Если количество объектов, полученных в push-режиме, ниже этого предела, то объекты будут распакованы в отдельные объектные файлы. Однако если количество полученных объектов равно или превышает этот предел, то полученный пакет будет сохранен как пакет после добавления любых недостающих дельта-баз. Сохранение пакета из push может ускорить выполнение операции push, особенно в медленных файловых системах. Если не задан, вместо него используется значение &lt;code&gt;transfer.unpackLimit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5106f465347ea1c1f64d4a4e406ce8334671d0b" translate="yes" xml:space="preserve">
          <source>If the object being copied out to a temporary file is a symbolic link the content of the link will be written to a normal file. It is up to the end-user or the Porcelain to make use of this information.</source>
          <target state="translated">Если копируемый во временный файл объект является символической ссылкой,то содержимое ссылки будет записано в обычный файл.Использование этой информации зависит от конечного пользователя или от фарфора.</target>
        </trans-unit>
        <trans-unit id="0199138006db8140692b7fdc79404759dcaa332d" translate="yes" xml:space="preserve">
          <source>If the object is stored as a delta on-disk, this expands to the 40-hex sha1 of the delta base object. Otherwise, expands to the null sha1 (40 zeroes). See &lt;code&gt;CAVEATS&lt;/code&gt; below.</source>
          <target state="translated">Если объект хранится как дельта на диске, он расширяется до 40-шестнадцатеричного sha1 базового дельта-объекта. В противном случае расширяется до нулевого sha1 (40 нулей). См. &lt;code&gt;CAVEATS&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="bd902b813b2d32a3c916d53036b9b4661bcff5a2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">Если каталог хранилища объектов указан через переменную среды &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; то каталоги sha1 создаются под ним - в противном случае используется &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; по умолчанию $ GIT_DIR / objects .</target>
        </trans-unit>
        <trans-unit id="5445d9592417f6217da69d0d0ffe49e2288619f2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via this environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">Если каталог хранилища объектов указан с помощью этой переменной среды, то под ним создаются каталоги sha1 - в противном случае используется &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; по умолчанию $ GIT_DIR / objects .</target>
        </trans-unit>
        <trans-unit id="5f2dc3f2759f3e631848eb5ab78d16a8be4a1f31" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--all&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt; is given, all available commands are printed on the standard output.</source>
          <target state="translated">Если указан параметр &lt;code&gt;--all&lt;/code&gt; или &lt;code&gt;-a&lt;/code&gt; , все доступные команды выводятся на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="5db3d9ce81a9166e23fdfafcb7cf25752ff75423" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guide&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the useful Git guides is also printed on the standard output.</source>
          <target state="translated">Если &lt;code&gt;--guide&lt;/code&gt; параметр --guide или &lt;code&gt;-g&lt;/code&gt; , список полезных руководств Git также выводится на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="401de2382d11b6e27d9e64da4738d460ce293134" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guides&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the Git concept guides is also printed on the standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670e86a39706c7e65a8fa8905b8b3b00899ff047" translate="yes" xml:space="preserve">
          <source>If the option is passed without specifying &lt;code&gt;--force-with-lease&lt;/code&gt;, or specified along with &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt;, it is a &quot;no-op&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d4a6b6cbe8c87e55028aafc6f2a3b165e3a3fa" translate="yes" xml:space="preserve">
          <source>If the patch contains any changes to submodules then &lt;code&gt;git apply&lt;/code&gt; treats these changes as follows.</source>
          <target state="translated">Если патч содержит какие-либо изменения в подмодулях, &lt;code&gt;git apply&lt;/code&gt; обрабатывает эти изменения следующим образом.</target>
        </trans-unit>
        <trans-unit id="bc5f440658cbf7f8fc36476e96067d0db070086e" translate="yes" xml:space="preserve">
          <source>If the pattern does not start with either &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**/&lt;/code&gt; will be automatically prepended. For example, the pattern &lt;code&gt;foo/bar&lt;/code&gt; becomes &lt;code&gt;**/foo/bar&lt;/code&gt; and would match &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt;.</source>
          <target state="translated">Если шаблон не начинается с &lt;code&gt;~/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; или &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;**/&lt;/code&gt; будет автоматически добавлен в начало. Например, шаблон &lt;code&gt;foo/bar&lt;/code&gt; станет &lt;code&gt;**/foo/bar&lt;/code&gt; и будет соответствовать &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdf2b04ab13a298c669a989712845f14a413f23b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches &quot;foo&quot; and everything inside, recursively.</source>
          <target state="translated">Если образец заканчивается на &lt;code&gt;/&lt;/code&gt; , автоматически добавляется &lt;code&gt;**&lt;/code&gt; . Например, шаблон &lt;code&gt;foo/&lt;/code&gt; превращается в &lt;code&gt;foo/**&lt;/code&gt; . Другими словами, он рекурсивно соответствует &quot;foo&quot; и всему внутри.</target>
        </trans-unit>
        <trans-unit id="ead2b404e5878a53eb56a401706bd4f86f5cdd4b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches all branches that begin with &lt;code&gt;foo/&lt;/code&gt;. This is useful if your branches are organized hierarchically and you would like to apply a configuration to all the branches in that hierarchy.</source>
          <target state="translated">Если образец заканчивается на &lt;code&gt;/&lt;/code&gt; , автоматически добавляется &lt;code&gt;**&lt;/code&gt; . Например, шаблон &lt;code&gt;foo/&lt;/code&gt; превращается в &lt;code&gt;foo/**&lt;/code&gt; . Другими словами, он соответствует всем ветвям, начинающимся с &lt;code&gt;foo/&lt;/code&gt; . Это полезно, если ваши ветви организованы иерархически и вы хотите применить конфигурацию ко всем ветвям в этой иерархии.</target>
        </trans-unit>
        <trans-unit id="f1c8abd89592d50ca8ca62bbaec12c523f709263" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;./&lt;/code&gt;, it is replaced with the directory containing the current config file.</source>
          <target state="translated">Если шаблон начинается с &lt;code&gt;./&lt;/code&gt; , он заменяется каталогом, содержащим текущий файл конфигурации.</target>
        </trans-unit>
        <trans-unit id="f924b2c312a1632ec51dd0f0353e6842160ab641" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; will be substituted with the content of the environment variable &lt;code&gt;HOME&lt;/code&gt;.</source>
          <target state="translated">Если шаблон начинается с &lt;code&gt;~/&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; будет заменен содержимым переменной окружения &lt;code&gt;HOME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25b5ae377df44f33ba840cf2411c6edf767c0d5b" translate="yes" xml:space="preserve">
          <source>If the pre-receive hook exits with a non-zero exit status no updates will be performed, and the update, post-receive and post-update hooks will not be invoked either. This can be useful to quickly bail out if the update is not to be supported.</source>
          <target state="translated">Если предварительно полученный перехватчик выходит со статусом ненулевого выхода,обновления выполняться не будут,и обновления,перехватчики после получения и перехватчики после обновления также не будут вызываться.Это может быть полезно для быстрого выхода,если обновление не будет поддерживаться.</target>
        </trans-unit>
        <trans-unit id="0131da637807c8654fda6294e521f8e5e74d9c2b" translate="yes" xml:space="preserve">
          <source>If the problematic commit is the most recent commit, and you have not yet made that commit public, then you may just &lt;a href=&quot;#undoing-a-merge&quot;&gt;destroy it using &lt;code&gt;git reset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если проблемная фиксация является последней фиксацией, и вы еще не сделали эту фиксацию общедоступной, вы можете просто &lt;a href=&quot;#undoing-a-merge&quot;&gt;уничтожить ее с помощью &lt;code&gt;git reset&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f275a1769b3300733689c93e8034126052b9dd7" translate="yes" xml:space="preserve">
          <source>If the project list is taken from a file (&lt;code&gt;$projects_list&lt;/code&gt; points to a file), forks are only recognized if they are listed after the main project in that file.</source>
          <target state="translated">Если список проектов взят из файла ( &lt;code&gt;$projects_list&lt;/code&gt; указывает на файл), вилки распознаются только в том случае, если они перечислены после основного проекта в этом файле.</target>
        </trans-unit>
        <trans-unit id="cabde5708a0c59fc40ce3c5aef7bb8948c87aab4" translate="yes" xml:space="preserve">
          <source>If the reference repository is on the local machine, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to obtain objects from the reference repository. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the &lt;code&gt;--reference-if-able&lt;/code&gt;, a non existing directory is skipped with a warning instead of aborting the clone.</source>
          <target state="translated">Если эталонный репозиторий находится на локальном компьютере, автоматически настройте &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; для получения объектов из эталонного репозитория. Использование уже существующего репозитория в качестве альтернативы потребует копирования меньшего количества объектов из клонируемого репозитория, что снизит затраты на сетевое и локальное хранилище. При использовании &lt;code&gt;--reference-if-able&lt;/code&gt; несуществующий каталог пропускается с предупреждением вместо прерывания клона.</target>
        </trans-unit>
        <trans-unit id="5ea9c0fb462e839210565ca58d9885017561c1be" translate="yes" xml:space="preserve">
          <source>If the refspec is a globbing one, nothing is merged.</source>
          <target state="translated">Если реффицер-глобус,то ничего не сливается.</target>
        </trans-unit>
        <trans-unit id="67d81d9e5d98e20a38ce258501ea936cdaf3477e" translate="yes" xml:space="preserve">
          <source>If the remote has enabled the options &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;, &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt;, or &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt;, they may alternatively be 40-hex sha1s present on the remote.</source>
          <target state="translated">Если на пульте дистанционного управления включены параметры &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; , &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt; или &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt; , они также могут быть 40-шестнадцатеричными sha1, присутствующими на пульте дистанционного управления.</target>
        </trans-unit>
        <trans-unit id="43fe46812af3fc1b263ad2f17ddd0dcd8b849c57" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b40a2dab8bd4f0c4875755d97441dd96a4edce1" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, pull and add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Если удаленный доступ получен успешно, извлеките и добавьте ссылку на восходящий поток (отслеживание), используемую &lt;a href=&quot;git-pull&quot;&gt;git-pull [1] без&lt;/a&gt; аргументов и другими командами. Для получения дополнительной информации см &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; и &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0cb0804e07bed75e0e991fffdc9aae616f339a" translate="yes" xml:space="preserve">
          <source>If the remote side supports it, annotated tags objects will be downloaded on the same connection as the other objects if the object the tag references is downloaded. The caller must otherwise determine the tags this option made available.</source>
          <target state="translated">Если удаленная сторона поддерживает это,то объекты с аннотированными тегами будут загружаться по тому же соединению,что и другие объекты,если загружается объект со ссылками на теги.В противном случае вызывающий абонент должен определить теги,которые будут доступны при загрузке.</target>
        </trans-unit>
        <trans-unit id="b72444ac7244fe67691159600db782df37b1532c" translate="yes" xml:space="preserve">
          <source>If the repository is bare, &lt;code&gt;--no-checkout&lt;/code&gt; is assumed.</source>
          <target state="translated">Если репозиторий пустой, предполагается &lt;code&gt;--no-checkout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36e50561f165c018ae6f119c2c6f3e5164508f60" translate="yes" xml:space="preserve">
          <source>If the repository is specified as a local path (e.g., &lt;code&gt;/path/to/repo&lt;/code&gt;), this is the default, and --local is essentially a no-op. If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations). Specifying &lt;code&gt;--no-local&lt;/code&gt; will override the default when &lt;code&gt;/path/to/repo&lt;/code&gt; is given, using the regular Git transport instead.</source>
          <target state="translated">Если репозиторий указан как локальный путь (например, &lt;code&gt;/path/to/repo&lt;/code&gt; ), это значение по умолчанию, а --local, по сути, не работает. Если репозиторий указан как URL-адрес, этот флаг игнорируется (и мы никогда не используем локальные оптимизации). Указание &lt;code&gt;--no-local&lt;/code&gt; переопределит значение по умолчанию, если задано &lt;code&gt;/path/to/repo&lt;/code&gt; , вместо этого будет использоваться обычный транспорт Git.</target>
        </trans-unit>
        <trans-unit id="9c19da211c253af2b7a5a65c4c24c5e8a4f73309" translate="yes" xml:space="preserve">
          <source>If the result content is empty then the filter is expected to respond with a &quot;success&quot; status and a flush packet to signal the empty content.</source>
          <target state="translated">Если содержимое результата пустое,то ожидается,что фильтр ответит статусом &quot;успешно&quot; и пакетом флеш-пакета,сигнализирующим о пустом содержимом.</target>
        </trans-unit>
        <trans-unit id="87bdb08d6c6927271153931ec7c3dbb32bf0435b" translate="yes" xml:space="preserve">
          <source>If the server has found a suitable cut point and has decided to send a &quot;ready&quot; line, then the server can decide to (as an optimization) omit any &quot;ACK&quot; lines it would have sent during its response. This is because the server will have already determined the objects it plans to send to the client and no further negotiation is needed.</source>
          <target state="translated">Если сервер нашел подходящую точку среза и решил послать &quot;готовую&quot; строку,то сервер может решить (в качестве оптимизации)опустить любые &quot;ACK&quot; строки,которые он бы послал во время своего ответа.Это связано с тем,что сервер уже определил объекты,которые он планирует отправить клиенту,и никаких дальнейших переговоров не требуется.</target>
        </trans-unit>
        <trans-unit id="b994a26dfc45bfc84fb73ef67436c3f647661961" translate="yes" xml:space="preserve">
          <source>If the size of the incoming pack stream is larger than this limit, then git-receive-pack will error out, instead of accepting the pack file. If not set or set to 0, then the size is unlimited.</source>
          <target state="translated">Если размер потока входящих пакетов больше этого лимита,то git-recepive-pack выдаст ошибку вместо того,чтобы принять файл пакета.Если не установить или установить 0,то размер неограничен.</target>
        </trans-unit>
        <trans-unit id="ff78750ae83975fe12661694a886f60b06a8fa31" translate="yes" xml:space="preserve">
          <source>If the source material uses RFC 2822 style dates, the frontend should let fast-import handle the parsing and conversion (rather than attempting to do it itself) as the Git parser has been well tested in the wild.</source>
          <target state="translated">Если исходный материал использует даты в стиле RFC 2822,то фронтенд должен позволить быстро импортировать обработку парсинга и преобразования (а не пытаться сделать это самостоятельно),так как Git-парсер был хорошо протестирован в дикой природе.</target>
        </trans-unit>
        <trans-unit id="3c8cd70e721e8a0b9cd7092e81bbbfc31a3bd8bd" translate="yes" xml:space="preserve">
          <source>If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.</source>
          <target state="translated">Если репозиторий источника завершен,преобразовать мелкий репозиторий в полный,устранив все ограничения,налагаемые мелкими репозиториями.</target>
        </trans-unit>
        <trans-unit id="9e6d3a4e3136a4838fe6f50fd9653c6cb56b6d6c" translate="yes" xml:space="preserve">
          <source>If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.</source>
          <target state="translated">Если репозиторий источника неглубокий,извлеките как можно больше информации,чтобы текущий репозиторий имел такую же историю,как и репозиторий источника.</target>
        </trans-unit>
        <trans-unit id="de8398976a760845a7849338955a9624333ab515" translate="yes" xml:space="preserve">
          <source>If the starting point is specified as &lt;code&gt;ref@{Nth}&lt;/code&gt;, show the index format.</source>
          <target state="translated">Если начальная точка указана как &lt;code&gt;ref@{Nth}&lt;/code&gt; , показать формат индекса.</target>
        </trans-unit>
        <trans-unit id="6a2386c7d64f544644194a06f1f15e00500df35a" translate="yes" xml:space="preserve">
          <source>If the starting point was specified as &lt;code&gt;ref@{now}&lt;/code&gt;, show the timestamp format.</source>
          <target state="translated">Если начальная точка была указана как &lt;code&gt;ref@{now}&lt;/code&gt; , показать формат отметки времени.</target>
        </trans-unit>
        <trans-unit id="a401b7c4a3b36e61e5b713fb185191570664ec06" translate="yes" xml:space="preserve">
          <source>If the submodule has never been initialized, this is the only place where submodule configuration is found. It serves as the last fallback to specify where to obtain the submodule from.</source>
          <target state="translated">Если подмодуль никогда не был инициализирован,то это единственное место,где находится конфигурация подмодуля.Оно служит последним запасом для указания,откуда можно получить подмодуль.</target>
        </trans-unit>
        <trans-unit id="c93d30e9eb4c6197dacc1ad5f6b79e20616e783c" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, and you just want to use the setting as stored in &lt;code&gt;.gitmodules&lt;/code&gt;, you can automatically initialize the submodule with the &lt;code&gt;--init&lt;/code&gt; option.</source>
          <target state="translated">Если подмодуль еще не инициализирован, и вы просто хотите использовать настройку, хранящуюся в &lt;code&gt;.gitmodules&lt;/code&gt; , вы можете автоматически инициализировать подмодуль с параметром &lt;code&gt;--init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02845d91bbeb482c77721be199fb493e9af0747b" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, then the configuration inside the submodule does not exist yet, so where to obtain the submodule from is configured here for example.</source>
          <target state="translated">Если подмодуль ещё не инициализирован,то конфигурация внутри подмодуля ещё не существует,поэтому,например,где взять подмодуль,настроено здесь.</target>
        </trans-unit>
        <trans-unit id="ae19e2f586d76eb404950c906a0e28fc48bd4144" translate="yes" xml:space="preserve">
          <source>If the target branch in refs/remotes/p4-unshelved already exists, the old one will be renamed.</source>
          <target state="translated">Если целевая ветка в refs/remotes/p4-unshelved уже существует,то старая будет переименована.</target>
        </trans-unit>
        <trans-unit id="2f7883dbe6de00b83ac31c035cb47ace7f18b215" translate="yes" xml:space="preserve">
          <source>If the timestamp order of different files cross the revision order within the commit matching time window the order of commits may be wrong.</source>
          <target state="translated">Если порядок следования меток времени различных файлов пересекает порядок ревизий в пределах временного окна фиксации,то порядок фиксаций может быть неправильным.</target>
        </trans-unit>
        <trans-unit id="9e02bc5f839968fa2bd55c9715c548322d410f70" translate="yes" xml:space="preserve">
          <source>If the update is done via merge, the submodule conflicts are resolved and checked out.</source>
          <target state="translated">Если обновление выполняется через слияние,то конфликты подмодулей разрешаются и проверяются.</target>
        </trans-unit>
        <trans-unit id="e429444552f2f76afd93b7eab781098fd53d76ab" translate="yes" xml:space="preserve">
          <source>If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped. For example, running &lt;code&gt;git rebase master&lt;/code&gt; on the following history (in which &lt;code&gt;A'&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; introduce the same set of changes, but have different committer information):</source>
          <target state="translated">Если восходящая ветвь уже содержит внесенное вами изменение (например, потому что вы отправили по почте патч, который был применен в восходящем направлении), то эта фиксация будет пропущена. Например, запуск &lt;code&gt;git rebase master&lt;/code&gt; для следующей истории (в которой &lt;code&gt;A'&lt;/code&gt; и &lt;code&gt;A&lt;/code&gt; вводят один и тот же набор изменений, но имеют разную информацию о коммиттере):</target>
        </trans-unit>
        <trans-unit id="8dd2ebfbc7db6f2a970a9204f7e4fecacb05b440" translate="yes" xml:space="preserve">
          <source>If the user is driving it, then at each step of the search, the user will have to test the current commit and say if it is &quot;good&quot; or &quot;bad&quot; using the &quot;git bisect good&quot; or &quot;git bisect bad&quot; commands respectively that have been described above. For example:</source>
          <target state="translated">Если пользователь управляет коммитом,то на каждом шаге поиска он должен будет проверять текущий коммит и говорить,&quot;хороший&quot; или &quot;плохой&quot;,используя команды &quot;git bisect good&quot; или &quot;git bisect bad&quot; соответственно,которые были описаны выше.Например:</target>
        </trans-unit>
        <trans-unit id="6929af54c2109d01f0c27eda6b64b41906b00393" translate="yes" xml:space="preserve">
          <source>If the user provides a --tag-name-filter that maps multiple tags to the same name, no warning or error is provided; git-filter-branch simply overwrites each tag in some undocumented pre-defined order resulting in only one tag at the end. (A git-filter-branch regression test requires this surprising behavior.)</source>
          <target state="translated">Если пользователь предоставляет --tag-name-фильтр,который сопоставляет несколько тегов с одним и тем же именем,предупреждение или ошибка не выдаётся;git-фильтр просто перезаписывает каждый тег в некотором недокументированном предопределённом порядке,в результате чего в конце получается только один тег.(git-filter-branch регрессионный тест требует такого удивительного поведения).</target>
        </trans-unit>
        <trans-unit id="115afcefe8deea6713a6376b9b3612622ce5ff41" translate="yes" xml:space="preserve">
          <source>If the user running &lt;code&gt;git p4 submit&lt;/code&gt; does not exist in the p4 user map, &lt;code&gt;git p4&lt;/code&gt; exits. This option can be used to force submission regardless.</source>
          <target state="translated">Если пользователь, запустивший &lt;code&gt;git p4 submit&lt;/code&gt; , не существует в пользовательской карте &lt;code&gt;git p4&lt;/code&gt; , git p4 завершает работу. Этот параметр можно использовать для принудительной отправки в любом случае.</target>
        </trans-unit>
        <trans-unit id="4ce7fbc3c51757d8b6052ea0a42e4807120e305f" translate="yes" xml:space="preserve">
          <source>If the value is boolean, turns on or off pagination of the output of a particular Git subcommand when writing to a tty. Otherwise, turns on pagination for the subcommand using the pager specified by the value of &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt;. If &lt;code&gt;--paginate&lt;/code&gt; or &lt;code&gt;--no-pager&lt;/code&gt; is specified on the command line, it takes precedence over this option. To disable pagination for all commands, set &lt;code&gt;core.pager&lt;/code&gt; or &lt;code&gt;GIT_PAGER&lt;/code&gt; to &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">Если значение является логическим, включает или отключает разбиение на страницы вывода конкретной подкоманды Git при записи на tty. В противном случае включает разбивку на страницы для подкоманды с использованием пейджера, указанного значением &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt; . Если в командной строке указано &lt;code&gt;--paginate&lt;/code&gt; или --no &lt;code&gt;--no-pager&lt;/code&gt; , он имеет приоритет над этой опцией. Чтобы отключить разбиение на страницы для всех команд, установите &lt;code&gt;core.pager&lt;/code&gt; или &lt;code&gt;GIT_PAGER&lt;/code&gt; на &lt;code&gt;cat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d03e93ea222dab8f641cb8201b06b8ce56eb4397" translate="yes" xml:space="preserve">
          <source>If the variable is set to an integer value greater than 2 and lower than 10 (strictly) then Git will interpret this value as an open file descriptor and will try to write the trace messages into this file descriptor.</source>
          <target state="translated">Если переменная установлена в целое значение больше 2 и меньше 10 (строго),то Git будет интерпретировать это значение как открытый файловый дескриптор и попытается записать сообщения трассировки в этот файловый дескриптор.</target>
        </trans-unit>
        <trans-unit id="68e78b3aa184c7970e4ea72bcfa1c35c1841182d" translate="yes" xml:space="preserve">
          <source>If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:</source>
          <target state="translated">Если существует большое количество одноимённых удалённых репозиториев и вы хотите использовать для них другой формат (такой,что используемые вами URL будут переписаны в URL,которые работают),вы можете создать конфигурационный раздел формы:</target>
        </trans-unit>
        <trans-unit id="1add756b76a7c17e78b77f722a60e35881bd1c18" translate="yes" xml:space="preserve">
          <source>If there are conflicts, the user should edit the result and delete one of the alternatives. When &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, or &lt;code&gt;--union&lt;/code&gt; option is in effect, however, these conflicts are resolved favouring lines from &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt;, lines from &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt;, or lines from both respectively. The length of the conflict markers can be given with the &lt;code&gt;--marker-size&lt;/code&gt; option.</source>
          <target state="translated">Если есть конфликты, пользователь должен отредактировать результат и удалить одну из альтернатив. Когда &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; или &lt;code&gt;--union&lt;/code&gt; вариант в действительности, однако, эти конфликты решаются в пользу линии от &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; , строки из &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; или строки из обоих соответственно. Длину маркеров конфликта можно &lt;code&gt;--marker-size&lt;/code&gt; с помощью опции --marker-size .</target>
        </trans-unit>
        <trans-unit id="86762a48683c371a4cc7c3de1cb012419562ae87" translate="yes" xml:space="preserve">
          <source>If there are multiple branches, doing &lt;code&gt;git p4 sync&lt;/code&gt; will automatically use the &quot;BRANCH DETECTION&quot; algorithm to try to partition new changes into the right branch. This can be overridden with the &lt;code&gt;--branch&lt;/code&gt; option to specify just a single branch to update.</source>
          <target state="translated">Если есть несколько ветвей, выполнение &lt;code&gt;git p4 sync&lt;/code&gt; будет автоматически использовать алгоритм &amp;laquo;ОБНАРУЖЕНИЕ ВЕТВИ&amp;raquo;, чтобы попытаться разделить новые изменения на правую ветвь. Это можно &lt;code&gt;--branch&lt;/code&gt; с помощью параметра --branch, указав только одну ветвь для обновления.</target>
        </trans-unit>
        <trans-unit id="618accc0d1d550b6b8ec069f55b5b09af649e985" translate="yes" xml:space="preserve">
          <source>If there are multiple instances of the &lt;code&gt;credential.helper&lt;/code&gt; configuration variable, each helper will be tried in turn, and may provide a username, password, or nothing. Once Git has acquired both a username and a password, no more helpers will be tried.</source>
          <target state="translated">Если существует несколько экземпляров переменной конфигурации &lt;code&gt;credential.helper&lt;/code&gt; , каждый помощник будет опробован по очереди и может предоставить имя пользователя, пароль или ничего. Как только Git получит и имя пользователя, и пароль, больше никаких помощников не будет.</target>
        </trans-unit>
        <trans-unit id="af9d46d5bd3ac828de63ddb9d4effe59327aaa5a" translate="yes" xml:space="preserve">
          <source>If there are other repositories that you also use frequently, you can create similar configuration options to save typing; for example,</source>
          <target state="translated">Если есть другие репозитории,которые вы также часто используете,вы можете создать аналогичные опции конфигурации,чтобы сохранить набор текста;например,</target>
        </trans-unit>
        <trans-unit id="591918eb06b2723ac86bd0a089445e6e294cf8c5" translate="yes" xml:space="preserve">
          <source>If there exist packfiles in the pack directory not registered in the MIDX, then those packfiles are loaded into the &lt;code&gt;packed_git&lt;/code&gt; list and &lt;code&gt;packed_git_mru&lt;/code&gt; cache.</source>
          <target state="translated">Если существует packfiles в каталоге пакета не зарегистрирован в MIDX, то эта packfiles загружается в &lt;code&gt;packed_git&lt;/code&gt; список и &lt;code&gt;packed_git_mru&lt;/code&gt; кэш.</target>
        </trans-unit>
        <trans-unit id="03e18f44da1b610f354ea9baeb478307ccf925f8" translate="yes" xml:space="preserve">
          <source>If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular &lt;code&gt;.gitignore&lt;/code&gt; file itself. Otherwise the pattern may also match at any level below the &lt;code&gt;.gitignore&lt;/code&gt; level.</source>
          <target state="translated">Если есть разделитель в начале или в середине (или в обоих) шаблона, то шаблон относится к уровню каталога конкретного файла &lt;code&gt;.gitignore&lt;/code&gt; . В противном случае шаблон также может совпадать на любом уровне ниже уровня &lt;code&gt;.gitignore&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c5dbd4863767291eb0584c1211aa56213f1838" translate="yes" xml:space="preserve">
          <source>If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories.</source>
          <target state="translated">Если в конце детали есть разделитель,то деталь будет совпадать только с каталогами,в противном случае она может совпадать и с файлами,и с каталогами.</target>
        </trans-unit>
        <trans-unit id="7e5e3b6d9186f0b0d9ca9ea83f70b7fee637fea2" translate="yes" xml:space="preserve">
          <source>If there is a separator, then the key will be used instead of both the &amp;lt;token&amp;gt; and the default separator when adding the trailer.</source>
          <target state="translated">Если есть разделитель, то при добавлении трейлера будет использоваться ключ вместо &amp;lt;token&amp;gt; и разделителя по умолчанию.</target>
        </trans-unit>
        <trans-unit id="110096af5aaaf08aca8aad30cdfe6c3abec7eaf2" translate="yes" xml:space="preserve">
          <source>If there is no file or subtree at that path, &lt;code&gt;git fast-import&lt;/code&gt; will instead report</source>
          <target state="translated">Если на этом пути нет файла или поддерева, &lt;code&gt;git fast-import&lt;/code&gt; вместо этого сообщит</target>
        </trans-unit>
        <trans-unit id="1db0218c6ea3cc08d2d45a6158a3df08d714812b" translate="yes" xml:space="preserve">
          <source>If there is no parameter given by the user, use &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">Если пользователь не задан параметром, используйте вместо него &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08079a827cded7daddc3f36e473048d3482101ec" translate="yes" xml:space="preserve">
          <source>If there is only one &amp;lt;tree-ish&amp;gt; given, the commit is compared with its parents (see --stdin below).</source>
          <target state="translated">Если указан только один &amp;lt;tree-ish&amp;gt;, коммит сравнивается с его родительскими (см. --Stdin ниже).</target>
        </trans-unit>
        <trans-unit id="f3b2c7580e6489ea5e91cbe02a9f524e00ba7a5a" translate="yes" xml:space="preserve">
          <source>If there were more commits on the &lt;em&gt;master&lt;/em&gt; branch after the merge, the merge commit itself would not be shown by &lt;em&gt;git show-branch&lt;/em&gt; by default. You would need to provide &lt;code&gt;--sparse&lt;/code&gt; option to make the merge commit visible in this case.</source>
          <target state="translated">Если бы после слияния в &lt;em&gt;главной&lt;/em&gt; ветке было больше коммитов, по умолчанию &lt;em&gt;git show-branch&lt;/em&gt; не показывал бы сам коммит слияния . В этом случае вам нужно будет предоставить параметр &lt;code&gt;--sparse&lt;/code&gt; , чтобы сделать фиксацию слияния видимой.</target>
        </trans-unit>
        <trans-unit id="0ab64f384f8b476963c3f64ac176ef68ee6de9f2" translate="yes" xml:space="preserve">
          <source>If there were uncommitted worktree changes present when the merge started, &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">Если при запуске слияния присутствовали незафиксированные изменения рабочего дерева, &lt;code&gt;git merge --abort&lt;/code&gt; в некоторых случаях не сможет восстановить эти изменения. Поэтому рекомендуется всегда фиксировать или хранить ваши изменения перед запуском &lt;code&gt;git merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="967d5740c3c32e83504fdb7318f7465d81e3c6cb" translate="yes" xml:space="preserve">
          <source>If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the &quot;rest&quot; of the line) are output in place of the &lt;code&gt;%(rest)&lt;/code&gt; atom.</source>
          <target state="translated">Если этот атом используется в выходной строке, входные строки разделяются по первой границе пробела. Все символы перед этим пробелом считаются именем объекта; символы после этого первого пробела (т.е. &amp;laquo;остальная часть&amp;raquo; строки) выводятся вместо атома &lt;code&gt;%(rest)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b6208e01f164e5f8b5cfeffb592a9b059f78c4e" translate="yes" xml:space="preserve">
          <source>If this attribute is not set or has an invalid value, the value of the &lt;code&gt;gui.encoding&lt;/code&gt; configuration variable is used instead (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Если этот атрибут не установлен или имеет недопустимое значение, вместо него используется значение переменной конфигурации &lt;code&gt;gui.encoding&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d21856ae35021bd75d04c1b344656e77c3e714d8" translate="yes" xml:space="preserve">
          <source>If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the &amp;lsquo;GIT_EXTERNAL_DIFF&amp;rsquo; environment variable. The command is called with parameters as described under &quot;git Diffs&quot; in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. Note: if you want to use an external diff program only on a subset of your files, you might want to use &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; instead.</source>
          <target state="translated">Если эта переменная конфигурации установлена, генерация различий выполняется не с использованием внутреннего механизма сравнения, а с использованием данной команды. Может быть переопределено переменной окружения GIT_EXTERNAL_DIFF. Команда вызывается с параметрами, как описано в разделе &amp;laquo;git Diffs&amp;raquo; в &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; . Примечание: если вы хотите использовать внешнюю программу сравнения только с подмножеством ваших файлов, вы можете вместо этого использовать &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c67dbd9b5b9d0c250d594cf0e82ea55d38dac133" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &quot;1&quot;, then commands such as &lt;code&gt;git blame&lt;/code&gt; (in incremental mode), &lt;code&gt;git rev-list&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git check-attr&lt;/code&gt; and &lt;code&gt;git check-ignore&lt;/code&gt; will force a flush of the output stream after each record have been flushed. If this variable is set to &quot;0&quot;, the output of these commands will be done using completely buffered I/O. If this environment variable is not set, Git will choose buffered or record-oriented flushing based on whether stdout appears to be redirected to a file or not.</source>
          <target state="translated">Если для этой переменной среды установлено значение &amp;laquo;1&amp;raquo;, то такие команды, как &lt;code&gt;git blame&lt;/code&gt; (в инкрементном режиме), &lt;code&gt;git rev-list&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git check-attr&lt;/code&gt; и &lt;code&gt;git check-ignore&lt;/code&gt; , будут принудительно очищать выходной поток после каждого запись была сброшена. Если для этой переменной установлено значение &amp;laquo;0&amp;raquo;, вывод этих команд будет осуществляться с использованием полностью буферизованного ввода-вывода. Если эта переменная среды не задана, Git выберет буферизованную или ориентированную на запись очистку в зависимости от того, перенаправляется ли стандартный вывод в файл или нет.</target>
        </trans-unit>
        <trans-unit id="3c510f35b5c52541d7f8ff48371ed312cadc959c" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &lt;code&gt;0&lt;/code&gt;, git will not prompt on the terminal (e.g., when asking for HTTP authentication).</source>
          <target state="translated">Если для этой переменной среды установлено значение &lt;code&gt;0&lt;/code&gt; , git не будет запрашивать на терминале (например, при запросе HTTP-аутентификации).</target>
        </trans-unit>
        <trans-unit id="f0e0816f1f387058c1f2d75f7ff32a01f9295472" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, it overrides Git&amp;rsquo;s autodetection whether &lt;code&gt;GIT_SSH&lt;/code&gt;/&lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt;/&lt;code&gt;core.sshCommand&lt;/code&gt; refer to OpenSSH, plink or tortoiseplink. This variable overrides the config setting &lt;code&gt;ssh.variant&lt;/code&gt; that serves the same purpose.</source>
          <target state="translated">Если эта переменная среды установлена, она переопределяет автоматическое определение Git, относится ли &lt;code&gt;GIT_SSH&lt;/code&gt; / &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; / &lt;code&gt;core.sshCommand&lt;/code&gt; к OpenSSH, plink или tortoiseplink. Эта переменная переопределяет настройку конфигурации &lt;code&gt;ssh.variant&lt;/code&gt; , которая служит той же цели.</target>
        </trans-unit>
        <trans-unit id="81f782a4dbe0e346a4da365c1a6b3a9cbeb4a6e2" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, then Git commands which need to acquire passwords or passphrases (e.g. for HTTP or IMAP authentication) will call this program with a suitable prompt as command-line argument and read the password from its STDOUT. See also the &lt;code&gt;core.askPass&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Если эта переменная среды установлена, то команды Git, которым необходимо получить пароли или парольные фразы (например, для аутентификации HTTP или IMAP), будут вызывать эту программу с подходящей подсказкой в ​​качестве аргумента командной строки и считывать пароль из ее STDOUT. См. Также параметр &lt;code&gt;core.askPass&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="372352ecb2d8c55afffa99890c0eb497f2b1382d" translate="yes" xml:space="preserve">
          <source>If this feature is enabled, gitweb considers projects in subdirectories of project root (basename) to be forks of existing projects. For each project &lt;code&gt;$projname.git&lt;/code&gt;, projects in the &lt;code&gt;$projname/&lt;/code&gt; directory and its subdirectories will not be shown in the main projects list. Instead, a '+' mark is shown next to &lt;code&gt;$projname&lt;/code&gt;, which links to a &quot;forks&quot; view that lists all the forks (all projects in &lt;code&gt;$projname/&lt;/code&gt; subdirectory). Additionally a &quot;forks&quot; view for a project is linked from project summary page.</source>
          <target state="translated">Если эта функция включена, gitweb считает проекты в подкаталогах корневого каталога проекта (базовое имя) ветвями существующих проектов. Для каждого проекта &lt;code&gt;$projname.git&lt;/code&gt; проекты в &lt;code&gt;$projname/&lt;/code&gt; и его подкаталогах не будут отображаться в основном списке проектов. Вместо этого рядом с &lt;code&gt;$projname&lt;/code&gt; отображается знак &amp;laquo;+&amp;raquo; , который ссылается на представление &amp;laquo;вилок&amp;raquo;, в котором перечислены все вилки (все проекты в подкаталоге &lt;code&gt;$projname/&lt;/code&gt; ). Кроме того, на странице сводки проекта есть ссылка на представление &amp;laquo;вилок&amp;raquo; для проекта.</target>
        </trans-unit>
        <trans-unit id="728d51c620f0870eff1b0d62261ab6934369adf2" translate="yes" xml:space="preserve">
          <source>If this field has a true value then the given feature is overridable, which means that it can be configured (or enabled/disabled) on a per-repository basis.</source>
          <target state="translated">Если это поле имеет истинное значение,то данная функция является переопределяемой,что означает,что она может быть сконфигурирована (или включена/выключена)для каждого хранилища.</target>
        </trans-unit>
        <trans-unit id="582826e66f53339e6d7b4dc6a0d6a2edeb312487" translate="yes" xml:space="preserve">
          <source>If this file exists, $GIT_COMMON_DIR (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;) will be set to the path specified in this file if it is not explicitly set. If the specified path is relative, it is relative to $GIT_DIR. The repository with commondir is incomplete without the repository pointed by &quot;commondir&quot;.</source>
          <target state="translated">Если этот файл существует, $ GIT_COMMON_DIR (см. &lt;a href=&quot;git&quot;&gt;Git [1]&lt;/a&gt; ) будет установлен на путь, указанный в этом файле, если он не установлен явно. Если указанный путь относительный, он относительно $ GIT_DIR. Репозиторий с commondir будет неполным без репозитория, указанного с помощью commondir.</target>
        </trans-unit>
        <trans-unit id="1e44552a87aaa0e818702548719ba07ebc0f8696" translate="yes" xml:space="preserve">
          <source>If this file exists, the linked working tree may be on a portable device and not available. The presence of this file prevents &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; from being pruned either automatically or manually by &lt;code&gt;git worktree prune&lt;/code&gt;. The file may contain a string explaining why the repository is locked.</source>
          <target state="translated">Если этот файл существует, связанное рабочее дерево может быть на переносном устройстве и недоступно. Наличие этого файла предотвращает &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; автоматически или вручную с помощью &lt;code&gt;git worktree prune&lt;/code&gt; . Файл может содержать строку, объясняющую, почему репозиторий заблокирован.</target>
        </trans-unit>
        <trans-unit id="6849302064fdf0db00fe326dd1a92636c39a6d43" translate="yes" xml:space="preserve">
          <source>If this hook exits with a non-zero status, &lt;code&gt;git push&lt;/code&gt; will abort without pushing anything. Information about why the push is rejected may be sent to the user by writing to standard error.</source>
          <target state="translated">Если этот хук завершается с ненулевым статусом, &lt;code&gt;git push&lt;/code&gt; прерывается, ничего не нажимая. Информация о том, почему push отклонена, может быть отправлена ​​пользователю путем записи в стандартную ошибку.</target>
        </trans-unit>
        <trans-unit id="59816b743d970f13629ec48afd23da6545a4a7c5" translate="yes" xml:space="preserve">
          <source>If this is a problem for you, you can do a rebase instead, rebasing the branch with the revert onto the other branch. A rebase in this scenario will revert the change, because a rebase applies each individual commit, including the revert. Note that rebases rewrite history, so you should avoid rebasing published branches unless you&amp;rsquo;re sure you&amp;rsquo;re comfortable with that. See the NOTES section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e422a5c19027398b3db2e62a2dfa8c2a2031ac5" translate="yes" xml:space="preserve">
          <source>If this is reinitialization, the repository will be moved to the specified path.</source>
          <target state="translated">При повторной инициализации репозиторий будет перемещен по указанному пути.</target>
        </trans-unit>
        <trans-unit id="ae49e42c53a829e13a69befb7e448cbf7a3ab5aa" translate="yes" xml:space="preserve">
          <source>If this is set to code reference, it will be run once for each request. You can set parts of configuration that change per session this way. For example, one might use the following code in a gitweb configuration file</source>
          <target state="translated">Если установлено кодирование ссылки,то оно будет выполняться один раз для каждого запроса.Таким образом,вы можете установить части конфигурации,которые меняются за сессию.Например,в конфигурационном файле gitweb можно использовать следующий код</target>
        </trans-unit>
        <trans-unit id="2ecaf4f8ea5745cd5a451b94ab44dd28ff120dab" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show diffstat of the stash entry. Defaults to true. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">Если для него установлено значение true, команда &lt;code&gt;git stash show&lt;/code&gt; без параметра покажет diffstat записи тайника. По умолчанию true. См. Описание команды &lt;code&gt;show&lt;/code&gt; в &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee4998fa7e703962f55f3297f84fc3b952ae4a7f" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show the stash entry in patch form. Defaults to false. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">Если для него установлено значение true, команда &lt;code&gt;git stash show&lt;/code&gt; без параметра покажет запись тайника в форме патча. По умолчанию - false. См. Описание команды &lt;code&gt;show&lt;/code&gt; в &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e98f4c395c1b49b1de4c0111925dea856a6d079" translate="yes" xml:space="preserve">
          <source>If this is set, add emails found in Signed-off-by: or Cc: lines to the cc list. Default is the value of &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; configuration value; if that is unspecified, default to --signed-off-by-cc.</source>
          <target state="translated">Если это установлено, добавьте электронные письма, найденные в строках Signed-off-by: или Cc: в список cc. По умолчанию используется значение конфигурации &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; ; если это не указано, по умолчанию --signed-off-by-cc.</target>
        </trans-unit>
        <trans-unit id="196233ff4443211f5e0668c5723fedda5c2f6715" translate="yes" xml:space="preserve">
          <source>If this is set, add emails found in the &lt;code&gt;Signed-off-by&lt;/code&gt; trailer or Cc: lines to the cc list. Default is the value of &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; configuration value; if that is unspecified, default to --signed-off-by-cc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf7f20765eaeb225b14832d24072d63179e161f" translate="yes" xml:space="preserve">
          <source>If this is set, do not add the From: address to the cc: list. Default is the value of &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; configuration value; if that is unspecified, default to --no-suppress-from.</source>
          <target state="translated">Если это установлено, не добавляйте адрес From: в список cc :. По умолчанию используется значение конфигурации &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; ; если это не указано, по умолчанию --no-suppress-from.</target>
        </trans-unit>
        <trans-unit id="048d4528d0951754849879e2b4b5802f6461c9fb" translate="yes" xml:space="preserve">
          <source>If this is set, each email will be sent as a reply to the previous email sent. If disabled with &quot;--no-chain-reply-to&quot;, all emails after the first will be sent as replies to the first email sent. When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; configuration variable can be used to enable it.</source>
          <target state="translated">Если это установлено, каждое электронное письмо будет отправляться как ответ на предыдущее отправленное письмо. Если отключено с помощью &amp;laquo;--no-chain-reply-to&amp;raquo;, все электронные письма после первого будут отправлены как ответы на первое отправленное письмо. При его использовании рекомендуется, чтобы первый предоставленный файл был обзором всей серии исправлений. По умолчанию отключено, но для его &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; можно использовать переменную конфигурации sendemail.chainReplyTo .</target>
        </trans-unit>
        <trans-unit id="b4073ff276c4f44294d676470e6aaaeb5a46458f" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of &lt;code&gt;sendemail.cccover&lt;/code&gt; configuration value; if that is unspecified, default to --no-cc-cover.</source>
          <target state="translated">Если это установлено, электронные письма, найденные в заголовках Cc: в первом патче серии (обычно сопроводительное письмо), добавляются в список cc для каждого набора адресов электронной почты. По умолчанию используется значение конфигурации &lt;code&gt;sendemail.cccover&lt;/code&gt; ; если это не указано, по умолчанию используется --no-cc-cover.</target>
        </trans-unit>
        <trans-unit id="c3505cfc9a16fb3a406321b32681f1c27b3f4828" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of &lt;code&gt;sendemail.tocover&lt;/code&gt; configuration value; if that is unspecified, default to --no-to-cover.</source>
          <target state="translated">Если это установлено, электронные письма, найденные в заголовках &amp;laquo;Кому:&amp;raquo; в первом патче серии (обычно сопроводительное письмо), добавляются в список &amp;laquo;Кому&amp;raquo; для каждого набора адресов электронной почты. По умолчанию используется значение конфигурации &lt;code&gt;sendemail.tocover&lt;/code&gt; ; если это не указано, по умолчанию используется --no-to-cover.</target>
        </trans-unit>
        <trans-unit id="bd074611e2ce23fe3651c7c21615bc5d5c90b653" translate="yes" xml:space="preserve">
          <source>If this is set, the In-Reply-To and References headers will be added to each email sent. Whether each mail refers to the previous email (&lt;code&gt;deep&lt;/code&gt; threading per &lt;code&gt;git format-patch&lt;/code&gt; wording) or to the first email (&lt;code&gt;shallow&lt;/code&gt; threading) is governed by &quot;--[no-]chain-reply-to&quot;.</source>
          <target state="translated">Если это установлено, заголовки In-Reply-To и References будут добавляться к каждому отправляемому электронному письму. Относится ли каждое письмо к предыдущему электронному письму ( &lt;code&gt;deep&lt;/code&gt; цепочка в соответствии с формулировкой &lt;code&gt;git format-patch&lt;/code&gt; ) или к первому электронному письму ( &lt;code&gt;shallow&lt;/code&gt; цепочка ответов) регулируется &amp;laquo;- [no-] chain-reply-to&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="83fefd231faf2237df4d2ca57ddb91f5733dd174" translate="yes" xml:space="preserve">
          <source>If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules.</source>
          <target state="translated">Если эта опция присутствует и в записи субмодулей в .git/config суперпроекта,то настройка там переопределит найденную в .gitmodules.</target>
        </trans-unit>
        <trans-unit id="b576cec09f399abde10801d9e3b482a3974a7942" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support partial clone and partial fetch object filtering.</source>
          <target state="translated">Если этот параметр установлен, &lt;code&gt;upload-pack&lt;/code&gt; будет поддерживать фильтрацию объектов частичного клонирования и частичной выборки.</target>
        </trans-unit>
        <trans-unit id="46df2747ed059ec465747bf23f6d93b6698f2ce3" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support the &lt;code&gt;ref-in-want&lt;/code&gt; feature of the protocol version 2 &lt;code&gt;fetch&lt;/code&gt; command. This feature is intended for the benefit of load-balanced servers which may not have the same view of what OIDs their refs point to due to replication delay.</source>
          <target state="translated">Если этот параметр установлен, &lt;code&gt;upload-pack&lt;/code&gt; будет поддерживать функцию &lt;code&gt;ref-in-want&lt;/code&gt; команды &lt;code&gt;fetch&lt;/code&gt; версии 2 протокола . Эта функция предназначена для серверов с балансировкой нагрузки, которые могут не иметь одинакового представления о том, на какие OID указывают их ссылки из-за задержки репликации.</target>
        </trans-unit>
        <trans-unit id="3691063a71adef86ec77db2886b5e8b672228551" translate="yes" xml:space="preserve">
          <source>If this option is set, when &lt;code&gt;upload-pack&lt;/code&gt; would run &lt;code&gt;git pack-objects&lt;/code&gt; to create a packfile for a client, it will run this shell command instead. The &lt;code&gt;pack-objects&lt;/code&gt; command and arguments it &lt;code&gt;would&lt;/code&gt; have run (including the &lt;code&gt;git pack-objects&lt;/code&gt; at the beginning) are appended to the shell command. The stdin and stdout of the hook are treated as if &lt;code&gt;pack-objects&lt;/code&gt; itself was run. I.e., &lt;code&gt;upload-pack&lt;/code&gt; will feed input intended for &lt;code&gt;pack-objects&lt;/code&gt; to the hook, and expects a completed packfile on stdout.</source>
          <target state="translated">Если этот параметр установлен, когда &lt;code&gt;upload-pack&lt;/code&gt; будет запускать &lt;code&gt;git pack-objects&lt;/code&gt; для создания файла пакета для клиента, вместо этого будет выполнена эта команда оболочки. Команда &lt;code&gt;pack-objects&lt;/code&gt; и аргументы, которые она &lt;code&gt;would&lt;/code&gt; была запустить (включая &lt;code&gt;git pack-objects&lt;/code&gt; в начале), добавляются к команде оболочки. Stdin и stdout хука обрабатываются так, как если бы был запущен сам &lt;code&gt;pack-objects&lt;/code&gt; . Т.е., &lt;code&gt;upload-pack&lt;/code&gt; будет передавать обработчику ввод, предназначенный для &lt;code&gt;pack-objects&lt;/code&gt; , и ожидает завершенный packfile на stdout.</target>
        </trans-unit>
        <trans-unit id="043d313af4e6bae8eb0dfe37d6ed595c4f6e4603" translate="yes" xml:space="preserve">
          <source>If this option is specified and &lt;code&gt;git svn&lt;/code&gt; encounters an SVN committer name that does not exist in the authors-file, &lt;code&gt;git svn&lt;/code&gt; will abort operation. The user will then have to add the appropriate entry. Re-running the previous &lt;code&gt;git svn&lt;/code&gt; command after the authors-file is modified should continue operation.</source>
          <target state="translated">Если эта опция указана и &lt;code&gt;git svn&lt;/code&gt; встречает имя коммиттера SVN, которого нет в файле авторов, &lt;code&gt;git svn&lt;/code&gt; прервет операцию. Затем пользователю нужно будет добавить соответствующую запись. Повторный запуск предыдущей команды &lt;code&gt;git svn&lt;/code&gt; после изменения файла авторов должен продолжить работу.</target>
        </trans-unit>
        <trans-unit id="8c74599d52dc4064f88f6e7b7729fbf0a87fa3fe" translate="yes" xml:space="preserve">
          <source>If this option is specified one or more times, then only run the specified tasks in the specified order. If no &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; arguments are specified, then only the tasks with &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.enabled&lt;/code&gt; configured as &lt;code&gt;true&lt;/code&gt; are considered. See the &lt;code&gt;TASKS&lt;/code&gt; section for the list of accepted &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c99ad12996bd9192637a1c1520fb2b24def75b" translate="yes" xml:space="preserve">
          <source>If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument. The program is expected to return a single line of the form &quot;Name &amp;lt;email&amp;gt;&quot; or &quot;Name &amp;lt;&amp;gt;&quot;, which will be treated as if included in the authors file.</source>
          <target state="translated">Если указана эта опция, для каждого имени коммиттера SVN, которого нет в файле авторов, данный файл выполняется с именем коммиттера в качестве первого аргумента. Ожидается, что программа вернет одну строку в форме &amp;laquo;Имя &amp;lt;электронная почта&amp;gt;&amp;raquo; или &amp;laquo;Имя &amp;lt;&amp;gt;&amp;raquo;, которая будет обрабатываться так, как если бы она была включена в файл авторов.</target>
        </trans-unit>
        <trans-unit id="9706c1068d7b5bd67656b65aa296c50f3e651323" translate="yes" xml:space="preserve">
          <source>If this variable is not specified, it defaults to &lt;code&gt;normal&lt;/code&gt;. This variable can be overridden with the -u|--untracked-files option of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">Если эта переменная не указана, по умолчанию используется &lt;code&gt;normal&lt;/code&gt; . Эту переменную можно переопределить с помощью параметра -u | --untracked-files команд &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; и &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b0cae3fed40383cf5d614f1da46a2c524e4930e" translate="yes" xml:space="preserve">
          <source>If this variable is set to &quot;1&quot;, &quot;2&quot; or &quot;true&quot; (comparison is case insensitive), trace messages will be printed to stderr.</source>
          <target state="translated">Если эта переменная установлена в &quot;1&quot;,&quot;2&quot; или &quot;true&quot; (сравнение не чувствительно к регистру),то сообщения о трассировке будут распечатываться в stderr.</target>
        </trans-unit>
        <trans-unit id="c1357386502b4e540a41766c550326b57fc0ea56" translate="yes" xml:space="preserve">
          <source>If this variable is set to a path, non-worktree files that are normally in $GIT_DIR will be taken from this path instead. Worktree-specific files such as HEAD or index are taken from $GIT_DIR. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; and &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; for details. This variable has lower precedence than other path variables such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY&amp;hellip;​</source>
          <target state="translated">Если для этой переменной задан путь, файлы, не относящиеся к рабочему дереву, которые обычно находятся в $ GIT_DIR, будут взяты из этого пути. Файлы, относящиеся к рабочему дереву, такие как HEAD или index, берутся из $ GIT_DIR. См. Подробности в &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; и &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]&lt;/a&gt; . Эта переменная имеет более низкий приоритет, чем другие переменные пути, такие как GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="8249d2ab5516fac15cd6ed908f0ba3c1a12338b5" translate="yes" xml:space="preserve">
          <source>If this variable is set, &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command is in the same form as the &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; environment variable and is overridden when the environment variable is set.</source>
          <target state="translated">Если эта переменная установлена, &lt;code&gt;git fetch&lt;/code&gt; и &lt;code&gt;git push&lt;/code&gt; будут использовать указанную команду вместо &lt;code&gt;ssh&lt;/code&gt; , когда им нужно подключиться к удаленной системе. Команда имеет ту же форму, что и переменная среды &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; , и переопределяется при установке переменной среды.</target>
        </trans-unit>
        <trans-unit id="e4e675f6ba8abd4a71f30087b18137ff3c23311f" translate="yes" xml:space="preserve">
          <source>If this variable is set, the default hash algorithm for new repositories will be set to this value. This value is currently ignored when cloning; the setting of the remote repository is used instead. The default is &quot;sha1&quot;. THIS VARIABLE IS EXPERIMENTAL! See &lt;code&gt;--object-format&lt;/code&gt; in &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af55b279f11e2f816fa42fab0cbda45b206e1ef" translate="yes" xml:space="preserve">
          <source>If timestamps of commits in the CVS repository are not stable enough to be used for ordering commits changes may show up in the wrong order.</source>
          <target state="translated">Если временные метки коммитов в CVS репозитории недостаточно стабильны для того,чтобы их можно было использовать для заказа изменений коммитов,то они могут отображаться в неправильном порядке.</target>
        </trans-unit>
        <trans-unit id="51615abc07df5f5fedb19397be1e475bae29e04c" translate="yes" xml:space="preserve">
          <source>If true (default), a single editor instance will be spawned to edit files you have to edit (patches when &lt;code&gt;--annotate&lt;/code&gt; is used, and the summary when &lt;code&gt;--compose&lt;/code&gt; is used). If false, files will be edited one after the other, spawning a new editor each time.</source>
          <target state="translated">Если true (по умолчанию), будет создан один экземпляр редактора для редактирования файлов, которые вы должны редактировать (патчи, когда используется &lt;code&gt;--annotate&lt;/code&gt; , и сводка, когда используется &lt;code&gt;--compose&lt;/code&gt; ). Если false, файлы будут редактироваться один за другим, каждый раз создавая новый редактор.</target>
        </trans-unit>
        <trans-unit id="6c99dc0ffc12cab74a91d9cd9821ddfe241990c4" translate="yes" xml:space="preserve">
          <source>If true prevents displaying information about repository owner.</source>
          <target state="translated">Если значение true предотвращает отображение информации о владельце репозитория.</target>
        </trans-unit>
        <trans-unit id="fad7b766b28596874c184072e4308f81cec3bb8e" translate="yes" xml:space="preserve">
          <source>If true the web server started by &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; will be bound to the local IP (127.0.0.1).</source>
          <target state="translated">Если true, веб-сервер, запущенный &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1],&lt;/a&gt; будет привязан к локальному IP (127.0.0.1).</target>
        </trans-unit>
        <trans-unit id="24fc21f99a5940a5b287a59503e7df044758b9be" translate="yes" xml:space="preserve">
          <source>If true this repository is assumed to be &lt;code&gt;bare&lt;/code&gt; and has no working directory associated with it. If this is the case a number of commands that require a working directory will be disabled, such as &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; or &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, этот репозиторий считается &lt;code&gt;bare&lt;/code&gt; и не имеет связанного с ним рабочего каталога. В этом случае ряд команд, которым требуется рабочий каталог, будут отключены, например, &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; или &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18d14681f32fdc08f62b0e7a189d6a89008757fd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;git gui blame&lt;/code&gt; uses &lt;code&gt;-C&lt;/code&gt; instead of &lt;code&gt;-C -C&lt;/code&gt; for original location detection. It makes blame significantly faster on huge repositories at the expense of less thorough copy detection.</source>
          <target state="translated">Если это правда, &lt;code&gt;git gui blame&lt;/code&gt; использует &lt;code&gt;-C&lt;/code&gt; вместо &lt;code&gt;-C -C&lt;/code&gt; для определения исходного местоположения. Это значительно ускоряет поиск виновных в огромных репозиториях за счет менее тщательного обнаружения копий.</target>
        </trans-unit>
        <trans-unit id="a4dc06197e1e60c2601c1eee394ecb56132cf3c4" translate="yes" xml:space="preserve">
          <source>If true, Git will avoid using lstat() calls to detect if files have changed by setting the &quot;assume-unchanged&quot; bit for those tracked files which it has updated identically in both the index and working tree.</source>
          <target state="translated">Если переменная имеет значение true,Git избежит использования вызовов lstat()для обнаружения изменений в файлах,установив бит &quot;assumee-unchanged&quot; для тех отслеживаемых файлов,которые он обновил идентично как в индексе,так и в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="f52d8aadd1ed60dd80b38e7a96aadc385cabb931" translate="yes" xml:space="preserve">
          <source>If true, Git will warn you if the ref name you passed it is ambiguous and might match multiple refs in the repository. True by default.</source>
          <target state="translated">Если переменная имеет значение true,Git предупредит вас,если имя ссылки,которую вы передали,неоднозначно и может совпадать с несколькими ссылками в репозитории.По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="b4f1cbcb9d6580097e1319f75786e1aefcc4a19a" translate="yes" xml:space="preserve">
          <source>If true, allow clients to use &lt;code&gt;git archive --remote&lt;/code&gt; to request any tree, whether reachable from the ref tips or not. See the discussion in the &quot;SECURITY&quot; section of &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for more details. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Если true, разрешите клиентам использовать &lt;code&gt;git archive --remote&lt;/code&gt; для запроса любого дерева, независимо от того, доступно ли оно из подсказок или нет. См. Обсуждение в разделе &amp;laquo;БЕЗОПАСНОСТЬ&amp;raquo; в &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt; для получения более подробной информации. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9577d8134a35c2d555845d35ede1972ec309a7fc" translate="yes" xml:space="preserve">
          <source>If true, enable &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; for use by remote clients via &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt;. Defaults to false for user-defined formats, but true for the &quot;tar.gz&quot; and &quot;tgz&quot; formats.</source>
          <target state="translated">Если это правда, включите &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; для использования удаленными клиентами через &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt; . По умолчанию false для форматов, определяемых пользователем, но верно для форматов tar.gz и tgz.</target>
        </trans-unit>
        <trans-unit id="5f15956c2db32b4b1b45dac474661942b8aa7008" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, выборка будет автоматически вести себя так, как если бы в &lt;code&gt;--prune&lt;/code&gt; была указана опция --prune . См. Также &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; и раздел PRUNING в &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7d985f4709f0d26edc0babef707e65f833d349aa" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec was provided when pruning, if not set already. This allows for setting both this option and &lt;code&gt;fetch.prune&lt;/code&gt; to maintain a 1=1 mapping to upstream refs. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, выборка будет автоматически вести себя так, как если бы &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec был предоставлен при сокращении, если он еще не установлен. Это позволяет установить как этот параметр, так и &lt;code&gt;fetch.prune&lt;/code&gt; , чтобы поддерживать отображение 1 = 1 для исходных ссылок . См. Также &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; и раздел PRUNING в &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2de6ae2b37da0c5dc299e33fe86fea1c6d9d4a0f" translate="yes" xml:space="preserve">
          <source>If true, git-am will call git-mailsplit for patches in mbox format with parameter &lt;code&gt;--keep-cr&lt;/code&gt;. In this case git-mailsplit will not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;. Can be overridden by giving &lt;code&gt;--no-keep-cr&lt;/code&gt; from the command line. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;, &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, git-am вызовет git-mailsplit для патчей в формате mbox с параметром &lt;code&gt;--keep-cr&lt;/code&gt; . В этом случае git-mailsplit не удалит &lt;code&gt;\r&lt;/code&gt; из строк, заканчивающихся на &lt;code&gt;\r\n&lt;/code&gt; . Можно изменить, указав &lt;code&gt;--no-keep-cr&lt;/code&gt; из командной строки. См. &lt;a href=&quot;git-am&quot;&gt;Git-am [1]&lt;/a&gt; , &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94bf962607289b1694c70432d3fab451c61737d" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--abbrev-commit&lt;/code&gt;. You may override this option with &lt;code&gt;--no-abbrev-commit&lt;/code&gt;.</source>
          <target state="translated">Если истинно, то &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; принимают значение &lt;code&gt;--abbrev-commit&lt;/code&gt; . Вы можете переопределить эту опцию с помощью &lt;code&gt;--no-abbrev-commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7c96ef3a79b38b8c56dee4db799ed4d172ce90c" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--show-signature&lt;/code&gt;.</source>
          <target state="translated">Если истина, то &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; предполагают &lt;code&gt;--show-signature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cb33eaf81fb27f3c3d3ba0e81d6670ba0d0bfaf" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--use-mailmap&lt;/code&gt;, otherwise assume &lt;code&gt;--no-use-mailmap&lt;/code&gt;. True by default.</source>
          <target state="translated">Если истинно, то &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; предполагают &lt;code&gt;--use-mailmap&lt;/code&gt; , иначе &lt;code&gt;--no-use-mailmap&lt;/code&gt; . По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="672cef13127670a717c7a3aa65681a15ad776d1b" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt; (and therefore &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;) act by default as if the --scissors option was provided on the command-line. When active, this features removes everything from the message body before a scissors line (i.e. consisting mainly of &quot;&amp;gt;8&quot;, &quot;8&amp;lt;&quot; and &quot;-&quot;).</source>
          <target state="translated">Если true, заставляет &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt; (и, следовательно, &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; ) действовать по умолчанию, как если бы в командной строке была указана опция --scissors. В активном состоянии эта функция удаляет все из тела сообщения до линии &amp;laquo;ножницы&amp;raquo; (т.е. состоящей в основном из &amp;laquo;&amp;gt; 8&amp;raquo;, &amp;laquo;8 &amp;lt;&amp;raquo; и &amp;laquo;-&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="d25b510a17b04a17cfbdc40d0999d1586f4d5f91" translate="yes" xml:space="preserve">
          <source>If true, makes Git check if converting &lt;code&gt;CRLF&lt;/code&gt; is reversible when end-of-line conversion is active. Git will verify if a command modifies a file in the work tree either directly or indirectly. For example, committing a file followed by checking out the same file should yield the original file in the work tree. If this is not the case for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;, Git will reject the file. The variable can be set to &quot;warn&quot;, in which case Git will only warn about an irreversible conversion but continue the operation.</source>
          <target state="translated">Если true, Git проверяет, является ли преобразование &lt;code&gt;CRLF&lt;/code&gt; обратимым, когда активно преобразование конца строки. Git проверит, изменяет ли команда файл в рабочем дереве прямо или косвенно. Например, фиксация файла с последующим извлечением того же файла должна привести к появлению исходного файла в дереве работы. Если это не так для текущей настройки &lt;code&gt;core.autocrlf&lt;/code&gt; , Git отклонит файл. Переменная может иметь значение &amp;laquo;предупреждать&amp;raquo;, и в этом случае Git будет предупреждать только о необратимом преобразовании, но продолжит операцию.</target>
        </trans-unit>
        <trans-unit id="3a6f979740fe111373346b7083b54b9e059af003" translate="yes" xml:space="preserve">
          <source>If true, omit the column with date of the most current commit on the projects list page. It can save a bit of I/O and a fork per repository.</source>
          <target state="translated">Если переменная имеет значение true,опустите колонку с датой последнего фиксации на странице списка проектов.Это может сохранить немного ввода/вывода и вилку для каждого репозитория.</target>
        </trans-unit>
        <trans-unit id="9e101a02df349b50a39b60288665a643391bcf24" translate="yes" xml:space="preserve">
          <source>If true, pushing to this remote will automatically behave as if the &lt;code&gt;--mirror&lt;/code&gt; option was given on the command line.</source>
          <target state="translated">Если true, нажатие на этот пульт будет автоматически вести себя так, как если бы в &lt;code&gt;--mirror&lt;/code&gt; была указана опция --mirror .</target>
        </trans-unit>
        <trans-unit id="561edb27b58ccdfdecb1aae75865de22935f3cd3" translate="yes" xml:space="preserve">
          <source>If true, some gitweb features are disabled to prevent content in repositories from launching cross-site scripting (XSS) attacks. Set this to true if you don&amp;rsquo;t trust the content of your repositories. False by default (set to 0).</source>
          <target state="translated">Если это правда, некоторые функции gitweb отключены, чтобы контент в репозиториях не запускал атаки межсайтового скриптинга (XSS). Установите значение true, если вы не доверяете содержимому своих репозиториев. По умолчанию false (установлено значение 0).</target>
        </trans-unit>
        <trans-unit id="698e5f4a0ab76eb97600c890fa9adac3c5e93fa4" translate="yes" xml:space="preserve">
          <source>If true, the initial commit will be shown as a big creation event. This is equivalent to a diff against an empty tree. Tools like &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; or &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;, which normally hide the root commit will now show it. True by default.</source>
          <target state="translated">Если true, начальная фиксация будет отображаться как большое событие создания. Это эквивалентно сравнению с пустым деревом. Такие инструменты, как &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; или &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; , которые обычно скрывают корневой коммит, теперь покажут его. По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="7f4771e5273a3a0e51423699c29e2caf790623f9" translate="yes" xml:space="preserve">
          <source>If true, the server will look up the end-of-line conversion attributes for files to determine the &lt;code&gt;-k&lt;/code&gt; modes to use. If the attributes force Git to treat a file as text, the &lt;code&gt;-k&lt;/code&gt; mode will be left blank so CVS clients will treat it as text. If they suppress text conversion, the file will be set with &lt;code&gt;-kb&lt;/code&gt; mode, which suppresses any newline munging the client might otherwise do. If the attributes do not allow the file type to be determined, then &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">Если это правда, сервер будет искать атрибуты преобразования конца строки для файлов, чтобы определить используемые режимы &lt;code&gt;-k&lt;/code&gt; . Если атрибуты заставляют Git обрабатывать файл как текст, режим &lt;code&gt;-k&lt;/code&gt; останется пустым, поэтому клиенты CVS будут рассматривать его как текст. Если они подавляют преобразование текста, для файла будет установлен режим &lt;code&gt;-kb&lt;/code&gt; , который подавляет любое изменение новой строки, которое клиент мог бы сделать иначе. Если атрибуты не позволяют определить тип файла, используется &lt;code&gt;gitcvs.allBinary&lt;/code&gt; . См. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36ac6e641c359be495ff334484c92173e0b7c3c8" translate="yes" xml:space="preserve">
          <source>If true, the split-index feature of the index will be used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">Если true, то будет использоваться функция индексации с разделением. См. &lt;a href=&quot;git-update-index&quot;&gt;Git-update-index [1]&lt;/a&gt; . По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="521397cd2bc3f328c7b75df2807813cd34103bfb" translate="yes" xml:space="preserve">
          <source>If true, then gc will rewrite the commit-graph file when &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; is run. When using &lt;code&gt;git gc --auto&lt;/code&gt; the commit-graph will be updated if housekeeping is required. Default is true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for details.</source>
          <target state="translated">Если true, то gc перепишет файл графика фиксации при запуске &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; . При использовании &lt;code&gt;git gc --auto&lt;/code&gt; график фиксации будет обновлен, если требуется обслуживание. По умолчанию верно. См. Подробности в &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="902fdcf00401d2e7de222ff42ce846a756cbb163" translate="yes" xml:space="preserve">
          <source>If true, then git will read the commit-graph file (if it exists) to parse the graph structure of commits. Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="translated">Если true, то git прочитает файл графика фиксации (если он существует), чтобы проанализировать структуру графика коммитов. По умолчанию true. См. &lt;a href=&quot;git-commit-graph&quot;&gt;Git-commit-graph [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ca076926e8bbfce2f59c8069a39ed42dca4bb470" translate="yes" xml:space="preserve">
          <source>If true, then git will use the changed-path Bloom filters in the commit-graph file (if it exists, and they are present). Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615bfb2827e0f7022b5822b60fa7f8c63365efe6" translate="yes" xml:space="preserve">
          <source>If true, this is equivalent to the --verify-signatures command line option. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">Если true, это эквивалентно параметру командной строки --verify-signatures. Подробнее см. &lt;a href=&quot;git-merge&quot;&gt;Git-merge [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ab6fd64e80cf040c0dbc59c3bda45e3cb1c29b3" translate="yes" xml:space="preserve">
          <source>If true, this remote will be skipped by default when updating using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or the &lt;code&gt;update&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">Если true, этот пульт будет пропущен по умолчанию при обновлении с помощью &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; или подкоманды &lt;code&gt;update&lt;/code&gt; &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="537153cdd9a230b7ef7748cee5c002a80aec5646" translate="yes" xml:space="preserve">
          <source>If we compute the following non optimal function on it:</source>
          <target state="translated">Если мы вычислим следующую неоптимальную функцию:</target>
        </trans-unit>
        <trans-unit id="b2bbf437e467ca2cfec5d122277b398062cce56a" translate="yes" xml:space="preserve">
          <source>If we examined all this history together in one repository, it will look like:</source>
          <target state="translated">Если мы рассмотрим всю эту историю вместе в одном репозитории,она будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="f77fa3523026c17c64002e6f77dd7e18ad8c7cf7" translate="yes" xml:space="preserve">
          <source>If we have moved away from commit &lt;code&gt;f&lt;/code&gt;, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which &lt;code&gt;HEAD&lt;/code&gt; referred, we can use either of these commands:</source>
          <target state="translated">Если мы отошли от коммита &lt;code&gt;f&lt;/code&gt; , мы должны сначала восстановить его имя объекта (обычно с помощью git reflog), а затем мы можем создать ссылку на него. Например, чтобы увидеть последние два коммита, на которые ссылается &lt;code&gt;HEAD&lt;/code&gt; , мы можем использовать любую из этих команд:</target>
        </trans-unit>
        <trans-unit id="1d5fb2a96e98dbf044763df4f4d84c289b1a7a1e" translate="yes" xml:space="preserve">
          <source>If we look at the way commits are created under the cover, we&amp;rsquo;ll see that there are more flexible ways creating commits.</source>
          <target state="translated">Если мы посмотрим, как создаются коммиты под обложкой, мы увидим, что есть более гибкие способы создания коммитов.</target>
        </trans-unit>
        <trans-unit id="2a7aed1833634138d2979858dc472c551054c3f5" translate="yes" xml:space="preserve">
          <source>If we need to talk about a particular commit, the character &quot;o&quot; may be replaced with another letter or number.</source>
          <target state="translated">Если нам нужно поговорить о конкретном коммите,то символ &quot;о&quot; может быть заменен другой буквой или цифрой.</target>
        </trans-unit>
        <trans-unit id="73117dc442919d58c7658111f0e65fc3ffc2d92d" translate="yes" xml:space="preserve">
          <source>If width is &lt;code&gt;0&lt;/code&gt; (zero) then indent the lines of the output without wrapping them.</source>
          <target state="translated">Если ширина равна &lt;code&gt;0&lt;/code&gt; (нулю), то отступите строки вывода, не оборачивая их.</target>
        </trans-unit>
        <trans-unit id="a0f8f4ea612137fd1324a3c99aa8cca8319d30d8" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;+&lt;/code&gt; (plus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">Если вы добавляете знак &lt;code&gt;+&lt;/code&gt; (плюс) после &lt;code&gt;%&lt;/code&gt; заполнителя, перевод строки вставляется непосредственно перед раскрытием, если и только если заполнитель расширяется до непустой строки.</target>
        </trans-unit>
        <trans-unit id="f83e564943919127dff3b2d8ad2099402ce321cb" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;-&lt;/code&gt; (minus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.</source>
          <target state="translated">Если вы добавляете &lt;code&gt;-&lt;/code&gt; (знак минус) после &lt;code&gt;%&lt;/code&gt; заполнителя, все последовательные переводы строки, непосредственно предшествующие раскрытию, удаляются тогда и только тогда, когда заполнитель расширяется до пустой строки.</target>
        </trans-unit>
        <trans-unit id="a78fb3b12f14b3649d1e2f03162a9771701e268a" translate="yes" xml:space="preserve">
          <source>If you add a ` ` (space) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">Если вы добавляете `` (пробел) после &lt;code&gt;%&lt;/code&gt; заполнителя, пробел вставляется непосредственно перед раскрытием, если и только если заполнитель расширяется до непустой строки.</target>
        </trans-unit>
        <trans-unit id="2c694abd299e141b455acf195b0e2c24045c8fb9" translate="yes" xml:space="preserve">
          <source>If you allow overriding for the snapshot feature, you can specify which snapshot formats are globally disabled. You can also add any command-line options you want (such as setting the compression level). For instance, you can disable Zip compressed snapshots and set &lt;strong&gt;gzip&lt;/strong&gt;(1) to run at level 6 by adding the following lines to your gitweb configuration file:</source>
          <target state="translated">Если вы разрешаете переопределение для функции моментального снимка, вы можете указать, какие форматы моментального снимка глобально отключены. Вы также можете добавить любые параметры командной строки, которые хотите (например, установить уровень сжатия). Например, вы можете отключить сжатые снимки Zip и настроить &lt;strong&gt;gzip&lt;/strong&gt; (1) для работы на уровне 6, добавив следующие строки в файл конфигурации gitweb:</target>
        </trans-unit>
        <trans-unit id="1eda80bb2b9aeb620d19886733f7a0a33613b07f" translate="yes" xml:space="preserve">
          <source>If you already use &lt;code&gt;mod_userdir&lt;/code&gt; in your virtual host or you don&amp;rsquo;t want to use the '~' as first character, just comment or remove the second rewrite rule, and uncomment one of the following according to what you want.</source>
          <target state="translated">Если вы уже используете &lt;code&gt;mod_userdir&lt;/code&gt; на своем виртуальном хосте или не хотите использовать '~' в качестве первого символа, просто прокомментируйте или удалите второе правило перезаписи и раскомментируйте одно из следующего в соответствии с тем, что вы хотите.</target>
        </trans-unit>
        <trans-unit id="28aab4433d981c882862a14d41ff2a1b6ecf68f5" translate="yes" xml:space="preserve">
          <source>If you also want to see complete diffs at each step, use</source>
          <target state="translated">Если вы также хотите видеть полные различия на каждом шаге,используйте</target>
        </trans-unit>
        <trans-unit id="cc8e02bd7d5fd8efba31a3f28960e44c003964ed" translate="yes" xml:space="preserve">
          <source>If you and the maintainer both have accounts on the same machine, then you can just pull changes from each other&amp;rsquo;s repositories directly; commands that accept repository URLs as arguments will also accept a local directory name:</source>
          <target state="translated">Если у вас и сопровождающего есть учетные записи на одном компьютере, вы можете просто получать изменения напрямую из репозиториев друг друга; Команды, которые принимают URL-адреса репозитория в качестве аргументов, также принимают имя локального каталога:</target>
        </trans-unit>
        <trans-unit id="41ebdd5e935074b399d696e8dc1f4204152e3f63" translate="yes" xml:space="preserve">
          <source>If you are a contributor that sends changes upstream in the form of emails, you should use topic branches as usual (see above). Then use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; to generate the corresponding emails (highly recommended over manually formatting them because it makes the maintainer&amp;rsquo;s life easier).</source>
          <target state="translated">Если вы являетесь участником, который отправляет изменения вверх по течению в форме электронных писем, вам следует использовать тематические ветки как обычно (см. Выше). Затем используйте &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; для создания соответствующих писем (настоятельно рекомендуется, а не форматировать их вручную, потому что это облегчает жизнь сопровождающему).</target>
        </trans-unit>
        <trans-unit id="f7586aada4dc4dabc26450bca6e988967f6c8334" translate="yes" xml:space="preserve">
          <source>If you are a maintainer and would like to merge other people&amp;rsquo;s topic branches to the integration branches, they will typically send a request to do so by mail. Such a request looks like</source>
          <target state="translated">Если вы сопровождаете и хотите объединить тематические ветки других людей с ветвями интеграции, они обычно отправляют запрос на это по почте. Такой запрос выглядит как</target>
        </trans-unit>
        <trans-unit id="6a4170b1f048a116a2a20a0123a6634648180f67" translate="yes" xml:space="preserve">
          <source>If you are coming from a CVS background, the style of cooperation suggested in the previous section may be new to you. You do not have to worry. Git supports the &quot;shared public repository&quot; style of cooperation you are probably more familiar with as well.</source>
          <target state="translated">Если вы пришли из CVS фона,стиль сотрудничества,предложенный в предыдущем разделе,может быть новым для вас.Вам не нужно беспокоиться.Git поддерживает стиль сотрудничества &quot;общий публичный репозиторий&quot;,с которым вы,вероятно,знакомы больше.</target>
        </trans-unit>
        <trans-unit id="d473d9569ed7194445a9c66a5a376371d037be9a" translate="yes" xml:space="preserve">
          <source>If you are creating a branch that you want to switch to immediately, it is easier to use the &quot;git switch&quot; command with its &lt;code&gt;-c&lt;/code&gt; option to do the same thing with a single command.</source>
          <target state="translated">Если вы создаете ветку, на которую хотите немедленно переключиться, проще использовать команду &amp;laquo;git switch&amp;raquo; с опцией &lt;code&gt;-c&lt;/code&gt; , чтобы сделать то же самое с одной командой.</target>
        </trans-unit>
        <trans-unit id="882d5e43cce8c196ac8e463999e712ea9e114942" translate="yes" xml:space="preserve">
          <source>If you are following somebody else&amp;rsquo;s tree, you are most likely using remote-tracking branches (eg. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;). You usually want the tags from the other end.</source>
          <target state="translated">Если вы следите за чужим деревом, вы, скорее всего, используете ветки удаленного отслеживания (например, &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; ). Обычно вам нужны теги с другого конца.</target>
        </trans-unit>
        <trans-unit id="0f51d0b61f348c2beb156a534ba33bcb5f141385" translate="yes" xml:space="preserve">
          <source>If you are going to offer CVS access via pserver, add a line in /etc/inetd.conf like</source>
          <target state="translated">Если вы собираетесь предложить доступ к CVS через pserver,добавьте строку в файле /etc/inetd.conf like</target>
        </trans-unit>
        <trans-unit id="e1c58ac4057b121c58f1f5681f07adc3f2f06c66" translate="yes" xml:space="preserve">
          <source>If you are instead primarily interested in using Git to fetch a project, for example, to test the latest version, you may prefer to start with the first two chapters of &lt;a href=&quot;user-manual&quot;&gt;The Git User&amp;rsquo;s Manual&lt;/a&gt;.</source>
          <target state="translated">Если вместо этого вы в первую очередь заинтересованы в использовании Git для получения проекта, например, для тестирования последней версии, вы можете предпочесть начать с первых двух глав &lt;a href=&quot;user-manual&quot;&gt;Руководства пользователя Git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ce35cf81da423ef90a67288a1d702b7e25d4c6b" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="translated">Если вас интересуют более подробные сведения о процессе просмотра изменений, просто взгляните на первую реализацию &lt;code&gt;cmd_log()&lt;/code&gt; ; вызовите &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; и прокрутите вниз до этой функции (обратите внимание, что вам больше не нужно вызывать &lt;code&gt;setup_pager()&lt;/code&gt; напрямую).</target>
        </trans-unit>
        <trans-unit id="9ac179f42cb3351e666e44e39b35f145be521392" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0~155^2~4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b0f41c084141a75721908d0d5d7971792ac89f" translate="yes" xml:space="preserve">
          <source>If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use &lt;code&gt;git stash&lt;/code&gt; to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary.</source>
          <target state="translated">Если вы не совсем уверены в том, что промежуточные ревизии являются согласованными (они компилируются, проходят тестовый набор и т. Д.), Вам следует использовать &lt;code&gt;git stash&lt;/code&gt; , чтобы спрятать еще не зафиксированные изменения после каждого коммита, протестировать и изменить коммит, если исправлены необходимы.</target>
        </trans-unit>
        <trans-unit id="f188b17d328d7a9e1b61bcc0d2e0defbbf399561" translate="yes" xml:space="preserve">
          <source>If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too (and can also report changes to a submodule&amp;rsquo;s work tree).</source>
          <target state="translated">Если вас интересуют только изменения инициализированных в данный момент подмодулей относительно фиксации, записанной в индексе или HEAD, &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; и &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; также предоставят эту информацию (а также могут сообщить об изменениях в дерево работы подмодуля).</target>
        </trans-unit>
        <trans-unit id="9fb9a58a453e5ac1de19a98e53575241a40d1da0" translate="yes" xml:space="preserve">
          <source>If you are paranoid, running &lt;code&gt;git verify-pack&lt;/code&gt; command would detect if you have a corrupt pack, but do not worry too much. Our programs are always perfect ;-).</source>
          <target state="translated">Если вы параноик, запуск команды &lt;code&gt;git verify-pack&lt;/code&gt; определит, есть ли у вас поврежденный пакет, но не беспокойтесь слишком сильно. Наши программы всегда безупречны ;-).</target>
        </trans-unit>
        <trans-unit id="277e03057ecd44d387d6f501d21982d9ff59224b" translate="yes" xml:space="preserve">
          <source>If you are repacking very old imported data (e.g. older than the last year), consider expending some extra CPU time and supplying --window=50 (or higher) when you run &lt;code&gt;git repack&lt;/code&gt;. This will take longer, but will also produce a smaller packfile. You only need to expend the effort once, and everyone using your project will benefit from the smaller repository.</source>
          <target state="translated">Если вы переупаковываете очень старые импортированные данные (например, старше, чем в прошлом году), подумайте о том, чтобы потратить дополнительное время процессора и указать --window = 50 (или выше) при запуске &lt;code&gt;git repack&lt;/code&gt; . Это займет больше времени, но при этом будет создан пакетный файл меньшего размера. Вам нужно затратить усилия только один раз, и каждый, кто использует ваш проект, получит пользу от меньшего хранилища.</target>
        </trans-unit>
        <trans-unit id="c500814f6020ec6c3d1c5a9b455910ea7fc36da1" translate="yes" xml:space="preserve">
          <source>If you are using &quot;git bisect run&quot;, you can use the same manual fix up as above, and then start another &quot;git bisect run&quot; in the special branch. Or as the &quot;git bisect&quot; man page says, the script passed to &quot;git bisect run&quot; can apply a patch before it compiles and test the software &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;. The patch should turn a current untestable commits into a testable one. So the testing will result in &quot;good&quot; or &quot;bad&quot; and &quot;git bisect&quot; will be able to find the first bad commit. And the script should not forget to remove the patch once the testing is done before exiting from the script.</source>
          <target state="translated">Если вы используете &amp;laquo;git bisect run&amp;raquo;, вы можете использовать то же ручное исправление, что и выше, а затем запустить еще один &amp;laquo;git bisect run&amp;raquo; в специальной ветке. Или, как сказано на странице руководства &amp;laquo;git bisect&amp;raquo;, сценарий, переданный команде &amp;laquo;git bisect run&amp;raquo;, может применить патч до компиляции и тестирования программного обеспечения &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt; . Патч должен превратить текущие непроверяемые коммиты в проверяемые. Таким образом, результатом тестирования будет &amp;laquo;хорошо&amp;raquo; или &amp;laquo;плохо&amp;raquo;, а &amp;laquo;git bisect&amp;raquo; сможет найти первую плохую фиксацию. И сценарий не должен забывать удалить патч после завершения тестирования перед выходом из сценария.</target>
        </trans-unit>
        <trans-unit id="c6c0585fbbb0e19d850e67091effac179b4cf010" translate="yes" xml:space="preserve">
          <source>If you blow the index away entirely, you generally haven&amp;rsquo;t lost any information as long as you have the name of the tree that it described.</source>
          <target state="translated">Если вы полностью удалите индекс, вы, как правило, не потеряете никакой информации, если у вас есть имя дерева, которое он описывает.</target>
        </trans-unit>
        <trans-unit id="2d2eeeb68a563ca60a2c585f75afbad9b4a5940e" translate="yes" xml:space="preserve">
          <source>If you both have a test suite and use git bisect, then it becomes less important to check that all tests pass after each commit. Though of course it is probably a good idea to have some checks to avoid breaking too many things because it could make bisecting other bugs more difficult.</source>
          <target state="translated">Если у вас обоих есть тестовый набор и вы используете git-бисект,то становится менее важным проверить,что все тесты проходят после каждого коммита.Хотя,конечно,возможно,было бы неплохо иметь несколько проверок,чтобы не сломать слишком много вещей,потому что это может усложнить биссектрису других ошибок.</target>
        </trans-unit>
        <trans-unit id="7c966eb4fc191c72371d7ddd65b21062f03ccb57" translate="yes" xml:space="preserve">
          <source>If you can do that, you can now recreate the missing object with</source>
          <target state="translated">Если вы можете это сделать,то теперь вы можете воссоздать отсутствующий объект с помощью функции</target>
        </trans-unit>
        <trans-unit id="5c6e6ccfdc26bd491d9ed428be6d535f807a44d7" translate="yes" xml:space="preserve">
          <source>If you choose to wait for the repack, don&amp;rsquo;t try to run benchmarks or performance tests until repacking is completed. fast-import outputs suboptimal packfiles that are simply never seen in real use situations.</source>
          <target state="translated">Если вы решите дождаться переупаковки, не пытайтесь запускать тесты производительности или тесты производительности, пока переупаковка не будет завершена. fast-import выводит неоптимальные файлы пакетов, которые просто никогда не встречаются в реальных ситуациях использования.</target>
        </trans-unit>
        <trans-unit id="db9a66177c2b117d0740a2ed1a511dcc1bea6811" translate="yes" xml:space="preserve">
          <source>If you decide that you&amp;rsquo;d rather see version 2.6.17, you can modify the current branch to point at v2.6.17 instead, with</source>
          <target state="translated">Если вы решите, что предпочитаете версию 2.6.17, вы можете изменить текущую ветвь, указав вместо этого на v2.6.17, с помощью</target>
        </trans-unit>
        <trans-unit id="c943de9e92fabf055b174eed9b10ced62cf6d401" translate="yes" xml:space="preserve">
          <source>If you decide you want the history back, you can always create a new reference pointing to it, for example, a new branch:</source>
          <target state="translated">Если вы решили,что хотите вернуть историю,вы всегда можете создать новую ссылку на неё,например,новое ответвление:</target>
        </trans-unit>
        <trans-unit id="1f288af5e76ef5a4f231f5810c9960b284e03991" translate="yes" xml:space="preserve">
          <source>If you develop on a branch crazy-idea, then regret it, you can always delete the branch with</source>
          <target state="translated">Если вы развиваетесь на сумасшедшей ветке,то пожалеете об этом,вы всегда можете удалить ветку с помощью</target>
        </trans-unit>
        <trans-unit id="6d7822c644d713e2101d339a30a68a502f988e1b" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t specify the CVSROOT/CVS_SERVER directly in the checkout command, automatically saving it in your &lt;code&gt;CVS/Root&lt;/code&gt; files, then you need to set them explicitly in your environment. CVSROOT should be set as per normal, but the directory should point at the appropriate Git repo. As above, for SSH clients &lt;code&gt;not&lt;/code&gt; restricted to &lt;code&gt;git-shell&lt;/code&gt;, CVS_SERVER should be set to &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">Если вы не указали CVSROOT / CVS_SERVER непосредственно в команде checkout, автоматически сохранив его в ваших файлах &lt;code&gt;CVS/Root&lt;/code&gt; , то вам необходимо явно установить их в своей среде. CVSROOT должен быть установлен как обычно, но каталог должен указывать на соответствующий репозиторий Git. Как и выше, для клиентов SSH, &lt;code&gt;not&lt;/code&gt; ограниченных &lt;code&gt;git-shell&lt;/code&gt; , CVS_SERVER следует установить на &lt;code&gt;git-cvsserver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="467e5efa7fe7a25688df5c19177b2c4b9a971487" translate="yes" xml:space="preserve">
          <source>If you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:</source>
          <target state="translated">Если вы обнаружили ошибку при указании статуса ревизии,вы можете сохранить вывод этой команды в файл,отредактировать его,чтобы удалить неправильные записи,а затем выдать следующие команды,чтобы вернуться в исправленное состояние:</target>
        </trans-unit>
        <trans-unit id="fdb535b3114700ba9158b47e1cadbbb4ffee0391" translate="yes" xml:space="preserve">
          <source>If you do merge, note the following rule: &lt;code&gt;git svn dcommit&lt;/code&gt; will attempt to commit on top of the SVN commit named in</source>
          <target state="translated">Если вы выполняете слияние, обратите внимание на следующее правило: &lt;code&gt;git svn dcommit&lt;/code&gt; попытается выполнить фиксацию поверх фиксации SVN, указанной в</target>
        </trans-unit>
        <trans-unit id="d7d53a76c809507d4642710878a2561fe720cf02" translate="yes" xml:space="preserve">
          <source>If you do not have &lt;code&gt;mod_rewrite&lt;/code&gt; available to match against the query string, it is sufficient to just protect &lt;code&gt;git-receive-pack&lt;/code&gt; itself, like:</source>
          <target state="translated">Если у вас нет доступного &lt;code&gt;mod_rewrite&lt;/code&gt; для сопоставления со строкой запроса, достаточно просто защитить сам &lt;code&gt;git-receive-pack&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="61817ad83cf40051c64b68562493dd77ca2fe6f8" translate="yes" xml:space="preserve">
          <source>If you do not have this configuration variable, the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; is used instead.</source>
          <target state="translated">Если у вас нет этой переменной конфигурации, вместо &lt;code&gt;i18n.commitEncoding&lt;/code&gt; используется значение i18n.commitEncoding .</target>
        </trans-unit>
        <trans-unit id="14f3fbb24beba0c7fa85b6385a5b3979968f4593" translate="yes" xml:space="preserve">
          <source>If you do not know the encoding of a file, then you can use the &lt;code&gt;file&lt;/code&gt; command to guess the encoding:</source>
          <target state="translated">Если вы не знаете кодировку файла, вы можете использовать команду &lt;code&gt;file&lt;/code&gt; , чтобы угадать кодировку:</target>
        </trans-unit>
        <trans-unit id="371074e4db6e9a2527bbe63c09ef576231a57ee5" translate="yes" xml:space="preserve">
          <source>If you do not want this feature on your server just remove the second rewrite rule.</source>
          <target state="translated">Если вы не хотите,чтобы эта функция присутствовала на вашем сервере,просто удалите второе правило перезаписи.</target>
        </trans-unit>
        <trans-unit id="b68a865397b0b847cde7a3d94bca4e3b8a2b1c61" translate="yes" xml:space="preserve">
          <source>If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back.</source>
          <target state="translated">Если вы не хотите потерять свою работу (историю от X до B)или работу другого человека (историю от X до A),вам нужно сначала получить историю из репозитория,создать историю,содержащую изменения,сделанные обеими сторонами,и оттолкнуть результат назад.</target>
        </trans-unit>
        <trans-unit id="86c596eda084e162303624098fd515841984d889" translate="yes" xml:space="preserve">
          <source>If you do this, then you should make a public announcement indicating that &lt;code&gt;next&lt;/code&gt; was rewound and rebuilt.</source>
          <target state="translated">Если вы это сделаете, то вы должны сделать публичное объявление о том, что &lt;code&gt;next&lt;/code&gt; был перемотан и восстановлен.</target>
        </trans-unit>
        <trans-unit id="325a3c2222e4d4aaa5c937ccab45f34c95352c49" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to continue with that right away, a few other digressions that may be interesting at this point are:</source>
          <target state="translated">Если вы не хотите сразу же продолжать это, сделайте еще несколько интересных отступлений:</target>
        </trans-unit>
        <trans-unit id="bf36326b8dfc35954574299040bce7c304964cb4" translate="yes" xml:space="preserve">
          <source>If you enable PATH_INFO usage in gitweb by putting</source>
          <target state="translated">Если вы включите использование PATH_INFO в gitweb,поставив</target>
        </trans-unit>
        <trans-unit id="3e267e16654424679545d579a56c2fc25a567700" translate="yes" xml:space="preserve">
          <source>If you examine the file &lt;code&gt;.git/config&lt;/code&gt;, you will see that Git has added a new stanza:</source>
          <target state="translated">Если вы изучите файл &lt;code&gt;.git/config&lt;/code&gt; , вы увидите, что Git добавил новую строфу:</target>
        </trans-unit>
        <trans-unit id="adaf459f23d870ce117760016108b7b8ca67ba63" translate="yes" xml:space="preserve">
          <source>If you examine the resulting commit using gitk, you will see that it has two parents, one pointing to the top of the current branch, and one to the top of the other branch.</source>
          <target state="translated">Если вы изучите полученный коммит с помощью gitk,то увидите,что у него есть два родителя,один из которых указывает на вершину текущей ветки,а другой-на вершину другой ветки.</target>
        </trans-unit>
        <trans-unit id="f87315138be947ec0afa0ac1351920e4dfe2a0c2" translate="yes" xml:space="preserve">
          <source>If you find some reason to set this option to &lt;code&gt;false&lt;/code&gt;, other than one-off testing, you should report the behavior difference as a bug in Git (see &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; for details).</source>
          <target state="translated">Если вы найдете какую-либо причину для установки этого параметра в значение &lt;code&gt;false&lt;/code&gt; , кроме разового тестирования, вы должны сообщить о различии в поведении как об ошибке в Git ( подробности см. На &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="73749649a005053153ee8a2fa11f927ee43ebec2" translate="yes" xml:space="preserve">
          <source>If you find that some maintenance windows are taking longer than one hour to complete, then consider reducing the complexity of your maintenance tasks. For example, the &lt;code&gt;gc&lt;/code&gt; task is much slower than the &lt;code&gt;incremental-repack&lt;/code&gt; task. However, this comes at a cost of a slightly larger object database. Consider moving more expensive tasks to be run less frequently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbcb62743d9f0aa650833d05c94c3e3db4eb4e0d" translate="yes" xml:space="preserve">
          <source>If you find you forked off the wrong branch and want to move it &quot;back in time&quot;, use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">Если вы обнаружили, что разветвлены не на той ветке, и хотите переместить ее &amp;laquo;назад во времени&amp;raquo;, используйте &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12cef549aa55079a651285c652b78bc4bc8af80c" translate="yes" xml:space="preserve">
          <source>If you find you need new features from the branch &lt;code&gt;other&lt;/code&gt; to continue working on your topic, merge &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;topic&lt;/code&gt;. (However, do not do this &quot;just habitually&quot;, see below.)</source>
          <target state="translated">Если вы обнаружите, что вам нужны новые функции из &lt;code&gt;other&lt;/code&gt; ветки, чтобы продолжить работу над своей темой, объедините &lt;code&gt;other&lt;/code&gt; с &lt;code&gt;topic&lt;/code&gt; . (Однако не делайте этого &amp;laquo;просто по привычке&amp;raquo;, см. Ниже.)</target>
        </trans-unit>
        <trans-unit id="c89cdceb268014744fee40998409a87331a70cef" translate="yes" xml:space="preserve">
          <source>If you followed the last paragraph, you will now have many small topic branches, and occasionally wonder how they interact. Perhaps the result of merging them does not even work? But on the other hand, we want to avoid merging them anywhere &quot;stable&quot; because such merges cannot easily be undone.</source>
          <target state="translated">Если вы следовали последнему параграфу,то теперь у вас будет много маленьких тематических ветвей,и время от времени вы будете задаваться вопросом,как они взаимодействуют.Может быть,результат их слияния даже не сработает? Но,с другой стороны,мы хотим избежать их слияния в любом &quot;стабильном&quot; месте,потому что такие слияния не могут быть легко отменены.</target>
        </trans-unit>
        <trans-unit id="f8ccc691fa447494e794dd8643eee96c05ab0ca5" translate="yes" xml:space="preserve">
          <source>If you get stuck and decide to just give up and throw the whole mess away, you can always return to the pre-merge state with</source>
          <target state="translated">Если ты застрянешь и решишь просто сдаться и выкинуть весь беспорядок,ты всегда можешь вернуться в состояние предварительной торговли с помощью</target>
        </trans-unit>
        <trans-unit id="8d7c02e3dd22e344be3301eb8a2278c07f5b614c" translate="yes" xml:space="preserve">
          <source>If you grasp the ideas in that initial commit, you should check out a more recent version and skim &lt;code&gt;cache.h&lt;/code&gt;, &lt;code&gt;object.h&lt;/code&gt; and &lt;code&gt;commit.h&lt;/code&gt;.</source>
          <target state="translated">Если вы уловили идеи этого первоначального коммита, вам следует проверить более свежую версию и просмотреть &lt;code&gt;cache.h&lt;/code&gt; , &lt;code&gt;object.h&lt;/code&gt; и &lt;code&gt;commit.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b91c4875b14e285ca788a5bd5edf75dfcd9633ab" translate="yes" xml:space="preserve">
          <source>If you have a clone of git.git itself, the output of &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; can show you the authors for specific parts of the project.</source>
          <target state="translated">Если у вас есть клон самого git.git, в выходных данных &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; и &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; можно увидеть авторов конкретных частей проекта.</target>
        </trans-unit>
        <trans-unit id="d76da65add1ab668fa52a438912f17a42719fc64" translate="yes" xml:space="preserve">
          <source>If you have a repository where all the branches of interest exist as subdirectories of a single depot path, you can use &lt;code&gt;--detect-branches&lt;/code&gt; when cloning or syncing to have &lt;code&gt;git p4&lt;/code&gt; automatically find subdirectories in p4, and to generate these as branches in Git.</source>
          <target state="translated">Если у вас есть репозиторий, в котором все интересующие ветви существуют как подкаталоги одного пути к депо, вы можете использовать &lt;code&gt;--detect-branches&lt;/code&gt; при клонировании или синхронизации, чтобы &lt;code&gt;git p4&lt;/code&gt; автоматически находил подкаталоги в p4 и генерировал их как ветки в Git ,</target>
        </trans-unit>
        <trans-unit id="0a6081c46922db10b6bc6f47a7f76b221a6196d2" translate="yes" xml:space="preserve">
          <source>If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:</source>
          <target state="translated">Если у вас есть скрипт,который может определить,хороший у вас исходный код или плохой,вы можете сделать бисекс,выпустив команду:</target>
        </trans-unit>
        <trans-unit id="863f4e57810f45268a83fecc8614e1be7d434564" translate="yes" xml:space="preserve">
          <source>If you have added attributes to a file that cause the canonical repository format for that file to change, such as adding a clean/smudge filter or text/eol/ident attributes, merging anything where the attribute is not in place would normally cause merge conflicts.</source>
          <target state="translated">Если вы добавили в файл атрибуты,которые приводят к изменению канонического формата хранилища этого файла,например,добавление фильтра чистоты/масла или атрибутов text/eol/ident,то слияние всего,где атрибут отсутствует,обычно приводит к конфликтам слияния.</target>
        </trans-unit>
        <trans-unit id="0176ab2e378e3df6f1e24b7af5113bcd1e2d5987" translate="yes" xml:space="preserve">
          <source>If you have an old Git that does not understand the version 2 &lt;code&gt;*.idx&lt;/code&gt; file, cloning or fetching over a non native protocol (e.g. &quot;http&quot;) that will copy both &lt;code&gt;*.pack&lt;/code&gt; file and corresponding &lt;code&gt;*.idx&lt;/code&gt; file from the other side may give you a repository that cannot be accessed with your older version of Git. If the &lt;code&gt;*.pack&lt;/code&gt; file is smaller than 2 GB, however, you can use &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt; on the *.pack file to regenerate the &lt;code&gt;*.idx&lt;/code&gt; file.</source>
          <target state="translated">Если у вас есть старый Git, который не понимает файл &lt;code&gt;*.idx&lt;/code&gt; версии 2 , клонирование или выборка по неродному протоколу (например, &amp;laquo;http&amp;raquo;), который скопирует как файл &lt;code&gt;*.pack&lt;/code&gt; ,так и соответствующий файл &lt;code&gt;*.idx&lt;/code&gt; с другой стороны может предоставить вам репозиторий, к которому нельзя получить доступ из вашей старой версии Git. Однако, &lt;code&gt;*.pack&lt;/code&gt; файл * .pack меньше 2 ГБ, вы можете использовать &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack [1]&lt;/a&gt; в файле * .pack для регенерации файла &lt;code&gt;*.idx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c4d7bfb0f77357b6cf0e14e83f75e3ad3892e2a" translate="yes" xml:space="preserve">
          <source>If you have an unfortunate branch that is named &lt;code&gt;hello.c&lt;/code&gt;, this step would be confused as an instruction to switch to that branch. You should instead write:</source>
          <target state="translated">Если у вас есть неудачная ветка с именем &lt;code&gt;hello.c&lt;/code&gt; , этот шаг можно спутать с инструкцией по переключению на эту ветку. Вместо этого вы должны написать:</target>
        </trans-unit>
        <trans-unit id="6748330dc78a7c7da8f6ed8d92c497a5f2638cdd" translate="yes" xml:space="preserve">
          <source>If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface.</source>
          <target state="translated">Если вы импортировали некоторые изменения из другой ВКС и хотите добавить теги для основных релизов вашей работы,полезно иметь возможность указать дату для встраивания внутри объекта тега;такие данные в объекте тега влияют,например,на порядок расположения тегов в gitweb-интерфейсе.</target>
        </trans-unit>
        <trans-unit id="d87d691ee6c65f8321e66034d85f79793605b8a9" translate="yes" xml:space="preserve">
          <source>If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">Если у вас есть локальные изменения в одном или нескольких файлах,которые отличаются между текущей веткой и веткой,в которую вы переключаетесь,команда отказывается переключать ветки,чтобы сохранить ваши изменения в контексте.Однако,с помощью этой опции выполняется трёхстороннее слияние между текущим ответвлением,содержимым вашего рабочего дерева и новым ответвлением,и вы будете находиться в новом ответвлении.</target>
        </trans-unit>
        <trans-unit id="8478bf298413f91bee793cf9d5101299eaa200bd" translate="yes" xml:space="preserve">
          <source>If you have multifactor authentication setup on your gmail account, you will need to generate an app-specific password for use with &lt;code&gt;git send-email&lt;/code&gt;. Visit &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt; to create it.</source>
          <target state="translated">Если в вашей учетной записи Gmail настроена многофакторная проверка подлинности, вам потребуется сгенерировать пароль для конкретного приложения для использования с &lt;code&gt;git send-email&lt;/code&gt; . Посетите &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords,&lt;/a&gt; чтобы создать его.</target>
        </trans-unit>
        <trans-unit id="a8709177c278b5c18333d173ba933d08e65c6841" translate="yes" xml:space="preserve">
          <source>If you have some initial content (say, a tarball):</source>
          <target state="translated">Если у вас есть какое-то начальное содержание (скажем,тарбол):</target>
        </trans-unit>
        <trans-unit id="495e5ec3bcea1de47c24c2073588d5c3b0cf061c" translate="yes" xml:space="preserve">
          <source>If you have these three &lt;code&gt;gitattributes&lt;/code&gt; file:</source>
          <target state="translated">Если у вас есть эти три файла &lt;code&gt;gitattributes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8c8ea948fec03c8051df6ee29e66dada48224b15" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes in your submodule working tree, &lt;code&gt;git
submodule update&lt;/code&gt; will not overwrite them. Instead, you get the usual warning about not being able switch from a dirty branch.</source>
          <target state="translated">Если в рабочем дереве вашего подмодуля есть незафиксированные изменения, &lt;code&gt;git submodule update&lt;/code&gt; не перезапишет их. Вместо этого вы получите обычное предупреждение о невозможности переключения с грязной ветки.</target>
        </trans-unit>
        <trans-unit id="8d0e9d461fd9a2a62902f7fa232c913269bc56dd" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t specified an editor specifically for Git, it will by default use the editor you&amp;rsquo;ve configured using the &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; environment variables, or if neither is specified, the system default (which is usually &lt;code&gt;vi&lt;/code&gt;). Since some people find &lt;code&gt;vi&lt;/code&gt; difficult to use or prefer a different editor, it may be desirable to change the editor used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ccda3cb1e710a989feb173887174c1818fd9d4a" translate="yes" xml:space="preserve">
          <source>If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with &lt;code&gt;rm&lt;/code&gt; (as opposed to &lt;code&gt;git rm&lt;/code&gt;), use &lt;code&gt;git commit -a&lt;/code&gt;, as it will automatically notice and record all removals. You can also have a similar effect without committing by using &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">Если вы предполагаете, что ваша следующая фиксация должна записывать все модификации отслеживаемых файлов в рабочем дереве и записывать все удаления файлов, которые были удалены из рабочего дерева с помощью &lt;code&gt;rm&lt;/code&gt; (в отличие от &lt;code&gt;git rm&lt;/code&gt; ), используйте &lt;code&gt;git commit -a&lt;/code&gt; , поскольку он автоматически заметит и запишет все удаления. Вы также можете получить аналогичный эффект без фиксации, используя &lt;code&gt;git add -u&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5223949abb561108f8606da60ebd3c3b78a9872c" translate="yes" xml:space="preserve">
          <source>If you intend to set up a shared public repository that all developers can read/write, or if you want to use &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;, then you probably want to make a bare clone of the imported repository, and use the clone as the shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Если вы намереваетесь создать общий публичный репозиторий, который могут читать / писать все разработчики, или если вы хотите использовать &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; , то вы, вероятно, захотите создать голый клон импортированного репозитория и использовать его как общий репозиторий. См. &lt;a href=&quot;gitcvs-migration&quot;&gt;Gitcvs-migration [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e8fe75eb0be8caf3b1c84cce78f8d98c5c3831c" translate="yes" xml:space="preserve">
          <source>If you just have a few changes, the simplest way to submit them may just be to send them as patches in email:</source>
          <target state="translated">Если у вас есть только несколько изменений,самый простой способ отправить их по электронной почте-это отправить их как патчи:</target>
        </trans-unit>
        <trans-unit id="c3509063d9c8d28fc350d64af9974d7f7ad07d9f" translate="yes" xml:space="preserve">
          <source>If you just need to use Git as a revision control system you may prefer to start with &quot;A Tutorial Introduction to Git&quot; (&lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;) or &lt;a href=&quot;user-manual&quot;&gt;the Git User Manual&lt;/a&gt;.</source>
          <target state="translated">Если вам просто нужно использовать Git в качестве системы контроля версий, вы можете предпочесть начать с &amp;laquo;Введение в Git&amp;raquo; ( &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; ) или &lt;a href=&quot;user-manual&quot;&gt;Руководства пользователя Git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a839fbf210e306e2136c31f2a968baa357075d1" translate="yes" xml:space="preserve">
          <source>If you just want to edit the commit message for a commit, replace the command &quot;pick&quot; with the command &quot;reword&quot;.</source>
          <target state="translated">Если вы просто хотите отредактировать сообщение о фиксации для фиксации,замените команду &quot;pick&quot; на команду &quot;reword&quot;.</target>
        </trans-unit>
        <trans-unit id="1a22bf44debddb2b1654740b48fdcb88c27e49eb" translate="yes" xml:space="preserve">
          <source>If you just want to get the newest copies of the integration branches, staying up to date is easy too:</source>
          <target state="translated">Если вы просто хотите получить новейшие копии интеграционных ветвей,оставаться в курсе событий тоже легко:</target>
        </trans-unit>
        <trans-unit id="5a13a90084d33cb33125eb2c50fff6e07ce8c0d9" translate="yes" xml:space="preserve">
          <source>If you just want to look at an old version of the file, without modifying the working directory, you can do that with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;:</source>
          <target state="translated">Если вы просто хотите просмотреть старую версию файла, не изменяя рабочий каталог, вы можете сделать это с помощью &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5af7e34f55f5a635b889f9cb9a1ef742b6e402c4" translate="yes" xml:space="preserve">
          <source>If you just want to run git as if it was started in &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; then use &lt;code&gt;git -C &amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f30cb563d71e3909ec492d5d34c92facf1030b" translate="yes" xml:space="preserve">
          <source>If you just want to verify whether a given tagged version contains a given commit, you could use &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;:</source>
          <target state="translated">Если вы просто хотите проверить, содержит ли данная версия с тегами заданный коммит, вы можете использовать &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d8a6261ebe4a4d52d4d9a2234a54f319605d4abc" translate="yes" xml:space="preserve">
          <source>If you keep your primary branches immediately under &lt;code&gt;refs/heads&lt;/code&gt;, and topic branches in subdirectories of it, having the following in the configuration file may help:</source>
          <target state="translated">Если вы держите свои основные ветки сразу в &lt;code&gt;refs/heads&lt;/code&gt; , а тематические ветки в его подкаталогах, может помочь следующее в файле конфигурации:</target>
        </trans-unit>
        <trans-unit id="933889a0268ded50e3304543b4e7167783337a6d" translate="yes" xml:space="preserve">
          <source>If you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">Если вы заранее знаете более одной хорошей фиксации, вы можете сузить пространство пополам, указав все хорошие коммиты сразу после плохой фиксации при выполнении команды &lt;code&gt;bisect start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d0efb22e26170e5f6a2a2c939fcf419b948a8aa" translate="yes" xml:space="preserve">
          <source>If you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the basis, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command. Here are more examples:</source>
          <target state="translated">Если вы знаете, до какой фиксации предполагаемый репозиторий получателя должен иметь необходимые объекты, вы можете использовать эти знания для определения основы, давая точку отсечения для ограничения ревизий и объектов, которые входят в результирующий пакет. В предыдущем примере для этой цели использовался тег lastR2bundle, но вы можете использовать любые другие параметры, которые вы задали бы команде &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; . Вот еще примеры:</target>
        </trans-unit>
        <trans-unit id="6178dcf6380091f437345048b81ae6acd9e3fdb2" translate="yes" xml:space="preserve">
          <source>If you leave out the commit name, &lt;code&gt;git grep&lt;/code&gt; will search any of the files it manages in your current directory. So</source>
          <target state="translated">Если вы не укажете имя коммита, &lt;code&gt;git grep&lt;/code&gt; будет искать любой из файлов, которыми он управляет в вашем текущем каталоге. Так</target>
        </trans-unit>
        <trans-unit id="1d3a773743dd2af35a158be46f7bad29aaa6f592" translate="yes" xml:space="preserve">
          <source>If you like to live dangerously, you can replace &lt;strong&gt;all&lt;/strong&gt; core.gitproxy by a new one with</source>
          <target state="translated">Если вам нравится жить опасно, вы можете заменить &lt;strong&gt;весь&lt;/strong&gt; core.gitproxy на новый с</target>
        </trans-unit>
        <trans-unit id="9bff9b22c3bcd9cedd5449471391b1cdf79647bb" translate="yes" xml:space="preserve">
          <source>If you make a commit and then find a mistake immediately after that, you can recover from it with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">Если вы сделаете фиксацию, а затем сразу после этого обнаружите ошибку, вы можете исправить ее с помощью &lt;code&gt;git reset&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de1cbbe8d26471b895b54a3d07b205ed1595e0f4" translate="yes" xml:space="preserve">
          <source>If you make a commit that you later wish you hadn&amp;rsquo;t, there are two fundamentally different ways to fix the problem:</source>
          <target state="translated">Если вы совершаете фиксацию, которую позже пожалели, что этого не делали, есть два принципиально разных способа решить проблему:</target>
        </trans-unit>
        <trans-unit id="99ec09f13fb1346102b0f372f091bd234e630539" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;pu&lt;/code&gt;.</source>
          <target state="translated">Если вы дадите (очень) понять, что эта ветка будет удалена сразу после тестирования, вы даже можете опубликовать эту ветку, например, чтобы дать тестировщикам возможность поработать с ней, или другим разработчикам шанс увидеть, незавершенная работа будет совместима. &lt;code&gt;git.git&lt;/code&gt; есть такая официальная ветка интеграции, которая называется &lt;code&gt;pu&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2711d396bb29a520681068259bdc58e0b9b32fcb" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d532db8eaaa16fed286ca601d3c879ce0db79d29" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git checkout&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="translated">Если вы примете решение запустить новую ветку в какой-то другой момент истории, кроме текущего &lt;code&gt;HEAD&lt;/code&gt; , вы можете сделать это, просто указав &lt;code&gt;git checkout&lt;/code&gt; , какой будет база для проверки. Другими словами, если у вас есть более ранний тег или ветка, вы просто выполните</target>
        </trans-unit>
        <trans-unit id="9f31f9c748a9e0ffbef8f11bc85a6ff4ec5b3e8d" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git switch&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef318d408cfc2262e9ecdfec6313bac5c50bc49a" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead.</source>
          <target state="translated">Если вы вручную перемещаете связанное рабочее дерево, вам необходимо обновить файл &lt;code&gt;gitdir&lt;/code&gt; в каталоге записи. Например, если связанное рабочее дерево перемещено в &lt;code&gt;/newpath/test-next&lt;/code&gt; , а его файл &lt;code&gt;.git&lt;/code&gt; указывает на &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; , обновите &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; вместо ссылки на &lt;code&gt;/newpath/test-next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0359d10c71e55182679347b30eaf723b449ffc8c" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead. Better yet, run &lt;code&gt;git worktree repair&lt;/code&gt; to reestablish the connection automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb87bde3a880515ee52eb5a157ecf80cef103126" translate="yes" xml:space="preserve">
          <source>If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:</source>
          <target state="translated">Если вы по ошибке сбросили или очистили заначки,их невозможно восстановить с помощью обычных механизмов безопасности.Тем не менее,вы можете попробовать следующее заклинание,чтобы получить список тайников,которые все еще находятся в вашем репозитории,но больше недоступны:</target>
        </trans-unit>
        <trans-unit id="110b0b8058519e9efd87b798163b83180b4fd090" translate="yes" xml:space="preserve">
          <source>If you need to add &lt;code&gt;Acked-by&lt;/code&gt; lines to, say, the last 10 commits (none of which is a merge), use this command:</source>
          <target state="translated">Если вам нужно добавить &lt;code&gt;Acked-by&lt;/code&gt; , скажем, к последним 10 коммитам (ни одна из которых не является слиянием), используйте эту команду:</target>
        </trans-unit>
        <trans-unit id="a06310bf48a43d3f06d75e4fe748345a055d13a9" translate="yes" xml:space="preserve">
          <source>If you need to amend commits from deeper in your history, you can use &lt;a href=&quot;#interactive-rebase&quot;&gt;interactive rebase&amp;rsquo;s &lt;code&gt;edit&lt;/code&gt; instruction&lt;/a&gt;.</source>
          <target state="translated">Если вам нужно изменить коммиты более глубоко в вашей истории, вы можете использовать &lt;a href=&quot;#interactive-rebase&quot;&gt;интерактивную инструкцию &lt;code&gt;edit&lt;/code&gt; rebase&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f26f13a2edb916f980bf0b233ef42611b499ae1c" translate="yes" xml:space="preserve">
          <source>If you need to make any further adjustments, do so now, and then add any newly modified content to the index. Finally, commit your changes with:</source>
          <target state="translated">Если вам необходимо внести дополнительные изменения,сделайте это сейчас,а затем добавьте любое новое измененное содержимое в индекс.Наконец,зафиксируйте свои изменения:</target>
        </trans-unit>
        <trans-unit id="b7346c069533043ab7106064793cec780b496e9d" translate="yes" xml:space="preserve">
          <source>If you need to pass multiple options, separate them with a comma.</source>
          <target state="translated">Если нужно передать несколько опций,разделите их запятой.</target>
        </trans-unit>
        <trans-unit id="809b912a9ed5d5a0eab31e3007d95029a30a63c6" translate="yes" xml:space="preserve">
          <source>If you need to reorder or edit a number of commits in a branch, it may be easier to use &lt;code&gt;git rebase -i&lt;/code&gt;, which allows you to reorder and squash commits, as well as marking them for individual editing during the rebase. See &lt;a href=&quot;#interactive-rebase&quot;&gt;Using interactive rebases&lt;/a&gt; for details, and &lt;a href=&quot;#reordering-patch-series&quot;&gt;Reordering or selecting from a patch series&lt;/a&gt; for alternatives.</source>
          <target state="translated">Если вам нужно изменить порядок или отредактировать несколько коммитов в ветке, может быть проще использовать &lt;code&gt;git rebase -i&lt;/code&gt; , который позволяет вам изменять порядок и сквошировать коммиты, а также отмечать их для индивидуального редактирования во время перебазирования. Подробности см. В &lt;a href=&quot;#interactive-rebase&quot;&gt;разделах &amp;laquo;Использование интерактивных перемещений&amp;raquo;&lt;/a&gt; и &amp;laquo; &lt;a href=&quot;#reordering-patch-series&quot;&gt;Изменение порядка или выбор из серии исправлений&amp;raquo;&lt;/a&gt; для получения альтернатив.</target>
        </trans-unit>
        <trans-unit id="653cbb8173c66cbe6d9c641e8756d2055e0c1628" translate="yes" xml:space="preserve">
          <source>If you never pushed anything out, just re-tag it. Use &quot;-f&quot; to replace the old one. And you&amp;rsquo;re done.</source>
          <target state="translated">Если вы никогда ничего не выталкивали, просто пометьте его заново. Используйте &quot;-f&quot;, чтобы заменить старый. И вы сделали.</target>
        </trans-unit>
        <trans-unit id="e0169e9e6701b28da91f9800a1f0eacd543a0e6b" translate="yes" xml:space="preserve">
          <source>If you now continue development as usual, and eventually merge &lt;code&gt;topic&lt;/code&gt; to &lt;code&gt;subsystem&lt;/code&gt;, the commits from &lt;code&gt;subsystem&lt;/code&gt; will remain duplicated forever:</source>
          <target state="translated">Если вы теперь продолжите разработку как обычно и в конечном итоге объедините &lt;code&gt;topic&lt;/code&gt; с &lt;code&gt;subsystem&lt;/code&gt; , коммиты из &lt;code&gt;subsystem&lt;/code&gt; останутся дублированными навсегда:</target>
        </trans-unit>
        <trans-unit id="d9ba20830393f58c8170e264c4d66d9dd0605070" translate="yes" xml:space="preserve">
          <source>If you now run</source>
          <target state="translated">Если ты сейчас побежишь</target>
        </trans-unit>
        <trans-unit id="ee95c7e5ff1bbdc349787f30139d15eef70dff52" translate="yes" xml:space="preserve">
          <source>If you only want to remove the local checkout of a submodule from your work tree without committing the removal, use &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;deinit&lt;/code&gt; instead. Also see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details on submodule removal.</source>
          <target state="translated">Если вы хотите удалить только локальную проверку подмодуля из своего рабочего дерева, не выполняя удаление, используйте вместо этого &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;deinit&lt;/code&gt; . Также см. &lt;a href=&quot;gitsubmodules&quot;&gt;Gitsubmodules [7]&lt;/a&gt; для получения подробной информации об удалении подмодулей.</target>
        </trans-unit>
        <trans-unit id="de4ecb2fda4e4a17fa4230cd7b06e657b6ab1e40" translate="yes" xml:space="preserve">
          <source>If you plan to publish this repository to be accessed over http, you should do &lt;code&gt;mv my-git.git/hooks/post-update.sample
my-git.git/hooks/post-update&lt;/code&gt; at this point. This makes sure that every time you push into this repository, &lt;code&gt;git update-server-info&lt;/code&gt; is run.</source>
          <target state="translated">Если вы планируете опубликовать этот репозиторий для доступа через http, на этом этапе вам следует выполнить &lt;code&gt;mv my-git.git/hooks/post-update.sample my-git.git/hooks/post-update&lt;/code&gt; . Это гарантирует, что каждый раз, когда вы вставляете в этот репозиторий, запускается &lt;code&gt;git update-server-info&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dce58b5a972f1c023066ee29ac3c991fde1e2420" translate="yes" xml:space="preserve">
          <source>If you present all of your changes as a single patch (or commit), they may find that it is too much to digest all at once.</source>
          <target state="translated">Если вы представите все свои изменения как один патч (или коммит),они могут обнаружить,что это слишком много,чтобы переварить все сразу.</target>
        </trans-unit>
        <trans-unit id="6e4131986cf58f7abe3d9d87945a8e4a59143945" translate="yes" xml:space="preserve">
          <source>If you present them with the entire history of your work, complete with mistakes, corrections, and dead ends, they may be overwhelmed.</source>
          <target state="translated">Если вы преподнесете им всю историю своей работы,полную ошибок,исправлений и тупиков,они могут быть перегружены.</target>
        </trans-unit>
        <trans-unit id="21ee16e384bb8d43949dac71aebc6ab455b71a15" translate="yes" xml:space="preserve">
          <source>If you provide a &lt;code&gt;directory&lt;/code&gt;, the command is run inside it. If this directory does not exist, it will be created.</source>
          <target state="translated">Если вы указываете &lt;code&gt;directory&lt;/code&gt; , команда запускается внутри него. Если этот каталог не существует, он будет создан.</target>
        </trans-unit>
        <trans-unit id="e318df70fba90a3c817f7eb76621f705fc69949d" translate="yes" xml:space="preserve">
          <source>If you pushed your change to a branch whose name is different from the one you have locally, e.g.</source>
          <target state="translated">Если вы перешли на ветку,чьё имя отличается от имени,которое у вас есть локально,например</target>
        </trans-unit>
        <trans-unit id="f36c21fb05ddb2d8eeea70a503cb3c797b4a7baa" translate="yes" xml:space="preserve">
          <source>If you really don&amp;rsquo;t want to clone it, for whatever reasons, check the following points instead (in this order). This is a very destructive approach, so &lt;strong&gt;make a backup&lt;/strong&gt; or go back to cloning it. You have been warned.</source>
          <target state="translated">Если вы действительно не хотите клонировать его по каким-либо причинам, вместо этого проверьте следующие пункты (в этом порядке). Это очень разрушительный подход, поэтому &lt;strong&gt;сделайте резервную копию&lt;/strong&gt; или вернитесь к ее клонированию. Вы были предупреждены.</target>
        </trans-unit>
        <trans-unit id="3a0d5ef629f0a421a47e2200b4c6f6985f396b8e" translate="yes" xml:space="preserve">
          <source>If you really want to remove a submodule from the repository and commit that use &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; instead. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for removal options.</source>
          <target state="translated">Если вы действительно хотите удалить подмодуль из репозитория и зафиксировать его, используйте вместо этого &lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt; . См. &lt;a href=&quot;gitsubmodules&quot;&gt;Параметры&lt;/a&gt; удаления в gitsubmodules [7] .</target>
        </trans-unit>
        <trans-unit id="a5e65b5631472cf01bf2ff6d1fb37eb4b5d6b41d" translate="yes" xml:space="preserve">
          <source>If you really want to use &lt;code&gt;konqueror&lt;/code&gt;, then you can use something like the following:</source>
          <target state="translated">Если вы действительно хотите использовать &lt;code&gt;konqueror&lt;/code&gt; , вы можете использовать что-то вроде следующего:</target>
        </trans-unit>
        <trans-unit id="e3a8dad6f18366292640cec2d899866b39003a2b" translate="yes" xml:space="preserve">
          <source>If you receive such a patch series (as maintainer, or perhaps as a reader of the mailing list it was sent to), save the mails to files, create a new topic branch and use &lt;code&gt;git am&lt;/code&gt; to import the commits:</source>
          <target state="translated">Если вы получили такую ​​серию патчей (как сопровождающий или, возможно, как читатель списка рассылки, куда он был отправлен), сохраните письма в файлы, создайте новую ветку темы и используйте &lt;code&gt;git am&lt;/code&gt; для импорта коммитов:</target>
        </trans-unit>
        <trans-unit id="8122cfb5e210d22279775f15b8524f8a454a6069" translate="yes" xml:space="preserve">
          <source>If you receive the SHA-1 name of a blob from one source, and its contents from another (possibly untrusted) source, you can still trust that those contents are correct as long as the SHA-1 name agrees. This is because the SHA-1 is designed so that it is infeasible to find different contents that produce the same hash.</source>
          <target state="translated">Если вы получаете SHA-1 имя блоба из одного источника,а его содержимое-из другого (возможно,недоверенного)источника,вы все равно можете доверять,что это содержимое верно,при условии,что SHA-1 имя согласовано.Это связано с тем,что SHA-1 спроектирован таким образом,что невозможно найти различное содержимое,которое приводит к появлению одного и того же хэша.</target>
        </trans-unit>
        <trans-unit id="72b668cfa18e4e3a824ca9d20a1fa4e3cde95d1f" translate="yes" xml:space="preserve">
          <source>If you recognize such corruption early you can easily fix it by setting the conversion type explicitly in .gitattributes. Right after committing you still have the original file in your work tree and this file is not yet corrupted. You can explicitly tell Git that this file is binary and Git will handle the file appropriately.</source>
          <target state="translated">Если вы обнаружили такое повреждение на ранней стадии,вы можете легко исправить его,явно задав тип преобразования в .gitattributes.Сразу после фиксации у вас в рабочем дереве остался исходный файл,и этот файл ещё не повреждён.Вы можете явно указать Git'у,что этот файл является двоичным и Git'у будет обрабатывать его соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="6d44148625d48b9905fb64fc2d01c214d013573d" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git branch&lt;/code&gt; at this point, you&amp;rsquo;ll see that Git has temporarily moved you in &quot;(no branch)&quot;. HEAD is now detached from any branch and points directly to a commit (with commit id 65934) that is reachable from &quot;master&quot; but not from v2.6.18. Compile and test it, and see whether it crashes. Assume it does crash. Then:</source>
          <target state="translated">Если вы запустите &lt;code&gt;git branch&lt;/code&gt; на этом этапе, вы увидите, что Git временно переместил вас в &amp;laquo;(без ветки)&amp;raquo;. HEAD теперь отсоединен от любой ветки и указывает непосредственно на фиксацию (с идентификатором фиксации 65934), которая доступна из &amp;laquo;master&amp;raquo;, но не из v2.6.18. Скомпилируйте и протестируйте его и посмотрите, не вылетит ли он. Предположим, это действительно сбой. Затем:</target>
        </trans-unit>
        <trans-unit id="e4f37857c4f0244dcc0891e65a70e27a5bbdffad" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; later, the remote-tracking branches for the named &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; will be updated.</source>
          <target state="translated">Если вы запустите &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; позже, ветки удаленного отслеживания для названного &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; будут обновлены.</target>
        </trans-unit>
        <trans-unit id="086aebbf0140fb264a45c34927db290b089af7f6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git repack&lt;/code&gt; again at this point, it will say &quot;Nothing new to pack.&quot;. Once you continue your development and accumulate the changes, running &lt;code&gt;git repack&lt;/code&gt; again will create a new pack, that contains objects created since you packed your repository the last time. We recommend that you pack your project soon after the initial import (unless you are starting your project from scratch), and then run &lt;code&gt;git repack&lt;/code&gt; every once in a while, depending on how active your project is.</source>
          <target state="translated">Если вы снова запустите &lt;code&gt;git repack&lt;/code&gt; на этом этапе, он выдаст сообщение &amp;laquo;Ничего нового для упаковки&amp;raquo;. Как только вы продолжите разработку и накапливаете изменения, повторный запуск &lt;code&gt;git repack&lt;/code&gt; создаст новый пакет, содержащий объекты, созданные с момента последней упаковки вашего репозитория. Мы рекомендуем вам упаковать свой проект вскоре после первоначального импорта (если вы не начинаете свой проект с нуля), а затем запускать &lt;code&gt;git repack&lt;/code&gt; время от времени, в зависимости от того, насколько активен ваш проект.</target>
        </trans-unit>
        <trans-unit id="f6784580fd898de2457fa8e4a33fffee5347973c" translate="yes" xml:space="preserve">
          <source>If you simply want to have CRLF line endings in your working directory regardless of the repository you are working with, you can set the config variable &quot;core.autocrlf&quot; without using any attributes.</source>
          <target state="translated">Если вы просто хотите,чтобы CRLF-строки заканчивались в вашей рабочей директории независимо от того,с каким репозиторием вы работаете,вы можете установить конфигурационную переменную &quot;core.autocrlf&quot; без использования каких-либо атрибутов.</target>
        </trans-unit>
        <trans-unit id="7c25024f01247f9dfa8226991c206d71987ca030" translate="yes" xml:space="preserve">
          <source>If you suspect that any of these issues may apply to the repository you want to import, consider using cvs2git:</source>
          <target state="translated">Если вы подозреваете,что какая-либо из этих проблем может относиться к репозиторию,который вы хотите импортировать,подумайте об использовании cvs2git:</target>
        </trans-unit>
        <trans-unit id="d4145f8caae501b7db828bb5aa5f527a21b88535" translate="yes" xml:space="preserve">
          <source>If you think you have found a git bug, you can start by exporting an anonymized stream of the whole repository:</source>
          <target state="translated">Если вы думаете,что нашли ошибку в git'е,вы можете начать с экспорта анонимизированного потока всего репозитория:</target>
        </trans-unit>
        <trans-unit id="846aba2aee9d2174839c8e896f13afd75da487fc" translate="yes" xml:space="preserve">
          <source>If you tried a merge which resulted in complex conflicts and want to start over, you can recover with &lt;code&gt;git merge --abort&lt;/code&gt;.</source>
          <target state="translated">Если вы попытались выполнить слияние, которое привело к сложным конфликтам, и хотите начать все сначала, вы можете &lt;code&gt;git merge --abort&lt;/code&gt; восстановление с помощью git merge --abort .</target>
        </trans-unit>
        <trans-unit id="0e65bb746f0318eba11b3455708b3d4c243b8cb3" translate="yes" xml:space="preserve">
          <source>If you tried a pull which resulted in complex conflicts and would want to start over, you can recover with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">Если вы попытались выполнить извлечение, которое привело к сложным конфликтам, и вы хотите начать все сначала, вы можете &lt;code&gt;git reset&lt;/code&gt; восстановление с помощью git reset .</target>
        </trans-unit>
        <trans-unit id="a4f4230d5ba7e1273c96751869d78c8666680eb6" translate="yes" xml:space="preserve">
          <source>If you try and cheat and try to make git-filter-branch only work on files modified in a commit, then two things happen</source>
          <target state="translated">Если вы попытаетесь обмануть и заставить git-фильтр-отделение работать только с файлами,изменёнными в коммите,то произойдут две вещи</target>
        </trans-unit>
        <trans-unit id="8c2ff328d40e63aa92549620e7b30dc7bd79b356" translate="yes" xml:space="preserve">
          <source>If you use any of the options marked &quot;Turns off &lt;code&gt;apply&lt;/code&gt;&quot; above, &lt;code&gt;git apply&lt;/code&gt; reads and outputs the requested information without actually applying the patch. Give this flag after those flags to also apply the patch.</source>
          <target state="translated">Если вы используете любую из опций, помеченных выше &amp;laquo;Отключить &lt;code&gt;apply&lt;/code&gt; &amp;raquo;, &lt;code&gt;git apply&lt;/code&gt; читает и выводит запрошенную информацию без фактического применения патча. Установите этот флаг после этих флагов, чтобы также применить исправление.</target>
        </trans-unit>
        <trans-unit id="9ac6e5a034fc806d1c17415da5d8566070ff7060" translate="yes" xml:space="preserve">
          <source>If you use the rewrite rules from the example you &lt;strong&gt;might&lt;/strong&gt; also need something like the following in your gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; following example):</source>
          <target state="translated">Если вы используете правила перезаписи из примера, вам также &lt;strong&gt;может&lt;/strong&gt; понадобиться что-то вроде следующего в вашем файле конфигурации &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ( /etc/gitweb.conf в следующем примере):</target>
        </trans-unit>
        <trans-unit id="7b6c2f4a6c5d4d8aeea38b5e0c4e8e111c81122f" translate="yes" xml:space="preserve">
          <source>If you want a shared repository, you will need to make a bare clone of the imported directory, as described above. Then treat the imported directory as another development clone for purposes of merging incremental imports.</source>
          <target state="translated">Если вам нужен общий репозиторий,вам нужно сделать &quot;голый&quot; клон импортируемого каталога,как описано выше.Затем относитесь к импортируемой директории как к другому клону разработки для целей объединения инкрементальных импортов.</target>
        </trans-unit>
        <trans-unit id="f7444f839f8aa37b3a95b6650647c55221c170f1" translate="yes" xml:space="preserve">
          <source>If you want command input to still be interpreted as usual by &lt;code&gt;git rev-parse&lt;/code&gt; before the output is shell quoted, see the &lt;code&gt;--sq&lt;/code&gt; option.</source>
          <target state="translated">Если вы хотите, чтобы ввод команды по-прежнему интерпретировался как обычно с помощью &lt;code&gt;git rev-parse&lt;/code&gt; до того, как вывод будет заключен в кавычки оболочки, см. &lt;code&gt;--sq&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54d050e248b6c4afcd2cdb81603440db07ba11e1" translate="yes" xml:space="preserve">
          <source>If you want to break the dependency of a repository cloned with &lt;code&gt;--shared&lt;/code&gt; on its source repository, you can simply run &lt;code&gt;git repack -a&lt;/code&gt; to copy all objects from the source repository into a pack in the cloned repository.</source>
          <target state="translated">Если вы хотите разорвать зависимость репозитория, клонированного с помощью &lt;code&gt;--shared&lt;/code&gt; , от его исходного репозитория, вы можете просто запустить &lt;code&gt;git repack -a&lt;/code&gt; , чтобы скопировать все объекты из исходного репозитория в пакет в клонированном репозитории.</target>
        </trans-unit>
        <trans-unit id="175eedbbcb252ccb8b65afc8343c53ee6468a326" translate="yes" xml:space="preserve">
          <source>If you want to check out &lt;code&gt;all&lt;/code&gt; C source files out of the index, you can say</source>
          <target state="translated">Если вы хотите извлечь &lt;code&gt;all&lt;/code&gt; исходные файлы C из индекса, вы можете сказать</target>
        </trans-unit>
        <trans-unit id="412503812484d6bb436647749abac1512a88fe3d" translate="yes" xml:space="preserve">
          <source>If you want to configure a general editor for most programs which need one, you can edit your shell configuration (e.g., &lt;code&gt;~/.bashrc&lt;/code&gt; or &lt;code&gt;~/.zshenv&lt;/code&gt;) to contain a line setting the &lt;code&gt;EDITOR&lt;/code&gt; or &lt;code&gt;VISUAL&lt;/code&gt; environment variable to an appropriate value. For example, if you prefer the editor &lt;code&gt;nano&lt;/code&gt;, then you could write the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfd781535d8a753d031feb44f687140ff2bbcfb" translate="yes" xml:space="preserve">
          <source>If you want to configure an editor specifically for Git, you can either set the &lt;code&gt;core.editor&lt;/code&gt; configuration value or the &lt;code&gt;GIT_EDITOR&lt;/code&gt; environment variable. You can see &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details on the order in which these options are consulted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8498bad4ba6680850d835a14e8199fc54c7601f" translate="yes" xml:space="preserve">
          <source>If you want to delete an entry for a multivar (like core.gitproxy above), you have to provide a regex matching the value of exactly one line.</source>
          <target state="translated">Если вы хотите удалить запись для мультивара (например,core.gitproxy выше),вы должны предоставить регекс,совпадающий со значением ровно одной строки.</target>
        </trans-unit>
        <trans-unit id="b6ce9e2807ee6d14a7a74a4824bf5e00e758331b" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--fsmonitor&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">Если вы хотите включить (или отключить) эту функцию, проще использовать &lt;code&gt;core.fsmonitor&lt;/code&gt; конфигурации core.fsmonitor (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ), чем использовать параметр &lt;code&gt;--fsmonitor&lt;/code&gt; для &lt;code&gt;git update-index&lt;/code&gt; в каждом репозитории, особенно если вы хотите сделать это во всех репозиториях, которые вы используете, потому что вы можете установить переменную конфигурации в вашем &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; только один раз, и она повлияет на все репозитории, которых вы касаетесь.</target>
        </trans-unit>
        <trans-unit id="fade353b5f9f7d0b204907810eaa983a2e094489" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--untracked-cache&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;) in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">Если вы хотите включить (или отключить) эту функцию, проще использовать &lt;code&gt;core.untrackedCache&lt;/code&gt; конфигурации core.untrackedCache (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ), чем использовать параметр &lt;code&gt;--untracked-cache&lt;/code&gt; для &lt;code&gt;git update-index&lt;/code&gt; в каждом репозитории, особенно если вы хотите сделать это во всех репозиториях, которые вы используете, потому что вы можете установить для переменной конфигурации значение &lt;code&gt;true&lt;/code&gt; (или &lt;code&gt;false&lt;/code&gt; ) в вашем &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; только один раз, и это повлияет на все репозитории, которых вы касаетесь.</target>
        </trans-unit>
        <trans-unit id="58323cdd8a68e6e1cc6d62c47524db6593349b87" translate="yes" xml:space="preserve">
          <source>If you want to ensure that text files that any contributor introduces to the repository have their line endings normalized, you can set the &lt;code&gt;text&lt;/code&gt; attribute to &quot;auto&quot; for &lt;code&gt;all&lt;/code&gt; files.</source>
          <target state="translated">Если вы хотите гарантировать, что текстовые файлы, которые любой участник вводит в репозиторий, имеют нормализованные окончания строк, вы можете установить для &lt;code&gt;text&lt;/code&gt; атрибута значение &amp;laquo;auto&amp;raquo; для &lt;code&gt;all&lt;/code&gt; файлов.</target>
        </trans-unit>
        <trans-unit id="46aa6af5bcc60a63656632720781ded6cb9a0464" translate="yes" xml:space="preserve">
          <source>If you want to fold two or more commits into one, replace the command &quot;pick&quot; for the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;. If the commits had different authors, the folded commit will be attributed to the author of the first commit. The suggested commit message for the folded commit is the concatenation of the commit messages of the first commit and of those with the &quot;squash&quot; command, but omits the commit messages of commits with the &quot;fixup&quot; command.</source>
          <target state="translated">Если вы хотите сложить два или более коммита в один,замените команду &quot;pick&quot; для второго и последующих коммитов на &quot;squash&quot; или &quot;fixup&quot;.Если у коммитов были разные авторы,то сложенный коммит будет приписан автору первого коммита.Предлагаемое сообщение о фиксации для сложенной фиксации-это объединение сообщений о фиксации первой фиксации и сообщений о фиксации команды &quot;squash&quot;,но опускает сообщения о фиксации фиксации командой &quot;fixup&quot;.</target>
        </trans-unit>
        <trans-unit id="a1fc176bf758306e3705a3dd88ad77db4fb55698" translate="yes" xml:space="preserve">
          <source>If you want to have one URL for both gitweb and your &lt;code&gt;http://&lt;/code&gt; repositories, you can configure Apache like this:</source>
          <target state="translated">Если вы хотите иметь один URL-адрес как для gitweb, так и для репозиториев &lt;code&gt;http://&lt;/code&gt; , вы можете настроить Apache следующим образом:</target>
        </trans-unit>
        <trans-unit id="23a694ff61b56e5a1054639701ce379b6eeb6564" translate="yes" xml:space="preserve">
          <source>If you want to know all the values for a multivar, do:</source>
          <target state="translated">Если вы хотите знать все значения для мультивара,сделайте это:</target>
        </trans-unit>
        <trans-unit id="be838b052e83d8fa0d4980781547923358bc58d3" translate="yes" xml:space="preserve">
          <source>If you want to make a change within a submodule and you have a detached head, then you should create or checkout a branch, make your changes, publish the change within the submodule, and then update the superproject to reference the new commit:</source>
          <target state="translated">Если вы хотите внести изменения внутри подмодуля и у вас есть отдельная голова,то вы должны создать или извлечь ветку,внести изменения,опубликовать изменения внутри подмодуля,а затем обновить суперпроект,чтобы сослаться на новый коммит:</target>
        </trans-unit>
        <trans-unit id="f02c3e1c88ba7fbd299965b88348f8af1bb2eec2" translate="yes" xml:space="preserve">
          <source>If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the &lt;code&gt;^{type}&lt;/code&gt; peeling operator to the parameter. For example, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; will make sure &lt;code&gt;$VAR&lt;/code&gt; names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that &lt;code&gt;$VAR&lt;/code&gt; names an existing object of any type, &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; can be used.</source>
          <target state="translated">Если вы хотите убедиться, что выходные данные действительно именуют объект в вашей базе данных объектов и / или могут использоваться в качестве объекта определенного типа, который вам нужен, вы можете добавить к параметру оператор отслаивания &lt;code&gt;^{type}&lt;/code&gt; . Например, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; будет гарантировать, что &lt;code&gt;$VAR&lt;/code&gt; назовет существующий объект, который является фиктивным (то есть фиксацией или аннотированным тегом, указывающим на фиксацию). Чтобы убедиться, что &lt;code&gt;$VAR&lt;/code&gt; дает имя существующему объекту любого типа, можно использовать &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="136531f3c928e37ad60b2649b3285deac4e99b46" translate="yes" xml:space="preserve">
          <source>If you want to refer to a git refspec that has characters that are not allowed by CVS, you have two options. First, it may just work to supply the git refspec directly to the appropriate CVS -r argument; some CVS clients don&amp;rsquo;t seem to do much sanity checking of the argument. Second, if that fails, you can use a special character escape mechanism that only uses characters that are valid in CVS tags. A sequence of 4 or 5 characters of the form (underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;), one or two characters, and dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;)) can encode various characters based on the one or two letters: &lt;code&gt;&quot;s&quot;&lt;/code&gt; for slash (&lt;code&gt;&quot;/&quot;&lt;/code&gt;), &lt;code&gt;&quot;p&quot;&lt;/code&gt; for period (&lt;code&gt;&quot;.&quot;&lt;/code&gt;), &lt;code&gt;&quot;u&quot;&lt;/code&gt; for underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), or two hexadecimal digits for any byte value at all (typically an ASCII number, or perhaps a part of a UTF-8 encoded character).</source>
          <target state="translated">Если вы хотите сослаться на git refspec, в котором есть символы, запрещенные CVS, у вас есть два варианта. Во-первых, можно просто передать git refspec напрямую в соответствующий аргумент CVS -r; некоторые клиенты CVS, кажется, не проводят тщательной проверки аргумента. Во-вторых, если это не удается, вы можете использовать специальный механизм escape-символов, который использует только те символы, которые допустимы в тегах CVS. Последовательность из 4 или 5 символов формы (подчеркивание ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ), тире ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), один или два символа и тире ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; )) может кодировать различные символы на основе одной или двух букв: &lt;code&gt;&quot;s&quot;&lt;/code&gt; для косой черты ( &lt;code&gt;&quot;/&quot;&lt;/code&gt; ), &lt;code&gt;&quot;p&quot;&lt;/code&gt; для точки ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; ), &lt;code&gt;&quot;u&quot;&lt;/code&gt; для подчеркивания ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ) или две шестнадцатеричные цифры для любого байтового значения (обычно это число ASCII или, возможно, часть символа в кодировке UTF-8).</target>
        </trans-unit>
        <trans-unit id="e8beaf63d7e0d62995b4c7a9252b3f2ea0574fab" translate="yes" xml:space="preserve">
          <source>If you want to replace many blobs, trees or commits that are part of a string of commits, you may just want to create a replacement string of commits and then only replace the commit at the tip of the target string of commits with the commit at the tip of the replacement string of commits.</source>
          <target state="translated">Если вы хотите заменить много блоков,деревьев или коммитов,которые являются частью строки коммитов,вы можете просто создать замену строки коммитов,а затем заменить только коммит по кончику целевой строки коммитов на коммит по кончику строки замены коммитов.</target>
        </trans-unit>
        <trans-unit id="44f075cf045ec7b6bbf9c6b54de29b3e2085d2d6" translate="yes" xml:space="preserve">
          <source>If you want to restore &lt;code&gt;all&lt;/code&gt; C source files to match the version in the index, you can say</source>
          <target state="translated">Если вы хотите восстановить &lt;code&gt;all&lt;/code&gt; исходные файлы C в соответствии с версией в индексе, вы можете сказать</target>
        </trans-unit>
        <trans-unit id="7bbbea69a50b6a93a6b75d0ba68d2bc45319d47b" translate="yes" xml:space="preserve">
          <source>If you want to rewrite URLs for push only, you can create a configuration section of the form:</source>
          <target state="translated">Если вы хотите переписать URL только для push,вы можете создать конфигурационный раздел формы:</target>
        </trans-unit>
        <trans-unit id="295a38729bbd2cc488fb271a44e4d101d6ee7a15" translate="yes" xml:space="preserve">
          <source>If you want to show differences between binary or specially-formatted blobs in your repository, you can choose to use either an external diff command, or to use textconv to convert them to a diff-able text format. Which method you choose depends on your exact situation.</source>
          <target state="translated">Если вы хотите показать различия между бинарными или специально отформатированными блоками в вашем репозитории,вы можете использовать либо внешнюю команду diff,либо текстовуюconv для их конвертирования в текстовый формат с поддержкой различий.Какой метод вы выберете,зависит от вашей конкретной ситуации.</target>
        </trans-unit>
        <trans-unit id="e3f3cfd8a6d2a1c0d741f6415c0be4ad8848457f" translate="yes" xml:space="preserve">
          <source>If you want to show other people your bisection process, you can get a log using for example:</source>
          <target state="translated">Если вы хотите показать другим людям свой процесс приготовления бисквитов,вы можете получить журнал,например,с помощью:</target>
        </trans-unit>
        <trans-unit id="07b554efbcde38cd3d8cb2b2cd3fe1b74a5f9d9d" translate="yes" xml:space="preserve">
          <source>If you want to start a disconnected history that records a set of paths that is totally different from the one of &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;, then you should clear the index and the working tree right after creating the orphan branch by running &lt;code&gt;git rm -rf .&lt;/code&gt; from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc.</source>
          <target state="translated">Если вы хотите запустить отключенную историю, в которой записывается набор путей, который полностью отличается от пути из &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; , вы должны очистить индекс и рабочее дерево сразу после создания сиротской ветки, запустив &lt;code&gt;git rm -rf .&lt;/code&gt; с верхнего уровня рабочего дерева. После этого вы будете готовы подготовить свои новые файлы, повторно заполнить рабочее дерево, скопировав их из другого места, распаковав архив и т. Д.</target>
        </trans-unit>
        <trans-unit id="5dc24ba332edd3d8bebaa76b808aacd296106da2" translate="yes" xml:space="preserve">
          <source>If you want to start a new branch from a remote branch of the same name:</source>
          <target state="translated">Если вы хотите запустить новое ответвление с удалённого филиала с тем же именем:</target>
        </trans-unit>
        <trans-unit id="b533f775f69c9c29e40e15bb405c24bc01b04dac" translate="yes" xml:space="preserve">
          <source>If you want to use gitweb with several project roots you can edit your Apache virtual host and gitweb configuration files in the following way.</source>
          <target state="translated">Если вы хотите использовать gitweb с несколькими корнями проектов,вы можете редактировать ваш виртуальный хост Apache и конфигурационные файлы gitweb следующим образом.</target>
        </trans-unit>
        <trans-unit id="cced0d77bb2b4a5861e7555078781fd81234d732" translate="yes" xml:space="preserve">
          <source>If you want to, you can use &lt;code&gt;git cat-file&lt;/code&gt; to look at those objects, but you&amp;rsquo;ll have to use the object name, not the filename of the object:</source>
          <target state="translated">Если вы хотите, вы можете использовать &lt;code&gt;git cat-file&lt;/code&gt; для просмотра этих объектов, но вам придется использовать имя объекта, а не имя файла объекта:</target>
        </trans-unit>
        <trans-unit id="9eff57ed3284da22d90930841774b80f0270e4be" translate="yes" xml:space="preserve">
          <source>If you wish the exclude patterns to affect only certain repositories (instead of every repository for a given project), you may instead put them in a file in your repository named &lt;code&gt;.git/info/exclude&lt;/code&gt;, or in any file specified by the &lt;code&gt;core.excludesFile&lt;/code&gt; configuration variable. Some Git commands can also take exclude patterns directly on the command line. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for the details.</source>
          <target state="translated">Если вы хотите, чтобы шаблоны исключения влияли только на определенные репозитории (вместо каждого репозитория для данного проекта), вы можете вместо этого поместить их в файл в вашем репозитории с именем &lt;code&gt;.git/info/exclude&lt;/code&gt; или в любой файл, указанный &lt;code&gt;core.excludesFile&lt;/code&gt; переменная конфигурации. Некоторые команды Git также могут принимать шаблоны исключения непосредственно в командной строке. См. Подробности в &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3a956a01313129dd0835296263e6883d7abec99" translate="yes" xml:space="preserve">
          <source>If you wish to affect only a single repository (i.e., to assign attributes to files that are particular to one user&amp;rsquo;s workflow for that repository), then attributes should be placed in the &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file. Attributes which should be version-controlled and distributed to other repositories (i.e., attributes of interest to all users) should go into &lt;code&gt;.gitattributes&lt;/code&gt; files. Attributes that should affect all repositories for a single user should be placed in a file specified by the &lt;code&gt;core.attributesFile&lt;/code&gt; configuration option (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Its default value is $XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/attributes is used instead. Attributes for all users on a system should be placed in the &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; file.</source>
          <target state="translated">Если вы хотите воздействовать только на один репозиторий (т. &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; атрибуты файлам, которые относятся к рабочему процессу одного пользователя для этого репозитория), тогда атрибуты должны быть помещены в файл $ GIT_DIR / info / attributes . Атрибуты, которые должны контролироваться по версиям и распространяться среди других репозиториев (т. &lt;code&gt;.gitattributes&lt;/code&gt; Атрибуты, представляющие интерес для всех пользователей), должны входить в файлы .gitattributes . Атрибуты, которые должны влиять на все репозитории для одного пользователя, должны быть помещены в файл, указанный в &lt;code&gt;core.attributesFile&lt;/code&gt; конфигурации core.attributesFile (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt;). Его значение по умолчанию - $ XDG_CONFIG_HOME / git / attributes. Если $ XDG_CONFIG_HOME не задан или пуст, вместо него используются атрибуты $ HOME / .config / git /. Атрибуты для всех пользователей системы должны быть помещены в файл &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bef77486a59978a04a1c46b2c068b3863595296" translate="yes" xml:space="preserve">
          <source>If you work with other people, you will need commands listed in the &lt;a href=&quot;#PARTICIPANT&quot;&gt;Individual Developer (Participant)&lt;/a&gt; section as well.</source>
          <target state="translated">Если вы работаете с другими людьми, вам также потребуются команды, перечисленные в разделе &amp;laquo; &lt;a href=&quot;#PARTICIPANT&quot;&gt;Индивидуальный разработчик (участник)&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="4cb8198fe4b8e422fe561ded3cf681f52266950f" translate="yes" xml:space="preserve">
          <source>If you would like the daemon to exit early, forgetting all cached credentials before their timeout, you can issue an &lt;code&gt;exit&lt;/code&gt; action:</source>
          <target state="translated">Если вы хотите, чтобы демон завершил работу раньше, забыв все кэшированные учетные данные до их тайм-аута, вы можете выполнить действие &lt;code&gt;exit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6fb92003fb885c97541d201047e1ea900190bac9" translate="yes" xml:space="preserve">
          <source>If you would like to use your own terms instead of &quot;bad&quot;/&quot;good&quot; or &quot;new&quot;/&quot;old&quot;, you can choose any names you like (except existing bisect subcommands like &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, &amp;hellip;​) by starting the bisection using</source>
          <target state="translated">Если вы хотите использовать свои собственные термины вместо &amp;laquo;плохой&amp;raquo; / &amp;laquo;хороший&amp;raquo; или &amp;laquo;новый&amp;raquo; / &amp;laquo;старый&amp;raquo;, вы можете выбрать любые имена, которые вам нравятся (кроме существующих разделенных пополам подкоманд, таких как &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; ,&amp;hellip;), запустив деление пополам с использованием</target>
        </trans-unit>
        <trans-unit id="ac9785fae40224d0d9d1a9569429bd18f0ceb511" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re releasing a new version of a software project, you may want to simultaneously make a changelog to include in the release announcement.</source>
          <target state="translated">Если вы выпускаете новую версию программного проекта, вы можете одновременно сделать журнал изменений и включить его в объявление о выпуске.</target>
        </trans-unit>
        <trans-unit id="6cd2cc907ee3e17f5caea471b5027cb72158e075" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve been committing small enough changes, you may now have a good shot at reconstructing the contents of the in-between state 4b9458b.</source>
          <target state="translated">Если вы совершали достаточно небольшие изменения, теперь у вас есть хороший шанс восстановить содержимое промежуточного состояния 4b9458b.</target>
        </trans-unit>
        <trans-unit id="5516e4c9c575f8921939c0e95aa6e39fac3c93e0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve configured a web server that isn&amp;rsquo;t listed here for gitweb, please send in the instructions so they can be included in a future release.</source>
          <target state="translated">Если вы настроили для gitweb веб-сервер, которого здесь нет, отправьте инструкции, чтобы их можно было включить в будущий выпуск.</target>
        </trans-unit>
        <trans-unit id="2ca9c9b64a14bae5a21173833d4a0e06ad289f34" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve messed up the working tree, but haven&amp;rsquo;t yet committed your mistake, you can return the entire working tree to the last committed state with</source>
          <target state="translated">Если вы испортили рабочее дерево, но еще не совершили свою ошибку, вы можете вернуть все рабочее дерево в последнее зафиксированное состояние с помощью</target>
        </trans-unit>
        <trans-unit id="346e091fa815a370c1b9ad910c5cda575a1ee6ab" translate="yes" xml:space="preserve">
          <source>If your Gmail account is set to another language than English, the name of the &quot;Drafts&quot; folder will be localized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdd278937e1b543d6e4ef46f26f74578bcd1798" translate="yes" xml:space="preserve">
          <source>If your branch was based on &amp;lt;upstream&amp;gt; but &amp;lt;upstream&amp;gt; was rewound and your branch contains commits which were dropped, this option can be used with &lt;code&gt;--keep-base&lt;/code&gt; in order to drop those commits from your branch.</source>
          <target state="translated">Если ваша ветка была основана на &amp;lt;upstream&amp;gt;, но &amp;lt;upstream&amp;gt; была перемотана, и ваша ветка содержит коммиты, которые были отброшены, эту опцию можно использовать с &lt;code&gt;--keep-base&lt;/code&gt; , чтобы удалить эти коммиты из вашей ветки.</target>
        </trans-unit>
        <trans-unit id="862f720d820aceb82a46583ae7c2b519ed5f9115" translate="yes" xml:space="preserve">
          <source>If your editor or some other system is running &lt;code&gt;git fetch&lt;/code&gt; in the background for you a way to mitigate this is to simply set up another remote:</source>
          <target state="translated">Если ваш редактор или другая система запускает &lt;code&gt;git fetch&lt;/code&gt; в фоновом режиме, для вас способ смягчить это - просто настроить другой пульт:</target>
        </trans-unit>
        <trans-unit id="39db9e1c175e21d39e4bc51b769419f8b3c379b1" translate="yes" xml:space="preserve">
          <source>If your goal is to modify a configuration file, it can often be helpful to have a file checked into the repository which is a template or set of defaults which can then be copied alongside and modified as appropriate. This second, modified file is usually ignored to prevent accidentally committing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233e7aed3c7b3f81991c7f01f9bc6c69656e4a7c" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then submodules are populated based on interactions with the &lt;code&gt;git submodule&lt;/code&gt; command. Specifically, &lt;code&gt;git submodule init -- &amp;lt;path&amp;gt;&lt;/code&gt; will ensure the submodule at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is present, while &lt;code&gt;git submodule deinit [-f] -- &amp;lt;path&amp;gt;&lt;/code&gt; will remove the files for the submodule at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; (including any untracked files, uncommitted changes, and unpushed history). Similar to how sparse-checkout removes files from the working tree but still leaves entries in the index, deinitialized submodules are removed from the working directory but still have an entry in the index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc3997d817725ac54010e2c723e5760c4e0b90b" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then those submodules will appear based on which you initialized with the &lt;code&gt;git submodule&lt;/code&gt; command. If your sparse-checkout patterns exclude an initialized submodule, then that submodule will still appear in your working directory.</source>
          <target state="translated">Если ваш репозиторий содержит один или несколько подмодулей, то эти подмодули появятся на основе того, что вы инициализировали с помощью команды &lt;code&gt;git submodule&lt;/code&gt; . Если ваши шаблоны разреженной проверки исключают инициализированный подмодуль, то этот подмодуль все равно появится в вашем рабочем каталоге.</target>
        </trans-unit>
        <trans-unit id="17a3911595f90d594aeea889e0f0755079e1efba" translate="yes" xml:space="preserve">
          <source>If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead.</source>
          <target state="translated">Если в середине бисектного сеанса вы знаете,что предлагаемая ревизия не подходит для тестирования (например,она не собирается и вы знаете,что сбой не имеет никакого отношения к ошибке,которую вы преследуете),вы можете вручную выбрать ближайшую фиксацию и протестировать её вместо неё.</target>
        </trans-unit>
        <trans-unit id="4eaf7ef623b220dfff5cf0aad12284c2791aab6b" translate="yes" xml:space="preserve">
          <source>Ignore carriage-return at the end of line when doing a comparison.</source>
          <target state="translated">Не обращайте внимания на возвращение в конце очереди при сравнении.</target>
        </trans-unit>
        <trans-unit id="14129ef50a9ff92ecf5a9d9520de0a5438b9b27c" translate="yes" xml:space="preserve">
          <source>Ignore case differences between the patterns and the files.</source>
          <target state="translated">Игнорируйте различия между шаблонами и файлами.</target>
        </trans-unit>
        <trans-unit id="93adbe048de005f652abeded323ffca0e07802f9" translate="yes" xml:space="preserve">
          <source>Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.</source>
          <target state="translated">Игнорируйте изменения в количестве белых пробелов.При этом игнорируются пробельные символы в конце строки,а все остальные последовательности одного или нескольких пробельных символов считаются эквивалентными.</target>
        </trans-unit>
        <trans-unit id="dceba3e490b99e465dabc6c0a6eb46378a762d2c" translate="yes" xml:space="preserve">
          <source>Ignore changes in whitespace at EOL.</source>
          <target state="translated">Игнорируйте изменения белого пробела на EOL.</target>
        </trans-unit>
        <trans-unit id="0e8a5619a2125f597eccb060c4d8cfcacf8da768" translate="yes" xml:space="preserve">
          <source>Ignore changes made by the revision when assigning blame, as if the change never happened. Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines. This option may be specified multiple times to ignore more than one revision. If the &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a &lt;code&gt;?&lt;/code&gt; in the blame output. If the &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">Игнорируйте изменения, внесенные ревизией, при назначении вины, как будто изменения никогда не было. Строки, которые были изменены или добавлены игнорируемой фиксацией, будут возложены на предыдущую фиксацию, которая изменила эту строку или соседние строки. Этот параметр можно указывать несколько раз, чтобы игнорировать более одной ревизии. Если установлен &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; конфигурации blame.markIgnoredLines , то строки, которые были изменены игнорируемой фиксацией и отнесены к другой фиксации, будут отмечены знаком &lt;code&gt;?&lt;/code&gt; в виноватом выводе. Если установлена &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; конфигурации blame.markUnblamableLines , то те строки, затронутые проигнорированной фиксацией, которую мы не смогли отнести к другой ревизии, помечаются &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="847c383f096e8b2857c23f7df697a300205d1cde" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules in the diff generation. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using &quot;all&quot; hides all changes to submodules.</source>
          <target state="translated">Игнорировать изменения субмодулей при генерации различий. &amp;lt;when&amp;gt; может иметь значение &amp;laquo;нет&amp;raquo;, &amp;laquo;неотслеживаемый&amp;raquo;, &amp;laquo;грязный&amp;raquo; или &amp;laquo;все&amp;raquo;, что является значением по умолчанию. Использование &quot;none&quot; будет считать подмодуль измененным, если он содержит неотслеживаемые или измененные файлы или его HEAD отличается от фиксации, записанной в суперпроекте, и может использоваться для переопределения любых настроек параметра &lt;code&gt;ignore&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; или &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [ 5]&lt;/a&gt; . Когда используется &amp;laquo;неотслеживаемый&amp;raquo; субмодули, они не считаются грязными, если они содержат только неотслеживаемый контент (но они по-прежнему сканируются на наличие измененного контента). Использование &quot;dirty&quot; игнорирует все изменения в дереве работы подмодулей,показаны только изменения коммитов, хранящихся в суперпроекте (так было до версии 1.7.0). Использование &amp;laquo;all&amp;raquo; скрывает все изменения в подмодулях.</target>
        </trans-unit>
        <trans-unit id="0a92f8e585ade182f513a5692eb0bb44a7e837dd" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules when looking for changes. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using &quot;all&quot; hides all changes to submodules (and suppresses the output of submodule summaries when the config option &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set).</source>
          <target state="translated">При поиске изменений игнорируйте изменения в подмодулях. &amp;lt;when&amp;gt; может иметь значение &amp;laquo;нет&amp;raquo;, &amp;laquo;неотслеживаемый&amp;raquo;, &amp;laquo;грязный&amp;raquo; или &amp;laquo;все&amp;raquo;, что является значением по умолчанию. Использование &quot;none&quot; будет считать подмодуль измененным, если он содержит неотслеживаемые или измененные файлы или его HEAD отличается от фиксации, записанной в суперпроекте, и может использоваться для переопределения любых настроек параметра &lt;code&gt;ignore&lt;/code&gt; в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; или &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [ 5]&lt;/a&gt;, Когда используется &amp;laquo;неотслеживаемый&amp;raquo; субмодули, они не считаются грязными, если они содержат только неотслеживаемый контент (но они по-прежнему сканируются на наличие измененного контента). Использование &quot;dirty&quot; игнорирует все изменения в дереве работы подмодулей, отображаются только изменения коммитов, хранящихся в суперпроекте (такое поведение было до 1.7.0). Использование &amp;laquo;all&amp;raquo; скрывает все изменения в подмодулях (и подавляет вывод сводок по подмодулям, если установлен параметр конфигурации &lt;code&gt;status.submoduleSummary&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="edef0f1f35c1dd9261cf7c47fc61c6526d72c57b" translate="yes" xml:space="preserve">
          <source>Ignore changes whose all lines match &amp;lt;regex&amp;gt;. This option may be specified more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f616e5a6b317fb9674ab4a6ecd11655583864222" translate="yes" xml:space="preserve">
          <source>Ignore changes whose lines are all blank.</source>
          <target state="translated">Игнорируйте изменения,все линии которых пустые.</target>
        </trans-unit>
        <trans-unit id="6b93913a06aa23ba136e18a208983b558968a818" translate="yes" xml:space="preserve">
          <source>Ignore refs for branches or tags matching the Perl regular expression. A &quot;negative look-ahead assertion&quot; like &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; can be used to allow only certain refs.</source>
          <target state="translated">Игнорировать ссылки на ветки или теги, соответствующие регулярному выражению Perl. Утверждение &amp;laquo;отрицательного упреждающего просмотра&amp;raquo;, например &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; Можно использовать для разрешения только определенных ссылок.</target>
        </trans-unit>
        <trans-unit id="cca615474ea8523b5665d433104181e17b949af0" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in &lt;code&gt;file&lt;/code&gt;, which must be in the same format as an &lt;code&gt;fsck.skipList&lt;/code&gt;. This option may be repeated, and these files will be processed after any files specified with the &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; config option. An empty file name, &lt;code&gt;&quot;&quot;&lt;/code&gt;, will clear the list of revs from previously processed files.</source>
          <target state="translated">Игнорировать ревизии, перечисленные в &lt;code&gt;file&lt;/code&gt; , который должен быть в том же формате, что и &lt;code&gt;fsck.skipList&lt;/code&gt; . Этот параметр можно повторить, и эти файлы будут обрабатываться после любых файлов, указанных в &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; конфигурации blame.ignoreRevsFile . Пустое имя файла &lt;code&gt;&quot;&quot;&lt;/code&gt; очистит список версий из ранее обработанных файлов.</target>
        </trans-unit>
        <trans-unit id="0cee361918756e813fbfde1e81b931c608ea0bab" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in the file, one unabbreviated object name per line, in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. Whitespace and comments beginning with &lt;code&gt;#&lt;/code&gt; are ignored. This option may be repeated multiple times. Empty file names will reset the list of ignored revisions. This option will be handled before the command line option &lt;code&gt;--ignore-revs-file&lt;/code&gt;.</source>
          <target state="translated">Игнорировать ревизии, перечисленные в файле, по одному несокращенному имени объекта в строке в &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; . Пробелы и комментарии, начинающиеся с символа &lt;code&gt;#&lt;/code&gt; , игнорируются. Этот вариант может повторяться несколько раз. Пустые имена файлов приведут к сбросу списка игнорируемых ревизий. Этот параметр будет обрабатываться перед параметром командной строки &lt;code&gt;--ignore-revs-file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf2829d6b1d696605f65878628b97d7705cf8bc" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">Игнорируйте линии ножниц (см. &lt;a href=&quot;git-mailinfo&quot;&gt;Git-mailinfo [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2348d1bd6f42459d3ee1b173782de699bb2835d4" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines. Useful for overriding mailinfo.scissors settings.</source>
          <target state="translated">Игнорируй линии ножниц.Полезно для переопределения настроек mailinfo.scissors.</target>
        </trans-unit>
        <trans-unit id="df44e8d5c0f3cfab7d419d47fcf746abf35ec612" translate="yes" xml:space="preserve">
          <source>Ignore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c0493eeab50cd9f84c9bb7fb54695bfa5cd858" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.</source>
          <target state="translated">Игнорируйте пробелы при сравнении линий.Это игнорирует различия,даже если в одной строке есть пробелы,а в другой нет.</target>
        </trans-unit>
        <trans-unit id="f41139f9e81b5ab318787773cf3063813dbcefdd" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing the parent&amp;rsquo;s version and the child&amp;rsquo;s to find where the lines came from.</source>
          <target state="translated">Игнорируйте пробелы при сравнении родительской и дочерней версий, чтобы определить, откуда пришли строки.</target>
        </trans-unit>
        <trans-unit id="67259bef7d0f56e262c4cda325ae4b91dc800c88" translate="yes" xml:space="preserve">
          <source>Ignored files are not listed, unless &lt;code&gt;--ignored&lt;/code&gt; option is in effect, in which case &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;!!&lt;/code&gt;.</source>
          <target state="translated">Пропущенные файлы не указаны, если &lt;code&gt;--ignored&lt;/code&gt; опция не действует, и в этом случае &lt;code&gt;XY&lt;/code&gt; является &lt;code&gt;!!&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="5a64e868764637ce6fa403b78bdbf74f10990fd5" translate="yes" xml:space="preserve">
          <source>Ignored items have the following format:</source>
          <target state="translated">Игнорируемые элементы имеют следующий формат:</target>
        </trans-unit>
        <trans-unit id="fe5aad4a58f02d9cd03afd86649692db9ed515bd" translate="yes" xml:space="preserve">
          <source>Ignores missing files during a --refresh</source>
          <target state="translated">Игнорирует отсутствующие файлы во время --refresh</target>
        </trans-unit>
        <trans-unit id="87a5b84b90eaf9c6a4ea4cf7776f8cdbe987e92e" translate="yes" xml:space="preserve">
          <source>Ignoring files</source>
          <target state="translated">Игнорирование файлов</target>
        </trans-unit>
        <trans-unit id="d83f269a97cfa5cb2870ace661718351e9ef1d6f" translate="yes" xml:space="preserve">
          <source>Imagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:</source>
          <target state="translated">Представьте себе,что в верхней части публичного коммита P,вы применили известные патчи X,Y и Z от кого-то другого,а затем построили свои три патча серии A,B,C,история была бы как:</target>
        </trans-unit>
        <trans-unit id="220433d0f0fcbc1334d4126616d73a1ad095f039" translate="yes" xml:space="preserve">
          <source>Imagine that you built your work on your &lt;code&gt;master&lt;/code&gt; branch on top of the &lt;code&gt;v1.0&lt;/code&gt; release, and want it to be integrated to the project. First you push that change to your public repository for others to see:</source>
          <target state="translated">Представьте, что вы построили свою работу над &lt;code&gt;master&lt;/code&gt; веткой поверх версии &lt;code&gt;v1.0&lt;/code&gt; и хотите, чтобы она была интегрирована в проект. Сначала вы отправляете это изменение в свой публичный репозиторий, чтобы другие могли его увидеть:</target>
        </trans-unit>
        <trans-unit id="d92dfaf42e4c06410357fc423fdf173e48ba5a6c" translate="yes" xml:space="preserve">
          <source>Imagine that you have to rebase what you have already published. You will have to bypass the &quot;must fast-forward&quot; rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with her commit, and blindly pushing with &lt;code&gt;--force&lt;/code&gt; will lose her work.</source>
          <target state="translated">Представьте, что вам нужно переустановить то, что вы уже опубликовали. Вам придется обойти правило &amp;laquo;перемотать вперед&amp;raquo;, чтобы заменить историю, которую вы изначально опубликовали, историей с измененной базой. Если кто-то другой построил вашу исходную историю, пока вы выполняете перебазирование, верхушка ветки на удаленном компьютере может продвигаться вперед вместе с ее фиксацией, и слепое нажатие с &lt;code&gt;--force&lt;/code&gt; потеряет ее работу.</target>
        </trans-unit>
        <trans-unit id="8a9ff0ad91f2190aebd8f7874a38eff49a81d587" translate="yes" xml:space="preserve">
          <source>Imagine this history:</source>
          <target state="translated">Представь себе эту историю:</target>
        </trans-unit>
        <trans-unit id="db144a77867a22b1db2aa0f495d3082ced7cfb54" translate="yes" xml:space="preserve">
          <source>Imitate &lt;code&gt;git clone&lt;/code&gt; but track only selected branches</source>
          <target state="translated">Имитировать &lt;code&gt;git clone&lt;/code&gt; , но отслеживать только выбранные ветки</target>
        </trans-unit>
        <trans-unit id="4a694f013e1a15bee19331c0c7b9e3ce34840db9" translate="yes" xml:space="preserve">
          <source>Imitate a CVS server. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Имитируйте сервер CVS. См. &lt;a href=&quot;git-cvsserver&quot;&gt;Git-cvsserver [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">Детали внедрения</target>
        </trans-unit>
        <trans-unit id="f1c03dca591efe03ac168cd03c30c9d29e88acc3" translate="yes" xml:space="preserve">
          <source>Import Now, Repack Later</source>
          <target state="translated">Импортируйте сейчас,переупаковывайте позже</target>
        </trans-unit>
        <trans-unit id="b3e1462f677f3a661ca64753ac202708178b3a16" translate="yes" xml:space="preserve">
          <source>Import a GNU Arch repository into Git</source>
          <target state="translated">Импорт репозитория архива GNU в Git</target>
        </trans-unit>
        <trans-unit id="502aadd2b2c2382144812aea24a52e335147d4a4" translate="yes" xml:space="preserve">
          <source>Import all changes from both named depot paths into a single repository. Only files below these directories are included. There is not a subdirectory in Git for each &quot;proj1&quot; and &quot;proj2&quot;. You must use the &lt;code&gt;--destination&lt;/code&gt; option when specifying more than one depot path. The revision specifier must be specified identically on each depot path. If there are files in the depot paths with the same name, the path with the most recently updated version of the file is the one that appears in Git.</source>
          <target state="translated">Импортируйте все изменения из обоих названных путей депо в единый репозиторий. Включены только файлы ниже этих каталогов. В Git нет подкаталога для каждого &amp;laquo;proj1&amp;raquo; и &amp;laquo;proj2&amp;raquo;. Вы должны использовать опцию &lt;code&gt;--destination&lt;/code&gt; при указании более одного пути депо. Спецификатор ревизии должен быть указан идентично на каждом пути депо. Если в путях депо есть файлы с тем же именем, путь с самой последней обновленной версией файла - это тот, который отображается в Git.</target>
        </trans-unit>
        <trans-unit id="90051e560d673faccfb0bfe61644ca104b05b719" translate="yes" xml:space="preserve">
          <source>Import all commits, including recent ones. cvsimport by default skips commits that have a timestamp less than 10 minutes ago.</source>
          <target state="translated">Импорт всех коммитов,включая недавние.cvsimport по умолчанию пропускает коммиты,которые имеют временную метку менее 10 минут назад.</target>
        </trans-unit>
        <trans-unit id="3ffbc41d8e969bcf6a3014a353f6e7a2bfd3e3ba" translate="yes" xml:space="preserve">
          <source>Import at most &lt;code&gt;n&lt;/code&gt; changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use &lt;code&gt;@all&lt;/code&gt; as the revision specifier, but then to use &lt;code&gt;--max-changes 1000&lt;/code&gt; to import only the last 1000 revisions rather than the entire revision history.</source>
          <target state="translated">Импортируйте не более &lt;code&gt;n&lt;/code&gt; изменений, а не весь диапазон изменений, включенных в данный спецификатор ревизии. Типичным использованием будет использование &lt;code&gt;@all&lt;/code&gt; в качестве спецификатора ревизии, но затем использование &lt;code&gt;--max-changes 1000&lt;/code&gt; для импорта только последних 1000 ревизий, а не всей истории ревизий.</target>
        </trans-unit>
        <trans-unit id="a203d27ce8c09d6ab5f978bc976ed19c7da8bd29" translate="yes" xml:space="preserve">
          <source>Import changes into &amp;lt;ref&amp;gt; instead of refs/remotes/p4/master. If &amp;lt;ref&amp;gt; starts with refs/, it is used as is. Otherwise, if it does not start with p4/, that prefix is added.</source>
          <target state="translated">Импортируйте изменения в &amp;lt;ref&amp;gt; вместо refs / remotes / p4 / master. Если &amp;lt;ref&amp;gt; начинается с refs /, он используется как есть. В противном случае, если он не начинается с p4 /, этот префикс добавляется.</target>
        </trans-unit>
        <trans-unit id="3446130415616c26cfbd9b0cb3b27c636fdfb1f4" translate="yes" xml:space="preserve">
          <source>Import exactly the p4 change numbers listed in &lt;code&gt;file&lt;/code&gt;, one per line. Normally, &lt;code&gt;git p4&lt;/code&gt; inspects the current p4 repository state and detects the changes it should import.</source>
          <target state="translated">Импортируйте точно те номера изменений p4, которые указаны в &lt;code&gt;file&lt;/code&gt; , по одному в каждой строке. Обычно &lt;code&gt;git p4&lt;/code&gt; проверяет текущее состояние репозитория p4 и обнаруживает изменения, которые он должен импортировать.</target>
        </trans-unit>
        <trans-unit id="051514630860e82d8e6dfeb8000cb04203f0530f" translate="yes" xml:space="preserve">
          <source>Import from and submit to Perforce repositories</source>
          <target state="translated">Импорт из репозиториев Perforce и отправка в репозитории Perforce</target>
        </trans-unit>
        <trans-unit id="bc1da86269dd0fa043570d9e0331c263ee1c8e9b" translate="yes" xml:space="preserve">
          <source>Import labels from p4 into Git.</source>
          <target state="translated">Импортируйте этикетки из p4 в Git.</target>
        </trans-unit>
        <trans-unit id="01c4fe3eff92a8abc6c7acba932cff943343d8ce" translate="yes" xml:space="preserve">
          <source>Import one commit for each change in the history of that depot path.</source>
          <target state="translated">Импортируйте по одному коммиту за каждое изменение в истории этого депо.</target>
        </trans-unit>
        <trans-unit id="5fa6a825ca52ecc53990e4e3e6add862904fa4f4" translate="yes" xml:space="preserve">
          <source>Import one commit with all files in the &lt;code&gt;#head&lt;/code&gt; change under that tree.</source>
          <target state="translated">Импортируйте одну фиксацию со всеми файлами в изменении &lt;code&gt;#head&lt;/code&gt; под этим деревом.</target>
        </trans-unit>
        <trans-unit id="1a475e0c7f94606844ba9fa0d34742cd54c3d13c" translate="yes" xml:space="preserve">
          <source>Import only changes 1 through 6.</source>
          <target state="translated">Импорт изменяется только с 1 по 6.</target>
        </trans-unit>
        <trans-unit id="e9848e9219c243527c0682e352e98364329421b1" translate="yes" xml:space="preserve">
          <source>Import p4 labels into git, as per --import-labels.</source>
          <target state="translated">Импортируйте этикетки p4 в гит,согласно этикеткам --импорт.</target>
        </trans-unit>
        <trans-unit id="34d234038bf4e799d075c2933026167918f64329" translate="yes" xml:space="preserve">
          <source>Import p4 labels.</source>
          <target state="translated">Импортные этикетки р4.</target>
        </trans-unit>
        <trans-unit id="2f4ea105dee6a1ad94ce6623f490fbb875775ee0" translate="yes" xml:space="preserve">
          <source>Import-only: don&amp;rsquo;t perform a checkout after importing. This option ensures the working directory and index remain untouched and will not create them if they do not exist.</source>
          <target state="translated">Только импорт: не выполняйте проверку после импорта. Эта опция гарантирует, что рабочий каталог и индекс останутся нетронутыми и не создадут их, если они не существуют.</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="a64c4afd3bd1cef7955450469801cfbdf061341b" translate="yes" xml:space="preserve">
          <source>Important note! If you have any local changes in these branches, then this merge will create a commit object in the history (with no local changes Git will simply do a &quot;fast-forward&quot; merge). Many people dislike the &quot;noise&quot; that this creates in the Linux history, so you should avoid doing this capriciously in the &lt;code&gt;release&lt;/code&gt; branch, as these noisy commits will become part of the permanent history when you ask Linus to pull from the release branch.</source>
          <target state="translated">Важная заметка! Если у вас есть какие-либо локальные изменения в этих ветвях, то это слияние создаст объект фиксации в истории (без локальных изменений Git просто выполнит слияние с перемоткой вперед). Многим людям не нравится &amp;laquo;шум&amp;raquo;, который это создает в истории Linux, поэтому вам следует избегать делать это по прихоти в ветке &lt;code&gt;release&lt;/code&gt; , так как эти шумные коммиты станут частью постоянной истории, когда вы попросите Линуса вытащить из ветки выпуска.</target>
        </trans-unit>
        <trans-unit id="a87b614cdbaa5301ddda5b9a1cda5205ccdf1bbc" translate="yes" xml:space="preserve">
          <source>Importing a cvs archive</source>
          <target state="translated">Импорт cvs архива</target>
        </trans-unit>
        <trans-unit id="3e30801aed656938780d8d09defb05967bf70053" translate="yes" xml:space="preserve">
          <source>Importing a new project</source>
          <target state="translated">Импорт нового проекта</target>
        </trans-unit>
        <trans-unit id="7d3eb76e15d3e80f60fde0cbe9f4a9a66f1cc724" translate="yes" xml:space="preserve">
          <source>Importing or exporting patches:</source>
          <target state="translated">Импорт или экспорт патчей:</target>
        </trans-unit>
        <trans-unit id="8c866a3a4bff8b0052306000b7abfebb33a38b38" translate="yes" xml:space="preserve">
          <source>Importing patches to a project</source>
          <target state="translated">Импорт патчей в проект</target>
        </trans-unit>
        <trans-unit id="19051f1cf9bd70907beeecdf5147851f44537c38" translate="yes" xml:space="preserve">
          <source>Importing these tags as-is in Git is impossible without making at least one commit which &amp;ldquo;fixes up&amp;rdquo; the files to match the content of the tag. Use fast-import&amp;rsquo;s &lt;code&gt;reset&lt;/code&gt; command to reset a dummy branch outside of your normal branch space to the base commit for the tag, then commit one or more file fixup commits, and finally tag the dummy branch.</source>
          <target state="translated">Импорт этих тегов в Git &amp;laquo;как есть&amp;raquo; невозможен без выполнения хотя бы одной фиксации, которая &amp;laquo;исправляет&amp;raquo; файлы, чтобы они соответствовали содержимому тега. Используйте фаста-ИМПОРТ в &lt;code&gt;reset&lt;/code&gt; команды для сброса фиктивной ветви вне обычной ветви пространства к основанию фиксации для тега, а затем совершить один или несколько FixUp фиксаций файлов, и , наконец , помечать ветку фиктивной.</target>
        </trans-unit>
        <trans-unit id="ffa5110d0a0de3d5244ac22023669387afe15c4d" translate="yes" xml:space="preserve">
          <source>Imports a CVS repository into Git. It will either create a new repository, or incrementally import into an existing one.</source>
          <target state="translated">Импортирует CVS репозиторий в Git.Он либо создаст новый репозиторий,либо постепенно импортирует его в существующий.</target>
        </trans-unit>
        <trans-unit id="189a5fab4172fe96418112b3abf1f29736c5a78f" translate="yes" xml:space="preserve">
          <source>Imports a project from one or more GNU Arch repositories. It will follow branches and repositories within the namespaces defined by the &amp;lt;archive/branch&amp;gt; parameters supplied. If it cannot find the remote branch a merge comes from it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible (see discussion below).</source>
          <target state="translated">Импортирует проект из одного или нескольких репозиториев GNU Arch. Он будет следовать за ветвями и репозиториями в пространствах имен, определенных предоставленными параметрами &amp;lt;archive / branch&amp;gt;. Если он не может найти удаленную ветку, происходит слияние, она просто импортирует ее как обычную фиксацию. Если он сможет его найти, он помечает это как слияние, когда это возможно (см. Обсуждение ниже).</target>
        </trans-unit>
        <trans-unit id="0e7ba011d44c49f30a4b102d2d50cfa93397d28b" translate="yes" xml:space="preserve">
          <source>Imports the full contents of the head revision from the given p4 depot path into a single commit in the Git branch &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;.</source>
          <target state="translated">Импортирует полное содержимое головной ревизии из заданного пути депо p4 в одну фиксацию в ветке Git &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc75793944c924c387fa08f2263917093a9e6ee9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; jargon, &quot;cherry pick&quot; means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the &quot;git cherry-pick&quot; command to extract the change introduced by an existing &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; and to record it based on the tip of the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; as a new commit.</source>
          <target state="translated">На жаргоне &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; &amp;laquo;выбор вишни&amp;raquo; означает выбор подмножества изменений из серии изменений (обычно фиксация) и их запись как новая серия изменений поверх другой кодовой базы. В Git это выполняется командой &amp;laquo;git cherry-pick&amp;raquo;, чтобы извлечь изменение, внесенное существующей &lt;a href=&quot;#def_commit&quot;&gt;фиксацией,&lt;/a&gt; и записать его на основе кончика текущей &lt;a href=&quot;#def_branch&quot;&gt;ветки&lt;/a&gt; как новую фиксацию.</target>
        </trans-unit>
        <trans-unit id="5a7b7bab83d67b10ed8bbe7275df22f645616a7a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--parseopt&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like &lt;code&gt;getopt(1)&lt;/code&gt; does.</source>
          <target state="translated">В режиме &lt;code&gt;--parseopt&lt;/code&gt; &lt;code&gt;git rev-parse&lt;/code&gt; помогает настроить параметры, чтобы передать сценариям оболочки те же возможности, что и встроенные функции C. Он работает как нормализатор опций (например, разделяет совокупные значения отдельных переключателей), примерно как &lt;code&gt;getopt(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a61808962b5b6bb1a272b1dd2c4e90c87c42eb63" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--sq-quote&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; echoes on the standard output a single line suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt;. This line is made by normalizing the arguments following &lt;code&gt;--sq-quote&lt;/code&gt;. Nothing other than quoting the arguments is done.</source>
          <target state="translated">В &lt;code&gt;--sq-quote&lt;/code&gt; режиме, &lt;code&gt;git rev-parse&lt;/code&gt; эхо - сигналы на стандартный вывод одной линии подходит для &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; . Эта строка сделана путем нормализации аргументов, следующих за &lt;code&gt;--sq-quote&lt;/code&gt; . Ничего, кроме цитирования аргументов, не делается.</target>
        </trans-unit>
        <trans-unit id="02025b63af6480e186ac72d3a5a618d5536d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--stdin&lt;/code&gt; mode, take lines in the format</source>
          <target state="translated">В режиме &lt;code&gt;--stdin&lt;/code&gt; брать строки в формате</target>
        </trans-unit>
        <trans-unit id="46fb44ff2c3ae3502717728ebf0f15532f206b66" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; contains just &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">В &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;foo&lt;/code&gt; содержит только &amp;laquo;Foo&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0e95077ff33e18325bb9215a9cc5764269fc90de" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;dbDriver&lt;/code&gt; and &lt;code&gt;dbUser&lt;/code&gt; you can use the following variables:</source>
          <target state="translated">В &lt;code&gt;dbDriver&lt;/code&gt; и &lt;code&gt;dbUser&lt;/code&gt; вы можете использовать следующие переменные:</target>
        </trans-unit>
        <trans-unit id="6c351c60eb0e6d6c6a7b2ff86bb73c9f63bc0dc3" translate="yes" xml:space="preserve">
          <source>In Git 1.7.0 or later, to cancel a conflicting merge, use &lt;code&gt;git reset --merge&lt;/code&gt;. &lt;strong&gt;Warning&lt;/strong&gt;: In older versions of Git, running &lt;code&gt;git pull&lt;/code&gt; with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict.</source>
          <target state="translated">В Git 1.7.0 или новее, чтобы отменить конфликтующее слияние, используйте &lt;code&gt;git reset --merge&lt;/code&gt; . &lt;strong&gt;Предупреждение&lt;/strong&gt; : в более старых версиях Git запускать &lt;code&gt;git pull&lt;/code&gt; с незафиксированными изменениями не рекомендуется: хотя это возможно, это оставляет вас в состоянии, из которого может быть трудно выйти в случае конфликта.</target>
        </trans-unit>
        <trans-unit id="e5fbbb479d61fa23b446f30021dbc9109422a0ad" translate="yes" xml:space="preserve">
          <source>In Git like in many other Version Control Systems (VCS), the different states of the data that is managed by the system are called commits. And, as VCS are mostly used to manage software source code, sometimes &quot;interesting&quot; changes of behavior in the software are introduced in some commits.</source>
          <target state="translated">В Git'е,как и во многих других системах контроля версий (Version Control Systems-VCS),различные состояния данных,которыми управляет система,называются коммитами.И,поскольку VCS в основном используются для управления исходным кодом программ,иногда в некоторых коммитах вносятся &quot;интересные&quot; изменения в поведение программ.</target>
        </trans-unit>
        <trans-unit id="8b9196b57e8598c90aa9a79e64e11940ec4bed09" translate="yes" xml:space="preserve">
          <source>In Git&amp;rsquo;s context, synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">В контексте Git - синоним &lt;a href=&quot;#def_object_name&quot;&gt;имени объекта&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="644d8f376b3ac284860f081b25e96334d4db2911" translate="yes" xml:space="preserve">
          <source>In Git, there are two kinds of tags, a &quot;light&quot; one, and an &quot;annotated tag&quot;.</source>
          <target state="translated">В Git'е есть два вида меток,&quot;легкий&quot; и &quot;аннотированный&quot;.</target>
        </trans-unit>
        <trans-unit id="1e877f57bcce771b4a2551649d22c402a8ae8603" translate="yes" xml:space="preserve">
          <source>In SVN, it is possible (though discouraged) to commit changes to a tag (because a tag is just a directory copy, thus technically the same as a branch). When cloning an SVN repository, &lt;code&gt;git svn&lt;/code&gt; cannot know if such a commit to a tag will happen in the future. Thus it acts conservatively and imports all SVN tags as branches, prefixing the tag name with &lt;code&gt;tags/&lt;/code&gt;.</source>
          <target state="translated">В SVN можно (хотя и не рекомендуется) фиксировать изменения в теге (потому что тег - это просто копия каталога, поэтому технически то же самое, что и ветвь). При клонировании репозитория SVN &lt;code&gt;git svn&lt;/code&gt; не может знать, произойдет ли такая фиксация тега в будущем. Таким образом, он действует консервативно и импортирует все теги SVN как ветки, добавляя к имени тега префикс &lt;code&gt;tags/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c215580302a5f52c2e27d45d0d7c1d84a4eccdbe" translate="yes" xml:space="preserve">
          <source>In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0</source>
          <target state="translated">В Thunderbird 2:Edit...Preferences...Composition,оберните обычные текстовые сообщения на 0</target>
        </trans-unit>
        <trans-unit id="f440374532f0b3d43494a1b042e56f8d4bce5f5d" translate="yes" xml:space="preserve">
          <source>In Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for &quot;mail.wrap_long_lines&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;. Also, search for &quot;mailnews.wraplength&quot; and set the value to 0.</source>
          <target state="translated">В Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Найдите &quot;mail.wrap_long_lines&quot;. Переключите его, чтобы убедиться, что установлено значение &lt;code&gt;false&lt;/code&gt; . Также найдите &quot;mailnews.wraplength&quot; и установите значение 0.</target>
        </trans-unit>
        <trans-unit id="17583a69f7262368825714769d6089546a690b45" translate="yes" xml:space="preserve">
          <source>In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.</source>
          <target state="translated">В быстром обновлении с А на Б набор коммитов,на котором построен первоначальный коммит А,является подмножеством коммитов,на которых построен новый коммит Б.Следовательно,он не теряет своей истории.</target>
        </trans-unit>
        <trans-unit id="3d5b5c31f19f75af08174ee7bc83bae8bb6f0e50" translate="yes" xml:space="preserve">
          <source>In a normal repository, this tends to work automatically. The objects are mostly reachable from the branches and tags, and that&amp;rsquo;s what clients fetch. Any deltas we find on the server are likely to be between objects the client has or will have.</source>
          <target state="translated">В обычном репозитории это обычно работает автоматически. Объекты в основном доступны из веток и тегов, и это то, что получают клиенты. Любые дельты, которые мы обнаруживаем на сервере, скорее всего, будут между объектами, которые есть или будут у клиента.</target>
        </trans-unit>
        <trans-unit id="8fbcefe66dafd74525f6b8ab70d285c817dc5cf1" translate="yes" xml:space="preserve">
          <source>In a repository using the traditional SHA-1, pack checksums, index checksums, and object IDs (object names) mentioned below are all computed using SHA-1. Similarly, in SHA-256 repositories, these values are computed using SHA-256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="566e8925a0c194716258bb9a397f522567172cf6" translate="yes" xml:space="preserve">
          <source>In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:</source>
          <target state="translated">В ситуации,когда тема состояла из трех коммитов,а мейнтейнер применил два из них,ситуация может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="ee8b5fc930f29435d4aa076d7196ceac4e277fb2" translate="yes" xml:space="preserve">
          <source>In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done (either merged to the &quot;release&quot; branch, or sent out and accepted upstream).</source>
          <target state="translated">В рабочем процессе,использующем относительно долгоживущие тематические ветки,разработчику иногда приходится разрешать одни и те же конфликты снова и снова до тех пор,пока тематические ветки не будут выполнены (либо слиты в ветку &quot;релиз&quot;,либо отправлены и приняты вверх по течению).</target>
        </trans-unit>
        <trans-unit id="f7c91952cc20e93e498fb039cc3dfb4469b10f04" translate="yes" xml:space="preserve">
          <source>In addition there are a number of other widely deployed hosting, browsing and reviewing solutions such as:</source>
          <target state="translated">Кроме того,существует ряд других широко распространенных решений для хостинга,просмотра и обзора,таких как:</target>
        </trans-unit>
        <trans-unit id="24a0d0f28bd8af9cb9f6203128773b89ba8e8365" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--full-index&lt;/code&gt;, output a binary diff that can be applied with &lt;code&gt;git-apply&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666628046a18a0e7af967b1de7c1a7d7baa813ae" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--full-index&lt;/code&gt;, output a binary diff that can be applied with &lt;code&gt;git-apply&lt;/code&gt;. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">В дополнение к &lt;code&gt;--full-index&lt;/code&gt; вывести двоичный файл diff, который можно применить с помощью &lt;code&gt;git-apply&lt;/code&gt; . Подразумевается &lt;code&gt;--patch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f6c767f6bc5922d93e508ae1661b26c77720a8f" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;-M&lt;/code&gt;, detect lines moved or copied from other files that were modified in the same commit. This is useful when you reorganize your program and move code around across files. When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit.</source>
          <target state="translated">В дополнение к &lt;code&gt;-M&lt;/code&gt; обнаруживать строки, перемещенные или скопированные из других файлов, которые были изменены в той же фиксации. Это полезно, когда вы реорганизуете свою программу и перемещаете код между файлами. Если этот параметр задан дважды, команда дополнительно ищет копии из других файлов в фиксации, создавшей файл. Когда эта опция указана три раза, команда дополнительно ищет копии из других файлов в любом коммите.</target>
        </trans-unit>
        <trans-unit id="1888d5f31940dfed593ca4ff2d62ba84db0ce760" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;.gitattributes&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/attributes&lt;/code&gt;, Git looks into this file for attributes (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). Path expansions are made the same way as for &lt;code&gt;core.excludesFile&lt;/code&gt;. Its default value is &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; is used instead.</source>
          <target state="translated">В дополнение к &lt;code&gt;.gitattributes&lt;/code&gt; (для каждого каталога) и &lt;code&gt;.git/info/attributes&lt;/code&gt; , Git просматривает этот файл на предмет атрибутов (см. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; ). Расширения пути выполняются так же, как и для &lt;code&gt;core.excludesFile&lt;/code&gt; . Его значение по умолчанию - &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt; . Если &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; не задан или пуст, вместо него используются &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a80ff33db6a243344cb7df3dd9b8d8d41e916e5f" translate="yes" xml:space="preserve">
          <source>In addition to HEAD, there are several other special names for commits:</source>
          <target state="translated">В дополнение к HEAD,есть несколько других специальных имен для коммитов:</target>
        </trans-unit>
        <trans-unit id="3d952784176d6003ec5b2f9f790384bd9b8c8247" translate="yes" xml:space="preserve">
          <source>In addition to being the staging area for new commits, the index file is also populated from the object database when checking out a branch, and is used to hold the trees involved in a merge operation. See &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; and the relevant man pages for details.</source>
          <target state="translated">Помимо того, что индексный файл является промежуточной областью для новых коммитов, он также заполняется из базы данных объектов при извлечении ветви и используется для хранения деревьев, участвующих в операции слияния. См. &lt;a href=&quot;gitcore-tutorial&quot;&gt;Gitcore-tutorial [7]&lt;/a&gt; и соответствующие справочные страницы для подробностей.</target>
        </trans-unit>
        <trans-unit id="e26ec25b7f02c15aecd179e2dad4bd1f6afe8d5c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20.</source>
          <target state="translated">В дополнение к названиям ветвей,заполните сообщение журнала максимум указанным количеством однострочных описаний из реальных коммитов,которые сливаются.По умолчанию значением по умолчанию является false,а значением по умолчанию true является синоним 20.</target>
        </trans-unit>
        <trans-unit id="c5e07d7771d3e15091a04a68ed9a697dc979376c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from at most &amp;lt;n&amp;gt; actual commits that are being merged. See also &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg[1]&lt;/a&gt;.</source>
          <target state="translated">Помимо имен веток, заполните сообщение журнала однострочными описаниями максимум &amp;lt;n&amp;gt; фактических коммитов, которые объединяются. См. Также &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="53e8184a4fded8ffd5d3887baaffe37015550f76" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged. At most &amp;lt;n&amp;gt; commits from each merge parent will be used (20 if &amp;lt;n&amp;gt; is omitted). This overrides the &lt;code&gt;merge.log&lt;/code&gt; configuration variable.</source>
          <target state="translated">Помимо имен веток, заполните сообщение журнала однострочными описаниями фактических объединяемых коммитов. Будет использовано не более &amp;lt;n&amp;gt; коммитов от каждого родителя слияния (20, если &amp;lt;n&amp;gt; опущено). Это переопределяет переменную конфигурации &lt;code&gt;merge.log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6235bcb46867554949f149e203ea63eff52ea516" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with the branch description text associated with them. Defaults to false.</source>
          <target state="translated">В дополнение к названиям филиалов,заполните сообщение журнала текстом описания филиала,связанным с ними.По умолчанию используется значение по умолчанию false.</target>
        </trans-unit>
        <trans-unit id="f62e3d2f843321847fb42ac94f40312c54d52ccf" translate="yes" xml:space="preserve">
          <source>In addition to labelling blobs and commits with mark ids, also label tags. This is useful in conjunction with &lt;code&gt;--export-marks&lt;/code&gt; and &lt;code&gt;--import-marks&lt;/code&gt;, and is also useful (and necessary) for exporting of nested tags. It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers.</source>
          <target state="translated">Помимо маркировки BLOB-объектов и коммитов с помощью идентификаторов меток, также метки меток. Это полезно в сочетании с &lt;code&gt;--export-marks&lt;/code&gt; и &lt;code&gt;--import-marks&lt;/code&gt; , а также полезно (и необходимо) для экспорта вложенных тегов. Это не повредит другим случаям и будет использоваться по умолчанию, но многие интерфейсы быстрого импорта не готовы принимать теги с идентификаторами меток.</target>
        </trans-unit>
        <trans-unit id="22782295e6ea8ee2d620246684c55c016d61141f" translate="yes" xml:space="preserve">
          <source>In addition to objects reachable from any of our references, keep objects reachable from listed &amp;lt;head&amp;gt;s.</source>
          <target state="translated">В дополнение к объектам, доступным по любой из наших ссылок, сохраните объекты доступными из перечисленных &amp;lt;head&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="99c28f63ba36fb0fcaa38897708f95d9a693e369" translate="yes" xml:space="preserve">
          <source>In addition to saving you keystrokes, &lt;code&gt;git pull&lt;/code&gt; also helps you by producing a default commit message documenting the branch and repository that you pulled from.</source>
          <target state="translated">Помимо сохранения нажатий клавиш, &lt;code&gt;git pull&lt;/code&gt; также помогает вам, создавая сообщение фиксации по умолчанию, документирующее ветку и репозиторий, из которых вы извлекли.</target>
        </trans-unit>
        <trans-unit id="7129d0d8ea665296c3d9391d29a173f1ab2fc5f1" translate="yes" xml:space="preserve">
          <source>In addition to searching in the tracked files in the working tree, search also in untracked files.</source>
          <target state="translated">Помимо поиска в отслеживаемых файлах в рабочем дереве,поиск осуществляется также в неотслеживаемых файлах.</target>
        </trans-unit>
        <trans-unit id="d5b7aa3ae2fa07bc2a7838db49f832f9fd332a95" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; markers, it uses another &lt;code&gt;|||||||&lt;/code&gt; marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original.</source>
          <target state="translated">Помимо &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; , он использует еще один &lt;code&gt;|||||||&lt;/code&gt; маркер, за которым следует исходный текст. Вы можете сказать, что оригинал просто констатировал факт, и ваша сторона просто уступила этому заявлению и сдалась, в то время как другая сторона пыталась иметь более позитивное отношение. Иногда можно получить лучшее разрешение, просмотрев оригинал.</target>
        </trans-unit>
        <trans-unit id="3a9ee73184ef3bce8e3d7aa50aca9c03ee962a97" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; listed on the command line, read them from the standard input. If a &lt;code&gt;--&lt;/code&gt; separator is seen, stop reading commits and start reading paths to limit the result.</source>
          <target state="translated">Помимо &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; , перечисленных в командной строке, прочтите их со стандартного ввода. Если &lt;code&gt;--&lt;/code&gt; разделитель видно, прекратить чтение фиксаций и начать читать пути , чтобы ограничить результат.</target>
        </trans-unit>
        <trans-unit id="e57f382f37af963780a48b9b24f281a677f73e3f" translate="yes" xml:space="preserve">
          <source>In addition to the above settings, you can change whether TREESAME affects inclusion:</source>
          <target state="translated">В дополнение к вышеперечисленным настройкам,вы можете изменить,влияет ли TREESAME на включение:</target>
        </trans-unit>
        <trans-unit id="15a1839e21183f6c87dd1989058c966575a3a5b3" translate="yes" xml:space="preserve">
          <source>In addition to the above two patterns, we also expect that all files in the root directory are included. If a recursive pattern is added, then all leading directories are added as parent patterns.</source>
          <target state="translated">В дополнение к двум вышеуказанным шаблонам,мы также ожидаем,что все файлы в корневой директории будут включены.Если добавляется рекурсивный шаблон,то все ведущие каталоги добавляются как родительские.</target>
        </trans-unit>
        <trans-unit id="5cdd7d140b9026d9dc5fc6d397fdc9a74057bb4e" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field.</source>
          <target state="translated">В дополнение к сказанному выше, для фиксации и тегов объектов, имена полей заголовка ( &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;parent&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; и &lt;code&gt;tag&lt;/code&gt; ) может быть использован для указания значения в поле заголовка.</target>
        </trans-unit>
        <trans-unit id="0cd22d754613826bc7df21407a063908e095a28b" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field. Fields &lt;code&gt;tree&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; can also be used with modifier &lt;code&gt;:short&lt;/code&gt; and &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; just like &lt;code&gt;objectname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da373db26873c5d2b59dd68ca741f2f25c73567" translate="yes" xml:space="preserve">
          <source>In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3a21fa25ba67eb3d7f9da7f4344fe1b071989c" translate="yes" xml:space="preserve">
          <source>In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of &lt;code&gt;git diff --cached&lt;/code&gt;). If &lt;code&gt;-v&lt;/code&gt; is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of &lt;code&gt;git diff&lt;/code&gt;).</source>
          <target state="translated">В дополнение к именам файлов, которые были изменены, также отображаются текстовые изменения, которые должны быть зафиксированы (например, как результат &lt;code&gt;git diff --cached&lt;/code&gt; ). Если &lt;code&gt;-v&lt;/code&gt; указано дважды, то также отображаются изменения в рабочем дереве, которые еще не были подготовлены (например, как результат &lt;code&gt;git diff&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d2884340103002807461c187c73c074fbbd3657" translate="yes" xml:space="preserve">
          <source>In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref. Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote.</source>
          <target state="translated">В дополнение к объекту,на который он указывает,показать ссылку,на которую он указывает,когда показывает символическую ссылку.В настоящее время загружаемый пакет показывает только симреф HEAD,так что он будет единственным,показываемым ls-remote.</target>
        </trans-unit>
        <trans-unit id="6c7a07603f44cd9719a4b680d9f7256b9473029e" translate="yes" xml:space="preserve">
          <source>In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out.</source>
          <target state="translated">В дополнение к патчам сгенерируйте файл сопроводительного письма,содержащий описание ветки,шорт-лог и общий дифстат.Вы можете заполнить описание в файле перед отправкой.</target>
        </trans-unit>
        <trans-unit id="102ba20e10a0928862b597a4b85d8411aa7a16cb" translate="yes" xml:space="preserve">
          <source>In addition to the text-based messages available in &lt;code&gt;GIT_TRACE2&lt;/code&gt;, this setting writes a column-based format for understanding nesting regions. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">В дополнение к текстовым сообщениям, доступным в &lt;code&gt;GIT_TRACE2&lt;/code&gt; , этот параметр записывает формат на основе столбцов для понимания областей вложенности. См. &lt;code&gt;GIT_TRACE2&lt;/code&gt; для доступных опций вывода трассировки и &lt;a href=&quot;api-trace2&quot;&gt;документацию Trace2&lt;/a&gt; для полной информации.</target>
        </trans-unit>
        <trans-unit id="547bdce4dd37bfda9e1c54bdf493ad3c6de08ff9" translate="yes" xml:space="preserve">
          <source>In addition, any unrecognized string that has a &lt;code&gt;%&lt;/code&gt; in it is interpreted as if it has &lt;code&gt;tformat:&lt;/code&gt; in front of it. For example, these two are equivalent:</source>
          <target state="translated">Кроме того, любая нераспознанная строка, в которой есть &lt;code&gt;%&lt;/code&gt; , интерпретируется так, как если бы &lt;code&gt;tformat:&lt;/code&gt; ней был tformat : . Например, эти два эквивалента:</target>
        </trans-unit>
        <trans-unit id="bc74e38407c657e1d62a835de829f2a0637ff932" translate="yes" xml:space="preserve">
          <source>In addition, if the variable is set to &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt;, Git will try to open the path as a Unix Domain Socket. The socket type can be either &lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;dgram&lt;/code&gt;.</source>
          <target state="translated">Кроме того, если для переменной задано значение &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt; , Git попытается открыть путь как сокет домена Unix. Тип сокета может быть либо &lt;code&gt;stream&lt;/code&gt; либо &lt;code&gt;dgram&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdc73bece50193400c9954e5c33b0d5db46ea312" translate="yes" xml:space="preserve">
          <source>In addition, some Git commands (such as &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; and &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;) can also take revision parameters which denote other objects than commits, e.g. blobs (&quot;files&quot;) or trees (&quot;directories of files&quot;).</source>
          <target state="translated">Кроме того, некоторые команды Git (такие как &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; ) также могут принимать параметры ревизии, которые обозначают другие объекты, кроме коммитов, например капли (&amp;laquo;файлы&amp;raquo;) или деревья (&amp;laquo;каталоги файлов&amp;raquo; ).</target>
        </trans-unit>
        <trans-unit id="5a217c5b9ad4a208c3474725c21c0795d0272c6d" translate="yes" xml:space="preserve">
          <source>In addition, some advanced users find &lt;code&gt;pre-commit&lt;/code&gt; hooks to be an impediment to workflows that use temporary commits to stage work in progress or that create fixup commits, so it&amp;rsquo;s better to push these kinds of checks to the server anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0114752cc3965279675b92f9d509a7719a899c" translate="yes" xml:space="preserve">
          <source>In addition, the date part is accepted in the following formats: &lt;code&gt;YYYY.MM.DD&lt;/code&gt;, &lt;code&gt;MM/DD/YYYY&lt;/code&gt; and &lt;code&gt;DD.MM.YYYY&lt;/code&gt;.</source>
          <target state="translated">Кроме того, часть даты принимается в следующих форматах: &lt;code&gt;YYYY.MM.DD&lt;/code&gt; , &lt;code&gt;MM/DD/YYYY&lt;/code&gt; и &lt;code&gt;DD.MM.YYYY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b090b5874a4f9cb2a75963ffefe67f7cff33a14b" translate="yes" xml:space="preserve">
          <source>In addition, the following pairs of options are incompatible:</source>
          <target state="translated">Кроме того,следующие пары опционов несовместимы:</target>
        </trans-unit>
        <trans-unit id="c9eac4f7a75d08c8d5ecd2f93cae76dbdd2c65fb" translate="yes" xml:space="preserve">
          <source>In addition, there are a number of optional keys:</source>
          <target state="translated">Кроме того,имеется ряд дополнительных клавиш:</target>
        </trans-unit>
        <trans-unit id="85bcf09fd5e608ff2a7f0cedbab486dcd84fe020" translate="yes" xml:space="preserve">
          <source>In addition, you can use the &lt;code&gt;store&lt;/code&gt; credential manager which stores in a file in your home directory, or the &lt;code&gt;cache&lt;/code&gt; credential manager, which does not permanently store your credentials, but does prevent you from being prompted for them for a certain period of time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3170175bde47695f8d16d1aa859fc39830538d4d" translate="yes" xml:space="preserve">
          <source>In all &quot;keep index&quot; cases, the index entry stays as in the original index file. If the entry is not up to date, &lt;code&gt;git read-tree&lt;/code&gt; keeps the copy in the work tree intact when operating under the -u flag.</source>
          <target state="translated">Во всех случаях &amp;laquo;сохранить индекс&amp;raquo; запись индекса остается такой же, как в исходном индексном файле. Если запись устарела, &lt;code&gt;git read-tree&lt;/code&gt; сохраняет копию в рабочем дереве нетронутой при работе с флагом -u.</target>
        </trans-unit>
        <trans-unit id="518e45973547d44ae8b0cf643cea7c8e1439a6f7" translate="yes" xml:space="preserve">
          <source>In all of these cases, the commands themselves first optionally limit the two sets of files by any pathspecs given on their command-lines, and compare corresponding paths in the two resulting sets of files.</source>
          <target state="translated">Во всех этих случаях сами команды сначала опционально ограничивают два набора файлов любыми указанными в их командных строках путями,а затем сравнивают соответствующие пути в двух результирующих наборах файлов.</target>
        </trans-unit>
        <trans-unit id="a976d8376129a573bbe9b45628bf2bdf5e1fe7e1" translate="yes" xml:space="preserve">
          <source>In an environment that restricts the users' access only to git commands over the wire, this hook can be used to implement access control without relying on filesystem ownership and group membership. See &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt; for how you might use the login shell to restrict the user&amp;rsquo;s access to only git commands.</source>
          <target state="translated">В среде, которая ограничивает доступ пользователей только к командам git по сети, этот хук можно использовать для реализации контроля доступа, не полагаясь на владение файловой системой и членство в группе. См. &lt;a href=&quot;git-shell&quot;&gt;Git-shell [1],&lt;/a&gt; чтобы узнать, как можно использовать оболочку входа в систему, чтобы ограничить доступ пользователя только командами git.</target>
        </trans-unit>
        <trans-unit id="9220471bbc29ec41ed13c216a79cb80f852ef698" translate="yes" xml:space="preserve">
          <source>In any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error. It returns an empty string instead.</source>
          <target state="translated">В любом случае,имя поля,которое ссылается на поле,неприменимое к объекту,на который ссылается ссылка,не вызывает ошибки.Вместо этого оно возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="3ed3c4a7faef04068c3d21c5e427f36b63dea04c" translate="yes" xml:space="preserve">
          <source>In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cc553818c07e93d42b2d9a9da22e8f0487ba9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">В обоих форматах &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; - любое из выражений спецификации фиксации, также принимаемых &lt;code&gt;from&lt;/code&gt; (см. Выше).</target>
        </trans-unit>
        <trans-unit id="9838d0f6a0615e5345bacba941fa3a7ae58fc03e" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is the type of file entry, specified in octal. Git only supports the following modes:</source>
          <target state="translated">В обоих форматах &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; - это тип записи файла, указанный в восьмеричном формате. Git поддерживает только следующие режимы:</target>
        </trans-unit>
        <trans-unit id="e124f640b7099c2dfc555e83763a437b341aea9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is the complete path of the file to be added (if not already existing) or modified (if already existing).</source>
          <target state="translated">В обоих форматах &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; - это полный путь к файлу, который нужно добавить (если он еще не существует) или изменить (если уже существует).</target>
        </trans-unit>
        <trans-unit id="e22465a192b99fdb8a38ceb6e2163b1bb2a55eaa" translate="yes" xml:space="preserve">
          <source>In both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line. The temporary file names are always safe strings; they will never contain directory separators or whitespace characters. The path field is always relative to the current directory and the temporary file names are always relative to the top level directory.</source>
          <target state="translated">В обоих форматах RS (разделитель записей)по умолчанию является новой строкой,но будет нулевым байтом,если в командной строке был передан -z.Имена временных файлов всегда являются безопасными строками;они никогда не будут содержать разделители каталогов или пробельные символы.Поле пути всегда относительно текущего каталога,а имена временных файлов всегда относительно каталога верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="bbdfd88cae7c8d5fe4027454edb7c9f3a518f214" translate="yes" xml:space="preserve">
          <source>In both rename and copy detection, the same &quot;extent of changes&quot; algorithm used in diffcore-break is used to determine if two files are &quot;similar enough&quot;, and can be customized to use a similarity score different from the default of 50% by giving a number after the &quot;-M&quot; or &quot;-C&quot; option (e.g. &quot;-M8&quot; to tell it to use 8/10 = 80%).</source>
          <target state="translated">Как при переименовании,так и при обнаружении копирования,один и тот же алгоритм &quot;степени изменений&quot;,используемый в diffcore-break,используется для определения того,являются ли два файла &quot;достаточно похожими&quot;,и может быть настроен на использование оценки схожести,отличной от значения по умолчанию в 50%,путем указания числа после опции &quot;-M&quot; или &quot;-C&quot; (например,&quot;-M8&quot;,чтобы сказать ему использовать 8/10=80%).</target>
        </trans-unit>
        <trans-unit id="cef1680a7a27c73f800aa2ae728f37bb9ebeed5c" translate="yes" xml:space="preserve">
          <source>In case &amp;lt;old&amp;gt; and &amp;lt;new&amp;gt; are the same, and &amp;lt;old&amp;gt; is a file under &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; or &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;, the remote is converted to the configuration file format.</source>
          <target state="translated">В случае, если &amp;lt;old&amp;gt; и &amp;lt;new&amp;gt; совпадают, а &amp;lt;old&amp;gt; - это файл в &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; или &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; , пульт преобразуется в формат файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="77e55c61e61a6a73beec771303a37403de7ae828" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt;, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3736cf7c9e88d8830feeb4facce5d47bac7822e0" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items user.name and user.email, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="translated">Если (некоторые из) эти переменные среды не заданы, информация берется из элементов конфигурации user.name и user.email, или, если нет, из переменной среды EMAIL, или, если она не задана, из системного пользователя имя и имя хоста, используемое для исходящей почты (берется из &lt;code&gt;/etc/mailname&lt;/code&gt; и возвращается к полному имени хоста, если этот файл не существует).</target>
        </trans-unit>
        <trans-unit id="fab172a52a0d96a15d352f159439993a534e8fe5" translate="yes" xml:space="preserve">
          <source>In case of conflict, &lt;code&gt;git rebase&lt;/code&gt; will stop at the first problematic commit and leave conflict markers in the tree. You can use &lt;code&gt;git diff&lt;/code&gt; to locate the markers (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with</source>
          <target state="translated">В случае конфликта &lt;code&gt;git rebase&lt;/code&gt; остановится при первой проблемной фиксации и оставит маркеры конфликта в дереве. Вы можете использовать &lt;code&gt;git diff&lt;/code&gt; , чтобы найти маркеры (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;) и внести изменения, чтобы разрешить конфликт. Для каждого файла, который вы редактируете, вам нужно сообщить Git, что конфликт разрешен, обычно это делается с помощью</target>
        </trans-unit>
        <trans-unit id="8de3ddb587a19db9387af113a7f3cb72b19328d0" translate="yes" xml:space="preserve">
          <source>In case of failure in the output of &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt;, show directions on how to proceed from the current state.</source>
          <target state="translated">В случае сбоя в выводе &lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt; , покажите инструкции, как действовать из текущего состояния.</target>
        </trans-unit>
        <trans-unit id="1ca6e2b22c66fb3bb4920e7b16e070cab433e13d" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content as well as any future content for the lifetime of the Git process, then it is expected to respond with an &quot;abort&quot; status at any point in the protocol.</source>
          <target state="translated">В случае,если фильтр не может или не хочет обрабатывать содержимое,а также любое будущее содержимое на протяжении всего срока действия Git-процесса,ожидается,что в любой момент в протоколе он будет отвечать со статусом &quot;abort&quot;.</target>
        </trans-unit>
        <trans-unit id="a44b155f3278323b322b1edffc06fec805c87137" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content, it is expected to respond with an &quot;error&quot; status.</source>
          <target state="translated">В случае,если фильтр не может или не хочет обрабатывать содержимое,ожидается,что он ответит со статусом &quot;ошибка&quot;.</target>
        </trans-unit>
        <trans-unit id="063d2c577358a9002bf9810cc43ec764ca0682e1" translate="yes" xml:space="preserve">
          <source>In command synopses, the word &quot;tree-ish&quot; is sometimes used to designate such an argument.</source>
          <target state="translated">В командных синопсах слово &quot;tree-ish&quot; иногда используется для обозначения такого аргумента.</target>
        </trans-unit>
        <trans-unit id="0cb56babf143d18da14e8d5b38b880de0eb432ae" translate="yes" xml:space="preserve">
          <source>In compact output mode, specified with configuration variable fetch.output, if either entire &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; is found in the other string, it will be substituted with &lt;code&gt;*&lt;/code&gt; in the other string. For example, &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; becomes &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt;.</source>
          <target state="translated">В компактном режиме вывода, заданном с помощью переменной конфигурации fetch.output, если в другой строке находится либо весь &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; , либо &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; , он будет заменен на &lt;code&gt;*&lt;/code&gt; в другой строке. Например, &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; становится &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a206b483cbd4faf3ff1c681d69d041ba456195" translate="yes" xml:space="preserve">
          <source>In contrast to a regular interactive rebase, there are &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; commands in addition to &lt;code&gt;pick&lt;/code&gt; ones.</source>
          <target state="translated">В отличие от обычного интерактивного перебазирования, в дополнение к командам &lt;code&gt;pick&lt;/code&gt; есть команды &lt;code&gt;label&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; и &lt;code&gt;merge&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a91f8ccdcda758152dfb84f7e032555a6abd0478" translate="yes" xml:space="preserve">
          <source>In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:</source>
          <target state="translated">Напротив,непередаваемое обновление потеряет историю.Например,предположим,что вы и кто-то другой запустили один и тот же коммит X,и вы построили историю,ведущую к коммиту B,в то время как другой человек построил историю,ведущую к коммиту A.История выглядит так:</target>
        </trans-unit>
        <trans-unit id="732c99dfb4118d47f73ec2f7f549a4abcdf7b217" translate="yes" xml:space="preserve">
          <source>In detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b2f985753911580a2527f5513df7870e7e2eaf" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has 10\^5 files and 10\^5 commits, but each commit only modifies 5 files, then git-filter-branch will make you do 10\^10 modifications, despite only having (at most) 5*10^5 unique blobs.</source>
          <target state="translated">При редактировании файлов git-фильтр по замыслу проверяет каждый коммит в том виде,в каком он существовал в исходном репо.Если в вашем репо есть 10\^5 файлов и 10\^5 коммитов,но каждый коммит модифицирует только 5 файлов,то git-фильтр заставит вас делать модификации 10\^10,несмотря на то,что у вас есть только (максимум)5*10^5 уникальных блоков.</target>
        </trans-unit>
        <trans-unit id="2e3fe33f9a577c2f8225b1f2426166ec832bed24" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has &lt;code&gt;10^5&lt;/code&gt; files and &lt;code&gt;10^5&lt;/code&gt; commits, but each commit only modifies five files, then git-filter-branch will make you do &lt;code&gt;10^10&lt;/code&gt; modifications, despite only having (at most) &lt;code&gt;5*10^5&lt;/code&gt; unique blobs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a532459a44f155e770ddc46e416638b81292d839" translate="yes" xml:space="preserve">
          <source>In either format, values can be specified in any form that Git recognizes as an object name. Commands in any other format or a repeated &amp;lt;ref&amp;gt; produce an error. Command meanings are:</source>
          <target state="translated">В любом формате значения могут быть указаны в любой форме, которую Git распознает как имя объекта. Команды в любом другом формате или повторение &amp;lt;ref&amp;gt; вызывают ошибку. Значения команд:</target>
        </trans-unit>
        <trans-unit id="9c49e183be0df7128f7b7d238522888866505455" translate="yes" xml:space="preserve">
          <source>In fact development teams often maintain both a development branch and a maintenance branch, and it would be quite easy for them if &quot;git bisect&quot; just worked when they want to bisect a regression on the development branch that is not on the maintenance branch. They should be able to start bisecting using:</source>
          <target state="translated">На самом деле,команды разработчиков часто содержат и ветку разработки,и ветку обслуживания,и для них было бы довольно легко,если бы &quot;git-биссект&quot; просто работал,когда они хотят разбить биссектрису на ветку разработки,которой нет в ветке обслуживания.Они должны иметь возможность начать использовать биссектрису:</target>
        </trans-unit>
        <trans-unit id="49c9270dc1d07096e092a06d8107784ae1248f61" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s invaluable because there are bugs i would never even &lt;code&gt;try&lt;/code&gt; to debug if it wasn&amp;rsquo;t for git bisect. In the past there were bug patterns that were immediately hopeless for me to debug - at best i could send the crash/bug signature to lkml and hope that someone else can think of something.</source>
          <target state="translated">На самом деле это бесценно, потому что есть ошибки, которые я бы даже не &lt;code&gt;try&lt;/code&gt; отлаживать, если бы не git bisect. В прошлом были шаблоны ошибок, отладить которые мне сразу было безнадежно - в лучшем случае я мог отправить сигнатуру сбоя / ошибки в lkml и надеяться, что кто-то еще что-нибудь придумает.</target>
        </trans-unit>
        <trans-unit id="4d0defa9e6e327fdaa3580beb798bb05e9bb4ad4" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s this last feature that &quot;sold&quot; it to the Git community, so it is now in the &quot;master&quot; branch of Git&amp;rsquo;s Git repository and it should be released in Git 1.6.5 in October or November 2009.</source>
          <target state="translated">Фактически, именно эта последняя функция &amp;laquo;продала&amp;raquo; ее сообществу Git, поэтому теперь она находится в &amp;laquo;главной&amp;raquo; ветви репозитория Git Git и должна быть выпущена в Git 1.6.5 в октябре или ноябре 2009 года.</target>
        </trans-unit>
        <trans-unit id="a503332ebe0b76ca226cc7fab9355da1cbc846ca" translate="yes" xml:space="preserve">
          <source>In fact people are specially interested in commits that introduce a &quot;bad&quot; behavior, called a bug or a regression. They are interested in these commits because a commit (hopefully) contains a very small set of source code changes. And it&amp;rsquo;s much easier to understand and properly fix a problem when you only need to check a very small set of changes, than when you don&amp;rsquo;t know where look in the first place.</source>
          <target state="translated">На самом деле людей особенно интересуют коммиты, которые приводят к &amp;laquo;плохому&amp;raquo; поведению, называемому ошибкой или регрессом. Они заинтересованы в этих коммитах, потому что коммит (надеюсь) содержит очень небольшой набор изменений исходного кода. И гораздо легче понять и правильно исправить проблему, когда вам нужно проверить только очень небольшой набор изменений, чем когда вы не знаете, куда смотреть в первую очередь.</target>
        </trans-unit>
        <trans-unit id="ef62eb9471b68497e696b504f306bae12d5b62ac" translate="yes" xml:space="preserve">
          <source>In fact the problem is that big software often has many different configuration options and that each test case should pass for each configuration after each commit. So if you have for each release: N configurations, M commits and T test cases, you should perform:</source>
          <target state="translated">На самом деле проблема заключается в том,что большое программное обеспечение часто имеет много различных вариантов конфигурации,и что каждый тестовый случай должен пройти для каждой конфигурации после каждого коммита.Поэтому,если у вас есть для каждого релиза:N конфигураций,M коммитов и T тестовых примеров,вы должны выполнить:</target>
        </trans-unit>
        <trans-unit id="99977c45d37760acd8d4612dba46dd63b60c39cd" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git bisect&lt;/code&gt; can be used to find the commit that changed &lt;strong&gt;any&lt;/strong&gt; property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark&amp;rsquo;s performance to improve. To support this more general usage, the terms &quot;old&quot; and &quot;new&quot; can be used in place of &quot;good&quot; and &quot;bad&quot;, or you can choose your own terms. See section &quot;Alternate terms&quot; below for more information.</source>
          <target state="translated">Фактически, &lt;code&gt;git bisect&lt;/code&gt; можно использовать для поиска фиксации, которая изменила &lt;strong&gt;любое&lt;/strong&gt; свойство вашего проекта; например, фиксация, исправившая ошибку, или фиксация, которая привела к повышению производительности теста. Чтобы поддержать это более общее использование, термины &amp;laquo;старый&amp;raquo; и &amp;laquo;новый&amp;raquo; могут использоваться вместо &amp;laquo;хорошего&amp;raquo; и &amp;laquo;плохого&amp;raquo;, или вы можете выбрать свои собственные термины. См. Раздел &amp;laquo;Альтернативные условия&amp;raquo; ниже для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="7071f9821fe5bdd2a61f333d551d92b1d1a7cc62" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git diff-index --cached&lt;/code&gt;&lt;strong&gt;should&lt;/strong&gt; always be entirely equivalent to actually doing a &lt;code&gt;git write-tree&lt;/code&gt; and comparing that. Except this one is much nicer for the case where you just want to check where you are.</source>
          <target state="translated">Фактически, &lt;code&gt;git diff-index --cached&lt;/code&gt; всегда &lt;strong&gt;должен&lt;/strong&gt; быть полностью эквивалентен фактическому созданию &lt;code&gt;git write-tree&lt;/code&gt; и его сравнению. За исключением того, что этот гораздо лучше для случая, когда вы просто хотите проверить, где вы находитесь.</target>
        </trans-unit>
        <trans-unit id="4ed30cb15a7bebad154936439885b3df49088a74" translate="yes" xml:space="preserve">
          <source>In fact, as you did that, if you now look into your object directory, you&amp;rsquo;ll notice that Git will have added two new objects to the object database. If you did exactly the steps above, you should now be able to do</source>
          <target state="translated">Фактически, когда вы это сделали, если вы теперь заглянете в свой каталог объектов, вы заметите, что Git добавит два новых объекта в базу данных объектов. Если вы выполнили точно указанные выше действия, теперь вы сможете</target>
        </trans-unit>
        <trans-unit id="c9492aea4e59a8249b05f0197902254019664286" translate="yes" xml:space="preserve">
          <source>In fact, if you have &lt;code&gt;master&lt;/code&gt; checked out, then this branch has been configured by &lt;code&gt;git clone&lt;/code&gt; to get changes from the HEAD branch of the origin repository. So often you can accomplish the above with just a simple</source>
          <target state="translated">Фактически, если у вас есть &lt;code&gt;master&lt;/code&gt; , то эта ветка была настроена с помощью &lt;code&gt;git clone&lt;/code&gt; для получения изменений из ветки HEAD исходного репозитория. Очень часто вы можете выполнить вышеперечисленное с помощью простого</target>
        </trans-unit>
        <trans-unit id="c5bd224f8ecefe700eae1705d4f2a63ae227649f" translate="yes" xml:space="preserve">
          <source>In fact, in &lt;a href=&quot;#git-concepts&quot;&gt;Git concepts&lt;/a&gt; we shall see that everything stored in Git history, including file data and directory contents, is stored in an object with a name that is a hash of its contents.</source>
          <target state="translated">Фактически, в &lt;a href=&quot;#git-concepts&quot;&gt;концепциях Git&lt;/a&gt; мы увидим, что все, что хранится в истории Git, включая данные файлов и содержимое каталогов, хранится в объекте с именем, которое является хешем его содержимого.</target>
        </trans-unit>
        <trans-unit id="9ce4601e5a5f52f186df099525d9504862a821c8" translate="yes" xml:space="preserve">
          <source>In fact, together with the &lt;code&gt;git rev-list&lt;/code&gt; program (which generates a list of revisions), &lt;code&gt;git diff-tree&lt;/code&gt; ends up being a veritable fount of changes. You can emulate &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git log -p&lt;/code&gt;, etc. with a trivial script that pipes the output of &lt;code&gt;git rev-list&lt;/code&gt; to &lt;code&gt;git diff-tree --stdin&lt;/code&gt;, which was exactly how early versions of &lt;code&gt;git log&lt;/code&gt; were implemented.</source>
          <target state="translated">Фактически, вместе с программой &lt;code&gt;git rev-list&lt;/code&gt; (которая генерирует список ревизий) &lt;code&gt;git diff-tree&lt;/code&gt; оказывается настоящим кладезем изменений. Вы можете эмулировать &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git log -p&lt;/code&gt; и т. Д. С помощью тривиального скрипта, который &lt;code&gt;git diff-tree --stdin&lt;/code&gt; вывод &lt;code&gt;git rev-list&lt;/code&gt; в git diff-tree --stdin , как и были реализованы ранние версии &lt;code&gt;git log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da9de14a63db6e5a8e5a19a81e9a6160f95eb222" translate="yes" xml:space="preserve">
          <source>In fact, we can perform all the normal Git operations. But, let&amp;rsquo;s look at what happens when we then checkout &lt;code&gt;master&lt;/code&gt;:</source>
          <target state="translated">Фактически, мы можем выполнять все обычные операции Git. Но давайте посмотрим, что происходит, когда мы затем проверяем &lt;code&gt;master&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="728d90294e037628a986d3380572564cc895d389" translate="yes" xml:space="preserve">
          <source>In future versions we may learn to support patterns containing \0 for more search backends, until then we&amp;rsquo;ll die when the pattern type in question doesn&amp;rsquo;t support them.</source>
          <target state="translated">В будущих версиях мы можем научиться поддерживать шаблоны, содержащие \ 0, для дополнительных механизмов поиска, до тех пор мы умрем, когда рассматриваемый тип шаблона их не поддерживает.</target>
        </trans-unit>
        <trans-unit id="674a2666658c40a25d4cd65b3ea28af975f1fa97" translate="yes" xml:space="preserve">
          <source>In general a client can request to speak protocol v2 by sending &lt;code&gt;version=2&lt;/code&gt; through the respective side-channel for the transport being used which inevitably sets &lt;code&gt;GIT_PROTOCOL&lt;/code&gt;. More information can be found in &lt;code&gt;pack-protocol.txt&lt;/code&gt; and &lt;code&gt;http-protocol.txt&lt;/code&gt;. In all cases the response from the server is the capability advertisement.</source>
          <target state="translated">Как правило, клиент может запросить передачу по протоколу v2, отправив &lt;code&gt;version=2&lt;/code&gt; через соответствующий побочный канал для используемого транспорта, который неизбежно устанавливает &lt;code&gt;GIT_PROTOCOL&lt;/code&gt; . Дополнительную информацию можно найти в &lt;code&gt;pack-protocol.txt&lt;/code&gt; и &lt;code&gt;http-protocol.txt&lt;/code&gt; . Во всех случаях ответ сервера является объявлением о возможности.</target>
        </trans-unit>
        <trans-unit id="1aaa12db7c29bdac4538baf95940db6bed82a0b8" translate="yes" xml:space="preserve">
          <source>In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.</source>
          <target state="translated">В общем,URL содержат информацию о транспортном протоколе,адресе удаленного сервера и пути к хранилищу.В зависимости от транспортного протокола часть этой информации может отсутствовать.</target>
        </trans-unit>
        <trans-unit id="811906db3a55c059a1cd7d72b959827c93f94a02" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &quot;refs/&quot; are shared. Pseudo refs are ones like HEAD which are directly under GIT_DIR instead of inside GIT_DIR/refs. There is one exception to this: refs inside refs/bisect and refs/worktree is not shared.</source>
          <target state="translated">В общем случае,все псевдо-ссылки относятся к одному рабочему дереву,и все ссылки,начинающиеся с &quot;refs/&quot;,являются общими.Псевдо-справки похожи на HEAD,которые находятся непосредственно под GIT_DIR,а не внутри GIT_DIR/refs.Есть одно исключение:ссылки внутри refs/bisect и refs/worktree не разделяются.</target>
        </trans-unit>
        <trans-unit id="c1959905d09bef6c12ae8c7983e3b002ca1126c5" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &lt;code&gt;refs/&lt;/code&gt; are shared. Pseudo refs are ones like &lt;code&gt;HEAD&lt;/code&gt; which are directly under &lt;code&gt;$GIT_DIR&lt;/code&gt; instead of inside &lt;code&gt;$GIT_DIR/refs&lt;/code&gt;. There are exceptions, however: refs inside &lt;code&gt;refs/bisect&lt;/code&gt; and &lt;code&gt;refs/worktree&lt;/code&gt; are not shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e394e7bf320940c252fcc858f73aeff38e0e3c05" translate="yes" xml:space="preserve">
          <source>In general, it is better to enumerate existing objects with problems with &lt;code&gt;fsck.skipList&lt;/code&gt;, instead of listing the kind of breakages these problematic objects share to be ignored, as doing the latter will allow new instances of the same breakages go unnoticed.</source>
          <target state="translated">В общем, лучше перечислить существующие объекты с проблемами с помощью &lt;code&gt;fsck.skipList&lt;/code&gt; , вместо того, чтобы перечислять виды поломок, которые разделяются этими проблемными объектами, которые следует игнорировать, поскольку выполнение последнего позволит новым экземплярам тех же поломок остаться незамеченными.</target>
        </trans-unit>
        <trans-unit id="7dc03507399a3b4938c051e86309da2b5ba01f5b" translate="yes" xml:space="preserve">
          <source>In general, the interrogate commands do not touch the files in the working tree.</source>
          <target state="translated">В общем случае команды опроса не затрагивают файлы в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="da99798f442d92adef44d8e41846c087acff5111" translate="yes" xml:space="preserve">
          <source>In general, there are a variety of problems that can occur when using squash merges to merge two branches multiple times. These can include seeing extra commits in &lt;code&gt;git log&lt;/code&gt; output, with a GUI, or when using the &lt;code&gt;...&lt;/code&gt; notation to express a range, as well as the possibility of needing to re-resolve conflicts again and again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0830c69bce9b1a4ab3ff9dbb3ca0e63e381af048" translate="yes" xml:space="preserve">
          <source>In general, using</source>
          <target state="translated">В общем,используя</target>
        </trans-unit>
        <trans-unit id="37034b2d8b34e79ca4767d593d59ca39d0651fd5" translate="yes" xml:space="preserve">
          <source>In here all submodules except &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob) are active. &lt;code&gt;foo&lt;/code&gt; due to its own active flag and all the others due to the submodule active pathspec, which specifies that any submodule starting with &lt;code&gt;b&lt;/code&gt; except &lt;code&gt;baz&lt;/code&gt; are also active, regardless of the presence of the .url field.</source>
          <target state="translated">Здесь активны все подмодули, кроме &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob). &lt;code&gt;foo&lt;/code&gt; из-за его собственного активного флага, а все остальные из-за активного pathspec подмодуля, который указывает, что любой подмодуль, начинающийся с &lt;code&gt;b&lt;/code&gt; , кроме &lt;code&gt;baz&lt;/code&gt; , также активен, независимо от наличия поля .url.</target>
        </trans-unit>
        <trans-unit id="f129c819372eb3b42173e4b2d9e114ef285b7635" translate="yes" xml:space="preserve">
          <source>In interactive commands, allow the user to provide one-letter input with a single key (i.e., without hitting enter). Currently this is used by the &lt;code&gt;--patch&lt;/code&gt; mode of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;, &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, and &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. Note that this setting is silently ignored if portable keystroke input is not available; requires the Perl module Term::ReadKey.</source>
          <target state="translated">В интерактивных командах разрешите пользователю вводить однобуквенные символы с помощью одной клавиши (т. Е. Без нажатия клавиши ввода). В настоящее время это используется в режиме &lt;code&gt;--patch&lt;/code&gt; для &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; , &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; , &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; , &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; , &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; и &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; . Обратите внимание, что этот параметр автоматически игнорируется, если переносимый ввод нажатием клавиш недоступен; требуется Perl-модуль Term :: ReadKey.</target>
        </trans-unit>
        <trans-unit id="1d1c8ed607ef3eefbb04beacb314688e02741550" translate="yes" xml:space="preserve">
          <source>In interactive mode, you can mark commits with the action &quot;edit&quot;. However, this does not necessarily mean that &lt;code&gt;git rebase&lt;/code&gt; expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:</source>
          <target state="translated">В интерактивном режиме вы можете пометить коммиты с помощью действия &amp;laquo;изменить&amp;raquo;. Однако это не обязательно означает, что &lt;code&gt;git rebase&lt;/code&gt; ожидает, что результатом этого редактирования будет ровно один коммит. Действительно, вы можете отменить коммит или добавить другие коммиты. Это можно использовать для разделения коммита на две части:</target>
        </trans-unit>
        <trans-unit id="15b1add937944ed893f52c8ec0293a4127b76c00" translate="yes" xml:space="preserve">
          <source>In its first form, the command provides the content or the type of an object in the repository. The type is required unless &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; is used to find the object type, or &lt;code&gt;-s&lt;/code&gt; is used to find the object size, or &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; is used (which imply type &quot;blob&quot;).</source>
          <target state="translated">В своей первой форме команда предоставляет содержимое или тип объекта в репозитории. Тип является обязательным, если для поиска типа объекта не используется &lt;code&gt;-t&lt;/code&gt; или &lt;code&gt;-p&lt;/code&gt; , или &lt;code&gt;-s&lt;/code&gt; используется для определения размера объекта, или используется &lt;code&gt;--textconv&lt;/code&gt; или &lt;code&gt;--filters&lt;/code&gt; (что подразумевает тип &quot;blob&quot;).</target>
        </trans-unit>
        <trans-unit id="1ce9842f8f482fa7cd77bb4bd4603b72b75e4e0b" translate="yes" xml:space="preserve">
          <source>In its most compact form, this instruction only takes up one byte (0x80) with both offset and size omitted, which will have default values zero. There is another exception: size zero is automatically converted to 0x10000.</source>
          <target state="translated">В самом компактном виде эта инструкция занимает всего один байт (0x80),при этом опущены как смещение,так и размер,которые будут иметь значения по умолчанию равные нулю.Есть еще одно исключение:размер нуля автоматически конвертируется в 0x10000.</target>
        </trans-unit>
        <trans-unit id="ed6a0138b63bece5f8693e0a03055de4444b4006" translate="yes" xml:space="preserve">
          <source>In its simplest form, &lt;code&gt;git worktree add &amp;lt;path&amp;gt;&lt;/code&gt; automatically creates a new branch whose name is the final component of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, which is convenient if you plan to work on a new topic. For instance, &lt;code&gt;git
worktree add ../hotfix&lt;/code&gt; creates new branch &lt;code&gt;hotfix&lt;/code&gt; and checks it out at path &lt;code&gt;../hotfix&lt;/code&gt;. To instead work on an existing branch in a new working tree, use &lt;code&gt;git worktree add &amp;lt;path&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;. On the other hand, if you just plan to make some experimental changes or do testing without disturbing existing development, it is often convenient to create a &lt;code&gt;throwaway&lt;/code&gt; working tree not associated with any branch. For instance, &lt;code&gt;git worktree add -d &amp;lt;path&amp;gt;&lt;/code&gt; creates a new working tree with a detached &lt;code&gt;HEAD&lt;/code&gt; at the same commit as the current branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70413e1dbdf33a9cdd6044f089c7e374f7b737c4" translate="yes" xml:space="preserve">
          <source>In mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; &lt;code&gt;1&lt;/code&gt; is matched to &lt;code&gt;C&lt;/code&gt; at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:</source>
          <target state="translated">С математической точки зрения, мы ищем своего рода двустороннее сопоставление с минимальной стоимостью; &lt;code&gt;1&lt;/code&gt; сопоставляется с &lt;code&gt;C&lt;/code&gt; за некоторую плату и т. Д. Базовый граф фактически является полным двудольным графом; Стоимость, которую мы связываем с каждым ребром, - это размер разницы между патчами двух коммитов. Чтобы объяснить также новые коммиты, мы вводим фиктивные узлы с обеих сторон:</target>
        </trans-unit>
        <trans-unit id="abc4a2c282027431dbb87981bf40f5240785d9ef" translate="yes" xml:space="preserve">
          <source>In modern git, you can say this in a more direct way:</source>
          <target state="translated">В современном git'е можно сказать это более прямолинейно:</target>
        </trans-unit>
        <trans-unit id="1cd9dc714cc1317fe8fea12649b27b5eeab6e568" translate="yes" xml:space="preserve">
          <source>In most cases, this means the attributes given in the input will be repeated in the output, but Git may also modify the credential description, for example by removing the &lt;code&gt;path&lt;/code&gt; attribute when the protocol is HTTP(s) and &lt;code&gt;credential.useHttpPath&lt;/code&gt; is false.</source>
          <target state="translated">В большинстве случаев это означает, что атрибуты, указанные во входных данных, будут повторяться в выходных данных, но Git может также изменить описание учетных данных, например, удалив атрибут &lt;code&gt;path&lt;/code&gt; когда протоколом является HTTP (s) и &lt;code&gt;credential.useHttpPath&lt;/code&gt; имеет значение false.</target>
        </trans-unit>
        <trans-unit id="c12479d09bff69f421dbf9e45fddc92269d1f574" translate="yes" xml:space="preserve">
          <source>In most cases, users should run &lt;em&gt;git gc&lt;/em&gt;, which calls &lt;em&gt;git prune&lt;/em&gt;. See the section &quot;NOTES&quot;, below.</source>
          <target state="translated">В большинстве случаев пользователям следует запустить &lt;em&gt;git gc&lt;/em&gt; , который вызывает &lt;em&gt;git prune&lt;/em&gt; . См. Раздел &amp;laquo;ПРИМЕЧАНИЯ&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="6d4e8e52070be526725731839d6ade7553803d5e" translate="yes" xml:space="preserve">
          <source>In most cases, users will not need to call &lt;code&gt;git prune&lt;/code&gt; directly, but should instead call &lt;code&gt;git gc&lt;/code&gt;, which handles pruning along with many other housekeeping tasks.</source>
          <target state="translated">В большинстве случаев пользователям не нужно вызывать &lt;code&gt;git prune&lt;/code&gt; напрямую, вместо этого следует вызывать &lt;code&gt;git gc&lt;/code&gt; , который выполняет обрезку вместе со многими другими служебными задачами.</target>
        </trans-unit>
        <trans-unit id="7de19f518cc5353753469bfb19c4e4f93734f02e" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees and some refs are local. One example is &lt;code&gt;HEAD&lt;/code&gt; which is different for each working tree. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1d2a97ebd3bb9e2d938b11b92fc4a8e0c826fa" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees, some refs are local. One example is HEAD is different for all working trees. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="translated">В нескольких рабочих деревьях некоторые ссылки могут быть разделены между всеми рабочими деревьями,некоторые ссылки являются локальными.Одним из примеров является HEAD,который отличается для всех рабочих деревьев.Этот раздел о правилах совместного использования и о том,как получить доступ к ссылкам одного рабочего дерева из другого.</target>
        </trans-unit>
        <trans-unit id="fef9e754382e4f5002bb7f83483631df5de227e1" translate="yes" xml:space="preserve">
          <source>In older Git versions it could be easily forgotten to commit new or modified files in a submodule, which silently leads to similar problems as not pushing the submodule changes. Starting with Git 1.7.0 both &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git diff&lt;/code&gt; in the superproject show submodules as modified when they contain new or modified files to protect against accidentally committing such a state. &lt;code&gt;git
diff&lt;/code&gt; will also add a &lt;code&gt;-dirty&lt;/code&gt; to the work tree side when generating patch output or used with the &lt;code&gt;--submodule&lt;/code&gt; option:</source>
          <target state="translated">В более старых версиях Git можно легко забыть о фиксации новых или измененных файлов в подмодуле, что незаметно приводит к таким же проблемам, как отказ от внесения изменений в подмодуль. Начиная с Git 1.7.0 и &lt;code&gt;git status&lt;/code&gt; , и &lt;code&gt;git diff&lt;/code&gt; в суперпроекте показывают подмодули как измененные, если они содержат новые или измененные файлы, для защиты от случайной фиксации такого состояния. &lt;code&gt;git diff&lt;/code&gt; также добавит &lt;code&gt;-dirty&lt;/code&gt; на сторону рабочего дерева при генерации вывода патча или использовании с параметром &lt;code&gt;--submodule&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cea51be0687534aeac695491ce11f4552163d8c9" translate="yes" xml:space="preserve">
          <source>In order to allow extensions that add extra data to the MIDX, we organize the body into &quot;chunks&quot; and provide a lookup table at the beginning of the body. The header includes certain length values, such as the number of packs, the number of base MIDX files, hash lengths and types.</source>
          <target state="translated">Для того,чтобы разрешить расширения,которые добавляют дополнительные данные в MIDX,мы организуем кузов в &quot;куски&quot; и предоставляем таблицу поиска в начале кузова.В заголовке указываются определенные значения длины,такие как количество пакетов,количество базовых MIDX-файлов,длины и типы хэшей.</target>
        </trans-unit>
        <trans-unit id="f6b8f2c2e89120a466dd40e221531b6adf7a10b9" translate="yes" xml:space="preserve">
          <source>In order to determine what URL to use to fetch from, the value of the configuration &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; is consulted and if there is not any such variable, the value on the &lt;code&gt;URL:&lt;/code&gt; line in &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">Чтобы определить, какой URL-адрес использовать для выборки, &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; значение конфигурации remote. &amp;lt;origin&amp;gt; .url, и, если такой переменной нет, значение в строке &lt;code&gt;URL:&lt;/code&gt; в &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; используется.</target>
        </trans-unit>
        <trans-unit id="1bb65c849d69cb9e41866b99d141938531c8bf39" translate="yes" xml:space="preserve">
          <source>In order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; are consulted, and if there aren&amp;rsquo;t any, &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is consulted and its &lt;code&gt;Pull:&lt;/code&gt; lines are used. In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:</source>
          <target state="translated">Чтобы определить, какие удаленные ветки следует извлекать (и при необходимости сохранять в ветвях удаленного отслеживания), когда команда запускается без каких-либо параметров refspec в командной строке, проверяются значения переменной конфигурации &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; , и если их нет, &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; и используются его строки &lt;code&gt;Pull:&lt;/code&gt; . В дополнение к форматам refspec, описанным в разделе OPTIONS, вы можете иметь подстановку refspec, которая выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="b571757e7fe93a92c37f6bdbb5b1d110de433e8f" translate="yes" xml:space="preserve">
          <source>In order to ensure a current tracking branch state, &lt;code&gt;update --remote&lt;/code&gt; fetches the submodule&amp;rsquo;s remote repository before calculating the SHA-1. If you don&amp;rsquo;t want to fetch, you should use &lt;code&gt;submodule update
--remote --no-fetch&lt;/code&gt;.</source>
          <target state="translated">Чтобы гарантировать текущее состояние ветви отслеживания, &lt;code&gt;update --remote&lt;/code&gt; извлекает удаленный репозиторий подмодуля перед вычислением SHA-1. Если вы не хотите получать, вы должны использовать &lt;code&gt;submodule update --remote --no-fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ecc869f1231e06aba76a745114504d0b9155917" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on &quot;worktreeConfig&quot; extension, e.g.:</source>
          <target state="translated">Для того чтобы иметь конфигурацию,специфичную для рабочих деревьев,можно включить расширение &quot;worktreeConfig&quot;,например:</target>
        </trans-unit>
        <trans-unit id="1e42ca6d9de6de9f8c6bfadac339f32432bf0913" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on the &lt;code&gt;worktreeConfig&lt;/code&gt; extension, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb76ce16c3a3c52ec0347fc95609ba6324ad6c16" translate="yes" xml:space="preserve">
          <source>In order to protect the privacy of objects that have been removed from history but may not yet have been pruned, &lt;code&gt;git-upload-archive&lt;/code&gt; avoids serving archives for commits and trees that are not reachable from the repository&amp;rsquo;s refs. However, because calculating object reachability is computationally expensive, &lt;code&gt;git-upload-archive&lt;/code&gt; implements a stricter but easier-to-check set of rules:</source>
          <target state="translated">Чтобы защитить конфиденциальность объектов, которые были удалены из истории, но, возможно, еще не были обрезаны, &lt;code&gt;git-upload-archive&lt;/code&gt; избегает обслуживания архивов для коммитов и деревьев, которые недоступны из ссылок репозитория. Однако, поскольку вычисление достижимости объекта требует больших вычислительных ресурсов, &lt;code&gt;git-upload-archive&lt;/code&gt; реализует более строгий, но более простой для проверки набор правил:</target>
        </trans-unit>
        <trans-unit id="17696fe6311cd47e2efc1108f911bdeb8c2c0989" translate="yes" xml:space="preserve">
          <source>In order to set &quot;assume unchanged&quot; bit, use &lt;code&gt;--assume-unchanged&lt;/code&gt; option. To unset, use &lt;code&gt;--no-assume-unchanged&lt;/code&gt;. To see which files have the &quot;assume unchanged&quot; bit set, use &lt;code&gt;git ls-files -v&lt;/code&gt; (see &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt;).</source>
          <target state="translated">Чтобы установить бит &amp;laquo;считать неизменным&amp;raquo;, используйте параметр &lt;code&gt;--assume-unchanged&lt;/code&gt; . Чтобы отключить, используйте &lt;code&gt;--no-assume-unchanged&lt;/code&gt; . Чтобы увидеть, в каких файлах установлен бит &amp;laquo;считать неизменным&amp;raquo;, используйте &lt;code&gt;git ls-files -v&lt;/code&gt; (см. &lt;a href=&quot;git-ls-files&quot;&gt;Git-ls-files [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="267b1e8e9ade7b3919e26586bb280b53787cfd98" translate="yes" xml:space="preserve">
          <source>In other messages Andreas says that they also use the &quot;best practices&quot; described above: small logical commits, topic branches, no evil merge,&amp;hellip;​ These practices all improve the bisectability of the commit graph, by making it easier and more useful to bisect.</source>
          <target state="translated">В других сообщениях Андреас говорит, что они также используют &amp;laquo;лучшие практики&amp;raquo;, описанные выше: небольшие логические коммиты, тематические ветки, отсутствие злого слияния,&amp;hellip; Все эти методы улучшают делимость графа коммитов пополам, делая его проще и полезнее. ,</target>
        </trans-unit>
        <trans-unit id="cbba08cd602a94910294469b1bfe69221cf43d34" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;--merge&lt;/code&gt; does something like a &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt;, but carries forward unmerged index entries.</source>
          <target state="translated">Другими словами, &lt;code&gt;--merge&lt;/code&gt; делает что-то вроде &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt; , но переносит не объединенные записи индекса.</target>
        </trans-unit>
        <trans-unit id="2c3347c08edbf67732cb77724b9990f6671bac50" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-files&lt;/code&gt; always shows us the difference between what is recorded in the index, and what is currently in the working tree. That&amp;rsquo;s very useful.</source>
          <target state="translated">Другими словами, &lt;code&gt;git diff-files&lt;/code&gt; всегда показывает нам разницу между тем, что записано в индексе, и тем, что в настоящее время находится в рабочем дереве. Это очень полезно.</target>
        </trans-unit>
        <trans-unit id="7466e77eb24cbec56937901c0950f635d6a29d08" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-index&lt;/code&gt; normally compares a tree against the working tree, but when given the &lt;code&gt;--cached&lt;/code&gt; flag, it is told to instead compare against just the index cache contents, and ignore the current working tree state entirely. Since we just wrote the index file to HEAD, doing &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; should thus return an empty set of differences, and that&amp;rsquo;s exactly what it does.</source>
          <target state="translated">Другими словами, &lt;code&gt;git diff-index&lt;/code&gt; обычно сравнивает дерево с рабочим деревом, но когда ему &lt;code&gt;--cached&lt;/code&gt; флаг --cached , ему предлагается вместо этого сравнивать только с содержимым индексного кеша и полностью игнорировать текущее рабочее состояние дерева. Поскольку мы только что записали индексный файл в HEAD, выполнение &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; должно вернуть пустой набор различий, и это именно то, что он делает.</target>
        </trans-unit>
        <trans-unit id="8c2ef787b7de3a9f3b5df9786c452fde9692465e" translate="yes" xml:space="preserve">
          <source>In other words, there is no need to worry about what exists only in the working tree. When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact. When they &lt;strong&gt;do&lt;/strong&gt; interfere, the merge does not even start (&lt;code&gt;git read-tree&lt;/code&gt; complains loudly and fails without modifying anything). In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again.</source>
          <target state="translated">Другими словами, не нужно беспокоиться о том, что существует только в рабочем дереве. Когда у вас есть локальные изменения в части проекта, которая не участвует в слиянии, ваши изменения не мешают слиянию и остаются неизменными. Когда они &lt;strong&gt;действительно&lt;/strong&gt; мешают, слияние , даже не запускается ( &lt;code&gt;git read-tree&lt;/code&gt; жалуется громко и не без изменения ничего). В таком случае вы можете просто продолжить делать то, что вы делали в середине, и когда ваше рабочее дерево будет готово (то есть вы закончили незавершенную работу), повторите попытку слияния.</target>
        </trans-unit>
        <trans-unit id="5a674f35b2eda0a90a7f397ea7dadc5a212b7275" translate="yes" xml:space="preserve">
          <source>In other words, while a &quot;tree&quot; represents a particular directory state of a working directory, a &quot;commit&quot; represents that state in time, and explains how we got there.</source>
          <target state="translated">Другими словами,в то время как &quot;дерево&quot; представляет определенное состояние каталога рабочего каталога,&quot;коммит&quot; представляет это состояние во времени и объясняет,как мы туда попали.</target>
        </trans-unit>
        <trans-unit id="857191c898a7fbefd37c145d86f76b0005dd57eb" translate="yes" xml:space="preserve">
          <source>In other words, you can easily validate a whole archive by just sending out a single email that tells the people the name (SHA-1 hash) of the top commit, and digitally sign that email using something like GPG/PGP.</source>
          <target state="translated">Другими словами,вы можете легко проверить весь архив,просто отправив одно письмо,в котором людям сообщается имя (SHA-1 хэш)верхнего коммита,и в цифровом виде подписать это письмо с помощью чего-нибудь вроде GPG/PGP.</target>
        </trans-unit>
        <trans-unit id="e52122aac7e01b0550d02d6bfc5c4fbaa85b48ac" translate="yes" xml:space="preserve">
          <source>In our example of only two files, we did not have unchanged files so only &lt;code&gt;example&lt;/code&gt; resulted in collapsing. But in real-life large projects, when only a small number of files change in one commit, this &lt;code&gt;collapsing&lt;/code&gt; tends to trivially merge most of the paths fairly quickly, leaving only a handful of real changes in non-zero stages.</source>
          <target state="translated">В нашем примере с двумя файлами у нас не было неизмененных файлов, поэтому только &lt;code&gt;example&lt;/code&gt; привел к сворачиванию. Но в реальных крупных проектах, когда за одну фиксацию изменяется только небольшое количество файлов, это &lt;code&gt;collapsing&lt;/code&gt; имеет тенденцию к тривиальному слиянию большинства путей довольно быстро, оставляя лишь несколько реальных изменений на ненулевых стадиях.</target>
        </trans-unit>
        <trans-unit id="a3569415a118c16e9c5d7e18e58096bbd8336f98" translate="yes" xml:space="preserve">
          <source>In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with the updated master and topic branch, as long as the recorded resolution is still applicable.</source>
          <target state="translated">В нашем примере,когда вы выполняете тестовое слияние,записывается ручное разрешение,и оно будет использовано повторно при фактическом слиянии позже с обновленной основной и тематической веткой,если записанное разрешение все еще применимо.</target>
        </trans-unit>
        <trans-unit id="8e5ca17ff33890ba6e129c741e431196f019fa29" translate="yes" xml:space="preserve">
          <source>In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the &lt;code&gt;--source&lt;/code&gt; tree are removed, to make them match &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; exactly. The default is no-overlay mode.</source>
          <target state="translated">В режиме наложения команда никогда не удаляет файлы при восстановлении. В режиме без наложения отслеживаемые файлы, которые не отображаются в дереве &lt;code&gt;--source&lt;/code&gt; , удаляются, чтобы они точно соответствовали &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; . По умолчанию используется режим без наложения.</target>
        </trans-unit>
        <trans-unit id="5b1c0d5c1dcebbb2369ea9f003ec30402ee8a395" translate="yes" xml:space="preserve">
          <source>In particular, let&amp;rsquo;s not even check in the two files into Git yet, we&amp;rsquo;ll start off by adding another line to &lt;code&gt;hello&lt;/code&gt; first:</source>
          <target state="translated">В частности, давайте пока даже не проверяем эти два файла в Git, мы начнем с добавления еще одной строки в &lt;code&gt;hello&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d0e454374a9a3ee3d6a441cd0674139a3f061022" translate="yes" xml:space="preserve">
          <source>In particular, the &lt;code&gt;refs&lt;/code&gt; subdirectory will contain two other subdirectories, named &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;tags&lt;/code&gt; respectively. They do exactly what their names imply: they contain references to any number of different &lt;code&gt;heads&lt;/code&gt; of development (aka &lt;code&gt;branches&lt;/code&gt;), and to any &lt;code&gt;tags&lt;/code&gt; that you have created to name specific versions in your repository.</source>
          <target state="translated">В частности, подкаталог &lt;code&gt;refs&lt;/code&gt; будет содержать два других подкаталога с именами &lt;code&gt;heads&lt;/code&gt; и &lt;code&gt;tags&lt;/code&gt; соответственно. Они делают в точности то, что подразумевают их имена: они содержат ссылки на любое количество различных &lt;code&gt;heads&lt;/code&gt; разработки (также называемых &lt;code&gt;branches&lt;/code&gt; ) и на любые &lt;code&gt;tags&lt;/code&gt; которые вы создали для именования конкретных версий в вашем репозитории.</target>
        </trans-unit>
        <trans-unit id="2037a0a7d55894c0e552cd3905604e14aef5f5cc" translate="yes" xml:space="preserve">
          <source>In practice, you can interleave and repeat steps 1 and 2 as many times as you want: in order to keep track of what you want committed at step 3, Git maintains a snapshot of the tree&amp;rsquo;s contents in a special staging area called &quot;the index.&quot;</source>
          <target state="translated">На практике вы можете чередовать и повторять шаги 1 и 2 столько раз, сколько захотите: чтобы отслеживать то, что вы хотите зафиксировать на шаге 3, Git поддерживает моментальный снимок содержимого дерева в специальной промежуточной области, называемой &amp;laquo;индексом&amp;raquo;. &amp;laquo;.</target>
        </trans-unit>
        <trans-unit id="f0e4ad3997791ffc68facd5c602055afb63229a5" translate="yes" xml:space="preserve">
          <source>In principle, a note is a regular Git blob, and any kind of (non-)format is accepted. You can binary-safely create notes from arbitrary files using &lt;code&gt;git hash-object&lt;/code&gt;:</source>
          <target state="translated">В принципе, заметка - это обычный Git blob, и допускается любой (не) формат. Вы можете безопасно создавать заметки из произвольных файлов с помощью &lt;code&gt;git hash-object&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4601fb728bee4aeccfe338414983070eaafe0d7b" translate="yes" xml:space="preserve">
          <source>In protocol v2 communication is command oriented. When first contacting a server a list of capabilities will advertised. Some of these capabilities will be commands which a client can request be executed. Once a command has completed, a client can reuse the connection and request that other commands be executed.</source>
          <target state="translated">В протоколе v2 коммуникация ориентирована на команды.При первом обращении к серверу будет объявлен список возможностей.Некоторые из этих возможностей будут представлять собой команды,которые клиент может запросить для выполнения.После выполнения команды клиент может повторно использовать соединение и запросить выполнение других команд.</target>
        </trans-unit>
        <trans-unit id="f1e89ddf0408f3e3f9aa71b3da7906ab579cf106" translate="yes" xml:space="preserve">
          <source>In protocol v2 these special packets will have the following semantics:</source>
          <target state="translated">В протоколе v2 эти специальные пакеты будут иметь следующую семантику:</target>
        </trans-unit>
        <trans-unit id="0b2a25ba5b09240510379a9523ee7fbbaeebe9c6" translate="yes" xml:space="preserve">
          <source>In some cases it is possible that the new head will &lt;strong&gt;not&lt;/strong&gt; actually be a descendant of the old head. For example, the developer may have realized she made a serious mistake, and decided to backtrack, resulting in a situation like:</source>
          <target state="translated">В некоторых случаях возможно, что новая голова &lt;strong&gt;не&lt;/strong&gt; будет потомком старой головы. Например, разработчик мог понять, что допустил серьезную ошибку, и решил отступить, что привело к такой ситуации:</target>
        </trans-unit>
        <trans-unit id="013d925394580efad8fc98d09cd78b65808be1a0" translate="yes" xml:space="preserve">
          <source>In some cases like for kernel development it can be worth developing complex scripts to be able to fully automate bisecting.</source>
          <target state="translated">В некоторых случаях,как и при разработке ядра,может быть стоит разработать сложные скрипты,чтобы иметь возможность полностью автоматизировать биссектрису.</target>
        </trans-unit>
        <trans-unit id="0a49ce3de43e8ee8d78f327f1f504c6a86228a99" translate="yes" xml:space="preserve">
          <source>In some situations the reflog may not be able to save you. For example, suppose you delete a branch, then realize you need the history it contained. The reflog is also deleted; however, if you have not yet pruned the repository, then you may still be able to find the lost commits in the dangling objects that &lt;code&gt;git fsck&lt;/code&gt; reports. See &lt;a href=&quot;#dangling-objects&quot;&gt;Dangling objects&lt;/a&gt; for the details.</source>
          <target state="translated">В некоторых ситуациях рефлог не может вас спасти. Например, предположим, что вы удаляете ветку, а затем понимаете, что вам нужна содержащаяся в ней история. Также удаляется рефлог; однако, если вы еще не удалили репозиторий, вы все равно сможете найти потерянные коммиты в висячих объектах, о которых сообщает &lt;code&gt;git fsck&lt;/code&gt; . См. &lt;a href=&quot;#dangling-objects&quot;&gt;Подробности в&lt;/a&gt; разделе &amp;laquo; Висячие предметы&amp;raquo; .</target>
        </trans-unit>
        <trans-unit id="4f2c24901ef5f6fa3a7b78ff609de06af9cfd2f7" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; would update only entries matched by &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; and sparse patterns in &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt;. This option ignores the sparse patterns and adds back any files in &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В режиме разреженной проверки &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; будет обновлять только записи, соответствующие &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; и разреженные шаблоны в &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; . Эта опция игнорирует разреженные шаблоны и добавляет обратно все файлы в &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91e2068ee07240a386da6a01584d7cb7bf48667f" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, by default is to only update entries matched by &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">В режиме разреженной проверки по умолчанию обновляются только записи, соответствующие &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; , и разреженные шаблоны в $ GIT_DIR / info / sparse-checkout. Эта опция игнорирует разреженные шаблоны и безоговорочно восстанавливает любые файлы в &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9805e95abc4cc7297991de78ec147328f379f9f9" translate="yes" xml:space="preserve">
          <source>In such a case, &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; would return the parent of B0 in the above picture, but B0^..D is &lt;strong&gt;not&lt;/strong&gt; the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1).</source>
          <target state="translated">В таком случае &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; вернет родительский элемент B0 на приведенном выше рисунке, но B0 ^ .. D - это &lt;strong&gt;не&lt;/strong&gt; диапазон коммитов, которые вы хотели бы воспроизвести поверх B (он включает B0, что не то, что вы написали; это фиксация, которую отвергла другая сторона, когда она переместила свой конец с B0 на B1).</target>
        </trans-unit>
        <trans-unit id="38c59b4cda1fb890b6373e0ee120752a69f46faf" translate="yes" xml:space="preserve">
          <source>In such a case, you can &quot;unwrap&quot; the tag yourself before feeding it to &lt;code&gt;git merge&lt;/code&gt;, or pass &lt;code&gt;--ff-only&lt;/code&gt; when you do not have any work on your own. e.g.</source>
          <target state="translated">В таком случае вы можете &amp;laquo;развернуть&amp;raquo; тег самостоятельно, прежде чем передать его в &lt;code&gt;git merge&lt;/code&gt; , или передать &lt;code&gt;--ff-only&lt;/code&gt; , если у вас нет собственной работы. например</target>
        </trans-unit>
        <trans-unit id="122c6a9f6232138a6047defa817d1eec04cb3f10" translate="yes" xml:space="preserve">
          <source>In such a case, you do not want to automatically follow the other person&amp;rsquo;s tags.</source>
          <target state="translated">В таком случае вы не хотите автоматически следить за тегами другого человека.</target>
        </trans-unit>
        <trans-unit id="14b066e7c220e701d278a048087bd2ff212888b8" translate="yes" xml:space="preserve">
          <source>In such cases it can be very confusing to use the terms &quot;good&quot; and &quot;bad&quot; to refer to &quot;the state before the change&quot; and &quot;the state after the change&quot;. So instead, you can use the terms &quot;old&quot; and &quot;new&quot;, respectively, in place of &quot;good&quot; and &quot;bad&quot;. (But note that you cannot mix &quot;good&quot; and &quot;bad&quot; with &quot;old&quot; and &quot;new&quot; in a single session.)</source>
          <target state="translated">В таких случаях использование терминов &quot;хороший&quot; и &quot;плохой&quot; для обозначения &quot;состояния до изменения&quot; и &quot;состояния после изменения&quot; может быть очень запутанным.Поэтому вместо &quot;хорошего&quot; и &quot;плохого&quot; можно использовать термины &quot;старое&quot; и &quot;новое&quot; соответственно.(Но обратите внимание,что вы не можете смешивать &quot;хорошее&quot; и &quot;плохое&quot; со &quot;старым&quot; и &quot;новым&quot; в одном сеансе).</target>
        </trans-unit>
        <trans-unit id="abac94a936763ce45a21b8291dbe11f8fcd73ae6" translate="yes" xml:space="preserve">
          <source>In such cases, git-cherry shows a concise summary of what has yet to be applied:</source>
          <target state="translated">В таких случаях гит-вишня показывает краткое резюме того,что еще предстоит применить:</target>
        </trans-unit>
        <trans-unit id="46cccce64f7cd9f50066dd3d9623630b5fee1925" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;git pull&lt;/code&gt; can do the fetch and merge in one go, as follows.</source>
          <target state="translated">В этом случае &lt;code&gt;git pull&lt;/code&gt; может выполнить выборку и слияние за один раз, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="52b267d7dd12ef4e2f7423310ff8cbe9ef5b3665" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream (unless &lt;code&gt;--reapply-cherry-picks&lt;/code&gt; is given). So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724c7d4dfedb54b8a53a948ec5bdabaee78995fb" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream. So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="translated">В этом случае исправить легко, потому что &lt;code&gt;git rebase&lt;/code&gt; знает, что нужно пропустить изменения, которые уже присутствуют в новом апстриме. Итак, если вы скажете (при условии, что вы по &lt;code&gt;topic&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2f5cdfecd5b61a82b453fde83701ee64b8d8237" translate="yes" xml:space="preserve">
          <source>In that case, you can still force Git to update to the new head, as described in the following section. However, note that in the situation above this may mean losing the commits labeled &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, unless you&amp;rsquo;ve already created a reference of your own pointing to them.</source>
          <target state="translated">В этом случае вы все равно можете принудительно обновить Git до нового заголовка, как описано в следующем разделе. Однако обратите внимание, что в приведенной выше ситуации это может означать потерю коммитов с метками &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , если вы уже не создали собственную ссылку, указывающую на них.</target>
        </trans-unit>
        <trans-unit id="23201c1eda40e4016771870c9d54dd5324857456" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;git push&lt;/code&gt; command above we specify the name of the remote branch to update (&lt;code&gt;master&lt;/code&gt;). If we leave that out, &lt;code&gt;git push&lt;/code&gt; tries to update any branches in the remote repository that have the same name as a branch in the local repository. So the last &lt;code&gt;push&lt;/code&gt; can be done with either of:</source>
          <target state="translated">В приведенной выше команде &lt;code&gt;git push&lt;/code&gt; мы указываем имя удаленной ветки для обновления ( &lt;code&gt;master&lt;/code&gt; ). Если мы оставим это без &lt;code&gt;git push&lt;/code&gt; , git push попытается обновить любые ветки в удаленном репозитории, которые имеют то же имя, что и ветка в локальном репозитории. Таким образом, последний &lt;code&gt;push&lt;/code&gt; может быть выполнен одним из следующих способов:</target>
        </trans-unit>
        <trans-unit id="090c003198124abd0a59f9db99cb23a0a9d08a0d" translate="yes" xml:space="preserve">
          <source>In the above config only the submodule &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are active, &lt;code&gt;bar&lt;/code&gt; due to (1) and &lt;code&gt;baz&lt;/code&gt; due to (3). &lt;code&gt;foo&lt;/code&gt; is inactive because (1) takes precedence over (3)</source>
          <target state="translated">В приведенной выше конфигурации активны только субмодуль &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; из-за (1) и &lt;code&gt;baz&lt;/code&gt; из-за (3). &lt;code&gt;foo&lt;/code&gt; неактивен, потому что (1) имеет приоритет над (3)</target>
        </trans-unit>
        <trans-unit id="f2615d435cf358760e53af78267e9744a2a4cd7e" translate="yes" xml:space="preserve">
          <source>In the above example output, the function signature was changed from both files (hence two &lt;code&gt;-&lt;/code&gt; removals from both file1 and file2, plus &lt;code&gt;++&lt;/code&gt; to mean one line that was added does not appear in either file1 or file2). Also eight other lines are the same from file1 but do not appear in file2 (hence prefixed with &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">В выходных данных приведенного выше примера подпись функции была изменена из обоих файлов (следовательно, два &lt;code&gt;-&lt;/code&gt; удаления из файла1 и файла2, плюс &lt;code&gt;++&lt;/code&gt; , что означает, что одна добавленная строка не отображается ни в файле1, ни в файле2). Также восемь других строк совпадают с файлом file1, но не отображаются в file2 (следовательно, имеют префикс &lt;code&gt;+&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="236d1518399c3b158b7b503f699f9dfd06244979" translate="yes" xml:space="preserve">
          <source>In the above example we have N = 8, so this will give:</source>
          <target state="translated">В приведенном выше примере мы имеем N=8,так что это даст:</target>
        </trans-unit>
        <trans-unit id="4faa5ab35bd05c089c7f00cb50d40bc6a34dd151" translate="yes" xml:space="preserve">
          <source>In the case where the input consists entirely of whitespace characters, no output will be produced.</source>
          <target state="translated">В случае,если ввод полностью состоит из пробельных символов,выводиться не будет.</target>
        </trans-unit>
        <trans-unit id="6722ed28b0a968c96593a6b207713cd0f24f7d3a" translate="yes" xml:space="preserve">
          <source>In the check-in codepath, the worktree file is first converted with &lt;code&gt;filter&lt;/code&gt; driver (if specified and corresponding driver defined), then the result is processed with &lt;code&gt;ident&lt;/code&gt; (if specified), and then finally with &lt;code&gt;text&lt;/code&gt; (again, if specified and applicable).</source>
          <target state="translated">В кодовом пути регистрации файл рабочего дерева сначала преобразуется с помощью драйвера &lt;code&gt;filter&lt;/code&gt; (если он указан и соответствующий драйвер определен), затем результат обрабатывается с помощью &lt;code&gt;ident&lt;/code&gt; (если указан), а затем, наконец, с помощью &lt;code&gt;text&lt;/code&gt; (снова, если указано и применимо) ,</target>
        </trans-unit>
        <trans-unit id="41a87794ee334f48f97053e2010dfe2b224b3e78" translate="yes" xml:space="preserve">
          <source>In the check-out codepath, the blob content is first converted with &lt;code&gt;text&lt;/code&gt;, and then &lt;code&gt;ident&lt;/code&gt; and fed to &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">В кодовом пути извлечения содержимое большого двоичного объекта сначала преобразуется в &lt;code&gt;text&lt;/code&gt; , а затем &lt;code&gt;ident&lt;/code&gt; и передается для &lt;code&gt;filter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="113fa915b38684bf235e931affc2401ec6de4a63" translate="yes" xml:space="preserve">
          <source>In the cone mode case, the &lt;code&gt;git sparse-checkout list&lt;/code&gt; subcommand will list the directories that define the recursive patterns. For the example sparse-checkout file above, the output is as follows:</source>
          <target state="translated">В случае режима конуса подкоманда &lt;code&gt;git sparse-checkout list&lt;/code&gt; перечислит каталоги, которые определяют рекурсивные шаблоны. Для приведенного выше примера файла разреженной проверки результат будет следующим:</target>
        </trans-unit>
        <trans-unit id="50d1a515997c60c54243bae252639aa03db105b6" translate="yes" xml:space="preserve">
          <source>In the default overlay mode, &lt;code&gt;git checkout&lt;/code&gt; never removes files from the index or the working tree. When specifying &lt;code&gt;--no-overlay&lt;/code&gt;, files that appear in the index and working tree, but not in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; are removed, to make them match &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; exactly.</source>
          <target state="translated">В режиме наложения по умолчанию &lt;code&gt;git checkout&lt;/code&gt; никогда не удаляет файлы из индекса или рабочего дерева. При указании &lt;code&gt;--no-overlay&lt;/code&gt; файлы, которые появляются в индексном и рабочем дереве, но не в &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; , удаляются, чтобы они точно соответствовали &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cdd96542ff31058533f7beb40eadd124991c8c5" translate="yes" xml:space="preserve">
          <source>In the early days, Git (in the tradition of UNIX) was a bunch of programs which were extremely simple, and which you used in scripts, piping the output of one into another. This turned out to be good for initial development, since it was easier to test new things. However, recently many of these parts have become builtins, and some of the core has been &quot;libified&quot;, i.e. put into libgit.a for performance, portability reasons, and to avoid code duplication.</source>
          <target state="translated">В ранние времена Git (в традиции UNIX)представлял собой кучу программ,которые были чрезвычайно просты,и которые вы использовали в скриптах,объединяя выходные данные друг в друга.Это оказалось хорошо для начальной разработки,так как было проще тестировать новые вещи.Однако в последнее время многие из этих частей превратились в сборки,а часть ядра была &quot;освобождена&quot;,т.е.помещена в libgit.a по соображениям производительности,переносимости и во избежание дублирования кода.</target>
        </trans-unit>
        <trans-unit id="5c0100c9df6abb7d7f1348c7fe307c535cc01a6e" translate="yes" xml:space="preserve">
          <source>In the examples, the following &lt;code&gt;.gitattributes&lt;/code&gt; file is used:</source>
          <target state="translated">В примерах используется следующий файл &lt;code&gt;.gitattributes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cc3fe53f7a76d1235b536b2f3e4aace1aeafd632" translate="yes" xml:space="preserve">
          <source>In the external editor window, read in the patch file and exit the editor normally.</source>
          <target state="translated">В окне внешнего редактора прочитайте в файле патча и выйдите из редактора в обычном режиме.</target>
        </trans-unit>
        <trans-unit id="8ef2e6de3f32f727ff12807f3683863dc57cb535" translate="yes" xml:space="preserve">
          <source>In the first form, it renames &amp;lt;source&amp;gt;, which must exist and be either a file, symlink or directory, to &amp;lt;destination&amp;gt;. In the second form, the last argument has to be an existing directory; the given sources will be moved into this directory.</source>
          <target state="translated">В первой форме он переименовывает &amp;lt;source&amp;gt;, который должен существовать и быть либо файлом, либо символической ссылкой, либо каталогом, в &amp;lt;destination&amp;gt;. Во второй форме последним аргументом должен быть существующий каталог; указанные источники будут перемещены в этот каталог.</target>
        </trans-unit>
        <trans-unit id="76aeefd352a6b656fb05dc49a2aa92d1acbe97ce" translate="yes" xml:space="preserve">
          <source>In the first three forms, copy entries from &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; to the index. In the last form, set the current branch head (&lt;code&gt;HEAD&lt;/code&gt;) to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, optionally modifying index and working tree to match. The &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;HEAD&lt;/code&gt; in all forms.</source>
          <target state="translated">В первых трех формах скопируйте записи из &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; в индекс. В последней форме установите для заголовка текущей ветки ( &lt;code&gt;HEAD&lt;/code&gt; ) значение &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; , при необходимости изменив индекс и рабочее дерево для соответствия. &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; по умолчанию для &lt;code&gt;HEAD&lt;/code&gt; во всех формах.</target>
        </trans-unit>
        <trans-unit id="ef10a113d8afc34781099a24e1e343890650a1e1" translate="yes" xml:space="preserve">
          <source>In the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a &quot;Report a bug&quot; button. The output of &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; may look like this:</source>
          <target state="translated">В следующем примере разработчик работает над тематической веткой, которая реорганизует способ определения кнопок, и над другой тематической веткой, которая использует этот рефакторинг для реализации кнопки &amp;laquo;Сообщить об ошибке&amp;raquo;. Вывод &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="e8d35f4a27576cd3ee599047c232398088d285ec" translate="yes" xml:space="preserve">
          <source>In the following, we list all defined capabilities and for each we list which commands a helper with that capability must provide.</source>
          <target state="translated">Далее мы перечисляем все определенные возможности,и для каждой из них мы указываем,какие команды должен предоставить помощник с этой возможностью.</target>
        </trans-unit>
        <trans-unit id="c56abbab61e08007b56db2739d2660b32ff3baf6" translate="yes" xml:space="preserve">
          <source>In the following, we say that commit X is &quot;reachable&quot; from commit Y if commit X is an ancestor of commit Y. Equivalently, you could say that Y is a descendant of X, or that there is a chain of parents leading from commit Y to commit X.</source>
          <target state="translated">Далее мы говорим,что коммит X &quot;достижим&quot; от коммита Y,если коммит X является предком коммита Y.Аналогично можно сказать,что Y является потомком X,или что существует цепочка родителей,ведущая от коммита Y к коммиту X.</target>
        </trans-unit>
        <trans-unit id="2ab0015fa4bf468aa51dfb7b06e67d10a59ee05a" translate="yes" xml:space="preserve">
          <source>In the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file &lt;code&gt;foo&lt;/code&gt; in this commit graph:</source>
          <target state="translated">В дальнейшем мы всегда будем ссылаться на один и тот же пример истории, чтобы проиллюстрировать различия между настройками упрощения. Мы предполагаем, что вы фильтруете файл &lt;code&gt;foo&lt;/code&gt; в этом графе фиксации:</target>
        </trans-unit>
        <trans-unit id="1a1825758e9c1b0f3cada9dea61b97f18e404ba1" translate="yes" xml:space="preserve">
          <source>In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to &lt;code&gt;branch2&lt;/code&gt; (i.e. &lt;code&gt;git switch -c branch2 start&lt;/code&gt;), but nobody is perfect.</source>
          <target state="translated">В идеальном мире вы могли бы понять, что предыдущая фиксация не относилась к новой теме, когда вы создали и переключились на &lt;code&gt;branch2&lt;/code&gt; (т.е. &lt;code&gt;git switch -c branch2 start&lt;/code&gt; ), но никто не идеален.</target>
        </trans-unit>
        <trans-unit id="d370a0f8ed20ae4cd4e933b9beff011b3187e6ad" translate="yes" xml:space="preserve">
          <source>In the long form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by an open parenthesis &lt;code&gt;(&lt;/code&gt;, a comma-separated list of zero or more &quot;magic words&quot;, and a close parentheses &lt;code&gt;)&lt;/code&gt;, and the remainder is the pattern to match against the path.</source>
          <target state="translated">В длинной форме за ведущим двоеточием &lt;code&gt;:&lt;/code&gt; следует открытая скобка &lt;code&gt;(&lt;/code&gt; разделенный запятыми список из нуля или более &amp;laquo;волшебных слов&amp;raquo; и закрывающих скобок &lt;code&gt;)&lt;/code&gt; , а оставшаяся часть представляет собой образец для сопоставления пути.</target>
        </trans-unit>
        <trans-unit id="ecbb466c633c8f376663d1974093b0b801e94fbc" translate="yes" xml:space="preserve">
          <source>In the main Thunderbird window, &lt;code&gt;before&lt;/code&gt; you open the compose window for the patch, use Tools&amp;rarr;about:config to set the following to the indicated values:</source>
          <target state="translated">В главном окне Thunderbird, &lt;code&gt;before&lt;/code&gt; чем открывать окно создания патча, используйте Инструменты &amp;rarr; about: config, чтобы установить следующие значения на указанные значения:</target>
        </trans-unit>
        <trans-unit id="3f70c7e45d5c392e715fb2023b23a65e5f20b82a" translate="yes" xml:space="preserve">
          <source>In the output from &lt;code&gt;git show-branch&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt; should have everything &lt;code&gt;ko/master&lt;/code&gt; has, and &lt;code&gt;next&lt;/code&gt; should have everything &lt;code&gt;ko/next&lt;/code&gt; has, etc.</source>
          <target state="translated">В выходе из &lt;code&gt;git show-branch&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; должен иметь все &lt;code&gt;ko/master&lt;/code&gt; имеет, а &lt;code&gt;next&lt;/code&gt; должен иметь все &lt;code&gt;ko/next&lt;/code&gt; есть и т.д.</target>
        </trans-unit>
        <trans-unit id="9fb474287214ed4886618f1399ff63bbd11f6810" translate="yes" xml:space="preserve">
          <source>In the pager (&lt;code&gt;less&lt;/code&gt;), just search for &quot;bundle&quot;, go a few lines back, and see that it is in commit 18449ab0. Now just copy this object name, and paste it into the command line</source>
          <target state="translated">В пейджере ( &lt;code&gt;less&lt;/code&gt; ) просто найдите &amp;laquo;bundle&amp;raquo;, вернитесь на несколько строк назад и увидите, что он находится в фиксации 18449ab0. Теперь просто скопируйте это имя объекта и вставьте его в командную строку.</target>
        </trans-unit>
        <trans-unit id="5fc7016d20b7cd82938bb283d4d8443cc61835c8" translate="yes" xml:space="preserve">
          <source>In the past, &lt;code&gt;.git/HEAD&lt;/code&gt; was a symbolic link pointing at &lt;code&gt;refs/heads/master&lt;/code&gt;. When we wanted to switch to another branch, we did &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt;, and when we wanted to find out which branch we are on, we did &lt;code&gt;readlink .git/HEAD&lt;/code&gt;. But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default.</source>
          <target state="translated">В прошлом &lt;code&gt;.git/HEAD&lt;/code&gt; был символической ссылкой, указывающей на &lt;code&gt;refs/heads/master&lt;/code&gt; . Когда мы хотели переключиться на другую ветку, мы сделали &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt; , а когда мы хотели узнать, в какой ветке мы находимся, мы &lt;code&gt;readlink .git/HEAD&lt;/code&gt; . Но символические ссылки не полностью переносимы, поэтому теперь они устарели, а символические ссылки (как описано выше) используются по умолчанию.</target>
        </trans-unit>
        <trans-unit id="8dfab80b468101639bf9d627830b7559e865891a" translate="yes" xml:space="preserve">
          <source>In the previous example, when updating an existing branch, &lt;code&gt;git fetch&lt;/code&gt; checks to make sure that the most recent commit on the remote branch is a descendant of the most recent commit on your copy of the branch before updating your copy of the branch to point at the new commit. Git calls this process a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;.</source>
          <target state="translated">В предыдущем примере при обновлении существующей ветки &lt;code&gt;git fetch&lt;/code&gt; проверяет, является ли последняя фиксация в удаленной ветке потомком самой последней фиксации в вашей копии ветки перед обновлением вашей копии ветки, чтобы она указывала на новый коммит. Git называет этот процесс &lt;a href=&quot;#fast-forwards&quot;&gt;перемоткой вперед&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39fc6243d8461e10163ad54b5cc61dfd9c9ca8f0" translate="yes" xml:space="preserve">
          <source>In the process of undoing a previous bad change, you may find it useful to check out an older version of a particular file using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;. The command</source>
          <target state="translated">В процессе отмены предыдущего плохого изменения вам может быть полезно проверить старую версию конкретного файла с помощью &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; . Команда</target>
        </trans-unit>
        <trans-unit id="ce5a30d6d89274fe8c4b93a655981ad3cb2875fa" translate="yes" xml:space="preserve">
          <source>In the process, it may discover conflicts. In that case it will stop and allow you to fix the conflicts; after fixing conflicts, use &lt;code&gt;git add&lt;/code&gt; to update the index with those contents, and then, instead of running &lt;code&gt;git commit&lt;/code&gt;, just run</source>
          <target state="translated">В процессе могут обнаруживаться конфликты. В этом случае он остановится и позволит вам исправить конфликты; после устранения конфликтов используйте &lt;code&gt;git add&lt;/code&gt; для обновления индекса этим содержимым, а затем вместо запуска &lt;code&gt;git commit&lt;/code&gt; просто запустите</target>
        </trans-unit>
        <trans-unit id="ecd16080120d9546efe5335b66c01332d8bc5340" translate="yes" xml:space="preserve">
          <source>In the second form, a list of objects (separated by linefeeds) is provided on stdin, and the SHA-1, type, and size of each object is printed on stdout. The output format can be overridden using the optional &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; argument. If either &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; was specified, the input is expected to list the object names followed by the path name, separated by a single whitespace, so that the appropriate drivers can be determined.</source>
          <target state="translated">Во второй форме список объектов (разделенных переводом строки) предоставляется на stdin, а SHA-1, тип и размер каждого объекта печатаются на stdout. Формат вывода можно переопределить с помощью необязательного аргумента &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; . Если &lt;code&gt;--textconv&lt;/code&gt; или &lt;code&gt;--filters&lt;/code&gt; , ожидается, что на входе будут перечислены имена объектов, за которыми следует имя пути, разделенные одним пробелом, чтобы можно было определить соответствующие драйверы.</target>
        </trans-unit>
        <trans-unit id="909b0b19015ead3714bd1690a7877da1cf97f4fa" translate="yes" xml:space="preserve">
          <source>In the short-format, the status of each path is shown as one of these forms</source>
          <target state="translated">В коротком формате,статус каждого пути отображается как одна из этих форм.</target>
        </trans-unit>
        <trans-unit id="abe3a521aeac4a8adcc3faf0711763fbfd40b505" translate="yes" xml:space="preserve">
          <source>In the simple form, each line in the file consists of the canonical real name of an author, whitespace, and an email address used in the commit (enclosed by &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;) to map to the name. For example:</source>
          <target state="translated">В простой форме каждая строка в файле состоит из канонического настоящего имени автора, пробела и адреса электронной почты, используемого в фиксации (заключенного в &lt;code&gt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&lt;/code&gt; ) для сопоставления с именем. Например:</target>
        </trans-unit>
        <trans-unit id="9cca233f9abbc26e27451b19e09d21eb7d1965d2" translate="yes" xml:space="preserve">
          <source>In the verbose listing that show the commit object name, show the shortest prefix that is at least &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; hexdigits long that uniquely refers the object. The default value is 7 and can be overridden by the &lt;code&gt;core.abbrev&lt;/code&gt; config option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eecf34aeaad64fff7ea38378d33edc5335145626" translate="yes" xml:space="preserve">
          <source>In these cases you can tell Git the encoding of a file in the working directory with the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If a file with this attribute is added to Git, then Git re-encodes the content from the specified encoding to UTF-8. Finally, Git stores the UTF-8 encoded content in its internal data structure (called &quot;the index&quot;). On checkout the content is re-encoded back to the specified encoding.</source>
          <target state="translated">В этих случаях вы можете указать Git кодировку файла в рабочем каталоге с помощью атрибута &lt;code&gt;working-tree-encoding&lt;/code&gt; . Если файл с этим атрибутом добавляется в Git, то Git перекодирует содержимое из указанной кодировки в UTF-8. Наконец, Git хранит содержимое в кодировке UTF-8 в своей внутренней структуре данных (называемой &amp;laquo;индексом&amp;raquo;). При оформлении заказа содержимое перекодируется обратно в указанную кодировку.</target>
        </trans-unit>
        <trans-unit id="5322604525a9aed1b9bf470c8d7df77aa5a14cc1" translate="yes" xml:space="preserve">
          <source>In these tables, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; are some different states of a file. For example, the first line of the first table means that if a file is in state &lt;code&gt;A&lt;/code&gt; in the working tree, in state &lt;code&gt;B&lt;/code&gt; in the index, in state &lt;code&gt;C&lt;/code&gt; in &lt;code&gt;HEAD&lt;/code&gt; and in state &lt;code&gt;D&lt;/code&gt; in the target, then &lt;code&gt;git reset --soft
target&lt;/code&gt; will leave the file in the working tree in state &lt;code&gt;A&lt;/code&gt; and in the index in state &lt;code&gt;B&lt;/code&gt;. It resets (i.e. moves) the &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch, if you are on one) to &lt;code&gt;target&lt;/code&gt; (which has the file in state &lt;code&gt;D&lt;/code&gt;).</source>
          <target state="translated">В этих таблицах &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;D&lt;/code&gt; - это различные состояния файла. Например, первая строка первой таблицы означает, что если файл находится в состоянии &lt;code&gt;A&lt;/code&gt; в рабочем дереве, в состоянии &lt;code&gt;B&lt;/code&gt; в индексе, в состоянии &lt;code&gt;C&lt;/code&gt; в &lt;code&gt;HEAD&lt;/code&gt; и в состоянии &lt;code&gt;D&lt;/code&gt; в цели, то &lt;code&gt;git reset --soft target&lt;/code&gt; будет оставить файл в рабочем дереве в государственном &lt;code&gt;A&lt;/code&gt; и в индексе в государственном &lt;code&gt;B&lt;/code&gt; . Он сбрасывает (т. Е. &lt;code&gt;HEAD&lt;/code&gt; ) ГОЛОВУ (т. Е. Кончик текущей ветки, если вы на ней) к &lt;code&gt;target&lt;/code&gt; (которая имеет файл в состоянии &lt;code&gt;D&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31d8ef3e97391069cf0655f41499162005f123c2" translate="yes" xml:space="preserve">
          <source>In these two shorthand notations, you can omit one end and let it default to HEAD. For example, &lt;code&gt;origin..&lt;/code&gt; is a shorthand for &lt;code&gt;origin..HEAD&lt;/code&gt; and asks &quot;What did I do since I forked from the origin branch?&quot; Similarly, &lt;code&gt;..origin&lt;/code&gt; is a shorthand for &lt;code&gt;HEAD..origin&lt;/code&gt; and asks &quot;What did the origin do since I forked from them?&quot; Note that &lt;code&gt;..&lt;/code&gt; would mean &lt;code&gt;HEAD..HEAD&lt;/code&gt; which is an empty range that is both reachable and unreachable from HEAD.</source>
          <target state="translated">В этих двух сокращенных обозначениях вы можете опустить один конец и оставить по умолчанию HEAD. Например, &lt;code&gt;origin..&lt;/code&gt; является сокращением от &lt;code&gt;origin..HEAD&lt;/code&gt; и спрашивает: &amp;laquo;Что я сделал, поскольку я разветвился из исходной ветки?&amp;raquo; Точно так же &lt;code&gt;..origin&lt;/code&gt; является сокращением от &lt;code&gt;HEAD..origin&lt;/code&gt; и спрашивает: &quot;Что сделал origin, после того как я его разветвил?&quot; Обратите внимание, что &lt;code&gt;..&lt;/code&gt; будет означать &lt;code&gt;HEAD..HEAD&lt;/code&gt; , который представляет собой пустой диапазон, который одновременно доступен и недоступен из HEAD.</target>
        </trans-unit>
        <trans-unit id="fda0649080e4ad73be213a95d0150567b39a9905" translate="yes" xml:space="preserve">
          <source>In this case Git will attempt to undo the old change while leaving intact any changes made since then. If more recent changes overlap with the changes to be reverted, then you will be asked to fix conflicts manually, just as in the case of &lt;a href=&quot;#resolving-a-merge&quot;&gt;resolving a merge&lt;/a&gt;.</source>
          <target state="translated">В этом случае Git попытается отменить старое изменение, оставив нетронутыми все изменения, сделанные с тех пор. Если более поздние изменения совпадают с изменениями, которые необходимо отменить, вам будет предложено исправить конфликты вручную, как и в случае &lt;a href=&quot;#resolving-a-merge&quot;&gt;разрешения слияния&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7e31e9f418486f831893dd264d133713a86e996" translate="yes" xml:space="preserve">
          <source>In this case if you are bisecting manually, what you can do is create a special branch that starts just before the BBC. The first commit in this branch should be the BBC with the BFC squashed into it. And the other commits in the branch should be the commits between BBC and BFC rebased on the first commit of the branch and then the commit after BFC also rebased on.</source>
          <target state="translated">В этом случае,если вы делаете биссектрису вручную,то что вы можете сделать,так это создать специальную ветку,которая начинается непосредственно перед BBC.Первый коммит в этой ветке должен быть BBC с раздавленным BFC.А другие коммиты в этой ветке должны быть коммитами между BBC и BFC,отскочившими от первого коммита в этой ветке,а затем коммитом после BFC,также отскочившим от него.</target>
        </trans-unit>
        <trans-unit id="717fbe628e5024a7ab31b6335fd291caf38b26b3" translate="yes" xml:space="preserve">
          <source>In this case this creates a totally new commit that is not related to anything else. Normally you do this only &lt;strong&gt;once&lt;/strong&gt; for a project ever, and all later commits will be parented on top of an earlier commit.</source>
          <target state="translated">В этом случае создается совершенно новый коммит, не связанный ни с чем. Обычно вы делаете это только &lt;strong&gt;один раз&lt;/strong&gt; для проекта, и все последующие коммиты будут созданы поверх более раннего коммита.</target>
        </trans-unit>
        <trans-unit id="8d602afd53dc502b1f39532e44b808e7e4006de6" translate="yes" xml:space="preserve">
          <source>In this case we say that the HEAD is &quot;detached&quot;.</source>
          <target state="translated">В данном случае мы говорим,что Голова &quot;отделена&quot;.</target>
        </trans-unit>
        <trans-unit id="84d70e62f46cda65cca1be0dfe61a185714e74d6" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;git fetch&lt;/code&gt; will fail, and print out a warning.</source>
          <target state="translated">В этом случае &lt;code&gt;git fetch&lt;/code&gt; завершится ошибкой и выведет предупреждение.</target>
        </trans-unit>
        <trans-unit id="ec2a36fb392a8671d4d7ad6f96adda81069f0cb4" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; command makes sure that no local change is lost as the result of this &quot;merge&quot;. Here are the &quot;carry forward&quot; rules, where &quot;I&quot; denotes the index, &quot;clean&quot; means that index and work tree coincide, and &quot;exists&quot;/&quot;nothing&quot; refer to the presence of a path in the specified commit:</source>
          <target state="translated">В этом случае команда &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; гарантирует, что никакие локальные изменения не будут потеряны в результате этого &amp;laquo;слияния&amp;raquo;. Вот правила &amp;laquo;переноса&amp;raquo;, где &amp;laquo;I&amp;raquo; обозначает индекс, &amp;laquo;чистый&amp;raquo; означает, что индекс и рабочее дерево совпадают, а &amp;laquo;существует&amp;raquo; / &amp;laquo;ничего&amp;raquo; относится к наличию пути в указанной фиксации:</target>
        </trans-unit>
        <trans-unit id="53de38de1c4937be3492ea2adad08075be0660b2" translate="yes" xml:space="preserve">
          <source>In this case, though, Git may not eventually be able to tell the first bad one between some first skipped commits and a later bad commit.</source>
          <target state="translated">В этом случае,однако,Git может оказаться не в состоянии отличить первый плохой коммит от первого пропущенного и последующего плохого.</target>
        </trans-unit>
        <trans-unit id="cc3568a850f36cf3d79c68cf0d9db0591ec5b81e" translate="yes" xml:space="preserve">
          <source>In this case, when &lt;code&gt;git bisect run&lt;/code&gt; finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by &lt;code&gt;git pack objects&lt;/code&gt;.</source>
          <target state="translated">В этом случае, когда &lt;code&gt;git bisect run&lt;/code&gt; завершается, bisect / bad будет относиться к фиксации, у которой есть хотя бы один родитель, чей график достижимости полностью проходим в том смысле, который требуется для &lt;code&gt;git pack objects&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="052b0bf9d817f9d1efdbc01c640d54d8fda7ad16" translate="yes" xml:space="preserve">
          <source>In this example preload_index() was executed by the &lt;code&gt;main&lt;/code&gt; thread and started the &lt;code&gt;preload&lt;/code&gt; region. Seven threads, named &lt;code&gt;th01:preload_thread&lt;/code&gt; through &lt;code&gt;th07:preload_thread&lt;/code&gt;, were started. Events from each thread are atomically appended to the shared target stream as they occur so they may appear in random order with respect other threads. Finally, the main thread waits for the threads to finish and leaves the region.</source>
          <target state="translated">В этом примере preload_index () была выполнена &lt;code&gt;main&lt;/code&gt; потоком и запустила область &lt;code&gt;preload&lt;/code&gt; . Было &lt;code&gt;th01:preload_thread&lt;/code&gt; семь потоков с именами от th01: preload_thread до &lt;code&gt;th07:preload_thread&lt;/code&gt; . События из каждого потока атомарно добавляются к общему целевому потоку по мере их возникновения, поэтому они могут появляться в случайном порядке относительно других потоков. Наконец, основной поток ожидает завершения потоков и покидает область.</target>
        </trans-unit>
        <trans-unit id="8e1c791b90ef2153c52f59ff823e2b7a9d806696" translate="yes" xml:space="preserve">
          <source>In this example, &quot;origin&quot; is called a remote repository, or &quot;remote&quot; for short. The branches of this repository are called &quot;remote branches&quot; from our point of view. The remote-tracking branches listed above were created based on the remote branches at clone time and will be updated by &lt;code&gt;git fetch&lt;/code&gt; (hence &lt;code&gt;git pull&lt;/code&gt;) and &lt;code&gt;git push&lt;/code&gt;. See &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;Updating a repository with git fetch&lt;/a&gt; for details.</source>
          <target state="translated">В этом примере &amp;laquo;origin&amp;raquo; называется удаленным репозиторием, или для краткости &amp;laquo;удаленным&amp;raquo;. Ветви этого репозитория с нашей точки зрения называются &amp;laquo;удаленными ветвями&amp;raquo;. Перечисленные выше ветки удаленного отслеживания были созданы на основе удаленных ветвей во время клонирования и будут обновляться с помощью &lt;code&gt;git fetch&lt;/code&gt; (следовательно, &lt;code&gt;git pull&lt;/code&gt; ) и &lt;code&gt;git push&lt;/code&gt; . Подробнее см. &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;Обновление репозитория с помощью git fetch&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="888891869abe63aa603e61303e6b4eda4f092540" translate="yes" xml:space="preserve">
          <source>In this example, scanning for untracked files ran from +0.012568 to +0.027149 (since the process started) and took 0.014581 seconds.</source>
          <target state="translated">В данном примере сканирование на наличие неотслеживаемых файлов выполнялось с +0.012568 до +0.027149 (с момента запуска процесса)и заняло 0.014581 секунды.</target>
        </trans-unit>
        <trans-unit id="06524b5c41784cbbacde83bd5045f27a411dfe64" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;ko&lt;/code&gt; shorthand points at the Git maintainer&amp;rsquo;s repository at kernel.org, and looks like this:</source>
          <target state="translated">В этом примере сокращение &lt;code&gt;ko&lt;/code&gt; указывает на репозиторий разработчика Git на kernel.org и выглядит так:</target>
        </trans-unit>
        <trans-unit id="f509bc56ecf3e22348180170f4391a6c5749bec9" translate="yes" xml:space="preserve">
          <source>In this example, the preload region took 0.009122 seconds. The 7 threads took between 0.006069 and 0.008947 seconds to work on their portion of the index. Thread &quot;th01&quot; worked on 508 items at offset 0. Thread &quot;th02&quot; worked on 508 items at offset 2032. Thread &quot;th04&quot; worked on 508 items at offset 508.</source>
          <target state="translated">В данном примере область предварительной загрузки заняла 0,009122 секунды.Работа 7 потоков над своей частью индекса заняла от 0.006069 до 0.008947 секунд.Нить &quot;th01&quot; работала на 508 элементах при смещении 0.Нить &quot;th02&quot; работала на 508 элементах при смещении 2032.Нитка &quot;th04&quot; работала над 508 позициями в офсете 508.</target>
        </trans-unit>
        <trans-unit id="24b2f8c33beed03671571687642648d3c34d3255" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host IP address supported. Repositories can still be accessed by hostname though, assuming they correspond to these IP addresses.</source>
          <target state="translated">В этом примере каталог &lt;code&gt;/pub&lt;/code&gt; корневого уровня будет содержать подкаталог для каждого поддерживаемого IP-адреса виртуального хоста. Однако доступ к репозиториям можно получить по имени хоста, если они соответствуют этим IP-адресам.</target>
        </trans-unit>
        <trans-unit id="1b3657f6aff85ab6f6a5a7f723164213b6e98109" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host name supported. Further, both hosts advertise repositories simply as &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt;. For pre-1.4.0 clients, a symlink from &lt;code&gt;/software&lt;/code&gt; into the appropriate default repository could be made as well.</source>
          <target state="translated">В этом примере каталог &lt;code&gt;/pub&lt;/code&gt; корневого уровня будет содержать подкаталог для каждого поддерживаемого имени виртуального хоста. Кроме того, оба хоста рекламируют репозитории просто как &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt; . Для клиентов до версии 1.4.0 также может быть сделана символическая ссылка из &lt;code&gt;/software&lt;/code&gt; в соответствующий репозиторий по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4f73381570064f6ad92295b54ae4d9111ba415e0" translate="yes" xml:space="preserve">
          <source>In this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well its diff.</source>
          <target state="translated">В данном примере есть 3 старых и 3 новых коммита,в которых разработчик удалил 3-й,добавил новый перед первыми двумя и изменил сообщение о коммите 2-го коммита,а также его отличие.</target>
        </trans-unit>
        <trans-unit id="5f85b35b8b6aae26894cfdfbe33e3822a8120573" translate="yes" xml:space="preserve">
          <source>In this example, we passed &quot;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&quot; as parameter to &quot;git bisect run&quot;. This means that at each step, the grep command we passed will be launched. And if it exits with code 0 (that means success) then git bisect will mark the current state as &quot;good&quot;. If it exits with code 1 (or any code between 1 and 127 included, except the special code 125), then the current state will be marked as &quot;bad&quot;.</source>
          <target state="translated">В этом примере мы передали &amp;laquo;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&amp;raquo; в качестве параметра для &amp;laquo;git bisect run&amp;raquo;. Это означает, что на каждом шаге будет запускаться переданная нами команда grep. И если он завершится с кодом 0 (что означает успех), то git bisect пометит текущее состояние как &amp;laquo;хорошее&amp;raquo;. Если он завершается с кодом 1 (или любым кодом от 1 до 127, кроме специального кода 125), то текущее состояние будет помечено как &amp;laquo;плохое&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="eee8776c9677f60ee6e97b993bed2ed1a91281bf" translate="yes" xml:space="preserve">
          <source>In this format, each line is output after a header; the header at the minimum has the first line which has:</source>
          <target state="translated">В этом формате каждая строка выводится после заголовка;в заголовке,как минимум,есть первая строка:</target>
        </trans-unit>
        <trans-unit id="991df4351922c60c45e086aff27d9273fe47de49" translate="yes" xml:space="preserve">
          <source>In this format, use 40 &quot;0&quot; to specify a zero value, and use the empty string to specify a missing value.</source>
          <target state="translated">В этом формате используйте 40 &quot;0&quot; для указания нулевого значения,а пустую строку-для указания недостающего значения.</target>
        </trans-unit>
        <trans-unit id="b4a37ae142e5dfb709dfd08bf26fc04d26f39f66" translate="yes" xml:space="preserve">
          <source>In this mode, specific configuration stays in the path pointed by &lt;code&gt;git
rev-parse --git-path config.worktree&lt;/code&gt;. You can add or update configuration in this file with &lt;code&gt;git config --worktree&lt;/code&gt;. Older Git versions will refuse to access repositories with this extension.</source>
          <target state="translated">В этом режиме конкретная конфигурация остается в пути, указанном &lt;code&gt;git rev-parse --git-path config.worktree&lt;/code&gt; . Вы можете добавить или обновить конфигурацию в этом файле с помощью &lt;code&gt;git config --worktree&lt;/code&gt; . Более старые версии Git откажутся от доступа к репозиториям с этим расширением.</target>
        </trans-unit>
        <trans-unit id="26cf2860c6712d39e5cbcd807f1756d9308dfdb3" translate="yes" xml:space="preserve">
          <source>In this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.&amp;lt;SHA-1&amp;gt;. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged.</source>
          <target state="translated">В этом режиме индекс разделяется на два файла: $ GIT_DIR / index и $ GIT_DIR / sharedindex. &amp;lt;SHA-1&amp;gt;. Изменения накапливаются в $ GIT_DIR / index, разделенном индексе, в то время как файл общего индекса содержит все записи индекса и остается неизменным.</target>
        </trans-unit>
        <trans-unit id="ffc9d6f506ae4dc0ef8e821987c60f58237503b7" translate="yes" xml:space="preserve">
          <source>In this mode, the server will not request authentication until the client actually starts the object negotiation phase of the push, rather than during the initial contact. For this reason, you must also enable the &lt;code&gt;http.receivepack&lt;/code&gt; config option in any repositories that should accept a push. The default behavior, if &lt;code&gt;http.receivepack&lt;/code&gt; is not set, is to reject any pushes by unauthenticated users; the initial request will therefore report &lt;code&gt;403 Forbidden&lt;/code&gt; to the client, without even giving an opportunity for authentication.</source>
          <target state="translated">В этом режиме сервер не будет запрашивать аутентификацию до тех пор, пока клиент не начнет фазу согласования объекта push, а не во время первоначального контакта. По этой причине вы также должны включить &lt;code&gt;http.receivepack&lt;/code&gt; конфигурации http.receivepack во всех репозиториях, которые должны принимать push. Поведение по умолчанию, если &lt;code&gt;http.receivepack&lt;/code&gt; не задано, заключается в отклонении любых запросов от неаутентифицированных пользователей; Таким образом, первоначальный запрос будет сообщать клиенту &lt;code&gt;403 Forbidden&lt;/code&gt; , даже не предоставляя возможности для аутентификации.</target>
        </trans-unit>
        <trans-unit id="427d8f8d92a71761648b972f0beb3c2aad83aaaa" translate="yes" xml:space="preserve">
          <source>In this more general usage, you provide &lt;code&gt;git bisect&lt;/code&gt; with a &quot;new&quot; commit that has some property and an &quot;old&quot; commit that doesn&amp;rsquo;t have that property. Each time &lt;code&gt;git bisect&lt;/code&gt; checks out a commit, you test if that commit has the property. If it does, mark the commit as &quot;new&quot;; otherwise, mark it as &quot;old&quot;. When the bisection is done, &lt;code&gt;git bisect&lt;/code&gt; will report which commit introduced the property.</source>
          <target state="translated">В этом более общем использовании вы предоставляете &lt;code&gt;git bisect&lt;/code&gt; &amp;laquo;новый&amp;raquo; коммит, у которого есть какое-то свойство, и &amp;laquo;старый&amp;raquo; коммит, у которого этого свойства нет. Каждый раз, когда &lt;code&gt;git bisect&lt;/code&gt; проверяет фиксацию, вы проверяете, есть ли у этой фиксации свойство. Если это так, отметьте фиксацию как &amp;laquo;новую&amp;raquo;; в противном случае отметьте его как &amp;laquo;старый&amp;raquo;. Когда деление пополам выполнено, &lt;code&gt;git bisect&lt;/code&gt; сообщит, какой коммит ввел свойство.</target>
        </trans-unit>
        <trans-unit id="c1e29a4968fef09e4ce2211e751712b57ac5f128" translate="yes" xml:space="preserve">
          <source>In this view, we see all of the important single-parent changes from &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt;. We also see the carefully-resolved merge &lt;code&gt;M&lt;/code&gt; and the not-so-carefully-resolved merge &lt;code&gt;R&lt;/code&gt;. This is usually enough information to determine why the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; &quot;disappeared&quot; from history in the default view. However, there are a few issues with this approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6da0601a9e7aee317ec7d6d594e01f938b779c4" translate="yes" xml:space="preserve">
          <source>In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. This option prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">В необычных сценариях вы не сможете создавать файлы больше определенного размера в вашей файловой системе, и этот параметр можно использовать, чтобы указать команде разделить выходной файл пакета на несколько независимых файлов пакетов, каждый из которых не превышает заданный размер. Размер может быть дополнен суффиксами &amp;laquo;k&amp;raquo;, &amp;laquo;m&amp;raquo; или &amp;laquo;g&amp;raquo;. Минимальный допустимый размер ограничен 1 МиБ. Эта опция предотвращает создание растрового индекса. По умолчанию не ограничено, если не установлена ​​переменная конфигурации &lt;code&gt;pack.packSizeLimit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e6119784d7cd9e9e9f521473e212223da8f242e" translate="yes" xml:space="preserve">
          <source>In versions of Git before 2.23.0 patterns containing \0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \0 and &lt;code&gt;--ignore-case&lt;/code&gt;.</source>
          <target state="translated">В версиях Git до 2.23.0 шаблоны, содержащие \ 0, будут считаться исправленными. Это никогда не было задокументировано, также были странные и недокументированные взаимодействия между, например, не-ASCII шаблонами, содержащими \ 0 и &lt;code&gt;--ignore-case&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5da95a93eebb0b267da3b6f30d0296fee9bbc09f" translate="yes" xml:space="preserve">
          <source>Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit or 64 bit systems, respectively), plus the length of the branch name (typically under 200 bytes), per branch. fast-import will easily handle as many as 10,000 inactive branches in under 2 MiB of memory.</source>
          <target state="translated">Неактивные ветки хранятся в структуре,которая использует 96 или 120 байт (32-битные или 64-битные системы,соответственно),плюс длина имени ветки (обычно менее 200 байт),на каждую ветку.Быстрый импорт легко справится с 10 000 неактивных ветвей в памяти менее 2 Мбайт.</target>
        </trans-unit>
        <trans-unit id="40bf5b4a4e7b04d6908a8f7645b8e99e811e42d8" translate="yes" xml:space="preserve">
          <source>Include Some Progress Messages</source>
          <target state="translated">Включить некоторые сообщения о достигнутом прогрессе</target>
        </trans-unit>
        <trans-unit id="d1a7a0c5683de418c5f98fc4beae70e15874a175" translate="yes" xml:space="preserve">
          <source>Include a line &amp;ldquo;log size &amp;lt;number&amp;gt;&amp;rdquo; in the output for each commit, where &amp;lt;number&amp;gt; is the length of that commit&amp;rsquo;s message in bytes. Intended to speed up tools that read log messages from &lt;code&gt;git log&lt;/code&gt; output by allowing them to allocate space in advance.</source>
          <target state="translated">Включите строку &amp;laquo;размер журнала &amp;lt;число&amp;gt;&amp;raquo; в вывод для каждой фиксации, где &amp;lt;число&amp;gt; - длина сообщения этого фиксации в байтах. Предназначен для ускорения работы инструментов, которые читают сообщения журнала из вывода &lt;code&gt;git log&lt;/code&gt; , позволяя им заранее выделять место.</target>
        </trans-unit>
        <trans-unit id="af14d11414c6ac75b39c95b283e5bcf0f4ccb002" translate="yes" xml:space="preserve">
          <source>Include additional statistics at the end of blame output.</source>
          <target state="translated">Включите дополнительную статистику в конце вывода вины.</target>
        </trans-unit>
        <trans-unit id="67b90ce59db96c9a579b89f0489d7d9769ae1702" translate="yes" xml:space="preserve">
          <source>Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that &quot;first introduced&quot; a change to a branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c5e0ca752d4a1deb14e562052c4b503ef081b0" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">Включите коммиты, доступные из &amp;lt;rev&amp;gt; (т.е. &amp;lt;rev&amp;gt; и его предков).</target>
        </trans-unit>
        <trans-unit id="9605f416b0921199291f14b56df68cc8fe57350a" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev2&amp;gt; but exclude those that are reachable from &amp;lt;rev1&amp;gt;. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Включите коммиты, доступные из &amp;lt;rev2&amp;gt;, но исключите те, которые доступны из &amp;lt;rev1&amp;gt;. Если &amp;lt;rev1&amp;gt; или &amp;lt;rev2&amp;gt; опущены, по умолчанию используется &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce2adffe692042c194b87264e9afec51300d7f42" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; but exclude those that are reachable from both. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Включите коммиты, которые доступны из &amp;lt;rev1&amp;gt; или &amp;lt;rev2&amp;gt;, но исключите те, которые доступны из обоих. Если &amp;lt;rev1&amp;gt; или &amp;lt;rev2&amp;gt; опущены, по умолчанию используется &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1236fce64f1fb93f2ef7dcc7912c2d79c1d22c1" translate="yes" xml:space="preserve">
          <source>Include cross-references to the glossary, where appropriate.</source>
          <target state="translated">При необходимости включите перекрестные ссылки на глоссарий.</target>
        </trans-unit>
        <trans-unit id="ac12c15729a8f56d7cafe2e8c1b0d7927d0e53f1" translate="yes" xml:space="preserve">
          <source>Include debugging information related to the movement of lines between files (see &lt;code&gt;-C&lt;/code&gt;) and lines moved within a file (see &lt;code&gt;-M&lt;/code&gt;). The first number listed is the score. This is the number of alphanumeric characters detected as having been moved between or within files. This must be above a certain threshold for &lt;code&gt;git blame&lt;/code&gt; to consider those lines of code to have been moved.</source>
          <target state="translated">Включите отладочную информацию, связанную с перемещением строк между файлами (см. &lt;code&gt;-C&lt;/code&gt; ) и строками, перемещаемыми внутри файла (см. &lt;code&gt;-M&lt;/code&gt; ). Первое число в списке - это счет. Это количество буквенно-цифровых символов, обнаруженных как перемещенные между файлами или внутри файлов. Это должно быть выше определенного порога, чтобы &lt;code&gt;git blame&lt;/code&gt; мог считать эти строки кода перемещенными.</target>
        </trans-unit>
        <trans-unit id="eac52c02432a2a159a563ec983012928139e33b8" translate="yes" xml:space="preserve">
          <source>Include objects in &lt;code&gt;.keep&lt;/code&gt; files when repacking. Note that we still do not delete &lt;code&gt;.keep&lt;/code&gt; packs after &lt;code&gt;pack-objects&lt;/code&gt; finishes. This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches. This option is generally only useful if you are writing bitmaps with &lt;code&gt;-b&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;, as it ensures that the bitmapped packfile has the necessary objects.</source>
          <target state="translated">Включите объекты в файлы &lt;code&gt;.keep&lt;/code&gt; при переупаковке. Обратите внимание, что мы по-прежнему не удаляем пакеты &lt;code&gt;.keep&lt;/code&gt; после завершения работы с &lt;code&gt;pack-objects&lt;/code&gt; . Это означает, что мы можем дублировать объекты, но это делает этот параметр безопасным для использования при одновременных отправках или выборках. Этот параметр обычно полезен только в том случае, если вы пишете растровые изображения с помощью &lt;code&gt;-b&lt;/code&gt; или &lt;code&gt;repack.writeBitmaps&lt;/code&gt; , поскольку он гарантирует, что растровый файл пакета содержит необходимые объекты.</target>
        </trans-unit>
        <trans-unit id="3b3acf7c7b624670bc98269d1db58c312d8f1ad9" translate="yes" xml:space="preserve">
          <source>Include patch text in the output.</source>
          <target state="translated">Включите текст патча в выходной сигнал.</target>
        </trans-unit>
        <trans-unit id="7f58d83c9ac95ca37a657dfc92f2d025971598c2" translate="yes" xml:space="preserve">
          <source>Include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status.</source>
          <target state="translated">Включите вывод &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; в шаблон сообщения фиксации при использовании редактора для подготовки сообщения фиксации. По умолчанию включено, но может использоваться для переопределения переменной конфигурации commit.status.</target>
        </trans-unit>
        <trans-unit id="798a42403927f2977bd316b8bb1bba46f3e2c944" translate="yes" xml:space="preserve">
          <source>Include unasked-for annotated tags if the object they reference was included in the resulting packfile. This can be useful to send new tags to native Git clients.</source>
          <target state="translated">Включать незапрошенные аннотированные теги,если объект,на который они ссылаются,был включен в результирующий файл пакета.Это может быть полезно для отправки новых тегов родным клиентам Git'а.</target>
        </trans-unit>
        <trans-unit id="c5f574d342fa2383147936f6ccc821ddf1edb5ef" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to add a new file or change the content of an existing file. This command has two different means of specifying the content of the file.</source>
          <target state="translated">Включен в команду &lt;code&gt;commit&lt;/code&gt; для добавления нового файла или изменения содержимого существующего файла. У этой команды есть два разных способа определения содержимого файла.</target>
        </trans-unit>
        <trans-unit id="8dfee16c07e63cf25f2958c656ce64f423b1c0b9" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove a file or recursively delete an entire directory from the branch. If the file or directory removal makes its parent directory empty, the parent directory will be automatically removed too. This cascades up the tree until the first non-empty directory or the root is reached.</source>
          <target state="translated">Включен в команду &lt;code&gt;commit&lt;/code&gt; для удаления файла или рекурсивного удаления всего каталога из ветки. Если при удалении файла или каталога его родительский каталог становится пустым, родительский каталог также будет автоматически удален. Это каскадирует дерево до тех пор, пока не будет достигнут первый непустой каталог или корень.</target>
        </trans-unit>
        <trans-unit id="87d365412b703101b1d281d9e93e3f278251dd0d" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove all files (and also all directories) from the branch. This command resets the internal branch structure to have no files in it, allowing the frontend to subsequently add all interesting files from scratch.</source>
          <target state="translated">Включен в команду &lt;code&gt;commit&lt;/code&gt; для удаления всех файлов (а также всех каталогов) из ветки. Эта команда сбрасывает внутреннюю структуру ветвей, чтобы в ней не было файлов, позволяя веб-интерфейсу впоследствии добавлять все интересные файлы с нуля.</target>
        </trans-unit>
        <trans-unit id="28dccd9788a09aa2f373fa8c25c3b39e9406a080" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt;&lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; command to add a new note annotating a &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; or change this annotation contents. Internally it is similar to filemodify 100644 on &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; path (maybe split into subdirectories). It&amp;rsquo;s not advised to use any other commands to write to the &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; tree except &lt;code&gt;filedeleteall&lt;/code&gt; to delete all existing notes in this tree. This command has two different means of specifying the content of the note.</source>
          <target state="translated">Включен в команду &lt;code&gt;commit&lt;/code&gt; &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; для добавления новой заметки, аннотирующей &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , или для изменения содержимого этой аннотации. Внутренне это похоже на filemodify 100644 на пути &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; (может быть разделен на подкаталоги). Не рекомендуется использовать какие-либо другие команды для записи в дерево &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; , кроме &lt;code&gt;filedeleteall&lt;/code&gt; , чтобы удалить все существующие заметки в этом дереве. У этой команды есть два разных средства для определения содержания заметки.</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="de153f024523e4c2c467ece94c841922a681ecff" translate="yes" xml:space="preserve">
          <source>Includes one additional ancestor commit. The additional ancestry link does not change the way the tree state is built at this commit. If the &lt;code&gt;from&lt;/code&gt; command is omitted when creating a new branch, the first &lt;code&gt;merge&lt;/code&gt; commit will be the first ancestor of the current commit, and the branch will start out with no files. An unlimited number of &lt;code&gt;merge&lt;/code&gt; commands per commit are permitted by fast-import, thereby establishing an n-way merge.</source>
          <target state="translated">Включает одну дополнительную фиксацию предка. Дополнительная ссылка на предков не меняет способ построения состояния дерева при этой фиксации. Если команда &lt;code&gt;from&lt;/code&gt; опущена при создании новой ветки, первая фиксация &lt;code&gt;merge&lt;/code&gt; будет первым предком текущей фиксации, а ветвь начнется без файлов. Неограниченное количество команд &lt;code&gt;merge&lt;/code&gt; на одну фиксацию разрешено с помощью быстрого импорта, тем самым устанавливая n-стороннее слияние.</target>
        </trans-unit>
        <trans-unit id="8623cf320c015aba351966293c038ddef6f53905" translate="yes" xml:space="preserve">
          <source>Incompatible options</source>
          <target state="translated">Несовместимые опции</target>
        </trans-unit>
        <trans-unit id="9020a39adcad5a9de717e37976fa2cef184a1df6" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch. In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">Включает изменения из удаленного репозитория в текущую ветку. В режиме по умолчанию &lt;code&gt;git pull&lt;/code&gt; является сокращением для &lt;code&gt;git fetch&lt;/code&gt; , за которым следует &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d61077e89adde5af7a04457989a77b3c48490ae" translate="yes" xml:space="preserve">
          <source>Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by &lt;code&gt;git pull&lt;/code&gt; to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.</source>
          <target state="translated">Включает изменения из названных коммитов (с тех пор, как их история расходится с текущей веткой) в текущую ветку. Эта команда используется &lt;code&gt;git pull&lt;/code&gt; для включения изменений из другого репозитория и может использоваться вручную для объединения изменений из одной ветки в другую.</target>
        </trans-unit>
        <trans-unit id="709702f7f984cb3913cdb163bc5d2fe003c81b05" translate="yes" xml:space="preserve">
          <source>Incremental output</source>
          <target state="translated">Инкрементальный выход</target>
        </trans-unit>
        <trans-unit id="571937052d91a812bc84d435a3200a79bb1a0ee1" translate="yes" xml:space="preserve">
          <source>Indeed untestable commits are often untestable because a breakage was introduced at one time, and that breakage was fixed only after many other commits were introduced.</source>
          <target state="translated">Действительно,неопровержимые коммиты часто бывают неопровержимыми,так как поломка была введена в одно время,и эта поломка была исправлена только после того,как были введены многие другие коммиты.</target>
        </trans-unit>
        <trans-unit id="78699f384a94184571a61ab6b2f36f5cdf341b61" translate="yes" xml:space="preserve">
          <source>Indicate that only the objects wanted need to be fetched, not their dependents.</source>
          <target state="translated">Укажите,что нужны только те объекты,которые вы хотите получить,а не их иждивенцы.</target>
        </trans-unit>
        <trans-unit id="d063c49b2950871e5e846c69f89ed3fa8315be66" translate="yes" xml:space="preserve">
          <source>Indicate that these objects are being fetched from a promisor.</source>
          <target state="translated">Укажите,что эти объекты извлекаются из промоутера.</target>
        </trans-unit>
        <trans-unit id="d4b8f31320c23f43d173d656edb4ca6c63551ac5" translate="yes" xml:space="preserve">
          <source>Indicates a blob object name.</source>
          <target state="translated">Указывает имя объекта-объекта-объекта-объекта.</target>
        </trans-unit>
        <trans-unit id="6d441ed12cf0b86c55591d731de178963fe6c1ee" translate="yes" xml:space="preserve">
          <source>Indicates a commit object name.</source>
          <target state="translated">Обозначает имя объекта коммита.</target>
        </trans-unit>
        <trans-unit id="e89d58f77c5643f4921d84ac3c1216b6dc569e02" translate="yes" xml:space="preserve">
          <source>Indicates a commit or tag object name. A command that takes a &amp;lt;commit-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;commit&amp;gt; object but automatically dereferences &amp;lt;tag&amp;gt; objects that point at a &amp;lt;commit&amp;gt;.</source>
          <target state="translated">Указывает имя объекта фиксации или тега. Команда, которая принимает аргумент &amp;lt;commit-ish&amp;gt;, в конечном итоге хочет работать с объектом &amp;lt;commit&amp;gt;, но автоматически разыменовывает объекты &amp;lt;tag&amp;gt;, которые указывают на &amp;lt;commit&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="31963740af1f01e0807009b4b0a81e30ade64f1a" translate="yes" xml:space="preserve">
          <source>Indicates a filename - almost always relative to the root of the tree structure &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; describes.</source>
          <target state="translated">Указывает имя файла - почти всегда относительно корня древовидной структуры, &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; описывает GIT_INDEX_FILE .</target>
        </trans-unit>
        <trans-unit id="c59be5c9a5ab736a07e28f031fa629ea1cac80d9" translate="yes" xml:space="preserve">
          <source>Indicates a tree object name.</source>
          <target state="translated">Указывает имя объекта дерева.</target>
        </trans-unit>
        <trans-unit id="0236f6573fabb077368d656582f35373ba9e33e6" translate="yes" xml:space="preserve">
          <source>Indicates a tree, commit or tag object name. A command that takes a &amp;lt;tree-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;tree&amp;gt; object but automatically dereferences &amp;lt;commit&amp;gt; and &amp;lt;tag&amp;gt; objects that point at a &amp;lt;tree&amp;gt;.</source>
          <target state="translated">Указывает имя объекта дерева, фиксации или тега. Команда, которая принимает аргумент &amp;lt;tree-ish&amp;gt;, в конечном итоге хочет работать с объектом &amp;lt;tree&amp;gt;, но автоматически разыменовывает объекты &amp;lt;commit&amp;gt; и &amp;lt;tag&amp;gt;, которые указывают на &amp;lt;tree&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="73ecb0013f5389f15738299d7b0ca5b5c29b261f" translate="yes" xml:space="preserve">
          <source>Indicates that an object type is required. Currently one of: &lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, or &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">Указывает, что требуется тип объекта. В настоящее время одно из: &lt;code&gt;blob&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;commit&lt;/code&gt; или &lt;code&gt;tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db4dbaff6f210d92fcd8a0947f8ffe2ad6166cf6" translate="yes" xml:space="preserve">
          <source>Indicates the object name for any type of object.</source>
          <target state="translated">Указывает имя объекта для любого типа объекта.</target>
        </trans-unit>
        <trans-unit id="c66f56b69efd11f38dd2949f22030f51d42bccb8" translate="yes" xml:space="preserve">
          <source>Individual developer (participant)</source>
          <target state="translated">Индивидуальный разработчик (участник)</target>
        </trans-unit>
        <trans-unit id="dc704b04bf6fc4b099b66d2f7d86d56e0d061d7a" translate="yes" xml:space="preserve">
          <source>Individual developer (standalone)</source>
          <target state="translated">Индивидуальный разработчик (автономный)</target>
        </trans-unit>
        <trans-unit id="a964b0aa320ab2176eba7cb0319b97ea34b340ac" translate="yes" xml:space="preserve">
          <source>Individually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.</source>
          <target state="translated">Индивидуально проигрывайте все отложенные коммиты вместо того,чтобы быстро переадресовывать их на те,которые остались неизменными.Это гарантирует,что вся история ветви rebased будет состоять из новых коммитов.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="9bceb94c72e397fee5b7ad78b8c9312ee6319e43" translate="yes" xml:space="preserve">
          <source>Information about what is to be pushed is provided on the hook&amp;rsquo;s standard input with lines of the form:</source>
          <target state="translated">Информация о том, что должно быть отправлено, предоставляется на стандартном вводе ловушки со строками формы:</target>
        </trans-unit>
        <trans-unit id="43d35f7b76c469225469fd7a04662a08053d1e63" translate="yes" xml:space="preserve">
          <source>Initial client request</source>
          <target state="translated">Первоначальный запрос клиента</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="1b499097655f7a7af4711e162d7e54be3deca803" translate="yes" xml:space="preserve">
          <source>Initialization happens in &lt;code&gt;main()&lt;/code&gt;. Behind the scenes, an &lt;code&gt;atexit&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt; handler are registered.</source>
          <target state="translated">Инициализация происходит в &lt;code&gt;main()&lt;/code&gt; . За кадром регистрируются &lt;code&gt;atexit&lt;/code&gt; и обработчик &lt;code&gt;signal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ae1b6d002181530c62e52f42bb8d5d197750e5d" translate="yes" xml:space="preserve">
          <source>Initialize Git config values so any scheduled maintenance will start running on this repository. This adds the repository to the &lt;code&gt;maintenance.repo&lt;/code&gt; config variable in the current user&amp;rsquo;s global config and enables some recommended configuration values for &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt;. The tasks that are enabled are safe for running in the background without disrupting foreground processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e32f1c6a8cf663f45361425590d312db136ea3" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout</source>
          <target state="translated">Инициализировать и модифицировать разреженную проверку</target>
        </trans-unit>
        <trans-unit id="5be83bd5256f93987e394207f3c5233baf2d713e" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout configuration, which reduces the checkout to a set of paths given by a list of patterns.</source>
          <target state="translated">Инициализируйте и модифицируйте конфигурацию разреженной проверки,которая сводит проверку к набору путей,заданных списком деталей.</target>
        </trans-unit>
        <trans-unit id="825b58a6f65001fb659dd3ff519bf4df985a29aa" translate="yes" xml:space="preserve">
          <source>Initialize the sparse-checkout file so the working directory starts with only the files in the root of the repository. The sparse-checkout file can be modified to grow the working directory as needed.</source>
          <target state="translated">Инициализируйте разреженный файл проверки так,чтобы рабочий каталог начинался только с файлов в корневом каталоге репозитория.Файл разреженной проверки может быть модифицирован для увеличения рабочего каталога по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="9e0eca47ea83eb468f0ac7fe2e029fd23bbe773e" translate="yes" xml:space="preserve">
          <source>Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting &lt;code&gt;submodule.$name.url&lt;/code&gt; in .git/config. It uses the same setting from &lt;code&gt;.gitmodules&lt;/code&gt; as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream.</source>
          <target state="translated">Инициализируйте подмодули, записанные в индексе (которые были добавлены и зафиксированы где-то еще), установив &lt;code&gt;submodule.$name.url&lt;/code&gt; в .git / config. Он использует те же настройки из &lt;code&gt;.gitmodules&lt;/code&gt; в качестве шаблона. Если URL-адрес относительный, он будет разрешен с использованием удаленного по умолчанию. Если удаленного по умолчанию нет, текущий репозиторий будет считаться вышестоящим.</target>
        </trans-unit>
        <trans-unit id="52f8f7589ec2fc901a83216cac5106872728a87d" translate="yes" xml:space="preserve">
          <source>Initialize, update or inspect submodules</source>
          <target state="translated">Инициализировать,обновлять или инспектировать субмодули</target>
        </trans-unit>
        <trans-unit id="0d880d50dc463cd4220f01bcf54c48c1f2d57098" translate="yes" xml:space="preserve">
          <source>Initializes an empty Git repository with additional metadata directories for &lt;code&gt;git svn&lt;/code&gt;. The Subversion URL may be specified as a command-line argument, or as full URL arguments to -T/-t/-b. Optionally, the target directory to operate on can be specified as a second argument. Normally this command initializes the current directory.</source>
          <target state="translated">Инициализирует пустой репозиторий Git с дополнительными каталогами метаданных для &lt;code&gt;git svn&lt;/code&gt; . URL Subversion может быть указан как аргумент командной строки или как аргументы полного URL-адреса для -T / -t / -b. При желании целевой каталог для работы может быть указан в качестве второго аргумента. Обычно эта команда инициализирует текущий каталог.</target>
        </trans-unit>
        <trans-unit id="01c2c8357a87e8a6148f1dd9a9c884aae5e4de53" translate="yes" xml:space="preserve">
          <source>Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.</source>
          <target state="translated">Изначально игнорируйте любые пробелы в определении перемещения,затем группируйте блоки перемещенного кода только в блок,если изменение пробела на строку одинаково.Это несовместимо с другими режимами.</target>
        </trans-unit>
        <trans-unit id="229b7991e581f774e065f13c78dfa8719c8c393f" translate="yes" xml:space="preserve">
          <source>Inline data format</source>
          <target state="translated">Формат данных Inline</target>
        </trans-unit>
        <trans-unit id="7c7935726f449ea7185a4fe42a9ddf2d1c53a2e4" translate="yes" xml:space="preserve">
          <source>Input Format</source>
          <target state="translated">Формат ввода</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">Входной формат</target>
        </trans-unit>
        <trans-unit id="789cc08a97020bab893e17ca6133192d1f9f1dac" translate="yes" xml:space="preserve">
          <source>Input is of the &quot;mboxrd&quot; format and &quot;^&amp;gt;+From &quot; line escaping is reversed.</source>
          <target state="translated">Входные данные имеют формат &amp;laquo;mboxrd&amp;raquo;, а экранирование строки &amp;laquo;^&amp;gt; + From&amp;raquo; перевернуто.</target>
        </trans-unit>
        <trans-unit id="26242e7bd97bd8eebf44f9f25f143aed3a9bdc4d" translate="yes" xml:space="preserve">
          <source>Input/output format</source>
          <target state="translated">формат ввода/вывода</target>
        </trans-unit>
        <trans-unit id="4038e1c7ebc07b210c228498bd5816f54233b768" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;progress&lt;/code&gt; statements every &amp;lt;n&amp;gt; objects, to be shown by &lt;code&gt;git fast-import&lt;/code&gt; during import.</source>
          <target state="translated">Вставляйте операторы &lt;code&gt;progress&lt;/code&gt; каждые &amp;lt;n&amp;gt; объекты, которые будут отображаться с помощью &lt;code&gt;git fast-import&lt;/code&gt; во время импорта.</target>
        </trans-unit>
        <trans-unit id="39c559793b49987eea00aba844e216707b6e7dcc" translate="yes" xml:space="preserve">
          <source>Insert custom links to the action bar of all project pages. This allows you to link to third-party scripts integrating into gitweb.</source>
          <target state="translated">Вставьте пользовательские ссылки на панель действий всех страниц проекта.Это позволит вам ссылаться на сторонние скрипты,интегрирующиеся в gitweb.</target>
        </trans-unit>
        <trans-unit id="ce8fd02283c353dc3cacd2d3e6c1eab64a1913a3" translate="yes" xml:space="preserve">
          <source>Inside double quotes, double quote &lt;code&gt;&quot;&lt;/code&gt; and backslash &lt;code&gt;\&lt;/code&gt; characters must be escaped: use &lt;code&gt;\&quot;&lt;/code&gt; for &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; for &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">Внутри двойных кавычек, двойных кавычек &lt;code&gt;&quot;&lt;/code&gt; и обратной косой черты &lt;code&gt;\&lt;/code&gt; символы должны быть экранированы: использование &lt;code&gt;\&quot;&lt;/code&gt; для &lt;code&gt;&quot;&lt;/code&gt; и &lt;code&gt;\\&lt;/code&gt; для &lt;code&gt;\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab67c68674bb4a9f1f690fac98c95aa9c2e1e750" translate="yes" xml:space="preserve">
          <source>Inspecting changes</source>
          <target state="translated">Проверка изменений</target>
        </trans-unit>
        <trans-unit id="ecf21e44dd8609734c0bc387cabc376ab485d9f8" translate="yes" xml:space="preserve">
          <source>Inspection and Comparison</source>
          <target state="translated">Проверка и сравнение</target>
        </trans-unit>
        <trans-unit id="e0c3f2780ee983978068137722cf2d423843d21f" translate="yes" xml:space="preserve">
          <source>Inspects, updates and manages submodules.</source>
          <target state="translated">Проверяет,обновляет и управляет субмодулями.</target>
        </trans-unit>
        <trans-unit id="d9fb6eb12bbc11fdad6f18ee5bfa79361ddad72b" translate="yes" xml:space="preserve">
          <source>Install the Toggle Word Wrap add-on that is available from &lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt; It adds a menu entry &quot;Enable Word Wrap&quot; in the composer&amp;rsquo;s &quot;Options&quot; menu that you can tick off. Now you can compose the message as you otherwise do (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), but you have to insert line breaks manually in any text that you type.</source>
          <target state="translated">Установите надстройку Toggle Word Wrap, доступную по &lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;адресу https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/.&lt;/a&gt; Он добавляет пункт меню &amp;laquo;Включить перенос слов&amp;raquo; в меню &amp;laquo;Параметры&amp;raquo; композитора, который можно поставить галочку. Теперь вы можете составить сообщение, как и раньше (вырезать + вставить, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; и т. Д.), Но вам придется вручную вставлять разрывы строк в любой набираемый текст.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="7fad939655efbad1612ce7f4867922684d56913b" translate="yes" xml:space="preserve">
          <source>Instantly browse your working repository in gitweb</source>
          <target state="translated">Мгновенный просмотр вашего рабочего репозитория в gitweb</target>
        </trans-unit>
        <trans-unit id="53c902fb07156c6117155b6a0b0738c7ca12a6bf" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;git bisect visualize&lt;/code&gt; and then &lt;code&gt;git reset --hard
fb47ddb2db&lt;/code&gt;, you might just want to tell Git that you want to skip the current commit:</source>
          <target state="translated">Вместо &lt;code&gt;git bisect visualize&lt;/code&gt; , а затем &lt;code&gt;git reset --hard fb47ddb2db&lt;/code&gt; , вы можете просто сказать Git, что хотите пропустить текущий коммит:</target>
        </trans-unit>
        <trans-unit id="483617d942bddc8b6c044cd054e06089960e1981" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; expects lines on stdin in the format</source>
          <target state="translated">Вместо идентификатора фиксации в командной строке (чего в данном случае не ожидается) &lt;code&gt;git http-fetch&lt;/code&gt; ожидает строки на стандартном вводе в формате</target>
        </trans-unit>
        <trans-unit id="78b5184ca479cbe7999ac4fee6c0be2a7fd5b77a" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files. The hash is used to determine the name of the temporary file and is arbitrary. The output of index-pack is printed to stdout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="978fdd37a8d1d967862cc9e916d011571d6998cf" translate="yes" xml:space="preserve">
          <source>Instead of an absolute timestamp relative timestamps work as well, e.g. 2.weeks.ago is valid to address anything older than 2 weeks.</source>
          <target state="translated">Вместо абсолютных временных меток работает также относительная временная метка,например,2 недели назад,чтобы обратиться к чему-нибудь старше 2 недель.</target>
        </trans-unit>
        <trans-unit id="ad6345e758058b67dc8e001b3a11fe48b9b5f52b" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames and mode changes. Turns off &quot;apply&quot;.</source>
          <target state="translated">Вместо применения патча выводите сжатое обобщение информации,полученной из расширенных заголовков git'а,таких как творения,переименования и изменения режима работы.Отключает &quot;применение&quot;.</target>
        </trans-unit>
        <trans-unit id="5429abc21a21a789987424e6c0ab7612e06a85eb" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output diffstat for the input. Turns off &quot;apply&quot;.</source>
          <target state="translated">Вместо того,чтобы применить патч,выводите дифстат для входа.Отключает &quot;применить&quot;.</target>
        </trans-unit>
        <trans-unit id="881bf52883e6605d5234b3f22aaf3b7b4afc6968" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors. Turns off &quot;apply&quot;.</source>
          <target state="translated">Вместо применения патча посмотрите,применим ли патч к текущему рабочему дереву и/или файлу индекса и обнаруживает ли он ошибки.Отключает &quot;применение&quot;.</target>
        </trans-unit>
        <trans-unit id="6e355f85b13671d925fde0c740a0dbae977bb0bc" translate="yes" xml:space="preserve">
          <source>Instead of basing a new branch on current HEAD (the default), use:</source>
          <target state="translated">Вместо того,чтобы основывать новую ветку на текущем HEAD (по умолчанию),используйте:</target>
        </trans-unit>
        <trans-unit id="54f9cd044bb973ffe696d82cb4d71b8b1fd61c38" translate="yes" xml:space="preserve">
          <source>Instead of calling cvsps, read the provided cvsps output file. Useful for debugging or when cvsps is being handled outside cvsimport.</source>
          <target state="translated">Вместо того,чтобы вызывать cvsps,прочтите предоставленный выходной файл cvsps.Полезен для отладки или когда cvsps обрабатывается вне cvsimport.</target>
        </trans-unit>
        <trans-unit id="bb5ec3e62f50f37c713576e81a7468472cf1721e" translate="yes" xml:space="preserve">
          <source>Instead of checking out unmerged entries, copy out the files from named stage. &amp;lt;number&amp;gt; must be between 1 and 3. Note: --stage=all automatically implies --temp.</source>
          <target state="translated">Вместо того, чтобы проверять не объединенные записи, скопируйте файлы из именованной сцены. &amp;lt;число&amp;gt; должно быть от 1 до 3. Примечание: --stage = all автоматически подразумевает --temp.</target>
        </trans-unit>
        <trans-unit id="15d18d5e837d77d2ad93145197274038afcfa944" translate="yes" xml:space="preserve">
          <source>Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:</source>
          <target state="translated">Вместо того,чтобы выбирать ближайший коммит самостоятельно,вы можете попросить Git сделать это за вас,выпустив команду:</target>
        </trans-unit>
        <trans-unit id="69c915ad90f1fd98f69ec0b162209ef45c502e6d" translate="yes" xml:space="preserve">
          <source>Instead of comparing &amp;lt;tree-ish&amp;gt; directly, use the merge base between &amp;lt;tree-ish&amp;gt; and HEAD instead. &amp;lt;tree-ish&amp;gt; must be a commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac415dfd926403d29b00e04771f706952c9bf29" translate="yes" xml:space="preserve">
          <source>Instead of comparing the &amp;lt;tree-ish&amp;gt;s directly, use the merge base between the two &amp;lt;tree-ish&amp;gt;s as the &quot;before&quot; side. There must be two &amp;lt;tree-ish&amp;gt;s given and they must both be commits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071c6c805d6df82b0ae0937a6e3d6e7d94979975" translate="yes" xml:space="preserve">
          <source>Instead of comparing with the tip of &quot;test&quot; branch, compare with the tip of the current branch, but limit the comparison to the file &quot;test&quot;.</source>
          <target state="translated">Вместо сравнения с кончиком &quot;тестовой&quot; ветки сравните с кончиком текущей ветки,но ограничьте сравнение файлом &quot;test&quot;.</target>
        </trans-unit>
        <trans-unit id="17207c6e7e5006477485c406ccec2ab95d9a0907" translate="yes" xml:space="preserve">
          <source>Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to &amp;lt;n&amp;gt; candidates. Increasing &amp;lt;n&amp;gt; above 10 will take slightly longer but may produce a more accurate result. An &amp;lt;n&amp;gt; of 0 will cause only exact matches to be output.</source>
          <target state="translated">Вместо того, чтобы рассматривать только 10 самых последних тегов в качестве кандидатов для описания входной фиксации, рассмотрите до &amp;lt;n&amp;gt; кандидатов. Увеличение &amp;lt;n&amp;gt; выше 10 займет немного больше времени, но может дать более точный результат. Если &amp;lt;n&amp;gt; = 0, будут выводиться только точные совпадения.</target>
        </trans-unit>
        <trans-unit id="3d51a8a573b601f04a9b432f10be7818f6056cab" translate="yes" xml:space="preserve">
          <source>Instead of copying the files to the working directory write the content to temporary files. The temporary name associations will be written to stdout.</source>
          <target state="translated">Вместо того,чтобы копировать файлы в рабочую директорию,записывайте их содержимое во временные файлы.Ассоциации временных имен будут записываться в stdout.</target>
        </trans-unit>
        <trans-unit id="aece37f2a7e1b433117b2533e4c10ff1af967895" translate="yes" xml:space="preserve">
          <source>Instead of explicitly specifying which refs to update, update all heads that locally exist.</source>
          <target state="translated">Вместо того,чтобы явно указывать,какие ссылки обновлять,обновите все головки,которые существуют локально.</target>
        </trans-unit>
        <trans-unit id="c9dd00560176cb59ca6811a38f98f0a00cea59a2" translate="yes" xml:space="preserve">
          <source>Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags.</source>
          <target state="translated">Вместо того,чтобы найти метку,которая предшествует коммиту,найдите метку,которая приходит после коммита,и,таким образом,содержит ее.Автоматически подразумевает --теги.</target>
        </trans-unit>
        <trans-unit id="c3bcf62d531bd115333abb263736c08fc67412f8" translate="yes" xml:space="preserve">
          <source>Instead of having gitweb find repositories by scanning filesystem starting from $projectroot, you can provide a pre-generated list of visible projects by setting &lt;code&gt;$projects_list&lt;/code&gt; to point to a plain text file with a list of projects (with some additional info).</source>
          <target state="translated">Вместо того, чтобы использовать gitweb для поиска репозиториев путем сканирования файловой системы, начиная с $ projectroot, вы можете предоставить предварительно сгенерированный список видимых проектов, установив &lt;code&gt;$projects_list&lt;/code&gt; для указания на простой текстовый файл со списком проектов (с некоторой дополнительной информацией).</target>
        </trans-unit>
        <trans-unit id="b8a426e0ceafe99f9ee69973b04f605e2dee7cb4" translate="yes" xml:space="preserve">
          <source>Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack. Especially useful when packing a repository that is used for private development. Use with &lt;code&gt;-d&lt;/code&gt;. This will clean up the objects that &lt;code&gt;git prune&lt;/code&gt; leaves behind, but &lt;code&gt;git fsck --full --dangling&lt;/code&gt; shows as dangling.</source>
          <target state="translated">Вместо того, чтобы постепенно упаковывать распакованные объекты, упакуйте все, на что есть ссылки, в один пакет. Особенно полезно при упаковке репозитория, который используется для частной разработки. Используйте с &lt;code&gt;-d&lt;/code&gt; . Это очистит объекты, которые оставляет после себя &lt;code&gt;git prune&lt;/code&gt; , но &lt;code&gt;git fsck --full --dangling&lt;/code&gt; отображается как висячий .</target>
        </trans-unit>
        <trans-unit id="f1ffab5966e331d53c3cb8a3d86f241f936c7bef" translate="yes" xml:space="preserve">
          <source>Instead of initializing the repository as a directory to either &lt;code&gt;$GIT_DIR&lt;/code&gt; or &lt;code&gt;./.git/&lt;/code&gt;, create a text file there containing the path to the actual repository. This file acts as filesystem-agnostic Git symbolic link to the repository.</source>
          <target state="translated">Вместо того, чтобы инициализировать репозиторий как каталог для &lt;code&gt;$GIT_DIR&lt;/code&gt; или &lt;code&gt;./.git/&lt;/code&gt; , создайте там текстовый файл, содержащий путь к фактическому репозиторию. Этот файл действует как не зависящая от файловой системы символическая ссылка Git на репозиторий.</target>
        </trans-unit>
        <trans-unit id="f0ef88b9adcd939e8a3f3a231e5d0c4737f1545c" translate="yes" xml:space="preserve">
          <source>Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines.</source>
          <target state="translated">Вместо того,чтобы оставлять конфликты в файле,разрешайте конфликты в пользу нашей (или их,или обеих)стороны строк.</target>
        </trans-unit>
        <trans-unit id="ca8be3d7e71d110990923e82a424a61c61fcfea3" translate="yes" xml:space="preserve">
          <source>Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for details.</source>
          <target state="translated">Вместо создания tar-архива из локального репозитория, получите tar-архив из удаленного репозитория. Обратите внимание, что удаленный репозиторий может накладывать ограничения на то, какие выражения sha1 могут быть разрешены в &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; . Подробнее см. &lt;a href=&quot;git-upload-archive&quot;&gt;Git-upload-archive [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f9313c2b37d59bfbfa07ff3336c61ac5f242846" translate="yes" xml:space="preserve">
          <source>Instead of multiple service names, multiple commands will be supported by a single service</source>
          <target state="translated">Вместо нескольких имен сервисов,несколько команд будут поддерживаться одним сервисом.</target>
        </trans-unit>
        <trans-unit id="9913e3351ae1177f0328b10cfa41d1a78100d839" translate="yes" xml:space="preserve">
          <source>Instead of naming each ref to push, specifies that all refs under &lt;code&gt;refs/&lt;/code&gt; (which includes but is not limited to &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/remotes/&lt;/code&gt;, and &lt;code&gt;refs/tags/&lt;/code&gt;) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; is set.</source>
          <target state="translated">Вместо того, чтобы именовать каждую ссылку для отправки, указывает, что все ссылки в &lt;code&gt;refs/&lt;/code&gt; (которые включают, но не ограничиваются, &lt;code&gt;refs/heads/&lt;/code&gt; , &lt;code&gt;refs/remotes/&lt;/code&gt; и &lt;code&gt;refs/tags/&lt;/code&gt; ) зеркалируются в удаленном репозитории. Недавно созданные локальные ссылки будут отправлены на удаленный конец, локально обновленные ссылки будут принудительно обновлены на удаленном конце, а удаленные ссылки будут удалены с удаленного конца. Это значение по умолчанию, если установлен параметр конфигурации &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9634150ab7e71bf3eb3f2b25ec8ede96c11d4e06" translate="yes" xml:space="preserve">
          <source>Instead of naming the commits using the path to reach them from heads (e.g. &quot;master~2&quot; to mean the grandparent of &quot;master&quot;), name them with the unique prefix of their object names.</source>
          <target state="translated">Вместо того,чтобы называть коммиты,используя путь к ним от голов (например,&quot;master~2&quot; в значении дедушки &quot;master&quot;),назовите их уникальным префиксом имен объектов.</target>
        </trans-unit>
        <trans-unit id="17b0b1c8040238e6478f5b3afd0b8cbc3b08f080" translate="yes" xml:space="preserve">
          <source>Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree.</source>
          <target state="translated">Вместо того,чтобы размещать клонированный репозиторий там,где он должен быть,поместите клонированный репозиторий в указанную директорию,а затем сделайте туда символическую ссылку на файловую систему-диагностику Git'а.В результате Git-репозиторий можно отделить от рабочего дерева.</target>
        </trans-unit>
        <trans-unit id="22fb130092ca941fcb14aff3909ae71b595afba3" translate="yes" xml:space="preserve">
          <source>Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository&amp;rsquo;s HEAD, point to &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; branch instead. In a non-bare repository, this is the branch that will be checked out. &lt;code&gt;--branch&lt;/code&gt; can also take tags and detaches the HEAD at that commit in the resulting repository.</source>
          <target state="translated">Вместо того, чтобы указывать вновь созданный HEAD на ветку, на которую указывает HEAD клонированного репозитория, укажите вместо этого на ветку &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; . В репозитории non-bare это ветка, которая будет извлечена. &lt;code&gt;--branch&lt;/code&gt; также может принимать теги и отделять HEAD от этого коммита в полученном репозитории.</target>
        </trans-unit>
        <trans-unit id="33ebce829b735e00e4c7bea8b4f644ee8c315aa6" translate="yes" xml:space="preserve">
          <source>Instead of printing both the SHA-1 and the name, print only the name. If given with --tags the usual tag prefix of &quot;tags/&quot; is also omitted from the name, matching the output of &lt;code&gt;git-describe&lt;/code&gt; more closely.</source>
          <target state="translated">Вместо того, чтобы печатать и SHA-1, и имя, напечатайте только имя. Если указано с --tags, обычный префикс тега &amp;laquo;tags /&amp;raquo; также опускается из имени, что более точно соответствует выходным данным &lt;code&gt;git-describe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="064cb6e81b93b30bcf346d10dc97336e618d6fae" translate="yes" xml:space="preserve">
          <source>Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of &lt;code&gt;git show-branch --independent&lt;/code&gt;.</source>
          <target state="translated">Вместо того, чтобы печатать базы слияния, выведите минимальное подмножество предоставленных коммитов с теми же предками. Другими словами, среди предоставленных коммитов перечислите те, которые не могут быть достигнуты ни с одной другой. Это имитирует поведение &lt;code&gt;git show-branch --independent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="323f56e14b223cf1dac7d6a09fb1d2d15675463d" translate="yes" xml:space="preserve">
          <source>Instead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path. (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with &lt;code&gt;!&lt;/code&gt; then it is a negated pattern and matching it means the path is NOT excluded.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a77a1e8325cae4bfdfe406c89eaae3fe4ca07d52" translate="yes" xml:space="preserve">
          <source>Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; be specified. Note that the objects are visited in order sorted by their hashes.</source>
          <target state="translated">Вместо чтения списка объектов на стандартном вводе выполните запрошенную пакетную операцию для всех объектов в репозитории и любых альтернативных хранилищ объектов (а не только для доступных объектов). Требуется &lt;code&gt;--batch&lt;/code&gt; или &lt;code&gt;--batch-check&lt;/code&gt; . Обратите внимание, что объекты посещаются в порядке сортировки по их хешам.</target>
        </trans-unit>
        <trans-unit id="d4a14000f7e28706a0e6c2e4729bb02543a4d281" translate="yes" xml:space="preserve">
          <source>Instead of reading tree object(s) into the index, just empty it.</source>
          <target state="translated">Вместо того,чтобы читать объект(ы)дерева в индекс,просто опустошите его.</target>
        </trans-unit>
        <trans-unit id="5828d05fd5c0a35f4392daf67536f9a77ece2b90" translate="yes" xml:space="preserve">
          <source>Instead of running &lt;code&gt;git repack&lt;/code&gt; you can also run &lt;code&gt;git gc
--aggressive&lt;/code&gt;, which will also optimize other things after an import (e.g. pack loose refs). As noted in the &quot;AGGRESSIVE&quot; section in &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; the &lt;code&gt;--aggressive&lt;/code&gt; option will find new deltas with the &lt;code&gt;-f&lt;/code&gt; option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. For the reasons elaborated on above using &lt;code&gt;--aggressive&lt;/code&gt; after a fast-import is one of the few cases where it&amp;rsquo;s known to be worthwhile.</source>
          <target state="translated">Вместо запуска &lt;code&gt;git repack&lt;/code&gt; вы также можете запустить &lt;code&gt;git gc --aggressive&lt;/code&gt; , который также оптимизирует другие вещи после импорта (например, упаковывать свободные ссылки). Как отмечалось в разделе &amp;laquo;АГРЕССИВНЫЙ&amp;raquo; в &lt;a href=&quot;git-gc&quot;&gt;git-gc [1],&lt;/a&gt; параметр &lt;code&gt;--aggressive&lt;/code&gt; найдет новые дельты с параметром &lt;code&gt;-f&lt;/code&gt; для &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; . По причинам, изложенным выше, использование &lt;code&gt;--aggressive&lt;/code&gt; после быстрого импорта - один из немногих случаев, когда это целесообразно.</target>
        </trans-unit>
        <trans-unit id="27d7e1d82cdbf4a022b1041bc3a4b5c02db03622" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known diff tools, &lt;code&gt;git difftool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">Вместо запуска одного из известных инструментов сравнения, &lt;code&gt;git difftool&lt;/code&gt; можно настроить для запуска альтернативной программы, указав вызываемую командную строку в переменной конфигурации &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a6ec50c9a1e350ef9a3f4f762c317cd2d6e8233" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known merge tool programs, &lt;code&gt;git mergetool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">Вместо запуска одной из известных инструментальных программ слияния &lt;code&gt;git mergetool&lt;/code&gt; можно настроить для запуска альтернативной программы, указав командную строку для вызова в переменной конфигурации &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09dffc4d1650e5ccccc05b0bf19a3e3e59eb7116" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs in the given trees.</source>
          <target state="translated">Вместо того,чтобы искать отслеживаемые файлы в рабочем дереве,найдите капли в данных деревьях.</target>
        </trans-unit>
        <trans-unit id="31ae83b44368ffd8feca3b205d3db8ea7d6a3c5c" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs registered in the index file.</source>
          <target state="translated">Вместо того,чтобы искать отслеживаемые файлы в рабочем дереве,используйте поисковые блоки,зарегистрированные в индексном файле.</target>
        </trans-unit>
        <trans-unit id="55e6c9aa38dceb73a0632da59bc95f69bdfc3cb4" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with &lt;code&gt;git diff&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; is a synonym for &lt;code&gt;--files-with-matches&lt;/code&gt;.</source>
          <target state="translated">Вместо отображения каждой совпадающей строки показывайте только имена файлов, которые содержат (или не содержат) совпадения. Для лучшей совместимости с &lt;code&gt;git diff&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; является синонимом &lt;code&gt;--files-with-matches&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1fdcf67f0afaa931922f6239ba4fdd53758ce0d" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show the number of lines that match.</source>
          <target state="translated">Вместо того,чтобы показывать каждую совпаденную строку,покажите количество совпадающих строк.</target>
        </trans-unit>
        <trans-unit id="9ddb49ffe2885e9ce52c33a63e80e23af2a075a9" translate="yes" xml:space="preserve">
          <source>Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt; handles the case of three or more commits.</source>
          <target state="translated">Вместо того, чтобы показывать список коммитов, определите возможные базы слияния для указанных коммитов. Все базы слияния будут содержаться во всех указанных коммитах. Это отличается от того, как &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; обрабатывает случай трех или более коммитов.</target>
        </trans-unit>
        <trans-unit id="a8349eb4dd68e56b89f47b502f7a090d16d7f921" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. &quot;--abbrev=&amp;lt;n&amp;gt;&quot; (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba3d7561fe60e77ce239084badd1d1856e50d97" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal commit object name, show only a partial prefix. Non default number of digits can be specified with &quot;--abbrev=&amp;lt;n&amp;gt;&quot; (which also modifies diff output, if it is displayed).</source>
          <target state="translated">Вместо того, чтобы показывать полное 40-байтовое шестнадцатеричное имя объекта фиксации, показывайте только частичный префикс. Количество цифр не по умолчанию может быть указано с помощью &quot;--abbrev = &amp;lt;n&amp;gt;&quot; (который также изменяет вывод diff, если он отображается).</target>
        </trans-unit>
        <trans-unit id="7d6a3b8755cc865088fd97c8d79f6b68eb4292bc" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object lines, show only a partial prefix. Non default number of digits can be specified with --abbrev=&amp;lt;n&amp;gt;.</source>
          <target state="translated">Вместо того, чтобы показывать полные 40-байтовые шестнадцатеричные строки объекта, показывайте только частичный префикс. Количество цифр не по умолчанию можно указать с помощью --abbrev = &amp;lt;n&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="41bb60e5bd2f66611e158fbf7d65588b7e0bec0a" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=&amp;lt;n&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ecb5df7fcdb6c0e019f4aa574b567ad3276395" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. In diff-patch output format, &lt;code&gt;--full-index&lt;/code&gt; takes higher precedence, i.e. if &lt;code&gt;--full-index&lt;/code&gt; is specified, full blob names will be shown regardless of &lt;code&gt;--abbrev&lt;/code&gt;. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd3315e868be633e341c6b1fc6b217d4459f224" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. This is independent of the &lt;code&gt;--full-index&lt;/code&gt; option above, which controls the diff-patch output format. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вместо того, чтобы показывать полное 40-байтовое шестнадцатеричное имя объекта в выходных данных в формате diff-raw и в строках заголовка diff-tree, показывайте только частичный префикс. Это не зависит от указанной &lt;code&gt;--full-index&lt;/code&gt; опции --full-index , которая управляет выходным форматом diff-patch. Количество цифр не по умолчанию можно указать с помощью &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05b537007c39aa598d1319a3985738adfc8b433d" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; hexdigits long that uniquely refers the object. In diff-patch output format, &lt;code&gt;--full-index&lt;/code&gt; takes higher precedence, i.e. if &lt;code&gt;--full-index&lt;/code&gt; is specified, full blob names will be shown regardless of &lt;code&gt;--abbrev&lt;/code&gt;. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac504d3062e8b5bad74846fd627b7807bedc4f2" translate="yes" xml:space="preserve">
          <source>Instead of showing the path names relative to the current working directory, show the full path names.</source>
          <target state="translated">Вместо того,чтобы показывать имена путей относительно текущей рабочей директории,показывайте полные имена путей.</target>
        </trans-unit>
        <trans-unit id="5f0ed09aafafab46ef0c48e35d2b30851c21ae6a" translate="yes" xml:space="preserve">
          <source>Instead of staging files after each individual change, you can tell &lt;code&gt;git commit&lt;/code&gt; to notice the changes to the files whose contents are tracked in your working tree and do corresponding &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you. That is, this example does the same as the earlier example if there is no other change in your working tree:</source>
          <target state="translated">Вместо того, чтобы размещать файлы после каждого отдельного изменения, вы можете указать &lt;code&gt;git commit&lt;/code&gt; замечать изменения в файлах, содержимое которых отслеживается в вашем рабочем дереве, и выполнять для вас соответствующие &lt;code&gt;git add&lt;/code&gt; и &lt;code&gt;git rm&lt;/code&gt; . То есть этот пример делает то же самое, что и предыдущий, если в вашем рабочем дереве нет других изменений:</target>
        </trans-unit>
        <trans-unit id="a675a0b8f5c03b948f0d18f87a17852f45d21abd" translate="yes" xml:space="preserve">
          <source>Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges.</source>
          <target state="translated">Вместо того,чтобы останавливаться на первом неудачном слиянии,делайте все это одним выстрелом-продолжайте слияние даже тогда,когда предыдущие слияния возвращали ошибки,и возвращайте код ошибки только после всех слияний.</target>
        </trans-unit>
        <trans-unit id="de32bccd3ddde71a98cffd2de1232e1c99dfd513" translate="yes" xml:space="preserve">
          <source>Instead of submitting create a series of shelved changelists. After creating each shelve, the relevant files are reverted/deleted. If you have multiple commits pending multiple shelves will be created.</source>
          <target state="translated">Вместо того,чтобы подавать заявки,создайте серию полочных сменщиков.После создания каждой полки соответствующие файлы возвращаются/удаляются.Если у вас есть несколько коммитов в ожидании создания нескольких полок,будут созданы несколько полок.</target>
        </trans-unit>
        <trans-unit id="140c71a8b471c44c130e5b1eee8b0237e8238e05" translate="yes" xml:space="preserve">
          <source>Instead of taking list of paths from the command line, read list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.</source>
          <target state="translated">Вместо того,чтобы брать список путей из командной строки,читайте список путей со стандартного входа.По умолчанию пути разделены LF (т.е.один путь на строку).</target>
        </trans-unit>
        <trans-unit id="f4ba2e4e1080efba3c28ca42286f9295fb7a6889" translate="yes" xml:space="preserve">
          <source>Instead of the commit subject, use some other information to describe each commit. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can be any string accepted by the &lt;code&gt;--format&lt;/code&gt; option of &lt;code&gt;git log&lt;/code&gt;, such as &lt;code&gt;* [%h] %s&lt;/code&gt;. (See the &quot;PRETTY FORMATS&quot; section of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.)</source>
          <target state="translated">Вместо темы коммита используйте другую информацию для описания каждого коммита. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; может быть любой строкой, принятой параметром &lt;code&gt;--format&lt;/code&gt; журнала &lt;code&gt;git log&lt;/code&gt; , например &lt;code&gt;* [%h] %s&lt;/code&gt; . (См. Раздел &amp;laquo;ПРИЯТНЫЕ ФОРМАТЫ&amp;raquo; в &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a4e872330a2ee34ffbac6bb806a9bf43b1d76b3c" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object size identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">Вместо содержимого покажите размер объекта, обозначенный &amp;lt;object&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="f066e23ab4bd2d63e94325b4a2a048945fb424e1" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object type identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">Вместо содержимого покажите тип объекта, обозначенный &amp;lt;object&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="01b660ce7f25b8747605b72657d7e3925704df33" translate="yes" xml:space="preserve">
          <source>Instead of the default &quot;symref&quot; format for HEAD and other symbolic reference files, use symbolic links. This is sometimes needed to work with old scripts that expect HEAD to be a symbolic link.</source>
          <target state="translated">Вместо формата &quot;symref&quot; по умолчанию для HEAD и других символических файлов ссылок используйте символические ссылки.Иногда это необходимо для работы со старыми сценариями,которые ожидают,что HEAD будет символической ссылкой.</target>
        </trans-unit>
        <trans-unit id="f146d5682a8b5a97d10d05b37274aa1ba3a49c07" translate="yes" xml:space="preserve">
          <source>Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames.</source>
          <target state="translated">Вместо 4-х цифр по умолчанию с ведущими нулями,для генерируемых имён файлов может быть задана различная точность.</target>
        </trans-unit>
        <trans-unit id="e1d28ba0f9256454e559ca46e186461c224089ef" translate="yes" xml:space="preserve">
          <source>Instead of the first handful of characters, show the full pre- and post-image blob object names on the &quot;index&quot; line when generating patch format output.</source>
          <target state="translated">Вместо первой горстки символов при генерации вывода в формате патча показывайте полные имена объектов до и после изображения в строке &quot;индекс&quot;.</target>
        </trans-unit>
        <trans-unit id="e3b6588aa8ce45f7528fa4adfa5f41dc47858a56" translate="yes" xml:space="preserve">
          <source>Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note, this only includes the alias name and not its expanded email addresses. See &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; for more information about aliases.</source>
          <target state="translated">Вместо обычной операции выгрузите сокращенные имена псевдонимов из настроенных файлов псевдонимов, по одному на строку в алфавитном порядке. Обратите внимание, это включает только псевдоним, но не его расширенные адреса электронной почты. См. &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; для получения дополнительной информации о псевдонимах.</target>
        </trans-unit>
        <trans-unit id="a5193f3430d8f0ae554c9fb9924930f57b4baaf8" translate="yes" xml:space="preserve">
          <source>Instead of the standard 64 bytes, chomp the generated output filenames at around &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes (too short a value will be silently raised to a reasonable length). Defaults to the value of the &lt;code&gt;format.filenameMaxLength&lt;/code&gt; configuration variable, or 64 if unconfigured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a59d82290cfd961dc9ff35f15683facfa89709" translate="yes" xml:space="preserve">
          <source>Instead of the standard &lt;code&gt;[PATCH]&lt;/code&gt; prefix in the subject line, instead use &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt;. This allows for useful naming of a patch series, and can be combined with the &lt;code&gt;--numbered&lt;/code&gt; option.</source>
          <target state="translated">Вместо стандартного префикса &lt;code&gt;[PATCH]&lt;/code&gt; в строке темы используйте &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt; . Это позволяет использовать &lt;code&gt;--numbered&lt;/code&gt; именование серии патчей и может быть объединено с параметром --numbered .</target>
        </trans-unit>
        <trans-unit id="440b20677cca3bad5d5589368544d09ff6997de8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, you can also choose just to update one branch at a time, and to store it locally under an arbitrary name:</source>
          <target state="translated">Вместо использования &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; вы также можете выбрать обновление по одной ветке за раз и хранить ее локально под произвольным именем:</target>
        </trans-unit>
        <trans-unit id="c80da0469d96c6db5cfae1c5b4b2cc65c570bdb0" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;.patch&lt;/code&gt; as the suffix for generated filenames, use specified suffix. A common alternative is &lt;code&gt;--suffix=.txt&lt;/code&gt;. Leaving this empty will remove the &lt;code&gt;.patch&lt;/code&gt; suffix.</source>
          <target state="translated">Вместо использования &lt;code&gt;.patch&lt;/code&gt; в качестве суффикса для сгенерированных имен файлов используйте указанный суффикс. Распространенной альтернативой является &lt;code&gt;--suffix=.txt&lt;/code&gt; . Если оставить это поле &lt;code&gt;.patch&lt;/code&gt; суффикс .patch будет удален .</target>
        </trans-unit>
        <trans-unit id="f82d2e94f21038afaa9f1d66d3a9a0e365538f7c" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any ref found in &lt;code&gt;refs/&lt;/code&gt; namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag.</source>
          <target state="translated">Вместо использования только аннотированных тегов используйте любую ссылку, найденную в &lt;code&gt;refs/&lt;/code&gt; namespace. Этот параметр позволяет сопоставить любую известную ветвь, ветку удаленного отслеживания или облегченный тег.</target>
        </trans-unit>
        <trans-unit id="1177311a3949b6b80d45daef7bf2616b79441b65" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any tag found in &lt;code&gt;refs/tags&lt;/code&gt; namespace. This option enables matching a lightweight (non-annotated) tag.</source>
          <target state="translated">Вместо использования только аннотированных тегов используйте любой тег из пространства имен &lt;code&gt;refs/tags&lt;/code&gt; . Этот параметр позволяет сопоставить легкий (не аннотированный) тег.</target>
        </trans-unit>
        <trans-unit id="525df652b887a2877266435635ef66426239fc1d" translate="yes" xml:space="preserve">
          <source>Instead of using the author date of the original commit, use the current time as the author date of the rebased commit. This option implies &lt;code&gt;--force-rebase&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4860002e825b16be9527700d7d5e647a6362a7ef" translate="yes" xml:space="preserve">
          <source>Instead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies &lt;code&gt;--force-rebase&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa50874379be0d623d79d8af182cc42f83a49b1c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt; digits, or as many digits as needed to form a unique object name. An &amp;lt;n&amp;gt; of 0 will suppress long format, only showing the closest tag.</source>
          <target state="translated">Вместо использования 7 шестнадцатеричных цифр по умолчанию в качестве сокращенного имени объекта используйте цифры &amp;lt;n&amp;gt; или столько цифр, сколько необходимо для формирования уникального имени объекта. Значение 0 для &amp;lt;n&amp;gt; подавляет длинный формат, показывая только ближайший тег.</target>
        </trans-unit>
        <trans-unit id="8ef17c5b4695c9bfd592215d15d120e9c2a9006e" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use &amp;lt;m&amp;gt;+1 digits, where &amp;lt;m&amp;gt; is at least &amp;lt;n&amp;gt; but ensures the commit object names are unique. Note that 1 column is used for a caret to mark the boundary commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183487409af3884cbc9c819c550a69752622875c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt;+1 digits. Note that 1 column is used for a caret to mark the boundary commit.</source>
          <target state="translated">Вместо использования по умолчанию 7 + 1 шестнадцатеричных цифр в качестве сокращенного имени объекта используйте цифры &amp;lt;n&amp;gt; +1. Обратите внимание, что для обозначения фиксации границы используется 1 столбец.</target>
        </trans-unit>
        <trans-unit id="ee5547b5d72f6d52e84d0986cad360b6f68e956a" translate="yes" xml:space="preserve">
          <source>Instead of using the remote name &lt;code&gt;origin&lt;/code&gt; to keep track of the upstream repository, use &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вместо того чтобы использовать имя удаленного &lt;code&gt;origin&lt;/code&gt; , чтобы отслеживать вверх по течению хранилища, используйте &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8230f517afe99bceca1ecc093593da33efe8d9c7" translate="yes" xml:space="preserve">
          <source>Instead of using the remote name &lt;code&gt;origin&lt;/code&gt; to keep track of the upstream repository, use &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;. Overrides &lt;code&gt;clone.defaultRemoteName&lt;/code&gt; from the config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acaf18a5ec5cac3fd2f3b3d56ba27133d9e16abf" translate="yes" xml:space="preserve">
          <source>Instead of using the tip of the current branch, compare with the tip of &quot;test&quot; branch.</source>
          <target state="translated">Вместо того,чтобы использовать кончик текущей ветки,сравните с кончиком &quot;тестовой&quot; ветки.</target>
        </trans-unit>
        <trans-unit id="0e0bb2a4d944b8f5531055e279607820e676a94b" translate="yes" xml:space="preserve">
          <source>Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, &lt;code&gt;^commit&lt;/code&gt;, &lt;code&gt;commit1..commit2&lt;/code&gt;, and &lt;code&gt;commit1...commit2&lt;/code&gt; notations cannot be used).</source>
          <target state="translated">Вместо того, чтобы идти по цепочке предков фиксации, переместите записи рефлога от самой последней к более старой. Когда используется этот параметр, вы не можете указать коммиты для исключения (то есть нотации &lt;code&gt;^commit&lt;/code&gt; , &lt;code&gt;commit1..commit2&lt;/code&gt; и &lt;code&gt;commit1...commit2&lt;/code&gt; использовать нельзя).</target>
        </trans-unit>
        <trans-unit id="00c411b0a21221afdc6e21c624bf253d7212e3a9" translate="yes" xml:space="preserve">
          <source>Instead of writing the results out to &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt;, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in.</source>
          <target state="translated">Вместо того, чтобы записывать результаты в &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt; , запишите результирующий индекс в названный файл. Пока команда работает, исходный индексный файл блокируется тем же механизмом, что и обычно. Файл должен иметь возможность переименовать (2) во временный файл, который создается рядом с обычным индексным файлом; обычно это означает, что он должен находиться в той же файловой системе, что и сам индексный файл, и вам необходимо разрешение на запись в каталоги, в которых находятся индексный файл и выходной файл индекса.</target>
        </trans-unit>
        <trans-unit id="ef06396aed739ff032fb1ddeda938ad4cf5e4280" translate="yes" xml:space="preserve">
          <source>Instruct Git to avoid trying to guess defaults for &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;user.name&lt;/code&gt;, and instead retrieve the values only from the configuration. For example, if you have multiple email addresses and would like to use a different one for each repository, then with this configuration option set to &lt;code&gt;true&lt;/code&gt; in the global config along with a name, Git will prompt you to set up an email before making new commits in a newly cloned repository. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;user.email&lt;/code&gt; Git, чтобы он не пытался угадывать значения по умолчанию для user.email и &lt;code&gt;user.name&lt;/code&gt; , а вместо этого извлекал значения только из конфигурации. Например, если у вас есть несколько адресов электронной почты и вы хотите использовать разные адреса для каждого репозитория, то с этой опцией конфигурации, установленной в значение &lt;code&gt;true&lt;/code&gt; в глобальной конфигурации вместе с именем, Git предложит вам настроить электронную почту перед созданием нового фиксируется в недавно клонированном репозитории. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a592acd9f11ad3bff77a1878bfa756913e7df3fe" translate="yes" xml:space="preserve">
          <source>Instruction to add new data</source>
          <target state="translated">Инструкция по добавлению новых данных</target>
        </trans-unit>
        <trans-unit id="c222c271406b6a5c2fcfc84ba72b7981aee6b09e" translate="yes" xml:space="preserve">
          <source>Instruction to copy from base object</source>
          <target state="translated">Инструкция по копированию с базового объекта</target>
        </trans-unit>
        <trans-unit id="6131d2bc98a67fbf2df419d53c2a5951a56eb747" translate="yes" xml:space="preserve">
          <source>Instructs the remote helper that any subsequent input is part of a fast-import stream (generated by &lt;code&gt;git fast-export&lt;/code&gt;) containing objects which should be pushed to the remote.</source>
          <target state="translated">Указывает удаленному помощнику, что любой последующий ввод является частью потока быстрого импорта (сгенерированного &lt;code&gt;git fast-export&lt;/code&gt; ), содержащего объекты, которые должны быть отправлены на удаленный.</target>
        </trans-unit>
        <trans-unit id="563eacc97631ea8eeadfe6b54ffbd63455326490" translate="yes" xml:space="preserve">
          <source>Integer. Specifies desired depth of nested regions in the event output. Regions deeper than this value will be omitted. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; environment variable. Defaults to 2.</source>
          <target state="translated">Integer. Задает желаемую глубину вложенных областей в выходных данных события. Области глубже этого значения будут опущены. Может быть переопределено переменной среды &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; . По умолчанию 2.</target>
        </trans-unit>
        <trans-unit id="f3e0144605c9578fc597fd7ff39de75aab2afefe" translate="yes" xml:space="preserve">
          <source>Integer. When writing trace files to a target directory, do not write additional traces if we would exceed this many files. Instead, write a sentinel file that will block further tracing to this directory. Defaults to 0, which disables this check.</source>
          <target state="translated">Целостный.При записи файлов трасс в целевую директорию не записывайте дополнительные трассы,если мы превысим это количество файлов.Вместо этого запишите файл sendinel,который будет блокировать дальнейшую трассировку в эту директорию.По умолчанию 0,что отключает эту проверку.</target>
        </trans-unit>
        <trans-unit id="a6768cae9c51930f13c302375f3385c6c77b2104" translate="yes" xml:space="preserve">
          <source>Integrator</source>
          <target state="translated">Integrator</target>
        </trans-unit>
        <trans-unit id="e30f6e398ba3d7dd3d6ee2f7d0d8940d3116f2a5" translate="yes" xml:space="preserve">
          <source>Interacting with Others</source>
          <target state="translated">Взаимодействие с другими</target>
        </trans-unit>
        <trans-unit id="e9854d76872b55831675241f09e80f37f1939cea" translate="yes" xml:space="preserve">
          <source>Interaction between checkin/checkout attributes</source>
          <target state="translated">Взаимодействие между атрибутами проверки/отправки</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">Интерактивный режим</target>
        </trans-unit>
        <trans-unit id="fb0ea93fbb85b738df0bd31fcf1bc9eb5468d22b" translate="yes" xml:space="preserve">
          <source>Interactive use</source>
          <target state="translated">Интерактивное использование</target>
        </trans-unit>
        <trans-unit id="94db97a8381d05a800daa18ce0818d37326de61f" translate="yes" xml:space="preserve">
          <source>Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.</source>
          <target state="translated">Интерактивно выбирайте куски патча между индексом и рабочим деревом и добавляйте их в индекс.Это дает пользователю возможность просмотреть разницу перед добавлением измененного содержимого в индекс.</target>
        </trans-unit>
        <trans-unit id="bfdd4f344b8dfb9b5f469d3e0a6945b89367454c" translate="yes" xml:space="preserve">
          <source>Interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942e3b50f8575a931a7b62b4970978b40b59bcee" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; was specified, the index).</source>
          <target state="translated">В интерактивном режиме выберите блоки в разнице между &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (или индексом, если он не указан) и рабочим деревом. Выбранные блоки затем применяются в обратном порядке к рабочему дереву (и, если был указан &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; , индекс).</target>
        </trans-unit>
        <trans-unit id="6b61a0bfaba36c21326a6cc1d8076250bbb8f781" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the index and &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (defaults to &lt;code&gt;HEAD&lt;/code&gt;). The chosen hunks are applied in reverse to the index.</source>
          <target state="translated">В интерактивном режиме выберите блоки в разнице между индексом и &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (по умолчанию &lt;code&gt;HEAD&lt;/code&gt; ). Выбранные блоки применяются в обратном порядке к индексу.</target>
        </trans-unit>
        <trans-unit id="11c4e8d4b31fcec1faa8b21ab916ae6d7ecd6196" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the restore source and the restore location. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">В интерактивном режиме выберите блоки в разнице между источником восстановления и местом восстановления. См. Раздел &amp;laquo;Интерактивный режим&amp;raquo; в &lt;a href=&quot;git-add&quot;&gt;git-add [1],&lt;/a&gt; чтобы узнать, как работать в режиме &lt;code&gt;--patch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37d460e42c18dd6a2f67dd6cfcf736b2dc4e3735" translate="yes" xml:space="preserve">
          <source>Internal detail of implementation. What is important is that if this field is not present then per-repository override for given feature is not supported.</source>
          <target state="translated">Внутренние детали реализации.Важно то,что если это поле отсутствует,то переопределение на репозиторий для данной функции не поддерживается.</target>
        </trans-unit>
        <trans-unit id="fcd742802f00593c0aa9a5d67d6ee0045ea54dd6" translate="yes" xml:space="preserve">
          <source>Internal helper commands</source>
          <target state="translated">Внутренние команды помощника</target>
        </trans-unit>
        <trans-unit id="99089329f972015329c6ab2c5f20f49ab1b0fb2e" translate="yes" xml:space="preserve">
          <source>Internal variable identifying the repository format and layout version.</source>
          <target state="translated">Внутренняя переменная,определяющая формат хранилища и версию макета.</target>
        </trans-unit>
        <trans-unit id="d2a9fe262eee692f1042088fcd5412df8b02ed0e" translate="yes" xml:space="preserve">
          <source>Internal variable which enables various workarounds to enable Git to work better on filesystems that are not case sensitive, like APFS, HFS+, FAT, NTFS, etc. For example, if a directory listing finds &quot;makefile&quot; when Git expects &quot;Makefile&quot;, Git will assume it is really the same file, and continue to remember it as &quot;Makefile&quot;.</source>
          <target state="translated">Внутренняя переменная,позволяющая использовать различные обходные пути,чтобы Git мог лучше работать на файловых системах,не чувствительных к регистру,таких как APFS,HFS+,FAT,NTFS и др.Например,если список каталогов найдёт &quot;makefile&quot;,когда Git ожидает &quot;Makefile&quot;,то он будет считать,что это действительно тот же самый файл,и продолжать запоминать его как &quot;Makefile&quot;.</target>
        </trans-unit>
        <trans-unit id="2885f5339d53e1a4ffa0f79158576edb8758ff7a" translate="yes" xml:space="preserve">
          <source>Internally, Git always stores file names as sequences of bytes and doesn&amp;rsquo;t perform any encoding or case folding. However, Windows and macOS by default both perform case folding on file names. As a result, it&amp;rsquo;s possible to end up with multiple files or directories whose names differ only in case. Git can handle this just fine, but the file system can store only one of these files, so when Git reads the other file to see its contents, it looks modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5dd045ecadbef7edb9976d5bf76d5e7548b5a7" translate="yes" xml:space="preserve">
          <source>Interpret &amp;lt;refname&amp;gt; as a reference name pattern for a refspec (as used with remote repositories). If this option is enabled, &amp;lt;refname&amp;gt; is allowed to contain a single &lt;code&gt;*&lt;/code&gt; in the refspec (e.g., &lt;code&gt;foo/bar*/baz&lt;/code&gt; or &lt;code&gt;foo/bar*baz/&lt;/code&gt; but not &lt;code&gt;foo/bar*/baz*&lt;/code&gt;).</source>
          <target state="translated">Интерпретируйте &amp;lt;refname&amp;gt; как шаблон ссылочного имени для refspec (как используется с удаленными репозиториями). Если эта опция включена, &amp;lt;refname&amp;gt; может содержать одиночный &lt;code&gt;*&lt;/code&gt; в refspec (например, &lt;code&gt;foo/bar*/baz&lt;/code&gt; или &lt;code&gt;foo/bar*baz/&lt;/code&gt; но не &lt;code&gt;foo/bar*/baz*&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="670ef7722a61e3342fef6602c3dc04b50457ccb3" translate="yes" xml:space="preserve">
          <source>Interpret all preceding arguments as attributes and all following arguments as path names.</source>
          <target state="translated">Интерпретируйте все предыдущие аргументы как атрибуты,а все последующие аргументы как имена путей.</target>
        </trans-unit>
        <trans-unit id="c75cadb4ae816991e0dd6b40f2cda63b6ea63eb7" translate="yes" xml:space="preserve">
          <source>Interrogation commands</source>
          <target state="translated">Допросные команды</target>
        </trans-unit>
        <trans-unit id="f1e6fa1e2ddb5fcd808e3092148f74242800360f" translate="yes" xml:space="preserve">
          <source>Interrogators:</source>
          <target state="translated">Interrogators:</target>
        </trans-unit>
        <trans-unit id="8b0b6bf2544da29702a138cd7dd487472490ccff" translate="yes" xml:space="preserve">
          <source>Interrupt transfer after &amp;lt;n&amp;gt; seconds of inactivity.</source>
          <target state="translated">Прерывание передачи после &amp;lt;n&amp;gt; секунд бездействия.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
