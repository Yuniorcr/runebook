<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="82b93c6560af27195da14e70510e2b3d8651c3b7" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Actually the possible values of this option are:</source>
          <target state="translated">При общении с сервером используйте указанную версию протокола HTTP.Если вы хотите применить силу по умолчанию.Доступная версия и версия по умолчанию зависят от libcurl.На самом деле возможными значениями этой опции являются:</target>
        </trans-unit>
        <trans-unit id="becfdaabcf538340d904ac918eb155dd5d16c802" translate="yes" xml:space="preserve">
          <source>Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property &lt;code&gt;commiturl&lt;/code&gt;.</source>
          <target state="translated">Используйте указанный URL-адрес для подключения к целевому репозиторию Subversion. Это полезно в случаях, когда исходный репозиторий SVN доступен только для чтения. Этот параметр переопределяет свойство конфигурации &lt;code&gt;commiturl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e057e9e47493412f91dea4102ac0984cb71bdeb" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable to decide what to notice as error.</source>
          <target state="translated">Используйте значение переменной конфигурации &lt;code&gt;core.whitespace&lt;/code&gt; , чтобы решить, что считать ошибкой.</target>
        </trans-unit>
        <trans-unit id="810f8c03feb9550dd6740190f543dbb37624e241" translate="yes" xml:space="preserve">
          <source>Use this custom program instead of &quot;&lt;code&gt;gpg&lt;/code&gt;&quot; found on &lt;code&gt;$PATH&lt;/code&gt; when making or verifying a PGP signature. The program must support the same command-line interface as GPG, namely, to verify a detached signature, &quot;&lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt;&quot; is run, and the program is expected to signal a good signature by exiting with code 0, and to generate an ASCII-armored detached signature, the standard input of &quot;&lt;code&gt;gpg -bsau $key&lt;/code&gt;&quot; is fed with the contents to be signed, and the program is expected to send the result to its standard output.</source>
          <target state="translated">Используйте эту специальную программу вместо &quot; &lt;code&gt;gpg&lt;/code&gt; &quot; в &lt;code&gt;$PATH&lt;/code&gt; при создании или проверке подписи PGP. Программа должна поддерживать тот же интерфейс командной строки, что и GPG, а именно: для проверки отсоединенной подписи запускается &quot; &lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt; &quot;, и ожидается, что программа сигнализирует о хорошей подписи путем выхода с кодом. 0, и для генерации &lt;code&gt;gpg -bsau $key&lt;/code&gt; ASCII отдельной подписи на стандартный ввод &amp;laquo; gpg -bsau $ key &amp;raquo; подается подписываемое содержимое, и ожидается, что программа отправит результат на свой стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="ad85fb495e355ea9ee99bf9caef60d6a5acc4df9" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">Используйте это для совместимости с именами веток в старом стиле, используемыми более ранними версиями &lt;code&gt;git archimport&lt;/code&gt; . Имена веток в старом стиле были ветвью категории {litdd}, тогда как имена ветвей нового стиля - это версия архива, категория {litdd} ветка {litdd}. В обоих случаях имена, указанные в командной строке, заменят автоматически созданные.</target>
        </trans-unit>
        <trans-unit id="f09efb8456c99114df5272977533145bfda3715e" translate="yes" xml:space="preserve">
          <source>Use this option to integrate changes from the upstream subproject with your submodule&amp;rsquo;s current HEAD. Alternatively, you can run &lt;code&gt;git pull&lt;/code&gt; from the submodule, which is equivalent except for the remote branch name: &lt;code&gt;update --remote&lt;/code&gt; uses the default upstream repository and &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt;, while &lt;code&gt;git pull&lt;/code&gt; uses the submodule&amp;rsquo;s &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;. Prefer &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; if you want to distribute the default upstream branch with the superproject and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; if you want a more native feel while working in the submodule itself.</source>
          <target state="translated">Используйте эту опцию, чтобы интегрировать изменения из подпроекта восходящего потока с текущим HEAD вашего подмодуля. В качестве альтернативы вы можете запустить &lt;code&gt;git pull&lt;/code&gt; из подмодуля, что эквивалентно, за исключением имени удаленной ветки: &lt;code&gt;update --remote&lt;/code&gt; использует исходный репозиторий и &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; по умолчанию . &amp;lt;name&amp;gt; .branch , тогда как &lt;code&gt;git pull&lt;/code&gt; использует &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; подмодуля . &amp;lt;name&amp;gt; .merge . Предпочитайте &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; если вы хотите распространить ветвь восходящего потока по умолчанию с суперпроектом, и &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; если вы хотите более естественное ощущение при работе с самим подмодулем.</target>
        </trans-unit>
        <trans-unit id="205f9bc458a5cacd665ee1af1eac8a989bc13811" translate="yes" xml:space="preserve">
          <source>Use this option to set the namespace where the original commits will be stored. The default value is &lt;code&gt;refs/original&lt;/code&gt;.</source>
          <target state="translated">Используйте эту опцию, чтобы установить пространство имен, в котором будут храниться исходные коммиты. Значение по умолчанию - &lt;code&gt;refs/original&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="978a87da673ee3d6baf57006a070d2ceaf2e0a29" translate="yes" xml:space="preserve">
          <source>Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the &lt;code&gt;.git-rewrite/&lt;/code&gt; directory but you can override that choice by this parameter.</source>
          <target state="translated">Используйте эту опцию, чтобы установить путь к временному каталогу, используемому для перезаписи. При применении фильтра дерева команде необходимо временно извлечь дерево в какой-либо каталог, который может занимать значительное пространство в случае больших проектов. По умолчанию это делается в каталоге &lt;code&gt;.git-rewrite/&lt;/code&gt; но вы можете переопределить этот выбор с помощью этого параметра.</target>
        </trans-unit>
        <trans-unit id="7dad6966beac366ffc5d985e757265d090b93f5a" translate="yes" xml:space="preserve">
          <source>Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.</source>
          <target state="translated">Используйте этот параметр для нестабильной работы и удаления только путей из индекса.Рабочие файлы дерева,независимо от того,модифицированы они или нет,будут оставлены.</target>
        </trans-unit>
        <trans-unit id="22e3468b42fc7b02294ecbf3cdd521f378eedf7b" translate="yes" xml:space="preserve">
          <source>Use this to customize the program used for the signing format you chose. (see &lt;code&gt;gpg.program&lt;/code&gt; and &lt;code&gt;gpg.format&lt;/code&gt;) &lt;code&gt;gpg.program&lt;/code&gt; can still be used as a legacy synonym for &lt;code&gt;gpg.openpgp.program&lt;/code&gt;. The default value for &lt;code&gt;gpg.x509.program&lt;/code&gt; is &quot;gpgsm&quot;.</source>
          <target state="translated">Используйте это, чтобы настроить программу, используемую для выбранного вами формата подписи. (см. &lt;code&gt;gpg.program&lt;/code&gt; и &lt;code&gt;gpg.format&lt;/code&gt; ) &lt;code&gt;gpg.program&lt;/code&gt; все еще можно использовать как устаревший синоним &lt;code&gt;gpg.openpgp.program&lt;/code&gt; . Значение по умолчанию для &lt;code&gt;gpg.x509.program&lt;/code&gt; - &amp;laquo;gpgsm&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="2c0ec0febb1ffdfb71fd1faf1bdd4ef5cebdb7eb" translate="yes" xml:space="preserve">
          <source>Use this to specify the path to &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote side, if is not found on your $PATH. Installations of sshd ignores the user&amp;rsquo;s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in &quot;.bashrc&quot;, but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile).</source>
          <target state="translated">Используйте это, чтобы указать путь к &lt;code&gt;git-upload-pack&lt;/code&gt; на удаленной стороне, если он не найден в вашем $ PATH. При установке sshd игнорируются сценарии настройки среды пользователя для оболочек входа (например, .bash_profile), и ваш установленный частным образом git может не быть найден в системном значении $ PATH по умолчанию. Другой предлагаемый обходной путь - настроить ваш $ PATH в &quot;.bashrc&quot;, но этот флаг предназначен для людей, которые не хотят оплачивать накладные расходы на неинтерактивные оболочки, имея небольшой файл .bashrc (они устанавливают большинство вещей в .bash_profile).</target>
        </trans-unit>
        <trans-unit id="1f3cdffd9311e81ebd0ee41b41de344f546bb6a2" translate="yes" xml:space="preserve">
          <source>Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Please regard this as an experimental feature. May not contain colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;</source>
          <target state="translated">Использовал драйвер DBI. Вы можете указать здесь любой доступный драйвер, но он может не работать. cvsserver протестирован с &lt;code&gt;DBD::SQLite&lt;/code&gt; , сообщается о работе с &lt;code&gt;DBD::Pg&lt;/code&gt; и сообщается о том, что он &lt;strong&gt;не&lt;/strong&gt; работает с &lt;code&gt;DBD::mysql&lt;/code&gt; . Считайте это экспериментальной функцией. Может не содержать двоеточия ( &lt;code&gt;:&lt;/code&gt; ). По умолчанию: &lt;code&gt;SQLite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96c8aa1d6db1322edc422d5cc1ffbd12e71daed" translate="yes" xml:space="preserve">
          <source>Used Perl DBI driver. You can specify any available driver for this here, but it might not work. git-cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Experimental feature. May not contain double colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Используется драйвер Perl DBI. Вы можете указать здесь любой доступный драйвер, но он может не работать. git-cvsserver протестирован с &lt;code&gt;DBD::SQLite&lt;/code&gt; , сообщил, что работает с &lt;code&gt;DBD::Pg&lt;/code&gt; , и сообщил, что &lt;strong&gt;не&lt;/strong&gt; работает с &lt;code&gt;DBD::mysql&lt;/code&gt; . Экспериментальная особенность. Может не содержать двойное двоеточие ( &lt;code&gt;:&lt;/code&gt; ). По умолчанию: &lt;code&gt;SQLite&lt;/code&gt; . См. &lt;a href=&quot;git-cvsserver&quot;&gt;Git-cvsserver [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3dcc5e110a8886980641614ba00244bbf70eb3c6" translate="yes" xml:space="preserve">
          <source>Used as %(if)&amp;hellip;​%(then)&amp;hellip;​%(end) or %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either &quot;*&quot; or &quot; &quot; and we want to apply the &lt;code&gt;if&lt;/code&gt; condition only on the &lt;code&gt;HEAD&lt;/code&gt; ref. Append &quot;:equals=&amp;lt;string&amp;gt;&quot; or &quot;:notequals=&amp;lt;string&amp;gt;&quot; to compare the value between the %(if:&amp;hellip;​) and %(then) atoms with the given string.</source>
          <target state="translated">Используется как% (если)&amp;hellip;% (затем)&amp;hellip;% (конец) или% (если)&amp;hellip;% (затем)&amp;hellip;% (иначе)&amp;hellip;% (конец). Если есть атом со значением или строковым литералом после% (if), то печатается все, что находится после% (then), иначе, если используется атом% (else), то печатается все, что находится после% (else). Мы игнорируем пробел при оценке строки перед% (then), это полезно, когда мы используем атом% (HEAD), который печатает либо &amp;laquo;*&amp;raquo;, либо &amp;laquo;&amp;raquo;, и мы хотим применить условие &lt;code&gt;if&lt;/code&gt; только к &lt;code&gt;HEAD&lt;/code&gt; ref. Добавьте &quot;: equals = &amp;lt;string&amp;gt;&quot; или &quot;: notequals = &amp;lt;string&amp;gt;&quot;, чтобы сравнить значение между атомами% (if:&amp;hellip;) и% (then) с данной строкой.</target>
        </trans-unit>
        <trans-unit id="88972a7007de9e429d28d6bad7487052b23f9b65" translate="yes" xml:space="preserve">
          <source>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. &lt;code&gt;git bundle&lt;/code&gt; prints a list of missing commits, if any, and exits with a non-zero status.</source>
          <target state="translated">Используется для проверки того, что файл пакета действителен и будет корректно применяться к текущему репозиторию. Это включает в себя проверки самого формата пакета, а также проверку того, что предварительные требования существуют и полностью связаны в текущем репозитории. &lt;code&gt;git bundle&lt;/code&gt; выводит список отсутствующих коммитов, если таковые имеются, и завершает работу с ненулевым статусом.</target>
        </trans-unit>
        <trans-unit id="a81dfbb4b6756f63bb43c72d54c78dd02ef851d4" translate="yes" xml:space="preserve">
          <source>Used to create a bundle named &lt;code&gt;file&lt;/code&gt;. This requires the &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; arguments to define the bundle contents. &lt;code&gt;options&lt;/code&gt; contains the options specific to the &lt;code&gt;git bundle create&lt;/code&gt; subcommand.</source>
          <target state="translated">Используется для создания пакета с именем &lt;code&gt;file&lt;/code&gt; . Для этого требуются аргументы &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; для определения содержимого пакета. &lt;code&gt;options&lt;/code&gt; содержит параметры, специфичные для подкоманды &lt;code&gt;git bundle create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe127bac2ab0b61ffb60c0284f3741224c9951e1" translate="yes" xml:space="preserve">
          <source>Used to enforce or disable certificate revocation checks in cURL when http.sslBackend is set to &quot;schannel&quot;. Defaults to &lt;code&gt;true&lt;/code&gt; if unset. Only necessary to disable this if Git consistently errors and the message is about checking the revocation status of a certificate. This option is ignored if cURL lacks support for setting the relevant SSL option at runtime.</source>
          <target state="translated">Используется для принудительного применения или отключения проверок отзыва сертификатов в cURL, когда для http.sslBackend установлено значение &amp;laquo;schannel&amp;raquo;. По умолчанию &lt;code&gt;true&lt;/code&gt; , если не установлено. Это необходимо только в том случае, если Git постоянно выдает ошибки и появляется сообщение о проверке статуса отзыва сертификата. Эта опция игнорируется, если cURL не поддерживает установку соответствующей опции SSL во время выполнения.</target>
        </trans-unit>
        <trans-unit id="526891fe0801e3a16c20e50ecde492e75d4f6490" translate="yes" xml:space="preserve">
          <source>Used to set the maximum load that we will still respond to gitweb queries. If the server load exceeds this value then gitweb will return &quot;503 Service Unavailable&quot; error. The server load is taken to be 0 if gitweb cannot determine its value. Currently it works only on Linux, where it uses &lt;code&gt;/proc/loadavg&lt;/code&gt;; the load there is the number of active tasks on the system &amp;mdash; processes that are actually running &amp;mdash; averaged over the last minute.</source>
          <target state="translated">Используется для установки максимальной нагрузки, при которой мы все равно будем отвечать на запросы gitweb. Если загрузка сервера превышает это значение, gitweb вернет ошибку &amp;laquo;503 Service Unavailable&amp;raquo;. Загрузка сервера принимается равной 0, если gitweb не может определить ее значение. В настоящее время он работает только в Linux, где используется &lt;code&gt;/proc/loadavg&lt;/code&gt; ; нагрузка - это количество активных задач в системе - процессов, которые фактически выполняются, - усредненное за последнюю минуту.</target>
        </trans-unit>
        <trans-unit id="184dba4369820f49a823e624aa006f74d3fc96ef" translate="yes" xml:space="preserve">
          <source>Used with --remote to specify the path to the &lt;code&gt;git-upload-archive&lt;/code&gt; on the remote side.</source>
          <target state="translated">Используется с --remote для указания пути к &lt;code&gt;git-upload-archive&lt;/code&gt; на удаленной стороне.</target>
        </trans-unit>
        <trans-unit id="a985abb59dca2d23760f5b7ff00e7d00f2d0f353" translate="yes" xml:space="preserve">
          <source>Used with &lt;code&gt;--range-diff&lt;/code&gt;, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) for details.</source>
          <target state="translated">Используется с &lt;code&gt;--range-diff&lt;/code&gt; , настраивает эвристику, которая сопоставляет коммиты между предыдущей и текущей сериями исправлений, регулируя коэффициент ложной стоимости создания / удаления. См. &lt;a href=&quot;git-range-diff&quot;&gt;Git-range-diff [1]&lt;/a&gt; ) для подробностей.</target>
        </trans-unit>
        <trans-unit id="9777df5e2d0f3ca27a559e53074b9f39896040e8" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;fetch&lt;/code&gt; command.</source>
          <target state="translated">Используется с командой &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea99fa3d480e34606197cb808cc4a18c1d6b1306" translate="yes" xml:space="preserve">
          <source>User Manual</source>
          <target state="translated">руководство пользователя</target>
        </trans-unit>
        <trans-unit id="3d338fa6790366b9708dc60a5019a8d98f73c4b3" translate="yes" xml:space="preserve">
          <source>User configuration and preferences are stored at:</source>
          <target state="translated">Конфигурация и предпочтения пользователя хранятся в памяти:</target>
        </trans-unit>
        <trans-unit id="ba3e3bfcde6395de2671f768450f02d32f692aba" translate="yes" xml:space="preserve">
          <source>User name (e.g., &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt;). If the config key has a user name it must match the user name in the URL exactly. If the config key does not have a user name, that config key will match a URL with any user name (including none), but at a lower precedence than a config key with a user name.</source>
          <target state="translated">Имя пользователя (например, &lt;code&gt;user&lt;/code&gt; в &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt; ). Если ключ конфигурации имеет имя пользователя, оно должно точно соответствовать имени пользователя в URL-адресе. Если ключ конфигурации не имеет имени пользователя, этот ключ конфигурации будет соответствовать URL-адресу с любым именем пользователя (включая отсутствие имени), но с более низким приоритетом, чем ключ конфигурации с именем пользователя.</target>
        </trans-unit>
        <trans-unit id="9eabd3862d3bc88b6d20553afdc4c28a880bd15a" translate="yes" xml:space="preserve">
          <source>User specified as an option to all p4 commands, with &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4USER&lt;/code&gt; can be used instead.</source>
          <target state="translated">Пользователь, указанный в качестве опции для всех команд p4, с &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt; . &lt;code&gt;P4USER&lt;/code&gt; можно использовать переменную окружения P4USER .</target>
        </trans-unit>
        <trans-unit id="3129c28f60cb352aa378d9055c2dee4b71cd917d" translate="yes" xml:space="preserve">
          <source>User-specific configuration file. Also called &quot;global&quot; configuration file.</source>
          <target state="translated">Пользовательский конфигурационный файл.Также называется &quot;глобальным&quot; конфигурационным файлом.</target>
        </trans-unit>
        <trans-unit id="53b3f2b51348a1a5a4076e004425d0d150df3f8e" translate="yes" xml:space="preserve">
          <source>User-specific credentials file.</source>
          <target state="translated">Файл учетных данных пользователя.</target>
        </trans-unit>
        <trans-unit id="fbb3c5af6a1b800cb6bfa442ae5c6ae5ee1a4454" translate="yes" xml:space="preserve">
          <source>Username for SMTP-AUTH. Default is the value of &lt;code&gt;sendemail.smtpUser&lt;/code&gt;; if a username is not specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), then authentication is not attempted.</source>
          <target state="translated">Имя пользователя для SMTP-AUTH. По умолчанию используется значение &lt;code&gt;sendemail.smtpUser&lt;/code&gt; ; если имя пользователя не указано (с помощью &lt;code&gt;--smtp-user&lt;/code&gt; или &lt;code&gt;sendemail.smtpUser&lt;/code&gt; ), попытка аутентификации не выполняется.</target>
        </trans-unit>
        <trans-unit id="dd5ba62269befa999225c8d360ebd4fd64f50001" translate="yes" xml:space="preserve">
          <source>Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:</source>
          <target state="translated">Пользователи могут выбрать автоматическую стратегию слияния,используя либо опцию -s/--strategy,либо настроив notes.mergeStrategy соответственно:</target>
        </trans-unit>
        <trans-unit id="312954bd3f459a8154fbfda7b5edb71c57c929c2" translate="yes" xml:space="preserve">
          <source>Users migrating from CVS may also want to read &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Пользователи, переходящие с CVS, также могут захотеть прочитать &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2fd200f233551c846ddc52433b7473972ba45cd" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;assume unchanged&amp;rdquo; bit</source>
          <target state="translated">Использование бита &amp;laquo;считать неизменным&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="db59534f65c86c428a7a540c110ff1130d39acfc" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git add -A&amp;rdquo;</source>
          <target state="translated">Использование &amp;laquo;git add -A&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="3f756864c1cac8254338a14f16b7888b4cd11774" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git commit -a&amp;rdquo;</source>
          <target state="translated">Использование &amp;laquo;git commit -a&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="1ad6e2bdca2ef33d6f60d1165c40af77488df73e" translate="yes" xml:space="preserve">
          <source>Using --cacheinfo or --info-only</source>
          <target state="translated">Использование --cacheinfo или --info-only</target>
        </trans-unit>
        <trans-unit id="63a49bc3316ec7fe7ab1c50a106ab3c187422a12" translate="yes" xml:space="preserve">
          <source>Using --index-info</source>
          <target state="translated">Использование -индекс-информации</target>
        </trans-unit>
        <trans-unit id="9465002aca9e596e405478c595d6ec82ecf19f4d" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.</source>
          <target state="translated">Использование --recurse-подмодулей позволяет получить новые коммиты только в уже проверенных подмодулях прямо сейчас.Когда,например,восходящий подмодуль добавляется в только что извлечённые коммиты суперпроекта,сам подмодуль не может быть извлечён,что делает невозможным извлечение этого подмодуля позже без необходимости повторного извлечения.Ожидается,что это будет исправлено в будущей версии Git'а.</target>
        </trans-unit>
        <trans-unit id="3b6c4766d3d128d670a5d5adf42fc526da676a66" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all initialized submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules HEAD to be detached at that commit.</source>
          <target state="translated">Использование --recurse-подмодулей обновит содержимое всех инициализированных подмодулей в соответствии с коммитом,записанным в суперпроекте,вызвав read-tree рекурсивно,а также настроив подмодули HEAD на отсоединение при этом коммите.</target>
        </trans-unit>
        <trans-unit id="8315f077dd8f5ad49468aff013d2df68acafcb5e" translate="yes" xml:space="preserve">
          <source>Using --refresh</source>
          <target state="translated">Использование-обновление</target>
        </trans-unit>
        <trans-unit id="0565ce691b52b5953c2fb97dfb806a2f764f48e2" translate="yes" xml:space="preserve">
          <source>Using --temp or --stage=all</source>
          <target state="translated">Использование --temp или --stage=all</target>
        </trans-unit>
        <trans-unit id="509888a40362653e71adbbdc6d4e59bc0d3d4ce4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--index-filter&lt;/code&gt; with &lt;code&gt;git rm&lt;/code&gt; yields a significantly faster version. Like with using &lt;code&gt;rm filename&lt;/code&gt;, &lt;code&gt;git rm --cached filename&lt;/code&gt; will fail if the file is absent from the tree of a commit. If you want to &quot;completely forget&quot; a file, it does not matter when it entered history, so we also add &lt;code&gt;--ignore-unmatch&lt;/code&gt;:</source>
          <target state="translated">Использование &lt;code&gt;--index-filter&lt;/code&gt; с &lt;code&gt;git rm&lt;/code&gt; дает значительно более быструю версию. Как и при использовании &lt;code&gt;rm filename&lt;/code&gt; , &lt;code&gt;git rm --cached filename&lt;/code&gt; завершится ошибкой, если файл отсутствует в дереве фиксации. Если вы хотите &amp;laquo;полностью забыть&amp;raquo; файл, не имеет значения, когда он вошел в историю, поэтому мы также добавляем &lt;code&gt;--ignore-unmatch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="47e7ecf39552b28db7a0c771cb5239db7d4a81af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">Использование &lt;code&gt;--recurse-submodules&lt;/code&gt; обновит содержимое всех инициализированных подмодулей в соответствии с фиксацией, записанной в суперпроекте. Если локальные изменения в подмодуле будут перезаписаны, проверка завершится неудачно, если не используется &lt;code&gt;-f&lt;/code&gt; . Если ничего (или &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ) не используется, деревья работы подмодулей обновляться не будут. Как и в случае с &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; , это отключает &lt;code&gt;HEAD&lt;/code&gt; подмодуля.</target>
        </trans-unit>
        <trans-unit id="87e05fa35b92ebd2beac592a4000f99e52c8fa99" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">Использование &lt;code&gt;--recurse-submodules&lt;/code&gt; обновит содержимое всех инициализированных подмодулей в соответствии с фиксацией, записанной в суперпроекте. Если ничего (или &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ) не используется, деревья работы подмодулей обновляться не будут. Как и в случае с &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; , это приведет к отсоединению &lt;code&gt;HEAD&lt;/code&gt; подмодулей.</target>
        </trans-unit>
        <trans-unit id="131907fc18369579f75831dbffd3a45262caaa68" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-a&lt;/code&gt; would conflate &amp;lt;remote&amp;gt; with any local branches you happen to have been prefixed with the same &amp;lt;remote&amp;gt; pattern.</source>
          <target state="translated">Использование &lt;code&gt;-a&lt;/code&gt; объединит &amp;lt;remote&amp;gt; с любыми локальными ветвями, которые имеют префикс с тем же шаблоном &amp;lt;remote&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="bc196497d8f80228e3ec0969c92ba077224b9158" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;git checkout-index&lt;/em&gt; to &quot;export an entire tree&quot;</source>
          <target state="translated">Использование &lt;em&gt;git checkout-index&lt;/em&gt; для &amp;laquo;экспорта всего дерева&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="f145740948f023493614f8cb28fc352a33b08d80" translate="yes" xml:space="preserve">
          <source>Using a limit</source>
          <target state="translated">Используя ограничение</target>
        </trans-unit>
        <trans-unit id="0d18e7415acaf5bf1693b96116e4340271619597" translate="yes" xml:space="preserve">
          <source>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</source>
          <target state="translated">Использование другого проекта при сохранении самостоятельной истории.Субмодули позволяют содержать рабочее дерево другого проекта в собственном рабочем дереве,сохраняя при этом историю обоих проектов отдельно.Также,так как подмодули фиксируются в произвольной версии,другой проект может развиваться независимо,не затрагивая суперпроект,позволяя суперпроектному проекту фиксировать себя в новых версиях только при желании.</target>
        </trans-unit>
        <trans-unit id="03266ad998c58f3651e774794904a59499884e04" translate="yes" xml:space="preserve">
          <source>Using complex scripts</source>
          <target state="translated">Использование сложных скриптов</target>
        </trans-unit>
        <trans-unit id="9a4e17fa716627d801ba04248e7c13675c63f6bf" translate="yes" xml:space="preserve">
          <source>Using direct mode with SSL:</source>
          <target state="translated">Использование прямого режима с SSL:</target>
        </trans-unit>
        <trans-unit id="80be60b71aa62e009a5472e7b71ecca69fb605f2" translate="yes" xml:space="preserve">
          <source>Using direct mode:</source>
          <target state="translated">Использование прямого режима:</target>
        </trans-unit>
        <trans-unit id="1c1bc19943239ea53498134ee5024657c6f7482f" translate="yes" xml:space="preserve">
          <source>Using git for collaboration</source>
          <target state="translated">Использование git для сотрудничества</target>
        </trans-unit>
        <trans-unit id="e742dd237e897f0c09d1168ed38eeca1316d409b" translate="yes" xml:space="preserve">
          <source>Using interactive rebases</source>
          <target state="translated">Использование интерактивных скидок</target>
        </trans-unit>
        <trans-unit id="16c9cb76d4ea0981714eee54828fc3305174e2d5" translate="yes" xml:space="preserve">
          <source>Using macro attributes</source>
          <target state="translated">Использование макроатрибутов</target>
        </trans-unit>
        <trans-unit id="0bcad514939a1a512d30defc1dd83a6988408bd1" translate="yes" xml:space="preserve">
          <source>Using more options generally further limits the output (e.g. &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; limits to commits newer than &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt;, and using it with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; further limits to commits whose log message has a line that matches &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;), unless otherwise noted.</source>
          <target state="translated">Использование большего количества параметров обычно дополнительно ограничивает вывод (например, &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; ограничивает коммиты новее, чем &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt; , а использование его с &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; - дополнительные ограничения для коммитов, в сообщении журнала которых есть строка, которая соответствует &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; date1&amp;gt; pattern&amp;gt; ), если не указано иное.</target>
        </trans-unit>
        <trans-unit id="aab9e25047cbd960c71a3d6743c695a0fbcee99d" translate="yes" xml:space="preserve">
          <source>Using refspecs explicitly:</source>
          <target state="translated">Используя реффиксы в явном виде:</target>
        </trans-unit>
        <trans-unit id="e240eb205361a2a50754a2cbbad5230917e3c8f6" translate="yes" xml:space="preserve">
          <source>Using test suites and git bisect together</source>
          <target state="translated">Использование тестовых наборов и гит-бисектов вместе.</target>
        </trans-unit>
        <trans-unit id="8fdfb0e1e33426ffa586ab6e967bc34118a45d25" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--submodule=log&lt;/code&gt; option with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too.</source>
          <target state="translated">Использование &lt;code&gt;--submodule=log&lt;/code&gt; с &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; также предоставит эту информацию.</target>
        </trans-unit>
        <trans-unit id="d42f8d8f39d5c1ce54e65e242137998175012054" translate="yes" xml:space="preserve">
          <source>Using these options, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; will act similar to the more specialized family of commit log tools: &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;</source>
          <target state="translated">Используя эти параметры, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; будет действовать аналогично более специализированному семейству инструментов журнала фиксации: &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; и &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a34d360db274a11502bc402ef7758f2bc5adf11b" translate="yes" xml:space="preserve">
          <source>Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt;, or find a helper that integrates with secure storage provided by your operating system.</source>
          <target state="translated">Использование этого помощника сохранит ваши пароли в незашифрованном виде на диске, защищенном только разрешениями файловой системы. Если это недопустимый компромисс в плане безопасности, попробуйте &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]&lt;/a&gt; или найдите помощника, который интегрируется с безопасным хранилищем, предоставляемым вашей операционной системой.</target>
        </trans-unit>
        <trans-unit id="86d0ca06bdb5a3aacec696a9b10115a302a90ea4" translate="yes" xml:space="preserve">
          <source>Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:</source>
          <target state="translated">С помощью этого крючка можно легко генерировать письма с описанием обновлений в репозитории.Этот пример скрипта посылает по одному почтовому сообщению на каждый реферат со списком коммитов,отправленных в репозиторий,и записывает в журнал толкающие сертификаты подписанных коммитов с хорошими подписями в службу регистрации:</target>
        </trans-unit>
        <trans-unit id="7ae98ad0643543d139a0ccded2d96be6c57e816c" translate="yes" xml:space="preserve">
          <source>Using this option for any other purpose (don&amp;rsquo;t ask) is very strongly discouraged.</source>
          <target state="translated">Использование этой опции для любых других целей (не спрашивайте) очень не рекомендуется.</target>
        </trans-unit>
        <trans-unit id="ebe89d9e15d8a582f6b4a48c6c03d60cf9c673f1" translate="yes" xml:space="preserve">
          <source>Using tunnel mode:</source>
          <target state="translated">Использование туннельного режима:</target>
        </trans-unit>
        <trans-unit id="f17a1449e9ed80dcff59f550977b6693d42b10bf" translate="yes" xml:space="preserve">
          <source>Usual 3-way file level merge for text files. Conflicted regions are marked with conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The version from your branch appears before the &lt;code&gt;=======&lt;/code&gt; marker, and the version from the merged branch appears after the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">Обычное трехстороннее слияние на уровне файлов для текстовых файлов. Конфликтующие регионы отмечены маркерами конфликта &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; . Версия из вашей ветки отображается перед маркером &lt;code&gt;=======&lt;/code&gt; , а версия из объединенной ветки появляется после маркера &lt;code&gt;=======&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cb51fab051882aaba81e0715d7acfa80e2ce09c" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;git gc&lt;/code&gt; runs very quickly while providing good disk space utilization and performance. This option will cause &lt;code&gt;git gc&lt;/code&gt; to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the &quot;AGGRESSIVE&quot; section below for details.</source>
          <target state="translated">Обычно &lt;code&gt;git gc&lt;/code&gt; работает очень быстро, обеспечивая хорошее использование дискового пространства и производительность. Эта опция заставит &lt;code&gt;git gc&lt;/code&gt; более агрессивно оптимизировать репозиторий за счет гораздо большего количества времени. Эффект от этой оптимизации в основном устойчивый. См. Подробности в разделе &amp;laquo;АГРЕССИВНЫЙ&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="da9e2cbf852524ee1edb371514af799c05f82c93" translate="yes" xml:space="preserve">
          <source>Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.</source>
          <target state="translated">Обычно для слияния требуется,чтобы индексный файл,а также файлы в рабочем дереве были актуальны с текущей фиксацией заголовка,чтобы не потерять локальные изменения.Этот флаг отключает проверку с рабочим деревом и предназначен для использования при создании слияния деревьев,не имеющих прямого отношения к текущему состоянию рабочего дерева,во временный индексный файл.</target>
        </trans-unit>
        <trans-unit id="27214bb5573e76f1f8a1f21396536681c10927d6" translate="yes" xml:space="preserve">
          <source>Usually a three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:</source>
          <target state="translated">Обычно трехстороннее слияние с помощью &lt;code&gt;git read-tree&lt;/code&gt; разрешает слияние для действительно тривиальных случаев и оставляет другие случаи нерешенными в индексе, чтобы фарфор мог реализовать разные политики слияния. Этот флаг заставляет команду разрешить еще несколько случаев внутренне:</target>
        </trans-unit>
        <trans-unit id="1a018c180f83561166ef04fc1c1b049dd7bef5e3" translate="yes" xml:space="preserve">
          <source>Usually given &quot;&amp;lt;feature&amp;gt;&quot; is configurable via the &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config variable in the per-repository Git configuration file.</source>
          <target state="translated">Обычно данный параметр &quot;&amp;lt;feature&amp;gt;&quot; настраивается с помощью &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; конфигурации gitweb. &amp;lt;feature&amp;gt; в файле конфигурации Git для каждого репозитория.</target>
        </trans-unit>
        <trans-unit id="06bd62b74600c2b58fc5390378d7102461c2b477" translate="yes" xml:space="preserve">
          <source>Usually it is easier to configure any desired options through your personal &lt;code&gt;.ssh/config&lt;/code&gt; file. Please consult your ssh documentation for further details.</source>
          <target state="translated">Обычно проще настроить любые желаемые параметры через ваш личный файл &lt;code&gt;.ssh/config&lt;/code&gt; . Дополнительные сведения см. В документации по ssh.</target>
        </trans-unit>
        <trans-unit id="e92c22e35ceb9b2c8da5295a992718e30d5c9f60" translate="yes" xml:space="preserve">
          <source>Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.</source>
          <target state="translated">Обычно запись коммита,который имеет точно такое же дерево,как и его единственный родительский коммит,является ошибкой,и команда не позволяет вам сделать такой коммит.Эта опция обходит безопасность,и предназначена,в первую очередь,для использования иностранными скриптами интерфейса SCM.</target>
        </trans-unit>
        <trans-unit id="8ce3f0d516dc2a9d67b8e4ba143055eaf7bab452" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.</source>
          <target state="translated">Обычно команда автоматически создает последовательность коммитов.Этот флаг применяет изменения,необходимые для фиксации каждого именованного коммита в вашем рабочем дереве и индексе,без фиксации.Кроме того,при использовании этого параметра ваш индекс не должен совпадать с HEAD-комитом.Выбор вишни делается против начального состояния вашего индекса.</target>
        </trans-unit>
        <trans-unit id="55875ee1e78ad1cfc5a25d1e098bc17781327203" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.</source>
          <target state="translated">Обычно команда автоматически создает несколько коммитов с сообщениями журнала коммитов,в которых указывается,какие коммиты были возвращены.Этот флаг применяет изменения,необходимые для возврата именованных коммитов в ваше рабочее дерево и индекс,но не делает коммитов.Кроме того,при использовании этого параметра,ваш индекс не должен совпадать с HEAD коммитом.Возврат осуществляется против начального состояния вашего индекса.</target>
        </trans-unit>
        <trans-unit id="51d5f6e8faedb5ef4d1204f14e2f7ab2d7b77eaf" translate="yes" xml:space="preserve">
          <source>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go &amp;lt;n&amp;gt; more common commits beyond that. When &amp;lt;n&amp;gt; is negative, display only the &amp;lt;reference&amp;gt;s given, without showing the commit ancestry tree.</source>
          <target state="translated">Обычно команда останавливает вывод после отображения фиксации, которая является общим предком всех ветвей. Этот флаг указывает команде на &amp;lt;n&amp;gt; более частых коммитов сверх этого. Когда &amp;lt;n&amp;gt; отрицательно, отображать только данные &amp;lt;reference&amp;gt; без отображения дерева предков фиксации.</target>
        </trans-unit>
        <trans-unit id="29097abe7ecd686605680556737a55dc5b7468af" translate="yes" xml:space="preserve">
          <source>Usually the object names are output in SHA-1 form (with possible &lt;code&gt;^&lt;/code&gt; prefix); this option makes them output in a form as close to the original input as possible.</source>
          <target state="translated">Обычно имена объектов выводятся в форме SHA-1 (с возможным префиксом &lt;code&gt;^&lt;/code&gt; ); эта опция заставляет их выводить в форме, максимально приближенной к исходной.</target>
        </trans-unit>
        <trans-unit id="576f849692364345fa924f476c3413707294c315" translate="yes" xml:space="preserve">
          <source>Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe &lt;code&gt;-S&lt;/code&gt; with &lt;code&gt;git diff-*&lt;/code&gt;). In contrast to the &lt;code&gt;--sq-quote&lt;/code&gt; option, the command input is still interpreted as usual.</source>
          <target state="translated">Обычно вывод осуществляется по одной строке на каждый флаг и параметр. Эта опция делает вывод одной строкой, правильно цитируемой для использования оболочкой. Полезно, когда вы ожидаете, что ваш параметр будет содержать пробелы и символы новой строки (например, при использовании &lt;code&gt;git diff-*&lt;/code&gt; &lt;code&gt;-S&lt;/code&gt; с git diff- * ). В отличие от &lt;code&gt;--sq-quote&lt;/code&gt; , ввод команды по-прежнему интерпретируется как обычно.</target>
        </trans-unit>
        <trans-unit id="52303fe63fddea8a07d49fe1df917ff950ba6541" translate="yes" xml:space="preserve">
          <source>Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back &lt;code&gt;git format-patch -k&lt;/code&gt; output.</source>
          <target state="translated">Обычно программа удаляет мусор электронной почты из строки заголовка Subject :, чтобы извлечь строку заголовка для сообщения журнала фиксации. Эта опция предотвращает эту путаницу и наиболее полезна при использовании для чтения вывода &lt;code&gt;git format-patch -k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12904fba6e8c31d350b5463557502fba670802b3" translate="yes" xml:space="preserve">
          <source>Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.</source>
          <target state="translated">Обычно вы не можете выбрать слияние,потому что не знаете,какую сторону слияния следует считать главной.Эта опция задает родительский номер (начиная с 1)главной линии и позволяет cherry-pick переиграть изменение относительно указанного родителя.</target>
        </trans-unit>
        <trans-unit id="8ec09d5ac366ce3cd2a5e3c6c67d0b4fe311e4bf" translate="yes" xml:space="preserve">
          <source>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</source>
          <target state="translated">Обычно вы не можете вернуть слияние,потому что не знаете,какую сторону слияния следует считать основной.Эта опция задает родительский номер (начиная с 1)основной линии и позволяет вернуть изменение относительно указанного родителя.</target>
        </trans-unit>
        <trans-unit id="6969d1a350dfc3fafb277e2e6995e5ac7a289ac5" translate="yes" xml:space="preserve">
          <source>Usually you should not need to change (adjust) any of configuration variables described below; they should be automatically set by gitweb to correct value.</source>
          <target state="translated">Обычно нет необходимости изменять (корректировать)какие-либо из описанных ниже конфигурационных переменных;они должны автоматически устанавливаться gitweb для коррекции значения.</target>
        </trans-unit>
        <trans-unit id="b172c85defacdb686b541793ef9e8aeee0cdf60e" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git fetch&lt;/code&gt;, which is a higher level wrapper of this command, instead.</source>
          <target state="translated">Обычно вместо этого вы хотите использовать &lt;code&gt;git fetch&lt;/code&gt; , который является оболочкой более высокого уровня для этой команды.</target>
        </trans-unit>
        <trans-unit id="bec645de31c299cb10f93b6253e1e1669a5f0a31" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git push&lt;/code&gt;, which is a higher-level wrapper of this command, instead. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">Обычно вместо этого вы хотите использовать &lt;code&gt;git push&lt;/code&gt; , который является оболочкой более высокого уровня для этой команды. См. &lt;a href=&quot;git-push&quot;&gt;Git-push [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5982263578e4f00875c00a40da810fe92911cebc" translate="yes" xml:space="preserve">
          <source>Usually, &quot;git push&quot; refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.</source>
          <target state="translated">Обычно,&quot;git push&quot; отказывается обновлять удалённый рефлекс,который не является предком локального рефлекса,используемого для его перезаписи.</target>
        </trans-unit>
        <trans-unit id="f8497b6ab754b20f8d36f9efb8dfea581706bc5d" translate="yes" xml:space="preserve">
          <source>Usually, dangling blobs and trees aren&amp;rsquo;t very interesting. They&amp;rsquo;re almost always the result of either being a half-way mergebase (the blob will often even have the conflict markers from a merge in it, if you have had conflicting merges that you fixed up by hand), or simply because you interrupted a &lt;code&gt;git fetch&lt;/code&gt; with ^C or something like that, leaving &lt;code&gt;some&lt;/code&gt; of the new objects in the object database, but just dangling and useless.</source>
          <target state="translated">Обычно свисающие капли и деревья не очень интересны. Они почти всегда являются результатом либо наполовину базы слияния (в большом двоичном объекте часто даже присутствуют маркеры конфликта от слияния, если у вас были конфликтующие слияния, которые вы исправили вручную), либо просто потому, что вы прервали &lt;code&gt;git fetch&lt;/code&gt; с ^ C или что - то в этом роде, в результате чего &lt;code&gt;some&lt;/code&gt; из новых объектов в базе данных объектов, а просто болтается и бесполезно.</target>
        </trans-unit>
        <trans-unit id="ebecb811fcb50ea2c9e80ad196b73df5b02ee5fc" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when &lt;code&gt;--force-with-lease&lt;/code&gt; option is used, the command refuses to update a remote ref whose current value does not match what is expected.</source>
          <target state="translated">Обычно команда отказывается обновлять удаленную ссылку, которая не является предком локальной ссылки, используемой для ее перезаписи. Кроме того, когда используется опция &lt;code&gt;--force-with-lease&lt;/code&gt; , команда отказывается обновлять удаленную ссылку, текущее значение которой не соответствует ожидаемому.</target>
        </trans-unit>
        <trans-unit id="1039e5d0aca0474d85bb0cc56a14c21769cd56ed" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care.</source>
          <target state="translated">Обычно команда отказывается обновлять удаленный отказ,который не является предком локального отказа,используемого для его перезаписи.Этот флаг отключает проверку.Это означает,что удалённое хранилище может потерять коммиты;используйте его с осторожностью.</target>
        </trans-unit>
        <trans-unit id="b573cab97a4c7ff4e65c78f089627a289eeb14b6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;'s include:</source>
          <target state="translated">Допустимые значения &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; включают:</target>
        </trans-unit>
        <trans-unit id="2f441e23dc9e42a84676feea9743dbd62f2c9b12" translate="yes" xml:space="preserve">
          <source>Valid object types are:</source>
          <target state="translated">Действительные типы объектов:</target>
        </trans-unit>
        <trans-unit id="9b5bd1c32c0119d43f13ecb3f634510bb032afd7" translate="yes" xml:space="preserve">
          <source>Validate packed Git archive files</source>
          <target state="translated">Проверять упакованы файлы Git-архива</target>
        </trans-unit>
        <trans-unit id="c95efe4a20b3c90ba09bca423cb347dacda4f997" translate="yes" xml:space="preserve">
          <source>Validates the GPG signature created by &lt;code&gt;git commit -S&lt;/code&gt;.</source>
          <target state="translated">Проверяет подпись GPG, созданную &lt;code&gt;git commit -S&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee833db09826b15f6656c228fc09101a4d262c96" translate="yes" xml:space="preserve">
          <source>Validates the gpg signature created by &lt;code&gt;git tag&lt;/code&gt;.</source>
          <target state="translated">Проверяет подпись gpg, созданную &lt;code&gt;git tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="38ecbfb58a1b4075db82e349628396bb680485d8" translate="yes" xml:space="preserve">
          <source>Values for other tools can be used if there is a corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration entry (see below).</source>
          <target state="translated">Значения для других инструментов можно использовать при наличии соответствующей записи конфигурации &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="4590af9796b7774b94529a47844bbbd8cd70381f" translate="yes" xml:space="preserve">
          <source>Values obtained in later configuration files override values obtained earlier in the above sequence.</source>
          <target state="translated">Значения,полученные в последующих конфигурационных файлах,переопределяют значения,полученные ранее в указанной последовательности.</target>
        </trans-unit>
        <trans-unit id="42a2c91c112ab20fb86d229e79049c16aac8f47b" translate="yes" xml:space="preserve">
          <source>Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them.</source>
          <target state="translated">Значения многих переменных рассматриваются как простая строка,но есть переменные,которые берут значения определенных типов,и есть правила,как они пишутся.</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="translated">переменная замена</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="36ae09eeb0daa8ef3fa73e86b507f064c6f1150e" translate="yes" xml:space="preserve">
          <source>Various Git commands use the following environment variables:</source>
          <target state="translated">Различные команды Git'а используют следующие переменные окружения:</target>
        </trans-unit>
        <trans-unit id="c808db304a88e67e4d99602bde96a3fd73a86c36" translate="yes" xml:space="preserve">
          <source>Various aspects of gitweb&amp;rsquo;s behavior can be controlled through the configuration file &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See the &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details.</source>
          <target state="translated">Различные аспекты поведения gitweb можно контролировать с помощью файла конфигурации &lt;code&gt;gitweb_config.perl&lt;/code&gt; или &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; . Подробности смотрите в &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="514c3adc237433a43f04caf698ef6f51638f8f03" translate="yes" xml:space="preserve">
          <source>Various commands read from the configuration file and adjust their operation accordingly. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a list and more details about the configuration mechanism.</source>
          <target state="translated">Различные команды читают из файла конфигурации и соответствующим образом корректируют свою работу. См. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; для получения списка и более подробной информации о механизме конфигурации.</target>
        </trans-unit>
        <trans-unit id="9d741cda072f8e825584f9d44fb913d01a1b3645" translate="yes" xml:space="preserve">
          <source>Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.</source>
          <target state="translated">Различные значения из структурированных полей в ссылающихся объектах могут быть использованы для интерполяции в результирующий вывод или в качестве клавиш сортировки.</target>
        </trans-unit>
        <trans-unit id="0e52597805b02b27bbf6fa8afb053d38cd1cf9a2" translate="yes" xml:space="preserve">
          <source>Various ways to check your working tree</source>
          <target state="translated">Различные способы проверить ваше рабочее дерево</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">Вербоскопический выход.</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="1eee329978eae57e0140879a7cb5a19a8e448f4c" translate="yes" xml:space="preserve">
          <source>Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.</source>
          <target state="translated">Вербально отображает информацию о применяемой стратегии поиска до стандартной ошибки.Имя тега все равно будет распечатано в соответствии со стандартом.</target>
        </trans-unit>
        <trans-unit id="17eca013b0d71c76732d4067f559197bffc5dc5a" translate="yes" xml:space="preserve">
          <source>Verbosity: let &lt;code&gt;cvsimport&lt;/code&gt; report what it is doing.</source>
          <target state="translated">Подробность: пусть &lt;code&gt;cvsimport&lt;/code&gt; сообщает, что он делает.</target>
        </trans-unit>
        <trans-unit id="43241483b8c2e2b351480246076bc9d9d3aeeb38" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database</source>
          <target state="translated">Проверяет подключение и достоверность объектов в БД.</target>
        </trans-unit>
        <trans-unit id="083f6e6fa7581860cb22a12637eec790f2c234d9" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database.</source>
          <target state="translated">Проверяет подключение и достоверность объектов в БД.</target>
        </trans-unit>
        <trans-unit id="121ce6e2fb35359b4c456b6cab91a3389a1154d2" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; zero or missing, the ref must not exist.</source>
          <target state="translated">Сравните &amp;lt;ref&amp;gt; с &amp;lt;oldvalue&amp;gt;, но не меняйте его. Если &amp;lt;oldvalue&amp;gt; ноль или отсутствует, ссылка не должна существовать.</target>
        </trans-unit>
        <trans-unit id="f2a6ea4dcf4e13700439c2c62eb9c887c3645654" translate="yes" xml:space="preserve">
          <source>Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted.</source>
          <target state="translated">Убедитесь,что все,до чего можно добраться от цели,получено.Используется после того,как ранняя добыча прервана.</target>
        </trans-unit>
        <trans-unit id="dc19dfe6277cd8889c0ce32fc30714a767c456fd" translate="yes" xml:space="preserve">
          <source>Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.</source>
          <target state="translated">Убедитесь,что предоставлен ровно один параметр,и что его можно превратить в необработанный 20-байтовый SHA-1,который можно использовать для доступа к объектной базе данных.Если да,то излучите его в стандартный выходной сигнал;в противном случае ошибка будет устранена.</target>
        </trans-unit>
        <trans-unit id="e921c65f691e2b371e3e29dc398bb292612d2860" translate="yes" xml:space="preserve">
          <source>Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.</source>
          <target state="translated">Убедитесь,что фиксация подсказки сливаемой боковой ветки подписана действительным ключом,т.е.ключом,который имеет действительный uid:в модели доверия по умолчанию это означает,что ключ подписи был подписан доверенным ключом.Если фиксация tip-фиса бокового ответвления не подписана действительным ключом,слияние прерывается.</target>
        </trans-unit>
        <trans-unit id="baf3600caf9cbc675ef33fe6c51f69bd006b47ea" translate="yes" xml:space="preserve">
          <source>Verify the GPG signature of the given tag names.</source>
          <target state="translated">Убедитесь,что GPG подпись данных имен тегов.</target>
        </trans-unit>
        <trans-unit id="2977304de3538ddff5d274481548280fa86926b6" translate="yes" xml:space="preserve">
          <source>Verify the MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">Проверьте MIDX-файл для пакетных файлов в текущей папке .git.</target>
        </trans-unit>
        <trans-unit id="593811a1bcc6cbc445bcfa7fdf52e4a760c41784" translate="yes" xml:space="preserve">
          <source>Verify the contents of the MIDX file.</source>
          <target state="translated">Проверьте содержимое MIDX-файла.</target>
        </trans-unit>
        <trans-unit id="63de76d12bfde7fe2c14402fe2f03160cc3a7318" translate="yes" xml:space="preserve">
          <source>Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:</source>
          <target state="translated">Формат фарфора версии 1 аналогичен короткому,но гарантированно не изменяется в обратном направлении между версиями Git'а или на основе пользовательских настроек.Это делает его идеальным для парсинга по скриптам.Описание короткого формата,приведённое выше,также описывает фарфоровый формат,за некоторыми исключениями:</target>
        </trans-unit>
        <trans-unit id="33e409adcd5a97d5085c0477fcb4b42dc9a034a9" translate="yes" xml:space="preserve">
          <source>Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.</source>
          <target state="translated">Формат версии 2 добавляет более подробную информацию о состоянии рабочего дерева и измененных элементах.Версия 2 также определяет расширяемый набор удобных для разбора дополнительных заголовков.</target>
        </trans-unit>
        <trans-unit id="2b8063c91f48f5daba279d42a4965f292b8198dd" translate="yes" xml:space="preserve">
          <source>Version 2 pack-*.idx files support packs larger than 4 gib, and</source>
          <target state="translated">Файлы версии 2 pack-*.idx поддерживают пакеты размером более 4 гигабайт,и</target>
        </trans-unit>
        <trans-unit id="5a28a75eceea6b3fb1730e69daff64901cead811" translate="yes" xml:space="preserve">
          <source>Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet.</source>
          <target state="translated">Версия 4 выполняет простое сжатие pathname,которое уменьшает размер индекса на 30%-50% на больших репозиториях,что приводит к более быстрой загрузке.Версия 4 относительно молодая (впервые выпущена в 1.8.0 в октябре 2012 года).Другие реализации Git'а,такие как JGit и libgit2,могут его пока не поддерживать.</target>
        </trans-unit>
        <trans-unit id="5b61ffa7c699cf77c98fcf76236048d42ca5d233" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">Версия &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc1164df4f366b4e06ce848f94e3799671648de" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">Версия &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26980b77b1e7ef480646032aebce78732551db11" translate="yes" xml:space="preserve">
          <source>Versions of Git older than 1.7.7 don&amp;rsquo;t know about the &lt;code&gt;tar.gz&lt;/code&gt; format, you&amp;rsquo;ll need to use gzip explicitly:</source>
          <target state="translated">Версии Git старше 1.7.7 не знают о формате &lt;code&gt;tar.gz&lt;/code&gt; , вам нужно явно использовать gzip:</target>
        </trans-unit>
        <trans-unit id="48cda44638e8ce2f3c6e764951e4cd137e88bacc" translate="yes" xml:space="preserve">
          <source>Via the alternates mechanism, a &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can inherit part of its &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; from another object database, which is called an &quot;alternate&quot;.</source>
          <target state="translated">С помощью альтернативного механизма &lt;a href=&quot;#def_repository&quot;&gt;репозиторий&lt;/a&gt; может наследовать часть своей &lt;a href=&quot;#def_object_database&quot;&gt;объектной базы данных&lt;/a&gt; от другой объектной базы данных, которая называется &amp;laquo;альтернативной&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d75bfce3768015c62af9c4bd29fd7cad894764e0" translate="yes" xml:space="preserve">
          <source>Viewing everything that was changed in a revision, and step through revisions one at a time, viewing the history of the repository.</source>
          <target state="translated">Просмотр всего,что было изменено в ревизии,и прохождение ревизий по одной,просмотр истории хранилища.</target>
        </trans-unit>
        <trans-unit id="8e797001d4524362e7db8f18210266901eb28403" translate="yes" xml:space="preserve">
          <source>Viewing files in GUI tools</source>
          <target state="translated">Просмотр файлов в GUI инструментах</target>
        </trans-unit>
        <trans-unit id="05c33ea7de1cccd62a72042e46bec3b3d340cf9f" translate="yes" xml:space="preserve">
          <source>Viewing multiple Git repositories with common root.</source>
          <target state="translated">Просмотр нескольких Git-репозиториев с общим корнем.</target>
        </trans-unit>
        <trans-unit id="1439a80405107c5dd4ca129513bf97eb92ca8c3f" translate="yes" xml:space="preserve">
          <source>Viewing old file versions</source>
          <target state="translated">Просмотр старых версий файлов</target>
        </trans-unit>
        <trans-unit id="cba1ab24737b9af4081eae74baa579853869959f" translate="yes" xml:space="preserve">
          <source>Viewing project history</source>
          <target state="translated">Просмотр истории проекта</target>
        </trans-unit>
        <trans-unit id="48e788f7b4905bc5801452134707bb74e1fddd3c" translate="yes" xml:space="preserve">
          <source>Viewing the blame/annotation details of any file (if enabled).</source>
          <target state="translated">Просмотр информации об авторстве/нотации любого файла (если включено).</target>
        </trans-unit>
        <trans-unit id="afd57038f9956faea3beadae2f663a8f18e1dd6a" translate="yes" xml:space="preserve">
          <source>Viewing the contents of files in the repository at any revision.</source>
          <target state="translated">Просмотр содержимого файлов в хранилище при любой ревизии.</target>
        </trans-unit>
        <trans-unit id="79e8c237bcc343324671ba4de89f13c4632b7437" translate="yes" xml:space="preserve">
          <source>Viewing the revision log of branches, history of files and directories, see what was changed when, by who.</source>
          <target state="translated">Просмотр журнала ревизий ветвей,истории файлов и каталогов,посмотреть,что было изменено когда,кем.</target>
        </trans-unit>
        <trans-unit id="5d3b4279714ad2970a30b9dfdfce1d9cde0d271d" translate="yes" xml:space="preserve">
          <source>Voila.</source>
          <target state="translated">Voila.</target>
        </trans-unit>
        <trans-unit id="f7dda342bfe7129409283096bf9eae6889a3617d" translate="yes" xml:space="preserve">
          <source>Waiting $&amp;lt;int&amp;gt; seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; configuration variable.</source>
          <target state="translated">Ожидание $ &amp;lt;int&amp;gt; секунд перед повторным подключением к SMTP-серверу. Используется вместе с параметром --batch-size. По умолчанию &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; конфигурационная переменная sendemail.smtpReloginDelay .</target>
        </trans-unit>
        <trans-unit id="6abfc589b188840a4520edd8282e2221d54aed84" translate="yes" xml:space="preserve">
          <source>Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. &lt;code&gt;git blame --reverse START&lt;/code&gt; is taken as &lt;code&gt;git blame
--reverse START..HEAD&lt;/code&gt; for convenience.</source>
          <target state="translated">Идите по истории вперед, а не назад. Вместо того, чтобы показывать ревизию, в которой появилась строка, это показывает последнюю ревизию, в которой существовала строка. Для этого требуется ряд изменений, например START..END, где виновный путь существует в START. &lt;code&gt;git blame --reverse START&lt;/code&gt; для удобства используется как &lt;code&gt;git blame --reverse START..HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="246770a4db6a59723366cd008c0806351012631a" translate="yes" xml:space="preserve">
          <source>Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about.</source>
          <target state="translated">Пройдитесь по патчам серии и предупредите,если мы не сможем найти всю необходимую информацию для фиксации патча.На момент написания этой статьи предупреждается только об отсутствующей информации об авторе.</target>
        </trans-unit>
        <trans-unit id="8741434725596a0a6dcba1ea6ce0540165fbeb38" translate="yes" xml:space="preserve">
          <source>Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.</source>
          <target state="translated">Предупреждать, если изменения приводят к появлению маркеров конфликта или ошибок пробелов. То, что считается &lt;code&gt;core.whitespace&lt;/code&gt; пробелов, контролируется конфигурацией core.whitespace . По умолчанию завершающие пробелы (включая строки, состоящие исключительно из пробелов) и символ пробела, за которым сразу же следует символ табуляции внутри начального отступа строки, считаются ошибками пробелов. Выход с ненулевым статусом при обнаружении проблем. Не совместим с --exit-code.</target>
        </trans-unit>
        <trans-unit id="d0219dea42624b30174e17cfd1bb37d7d1a042a1" translate="yes" xml:space="preserve">
          <source>Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, or &lt;code&gt;quoted-printable&lt;/code&gt;) is used; this is due to SMTP limits as described by &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt;.</source>
          <target state="translated">Предупреждать о патчах, которые содержат строки длиннее 998 символов, если не используется подходящая кодировка передачи ( &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; или &lt;code&gt;quoted-printable&lt;/code&gt; ); это связано с ограничениями SMTP, описанными в &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="d9a62a2598117c2be58c53a722de6576cd225a89" translate="yes" xml:space="preserve">
          <source>Warnings are printed on the standard error output for any explicitly unsupported constructs, and any other lines that are not recognized by the parser.</source>
          <target state="translated">Предупреждения выводятся на стандартный вывод ошибок для любых явно неподдерживаемых конструкций,а также для любых других строк,которые не распознаются синтаксическим анализатором.</target>
        </trans-unit>
        <trans-unit id="54490e8680807566a4db5e14166b54af9ee18d68" translate="yes" xml:space="preserve">
          <source>We already saw in &lt;a href=&quot;#understanding-commits&quot;&gt;Understanding History: Commits&lt;/a&gt; that all commits are stored under a 40-digit &quot;object name&quot;. In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others:</source>
          <target state="translated">Мы уже видели в &amp;laquo; &lt;a href=&quot;#understanding-commits&quot;&gt;Понимании истории:&lt;/a&gt; коммиты&amp;raquo;, что все коммиты хранятся под 40-значным &amp;laquo;именем объекта&amp;raquo;. Фактически, вся информация, необходимая для представления истории проекта, хранится в объектах с такими именами. В каждом случае имя вычисляется путем взятия хэша SHA-1 содержимого объекта. Хэш SHA-1 - это криптографическая хеш-функция. Для нас это означает, что невозможно найти два разных объекта с одинаковым именем. Это имеет ряд преимуществ; среди прочего:</target>
        </trans-unit>
        <trans-unit id="d6fd523936a98d1231393ad2931c9779a4d79b0e" translate="yes" xml:space="preserve">
          <source>We are looking for a &quot;best&quot; explanation of the new series in terms of the old one. We can represent an &quot;explanation&quot; as an edge in the graph:</source>
          <target state="translated">Мы ищем &quot;лучшее&quot; объяснение новой серии с точки зрения старой.Мы можем представить &quot;объяснение&quot; в виде края на графике:</target>
        </trans-unit>
        <trans-unit id="9b940c15e60e8d5e30f8f0dd6fb317eefa03a3c7" translate="yes" xml:space="preserve">
          <source>We assume that GITWEB_CONFIG has its default Makefile value, namely &lt;code&gt;gitweb_config.perl&lt;/code&gt;. Put the following in &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; file:</source>
          <target state="translated">Мы предполагаем, что GITWEB_CONFIG имеет значение Makefile по умолчанию, а именно &lt;code&gt;gitweb_config.perl&lt;/code&gt; . Поместите в файл &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; следующее :</target>
        </trans-unit>
        <trans-unit id="860f449f084465687d5f3065e9dcdf4471fe0c53" translate="yes" xml:space="preserve">
          <source>We assume the following in /etc/services</source>
          <target state="translated">Мы предполагаем следующее в /etc/services</target>
        </trans-unit>
        <trans-unit id="e666201c4a3affd420bf339541f1e66f556269f5" translate="yes" xml:space="preserve">
          <source>We assume you have already created a Git repository for your project, possibly created from scratch or from a tarball (see &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;), or imported from an already existing CVS repository (see the next section).</source>
          <target state="translated">Мы предполагаем, что вы уже создали репозиторий Git для своего проекта, возможно, созданный с нуля или из &lt;a href=&quot;gittutorial&quot;&gt;архива&lt;/a&gt; (см. Gittutorial [7] ), или импортированный из уже существующего репозитория CVS (см. Следующий раздел).</target>
        </trans-unit>
        <trans-unit id="a35a2d4ac8af99272cba8ca44431c44847ef0735" translate="yes" xml:space="preserve">
          <source>We can also create a tag to refer to a particular commit; after running</source>
          <target state="translated">Мы также можем создать тэг для ссылки на конкретный коммит;после запуска</target>
        </trans-unit>
        <trans-unit id="ec584a188dcd2e25a99263b54f2feb909dc57e99" translate="yes" xml:space="preserve">
          <source>We can ask Git about this particular object with the &lt;code&gt;cat-file&lt;/code&gt; command. Don&amp;rsquo;t copy the 40 hex digits from this example but use those from your own version. Note that you can shorten it to only a few characters to save yourself typing all 40 hex digits:</source>
          <target state="translated">Мы можем спросить Git об этом конкретном объекте с помощью команды &lt;code&gt;cat-file&lt;/code&gt; . Не копируйте 40 шестнадцатеричных цифр из этого примера, используйте их из своей собственной версии. Обратите внимание, что вы можете сократить его до нескольких символов, чтобы не набирать все 40 шестнадцатеричных цифр:</target>
        </trans-unit>
        <trans-unit id="3d0c7ad92eed63e4b86ed7fcdbe0a2af116dc20a" translate="yes" xml:space="preserve">
          <source>We can further investigate the time spent scanning for untracked files.</source>
          <target state="translated">Мы можем дополнительно исследовать время,потраченное на сканирование неотслеживаемых файлов.</target>
        </trans-unit>
        <trans-unit id="14c5f91f2f30d67e424b3d8fa6177783e08a84fd" translate="yes" xml:space="preserve">
          <source>We can get just the branch-head names, and remove &lt;code&gt;master&lt;/code&gt;, with the help of the standard utilities cut and grep:</source>
          <target state="translated">Мы можем получить только имена заголовков веток и удалить &lt;code&gt;master&lt;/code&gt; с помощью стандартных утилит cut и grep:</target>
        </trans-unit>
        <trans-unit id="a00f6027326a1e03d87c7714c37d6396c5fc0f07" translate="yes" xml:space="preserve">
          <source>We can get this using the following command:</source>
          <target state="translated">Мы можем получить это,используя следующую команду:</target>
        </trans-unit>
        <trans-unit id="308213d749ac73498be48acb36aa505b62d477c8" translate="yes" xml:space="preserve">
          <source>We can give this name to &lt;code&gt;git show&lt;/code&gt; to see the details about this commit.</source>
          <target state="translated">Мы можем дать это имя команде &lt;code&gt;git show&lt;/code&gt; , чтобы увидеть подробности об этой фиксации.</target>
        </trans-unit>
        <trans-unit id="164a7b582707458e7c29a45bdd3cb932a29b3ca1" translate="yes" xml:space="preserve">
          <source>We can list all the heads in this repository with &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref[1]&lt;/a&gt;:</source>
          <target state="translated">Мы можем перечислить все головы в этом репозитории с помощью &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3342879e047ae36a38db13969064b38d54ccc902" translate="yes" xml:space="preserve">
          <source>We divide Git into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands.</source>
          <target state="translated">Мы разделяем Git на команды высокого уровня (&quot;фарфор&quot;)и низкого уровня (&quot;водопровод&quot;).</target>
        </trans-unit>
        <trans-unit id="011f9d254149abd4e25f111f5f8f2bc847e7e4cc" translate="yes" xml:space="preserve">
          <source>We explain how to do this in the following sections.</source>
          <target state="translated">Мы объясним,как это сделать,в следующих разделах.</target>
        </trans-unit>
        <trans-unit id="4822ab43c46db1b5802e2f53899245649e4398bd" translate="yes" xml:space="preserve">
          <source>We formulate a set of &lt;code&gt;rules&lt;/code&gt; for quick reference, while the prose tries to motivate each of them. Do not always take them literally; you should value good reasons for your actions higher than manpages such as this one.</source>
          <target state="translated">Сформулируем свод &lt;code&gt;rules&lt;/code&gt; для быстрого ознакомления, при этом проза пытается мотивировать каждое из них. Не всегда воспринимайте их буквально; вам следует ценить веские причины для своих действий выше, чем такие страницы руководства, как эта.</target>
        </trans-unit>
        <trans-unit id="27af85d69b0e1da45afccff7b9c2331995331c55" translate="yes" xml:space="preserve">
          <source>We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits.</source>
          <target state="translated">Мы обнаружили,что большинство коммитов на графике могут дать довольно много информации при тестировании.А коммиты,которые в среднем не дают много информации,находятся рядом с хорошими и плохими коммитами.</target>
        </trans-unit>
        <trans-unit id="319c4fde5f53d3ebfff60d2ca81633ff5c5e7332" translate="yes" xml:space="preserve">
          <source>We have already seen &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;how to keep remote-tracking branches up to date&lt;/a&gt; with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, and how to merge two branches. So you can merge in changes from the original repository&amp;rsquo;s master branch with:</source>
          <target state="translated">Мы уже видели, &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;как обновлять ветки удаленного отслеживания&lt;/a&gt; с помощью &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; и как объединить две ветки. Таким образом, вы можете объединить изменения из основной ветки исходного репозитория с помощью:</target>
        </trans-unit>
        <trans-unit id="9313b2be3fe8f9ef5431fd57e740ed2c389d7c2c" translate="yes" xml:space="preserve">
          <source>We have already seen how branches work previously, with &quot;fun and work&quot; example using two branches. The idea is the same if there are more than two branches. Let&amp;rsquo;s say you started out from &quot;master&quot; head, and have some new code in the &quot;master&quot; branch, and two independent fixes in the &quot;commit-fix&quot; and &quot;diff-fix&quot; branches:</source>
          <target state="translated">Мы уже видели, как работают ветки ранее, на примере &amp;laquo;весело и поработай&amp;raquo; с использованием двух веток. Идея такая же, если веток больше двух. Предположим, вы начали с &amp;laquo;master&amp;raquo;, и у вас есть новый код в &amp;laquo;master&amp;raquo; ветке и два независимых исправления в ветвях &amp;laquo;commit-fix&amp;raquo; и &amp;laquo;diff-fix&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="1170354586d8db2806a89632eb01397ff1d5b39a" translate="yes" xml:space="preserve">
          <source>We have seen several ways of naming commits already:</source>
          <target state="translated">Мы уже видели несколько способов именования коммитов:</target>
        </trans-unit>
        <trans-unit id="ea2d131015439270646c4d9deb94b3238eec4d65" translate="yes" xml:space="preserve">
          <source>We have seen that regressions are an important problem, and that &quot;git bisect&quot; has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it.</source>
          <target state="translated">Мы видели,что регрессии являются важной проблемой,и что &quot;гит-бисект&quot; имеет хорошие характеристики,которые дополняют очень хорошие практики и другие инструменты,особенно тестовые наборы,которые обычно используются для борьбы с регрессиями.Но,возможно,потребуется изменить некоторые рабочие процессы и (плохие)привычки,чтобы получить от этого максимум пользы.</target>
        </trans-unit>
        <trans-unit id="58d71328c844eab6bb246a8885f29a926cbaf29b" translate="yes" xml:space="preserve">
          <source>We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems.</source>
          <target state="translated">Мы видели,что тестовые наборы и гит-бисект очень мощны при совместном использовании.Он может быть еще более мощным,если вы сможете комбинировать их с другими системами.</target>
        </trans-unit>
        <trans-unit id="0dc1429b571e4014b12f464201faf90142f01343" translate="yes" xml:space="preserve">
          <source>We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log</source>
          <target state="translated">Мы игнорируем все свойства SVN, кроме svn: executable. Любые необработанные свойства регистрируются в $ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log</target>
        </trans-unit>
        <trans-unit id="5e0e70c2a550cebe0f64341bc25aba4f82846837" translate="yes" xml:space="preserve">
          <source>We said this tutorial shows what plumbing does to help you cope with the porcelain that isn&amp;rsquo;t flushing, but we so far did not talk about how the merge really works. If you are following this tutorial the first time, I&amp;rsquo;d suggest to skip to &quot;Publishing your work&quot; section and come back here later.</source>
          <target state="translated">Мы сказали, что в этом руководстве показано, что делает сантехника, чтобы помочь вам справиться с фарфором, который не смывается, но мы пока не говорили о том, как на самом деле работает слияние. Если вы следуете этому руководству в первый раз, я бы посоветовал пропустить раздел &amp;laquo;Публикация вашей работы&amp;raquo; и вернуться сюда позже.</target>
        </trans-unit>
        <trans-unit id="038e0426e816e440e5c183b0ccfae9faca0c65b5" translate="yes" xml:space="preserve">
          <source>We saw above that &lt;code&gt;origin&lt;/code&gt; is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">Выше мы видели, что &lt;code&gt;origin&lt;/code&gt; - это просто ярлык для ссылки на репозиторий, из которого вы изначально клонировали. Эта информация хранится в переменных конфигурации Git, которые вы можете увидеть с помощью &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="789eeb5f51968bf21d9746b92623ca08838d8bcb" translate="yes" xml:space="preserve">
          <source>We saw earlier that &quot;git bisect skip&quot; is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area.</source>
          <target state="translated">Ранее мы видели,что &quot;git-бисектный пропуск&quot; теперь использует PRNG,чтобы попытаться избежать областей в графе коммитов,где коммиты неоспоримы.Проблема в том,что иногда первый плохой коммит будет в непроверяемой области.</target>
        </trans-unit>
        <trans-unit id="e6f53989efc34bb4d6e54dcd09f15943b6a8a36c" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#conflict-resolution&quot;&gt;Getting conflict-resolution help during a merge&lt;/a&gt; that during a merge the index can store multiple versions of a single file (called &quot;stages&quot;). The third column in the &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; output above is the stage number, and will take on values other than 0 for files with merge conflicts.</source>
          <target state="translated">В разделе &amp;laquo; &lt;a href=&quot;#conflict-resolution&quot;&gt;Получение справки по разрешению конфликтов во время слияния&amp;raquo;&lt;/a&gt; мы видели, что во время слияния индекс может хранить несколько версий одного файла (так называемые &amp;laquo;стадии&amp;raquo;). Третий столбец в выходных данных &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt; выше - это номер стадии, и он будет принимать значения, отличные от 0 для файлов с конфликтами слияния.</target>
        </trans-unit>
        <trans-unit id="d5d682276e6a6d081a241de022b4ded4aef9c418" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Fixing a mistake by rewriting history&lt;/a&gt; that you can replace the most recent commit using</source>
          <target state="translated">В разделе &amp;laquo; &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Исправление ошибки путем переписывания истории&amp;raquo;&lt;/a&gt; мы видели, что вы можете заменить самую последнюю фиксацию, используя</target>
        </trans-unit>
        <trans-unit id="aafdc07c8e0d9b297fcdd505608f380ef754ed45" translate="yes" xml:space="preserve">
          <source>We saw in part one of the tutorial that commits have names like this. It turns out that every object in the Git history is stored under a 40-digit hex name. That name is the SHA-1 hash of the object&amp;rsquo;s contents; among other things, this ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object&amp;rsquo;s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.</source>
          <target state="translated">В первой части руководства мы видели, что коммиты имеют такие имена. Оказывается, каждый объект в истории Git хранится под 40-значным шестнадцатеричным именем. Это имя - хэш SHA-1 содержимого объекта; среди прочего, это гарантирует, что Git никогда не будет хранить одни и те же данные дважды (поскольку идентичным данным дается идентичное имя SHA-1), и что содержимое объекта Git никогда не изменится (поскольку это также изменит имя объекта ). Шестнадцатеричные строки из 7 символов здесь - это просто аббревиатура таких строк длиной 40 символов. Аббревиатуры можно использовать везде, где можно использовать строки из 40 символов, при условии, что они недвусмысленны.</target>
        </trans-unit>
        <trans-unit id="09c046487d09b436218fe11aa8c1087251442281" translate="yes" xml:space="preserve">
          <source>We separate the porcelain commands into the main commands and some ancillary user utilities.</source>
          <target state="translated">Мы разделяем команды фарфора на основные команды и некоторые вспомогательные пользовательские утилиты.</target>
        </trans-unit>
        <trans-unit id="f2e875357a5ce85901234308b841a3138ebd851b" translate="yes" xml:space="preserve">
          <source>We should point out that &quot;habitually&quot; (regularly for no real reason) merging an integration branch into your topics &amp;mdash; and by extension, merging anything upstream into anything downstream on a regular basis &amp;mdash; is frowned upon:</source>
          <target state="translated">Мы должны отметить, что &amp;laquo;обычное&amp;raquo; (регулярно без реальной причины) слияние ветки интеграции с вашими темами - и, в более широком смысле, слияние чего-либо восходящего потока с чем-либо нисходящим на регулярной основе - не одобряется:</target>
        </trans-unit>
        <trans-unit id="3b0c2056ade966758c96efbd333ad03c787ca3ac" translate="yes" xml:space="preserve">
          <source>We start with one specialized tool that is useful for finding the commit that introduced a bug into a project.</source>
          <target state="translated">Мы начинаем с одного специализированного инструмента,который полезен для поиска коммита,который ввёл ошибку в проект.</target>
        </trans-unit>
        <trans-unit id="3bb7fbe62fd9b3fa1a7f67f6a431251fe7b02079" translate="yes" xml:space="preserve">
          <source>We start with the most important, the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; and the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">Начнем с самого важного - &lt;a href=&quot;#def_object_database&quot;&gt;объектной базы данных&lt;/a&gt; и &lt;a href=&quot;#def_index&quot;&gt;индекса&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa1acdd625946113b786a5983b045431892f2e96" translate="yes" xml:space="preserve">
          <source>We supposed in the previous examples that the &quot;good&quot; commits were ancestors of the &quot;bad&quot; commit. But this is not a requirement of &quot;git bisect&quot;.</source>
          <target state="translated">В предыдущих примерах мы предполагали,что &quot;хорошие&quot; коммиты являются предками &quot;плохих&quot; коммитов.Но это не является требованием &quot;git-бисекта&quot;.</target>
        </trans-unit>
        <trans-unit id="09e675bfb62532c536d372645ebddf19b07c5684" translate="yes" xml:space="preserve">
          <source>We want to make &lt;code&gt;topic&lt;/code&gt; forked from branch &lt;code&gt;master&lt;/code&gt;; for example, because the functionality on which &lt;code&gt;topic&lt;/code&gt; depends was merged into the more stable &lt;code&gt;master&lt;/code&gt; branch. We want our tree to look like this:</source>
          <target state="translated">Мы хотим, чтобы &lt;code&gt;topic&lt;/code&gt; разветвлена ​​от &lt;code&gt;master&lt;/code&gt; ветки ; например, потому что функциональность, от которой зависит &lt;code&gt;topic&lt;/code&gt; была объединена в более стабильную &lt;code&gt;master&lt;/code&gt; ветку. Мы хотим, чтобы наше дерево выглядело так:</target>
        </trans-unit>
        <trans-unit id="0fa006b18282abd83f954d3423dfd83f70f68c0d" translate="yes" xml:space="preserve">
          <source>We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history.</source>
          <target state="translated">Мы познакомим вас с некоторыми инструментами,которые могут помочь вам в этом,объясним,как ими пользоваться,а затем объясним некоторые проблемы,которые могут возникнуть из-за того,что вы переписываете историю.</target>
        </trans-unit>
        <trans-unit id="e34d86d215639adac5ecaa74d7f70d803a2ef9de" translate="yes" xml:space="preserve">
          <source>We will sometimes represent Git history using diagrams like the one below. Commits are shown as &quot;o&quot;, and the links between them with lines drawn with - / and \. Time goes left to right:</source>
          <target state="translated">Иногда мы будем представлять историю Git'а,используя диаграммы,подобные приведённым ниже.Коммиты отображаются как &quot;o&quot;,а ссылки между ними с линиями,нарисованными с помощью-/и \.Время идет слева направо:</target>
        </trans-unit>
        <trans-unit id="ab9fd84ced67b4e6059fb12091ba4144199c5397" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume that the problem is a single missing or corrupted blob, which is sometimes a solvable problem. (Recovering missing trees and especially commits is &lt;strong&gt;much&lt;/strong&gt; harder).</source>
          <target state="translated">Мы предполагаем, что проблема заключается в единственном отсутствующем или поврежденном большом двоичном объекте, что иногда является решаемой проблемой. (Восстановить пропавшие деревья и особенно коммиты &lt;strong&gt;намного&lt;/strong&gt; сложнее).</target>
        </trans-unit>
        <trans-unit id="2aa7b1ec194976812ce4b6b3f7e0ba34eba549a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep this simple and stupid, so we&amp;rsquo;ll start off with populating a few trivial files just to get a feel for it.</source>
          <target state="translated">Мы будем делать это просто и глупо, поэтому начнем с заполнения нескольких тривиальных файлов, чтобы просто почувствовать это.</target>
        </trans-unit>
        <trans-unit id="2d4db37414a68811cd95f44af4830929ada62273" translate="yes" xml:space="preserve">
          <source>Webserver configuration</source>
          <target state="translated">настройка веб-портала</target>
        </trans-unit>
        <trans-unit id="c0f36d74c982d11ffbdfaa17b6ab39308ec52a2f" translate="yes" xml:space="preserve">
          <source>Webserver configuration with multiple projects' root</source>
          <target state="translated">Конфигурация сервера с корнем из нескольких проектов</target>
        </trans-unit>
        <trans-unit id="ef6d4f2b2672206d0b50ce512c5b9cc1369fe95f" translate="yes" xml:space="preserve">
          <source>What an alias file in each format looks like can be found in the documentation of the email program of the same name. The differences and limitations from the standard formats are described below:</source>
          <target state="translated">Как выглядит файл псевдонима в каждом формате можно найти в документации одноименной почтовой программы.Различия и ограничения стандартных форматов описаны ниже:</target>
        </trans-unit>
        <trans-unit id="fa6325f935566c907b8b84855ddf6b390a1827e3" translate="yes" xml:space="preserve">
          <source>What are the 7 digits of hex that Git responded to the commit with?</source>
          <target state="translated">Каковы 7 цифр гексагона,которыми Git ответил на обязательство?</target>
        </trans-unit>
        <trans-unit id="5fb651419665147da76edfca56099f33ccd0e645" translate="yes" xml:space="preserve">
          <source>What does this mean?</source>
          <target state="translated">Что это значит?</target>
        </trans-unit>
        <trans-unit id="b77fdbd3385bc488b50aa891b5b4c124304a8f69" translate="yes" xml:space="preserve">
          <source>What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug.</source>
          <target state="translated">Интересно также то,что конечные пользователи,сообщающие об ошибках (или QA-специалисты,которые воспроизвели ошибку),имеют доступ к окружению,в котором происходит ошибка.Так что часто они могут легче воспроизвести регрессию.А если они могут бисектировать,то из окружения,в котором происходит ошибка,будет извлечено больше информации,что означает,что её будет легче понять,а затем исправить.</target>
        </trans-unit>
        <trans-unit id="549056214cd4b23720c4559829b5b36cc5cf6d0c" translate="yes" xml:space="preserve">
          <source>What next?</source>
          <target state="translated">Что дальше?</target>
        </trans-unit>
        <trans-unit id="fe77441e9cc191fb4a5181d6f98e51e7bf6ce4ab" translate="yes" xml:space="preserve">
          <source>What people don&amp;rsquo;t get is that this is a situation where the &quot;end node principle&quot; applies. When you have limited resources (here: developers) you don&amp;rsquo;t push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales.</source>
          <target state="translated">Люди не понимают, что это ситуация, в которой применяется &amp;laquo;принцип конечного узла&amp;raquo;. Когда у вас ограниченные ресурсы (здесь: разработчики), вы не перекладываете на них основную нагрузку. Вместо этого вы отправляете вещи на ресурс, которого у вас много, на конечные узлы (здесь: пользователи), так что ситуация действительно масштабируется.</target>
        </trans-unit>
        <trans-unit id="e4950cd435094a3f200db11a5c1b540d80d04769" translate="yes" xml:space="preserve">
          <source>What should you do when you tag a wrong commit and you would want to re-tag?</source>
          <target state="translated">Что делать,если вы пометили неверный коммит и хотели бы повторно пометить?</target>
        </trans-unit>
        <trans-unit id="049920ec0574fb80b08ccee259e5814b007cd44c" translate="yes" xml:space="preserve">
          <source>What the -p option produces is slightly different from the traditional diff format:</source>
          <target state="translated">То,что производит опция -p,несколько отличается от традиционного формата diff:</target>
        </trans-unit>
        <trans-unit id="e27b60d4391d6c41de480e30a2d0df50a6723ae8" translate="yes" xml:space="preserve">
          <source>What to do when a push fails</source>
          <target state="translated">Что делать,если толчок не удается.</target>
        </trans-unit>
        <trans-unit id="42a1dbf4390cedcf2f183fba444335bae8d5ae11" translate="yes" xml:space="preserve">
          <source>What you chose are then highlighted with &lt;code&gt;*&lt;/code&gt;, like this:</source>
          <target state="translated">То, что вы выбрали, затем выделяется &lt;code&gt;*&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="e11a716b5dc9d27d9966b39b2c63b32b4c67e627" translate="yes" xml:space="preserve">
          <source>When &amp;lt;rev&amp;gt; is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify &lt;code&gt;-&lt;/code&gt; to make the command read from the standard input).</source>
          <target state="translated">Если &amp;lt;rev&amp;gt; не указан, команда аннотирует изменения, начиная с копии рабочего дерева в обратном направлении. Этот флаг заставляет команду делать вид, что копия рабочего дерева имеет содержимое указанного файла (укажите &lt;code&gt;-&lt;/code&gt; чтобы команда считывалась из стандартного ввода).</target>
        </trans-unit>
        <trans-unit id="df8212af8d2323e7260f5fa3c4bc0bbc714643ff" translate="yes" xml:space="preserve">
          <source>When --fork-point is active, &lt;code&gt;fork_point&lt;/code&gt; will be used instead of &amp;lt;upstream&amp;gt; to calculate the set of commits to rebase, where &lt;code&gt;fork_point&lt;/code&gt; is the result of &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt;
&amp;lt;branch&amp;gt;&lt;/code&gt; command (see &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;). If &lt;code&gt;fork_point&lt;/code&gt; ends up being empty, the &amp;lt;upstream&amp;gt; will be used as a fallback.</source>
          <target state="translated">Когда --fork-point активен, &lt;code&gt;fork_point&lt;/code&gt; будет использоваться вместо &amp;lt;upstream&amp;gt; для вычисления набора &lt;code&gt;fork_point&lt;/code&gt; для перебазирования, где fork_point является результатом &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; command ( см. &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; ). Если &lt;code&gt;fork_point&lt;/code&gt; окажется пустым, &amp;lt;upstream&amp;gt; будет использоваться в качестве запасного варианта.</target>
        </trans-unit>
        <trans-unit id="0b903c4e9a3738f389f65549fe23dcd21fd8909d" translate="yes" xml:space="preserve">
          <source>When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; is specified, it is the string that will be shown instead of the default one.</source>
          <target state="translated">Когда --graph не используется, все ветки истории сглаживаются, что может затруднить понимание того, что две последовательные фиксации не принадлежат линейной ветви. В этом случае этот вариант ставит между ними барьер. Если указан &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; , вместо строки по умолчанию будет отображаться строка.</target>
        </trans-unit>
        <trans-unit id="24ff3c267435a7dcecd3166ed52f8210a7c7f0de" translate="yes" xml:space="preserve">
          <source>When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used.</source>
          <target state="translated">При указании --stdout отчет о ходе работы отображается на фазе подсчета и сжатия объектов,но блокируется на фазе записи.Причина в том,что в некоторых случаях выходной поток напрямую связан с другой командой,которая может захотеть отобразить свой статус прогресса при обработке входящих данных пакета.Этот флаг похож на --progress за исключением того,что он заставляет выводить отчет о прогрессе и на фазу записи,даже если используется --stdout.</target>
        </trans-unit>
        <trans-unit id="d3e80ca53bd7d57db503ac84208eff0dbe6d901f" translate="yes" xml:space="preserve">
          <source>When -k is not in effect, all leading strings bracketed with &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word &quot;PATCH&quot;.</source>
          <target state="translated">Когда -k не действует, все начальные строки, заключенные в квадратные скобки парами &lt;code&gt;[&lt;/code&gt; и &lt;code&gt;]&lt;/code&gt; , удаляются. Эта опция ограничивает удаление только парами, строка в квадратных скобках которых содержит слово &amp;laquo;PATCH&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="882475218cb0a9fc17e76a3d4266386adec5dd71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; in the above example, the following usage text would be shown:</source>
          <target state="translated">Когда &lt;code&gt;&quot;$@&quot;&lt;/code&gt; в приведенном выше примере равно &lt;code&gt;-h&lt;/code&gt; или &lt;code&gt;--help&lt;/code&gt; , будет показан следующий текст использования:</target>
        </trans-unit>
        <trans-unit id="d78a0cbb0812363470a0c64a4a94d40dd1da90bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--batch-all-objects&lt;/code&gt; is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with &lt;code&gt;--batch&lt;/code&gt;. Note that &lt;code&gt;cat-file&lt;/code&gt; will still show each object only once, even if it is stored multiple times in the repository.</source>
          <target state="translated">Когда используется &lt;code&gt;--batch-all-objects&lt;/code&gt; , посещайте объекты в порядке, который может быть более эффективным для доступа к содержимому объекта, чем порядок хеширования. Точные детали заказа не указаны, но если вам не нужен конкретный порядок, это обычно должно привести к более быстрому выводу, особенно с &lt;code&gt;--batch&lt;/code&gt; . Обратите внимание, что в &lt;code&gt;cat-file&lt;/code&gt; каждый объект по-прежнему будет отображаться только один раз, даже если он хранится в репозитории несколько раз.</target>
        </trans-unit>
        <trans-unit id="95919047a579b82415a0ddd6c6f601bfbb7dc80f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--check&lt;/code&gt; is in effect, or when applying the patch (which is the default when none of the options that disables it is in effect), make sure the patch is applicable to what the current index file records. If the file to be patched in the working tree is not up to date, it is flagged as an error. This flag also causes the index file to be updated.</source>
          <target state="translated">Когда &lt;code&gt;--check&lt;/code&gt; или когда применяется патч (который используется по умолчанию, когда не действует ни одна из отключающих его опций), убедитесь, что патч применим к тому, что записывает текущий индексный файл. Если файл, который нужно исправить в рабочем дереве, устарел, он помечается как ошибка. Этот флаг также вызывает обновление индексного файла.</target>
        </trans-unit>
        <trans-unit id="526cf7ed548b3415806841ff6b0e065a944a8f5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--compose&lt;/code&gt; is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won&amp;rsquo;t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.</source>
          <target state="translated">Когда используется &lt;code&gt;--compose&lt;/code&gt; , git send-email будет использовать заголовки From, Subject и In-Reply-To, указанные в сообщении. Если тело сообщения (то, что вы вводите после заголовков и пустую строку) содержит только пустые (или с префиксом Git:) строки, сводка не будет отправлена, но заголовки From, Subject и In-Reply-To будут использоваться до тех пор, пока они не будут удалены.</target>
        </trans-unit>
        <trans-unit id="ac6d168ca5e25a70ab78d5a850025a2ad07d998b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--exclude&lt;/code&gt; and &lt;code&gt;--include&lt;/code&gt; patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern.</source>
          <target state="translated">Когда используются шаблоны &lt;code&gt;--exclude&lt;/code&gt; и &lt;code&gt;--include&lt;/code&gt; , они проверяются в том порядке, в котором они появляются в командной строке, и первое совпадение определяет, используется ли патч для каждого пути. Патч к пути, который не соответствует какому-либо шаблону включения / исключения, используется по умолчанию, если в командной строке нет шаблона включения, и игнорируется, если есть какой-либо шаблон включения.</target>
        </trans-unit>
        <trans-unit id="febfb7b902fc970c3396f3068a5c66e59c7ec8ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--notes&lt;/code&gt; is in effect, the message from the notes is matched as if it were part of the log message.</source>
          <target state="translated">Когда &lt;code&gt;--notes&lt;/code&gt; , сообщение из заметок сопоставляется, как если бы оно было частью сообщения журнала.</target>
        </trans-unit>
        <trans-unit id="b84c74a91c715b3bf1b4e927529a07a15aed9721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.</source>
          <target state="translated">Если &lt;code&gt;--numstat&lt;/code&gt; , не изменяйте пути к файлам, а используйте машиночитаемый формат с завершающим нулем.</target>
        </trans-unit>
        <trans-unit id="d371e700585c518084c33d84fef0af43b13c3439" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; or &lt;code&gt;--name-status&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">Когда &lt;code&gt;--raw&lt;/code&gt; , &lt;code&gt;--numstat&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; или &lt;code&gt;--name-status&lt;/code&gt; , не меняйте пути и используйте NUL в качестве ограничителей выходных полей.</target>
        </trans-unit>
        <trans-unit id="e163d548a1a886a531d60736c2ba3e851388a10a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--root&lt;/code&gt; is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree.</source>
          <target state="translated">Когда &lt;code&gt;--root&lt;/code&gt; , начальная фиксация будет отображаться как большое событие создания. Это эквивалентно сравнению с деревом NULL.</target>
        </trans-unit>
        <trans-unit id="5b88ba2b22685842fbd9b8b75fb2959da8ea9e8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--stdin&lt;/code&gt; is specified, the command does not take &amp;lt;tree-ish&amp;gt; arguments from the command line. Instead, it reads lines containing either two &amp;lt;tree&amp;gt;, one &amp;lt;commit&amp;gt;, or a list of &amp;lt;commit&amp;gt; from its standard input. (Use a single space as separator.)</source>
          <target state="translated">Когда &lt;code&gt;--stdin&lt;/code&gt; , команда не принимает аргументы &amp;lt;tree-ish&amp;gt; из командной строки. Вместо этого он считывает строки, содержащие два &amp;lt;tree&amp;gt;, один &amp;lt;commit&amp;gt; или список &amp;lt;commit&amp;gt; со стандартного ввода. (Используйте один пробел в качестве разделителя.)</target>
        </trans-unit>
        <trans-unit id="c23ac888d8fe422c1532e2aed10782043e7c6859" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--temp&lt;/code&gt; is used (or implied by &lt;code&gt;--stage=all&lt;/code&gt;) &lt;code&gt;git checkout-index&lt;/code&gt; will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.</source>
          <target state="translated">Когда используется &lt;code&gt;--temp&lt;/code&gt; (или подразумевается &lt;code&gt;--stage=all&lt;/code&gt; ) &lt;code&gt;git checkout-index&lt;/code&gt; будет создавать временный файл для каждой извлекаемой записи индекса. Индекс не будет обновляться статистической информацией. Эти параметры могут быть полезны, если вызывающей стороне нужны все этапы всех несвязанных записей, чтобы необработанные файлы могли быть обработаны внешним инструментом слияния.</target>
        </trans-unit>
        <trans-unit id="5c97ac9560dda79ead627bde39274f79b6e5dd8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; are used without &lt;code&gt;--pickaxe-all&lt;/code&gt;, only filepairs that match their respective criterion are kept in the output. When &lt;code&gt;--pickaxe-all&lt;/code&gt; is used, if even one filepair matches their respective criterion in a changeset, the entire changeset is kept. This behavior is designed to make reviewing changes in the context of the whole changeset easier.</source>
          <target state="translated">Когда &lt;code&gt;-S&lt;/code&gt; или &lt;code&gt;-G&lt;/code&gt; используются без &lt;code&gt;--pickaxe-all&lt;/code&gt; , в выходных данных сохраняются только файловые пары, соответствующие их критериям. При использовании &lt;code&gt;--pickaxe-all&lt;/code&gt; , если хотя бы одна файловая пара соответствует соответствующему критерию в наборе изменений, сохраняется весь набор изменений. Такое поведение разработано, чтобы упростить просмотр изменений в контексте всего набора изменений.</target>
        </trans-unit>
        <trans-unit id="b7230470efbcbdb8b4c76cdcdcf3272fde68030f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; finds a change, show all the changes in that changeset, not just the files that contain the change in &amp;lt;string&amp;gt;.</source>
          <target state="translated">Когда &lt;code&gt;-S&lt;/code&gt; или &lt;code&gt;-G&lt;/code&gt; находят изменение, отображать все изменения в этом наборе изменений, а не только файлы, содержащие изменение в &amp;lt;string&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="b52ce403c26e2631158c50ee6bd3c17065ed82dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-u&lt;/code&gt; option is not used, untracked files and directories are shown (i.e. the same as specifying &lt;code&gt;normal&lt;/code&gt;), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; and &lt;code&gt;git update-index
--split-index&lt;/code&gt;), Otherwise you can use &lt;code&gt;no&lt;/code&gt; to have &lt;code&gt;git status&lt;/code&gt; return more quickly without showing untracked files.</source>
          <target state="translated">Когда опция &lt;code&gt;-u&lt;/code&gt; не используется, отображаются неотслеживаемые файлы и каталоги (то есть такие же, как при указании &lt;code&gt;normal&lt;/code&gt; ), чтобы вы не забыли добавить вновь созданные файлы. Поскольку поиск неотслеживаемых файлов в файловой системе требует дополнительной работы, этот режим может занять некоторое время в большом рабочем дереве. Рассмотрите возможность включения неотслеживаемого кеша и разделенного индекса, если он поддерживается (см. &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; и &lt;code&gt;git update-index --split-index&lt;/code&gt; ). В противном случае вы можете использовать &lt;code&gt;no&lt;/code&gt; , чтобы &lt;code&gt;git status&lt;/code&gt; возвращался быстрее, не показывая неотслеживаемые файлы.</target>
        </trans-unit>
        <trans-unit id="97c7c816e31485397947c4cd78f79e742f80ec39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-z&lt;/code&gt; output option is in effect, the output is formatted this way:</source>
          <target state="translated">Когда действует опция вывода &lt;code&gt;-z&lt;/code&gt; , вывод форматируется следующим образом:</target>
        </trans-unit>
        <trans-unit id="2bf71954fc8fac90c9030e3b9b1232971580d22a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FETCH_HEAD&lt;/code&gt; (and no other commit) is specified, the branches recorded in the &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; file by the previous invocation of &lt;code&gt;git fetch&lt;/code&gt; for merging are merged to the current branch.</source>
          <target state="translated">Когда &lt;code&gt;FETCH_HEAD&lt;/code&gt; (и никакая другая фиксация), ветки, записанные в файле &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; при предыдущем вызове &lt;code&gt;git fetch&lt;/code&gt; для слияния, объединяются с текущей ветвью.</target>
        </trans-unit>
        <trans-unit id="093107f57324ea8ddf834562dc5da735634ce1c2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.fsckObjects&lt;/code&gt; or &lt;code&gt;receive.fsckObjects&lt;/code&gt; are not set, the value of this variable is used instead. Defaults to false.</source>
          <target state="translated">Если &lt;code&gt;fetch.fsckObjects&lt;/code&gt; или &lt;code&gt;receive.fsckObjects&lt;/code&gt; не заданы, вместо этого используется значение этой переменной. По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="f0f4e4ab298d72d3ce878991ffe1cd2532ffab74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.unpackLimit&lt;/code&gt; or &lt;code&gt;receive.unpackLimit&lt;/code&gt; are not set, the value of this variable is used instead. The default value is 100.</source>
          <target state="translated">Если &lt;code&gt;fetch.unpackLimit&lt;/code&gt; или &lt;code&gt;receive.unpackLimit&lt;/code&gt; не установлены, вместо них используется значение этой переменной. Значение по умолчанию - 100.</target>
        </trans-unit>
        <trans-unit id="0f43e1a31ad9e45784cdafec68b8141e1a628402" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; is set, errors can be switched to warnings and vice versa by configuring the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; setting where the &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; is the fsck message ID and the value is one of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;. For convenience, fsck prefixes the error/warning with the message ID, e.g. &quot;missingEmail: invalid author/committer line - missing email&quot; means that setting &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; will hide that issue.</source>
          <target state="translated">Когда установлен &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; , ошибки можно переключить на предупреждения и наоборот, настроив параметр &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; , где &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; - это идентификатор сообщения fsck, а значение - одно из &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; . Для удобства fsck добавляет перед ошибкой / предупреждением идентификатор сообщения, например, &amp;laquo;missingEmail: недопустимая строка автора / коммиттера - отсутствует адрес электронной почты&amp;raquo; означает, что установка &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; скроет эту проблему.</target>
        </trans-unit>
        <trans-unit id="ce3f108ee8253a42ecb067bc1a011bcbcd3ad290" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git apply&lt;/code&gt; is used as a &quot;better GNU patch&quot;, the user can pass the &lt;code&gt;--unsafe-paths&lt;/code&gt; option to override this safety check. This option has no effect when &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;--cached&lt;/code&gt; is in use.</source>
          <target state="translated">Когда &lt;code&gt;git apply&lt;/code&gt; используется как &amp;laquo;лучший патч GNU&amp;raquo;, пользователь может передать параметр &lt;code&gt;--unsafe-paths&lt;/code&gt; , чтобы отменить эту проверку безопасности. Этот параметр не действует при использовании &lt;code&gt;--index&lt;/code&gt; или &lt;code&gt;--cached&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea5ce8f581717a21d1ee89e4952655599f11488" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git difftool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;diff.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with the following variables available: &lt;code&gt;$LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;$REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image. &lt;code&gt;$MERGED&lt;/code&gt; is the name of the file which is being compared. &lt;code&gt;$BASE&lt;/code&gt; is provided for compatibility with custom merge tool commands and has the same value as &lt;code&gt;$MERGED&lt;/code&gt;.</source>
          <target state="translated">Когда с помощью этого инструмента вызывается &lt;code&gt;git difftool&lt;/code&gt; (с помощью параметра &lt;code&gt;-t&lt;/code&gt; или &lt;code&gt;--tool&lt;/code&gt; или &lt;code&gt;diff.tool&lt;/code&gt; конфигурации diff.tool ), настроенная командная строка будет вызвана со следующими доступными переменными: &lt;code&gt;$LOCAL&lt;/code&gt; устанавливается на имя временного файл, содержащий содержимое предварительного изображения diff, а &lt;code&gt;$REMOTE&lt;/code&gt; устанавливается равным имени временного файла, содержащего содержимое пост-изображения diff. &lt;code&gt;$MERGED&lt;/code&gt; - это имя сравниваемого файла. &lt;code&gt;$BASE&lt;/code&gt; предоставляется для совместимости с пользовательскими командами инструмента слияния и имеет то же значение, что и &lt;code&gt;$MERGED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02bc7953c8eb819402a97fdb05db86103d3e94f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run with explicit branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin master&lt;/code&gt;, the &amp;lt;refspec&amp;gt;s given on the command line determine what are to be fetched (e.g. &lt;code&gt;master&lt;/code&gt; in the example, which is a short-hand for &lt;code&gt;master:&lt;/code&gt;, which in turn means &quot;fetch the &lt;code&gt;master&lt;/code&gt; branch but I do not explicitly say what remote-tracking branch to update with it from the command line&quot;), and the example command will fetch &lt;code&gt;only&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch. The &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values determine which remote-tracking branch, if any, is updated. When used in this way, the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values do not have any effect in deciding &lt;code&gt;what&lt;/code&gt; gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide &lt;code&gt;where&lt;/code&gt; the refs that are fetched are stored by acting as a mapping.</source>
          <target state="translated">Когда &lt;code&gt;git fetch&lt;/code&gt; запускается с явными ветвями и / или тегами для выборки в командной строке, например, &lt;code&gt;git fetch origin master&lt;/code&gt; , &amp;lt;refspec&amp;gt;, заданные в командной строке, определяют, что нужно получить (например, &lt;code&gt;master&lt;/code&gt; в примере, которым является короткая рука для &lt;code&gt;master:&lt;/code&gt; , который , в свою очередь , означает &amp;laquo;Позовите &lt;code&gt;master&lt;/code&gt; ветвь , но я явно не сказать , что пульт дистанционного отслеживания ветви обновления с ним из командной строки&amp;raquo;), и пример команды будет получать &lt;code&gt;only&lt;/code&gt; на &lt;code&gt;master&lt;/code&gt; - ветви. Значения &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; определяют, какая ветвь удаленного отслеживания, если таковая имеется, обновляется. При таком использовании &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; значения не имеют никакого эффекта при принятии решения &lt;code&gt;what&lt;/code&gt; том, что будет извлечено (т. е. значения не используются в качестве refspecs, когда в командной строке перечислены refspecs); они используются только для того, чтобы решить, &lt;code&gt;where&lt;/code&gt; будут храниться выбранные ссылки, действуя как отображение.</target>
        </trans-unit>
        <trans-unit id="d3bb27ea8d5739147518646e08d478432b5ac353" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run without specifying what branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values are used as the refspecs&amp;mdash;​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the &lt;code&gt;origin&lt;/code&gt; (i.e. any ref that matches the left-hand side of the value, &lt;code&gt;refs/heads/*&lt;/code&gt;) and update the corresponding remote-tracking branches in the &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; hierarchy.</source>
          <target state="translated">Когда &lt;code&gt;git fetch&lt;/code&gt; запускается без указания, какие ветки и / или теги для выборки в командной строке, например, &lt;code&gt;git fetch origin&lt;/code&gt; или &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; значения используются в качестве refspecs - они указывают, какие ссылки для выборки и какие местные ссылки обновлять. В приведенном выше примере будут извлечены все ветки, которые существуют в &lt;code&gt;origin&lt;/code&gt; (т.е. любая ссылка, которая соответствует левой стороне значения, &lt;code&gt;refs/heads/*&lt;/code&gt; ), и обновлены соответствующие ветки удаленного отслеживания в &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; иерархия.</target>
        </trans-unit>
        <trans-unit id="6bfc306f6ccec6cbac00c82d44f7befe47671739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part below. This option overrides that check.</source>
          <target state="translated">Когда &lt;code&gt;git fetch&lt;/code&gt; используется с &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec, он может отказаться обновлять локальную ветку, как описано в части &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; ниже. Эта опция отменяет эту проверку.</target>
        </trans-unit>
        <trans-unit id="b8a0a18f13c1248a211519fc4b6c3ee775403075" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part of the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; documentation. This option overrides that check.</source>
          <target state="translated">Когда &lt;code&gt;git fetch&lt;/code&gt; используется с &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec, он может отказаться обновлять локальную ветку, как описано в части &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; документации &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; . Эта опция отменяет эту проверку.</target>
        </trans-unit>
        <trans-unit id="946d45913d1a6d20975808ddb9f4de7a3a592055" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it calls &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt;. This config variable can be used to set a different grace period. The value &quot;now&quot; may be used to disable the grace period and prune &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; immediately, or &quot;never&quot; may be used to suppress pruning.</source>
          <target state="translated">При запуске &lt;code&gt;git gc&lt;/code&gt; вызывается &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt; . Эта переменная конфигурации может использоваться для установки другого льготного периода. Значение &amp;laquo;сейчас&amp;raquo; может использоваться для отключения льготного периода и &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; , или &amp;laquo;никогда&amp;raquo; может использоваться для подавления отсечения.</target>
        </trans-unit>
        <trans-unit id="bdaf9b565f5bc5effacd5e94ca1e6e23df9c9f7a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it will call &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt;. Override the grace period with this config variable. The value &quot;now&quot; may be used to disable this grace period and always prune unreachable objects immediately, or &quot;never&quot; may be used to suppress pruning. This feature helps prevent corruption when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process writing to the repository; see the &quot;NOTES&quot; section of &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">При запуске &lt;code&gt;git gc&lt;/code&gt; вызывается &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt; . Отмените льготный период с помощью этой переменной конфигурации. Значение &amp;laquo;сейчас&amp;raquo; может использоваться для отключения этого периода отсрочки и всегда немедленно удалять недоступные объекты, или &amp;laquo;никогда&amp;raquo; может использоваться для подавления отсечения. Эта функция помогает предотвратить повреждение, когда &lt;code&gt;git gc&lt;/code&gt; выполняется одновременно с другим процессом, записывающим в репозиторий; см. раздел &amp;laquo;ПРИМЕЧАНИЯ&amp;raquo; в &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9771ab35f0db8c62ffb81b026ac116ab479df958" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git mergetool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with &lt;code&gt;$BASE&lt;/code&gt; set to the name of a temporary file containing the common base for the merge, if available; &lt;code&gt;$LOCAL&lt;/code&gt; set to the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;$REMOTE&lt;/code&gt; set to the name of a temporary file containing the contents of the file to be merged, and &lt;code&gt;$MERGED&lt;/code&gt; set to the name of the file to which the merge tool should write the result of the merge resolution.</source>
          <target state="translated">Когда &lt;code&gt;git mergetool&lt;/code&gt; вызывается с помощью этого инструмента (либо с помощью параметра &lt;code&gt;-t&lt;/code&gt; или &lt;code&gt;--tool&lt;/code&gt; , либо с помощью переменной конфигурации &lt;code&gt;merge.tool&lt;/code&gt; ), настроенная командная строка будет вызвана с параметром &lt;code&gt;$BASE&lt;/code&gt; установленным на имя временного файла, содержащего общую базу для слияние, если доступно; &lt;code&gt;$LOCAL&lt;/code&gt; устанавливается равным имени временного файла, содержащего содержимое файла в текущей ветви; &lt;code&gt;$REMOTE&lt;/code&gt; задано имя временного файла, содержащего содержимое файла, который нужно объединить, а в &lt;code&gt;$MERGED&lt;/code&gt; задано имя файла, в который инструмент объединения должен записать результат разрешения объединения.</target>
        </trans-unit>
        <trans-unit id="8d649c2a1b515f828b380ed0228639a9abf6f2e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-difftool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default diff tool will be read from the configured &lt;code&gt;diff.guitool&lt;/code&gt; variable instead of &lt;code&gt;diff.tool&lt;/code&gt;. The &lt;code&gt;--no-gui&lt;/code&gt; option can be used to override this setting. If &lt;code&gt;diff.guitool&lt;/code&gt; is not set, we will fallback in the order of &lt;code&gt;merge.guitool&lt;/code&gt;, &lt;code&gt;diff.tool&lt;/code&gt;, &lt;code&gt;merge.tool&lt;/code&gt; until a tool is found.</source>
          <target state="translated">Когда &lt;code&gt;git-difftool&lt;/code&gt; вызывается с параметром &lt;code&gt;-g&lt;/code&gt; или &lt;code&gt;--gui&lt;/code&gt; , инструмент сравнения по умолчанию будет считываться из настроенной переменной &lt;code&gt;diff.guitool&lt;/code&gt; вместо &lt;code&gt;diff.tool&lt;/code&gt; . Параметр &lt;code&gt;--no-gui&lt;/code&gt; может использоваться для отмены этого параметра. Если &lt;code&gt;diff.guitool&lt;/code&gt; не установлен, мы будем отступать в порядке &lt;code&gt;merge.guitool&lt;/code&gt; , &lt;code&gt;diff.tool&lt;/code&gt; , &lt;code&gt;merge.tool&lt;/code&gt; , пока инструмент не будет найден.</target>
        </trans-unit>
        <trans-unit id="dab1778e78eece39a70fe4959b77fef05af95366" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-mergetool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default merge tool will be read from the configured &lt;code&gt;merge.guitool&lt;/code&gt; variable instead of &lt;code&gt;merge.tool&lt;/code&gt;. If &lt;code&gt;merge.guitool&lt;/code&gt; is not set, we will fallback to the tool configured under &lt;code&gt;merge.tool&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;git-mergetool&lt;/code&gt; вызывается с параметром &lt;code&gt;-g&lt;/code&gt; или &lt;code&gt;--gui&lt;/code&gt; , инструмент слияния по умолчанию будет считываться из настроенной переменной &lt;code&gt;merge.guitool&lt;/code&gt; вместо &lt;code&gt;merge.tool&lt;/code&gt; . Если &lt;code&gt;merge.guitool&lt;/code&gt; не установлен, мы вернемся к инструменту, настроенному в &lt;code&gt;merge.tool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d1f905322639499a3e0c7d64b920e915841fa1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;group&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), the repository is made shareable between several users in a group (making sure all the files and objects are group-writable). When &lt;code&gt;all&lt;/code&gt; (or &lt;code&gt;world&lt;/code&gt; or &lt;code&gt;everybody&lt;/code&gt;), the repository will be readable by all users, additionally to being group-shareable. When &lt;code&gt;umask&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;), Git will use permissions reported by umask(2). When &lt;code&gt;0xxx&lt;/code&gt;, where &lt;code&gt;0xxx&lt;/code&gt; is an octal number, files in the repository will have this mode value. &lt;code&gt;0xxx&lt;/code&gt; will override user&amp;rsquo;s umask value (whereas the other options will only override requested parts of the user&amp;rsquo;s umask value). Examples: &lt;code&gt;0660&lt;/code&gt; will make the repo read/write-able for the owner and group, but inaccessible to others (equivalent to &lt;code&gt;group&lt;/code&gt; unless umask is e.g. &lt;code&gt;0022&lt;/code&gt;). &lt;code&gt;0640&lt;/code&gt; is a repository that is group-readable but not group-writable. See &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">Когда &lt;code&gt;group&lt;/code&gt; (или &lt;code&gt;true&lt;/code&gt; ), репозиторий становится доступным для совместного использования несколькими пользователями в группе (убедитесь, что все файлы и объекты доступны для групповой записи). Когда &lt;code&gt;all&lt;/code&gt; (или &lt;code&gt;world&lt;/code&gt; или &lt;code&gt;everybody&lt;/code&gt; ), репозиторий будет доступен для чтения всем пользователям, кроме того, что он будет доступен для группового доступа. Когда &lt;code&gt;umask&lt;/code&gt; (или &lt;code&gt;false&lt;/code&gt; ), Git будет использовать разрешения, сообщаемые umask (2). Когда &lt;code&gt;0xxx&lt;/code&gt; , где &lt;code&gt;0xxx&lt;/code&gt; - восьмеричное число, файлы в репозитории будут иметь это значение режима. &lt;code&gt;0xxx&lt;/code&gt; переопределит значение umask пользователя (тогда как другие параметры переопределят только запрошенные части значения umask пользователя). Примеры: &lt;code&gt;0660&lt;/code&gt; сделает репозиторий доступным для чтения / записи для владельца и группы, но недоступным для других (эквивалентно &lt;code&gt;group&lt;/code&gt; если umask не равен, например, &lt;code&gt;0022&lt;/code&gt; ). &lt;code&gt;0640&lt;/code&gt; - это репозиторий, который доступен для чтения для группы, но не для группы для записи. См. &lt;a href=&quot;git-init&quot;&gt;Git-init [1]&lt;/a&gt; . По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="0c640b1443fdc376fb0e05e5b19871e0f70bfa75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;interactive&lt;/code&gt;, enable the interactive mode of rebase.</source>
          <target state="translated">В &lt;code&gt;interactive&lt;/code&gt; режиме включите интерактивный режим rebase.</target>
        </trans-unit>
        <trans-unit id="0e5d1d0d5309f291d73a19a6f71347b59d761978" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified in the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">Когда &lt;code&gt;konqueror&lt;/code&gt; указан в &lt;code&gt;man.viewer&lt;/code&gt; конфигурации man.viewer , мы запускаем &lt;code&gt;kfmclient&lt;/code&gt; , чтобы попытаться открыть страницу руководства на уже открытом konqueror в новой вкладке, если это возможно.</target>
        </trans-unit>
        <trans-unit id="162b4f89725e01e084b1d2a9bb66f41a211da6f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;matching&lt;/code&gt; mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.</source>
          <target state="translated">Когда &lt;code&gt;matching&lt;/code&gt; задан режим, пути , которые явно соответствуют проигнорировано в шаблон показано на рисунке. Если каталог соответствует шаблону игнорирования, он отображается, но не пути, содержащиеся в игнорируемом каталоге. Если каталог не соответствует шаблону игнорирования, но все содержимое игнорируется, тогда каталог не отображается, но отображается все содержимое.</target>
        </trans-unit>
        <trans-unit id="239b51beb1f8c13233881b0568518d58e269df96" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt;, pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">Когда &lt;code&gt;merges&lt;/code&gt; , проходят &lt;code&gt;--rebase-merges&lt;/code&gt; вариант &lt;code&gt;git rebase&lt;/code&gt; так, чтобы местные коммиты слияния включены в перебазировании (см &lt;a href=&quot;git-rebase&quot;&gt;ГИТ-Rebase [1]&lt;/a&gt; для более подробной информации).</target>
        </trans-unit>
        <trans-unit id="26887709475bb99a484f3550dfcf66463a02ff1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;preserve&lt;/code&gt; (не рекомендуется в пользу &lt;code&gt;merges&lt;/code&gt; ), также передайте &lt;code&gt;--preserve-merges&lt;/code&gt; вместе с &lt;code&gt;git rebase&lt;/code&gt; , чтобы локально зафиксированные коммиты слияния не сглаживались при запуске &lt;code&gt;git pull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c040d756e251986ff4d930aa40402b774da81b76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserveUser&lt;/code&gt; is true, &lt;code&gt;git p4&lt;/code&gt; normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless.</source>
          <target state="translated">Когда &lt;code&gt;preserveUser&lt;/code&gt; истинно, &lt;code&gt;git p4&lt;/code&gt; обычно умирает, если не может найти автора в карте пользователя p4. Этот параметр все равно отправляет изменение.</target>
        </trans-unit>
        <trans-unit id="f1cb457481e4cab2531cdb48fb2ed70a72c47f80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;receive-pack&lt;/code&gt; takes in objects, they are placed into a temporary &quot;quarantine&quot; directory within the &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory and migrated into the main object store only after the &lt;code&gt;pre-receive&lt;/code&gt; hook has completed. If the push fails before then, the temporary directory is removed entirely.</source>
          <target state="translated">Когда &lt;code&gt;receive-pack&lt;/code&gt; принимает объекты, они помещаются во временный &amp;laquo;карантинный&amp;raquo; каталог в каталоге &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; и переносятся в главное хранилище объектов только после завершения обработки &lt;code&gt;pre-receive&lt;/code&gt; . Если до этого времени push не удается, временный каталог полностью удаляется.</target>
        </trans-unit>
        <trans-unit id="13eed45e8cb127a4420b06f0b52f497c696b7d45" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; is set to &quot;auto&quot;, the path is marked for automatic end-of-line conversion. If Git decides that the content is text, its line endings are converted to LF on checkin. When the file has been committed with CRLF, no conversion is done.</source>
          <target state="translated">Если для &lt;code&gt;text&lt;/code&gt; установлено значение &amp;laquo;авто&amp;raquo;, путь помечается для автоматического преобразования конца строки. Если Git решает, что контент является текстом, его окончания строки преобразуются в LF при возврате. Когда файл зафиксирован с помощью CRLF, преобразование не выполняется.</target>
        </trans-unit>
        <trans-unit id="2bb8610f0d3f51c94aca7dd51e3603814301750d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text=auto&lt;/code&gt; conversion is enabled in a cross-platform project using push and pull to a central repository the text files containing CRLFs should be normalized.</source>
          <target state="translated">Когда &lt;code&gt;text=auto&lt;/code&gt; преобразование включено в кроссплатформенном проекте с использованием push и pull в центральный репозиторий, текстовые файлы, содержащие CRLF, должны быть нормализованы.</target>
        </trans-unit>
        <trans-unit id="f1b569ad0a0d3f731d90377a830d25de99487fad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;upload-pack&lt;/code&gt; has started &lt;code&gt;pack-objects&lt;/code&gt;, there may be a quiet period while &lt;code&gt;pack-objects&lt;/code&gt; prepares the pack. Normally it would output progress information, but if &lt;code&gt;--quiet&lt;/code&gt; was used for the fetch, &lt;code&gt;pack-objects&lt;/code&gt; will output nothing at all until the pack data begins. Some clients and networks may consider the server to be hung and give up. Setting this option instructs &lt;code&gt;upload-pack&lt;/code&gt; to send an empty keepalive packet every &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; seconds. Setting this option to 0 disables keepalive packets entirely. The default is 5 seconds.</source>
          <target state="translated">Когда &lt;code&gt;upload-pack&lt;/code&gt; запустил &lt;code&gt;pack-objects&lt;/code&gt; , может быть период &lt;code&gt;pack-objects&lt;/code&gt; пока pack-objects готовят пакет. Обычно он выводит информацию о прогрессе, но если для выборки использовалось &lt;code&gt;--quiet&lt;/code&gt; , &lt;code&gt;pack-objects&lt;/code&gt; не будут выводить вообще ничего, пока не начнутся данные пакета. Некоторые клиенты и сети могут счесть сервер зависшим и отказаться от него. Установка этого параметра указывает &lt;code&gt;upload-pack&lt;/code&gt; отправлять пустой пакет keepalive каждые секунды &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; . Установка этого параметра на 0 полностью отключает пакеты keepalive. По умолчанию 5 секунд.</target>
        </trans-unit>
        <trans-unit id="09ea8c9e4617731ed2a0cdf40185d39ec477e171" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; is in effect, allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object at the tip of a hidden ref (by default, such a request is rejected). See also &lt;code&gt;uploadpack.hideRefs&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">Когда &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; , разрешите &lt;code&gt;upload-pack&lt;/code&gt; принимать запрос на выборку, который запрашивает объект в конце скрытой ссылки (по умолчанию такой запрос отклоняется). См. Также &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; . Даже если это неверно, клиент может иметь возможность украсть объекты с помощью методов, описанных в разделе &amp;laquo;БЕЗОПАСНОСТЬ&amp;raquo; &lt;a href=&quot;gitnamespaces&quot;&gt;справочной&lt;/a&gt; страницы gitnamespaces [7] ; лучше всего хранить личные данные в отдельном репозитории.</target>
        </trans-unit>
        <trans-unit id="5f953a201b0ae4d35f35034718b3114ef928787f" translate="yes" xml:space="preserve">
          <source>When Git doesn&amp;rsquo;t know how to handle a certain transport protocol, it attempts to use the &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:</source>
          <target state="translated">Когда Git не знает, как обрабатывать определенный транспортный протокол, он пытается использовать удаленный помощник &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; , если он существует. Чтобы явно запросить удаленный помощник, можно использовать следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="cf58a154a8f8fa8889640812d376b7964ce7bef2" translate="yes" xml:space="preserve">
          <source>When Git encounters a URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; is a protocol that it cannot handle natively, it automatically invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">Когда Git встречает URL-адрес формы &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; , где &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; - это протокол, который он не может обрабатывать изначально, он автоматически вызывает &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; с полным URL-адресом в качестве второго аргумента. Если такой URL-адрес встречается непосредственно в командной строке, первый аргумент совпадает со вторым, а если он встречается на настроенном удаленном компьютере, первым аргументом является имя этого пульта.</target>
        </trans-unit>
        <trans-unit id="27018e5bb4c8622ebcfed2f81b80284203c3bc2f" translate="yes" xml:space="preserve">
          <source>When Git encounters the first file that needs to be cleaned or smudged, it starts the filter and performs the handshake. In the handshake, the welcome message sent by Git is &quot;git-filter-client&quot;, only version 2 is supported, and the supported capabilities are &quot;clean&quot;, &quot;smudge&quot;, and &quot;delay&quot;.</source>
          <target state="translated">Когда Git сталкивается с первым файлом,который необходимо очистить или смазать,он запускает фильтр и производит рукопожатие.В процессе рукопожатия приветственное сообщение от Git'а-&quot;git-filter-client&quot;,поддерживается только версия 2,а поддерживаемые возможности-&quot;чисто&quot;,&quot;размазывание&quot; и &quot;задержка&quot;.</target>
        </trans-unit>
        <trans-unit id="f51f886a7edb2e397d8670010685e9d17fb9bc09" translate="yes" xml:space="preserve">
          <source>When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">Когда Git требуется аутентификация для определенного контекста URL-адреса, хранилище учетных данных будет рассматривать этот контекст как шаблон для сопоставления с каждой записью в файле учетных данных. Если протокол, имя хоста и имя пользователя (если оно у нас уже есть) совпадают, то пароль возвращается в Git. См. Обсуждение конфигурации в &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="fbdc4494c8c569621bd35073fd02055c267f7e54" translate="yes" xml:space="preserve">
          <source>When Git needs to show you a diff for the path with &lt;code&gt;diff&lt;/code&gt; attribute set to &lt;code&gt;jcdiff&lt;/code&gt;, it calls the command you specified with the above configuration, i.e. &lt;code&gt;j-c-diff&lt;/code&gt;, with 7 parameters, just like &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; program is called. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Когда Git нужно показать вам diff для пути с атрибутом &lt;code&gt;diff&lt;/code&gt; , установленным на &lt;code&gt;jcdiff&lt;/code&gt; , он вызывает команду, указанную вами в приведенной выше конфигурации, то есть &lt;code&gt;j-c-diff&lt;/code&gt; , с 7 параметрами, точно так же, как &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; программа GIT_EXTERNAL_DIFF . Подробнее см. &lt;a href=&quot;git&quot;&gt;Git [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb3065603615c6a64dfcb623c10f42c6b9e417fa" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;git push --signed&lt;/code&gt; sent a push certificate with a &quot;nonce&quot; that was issued by a receive-pack serving the same repository within this many seconds, export the &quot;nonce&quot; found in the certificate to &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; to the hooks (instead of what the receive-pack asked the sending side to include). This may allow writing checks in &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;post-receive&lt;/code&gt; a bit easier. Instead of checking &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; environment variable that records by how many seconds the nonce is stale to decide if they want to accept the certificate, they only can check &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; is &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">Когда &lt;code&gt;git push --signed&lt;/code&gt; отправил push-сертификат с &quot;nonce&quot;, который был выдан пакетом приема, обслуживающим тот же репозиторий, в течение этого количества секунд, экспортируйте &quot;nonce&quot;, найденный в сертификате, в &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; на хуки (вместо что пакет приема просил включить отправляющую сторону). Это может немного упростить написание чеков в режимах &lt;code&gt;pre-receive&lt;/code&gt; и &lt;code&gt;post-receive&lt;/code&gt; . Вместо проверки переменной среды &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; , которая записывает, на сколько секунд одноразовый номер устарел, чтобы решить, хотят ли они принять сертификат, они могут только проверить, что &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; в &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f34a76491c47ddfcf2959dd6944574eeda479afa" translate="yes" xml:space="preserve">
          <source>When a command has finished, and the client has received the entire response from the server, a client can either request that another command be executed or can terminate the connection. A client may optionally send an empty request consisting of just a flush-pkt to indicate that no more requests will be made.</source>
          <target state="translated">Когда команда завершена,и клиент получил весь ответ от сервера,клиент может либо запросить выполнение другой команды,либо прервать соединение.По желанию клиент может отправить пустой запрос,состоящий только из flush-pkt,чтобы указать,что больше никаких запросов не будет выполняться.</target>
        </trans-unit>
        <trans-unit id="98e606d10b24cc0c03b08a4efd9e014e2a7d092f" translate="yes" xml:space="preserve">
          <source>When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, &lt;code&gt;git commit&lt;/code&gt; creates a new commit &lt;code&gt;d&lt;/code&gt;, whose parent is commit &lt;code&gt;c&lt;/code&gt;, and then updates branch &lt;code&gt;master&lt;/code&gt; to refer to new commit &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;HEAD&lt;/code&gt; still refers to branch &lt;code&gt;master&lt;/code&gt; and so indirectly now refers to commit &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">Когда в этом состоянии создается фиксация, ветка обновляется, чтобы ссылаться на новую фиксацию. В частности, &lt;code&gt;git commit&lt;/code&gt; создает новый коммит &lt;code&gt;d&lt;/code&gt; , родительским элементом которого является commit &lt;code&gt;c&lt;/code&gt; , а затем обновляет &lt;code&gt;master&lt;/code&gt; ветки, чтобы он ссылался на новый коммит &lt;code&gt;d&lt;/code&gt; . &lt;code&gt;HEAD&lt;/code&gt; по- прежнему относится к &lt;code&gt;master&lt;/code&gt; ветки и теперь косвенно относится к фиксации &lt;code&gt;d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a1d656a10ad8d92cd23d5675fa9c3ba2b92a8d6f" translate="yes" xml:space="preserve">
          <source>When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), do not dump data (that is, only dump info lines and headers).</source>
          <target state="translated">Когда трассировка curl включена (см. &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; выше), не выгружайте данные (то есть выгружайте только информационные строки и заголовки).</target>
        </trans-unit>
        <trans-unit id="855748d09cda03242c615ed9f83d928cff4dd252" translate="yes" xml:space="preserve">
          <source>When a fetch mirror is created with &lt;code&gt;--mirror=fetch&lt;/code&gt;, the refs will not be stored in the &lt;code&gt;refs/remotes/&lt;/code&gt; namespace, but rather everything in &lt;code&gt;refs/&lt;/code&gt; on the remote will be directly mirrored into &lt;code&gt;refs/&lt;/code&gt; in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits.</source>
          <target state="translated">Когда зеркало выборки создается с помощью &lt;code&gt;--mirror=fetch&lt;/code&gt; , ссылки не будут храниться в пространстве имен &lt;code&gt;refs/remotes/&lt;/code&gt; , а скорее все, что находится в &lt;code&gt;refs/&lt;/code&gt; на удаленном компьютере, будет напрямую отражено в &lt;code&gt;refs/&lt;/code&gt; в локальном репозитории. Эта опция имеет смысл только в чистых репозиториях, потому что выборка перезапишет любые локальные коммиты.</target>
        </trans-unit>
        <trans-unit id="747511f053f093bdd8637c2efa65029ba86d5e79" translate="yes" xml:space="preserve">
          <source>When a git process is a (direct or indirect) child of another git process, it inherits Trace2 context information. This allows the child to print the command hierarchy. This example shows gc as child[3] of fetch. When the gc process reports its name as &quot;gc&quot;, it also reports the hierarchy as &quot;fetch/gc&quot;. (In this example, trace2 messages from the child process is indented for clarity.)</source>
          <target state="translated">Когда git-процесс является (прямым или косвенным)дочерним процессом другого git-процесса,он наследует контекстную информацию Trace2.Это позволяет дочернему процессу распечатывать иерархию команд.В данном примере gc показан как дочерний[3]fetch.Когда процесс gc сообщает своё имя как &quot;gc&quot;,он также сообщает иерархию как &quot;fetch/gc&quot;.(В этом примере сообщения trace2 от дочернего процесса имеют отступы для большей ясности).</target>
        </trans-unit>
        <trans-unit id="79294381fcaa0a0dccaa2b41ac29dc7daa74e3f5" translate="yes" xml:space="preserve">
          <source>When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries) so that &lt;code&gt;git pull&lt;/code&gt; will appropriately merge from the remote-tracking branch. This behavior may be changed via the global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration flag. That setting can be overridden by using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options, and changed later using &lt;code&gt;git branch --set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">Когда локальная ветка запускается из ветки удаленного отслеживания, Git настраивает ветку (в частности, записи конфигурации &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; и &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; ), чтобы &lt;code&gt;git pull&lt;/code&gt; соответствующим образом объединялся с удаленными Отслеживающая ветка. Это поведение можно изменить с помощью глобального &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; конфигурации branch.autoSetupMerge . Этот параметр можно переопределить с помощью параметров &lt;code&gt;--track&lt;/code&gt; и --no &lt;code&gt;--no-track&lt;/code&gt; , а позже изменить с помощью &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e12783acd89ac9262429bc89fcf85d9b95e88c1" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens during switching branches with the &lt;code&gt;-m&lt;/code&gt; option, you would see something like this:</source>
          <target state="translated">Когда возникает конфликт слияния во время переключения ветвей с параметром &lt;code&gt;-m&lt;/code&gt; , вы увидите что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="8b8f6236a48634fd451e67557b1ed432c992a4a6" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with &lt;code&gt;git add&lt;/code&gt; (or &lt;code&gt;git rm&lt;/code&gt; if the merge should result in deletion of the path).</source>
          <target state="translated">Когда происходит конфликт слияния, записи индекса для конфликтующих путей не объединяются, и вам необходимо разрешить конфликты и пометить разрешенные пути с помощью &lt;code&gt;git add&lt;/code&gt; (или &lt;code&gt;git rm&lt;/code&gt; , если слияние должно привести к удалению пути).</target>
        </trans-unit>
        <trans-unit id="054b9e9957838ff74728498487ffff5f26346d88" translate="yes" xml:space="preserve">
          <source>When a merge isn&amp;rsquo;t resolved automatically, Git leaves the index and the working tree in a special state that gives you all the information you need to help resolve the merge.</source>
          <target state="translated">Когда слияние не разрешается автоматически, Git оставляет индекс и рабочее дерево в особом состоянии, которое дает вам всю информацию, необходимую для разрешения слияния.</target>
        </trans-unit>
        <trans-unit id="1d6b6e4ed4a39cb92155b19d26f3a8478b8d6d5c" translate="yes" xml:space="preserve">
          <source>When a new branch is created with &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see &quot;branch.&amp;lt;name&amp;gt;.rebase&quot;). When &lt;code&gt;never&lt;/code&gt;, rebase is never automatically set to true. When &lt;code&gt;local&lt;/code&gt;, rebase is set to true for tracked branches of other local branches. When &lt;code&gt;remote&lt;/code&gt;, rebase is set to true for tracked branches of remote-tracking branches. When &lt;code&gt;always&lt;/code&gt;, rebase will be set to true for all tracking branches. See &quot;branch.autoSetupMerge&quot; for details on how to set up a branch to track another branch. This option defaults to never.</source>
          <target state="translated">Когда создается новая ветка с помощью &lt;code&gt;git branch&lt;/code&gt; , &lt;code&gt;git switch&lt;/code&gt; или &lt;code&gt;git checkout&lt;/code&gt; , которая отслеживает другую ветку, эта переменная сообщает Git настроить pull для перебазирования вместо слияния (см. &amp;laquo;Branch. &amp;lt;name&amp;gt; .rebase&amp;raquo;). Когда &lt;code&gt;never&lt;/code&gt; , для rebase автоматически не устанавливается значение true. Когда &lt;code&gt;local&lt;/code&gt; , rebase имеет значение true для отслеживаемых ветвей других локальных ветвей. В &lt;code&gt;remote&lt;/code&gt; rebase имеет значение true для отслеживаемых ветвей ветвей удаленного отслеживания. Когда &lt;code&gt;always&lt;/code&gt; , для всех ветвей отслеживания будет установлено значение true. См. &amp;laquo;Branch.autoSetupMerge&amp;raquo; для получения подробной информации о том, как настроить ветку для отслеживания другой ветки. По умолчанию этот параметр никогда не используется.</target>
        </trans-unit>
        <trans-unit id="ed0adff8e63a6741e1694d5ebc304264bd392424" translate="yes" xml:space="preserve">
          <source>When a patch failure occurs, &amp;lt;msg&amp;gt; will be printed to the screen before exiting. This overrides the standard message informing you to use &lt;code&gt;--continue&lt;/code&gt; or &lt;code&gt;--skip&lt;/code&gt; to handle the failure. This is solely for internal use between &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">Когда происходит сбой исправления, перед выходом на экран выводится &amp;lt;msg&amp;gt;. Это отменяет стандартное сообщение, информирующее вас об использовании &lt;code&gt;--continue&lt;/code&gt; или &lt;code&gt;--skip&lt;/code&gt; для обработки сбоя. Это исключительно для внутреннего использования между &lt;code&gt;git rebase&lt;/code&gt; и &lt;code&gt;git am&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b066fa036c4bb98c79472fbdf38de3d119f100" translate="yes" xml:space="preserve">
          <source>When a patch is part of an ongoing discussion, the patch generated by &lt;code&gt;git format-patch&lt;/code&gt; can be tweaked to take advantage of the &lt;code&gt;git am --scissors&lt;/code&gt; feature. After your response to the discussion comes a line that consists solely of &quot;&lt;code&gt;-- &amp;gt;8 --&lt;/code&gt;&quot; (scissors and perforation), followed by the patch with unnecessary header fields removed:</source>
          <target state="translated">Когда патч является частью продолжающегося обсуждения, патч, созданный с помощью &lt;code&gt;git format-patch&lt;/code&gt; , может быть изменен, чтобы использовать преимущества функции &lt;code&gt;git am --scissors&lt;/code&gt; . После вашего ответа на обсуждение идет строка, состоящая исключительно из &amp;laquo; &lt;code&gt;-- &amp;gt;8 --&lt;/code&gt; &amp;raquo; (ножницы и перфорация), за которой следует патч с удаленными ненужными полями заголовка:</target>
        </trans-unit>
        <trans-unit id="f3cb24e54c9837370739d06bd25b8c911a05ee6b" translate="yes" xml:space="preserve">
          <source>When a path is in the &quot;unmerged&quot; state, running &lt;code&gt;git update-index&lt;/code&gt; for that path tells Git to mark the path resolved.</source>
          <target state="translated">Когда путь находится в &amp;laquo;несвязанном&amp;raquo; состоянии, запуск &lt;code&gt;git update-index&lt;/code&gt; для этого пути сообщает Git пометить путь как разрешенный.</target>
        </trans-unit>
        <trans-unit id="f8965008f9824bf8da0b033710c2d7ac1f3f6568" translate="yes" xml:space="preserve">
          <source>When a pure mode change is encountered (which has no index information), the information is read from the current index instead.</source>
          <target state="translated">Когда происходит чистое изменение режима (в котором нет информации об индексе),информация считывается из текущего индекса.</target>
        </trans-unit>
        <trans-unit id="ef4651b07e5b8cb97cb93de85df1d7e556426d24" translate="yes" xml:space="preserve">
          <source>When a push mirror is created with &lt;code&gt;--mirror=push&lt;/code&gt;, then &lt;code&gt;git push&lt;/code&gt; will always behave as if &lt;code&gt;--mirror&lt;/code&gt; was passed.</source>
          <target state="translated">Когда push-зеркало создается с помощью &lt;code&gt;--mirror=push&lt;/code&gt; , тогда &lt;code&gt;git push&lt;/code&gt; всегда будет вести себя так, как если &lt;code&gt;--mirror&lt;/code&gt; было передано --mirror .</target>
        </trans-unit>
        <trans-unit id="deb13d30f8ba66c920f6495f36b99921916b0fbc" translate="yes" xml:space="preserve">
          <source>When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:</source>
          <target state="translated">В случае,когда для разрешения конфликтов слияния требуется rebase,сравните изменения,внесенные rebase непосредственно после использования:</target>
        </trans-unit>
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">При обновлении ссылки создаются записи журнала ссылок, чтобы отслеживать причину обновления ссылки (обычно это имя высокоуровневой команды, обновившей ссылку), в дополнение к старому и новому значениям ссылки. , Запрограммированная команда Porcelain может использовать вспомогательную функцию set_reflog_action в &lt;code&gt;git-sh-setup&lt;/code&gt; , чтобы задать имя этой переменной, когда она вызывается конечным пользователем как команда верхнего уровня, для записи в теле журнала reflog.</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">Когда репозиторий синхронизируется с помощью &lt;code&gt;git push&lt;/code&gt; и &lt;code&gt;git pull&lt;/code&gt; , объекты, упакованные в исходный репозиторий, обычно хранятся в распакованном виде в месте назначения. Хотя это позволяет вам использовать разные стратегии упаковки на обоих концах, это также означает, что вам может потребоваться время от времени переупаковывать оба репозитория.</target>
        </trans-unit>
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">Когда в скриптовом языке действует специальная котировка,все,что находится между атомом открытия верхнего уровня и его соответствием %(end),оценивается в соответствии с семантикой атома открытия,и цитируется только его результат от атома открытия верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">Когда говорят, что переменная принимает логическое значение, многие синонимы принимаются для &lt;code&gt;true&lt;/code&gt; и &lt;code&gt;false&lt;/code&gt; ; все они нечувствительны к регистру.</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">При принятии нового кода для ветки поставщика вы,вероятно,захотите записать как удаление путей,так и добавление новых,а также изменение существующих путей.</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">При принятии подписанного push-уведомления (см. &lt;a href=&quot;git-push&quot;&gt;Git-push [1]&lt;/a&gt; ) подписанный push-сертификат сохраняется в &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; объекте, и имя объекта можно узнать в переменной среды GIT_PUSH_CERT . См. Пример в описании обработчика &lt;code&gt;post-receive&lt;/code&gt; . Кроме того, сертификат проверяется с помощью GPG, и результат экспортируется со следующими переменными среды:</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">При получении учетных данных важно учитывать компонент &amp;laquo;путь&amp;raquo; URL-адреса http или https. По умолчанию - false. См. &lt;a href=&quot;gitcredentials&quot;&gt;Gitcredentials [7]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">При добавлении заметок к объекту,в котором уже есть заметки,перезапишите существующие заметки (вместо прерывания).</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">При рекламе подсказок доступной истории от альтернативы используйте оболочку для выполнения указанной команды вместо &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; . Первый аргумент - это абсолютный путь альтернативы. Вывод должен содержать по одному шестнадцатеричному идентификатору объекта в каждой строке (то есть такой же, как полученный &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">Когда аргумент может быть неправильно истолкован как пересмотр или как путь, они могут быть устранены путем помещения &lt;code&gt;--&lt;/code&gt; между ними. Например, &lt;code&gt;git diff -- HEAD&lt;/code&gt; : &amp;laquo;У меня есть файл с именем HEAD в моем рабочем дереве. Пожалуйста, покажите изменения между версией, которую я разместил в индексе, и тем, что у меня есть в рабочем дереве для этого файла&amp;raquo;, а не &amp;laquo;покажите разницу между HEAD коммит и дерево работы в целом &quot;. Вы можете сказать &lt;code&gt;git diff HEAD --&lt;/code&gt; чтобы запросить последнее.</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">Если аргумент может пониматься либо как ссылка, либо как имя файла, выберите его понимание как аргумент патча формата ( &lt;code&gt;--format-patch&lt;/code&gt; ) или как имя файла ( &lt;code&gt;--no-format-patch&lt;/code&gt; ). По умолчанию, когда возникает такой конфликт, git send-email не работает.</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">Когда интерактивная команда (например, &lt;code&gt;git add --patch&lt;/code&gt; ) показывает раскрашенное различие, git передает различие через команду оболочки, определенную этой переменной конфигурации. Команда может дополнительно разметить разницу для использования человеком при условии, что она сохраняет взаимно однозначное соответствие со строками в исходной разнице. По умолчанию отключено (без фильтрации).</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">Когда в качестве аргумента указывается необязательное имя Git-ветки (или имя объекта Git-комита),подкоманда работает на указанной ветке,а не на текущей.</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">Когда обновление изменяет ответвление (или,в общем случае,ссылку),которое раньше указывало на фиксацию А,чтобы указать на другую фиксацию Б,оно называется быстрым перемотным обновлением,если и только если Б является потомком А.</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">При применении патча обнаруживайте новую или измененную строку с ошибками в виде пробелов. То, что считается &lt;code&gt;core.whitespace&lt;/code&gt; пробелов, контролируется конфигурацией core.whitespace . По умолчанию завершающие пробелы (включая строки, состоящие исключительно из пробелов) и символ пробела, за которым сразу следует символ табуляции внутри начального отступа строки, считаются ошибками пробелов.</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">При применении патча игнорируйте дополнения, сделанные патчем. Это можно использовать для извлечения общей части между двумя файлами, сначала запустив для них &lt;code&gt;diff&lt;/code&gt; и применив результат с этой опцией, которая применила бы часть удаления, но не часть добавления.</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">При применении патча при необходимости игнорируйте изменения пробелов в контекстных строках. Строки контекста сохранят свои пробелы, и они не будут подвергаться исправлению пробелов независимо от значения параметра &lt;code&gt;--whitespace&lt;/code&gt; . Однако новые строки все равно будут исправлены.</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">При применении патча только к рабочему дереву, отметьте новые файлы, которые будут добавлены в индекс позже (см. &lt;code&gt;--intent-to-add&lt;/code&gt; в &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; ). Этот параметр игнорируется, если он не запущен в репозитории Git и не указан &lt;code&gt;--index&lt;/code&gt; . Обратите внимание, что &lt;code&gt;--index&lt;/code&gt; может подразумеваться другими параметрами, такими как &lt;code&gt;--cached&lt;/code&gt; или &lt;code&gt;--3way&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">При запросе на &lt;code&gt;abort&lt;/code&gt; (по умолчанию) эта программа умирает при обнаружении подписанного тега. С &lt;code&gt;strip&lt;/code&gt; теги будут автоматически сделаны без подписи, с &lt;code&gt;warn-strip&lt;/code&gt; они будут сделаны без подписи, но будет отображаться предупреждение, &lt;code&gt;verbatim&lt;/code&gt; они будут экспортированы без &lt;code&gt;warn&lt;/code&gt; , а с warn они будут экспортированы, но вы увидите предупреждение ,</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">При запросе на &lt;code&gt;abort&lt;/code&gt; (по умолчанию) эта программа умрет при обнаружении такого тега. С &lt;code&gt;drop&lt;/code&gt; такие теги будут исключены из вывода. При &lt;code&gt;rewrite&lt;/code&gt; , если помеченный объект является фиксацией, он перезапишет тег, чтобы пометить фиксацию предка (посредством родительской перезаписи; см. &lt;a href=&quot;git-rev-list&quot;&gt;Git-rev-list [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">При вызове с параметром &lt;code&gt;--incremental&lt;/code&gt; команда выводит результат в том виде, в каком он был построен. Вывод обычно будет говорить о строках, затронутых более поздними коммитами (т.е. строки будут аннотированы не по порядку) и предназначен для использования интерактивными программами просмотра.</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">При проверке путей из индекса проверьте этап № 2 ( &lt;code&gt;ours&lt;/code&gt; ) или № 3 ( &lt;code&gt;theirs&lt;/code&gt; ) для несвязанных путей.</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">При извлечении путей из индекса не обманывайте неупорядоченные записи;вместо этого неупорядоченные записи игнорируются.</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">При выделении путей из индекса эта опция позволяет воссоздать объединенное слияние в указанных путях.</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">При клонировании репозитория SVN, если не используется ни один из вариантов описания макета репозитория (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; создаст репозиторий Git с полностью линейной историей, где ветки и теги отображаются в рабочей копии как отдельные каталоги. Хотя это самый простой способ получить копию полного репозитория, для проектов с большим количеством ветвей рабочая копия будет во много раз больше, чем просто основная часть. Таким образом, для проектов, использующих стандартную структуру каталогов (ствол / ветки / теги), рекомендуется клонировать с опцией &lt;code&gt;--stdlayout&lt;/code&gt; , Если в проекте используется нестандартная структура и / или если ветки и теги не требуются, проще всего клонировать только один каталог (обычно магистральный), не задавая никаких параметров макета репозитория. Если требуется полная история с ветками и тегами, необходимо использовать параметры &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">При клонировании или извлечении репозитория, содержащего подмодули, подмодули не будут извлечены по умолчанию; Вы можете указать &lt;code&gt;clone&lt;/code&gt; на рекурсию в подмодули. В &lt;code&gt;init&lt;/code&gt; и &lt;code&gt;update&lt;/code&gt; подкоманды &lt;code&gt;git submodule&lt;/code&gt; будет поддерживать подмодулях проверили и на соответствующем пересмотре в вашем рабочем дереве. В качестве альтернативы вы можете установить &lt;code&gt;submodule.recurse&lt;/code&gt; иметь &lt;code&gt;checkout&lt;/code&gt; рекурсии в подмодули.</target>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">При фиксации исправлений рассмотрите возможность использования &lt;code&gt;merge&lt;/code&gt; для подключения фиксации (ов), которые предоставляют версии файлов в ветку исправлений. Это позволит таким инструментам, как &lt;code&gt;git blame&lt;/code&gt; , отслеживать реальную историю коммитов и правильно аннотировать исходные файлы.</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">При фиксации в svn из Git (как часть операций &lt;code&gt;set-tree&lt;/code&gt; или &lt;code&gt;dcommit&lt;/code&gt; ), если в существующем сообщении журнала еще нет строки &lt;code&gt;From:&lt;/code&gt; или &lt;code&gt;Signed-off-by:&lt;/code&gt; , добавьте строку &lt;code&gt;From:&lt;/code&gt; на основе коммита Git авторская строка. Если вы используете это, то &lt;code&gt;--use-log-author&lt;/code&gt; будет получать действительную строку автора для всех коммитов.</target>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">Когда выполняются обычные операции по созданию объектов, они проверяют, существенно ли увеличился репозиторий с момента последнего обслуживания, и если да, то запускают &lt;code&gt;git gc&lt;/code&gt; автоматически. См. &lt;code&gt;gc.auto&lt;/code&gt; ниже, чтобы узнать, как отключить это поведение.</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">При сравнении двух деревьев,перед разницей выводится идентификатор обоих деревьев (разделенных пробелом и завершенных новой строкой).При сравнении коммитов выводится идентификатор первой (или единственной)коммиты,за которой следует новая строка.</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">При преобразовании значения в его каноническую форму с использованием &lt;code&gt;--type=bool&lt;/code&gt; типа --type = bool , &lt;code&gt;git config&lt;/code&gt; гарантирует, что вывод будет &amp;laquo;истинным&amp;raquo; или &amp;laquo;ложным&amp;raquo; (написанным строчными буквами).</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">При копировании удаленного репозитория вы захотите как минимум обновить кеш индекса, когда вы это сделаете, и особенно с репозиториями других людей вы часто хотите убедиться, что кеш индекса находится в каком-то известном состоянии (вы не знаю , &lt;strong&gt;что&lt;/strong&gt; они сделали , и еще не зарегистрировались), поэтому , как правило , вы будете предшествовать &lt;code&gt;git update-index&lt;/code&gt; с а</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">При копировании заметок во время перезаписи (см. Параметр &amp;laquo;notes.rewrite. &amp;lt;command&amp;gt;&amp;raquo;) определяет, что делать, если у целевого коммита уже есть заметка. Должен быть одним из вариантов &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; . По умолчанию &lt;code&gt;concatenate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">При копировании заметок во время перезаписи укажите (полностью квалифицированный)номер ссылки,чьи заметки должны быть скопированы.Это может быть глобус,в этом случае будут скопированы заметки во всех совпадающих ссылках.Вы также можете указать эту конфигурацию несколько раз.</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">При копировании заметок во время перезаписи укажите (полностью квалифицированный)номер ссылки,чьи заметки следует скопировать.Ссылка может быть глобусом,в этом случае будут скопированы заметки во всех совпадающих ссылках.Вы также можете указать эту конфигурацию несколько раз.</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">Что делать при копировании заметок во время перезаписи, если в целевом коммите уже есть заметка. Должен быть одним из вариантов &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; . По умолчанию &lt;code&gt;concatenate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">Что делать при копировании заметок во время перезаписи, если в целевом коммите уже есть заметка. Должен быть одним из вариантов &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; или &lt;code&gt;ignore&lt;/code&gt; . Это отменяет настройку &lt;code&gt;core.rewriteMode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">При создании новой ветки, если &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; является ветвью, пометьте ее как &amp;laquo;восходящую&amp;raquo; от новой ветки. Это значение по умолчанию, если &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; является ветвью удаленного отслеживания. См. &quot;--Track&quot; в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">При создании новой ветки настройте конфигурацию &amp;laquo;восходящего потока&amp;raquo;. &lt;code&gt;-c&lt;/code&gt; подразумевается. См. &lt;code&gt;--track&lt;/code&gt; в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">При создании новой ветки настройте конфигурацию &amp;laquo;восходящего потока&amp;raquo;. См. &quot;--Track&quot; в &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; для подробностей.</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">При создании новой ветви настройте записи конфигурации &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; и &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; , чтобы отметить ветвь начальной точки как &amp;laquo;восходящую&amp;raquo; от новой ветки. Эта конфигурация скажет git показать взаимосвязь между двумя ветвями в &lt;code&gt;git status&lt;/code&gt; и &lt;code&gt;git branch -v&lt;/code&gt; . Кроме того, он предписывает &lt;code&gt;git pull&lt;/code&gt; без аргументов извлекать из восходящего потока, когда новая ветка проверяется.</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">При создании упакованного архива в репозитории,содержащем существующие пакеты,команда повторно использует существующие дельты.В результате иногда получается несколько неоптимальный пакет.Этот флаг говорит команде не использовать существующие дельты повторно,а вычислять их с нуля.</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">При создании файлов добавьте &amp;lt;string&amp;gt; (обычно это каталог, содержащий завершающий /)</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">При работе с выводом &lt;code&gt;git diff-tree&lt;/code&gt; он использует тот факт, что патч имеет префикс с именем объекта фиксации и выводит две 40-байтовые шестнадцатеричные строки. Первая строка - это идентификатор патча, а вторая строка - это идентификатор фиксации. Это можно использовать для сопоставления идентификатора патча с идентификатором фиксации.</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">При принятии решения, какие атрибуты назначены пути, Git &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; (который имеет наивысший приоритет), файлу &lt;code&gt;.gitattributes&lt;/code&gt; в том же каталоге, что и рассматриваемый путь, и его родительским каталогам до верхнего уровня дерево работы (чем дальше каталог, содержащий &lt;code&gt;.gitattributes&lt;/code&gt; , от рассматриваемого пути, тем ниже его приоритет). Наконец, рассматриваются глобальные и общесистемные файлы (они имеют самый низкий приоритет).</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">При деинициализации или удалении (см. Ниже) каталог Git подмодуля автоматически перемещается в &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; суперпроекта.</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">При отображении имен доступных объектов в дополнение к SHA-1 также отображается имя, описывающее, &lt;strong&gt;как&lt;/strong&gt; они достижимы, совместимые с &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; , например &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">При выполнении пробного прогона дайте результат в формате, готовом для фарфора. Подробнее см. &lt;a href=&quot;git-status&quot;&gt;Git-status [1]&lt;/a&gt; . Подразумевает &lt;code&gt;--dry-run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">При выполнении пробного прогона дайте результат в длинном формате. Подразумевает &lt;code&gt;--dry-run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">При выполнении пробного прогона дайте результат в кратком формате. Подробнее см. &lt;a href=&quot;git-status&quot;&gt;Git-status [1]&lt;/a&gt; . Подразумевает &lt;code&gt;--dry-run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">При преобразовании репозитория используйте уникальную метку для каждой фиксации ( &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; ) и укажите параметр --export-Mark в командной строке. fast-import создаст дамп файла, в котором перечислены все метки и соответствующий ей объект Git SHA-1. Если интерфейс может привязать метки обратно к исходному репозиторию, легко проверить точность и полноту импорта, сравнив каждую фиксацию Git с соответствующей исходной ревизией.</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">При редактировании сообщения о фиксации запустите редактор с содержимым данного файла. &lt;code&gt;commit.template&lt;/code&gt; переменной конфигурации часто используются , чтобы дать этот параметр неявно к команде. Этот механизм может использоваться проектами, которые хотят дать участникам подсказки о том, что писать в сообщении в каком порядке. Если пользователь выходит из редактора, не отредактировав сообщение, фиксация прерывается. Это не действует, если сообщение отправлено другими способами, например, с параметрами &lt;code&gt;-m&lt;/code&gt; или &lt;code&gt;-F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">При редактировании,предоставьте необработанное содержимое объекта,а не красиво напечатанное.В настоящее время это касается только деревьев,которые будут отображаться в их двоичном виде.С этим сложнее работать,но это может помочь при восстановлении дерева,которое настолько повреждено,что не может быть красиво напечатано.Обратите внимание,что вам может понадобиться настроить редактор на чистое чтение и запись двоичных данных.</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">Если этот параметр включен, обработчик &lt;code&gt;post-update&lt;/code&gt; по умолчанию запускает &lt;code&gt;git update-server-info&lt;/code&gt; , чтобы поддерживать информацию, используемую &amp;laquo;тупыми&amp;raquo; транспортами (например, HTTP), в актуальном состоянии. Если вы публикуете репозиторий Git, доступный через HTTP, вам, вероятно, следует включить эту ловушку.</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">При обнаружении сообщения или темы, отличной от ASCII, которые не объявляют свою кодировку, добавьте заголовки / цитаты, чтобы указать, что они закодированы в &amp;lt;encoding&amp;gt;. По умолчанию используется значение &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; ; если это не указано, будет запрошено, если будут обнаружены какие-либо файлы, отличные от ASCII.</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">При стирании учетных данных,соответствующие учетные данные будут удалены из всех файлов.</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">Когда включен extension.worktreeConfig, файл конфигурации &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; читается после &lt;code&gt;.git/config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">При ложном срабатывании слить текущее ответвление с восходящим.</target>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">При извлечении ссылок, перечисленных в командной строке, используйте указанный refspec (может быть задан более одного раза) для сопоставления ссылок с ветвями удаленного отслеживания вместо значений переменных конфигурации &lt;code&gt;remote.*.fetch&lt;/code&gt; для удаленного репозитория. См. Подробности в разделе &amp;laquo;Настроенные ветви удаленного отслеживания&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">Когда файлы изменяются вне Git, пользователю нужно будет явно обработать измененные файлы (например, см. Раздел &amp;laquo; &lt;code&gt;Examples&lt;/code&gt; &amp;raquo; в &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; ). Git обычно не обнаруживает изменений в этих файлах.</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">При фильтрации истории с &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; , не подрезать немного истории. (См. &amp;laquo;Упрощение истории&amp;raquo; в &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; для более подробного объяснения.)</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">При первом создании объекты хранятся в отдельных файлах,но для большей эффективности в дальнейшем могут быть сжаты вместе в &quot;пакетные файлы&quot;.</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">Когда задан диапазон отображаемых &lt;code&gt;commit1..commit2&lt;/code&gt; (например, commit1..commit2 или &lt;code&gt;commit2 ^commit1&lt;/code&gt; ), отображать только те коммиты, которые существуют непосредственно в цепочке предков между &lt;code&gt;commit1&lt;/code&gt; и &lt;code&gt;commit2&lt;/code&gt; , т.е. коммиты, которые являются потомками &lt;code&gt;commit1&lt;/code&gt; и предками &lt;code&gt;commit2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">Когда задан диапазон отображаемых &lt;code&gt;commit1..commit2&lt;/code&gt; (например, commit1..commit2 или &lt;code&gt;commit2 ^commit1&lt;/code&gt; ), отображать только те коммиты, которые существуют непосредственно в цепочке предков между &lt;code&gt;commit1&lt;/code&gt; и &lt;code&gt;commit2&lt;/code&gt; , т.е. коммиты, которые являются потомками &lt;code&gt;commit1&lt;/code&gt; и предками &lt;code&gt;commit2&lt;/code&gt; . (См. &amp;laquo;Упрощение истории&amp;raquo; в &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; для более подробного объяснения.)</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">При задании имени section.key, состоящего из двух частей, возвращается значение для section. &amp;lt;url&amp;gt; .key, часть &amp;lt;url&amp;gt; которого лучше всего соответствует заданному URL-адресу (если такой ключ не существует, используется значение для section.key как запасной вариант). Если в качестве имени указан только раздел, сделайте это для всех ключей в разделе и перечислите их. Возвращает код ошибки 1, если значение не найдено.</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">Когда указан номер версии SVN в форме &lt;code&gt;rN&lt;/code&gt; , возвращает соответствующий хеш фиксации Git (при желании за ним может следовать древовидный код, указывающий, в какой ветви следует искать). Когда задано дерево, возвращает соответствующий номер версии SVN.</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">Когда дано,а доступ к репозиторию для клонирования осуществляется через ssh,это указывает путь,не по умолчанию,для команды,запущенной на другом конце.</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">Когда он задан, и репозиторий, из которого выполняется выборка, обрабатывается &lt;code&gt;git fetch-pack&lt;/code&gt; , &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; чтобы указать путь , отличный от пути по умолчанию для команды, выполняемой на другом конце.</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">При &lt;code&gt;--or&lt;/code&gt; нескольких шаблонных выражений в сочетании с --or этот флаг указывается, чтобы ограничить совпадение файлами, в которых есть строки, соответствующие всем из них.</target>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">Когда он готов, он говорит Алисе получить изменения из репозитория в / home / bob / myrepo. Она делает это с помощью:</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">При импорте переименованного файла или каталога просто удалите старое имя (имена)и измените новое имя (имена)во время соответствующей фиксации.Git выполняет определение переименования после факта,а не явно во время фиксации.</target>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">В режиме списка покажите sha1 и зафиксируйте строку темы для каждого заголовка вместе с отношением к восходящей ветке (если есть). Если задано дважды, выведите путь к связанному рабочему дереву (если есть), а также имя восходящей ветки (см. Также &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; ). Обратите внимание, что путь HEAD текущего рабочего дерева не будет напечатан (это всегда будет ваш текущий каталог).</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">Когда информационные ошибки включены,git-daemon будет сообщать клиенту о более многословных ошибках,различая такие условия,как &quot;такого репозитория нет&quot; и &quot;репозиторий не экспортируется&quot;.Это удобнее для клиентов,но может привести к утечке информации о существовании не экспортированных репозиториев.Когда информационные ошибки не включены,все ошибки сообщают клиенту &quot;доступ запрещен&quot;.По умолчанию -нет-неинформативные-ошибки.</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">При инициализации подмодулей файл &lt;code&gt;.gitmodules&lt;/code&gt; в каталоге верхнего уровня содержащего репозитория используется для поиска URL-адреса каждого подмодуля. Этот файл должен быть отформатирован так же, как &lt;code&gt;$GIT_DIR/config&lt;/code&gt; . Ключом к URL каждого подмодуля является &amp;laquo;submodule. $ Name.url&amp;raquo;. Подробнее см. &lt;a href=&quot;gitmodules&quot;&gt;Gitmodules [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">При первоначальном вызове &lt;code&gt;git am&lt;/code&gt; вы даете ему имена почтовых ящиков для обработки. Увидев первый неприменимый патч, он прерывается на середине. Вы можете избавиться от этого одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">При вызове настраиваемого инструмента слияния Git использует набор временных файлов для передачи инструменту. Если инструмент возвращает ошибку и для этой переменной установлено значение &lt;code&gt;true&lt;/code&gt; , эти временные файлы будут сохранены, в противном случае они будут удалены после выхода из инструмента. По умолчанию - &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">Когда дело доходит до редактирования этого коммита, выполните &lt;code&gt;git reset HEAD^&lt;/code&gt; . В результате HEAD перематывается на единицу, и индекс следует за ним. Однако рабочее дерево остается прежним.</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">Когда неясно,как применить изменение,происходит следующее:</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">Когда неясно,как примирить изменения,происходит следующее:</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">При перечислении ссылок из альтернативного списка указывайте только те ссылки, которые начинаются с данного префикса. Префиксы совпадают, как если бы они были переданы в качестве аргументов для &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; . Чтобы перечислить несколько префиксов, разделите их пробелами. Если &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; , установка &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; не имеет никакого эффекта.</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">При листинге используйте указанный &amp;lt;format&amp;gt;, который может быть &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; и &lt;code&gt;long&lt;/code&gt; . Если не указано иное, по умолчанию используется &lt;code&gt;short&lt;/code&gt; формат .</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">Ослабляя недоступные объекты, не пытайтесь ослабить объекты старше &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; . Это можно использовать для оптимизации записи любых объектов, которые будут немедленно удалены с помощью последующей &lt;code&gt;git prune&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">При слиянии аннотированного (и, возможно, подписанного) тега Git всегда создает фиксацию слияния, даже если возможно быстрое слияние, и шаблон сообщения фиксации подготовлен с сообщением тега. Кроме того, если тег подписан, проверка подписи отображается как комментарий в шаблоне сообщения. См. Также &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">При слиянии нот,будьте более многословными.При обрезке заметок сообщайте имена всех объектов,чьи заметки удалены.</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">При объединении нот работайте тихо.</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">При слиянии нот разрешайте конфликты нот,используя данную стратегию.Признаются следующие стратегии:&quot;ручной&quot; (по умолчанию),&quot;наш&quot;,&quot;их&quot;,&quot;союз&quot; и &quot;cat_sort_uniq&quot;.Эта опция отменяет настройку конфигурации &quot;notes.mergeStrategy&quot;.См.ниже раздел &quot;NOTES MERGE STRATEGIES&quot; для получения дополнительной информации о каждой стратегии слияния записей.</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">Если он отсутствует или установлен по &lt;code&gt;default&lt;/code&gt; , многие поля в структуре stat проверяются, чтобы определить, был ли файл изменен с тех пор, как Git просмотрел его. Когда эта переменная конфигурации установлена ​​на &lt;code&gt;minimal&lt;/code&gt; , субсекундную часть mtime и ctime, uid и gid владельца файла, номер inode (и номер устройства, если Git был скомпилирован для его использования), исключаются из проверка среди этих полей, оставляя только целую вторую часть mtime (и ctime, если &lt;code&gt;core.trustCtime&lt;/code&gt; ) и размер файла для проверки.</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">Когда более одной детали совпадает с контуром,более поздняя линия перекрывает более раннюю.Это переопределение выполняется для каждого атрибута.</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">Когда перемещенные линии окрашиваются, например, с &lt;code&gt;diff.colorMoved&lt;/code&gt; параметра diff.colorMoved , этот параметр управляет &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; как обрабатываются пробелы. Подробные сведения о допустимых режимах см. &lt;code&gt;--color-moved-ws&lt;/code&gt; в &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">При выводе нескольких патчей префиксом темы будет &amp;laquo;[PATCH n / m]&amp;raquo;. Чтобы принудительно добавить 1/1 для одного патча, используйте &lt;code&gt;-n&lt;/code&gt; . Чтобы опустить номера патчей в теме, используйте &lt;code&gt;-N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">Когда используются несколько рабочих деревьев, большинство файлов в $ GIT_DIR относятся к каждому рабочему дереву, за некоторыми известными исключениями. Однако все файлы, находящиеся под &lt;code&gt;common&lt;/code&gt; именем, будут совместно использоваться всеми рабочими деревьями.</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">Когда ни командная строка, ни конфигурация не указывают, что следует отправлять, используется поведение по умолчанию, которое соответствует &lt;code&gt;simple&lt;/code&gt; значению для &lt;code&gt;push.default&lt;/code&gt; : текущая ветвь передается в соответствующую ветвь восходящего потока, но в качестве меры безопасности push прерывается, если восходящая ветвь не имеет того же имени, что и локальная.</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; не указан, предполагается &lt;code&gt;stash@{0}&lt;/code&gt; , в противном случае &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; должен быть ссылкой в ​​форме &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если в командной строке не &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; аргумент --push-option = &amp;lt;option&amp;gt; , &lt;code&gt;git push&lt;/code&gt; ведет себя так, как если бы каждое &amp;lt;value&amp;gt; этой переменной задано как &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">Если в командной строке не &lt;code&gt;--whitespace&lt;/code&gt; флаг --whitespace , этот элемент конфигурации используется по умолчанию.</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">Если в командной строке не было указано refspec, тогда &lt;code&gt;git pull&lt;/code&gt; использует refspec из конфигурации или &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; . В таких случаях применяются следующие правила:</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">Если удаленное управление не указано (через -r), ветвь &lt;code&gt;HEAD&lt;/code&gt; из CVS импортируется в &lt;code&gt;origin&lt;/code&gt; ветвь в репозитории Git, поскольку &lt;code&gt;HEAD&lt;/code&gt; уже имеет особое значение для Git. Когда указан пульт, ветвь &lt;code&gt;HEAD&lt;/code&gt; называется remotes / &amp;lt;remote&amp;gt; / master mirroring &lt;code&gt;git clone&lt;/code&gt; behavior. Используйте эту опцию, если вы хотите импортировать в другую ветку.</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">Если удаленный сервер не указан, по умолчанию будет использоваться &lt;code&gt;origin&lt;/code&gt; пульт, если только для текущей ветви не настроена восходящая ветвь.</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">Находясь на ветке &amp;lt;имя&amp;gt;, он переопределяет &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; для отправки . Он также переопределяет &lt;code&gt;remote.pushDefault&lt;/code&gt; для отправки из ветки &amp;lt;name&amp;gt;. Когда вы извлекаете из одного места (например, из вашего восходящего потока) и отправляете в другое место (например, в ваш собственный репозиторий публикации), вам нужно установить &lt;code&gt;remote.pushDefault&lt;/code&gt; , чтобы указать удаленный пульт для отправки для всех веток, и использовать этот параметр, чтобы переопределить его для конкретной ветки.</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">Находясь в ветке &amp;lt;name&amp;gt;, он сообщает &lt;code&gt;git fetch&lt;/code&gt; и &lt;code&gt;git push&lt;/code&gt; ,с какого пульта выбрать / нажать. Удаленный, на который нужно отправить, может быть переопределен с помощью &lt;code&gt;remote.pushDefault&lt;/code&gt; (для всех веток). Пульт дистанционного управления для текущей ветки может быть переопределен с помощью &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; . Если пульт не настроен или вы не находитесь в какой-либо ветке, по умолчанию используется &lt;code&gt;origin&lt;/code&gt; для выборки и &lt;code&gt;remote.pushDefault&lt;/code&gt; для отправки . Кроме того, &lt;code&gt;.&lt;/code&gt; (точка) - текущий локальный репозиторий (точка-репозиторий), см &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; последнее примечание branch. &amp;lt;name&amp;gt; .merge ниже.</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">При указании одного из этих флагов имя объекта,записанное для путей,не обновляется.Вместо этого,эти опции устанавливают и снимают бит &quot;fsmonitor valid&quot; для путей.См.ниже раздел &quot;Монитор файловой системы&quot; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">При указании одного из этих флагов имя объекта,записанное для путей,не обновляется.Вместо этого,эти опции устанавливают и снимают бит &quot;skip-worktree&quot; для путей.Дополнительные сведения см.в разделе &quot;Бит пропуска рабочего дерева&quot; ниже.</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Если один или несколько &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; указаны явно (в командной строке или с помощью &lt;code&gt;--stdin&lt;/code&gt; ), это может быть либо один шаблон, либо пара таких шаблонов, разделенных двоеточием &quot;:&quot; (это означает, что ссылка имя не может содержать двоеточие). Единственный шаблон &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; - это просто сокращение для &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">При упаковке капель быстрого импорта всегда пытаются опорочить последний написанный капля.Если это специально не устроено фронтендом,то,скорее всего,это будет не предыдущая версия того же файла,поэтому сгенерированная дельта будет не самой маленькой.Полученный пакетный файл будет сжат,но не будет оптимальным.</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">При передаче в &lt;code&gt;init&lt;/code&gt; или &lt;code&gt;clone&lt;/code&gt; это регулярное выражение будет сохранено как ключ конфигурации. Смотрите &lt;code&gt;fetch&lt;/code&gt; для описания &lt;code&gt;--ignore-paths&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">При передаче в &lt;code&gt;init&lt;/code&gt; или &lt;code&gt;clone&lt;/code&gt; это регулярное выражение будет сохранено как ключ конфигурации. См. &lt;code&gt;fetch&lt;/code&gt; для описания &lt;code&gt;--ignore-refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">При передаче в &lt;code&gt;init&lt;/code&gt; или &lt;code&gt;clone&lt;/code&gt; это регулярное выражение будет сохранено как ключ конфигурации. Смотрите &lt;code&gt;fetch&lt;/code&gt; для описания &lt;code&gt;--include-paths&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">Когда пути указаны, покажите их (обратите внимание, что на самом деле это не исходные имена путей, а скорее список шаблонов для сопоставления). В противном случае неявно использует корневой уровень дерева в качестве единственного аргумента пути.</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">Когда в командной строке указывается pathspec,зафиксируйте содержимое файлов,соответствующих pathspec,без записи изменений,уже добавленных в индекс.Содержимое этих файлов также инсценируется для следующей фиксации поверх того,что было инсценировано ранее.</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">Когда pathspec задается для &lt;code&gt;git stash push&lt;/code&gt; , новая запись stash записывает измененные состояния только для файлов, которые соответствуют pathspec. Записи индекса и файлы рабочего дерева затем откатываются до состояния HEAD только для этих файлов, оставляя неизменными файлы, которые не соответствуют pathspec.</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">Когда возможно, &lt;code&gt;pack-objects&lt;/code&gt; стараются повторно использовать существующие на диске дельты, чтобы избежать необходимости поиска новых на лету. Это важная оптимизация для обслуживания выборок, потому что это означает, что сервер может вообще избежать раздувания большинства объектов и просто отправлять байты прямо с диска. Эта оптимизация не может работать, когда объект хранится как дельта относительно базы, которой нет у получателя (и которую мы еще не отправляем). В этом случае сервер &amp;laquo;разрывает&amp;raquo; дельту и должен найти новый, у которого высокая стоимость процессора. Поэтому для производительности важно, чтобы набор объектов в дельта-отношениях на диске соответствовал тому, что клиент будет получать.</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">Если он присутствует, он также копирует значение &lt;code&gt;submodule.$name.update&lt;/code&gt; . $ Name.update . Эта команда не изменяет существующую информацию в .git / config. Затем вы можете настроить URL-адреса клонов подмодулей в .git / config для вашей локальной настройки и перейти к &lt;code&gt;git submodule update&lt;/code&gt; ; вы также можете просто использовать &lt;code&gt;git submodule update --init&lt;/code&gt; без явного шага &lt;code&gt;init&lt;/code&gt; если вы не собираетесь настраивать расположение каких-либо подмодулей.</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">При нажатии на пульт, отличный от пульта, с которого вы обычно подключаетесь, работайте как &lt;code&gt;current&lt;/code&gt; . Это самый безопасный вариант и подходит для новичков.</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">При нажатии,попросите удаленный сервер обновить ссылки в одной атомарной транзакции.В случае успеха все ссылки будут обновлены,или ни одна не будет обновлена.Если удаленная сторона не поддерживает эту возможность,нажатие будет неудачным.</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">При чтении переменной &lt;code&gt;core.repositoryformatversion&lt;/code&gt; реализация git, которая поддерживает версию 1, ДОЛЖНА также читать любые ключи конфигурации, найденные в разделе &lt;code&gt;extensions&lt;/code&gt; файла конфигурации.</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">При чтении трейлеров после токена,разделителя и значения могут быть белые пробела.Также внутри токена и значения могут быть пробелы.Значение может быть разбито на несколько строк с каждой последующей строкой,начинающейся с пробела,как,например,&quot;сгибание&quot; в RFC 822.</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">При чтении значения по умолчанию считываются из системных, глобальных и локальных файлов конфигурации репозитория, а параметры &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--local&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; и &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; могут использоваться для указания команда для чтения только из этого места (см. &lt;a href=&quot;#FILES&quot;&gt;ФАЙЛЫ&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">При записи фиксации добавьте строку с надписью &amp;laquo;(вишня, выбранная из фиксации&amp;hellip;)&amp;raquo; в исходное сообщение фиксации, чтобы указать, из какой фиксации было выбрано это изменение. Это делается только для вишенки без конфликтов. Не используйте эту опцию, если вы выбираете вишенку из своей частной ветки, потому что информация бесполезна для получателя. Если, с другой стороны, вы выбираете вишню между двумя общедоступными ветвями (например, переносите исправление в ветку обслуживания для более ранней версии из ветки разработки), добавление этой информации может быть полезно.</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">При записи вашей собственной работы содержимое измененных файлов в вашем рабочем дереве временно сохраняется в промежуточной области, называемой &amp;laquo;индексом&amp;raquo; с помощью &lt;code&gt;git add&lt;/code&gt; . Файл можно вернуть обратно, только в индексе, но не в рабочем дереве, к тому из последнего коммита с помощью &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; , который эффективно отменяет &lt;code&gt;git add&lt;/code&gt; и предотвращает участие изменений этого файла в следующая фиксация. После создания состояния, которое будет постепенно фиксироваться с помощью этих команд, &lt;code&gt;git commit&lt;/code&gt; (без каких-либо параметров пути) используется для записи того, что было поставлено до сих пор. Это самая простая форма команды. Пример:</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">Когда и удаленное,и локальное отделение называются &quot;test&quot;:</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">Когда используется переименование / копирование, &lt;code&gt;file1&lt;/code&gt; и &lt;code&gt;file2&lt;/code&gt; показывают имя исходного файла для переименования / копирования и имя файла, который производит переименование / копирование, соответственно.</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">При переупаковке с дельта-островами дельта-окно имеет тенденцию забиваться кандидатами, запрещенными конфигурацией. Переупаковка с помощью большого окна --window помогает (и не занимает столько времени, сколько могло бы быть в противном случае, потому что мы можем отклонить некоторые пары объектов на основе островов, прежде чем выполнять какие-либо вычисления с содержимым).</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">При восстановлении файлов в рабочем дереве из индекса используйте этап №2 ( &lt;code&gt;ours&lt;/code&gt; ) или этап №3 ( &lt;code&gt;theirs&lt;/code&gt; ) для несвязанных путей.</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">При восстановлении файлов в рабочем дереве из индекса не прерывайте операцию, если есть не объединенные записи и не &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; , &lt;code&gt;--merge&lt;/code&gt; или &lt;code&gt;--conflict&lt;/code&gt; . Незамкнутые пути на рабочем дереве остаются в покое.</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">При восстановлении файлов рабочего дерева из индекса воссоздайте конфликтное слияние в неупорядоченных путях.</target>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">При получении Svn фиксаций Into Git (как часть &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; или &lt;code&gt;dcommit&lt;/code&gt; операций), обратите внимание на первый &lt;code&gt;From:&lt;/code&gt; или &lt;code&gt;Signed-off-by:&lt;/code&gt; линиях в сообщении журнала и использовании, в качестве автора строки.</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">При использовании спецификаторов диапазона ревизий для ограничения аннотации,строки,которые не изменились с границы диапазона (либо фиксация v2.6.18,либо последняя фиксация,которой в приведенном выше примере более 3 недель),обвиняются в этой фиксации границы диапазона.</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">При перезаписи коммитов с помощью &amp;lt;command&amp;gt; (в настоящее время &lt;code&gt;amend&lt;/code&gt; или &lt;code&gt;rebase&lt;/code&gt; ) и для этой переменной установлено значение &lt;code&gt;true&lt;/code&gt; , Git автоматически копирует ваши заметки из оригинала в перезаписанный коммит. По умолчанию &lt;code&gt;true&lt;/code&gt; , но см. &amp;laquo;Notes.rewriteRef&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">При перезаписи коммитов с помощью &amp;lt;command&amp;gt; (в настоящее время &lt;code&gt;amend&lt;/code&gt; или &lt;code&gt;rebase&lt;/code&gt; ), если эта переменная имеет значение &lt;code&gt;false&lt;/code&gt; , git не будет копировать заметки из оригинала в перезаписанный коммит. По умолчанию &lt;code&gt;true&lt;/code&gt; . См. Также &amp;laquo; &lt;code&gt;notes.rewriteRef&lt;/code&gt; &amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">При переписывании коммитов,примечания к которым нужно скопировать с оригинала на переписанный коммит.Должен быть список ссылок или глобусов,разделенных двоеточием.</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">При запуске из подкаталога проекта, с помощью этой опции можно указать исключить изменения вне каталога и показать относительные пути к нему. Когда вы не находитесь в подкаталоге (например, в пустом репозитории), вы можете указать, какой подкаталог будет выводиться относительно, указав &amp;lt;path&amp;gt; в качестве аргумента.</target>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">При запуске из подкаталога команда обычно выводит пути относительно текущего каталога.Эта опция заставляет выводить пути относительно верхней директории проекта.</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">При запуске в каталоге, в котором нет каталога репозитория &quot;.git&quot;, Git пытается найти такой каталог в родительских каталогах, чтобы найти вершину рабочего дерева, но по умолчанию он не пересекает границы файловой системы. Для этой переменной среды можно установить значение true, чтобы Git не останавливался на границах файловой системы. Как и &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; , это не повлияет на явный каталог репозитория, установленный через &lt;code&gt;GIT_DIR&lt;/code&gt; или в командной строке.</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">При запуске команды с параметрами &lt;code&gt;-u&lt;/code&gt; и &lt;code&gt;-m&lt;/code&gt; в результате слияния может потребоваться перезапись путей, которые не отслеживаются в текущей ветви. Команда обычно отказывается продолжить слияние, чтобы не потерять такой путь. Однако этот предохранительный клапан иногда мешает. Например, часто бывает , что другая ветвь добавляется файл , который используется , чтобы быть сгенерированным файлом в вашей отрасли, и спусковой предохранительный клапан при попытке переключиться на эту ветвь после вы запускали &lt;code&gt;make&lt;/code&gt; , но перед запуском &lt;code&gt;make clean&lt;/code&gt; , чтобы удалить генерируемый файл. Эта опция сообщает команде, что нужно читать исключаемый файл для каждого каталога (обычно &lt;code&gt;.gitignore&lt;/code&gt; ), и позволяет перезаписать такой неотслеживаемый, но явно игнорируемый файл.</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">Отправляя патч таким способом, чаще всего вы отправляете свой собственный патч, поэтому в дополнение к маркеру &amp;laquo; &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; &amp;raquo; вы должны опустить строки &lt;code&gt;From:&lt;/code&gt; и &lt;code&gt;Date:&lt;/code&gt; в файле патча. Название патча, вероятно, будет отличаться от темы обсуждения, на которое патч отвечает, поэтому вполне вероятно, что вы захотите сохранить строку Subject:, как в примере выше.</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">Если установлено значение &amp;laquo; &lt;code&gt;always&lt;/code&gt; , всегда выделять совпадения. Когда &lt;code&gt;false&lt;/code&gt; (или &lt;code&gt;never&lt;/code&gt; ), никогда. Если установлено значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;auto&lt;/code&gt; , использовать цвет только тогда, когда вывод записывается на терминал. Если не задано, используется значение &lt;code&gt;color.ui&lt;/code&gt; ( по умолчанию &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">Если установлено значение &lt;code&gt;always&lt;/code&gt; , всегда используйте цвета для интерактивных подсказок и дисплеев (например, те, которые используются командами &amp;laquo;git-add --interactive&amp;raquo; и &amp;laquo;git-clean --interactive&amp;raquo;). Когда ложно (или &lt;code&gt;never&lt;/code&gt; ), никогда. Если установлено значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;auto&lt;/code&gt; , используйте цвета только при выводе на терминал. Если не задано, используется значение &lt;code&gt;color.ui&lt;/code&gt; ( по умолчанию &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">Если установлено значение &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;git apply&lt;/code&gt; игнорирует изменения в &lt;code&gt;--ignore-space-change&lt;/code&gt; же, как параметр --ignore-space-change . Если установлено одно из: no, none, never, false сообщает &lt;code&gt;git apply&lt;/code&gt; , чтобы он уважал все различия в пробелах. См. &lt;a href=&quot;git-apply&quot;&gt;Git-apply [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">Если установлено &lt;code&gt;merges&lt;/code&gt; , перебазируйте с помощью &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; , чтобы локальные коммиты слияния включались в перебазирование (подробности см. В &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">Если установлено значение &lt;code&gt;preserve&lt;/code&gt; (устарело в пользу &lt;code&gt;merges&lt;/code&gt; ), перебазируйте с параметром &lt;code&gt;--preserve-merges&lt;/code&gt; , переданным в &lt;code&gt;git rebase&lt;/code&gt; , чтобы локально созданные коммиты слияния не сглаживались.</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;git reset&lt;/code&gt; по умолчанию будет использовать параметр &lt;code&gt;--quiet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">Если установлено значение true, &lt;code&gt;git-rerere&lt;/code&gt; обновляет индекс полученным содержимым после того, как полностью разрешает конфликты с использованием ранее записанного разрешения. По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">При установке значения true клон этого субмодуля будет выполняться как мелкий клон (с глубиной истории 1),если только пользователь явно не запросит не мелкий клон.</target>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">Если установлено значение true, автоматически создавать временную запись в тайнике перед началом операции и применять ее после завершения операции. Это означает, что вы можете запустить rebase на грязном рабочем дереве. Однако используйте с осторожностью: последнее приложение тайника после успешной перебазирования может привести к нетривиальным конфликтам. Этот параметр может быть отменен параметрами &lt;code&gt;--no-autostash&lt;/code&gt; и &lt;code&gt;--autostash&lt;/code&gt; команды &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; . По умолчанию - false.</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">Если установлено значение true, выборка с этого пульта по умолчанию также удалит все локальные теги, которые больше не существуют на пульте, если сокращение активировано в целом через &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; , &lt;code&gt;fetch.prune&lt;/code&gt; или &lt;code&gt;--prune&lt;/code&gt; . Переопределяет настройки &lt;code&gt;fetch.pruneTags&lt;/code&gt; , если они есть.</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">Если установлено значение true, выборка с этого пульта по умолчанию также удалит все ссылки удаленного отслеживания, которые больше не существуют на пульте (как если бы в &lt;code&gt;--prune&lt;/code&gt; была указана опция --prune ). Переопределяет настройки &lt;code&gt;fetch.prune&lt;/code&gt; , если они есть.</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">Когда установлено значение true,git-receive-pack будет рекламировать своим клиентам возможности push options.Ложно по умолчанию.</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">Когда установлено значение true,этот пульт будет использоваться для получения объектов промоутеров.</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">Если установлено, выборка или получение будет прервана в случае искаженного объекта или ссылки на несуществующий объект. Кроме того, проверяются различные другие проблемы, в том числе устаревшие проблемы (см. &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ) и потенциальные проблемы безопасности, такие как наличие &lt;code&gt;.GIT&lt;/code&gt; или вредоносного файла &lt;code&gt;.gitmodules&lt;/code&gt; (см. Примечания к выпуску для v2. 2.1 и v2.17.1 для подробностей). Другие проверки работоспособности и безопасности могут быть добавлены в будущих выпусках.</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">При отображении &lt;code&gt;short&lt;/code&gt; или &lt;code&gt;porcelain&lt;/code&gt; вывода состояния распечатайте имя файла дословно и завершите записи NUL вместо LF. Если формат не указан, подразумевается выходной формат &lt;code&gt;--porcelain&lt;/code&gt; . Без опции &lt;code&gt;-z&lt;/code&gt; имена файлов с &amp;laquo;необычными&amp;raquo; символами заключаются в кавычки, как описано для переменной конфигурации &lt;code&gt;core.quotePath&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">При отображении изменений, включающих переименование или копирование, вывод &lt;code&gt;--stat&lt;/code&gt; форматирует путевые имена компактно, комбинируя общий префикс и суффикс путевых имен. Например, изменение, которое перемещает &lt;code&gt;arch/i386/Makefile&lt;/code&gt; в &lt;code&gt;arch/x86/Makefile&lt;/code&gt; при изменении 4 строк, будет показано следующим образом:</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">При отображении сообщений о фиксации,также показывайте заметки,которые хранятся в данном справочнике.Примечания должны быть полностью квалифицированными.Если данный реферат не существует,это не ошибка,но означает,что никакие заметки не должны быть напечатаны.</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">При отображении имен объектов добавляйте к ним префикс &lt;code&gt;^&lt;/code&gt; и удаляйте префикс &lt;code&gt;^&lt;/code&gt; из имен объектов, у которых он уже есть.</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">При отображении значения &amp;lt;name&amp;gt; как символической ссылки, попробуйте сократить значение, например, от &lt;code&gt;refs/heads/master&lt;/code&gt; до &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">При отображении с помощью &lt;code&gt;git diff-tree -c&lt;/code&gt; он сравнивает родителей коммита слияния с результатом слияния (то есть file1..fileN являются родителями). При отображении с помощью &lt;code&gt;git diff-files -c&lt;/code&gt; он сравнивает два неразрешенных родителя слияния с файлом рабочего дерева (т.е. file1 - это этап 2, также известный как &amp;laquo;наша версия&amp;raquo;, file2 - это этап 3, также известный как &amp;laquo;их версия&amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">Когда некоторые коммиты были пропущены (используя &quot;git-bisect skip&quot;),то алгоритм биссекции тот же,что и для шага 1)-3).Но затем мы используем примерно следующие шаги:</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">Если указано один или несколько раз, &lt;code&gt;-L&lt;/code&gt; ограничивает аннотацию запрошенными строками.</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">При указании опции -v используется формат:</target>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">При переключении ветвей с помощью &lt;code&gt;--merge&lt;/code&gt; поэтапные изменения могут быть потеряны.</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">При переключении веток,если у вас есть локальные изменения в одном или нескольких файлах,которые отличаются между текущей веткой и веткой,в которую вы переключаетесь,команда отказывается переключать ветки,чтобы сохранить ваши изменения в контексте.Однако,с помощью этой опции выполняется трёхстороннее слияние между текущей веткой,содержимым вашего рабочего дерева и новым ответвлением,и вы будете находиться в новом ответвлении.</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">При переключении ветвей продолжайте, даже если индекс или рабочее дерево отличается от &lt;code&gt;HEAD&lt;/code&gt; . Это используется для отбрасывания локальных изменений.</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">При использовании опции &quot;-С&quot; исходное содержимое измененных файлов,а также удаленных файлов (а также немодифицированных файлов,если используется опция &quot;--find-copies-harder&quot;)считаются кандидатами исходных файлов в операции переименования/копирования.Если входные данные были похожи на эти пары файлов,то речь идет об измененном файле fileY и вновь созданном файле file0:</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">Когда аргумент &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; является именем ветки, параметр &lt;code&gt;--detach&lt;/code&gt; может использоваться для отсоединения &lt;code&gt;HEAD&lt;/code&gt; от конца ветки ( &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; проверяет эту ветку без отсоединения &lt;code&gt;HEAD&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">Если &lt;code&gt;--aggressive&lt;/code&gt; параметр --aggressive , &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; будет вызываться с флагом &lt;code&gt;-f&lt;/code&gt; , который, в свою очередь, передаст &lt;code&gt;--no-reuse-delta&lt;/code&gt; в &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; . Это отбросит все существующие дельты и пересчитает их, за счет гораздо большего количества времени на переупаковку.</target>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">Когда &lt;code&gt;--stdin&lt;/code&gt; опция --stdin , шаблоны считываются из стандарта в виде списка, разделенного новой строкой, а не из аргументов.</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">Когда используется опция &lt;code&gt;-l&lt;/code&gt; , формат меняется на</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">Когда задана опция &lt;code&gt;-z&lt;/code&gt; , пути печатаются как есть и без кавычек, а строки заканчиваются байтом NUL (ASCII 0x00).</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">Когда файл &lt;code&gt;.gitattributes&lt;/code&gt; отсутствует в рабочем дереве, путь в индексе используется как резервный. В процессе оформления &lt;code&gt;.gitattributes&lt;/code&gt; используются атрибуты .gitattributes в индексе, а затем файл в рабочем дереве используется в качестве запасного варианта .</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">Когда переменная среды &lt;code&gt;LESS&lt;/code&gt; не задана, Git устанавливает ее в &lt;code&gt;FRX&lt;/code&gt; (если задана переменная среды &lt;code&gt;LESS&lt;/code&gt; , Git вообще ее не изменяет). Если вы хотите выборочно переопределить настройку Git по умолчанию для &lt;code&gt;LESS&lt;/code&gt; , вы можете установить &lt;code&gt;core.pager&lt;/code&gt; , например, &lt;code&gt;less -S&lt;/code&gt; . Это будет передано в оболочку Git, который переведет последнюю команду в &lt;code&gt;LESS=FRX less -S&lt;/code&gt; . Среда не устанавливает параметр &lt;code&gt;S&lt;/code&gt; , но командная строка устанавливает, давая команду less обрезать длинные строки. Точно так же установка &lt;code&gt;core.pager&lt;/code&gt; на &lt;code&gt;less -+F&lt;/code&gt; отключит &lt;code&gt;F&lt;/code&gt; параметр, заданный средой из командной строки, деактивируя поведение &amp;laquo;выйти, если один экран&amp;raquo; &lt;code&gt;less&lt;/code&gt; . Можно специально активировать некоторые флаги для определенных команд: например, установка &lt;code&gt;pager.blame&lt;/code&gt; на &lt;code&gt;less -S&lt;/code&gt; позволяет обрезать строку только для &lt;code&gt;git blame&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">При &lt;code&gt;core.fsmonitor&lt;/code&gt; переменной конфигурации core.fsmonitor монитор файловой системы добавляется в индекс или удаляется из него при следующем чтении индекса командой. Когда используется &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; , монитор файловой системы немедленно добавляется в индекс или удаляется из него.</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">При &lt;code&gt;core.untrackedCache&lt;/code&gt; переменной конфигурации core.untrackedCache неотслеживаемый кеш добавляется или удаляется из индекса в следующий раз, когда команда читает индекс; в то время как, когда используется &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; , неотслеживаемый кеш немедленно добавляется в индекс или удаляется из него.</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">Если для пути установлен атрибут &lt;code&gt;ident&lt;/code&gt; ity , Git заменяет &lt;code&gt;$Id$&lt;/code&gt; в объекте большого двоичного объекта на &lt;code&gt;$Id:&lt;/code&gt; за которым следует 40-символьное шестнадцатеричное имя объекта большого двоичного объекта, за которым следует знак доллара &lt;code&gt;$&lt;/code&gt; при оформлении заказа. Любая последовательность байтов, которая начинается с &lt;code&gt;$Id:&lt;/code&gt; и заканчивается символом &lt;code&gt;$&lt;/code&gt; в файле рабочего дерева, при регистрации заменяется на &lt;code&gt;$Id$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">Когда команда переходит в интерактивный режим,она показывает файлы и каталоги,которые необходимо очистить,и переходит в свой интерактивный командный цикл.</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">Когда команда переходит в интерактивный режим, она показывает вывод подкоманды &lt;code&gt;status&lt;/code&gt; , а затем переходит в интерактивный командный цикл.</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">Когда команда вызывается из подкаталога,покажите путь текущей директории относительно директории верхнего уровня.</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">При вызове команды из подкаталога,покажите путь к каталогу верхнего уровня относительно текущего каталога (обычно это последовательность &quot;../&quot;,или пустая строка).</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">Когда команда выполняется без pathspec,она ошибается,вместо того,чтобы деинитовать все,чтобы предотвратить ошибки.</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">Когда в командной строке не указывается, что &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; аргументами &amp;lt;refspec&amp;gt; ... или параметрами &lt;code&gt;--all&lt;/code&gt; , &lt;code&gt;--mirror&lt;/code&gt; , &lt;code&gt;--tags&lt;/code&gt; , команда находит &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; по умолчанию , консультируясь с конфигурацией &lt;code&gt;remote.*.push&lt;/code&gt; и если он не найден, &lt;code&gt;push.default&lt;/code&gt; конфигурацию push.default, чтобы решить, что &lt;code&gt;push.default&lt;/code&gt; значение push.default см. в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">Если в командной строке не указано, куда отправлять с аргументом &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; , выполняется консультация с &lt;code&gt;branch.*.remote&lt;/code&gt; конфигурацией branch. *. Для текущей ветки, чтобы определить, куда отправлять. Если конфигурация отсутствует, по умолчанию используется &lt;code&gt;origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">Когда различия при фиксации различаются, &lt;code&gt;git range-diff&lt;/code&gt; воссоздает исходную окраску различий и добавляет внешние маркеры различий - / + с красным / зеленым &lt;strong&gt;фоном&lt;/strong&gt; , чтобы их было легче увидеть, например, когда было изменение в том, какие именно строки были добавлены ,</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">Когда сообщение журнала фиксации начинается с &amp;laquo;squash!&amp;hellip;&amp;raquo; (Или &amp;laquo;fixup!&amp;hellip;&amp;raquo;), И в списке задач уже есть фиксация, которая соответствует тому же &lt;code&gt;...&lt;/code&gt; , автоматически измените список задач rebase -i так что коммит помечено для раздавливания приходит сразу после фиксации необходимо изменить, и изменить действие перемещенного совершить из &lt;code&gt;pick&lt;/code&gt; в &lt;code&gt;squash&lt;/code&gt; (или &lt;code&gt;fixup&lt;/code&gt; ). Фиксация соответствует &lt;code&gt;...&lt;/code&gt; , если совпадает тема фиксации или если &lt;code&gt;...&lt;/code&gt; относится к хешу фиксации. В качестве запасного варианта также работают частичные совпадения с предметом коммита. Рекомендуемый способ создания Fixup / сквош совершающего это с помощью &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; варианты &lt;a href=&quot;git-commit&quot;&gt;мерзавца фиксации [1]&lt;/a&gt;,</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">Когда установлен ключ конфигурации &lt;code&gt;extensions.partialclone&lt;/code&gt; , он указывает, что репо было создано с частичным клоном (или позже выполнено частичное получение) и что удаленный компьютер мог пропустить отправку определенных нежелательных объектов. Такой пульт называется &amp;laquo;пульт-обещатель&amp;raquo;, и он обещает, что все такие пропущенные объекты могут быть извлечены из него в будущем.</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">Когда для ключа конфигурации &lt;code&gt;extensions.preciousObjects&lt;/code&gt; установлено значение &lt;code&gt;true&lt;/code&gt; , объекты в репозитории НЕ ДОЛЖНЫ быть удалены (например, с помощью &lt;code&gt;git-prune&lt;/code&gt; или &lt;code&gt;git repack -d&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">Когда текущий рабочий каталог находится ниже директории хранилища,выведите &quot;true&quot;,в противном случае &quot;false&quot;.</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">При нахождении текущей рабочей директории внутри рабочего дерева хранилища выведите &quot;true&quot;,иначе &quot;false&quot;.</target>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">Когда переменная среды &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; установлена, вызывается названная ею программа вместо вызова diff, описанного выше. Для добавленного, удаленного или измененного пути &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; вызывается с 7 параметрами:</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">Когда запускается команда git-rebase, она сначала выполняет перехватчик pre-rebase, если он существует. Вы можете использовать этот хук для проверки работоспособности и отклонения перебазирования, если это не подходит. См. Пример в сценарии ловушки предварительной перебазировки шаблона.</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">Когда история включает в себя перекрестные слияния, для двух коммитов может быть более одного &lt;code&gt;best&lt;/code&gt; общего предка. Например, с такой топологией:</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">Когда программа просмотра man, указанная в переменных конфигурации &lt;code&gt;man.viewer&lt;/code&gt; , не входит в число поддерживаемых, будет найдена соответствующая переменная конфигурации &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; . Если эта переменная существует, то указанный инструмент будет рассматриваться как пользовательская команда, и для выполнения команды будет использоваться eval оболочки с переданной в качестве аргументов страницей руководства.</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">Когда вывод поступает на терминал, он по умолчанию имеет цветовую кодировку, как и обычный вывод &lt;code&gt;git diff&lt;/code&gt; . Кроме того, первая строка (добавление фиксации) зеленая, последняя строка (удаление фиксации) красная, вторая строка (с идеальным совпадением) желтая, как заголовок фиксации вывода &lt;code&gt;git show&lt;/code&gt; , а третья Строка окрашивает старую фиксацию в красный цвет, новую - в зеленый, а остальное - как заголовок фиксации &lt;code&gt;git show&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">Если патч не применяется правильно, вернитесь к трехстороннему слиянию, если патч записывает идентичность больших двоичных объектов, к которым он должен применяться, и эти капли доступны локально. &lt;code&gt;--no-3way&lt;/code&gt; можно использовать для переопределения переменной конфигурации am.threeWay. Для получения дополнительной информации см. Am.threeWay в &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">Когда патч не применяется чисто, вернитесь к трехстороннему слиянию, если патч записывает идентичность больших двоичных объектов, к которым он должен применяться, и у нас есть эти капли, доступные локально, возможно, оставляя маркеры конфликтов в файлах в рабочем дереве. для разрешения пользователя. Этот параметр подразумевает параметр &lt;code&gt;--index&lt;/code&gt; и несовместим с параметрами &lt;code&gt;--reject&lt;/code&gt; и &lt;code&gt;--cached&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">Когда отправка завершена, выводится один или несколько &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; или &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; строки, чтобы указать успех или неудачу каждой отправленной ссылки. Вывод отчета о состоянии заканчивается пустой строкой. Поле параметра &amp;lt;why&amp;gt; может быть заключено в кавычки в строке стиля C, если оно содержит LF.</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">Когда известно, что удаленная ветвь, которую вы хотите получить, регулярно перематывается и переустанавливается, ожидается, что ее новый наконечник не будет потомком его предыдущего наконечника (как хранится в вашей ветке удаленного отслеживания при последней выборке). Вы можете использовать знак &lt;code&gt;+&lt;/code&gt; , чтобы указать, что для таких веток потребуются обновления без перемотки вперед. Невозможно определить или объявить, что ветка будет доступна в репозитории с таким поведением; извлекающий пользователь просто должен знать, что это ожидаемый шаблон использования ветки.</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">Когда в репозитории есть голая печать &quot;true&quot;,в противном случае &quot;false&quot;.</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">Если в репозитории выведено мелкое &quot;true&quot;,в противном случае &quot;false&quot;.</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">Когда хранилище назван &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; имеет фиксацию на кончике реф , который отличается от исх у вас есть локально, вы можете использовать &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; синтаксис, чтобы иметь свое локальное имя, двоеточие &lt;code&gt;:&lt;/code&gt; , и его удаленное имя.</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">Когда репозиторий, из которого нужно клонировать, находится на локальном компьютере, этот флаг обходит обычный транспортный механизм &amp;laquo;с учетом Git&amp;raquo; и клонирует репозиторий, создавая копию HEAD и всего, что находится в каталогах объектов и ссылок. Файлы в каталоге &lt;code&gt;.git/objects/&lt;/code&gt; жестко связаны для экономии места, когда это возможно.</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">Когда репозиторий для клонирования находится на локальном компьютере, вместо использования жестких ссылок автоматически настраивайте &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; для совместного использования объектов с исходным репозиторием. Результирующий репозиторий запускается без какого-либо собственного объекта.</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">Когда результатом &lt;code&gt;git bisect&lt;/code&gt; является фиксация без слияния, вы обычно можете обнаружить проблему, изучив только эту фиксацию. Разработчики могут упростить это, разбив свои изменения на небольшие автономные коммиты. Однако это не поможет в приведенном выше случае, потому что проблема не очевидна при изучении любого отдельного коммита; вместо этого требуется глобальный взгляд на развитие. Что еще хуже, изменение семантики проблемной функции может быть лишь небольшой частью изменений в верхней строке разработки.</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">При использовании функции разделения индекса файлы общих индексов, которые не были изменены с момента, указанного в этой переменной, будут удалены при создании нового файла общего индекса. Значение &amp;laquo;сейчас&amp;raquo; немедленно удаляет все записи, а &amp;laquo;никогда&amp;raquo; полностью подавляет истечение срока. Значение по умолчанию - &amp;laquo;2.weeks.ago&amp;raquo;. Обратите внимание, что файл общего индекса считается измененным (с целью истечения срока его действия) каждый раз, когда на его основе создается новый файл с разделенным индексом или считывается из него. См. &lt;a href=&quot;git-update-index&quot;&gt;Git-update-index [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">Когда используется функция разделенного индекса, это указывает процент записей, которые может содержать разделенный индекс, по сравнению с общим количеством записей как в разделенном индексе, так и в общем индексе до записи нового общего индекса. Значение должно быть от 0 до 100. Если значение равно 0, то всегда записывается новый общий индекс, если он равен 100, новый общий индекс никогда не записывается. По умолчанию значение равно 20, поэтому новый общий индекс будет записан, если количество записей в разделенном индексе будет больше 20 процентов от общего количества записей. См. &lt;a href=&quot;git-update-index&quot;&gt;Git-update-index [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">Когда значение является &lt;code&gt;interactive&lt;/code&gt; , перебазирование выполняется в интерактивном режиме.</target>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">Когда в репозитории примерно больше свободных объектов, &lt;code&gt;git gc --auto&lt;/code&gt; упакует их. Некоторые команды Porcelain используют эту команду для выполнения время от времени упрощенной сборки мусора. Значение по умолчанию - 6700.</target>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">Если в репозитории имеется большее количество пакетов, не отмеченных &lt;code&gt;*.keep&lt;/code&gt; файлом, &lt;code&gt;git gc --auto&lt;/code&gt; объединяет их в один более крупный пакет. Значение по умолчанию - 50. Установка этого значения в 0 отключает его. Установка &lt;code&gt;gc.auto&lt;/code&gt; на 0 также отключит это.</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">Когда указан только один аргумент, а его нет &lt;code&gt;--&lt;/code&gt; (например, &lt;code&gt;git checkout abc&lt;/code&gt; ), и когда аргумент является как допустимым &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (например, существует ветвь &lt;code&gt;abc&lt;/code&gt; ), так и допустимым &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (например, файл или существует каталог с именем &amp;laquo;abc&amp;raquo;), Git обычно просит вас устранить неоднозначность. Однако, поскольку извлечение ветки является очень распространенной операцией, в такой ситуации &lt;code&gt;git checkout abc&lt;/code&gt; принимает &amp;laquo;abc&amp;raquo; в качестве &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; . Используйте &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; если вы хотите извлечь эти пути из индекса.</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">При установке этих переменных окружения соответствующие аргументы командной строки могут не использоваться.</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">Когда указан этот флаг, пакет читается из стандартного ввода, а затем его копия записывается в &amp;lt;pack-file&amp;gt;. Если &amp;lt;pack-file&amp;gt; не указан, пакет записывается в каталог objects / pack / текущего репозитория Git с именем по умолчанию, определяемым из содержимого пакета. Если &amp;lt;pack-file&amp;gt; не указан, рассмотрите возможность использования --keep, чтобы предотвратить состояние гонки между этим процессом и &lt;code&gt;git repack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">При установке этого флага имена объектов,записанные для путей,не обновляются.Вместо этого,данная опция устанавливает/удаляет бит &quot;assume unchanged&quot; для путей.При включённом бите &quot;assume unchanged&quot; (не изменять)пользователь обещает не изменять файл и позволяет Git'у полагать,что файл рабочего дерева соответствует тому,что записано в индексе.Если вы хотите изменить файл рабочего дерева,вам нужно снять бит,чтобы сообщить Git'у.Это иногда полезно при работе с большим проектом на файловой системе с очень медленным системным вызовом lstat(2)(например,cifs).</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">Когда эта форма &lt;code&gt;git read-tree&lt;/code&gt; возвращается успешно, вы можете увидеть , какие из &amp;laquo;локальных изменений&amp;raquo; , которые были внесены были перенесены, запустив &lt;code&gt;git diff-index --cached $M&lt;/code&gt; . Обратите внимание, что это не обязательно соответствует тому, что &lt;code&gt;git diff-index --cached $H&lt;/code&gt; произвел бы до такого слияния двух деревьев. Это из-за случаев 18 и 19 - если у вас уже были изменения в $ M (например, возможно, вы получили его по электронной почте в форме патча), &lt;code&gt;git diff-index --cached $H&lt;/code&gt; сказал бы вам об изменении до этого слияния, но оно не будет отображаться в &lt;code&gt;git diff-index --cached $M&lt;/code&gt; после слияния двух деревьев.</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">Когда указана эта опция, поведение выглядит так, как если бы в начале командной строки был добавлен специальный аргумент &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; , где &amp;lt;value&amp;gt; принимается как стандартный вывод указанной команды с любыми ведущими и завершающие пробелы обрезаны.</target>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">Когда этот специальный атрибут считывается &lt;code&gt;git credential&lt;/code&gt; , значение анализируется как URL-адрес и обрабатывается так, как если бы были прочитаны его составные части (например, &lt;code&gt;url=https://example.com&lt;/code&gt; будет вести себя так, как если бы &lt;code&gt;protocol=https&lt;/code&gt; и &lt;code&gt;host=example.com&lt;/code&gt; был предоставлен). Это может помочь вызывающим абонентам избежать самостоятельного анализа URL-адресов. Обратите внимание, что любые компоненты, отсутствующие в URL-адресе (например, в приведенном выше примере нет имени пользователя), будут установлены как пустые; если вы хотите предоставить URL-адрес и переопределить некоторые атрибуты, сначала укажите атрибут URL-адреса, а затем любые переопределения.</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">Когда файлы трассировок записываются в целевую директорию,они будут именоваться в соответствии с последним компонентом SID (опционально за ними следует счетчик,чтобы избежать столкновений имен файлов).</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">При отслеживании нескольких каталогов (с использованием параметров --stdlayout, --branches или --tags) git svn попытается подключиться к корню (или самому высокому разрешенному уровню) репозитория Subversion. Это значение по умолчанию позволяет лучше отслеживать историю, если целые проекты перемещаются в репозиторий, но может вызвать проблемы в репозиториях, где есть ограничения доступа для чтения. Передача &lt;code&gt;--no-minimize-url&lt;/code&gt; позволит git svn принимать URL-адреса как есть, не пытаясь подключиться к каталогу более высокого уровня. Этот параметр отключен по умолчанию, если отслеживается только один URL / ветка (от этого мало пользы).</target>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">Если true, git по умолчанию будет использовать параметр &lt;code&gt;--sparse&lt;/code&gt; в &lt;code&gt;git pack-objects&lt;/code&gt; , если &lt;code&gt;--revs&lt;/code&gt; параметр --revs . Этот алгоритм обходит только деревья, которые появляются на путях, которые вводят новые объекты. Это может иметь значительные преимущества в производительности при вычислении пакета для отправки небольшого изменения. Однако возможно, что в pack-файл будут добавлены дополнительные объекты, если включенные коммиты содержат определенные типы прямого переименования. По умолчанию &lt;code&gt;false&lt;/code&gt; , если не включен &lt;code&gt;feature.experimental&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">Если true, git будет включать раздел &amp;laquo;хеш-кеш&amp;raquo; в индекс растрового изображения (если он записан). Этот кеш можно использовать для передачи дельта-эвристики git, что потенциально может привести к улучшению разницы между объектами с растровым отображением и без него (например, при обслуживании выборки между более старым пакетом с растровым отображением и объектами, которые были отправлены с момента последнего gc). Обратной стороной является то, что он потребляет 4 байта на объект дискового пространства. По умолчанию true.</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">Если это так,то при упаковке в stdout git будет использовать растровые пакеты (если они есть)(например,во время серверной стороны получения).По умолчанию равно true.Обычно вам не нужно выключать это значение,если только вы не отлаживаете битовые карты пакета.</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">Если установлено значение true, git будет записывать индекс растрового изображения при упаковке всех объектов на диск (например, при запуске &lt;code&gt;git repack -a&lt;/code&gt; ). Этот индекс может ускорить фазу &amp;laquo;подсчета объектов&amp;raquo; последующих пакетов, созданных для клонов и выборок, за счет некоторого дискового пространства и дополнительного времени, затрачиваемого на начальную репакцию. Это не действует, если создано несколько файлов пакетов. По умолчанию true для голых репозиториев, в противном случае - false.</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">Если установлено значение true, перебазировать ветки поверх полученной ветки вместо объединения ветки по умолчанию с удаленного по умолчанию при запуске &amp;laquo;git pull&amp;raquo;. См. &quot;Branch. &amp;lt;name&amp;gt; .rebase&quot; для настройки этого для каждой ветки.</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">Если установлено значение true, переставьте ветвь &amp;lt;name&amp;gt; поверх выбранной ветки вместо слияния ветки по умолчанию с удаленного по умолчанию при запуске &amp;laquo;git pull&amp;raquo;. См. &quot;Pull.rebase&quot; для того, чтобы сделать это не привязанным к ветке способом.</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">Когда это верно,перезагрузите текущее ответвление на верхней части верхнего течения после извлечения.Если есть удалённое отслеживаемое ответвление,соответствующее верхнему ответвлению,и ответвление верхнего уровня было перебазировано с момента последней загрузки,то этот перебазинг использует эту информацию,чтобы избежать перебазирования нелокальных изменений.</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">Когда даются два дерева,он сравнивает первое дерево со вторым.Когда задан один коммит,он сравнивает коммит со своими родителями.Остальные коммиты,когда они заданы,используются,как если бы они были родителями первого коммита.</target>
        </trans-unit>
        <trans-unit id="6b17aa5b71b9d47ea9adc71f193314f65da5b538" translate="yes" xml:space="preserve">
          <source>When two trees are specified, the user is telling &lt;code&gt;git read-tree&lt;/code&gt; the following:</source>
          <target state="translated">Когда указаны два дерева, пользователь сообщает &lt;code&gt;git read-tree&lt;/code&gt; следующее:</target>
        </trans-unit>
        <trans-unit id="0b1c4e2bbef526c82867f5bdebb7889317040a32" translate="yes" xml:space="preserve">
          <source>When unpacking a corrupt packfile, the command dies at the first corruption. This flag tells it to keep going and make the best effort to recover as many objects as possible.</source>
          <target state="translated">При распаковке поврежденного файла пакета команда умирает при первом повреждении.Этот флаг говорит ей,что нужно продолжать и приложить максимум усилий,чтобы восстановить как можно больше объектов.</target>
        </trans-unit>
        <trans-unit id="5a3166bdcd39ee71b5c10c4011020b35e1491541" translate="yes" xml:space="preserve">
          <source>When unspecified, all references, after filtering done with --heads and --tags, are shown. When &amp;lt;refs&amp;gt;&amp;hellip;​ are specified, only references matching the given patterns are displayed.</source>
          <target state="translated">Если не указано иное, отображаются все ссылки после фильтрации, выполненной с помощью --heads и --tags. Когда указаны &amp;lt;refs&amp;gt;&amp;hellip;, отображаются только ссылки, соответствующие заданным шаблонам.</target>
        </trans-unit>
        <trans-unit id="fa62c673234c7d272766be9489825a6b1fba8b8c" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files.</source>
          <target state="translated">При использовании в сочетании с неотслеживаемым кэшем,он может еще больше повысить производительность,избегая затрат на сканирование всей рабочей директории в поисках новых файлов.</target>
        </trans-unit>
        <trans-unit id="4699c35836688678c5cc37f1963f740eb7581527" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;-B&lt;/code&gt;, omit also the preimage in the deletion part of a delete/create pair.</source>
          <target state="translated">При использовании вместе с &lt;code&gt;-B&lt;/code&gt; опускайте также прообраз в части удаления пары удаление / создание.</target>
        </trans-unit>
        <trans-unit id="81ec7d099c83d3c361cd6013c655cfcd1bc1c8c9" translate="yes" xml:space="preserve">
          <source>When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.</source>
          <target state="translated">При использовании с опциями -C/-c/--amend,или при фиксации после конфликтующей вишни,объявите,что авторство результирующего коммита теперь принадлежит коммиттеру.Это также продлевает временную метку автора.</target>
        </trans-unit>
        <trans-unit id="b6df5147373d036993fb497c4d7575874db40c5c" translate="yes" xml:space="preserve">
          <source>When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number &lt;code&gt;n&lt;/code&gt; controls this aspect of the -B option (defaults to 50%). &lt;code&gt;-B20%&lt;/code&gt; specifies that a change with addition and deletion compared to 20% or more of the file&amp;rsquo;s size are eligible for being picked up as a possible source of a rename to another file.</source>
          <target state="translated">При использовании с -M полностью перезаписанный файл также рассматривается как источник переименования (обычно -M рассматривает только исчезнувший файл как источник переименования), а число &lt;code&gt;n&lt;/code&gt; управляет этим аспектом параметра -B (по умолчанию 50%). &lt;code&gt;-B20%&lt;/code&gt; указывает, что изменение с добавлением и удалением по сравнению с 20% или более от размера файла может быть выбрано как возможный источник переименования в другой файл.</target>
        </trans-unit>
        <trans-unit id="372d4fbee27ed51979ac65f708d9745903af8bc0" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;--all&lt;/code&gt; print description for all recognized commands. This is the default.</source>
          <target state="translated">При использовании с &lt;code&gt;--all&lt;/code&gt; вывести описание всех распознанных команд. Это значение по умолчанию.</target>
        </trans-unit>
        <trans-unit id="9b2454d94f74e12e4789baf13180d6dd9add197c" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;-ad&lt;/code&gt;, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed).</source>
          <target state="translated">При использовании с &lt;code&gt;-ad&lt;/code&gt; любые недоступные объекты из существующих пакетов будут добавлены в конец файла пакета, а не удалены. Кроме того, все недоступные незакрепленные предметы будут упакованы (а их незакрепленные копии удалены).</target>
        </trans-unit>
        <trans-unit id="f93c22c6857bec96ca286a73d77a732b313ba7be" translate="yes" xml:space="preserve">
          <source>When using --error-unmatch to expand the user supplied &amp;lt;file&amp;gt; (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named &amp;lt;tree-ish&amp;gt; are still present. Using this option with &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt; options does not make any sense.</source>
          <target state="translated">При использовании --error-unmatch для расширения предоставленных пользователем аргументов &amp;lt;file&amp;gt; (то есть шаблона пути) до путей, представьте, что пути, которые были удалены в индексе, поскольку именованные &amp;lt;tree-ish&amp;gt; все еще присутствуют. Использование этой опции с опциями &lt;code&gt;-s&lt;/code&gt; или &lt;code&gt;-u&lt;/code&gt; не имеет смысла.</target>
        </trans-unit>
        <trans-unit id="c409615f2beb16e70015d6d6f46a1b549d1fd7f1" translate="yes" xml:space="preserve">
          <source>When using --hash (and not --dereference) the output format is: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</source>
          <target state="translated">При использовании --hash (а не --dereference) выходной формат: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="081b8dc63c3bf5b426e1b11153b55d3d12af50bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--get&lt;/code&gt;, and the requested variable is not found, behave as if &amp;lt;value&amp;gt; were the value assigned to the that variable.</source>
          <target state="translated">При использовании &lt;code&gt;--get&lt;/code&gt; , а запрошенная переменная не найдена, ведите себя так, как если бы &amp;lt;value&amp;gt; было значением, присвоенным этой переменной.</target>
        </trans-unit>
        <trans-unit id="a0e35ae72d386768f718c98e1facc75ecb16026b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;git diff&lt;/code&gt; to compare with work tree files, do not consider stat-only change as changed. Instead, silently run &lt;code&gt;git update-index --refresh&lt;/code&gt; to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain, and not lower level &lt;code&gt;diff&lt;/code&gt; commands such as &lt;code&gt;git diff-files&lt;/code&gt;.</source>
          <target state="translated">При использовании &lt;code&gt;git diff&lt;/code&gt; для сравнения с файлами рабочего дерева не считайте изменение только статистики измененным. Вместо этого, незаметно запустите &lt;code&gt;git update-index --refresh&lt;/code&gt; , чтобы обновить кэшированную статистическую информацию для путей, содержимое которых в дереве работ соответствует содержимому в индексе. По умолчанию для этого параметра установлено значение true. Обратите внимание, что это влияет только на &lt;code&gt;git diff&lt;/code&gt; Porcelain, но не на команды &lt;code&gt;diff&lt;/code&gt; нижнего уровня, такие как &lt;code&gt;git diff-files&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b88f8d37a4b8b52b11aa1a9190d81927513fc837" translate="yes" xml:space="preserve">
          <source>When using either the ssh:// or file:// transport, the GIT_PROTOCOL environment variable must be set explicitly to include &quot;version=2&quot;.</source>
          <target state="translated">При использовании транспорта ssh://или file://переменная окружения GIT_PROTOCOL должна быть явно установлена на &quot;version=2&quot;.</target>
        </trans-unit>
        <trans-unit id="0ba437f399f8167203a8f1358d574f4341e76291" translate="yes" xml:space="preserve">
          <source>When using multiple --branches or --tags, &lt;code&gt;git svn&lt;/code&gt; does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name). In these cases, use &lt;code&gt;init&lt;/code&gt; to set up your Git repository then, before your first &lt;code&gt;fetch&lt;/code&gt;, edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces. For example:</source>
          <target state="translated">При использовании нескольких --branches или --tags, &lt;code&gt;git svn&lt;/code&gt; не обрабатывает автоматически конфликты имен (например, если две ветки с разных путей имеют одно и то же имя или если ветка и тег имеют одинаковое имя). В этих случаях использование &lt;code&gt;init&lt;/code&gt; , чтобы настроить репозиторий затем, перед вашим первым &lt;code&gt;fetch&lt;/code&gt; , отредактировать файл / файл $ GIT_DIR конфигурации так , что ветви и теги, связанные с различными пространствами имен. Например:</target>
        </trans-unit>
        <trans-unit id="bb2aee242441b06254e02f3a0a2e1341fe75fee4" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--verify&lt;/code&gt; flag, the command requires an exact path:</source>
          <target state="translated">При использовании флага &lt;code&gt;--verify&lt;/code&gt; команда требует точного пути:</target>
        </trans-unit>
        <trans-unit id="33199341df233e06da35e7d1be5de579f81a31d0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;refspec&lt;/code&gt; capability, git normally updates the private ref on successful push. This update is disabled when the remote-helper declares the capability &lt;code&gt;no-private-update&lt;/code&gt;.</source>
          <target state="translated">При использовании возможности &lt;code&gt;refspec&lt;/code&gt; git обычно обновляет частную ссылку при успешном нажатии. Это обновление отключается, когда удаленный помощник объявляет возможность &lt;code&gt;no-private-update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9344e268a1ce18a0fd23fc1ab7349b109ba09f95" translate="yes" xml:space="preserve">
          <source>When using the deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like</source>
          <target state="translated">При использовании устаревшего синтаксиса &lt;code&gt;[section.subsection]&lt;/code&gt; изменение значения приведет к добавлению многострочного ключа вместо изменения, если в подразделе содержится хотя бы один символ верхнего регистра. Например, когда конфигурация выглядит как</target>
        </trans-unit>
        <trans-unit id="d587eeb587978498a5260d6dbb9ec4ed92ae5139" translate="yes" xml:space="preserve">
          <source>When using the git:// transport, you can request to use protocol v2 by sending &quot;version=2&quot; as an extra parameter:</source>
          <target state="translated">При использовании транспорта git://вы можете запросить использование протокола v2,отправив &quot;version=2&quot; в качестве дополнительного параметра:</target>
        </trans-unit>
        <trans-unit id="32ff889e17de28054dd0cab540306ba1d148a08f" translate="yes" xml:space="preserve">
          <source>When using the http:// or https:// transport a client makes a &quot;smart&quot; info/refs request as described in &lt;code&gt;http-protocol.txt&lt;/code&gt; and requests that v2 be used by supplying &quot;version=2&quot; in the &lt;code&gt;Git-Protocol&lt;/code&gt; header.</source>
          <target state="translated">При использовании транспорта http: // или https: // клиент делает &amp;laquo;умный&amp;raquo; запрос info / refs, как описано в &lt;code&gt;http-protocol.txt&lt;/code&gt; , и запрашивает, чтобы v2 использовалась, указав &amp;laquo;version = 2&amp;raquo; в &lt;code&gt;Git-Protocol&lt;/code&gt; . заголовок.</target>
        </trans-unit>
        <trans-unit id="1119c741c1d5ff1dc358a8c521dcf54497e7a91a" translate="yes" xml:space="preserve">
          <source>When we discuss merges we&amp;rsquo;ll also see the special name MERGE_HEAD, which refers to the other branch that we&amp;rsquo;re merging in to the current branch.</source>
          <target state="translated">Когда мы обсуждаем слияние, мы также увидим специальное имя MERGE_HEAD, которое относится к другой ветке, которую мы объединяем с текущей веткой.</target>
        </trans-unit>
        <trans-unit id="26b492dec7c9b7098cc4171f2408a6f7f7e92986" translate="yes" xml:space="preserve">
          <source>When we need to be precise, we will use the word &quot;branch&quot; to mean a line of development, and &quot;branch head&quot; (or just &quot;head&quot;) to mean a reference to the most recent commit on a branch. In the example above, the branch head named &quot;A&quot; is a pointer to one particular commit, but we refer to the line of three commits leading up to that point as all being part of &quot;branch A&quot;.</source>
          <target state="translated">Когда нам нужно быть точными,мы будем использовать слово &quot;branch&quot; для обозначения строки разработки,а &quot;branch head&quot; (или просто &quot;head&quot;)для обозначения ссылки на последний коммит в ветке.В приведённом выше примере глава ветки с именем &quot;A&quot; является указателем на один конкретный коммит,но мы ссылаемся на строку из трёх коммитов,ведущих к этой точке,так как все они являются частью &quot;ветки A&quot;.</target>
        </trans-unit>
        <trans-unit id="af865a0e18421a331501b917b6b084d9f08c05af" translate="yes" xml:space="preserve">
          <source>When we want to find out what commits in &lt;code&gt;M&lt;/code&gt; are contaminated with the bug introduced by &lt;code&gt;D&lt;/code&gt; and need fixing, however, we might want to view only the subset of &lt;code&gt;D..M&lt;/code&gt; that are actually descendants of &lt;code&gt;D&lt;/code&gt;, i.e. excluding &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt;. This is exactly what the &lt;code&gt;--ancestry-path&lt;/code&gt; option does. Applied to the &lt;code&gt;D..M&lt;/code&gt; range, it results in:</source>
          <target state="translated">Когда мы хотим узнать, что совершает в &lt;code&gt;M&lt;/code&gt; загрязнены с ошибкой , введенной &lt;code&gt;D&lt;/code&gt; и фиксации необходимости, однако, мы могли бы просмотреть только подмножество &lt;code&gt;D..M&lt;/code&gt; , которые являются фактически потомками &lt;code&gt;D&lt;/code&gt; , т.е. за исключением &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;K&lt;/code&gt; . Это именно то, что &lt;code&gt;--ancestry-path&lt;/code&gt; параметр --ancestry-path . Применительно к диапазону &lt;code&gt;D..M&lt;/code&gt; это приводит к:</target>
        </trans-unit>
        <trans-unit id="bd2b751f52f03b9f39eaea429dccc385cd6f8cb7" translate="yes" xml:space="preserve">
          <source>When writing a script that is expected to handle random user-input, it is a good practice to make it explicit which arguments are which by placing disambiguating &lt;code&gt;--&lt;/code&gt; at appropriate places.</source>
          <target state="translated">При написании сценария, который, как ожидается, будет обрабатывать случайный ввод пользователя, рекомендуется указать, какие аргументы являются какими, путем устранения неоднозначности &lt;code&gt;--&lt;/code&gt; в соответствующих местах.</target>
        </trans-unit>
        <trans-unit id="ec9cac719dc2571ad31301b21a571a63039a88c5" translate="yes" xml:space="preserve">
          <source>When writing remote-helpers for decentralized version control systems, it is advised to keep a local copy of the repository to interact with, and to let the private namespace refs point to this local repository, while the refs/remotes namespace is used to track the remote repository.</source>
          <target state="translated">При написании удаленных помощников для децентрализованных систем управления версиями рекомендуется сохранять локальную копию репозитория для взаимодействия,а также позволять ссылкам на личное пространство имён указывать на этот локальный репозиторий,в то время как для отслеживания удалённого репозитория используется пространство имён refs/remotes.</target>
        </trans-unit>
        <trans-unit id="20c75e316d5f2bc9ee11a82eb08a64c8e94c8af1" translate="yes" xml:space="preserve">
          <source>When writing, the new value is written to the repository local configuration file by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt;, &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to write to that location (you can say &lt;code&gt;--local&lt;/code&gt; but that is the default).</source>
          <target state="translated">При записи новое значение по умолчанию записывается в локальный файл конфигурации репозитория, а параметры &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; , &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; могут использоваться для указания команде записи в это место ( вы можете &lt;code&gt;--local&lt;/code&gt; но это значение по умолчанию).</target>
        </trans-unit>
        <trans-unit id="cd8a515ddc50bbc57c4721fd114c9828b7d7e56b" translate="yes" xml:space="preserve">
          <source>When you are happy with the state of this change, you can merge it into the &quot;test&quot; branch in preparation to make it public:</source>
          <target state="translated">Когда вы будете довольны состоянием этого изменения,вы можете объединить его в &quot;тестовую&quot; ветвь в рамках подготовки к публикации:</target>
        </trans-unit>
        <trans-unit id="778f60f4a64466f8d291144e663a70b4838a03f8" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple &lt;code&gt;git pull&lt;/code&gt; will let you move forward.</source>
          <target state="translated">Когда вы что-то делаете, вы узнаете, что есть изменения, которые могут иметь отношение к тому, что вы делаете. Когда ваши локальные изменения не конфликтуют с изменениями в восходящем потоке, простой &lt;code&gt;git pull&lt;/code&gt; позволит вам двигаться вперед.</target>
        </trans-unit>
        <trans-unit id="f6b623b307a4c06027202dc5b8021ae4a369fe95" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:</source>
          <target state="translated">Когда вы что-то делаете,приходит ваш босс и требует,чтобы вы что-то исправили немедленно.Традиционно,вы делаете фиксацию во временном ответвлении,чтобы сохранить ваши изменения,и возвращаетесь в своё первоначальное ответвление,чтобы сделать экстренное исправление,подобное этому:</target>
        </trans-unit>
        <trans-unit id="5dab203d26aab56f5ab1012e5091a813403ff2db" translate="yes" xml:space="preserve">
          <source>When you are interested in finding the origin for lines 40-60 for file &lt;code&gt;foo&lt;/code&gt;, you can use the &lt;code&gt;-L&lt;/code&gt; option like so (they mean the same thing &amp;mdash; both ask for 21 lines starting at line 40):</source>
          <target state="translated">Если вы хотите найти начало координат строк 40-60 для файла &lt;code&gt;foo&lt;/code&gt; , вы можете использовать опцию &lt;code&gt;-L&lt;/code&gt; следующим образом (они означают одно и то же - обе запрашивают 21 строку, начинающуюся со строки 40):</target>
        </trans-unit>
        <trans-unit id="709f7df580972f427522b82ef732f913e20c2078" translate="yes" xml:space="preserve">
          <source>When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to &lt;code&gt;git rev-list&lt;/code&gt;:</source>
          <target state="translated">Если вас не интересуют изменения старше версии v2.6.18 или изменения старше 3 недель, вы можете использовать спецификаторы диапазона ревизий, аналогичные &lt;code&gt;git rev-list&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da9f31c43174e26846193d472d4442e982c36d7b" translate="yes" xml:space="preserve">
          <source>When you are working in a small closely knit group, it is not unusual to interact with the same repository over and over again. By defining &lt;code&gt;remote&lt;/code&gt; repository shorthand, you can make it easier:</source>
          <target state="translated">Когда вы работаете в небольшой сплоченной группе, нет ничего необычного в том, чтобы взаимодействовать с одним и тем же хранилищем снова и снова. Определив сокращенное обозначение &lt;code&gt;remote&lt;/code&gt; репозитория, вы можете упростить задачу:</target>
        </trans-unit>
        <trans-unit id="9ac50cc4cb199a994adc57ff3704f94a4fe6fd25" translate="yes" xml:space="preserve">
          <source>When you ask &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; to show the conflicts, it runs a three-way diff between the conflicted merge results in the work tree with stages 2 and 3 to show only hunks whose contents come from both sides, mixed (in other words, when a hunk&amp;rsquo;s merge results come only from stage 2, that part is not conflicting and is not shown. Same for stage 3).</source>
          <target state="translated">Когда вы просите &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; показать конфликты, он запускает трехстороннее различие между конфликтующими результатами слияния в дереве работы с этапами 2 и 3, чтобы показать только блоки, содержимое которых поступает с обеих сторон, смешанное (в других Другими словами, когда результаты слияния блока поступают только на этапе 2, эта часть не конфликтует и не отображается. То же самое для этапа 3).</target>
        </trans-unit>
        <trans-unit id="3f0add0b9e7571c844c4ae8fb98b59f1c64d874a" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; and only have one remote, it may implicitly fall back on checking out and tracking e.g. &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt;. This stops working as soon as you have more than one remote with a &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">Когда вы запускаете &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; или &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; и имеете только один пульт, он может неявно отказаться от проверки и отслеживания, например &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt; . Это перестает работать, как только у вас будет более одного пульта со ссылкой на &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; . Этот параметр позволяет установить имя предпочтительного пульта дистанционного управления, которое всегда должно выигрывать, когда дело доходит до устранения неоднозначности. Типичный вариант использования - установить для него значение &lt;code&gt;origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f93e702904ad75a7ffcc41597ebc2474895e0b0" translate="yes" xml:space="preserve">
          <source>When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is &quot;derived&quot; from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2.</source>
          <target state="translated">Когда вы начинаете 3-х стороннее слияние с уже заполненным индексным файлом,предполагается,что он представляет состояние файлов в вашем рабочем дереве,и вы даже можете иметь файлы с изменениями,которые не были записаны в индексном файле.Далее предполагается,что это состояние &quot;выведено&quot; из дерева стадии 2.Трехстороннее слияние отказывается запускаться,если находит в исходном индексном файле запись,не соответствующую 2-му этапу.</target>
        </trans-unit>
        <trans-unit id="6831d00e1f830a484b6c5799e343f596bbc55899" translate="yes" xml:space="preserve">
          <source>When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit.</source>
          <target state="translated">Когда вы хотите просто интегрироваться с работой,ведущей к коммиту,который случайно помечен,например,синхронизируясь с точкой релиза вверх по тегу,вы можете не захотеть делать ненужный коммит слияния.</target>
        </trans-unit>
        <trans-unit id="2f28e5d62e5a87453e903e81e941382b8ac566c1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, just run</source>
          <target state="translated">Когда вы будете готовы, просто бегите</target>
        </trans-unit>
        <trans-unit id="4aa6b6296b8d97b342099d335ec15bc55634ad41" translate="yes" xml:space="preserve">
          <source>When your topic branch is long-lived, however, your topic branch would end up having many such &quot;Merge from master&quot; commits on it, which would unnecessarily clutter the development history. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of &quot;useless merges&quot;.</source>
          <target state="translated">Однако,когда ваша тематическая ветка долгоживущая,в конце концов,в ней будет много таких коммитов &quot;Слияние с мастером&quot;,которые без необходимости будут загромождать историю разработки.Читатели списка рассылки ядра Linux,возможно,помнят,что Линус жаловался на слишком частые тестовые слияния,когда сопровождающий подсистемы просил вытащить из ответвления,полного &quot;бесполезных слияний&quot;.</target>
        </trans-unit>
        <trans-unit id="bd4128428344ae6c28977b2bc5cf00953da1175f" translate="yes" xml:space="preserve">
          <source>When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:</source>
          <target state="translated">Когда ваша тематическая ветка изменяет область перекрытия,которую ваша основная ветка (или верхняя)коснулась,так как ваша тематическая ветка вышла из неё,вы можете протестировать её с последней основной веткой,ещё до того,как ваша тематическая ветка будет готова к проталкиванию вверх по течению:</target>
        </trans-unit>
        <trans-unit id="4f4eaf255ffc69df0530167a4810c74e9370cd43" translate="yes" xml:space="preserve">
          <source>Whenever possible, section headings should clearly describe the task they explain how to do, in language that requires no more knowledge than necessary: for example, &quot;importing patches into a project&quot; rather than &quot;the &lt;code&gt;git am&lt;/code&gt; command&quot;</source>
          <target state="translated">По возможности, заголовки разделов должны четко описывать задачу, которую они объясняют, как выполнять, на языке, который не требует дополнительных знаний, чем необходимо: например, &amp;laquo;импорт патчей в проект&amp;raquo;, а не &amp;laquo;команда &lt;code&gt;git am&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="11683716a14fb2e59c3ad4d48a607606706a0329" translate="yes" xml:space="preserve">
          <source>Where &quot;oldsha1&quot; is the 40 character hexadecimal value previously stored in &amp;lt;ref&amp;gt;, &quot;newsha1&quot; is the 40 character hexadecimal value of &amp;lt;newvalue&amp;gt; and &quot;committer&quot; is the committer&amp;rsquo;s name, email address and date in the standard Git committer ident format.</source>
          <target state="translated">Где oldsha1 - это 40-символьное шестнадцатеричное значение, ранее сохраненное в &amp;lt;ref&amp;gt;, &amp;laquo;newsha1&amp;raquo; - 40-символьное шестнадцатеричное значение &amp;lt;newvalue&amp;gt;, а &amp;laquo;committer&amp;raquo; - имя коммиттера, адрес электронной почты и дата в стандартном формате идентификатора коммиттера Git. ,</target>
        </trans-unit>
        <trans-unit id="9a6682bd90b10ed7b65387d46ac6e3098ba208ce" translate="yes" xml:space="preserve">
          <source>Where all fields are as described above and &quot;message&quot; is the value supplied to the -m option.</source>
          <target state="translated">Где все поля,как описано выше,и &quot;сообщение&quot;-это значение,передаваемое в опцию -m.</target>
        </trans-unit>
        <trans-unit id="1047cdb3a9504c1e49ba180691c6de133fb29736" translate="yes" xml:space="preserve">
          <source>Where to create the Git repository. If not provided, the last component in the p4 depot path is used to create a new directory.</source>
          <target state="translated">Где создать Git-репозиторий.Если это не предусмотрено,для создания нового каталога используется последний компонент пути p4 depot.</target>
        </trans-unit>
        <trans-unit id="de8afe671960d7a395defa2e40a80901d96e2485" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; would produce:</source>
          <target state="translated">В то время как &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; выдаст:</target>
        </trans-unit>
        <trans-unit id="92669e9b8b127c2ba15691914d72dae97b880d0d" translate="yes" xml:space="preserve">
          <source>Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. If merge.directoryRenames is set to &quot;false&quot;, directory rename detection is disabled, meaning that such new files will be left behind in the old directory. If set to &quot;true&quot;, directory rename detection is enabled, meaning that such new files will be moved into the new directory. If set to &quot;conflict&quot;, a conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to &quot;conflict&quot;.</source>
          <target state="translated">Обнаруживает ли Git переименования каталогов,влияя на то,что происходит во время слияния с новыми файлами,добавленными в каталог на одной стороне истории,когда этот каталог был переименован на другой стороне истории.Если параметр merge.directoryRenames установлен в значение &quot;false&quot;,то определение переименования каталога отключается,то есть такие новые файлы будут оставлены в старом каталоге.Если установлено значение &quot;true&quot;,то детектирование переименования директории включено,то есть такие новые файлы будут перемещены в новую директорию.Если установлено значение &quot;конфликт&quot;,то для таких путей будет сообщено о конфликте.Если значение параметра merge.renames равно false,то merge.directoryRenames будет проигнорирован и будет считаться ложным.По умолчанию установлено значение &quot;конфликт&quot;.</target>
        </trans-unit>
        <trans-unit id="6720b94e3bf2c12c61b3c14de0415d18239394a0" translate="yes" xml:space="preserve">
          <source>Whether Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. Defaults to the value of diff.renames.</source>
          <target state="translated">Обнаружит ли Гит переименование.Если установлено значение &quot;false&quot;,определение переименования отключено.Если установлено значение &quot;true&quot;,основное определение переименования включено.По умолчанию равнозначно значению diff.renames.</target>
        </trans-unit>
        <trans-unit id="d1f68ec7a1f81e21d54ab2e76eaccedf11117ff8" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; . If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to the value of diff.renames.</source>
          <target state="translated">Обнаруживает ли и как Git переименование в &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; и &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; . Если установлено значение &amp;laquo;false&amp;raquo;, определение переименования отключено. Если установлено значение &amp;laquo;true&amp;raquo;, включено базовое определение переименования. Если установлено значение &amp;laquo;копии&amp;raquo; или &amp;laquo;копировать&amp;raquo;, Git также обнаружит копии. По умолчанию используется значение diff.renames.</target>
        </trans-unit>
        <trans-unit id="cd914284b278d491020fec9d972b776a56df2f14" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain like &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and not lower level commands such as &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;.</source>
          <target state="translated">Обнаруживает ли Git переименование и каким образом. Если установлено значение &amp;laquo;false&amp;raquo;, определение переименования отключено. Если установлено значение &amp;laquo;true&amp;raquo;, включено базовое определение переименования. Если установлено значение &amp;laquo;копии&amp;raquo; или &amp;laquo;копировать&amp;raquo;, Git также обнаружит копии. По умолчанию true. Обратите внимание, что это влияет только на &lt;code&gt;git diff&lt;/code&gt; Porcelain, например &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; и &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , но не на команды более низкого уровня, такие как &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2329b3f81f31d1e7aac7efc37e396ae5ccc9b5fe" translate="yes" xml:space="preserve">
          <source>Whether git should follow HTTP redirects. If set to &lt;code&gt;true&lt;/code&gt;, git will transparently follow any redirect issued by a server it encounters. If set to &lt;code&gt;false&lt;/code&gt;, git will treat all redirects as errors. If set to &lt;code&gt;initial&lt;/code&gt;, git will follow redirects only for the initial request to a remote, but not for subsequent follow-up HTTP requests. Since git uses the redirected URL as the base for the follow-up requests, this is generally sufficient. The default is &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">Должен ли git следовать перенаправлениям HTTP. Если установлено значение &lt;code&gt;true&lt;/code&gt; , git будет прозрачно следовать любому перенаправлению, выданному сервером, с которым он сталкивается. Если установлено значение &lt;code&gt;false&lt;/code&gt; , git будет рассматривать все перенаправления как ошибки. Если установлено значение &lt;code&gt;initial&lt;/code&gt; , git будет следовать перенаправлениям только для начального запроса к удаленному устройству, но не для последующих последующих HTTP-запросов. Поскольку git использует перенаправленный URL-адрес в качестве основы для последующих запросов, этого обычно достаточно. Значение по умолчанию - &lt;code&gt;initial&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd0092aedf4252969afafd8803ba8faf98999493" translate="yes" xml:space="preserve">
          <source>Whether that update is allowed without &lt;code&gt;--force&lt;/code&gt; depends on the ref namespace it&amp;rsquo;s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; for what those are. Exceptions to those rules particular to &lt;code&gt;git fetch&lt;/code&gt; are noted below.</source>
          <target state="translated">Разрешено ли это обновление без &lt;code&gt;--force&lt;/code&gt; , зависит от пространства имен ref, в которое оно извлекается, типа извлекаемого объекта и от того, считается ли обновление быстрой перемоткой вперед. Как правило, для выборки применяются те же правила, что и при нажатии, см. &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; в &lt;a href=&quot;git-push&quot;&gt;git-push [1],&lt;/a&gt; чтобы узнать, что это такое. Исключения из этих правил, &lt;code&gt;git fetch&lt;/code&gt; к git fetch, указаны ниже.</target>
        </trans-unit>
        <trans-unit id="9c31395d6226db0f96527cf13d7284a32596aaef" translate="yes" xml:space="preserve">
          <source>Whether the CVS server interface is enabled for this repository. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Включен ли интерфейс сервера CVS для этого репозитория. См. &lt;a href=&quot;git-cvsserver&quot;&gt;Git-cvsserver [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e99c94b5e67663cef6460c2b09cda34348e975de" translate="yes" xml:space="preserve">
          <source>Whether to enable the grouping of projects by category on the project list page. The category of a project is determined by the &lt;code&gt;$GIT_DIR/category&lt;/code&gt; file or the &lt;code&gt;gitweb.category&lt;/code&gt; variable in each repository&amp;rsquo;s configuration. Disabled by default (set to 0).</source>
          <target state="translated">Включать ли группировку проектов по категориям на странице списка проектов. Категория проекта определяется &lt;code&gt;$GIT_DIR/category&lt;/code&gt; или переменной &lt;code&gt;gitweb.category&lt;/code&gt; в конфигурации каждого репозитория. По умолчанию отключено (установлено значение 0).</target>
        </trans-unit>
        <trans-unit id="be60442dc9a2bb750c3ffb3e91f602fa8cf454b7" translate="yes" xml:space="preserve">
          <source>Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default.</source>
          <target state="translated">Следует ли распечатать дифстат между ORIG_HEAD и результатом слияния в конце слияния.По умолчанию верно.</target>
        </trans-unit>
        <trans-unit id="e6d010b4fa5fb27d92c64dc2f59319c4e77b544c" translate="yes" xml:space="preserve">
          <source>Whether to show a diffstat of what changed upstream since the last rebase. False by default.</source>
          <target state="translated">Показывать ли дифстат того,что изменилось вверх по течению с момента последнего ребрендинга.Ложно по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2153c59644d7df4b2ed210d8ef453074b1a6c2ac" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Следует ли пропускать чтение настроек из общесистемного файла $ (prefix) / etc / gitconfig. Подробнее см. &lt;a href=&quot;git&quot;&gt;Git [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c8173d7da296bd9c5f5aef35e3d739c8852bc79" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; file. This environment variable can be used along with &lt;code&gt;$HOME&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; to create a predictable environment for a picky script, or you can set it temporarily to avoid using a buggy &lt;code&gt;/etc/gitconfig&lt;/code&gt; file while waiting for someone with sufficient permissions to fix it.</source>
          <target state="translated">&lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; ли пропускать чтение настроек из общесистемного файла $ (prefix) / etc / gitconfig . Эту переменную среды можно использовать вместе с &lt;code&gt;$HOME&lt;/code&gt; и &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; чтобы создать предсказуемую среду для придирчивого сценария, или вы можете установить ее временно, чтобы избежать использования &lt;code&gt;/etc/gitconfig&lt;/code&gt; файла / etc / gitconfig , ожидая, пока кто-то с достаточными разрешениями исправит его.</target>
        </trans-unit>
        <trans-unit id="488ddc0ec5d5c663a8e8059a323ed70db5316b78" translate="yes" xml:space="preserve">
          <source>Whether to use ANSI escape sequences to add color to patches. If this is set to &lt;code&gt;always&lt;/code&gt;, &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; will use color for all patches. If it is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, those commands will only use color when output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">Следует ли использовать escape-последовательности ANSI для добавления цвета к заплатам. Если установлено значение &lt;code&gt;always&lt;/code&gt; , &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; и &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; будут использовать цвет для всех патчей. Если установлено значение &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;auto&lt;/code&gt; , эти команды будут использовать цвет только при выводе на терминал. Если не задано, используется значение &lt;code&gt;color.ui&lt;/code&gt; ( по умолчанию &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="21386b2036d855c8d8dd6eb4c84085329fcf2561" translate="yes" xml:space="preserve">
          <source>Whether to use empty blobs as rename source.</source>
          <target state="translated">Использовать ли пустые капли в качестве источника переименования.</target>
        </trans-unit>
        <trans-unit id="63ea1a80cc99dbbdec2d362a1b57aa7468c9ed6d" translate="yes" xml:space="preserve">
          <source>Whether to verify the SSL certificate when fetching or pushing over HTTPS. Defaults to true. Can be overridden by the &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; environment variable.</source>
          <target state="translated">Следует ли проверять сертификат SSL при получении или передаче по HTTPS. По умолчанию true. Может быть переопределено переменной окружения &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec9fdb5354be84561f27023760593b27a86cd126" translate="yes" xml:space="preserve">
          <source>Which file to place a pattern in depends on how the pattern is meant to be used.</source>
          <target state="translated">В какой файл поместить шаблон,зависит от того,как будет использоваться шаблон.</target>
        </trans-unit>
        <trans-unit id="9342c5a7ca74e113fca6826c098da1e9dea46c59" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each strategy.</source>
          <target state="translated">Какую стратегию слияния выбрать по умолчанию при разрешении конфликтов заметок. Должно быть один из &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;cat_sort_uniq&lt;/code&gt; . По умолчанию &lt;code&gt;manual&lt;/code&gt; . См. Раздел &amp;laquo;ЗАМЕЧАНИЯ ПО СТРАТЕГИЯМ СЛИЯНИЯ&amp;raquo; выше для получения дополнительной информации по каждой стратегии.</target>
        </trans-unit>
        <trans-unit id="7dd75dabb694bc7182031b6cdb5c605283f3ff3a" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section of &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on each strategy.</source>
          <target state="translated">Какую стратегию слияния выбрать по умолчанию при разрешении конфликтов заметок. Должно быть один из &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; или &lt;code&gt;cat_sort_uniq&lt;/code&gt; . По умолчанию &lt;code&gt;manual&lt;/code&gt; . См. Раздел &amp;laquo;NOTES MERGE STRATEGIES&amp;raquo; в &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; для получения дополнительной информации по каждой стратегии.</target>
        </trans-unit>
        <trans-unit id="9bd73c0d97037644e549ed3fed8d2491f5cfc8e0" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each available strategy.</source>
          <target state="translated">Какую стратегию слияния выбрать при слиянии заметок с refs / notes / &amp;lt;name&amp;gt;. Это отменяет более общий &quot;notes.mergeStrategy&quot;. См. Раздел &amp;laquo;ПРИМЕЧАНИЯ К СТРАТЕГИЯМ СЛИЯНИЯ&amp;raquo; выше для получения дополнительной информации о каждой доступной стратегии.</target>
        </trans-unit>
        <trans-unit id="f202b61699020bcfa082fe897d7a8560aea486a1" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on the available strategies.</source>
          <target state="translated">Какую стратегию слияния выбрать при слиянии заметок с refs / notes / &amp;lt;name&amp;gt;. Это отменяет более общий &quot;notes.mergeStrategy&quot;. См. Раздел &amp;laquo;NOTES MERGE STRATEGIES&amp;raquo; в &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; для получения дополнительной информации о доступных стратегиях.</target>
        </trans-unit>
        <trans-unit id="556a322f94dd1e45943ded0ebea9906e93ca0c80" translate="yes" xml:space="preserve">
          <source>Which ref (or refs, if a glob or specified more than once), in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;git log&lt;/code&gt; family of commands. This setting can be overridden on the command line or by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">Какую ссылку (или ссылки, если глобус или указано более одного раза), помимо значения по умолчанию, установленного в &lt;code&gt;core.notesRef&lt;/code&gt; или &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; , для чтения заметок при отображении сообщений фиксации с помощью семейства команд &lt;code&gt;git log&lt;/code&gt; . Этот параметр можно переопределить в командной строке или переменной среды &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; . См. &lt;a href=&quot;git-log&quot;&gt;Git-log [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="08e8ee8d98ea130471cc368fbf1a571f3d29a34d" translate="yes" xml:space="preserve">
          <source>Which ref to manipulate notes from, instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. This overrides the &lt;code&gt;core.notesRef&lt;/code&gt; setting.</source>
          <target state="translated">С какой ссылки можно работать с заметками, а не с ссылок &lt;code&gt;refs/notes/commits&lt;/code&gt; . Это отменяет настройку &lt;code&gt;core.notesRef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="180171a89f79828ca3aedfa4194b8ff07f802f3f" translate="yes" xml:space="preserve">
          <source>Which refs, in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;log&lt;/code&gt; family of commands. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">Какие рефов, в дополнение к набору по умолчанию с помощью &lt;code&gt;core.notesRef&lt;/code&gt; или &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; , читать ноты с при показе фиксации сообщений с помощью &lt;code&gt;log&lt;/code&gt; семейства команд. См. &lt;a href=&quot;git-notes&quot;&gt;Git-notes [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4dbbdac6096ee85d080e618f1dfec3eb7804653" translate="yes" xml:space="preserve">
          <source>Which will add the following to a file named &lt;code&gt;.gitconfig&lt;/code&gt; in your home directory:</source>
          <target state="translated">Это добавит следующее в файл с именем &lt;code&gt;.gitconfig&lt;/code&gt; в вашем домашнем каталоге:</target>
        </trans-unit>
        <trans-unit id="0b383fc769f1bfb4acb136b5be3ea84e9742db33" translate="yes" xml:space="preserve">
          <source>Which would result in:</source>
          <target state="translated">В результате чего:</target>
        </trans-unit>
        <trans-unit id="5efe59371f7c539c77a16fb753d65287a4a1a881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are in, you can also specify what files are &lt;code&gt;not&lt;/code&gt; in, using negate patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">Хотя &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; обычно используется для указания, в каких файлах находятся, вы также можете указать, каких файлов &lt;code&gt;not&lt;/code&gt; , используя шаблоны отрицания. Например, чтобы удалить &lt;code&gt;unwanted&lt;/code&gt; файл :</target>
        </trans-unit>
        <trans-unit id="133c634c89411bc7bbb73a5aa8f4cda72b5442c2" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are included, you can also specify what files are &lt;code&gt;not&lt;/code&gt; included, using negative patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">Хотя &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; обычно используется для указания, какие файлы включаются, вы также можете указать, какие файлы &lt;code&gt;not&lt;/code&gt; включаются, используя отрицательные шаблоны. Например, чтобы удалить &lt;code&gt;unwanted&lt;/code&gt; файл :</target>
        </trans-unit>
        <trans-unit id="118bfe73a3b1ef14dd8bb7fedadb7cb55f01bcfb" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; was about specifying a single commit parent, these three notations also consider its parents. For example you can say &lt;code&gt;HEAD^2^@&lt;/code&gt;, however you cannot say &lt;code&gt;HEAD^@^2&lt;/code&gt;.</source>
          <target state="translated">Хотя &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; был связан с указанием одного родителя фиксации, эти три нотации также учитывают его родителей. Например, вы можете сказать &lt;code&gt;HEAD^2^@&lt;/code&gt; , но не можете сказать &lt;code&gt;HEAD^@^2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92e92ccd1a34f0875d32051d1b819b76c11daddf" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT{litdd}devo{litdd}VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">Хотя &lt;code&gt;git archimport&lt;/code&gt; будет пытаться создать разумные имена веток для импортируемых архивов, также можно указать имена веток Git вручную. Для этого напишите имя ветки Git после каждого параметра &amp;lt;archive / branch&amp;gt;, разделенное двоеточием. Таким образом, вы можете сократить имена веток Arch и преобразовать жаргон Arch в жаргон Git, например, сопоставив ветвь PROJECT {litdd} Dev {litdd} VERSION &quot;master&quot;.</target>
        </trans-unit>
        <trans-unit id="6e3c7753b36510ea58174f6c4603b4398587f401" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">В то время как &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; покажет эту фиксацию, &lt;code&gt;git log -S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; не будет) (поскольку количество вхождений этой строки не изменилось).</target>
        </trans-unit>
        <trans-unit id="9fa3ab181478a04a41a15d625153bef4e8a57c74" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git svn&lt;/code&gt; can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users. Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below).</source>
          <target state="translated">Хотя &lt;code&gt;git svn&lt;/code&gt; может отслеживать историю копий (включая ветки и теги) для репозиториев, использующих стандартный макет, он еще не может отображать историю слияния, которая произошла внутри git, для пользователей SVN. Поэтому рекомендуется, чтобы пользователи сохраняли историю как можно более линейной внутри Git, чтобы облегчить совместимость с SVN (см. Раздел ПРОГНОЗЫ ниже).</target>
        </trans-unit>
        <trans-unit id="6dffb65164b8303d8f69a39b7acb7d5c91ede142" translate="yes" xml:space="preserve">
          <source>While Git normally leaves file contents alone, it can be configured to normalize line endings to LF in the repository and, optionally, to convert them to CRLF when files are checked out.</source>
          <target state="translated">Хотя Git обычно оставляет содержимое файлов в покое,его можно настроить на нормализацию окончания строк в LF в репозитории и,опционально,на преобразование их в CRLF,когда файлы извлекаются из репозитория.</target>
        </trans-unit>
        <trans-unit id="28e5e3e789710acfbe64ae88514ac76e33edddf4" translate="yes" xml:space="preserve">
          <source>While a tree represents a particular directory state of a working directory, a commit represents that state in &quot;time&quot;, and explains how to get there.</source>
          <target state="translated">В то время как дерево представляет определённое состояние каталога рабочего каталога,коммит представляет это состояние во &quot;времени&quot; и объясняет,как туда добраться.</target>
        </trans-unit>
        <trans-unit id="4340adfab1f511dfd0a9b398534e55b63d70f9b2" translate="yes" xml:space="preserve">
          <source>While an &quot;easy case recovery&quot; sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via &lt;code&gt;git rebase
      --interactive&lt;/code&gt; will be &lt;strong&gt;resurrected&lt;/strong&gt;!</source>
          <target state="translated">Хотя &amp;laquo;легкое восстановление случая&amp;raquo; иногда оказывается успешным даже в тяжелом случае, оно может иметь непредвиденные последствия. Например, коммит, удаленный с помощью &lt;code&gt;git rebase --interactive&lt;/code&gt; будет &lt;strong&gt;воскрешен&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="aeca28e54d758d00b7b9efe81e9021c3ae168604" translate="yes" xml:space="preserve">
          <source>While at it, check the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;final-commit&lt;/code&gt; files as well. If what is in &lt;code&gt;final-commit&lt;/code&gt; is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like &quot;Hi, this is my first patch.\n&quot; in the patch e-mail should come after the three-dash line that signals the end of the commit message.</source>
          <target state="translated">Находясь в нем, проверьте также файлы &lt;code&gt;info&lt;/code&gt; и &lt;code&gt;final-commit&lt;/code&gt; . Если то, что находится в &lt;code&gt;final-commit&lt;/code&gt; , не совсем то, что вы хотели бы видеть в сообщении журнала фиксации, очень вероятно, что получатель в конечном итоге вручную отредактирует сообщение журнала при применении вашего патча. Такие слова, как &amp;laquo;Привет, это мой первый патч. \ N&amp;raquo; в электронном письме с патчем должны идти после трех штриховой линии, которая сигнализирует об окончании сообщения о фиксации.</target>
        </trans-unit>
        <trans-unit id="8ae695a4eabf8fe5dbbd3e5b96e3d4b6e1234599" translate="yes" xml:space="preserve">
          <source>While creating changes is useful, it&amp;rsquo;s even more useful if you can tell later what changed. The most useful command for this is another of the &lt;code&gt;diff&lt;/code&gt; family, namely &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">Хотя создание изменений полезно, это еще более полезно, если вы позже узнаете, что изменилось. Самая полезная команда для этого - другая команда из семейства &lt;code&gt;diff&lt;/code&gt; , а именно &lt;code&gt;git diff-tree&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84a06403fddbfbdfed756ddcbe7e1b6ff85edd7a" translate="yes" xml:space="preserve">
          <source>While one could just alter the configuration settings in the gitweb CGI itself, those changes would be lost upon upgrade. Configuration settings might also be placed into a file in the same directory as the CGI script with the default name &lt;code&gt;gitweb_config.perl&lt;/code&gt; &amp;mdash; allowing one to have multiple gitweb instances with different configurations by the use of symlinks.</source>
          <target state="translated">Хотя можно было просто изменить параметры конфигурации в самом gitweb CGI, эти изменения будут потеряны при обновлении. Параметры конфигурации также могут быть помещены в файл в том же каталоге, что и сценарий CGI, с именем по умолчанию &lt;code&gt;gitweb_config.perl&lt;/code&gt; , что позволяет иметь несколько экземпляров gitweb с разными конфигурациями с помощью символических ссылок.</target>
        </trans-unit>
        <trans-unit id="3129dc27b36b536bbc925e644f78f32bde86376a" translate="yes" xml:space="preserve">
          <source>While parent object ids are provided on the command line, author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">В то время как идентификаторы родительских объектов предоставляются в командной строке,информация об авторе и коммитере берется из следующих переменных окружения,если они установлены:</target>
        </trans-unit>
        <trans-unit id="7921bb694427f6298ff631684ef33f9b3436be57" translate="yes" xml:space="preserve">
          <source>While you are in the middle of working on something complicated, you find an unrelated but obvious and trivial bug. You would like to fix it before continuing. You can use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to save the current state of your work, and after fixing the bug (or, optionally after doing so on a different branch and then coming back), unstash the work-in-progress changes.</source>
          <target state="translated">Пока вы работаете над чем-то сложным, вы обнаруживаете несвязанную, но очевидную и тривиальную ошибку. Прежде чем продолжить, вы хотите исправить это. Вы можете использовать &lt;a href=&quot;git-stash&quot;&gt;git-stash [1],&lt;/a&gt; чтобы сохранить текущее состояние вашей работы, и после исправления ошибки (или, при желании, сделав это в другой ветке и затем вернувшись), открепите незавершенные изменения.</target>
        </trans-unit>
        <trans-unit id="aa47dd8a2f0ebe83c1c9e1c5b54451eb489a4bd1" translate="yes" xml:space="preserve">
          <source>Whitespace separated fields; any run of whitespace can be used as field separator (rules for Perl&amp;rsquo;s &quot;&lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt;&quot;).</source>
          <target state="translated">Поля, разделенные пробелами; любой пробел может использоваться в качестве разделителя полей (правила Perl &quot; &lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt; &quot;).</target>
        </trans-unit>
        <trans-unit id="863aeb0371f511e273bc66c19d53b7877f38ac8a" translate="yes" xml:space="preserve">
          <source>Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:</source>
          <target state="translated">Разделенный пробелами список разрешенных механизмов SMTP-AUTH.Эта настройка заставляет использовать только перечисленные механизмы.Пример:</target>
        </trans-unit>
        <trans-unit id="389ff74463b52646838e41646e64e38a902b85eb" translate="yes" xml:space="preserve">
          <source>Why bisecting merge commits can be harder than bisecting linear history</source>
          <target state="translated">Почему биссектрисные коммиты слияния могут быть сложнее,чем биссектрисная линейная история.</target>
        </trans-unit>
        <trans-unit id="4ae988a6589a0546387522087a0861a61e3e4225" translate="yes" xml:space="preserve">
          <source>Wildcards in the pattern such as &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are treated as literal characters.</source>
          <target state="translated">Подстановочные знаки в шаблоне, например &lt;code&gt;*&lt;/code&gt; или &lt;code&gt;?&lt;/code&gt; рассматриваются как буквальные символы.</target>
        </trans-unit>
        <trans-unit id="af4b569cb0fc1bae5a933e3532b964dc5d61facd" translate="yes" xml:space="preserve">
          <source>Will copy all files listed from the index to the working directory (not overwriting existing files).</source>
          <target state="translated">Скопирует все файлы из индекса в рабочую директорию (не перезаписывая существующие файлы).</target>
        </trans-unit>
        <trans-unit id="712e5286413fd90307ff92f23e110885525f2bb8" translate="yes" xml:space="preserve">
          <source>Will fail unless you manually run &lt;code&gt;git fetch origin-push&lt;/code&gt;. This method is of course entirely defeated by something that runs &lt;code&gt;git fetch
--all&lt;/code&gt;, in that case you&amp;rsquo;d need to either disable it or do something more tedious like:</source>
          <target state="translated">Не удастся, если вы вручную не запустите &lt;code&gt;git fetch origin-push&lt;/code&gt; . Этот метод, конечно, полностью &lt;code&gt;git fetch --all&lt;/code&gt; , что запускает git fetch --all , в этом случае вам нужно либо отключить его, либо сделать что-то более утомительное, например:</target>
        </trans-unit>
        <trans-unit id="bfd8a0b8d0916903c6596ed358a3cc07670d304e" translate="yes" xml:space="preserve">
          <source>Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via &lt;code&gt;CreateProcess()&lt;/code&gt; is not an option because it would require the handles to be marked inheritable (and consequently &lt;strong&gt;every&lt;/strong&gt; spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt;).</source>
          <target state="translated">Только для Windows: разрешить перенаправление стандартных дескрипторов ввода / вывода / ошибок на пути, указанные в переменных среды. Это особенно полезно в многопоточных приложениях, где канонический способ передачи стандартных дескрипторов через &lt;code&gt;CreateProcess()&lt;/code&gt; не является вариантом, потому что для этого потребовалось бы, чтобы дескрипторы были помечены как наследуемые (и, следовательно, &lt;strong&gt;каждый&lt;/strong&gt; порожденный процесс унаследовал бы их, возможно, блокируя обычные операции Git. ). Основным предполагаемым вариантом использования является использование именованных каналов для связи (например, &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c510c80ca0db551792868481dfce7936d126272" translate="yes" xml:space="preserve">
          <source>Windows-only: comma-separated list of environment variables' names that need to be unset before spawning any other process. Defaults to &lt;code&gt;PERL5LIB&lt;/code&gt; to account for the fact that Git for Windows insists on using its own Perl interpreter.</source>
          <target state="translated">Только для Windows: разделенный запятыми список имен переменных среды, которые необходимо сбросить перед запуском любого другого процесса. По умолчанию используется &lt;code&gt;PERL5LIB&lt;/code&gt; , чтобы учесть тот факт, что Git для Windows настаивает на использовании собственного интерпретатора Perl.</target>
        </trans-unit>
        <trans-unit id="e74f053e0d02cafdbd0bbd14c65f9fd314f00d13" translate="yes" xml:space="preserve">
          <source>Windows-only: override whether spawned processes inherit only standard file handles (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) or all handles. Can be &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Defaults to &lt;code&gt;auto&lt;/code&gt;, which means &lt;code&gt;true&lt;/code&gt; on Windows 7 and later, and &lt;code&gt;false&lt;/code&gt; on older Windows versions.</source>
          <target state="translated">Только для Windows: переопределить, наследуют ли порожденные процессы только стандартные дескрипторы файлов ( &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; и &lt;code&gt;stderr&lt;/code&gt; ) или все дескрипторы. Может быть &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . По умолчанию установлено значение &amp;laquo; &lt;code&gt;auto&lt;/code&gt; , что означает &amp;laquo; &lt;code&gt;true&lt;/code&gt; в Windows 7 и более поздних версиях и &amp;laquo; &lt;code&gt;false&lt;/code&gt; в более старых версиях Windows.</target>
        </trans-unit>
        <trans-unit id="949442d2f0c16b026f680dbb7df65e881242333c" translate="yes" xml:space="preserve">
          <source>With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:</source>
          <target state="translated">С --abbrev,установленным в 0,команда может быть использована для поиска ближайшего магнетического имени без суффикса:</target>
        </trans-unit>
        <trans-unit id="a158e0380ec8b734a269ad9d0f52eb5eb98f2274" translate="yes" xml:space="preserve">
          <source>With --all, the command can use branch heads as references, so the output shows the reference path as well:</source>
          <target state="translated">С помощью --all команда может использовать головки ответвлений в качестве ссылок,поэтому на выходе также отображается ссылочный путь:</target>
        </trans-unit>
        <trans-unit id="65ee9a1948ccba3bbf4e1e0783ded1eb1bf032c9" translate="yes" xml:space="preserve">
          <source>With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.</source>
          <target state="translated">С помощью --batch или --batch-check при запросе объектов с расширенными SHA-1 выражениями формы tree-ish:path-in-tree следуйте по симлинкам внутри репозитория.Вместо того,чтобы предоставлять вывод о самой ссылке,предоставляйте вывод об объекте,на который дана ссылка.Если сим-ссылка указывает вне дерева (например,ссылка на /foo или ссылка корневого уровня на ../foo),то будет выведена та часть ссылки,которая находится вне дерева.</target>
        </trans-unit>
        <trans-unit id="4f48f3dcfb8092537ede5a515e981d6e213aeb9f" translate="yes" xml:space="preserve">
          <source>With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.</source>
          <target state="translated">С помощью команды --no-commit выполните слияние и остановитесь непосредственно перед созданием коммита слияния,чтобы дать пользователю возможность проверить и в дальнейшем откорректировать результат слияния перед фиксацией.</target>
        </trans-unit>
        <trans-unit id="3e8c9cc261afe4f0a3a9c88b1d66c9688df929d7" translate="yes" xml:space="preserve">
          <source>With --no-log do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">При использовании --no-log не перечисляйте описания в одну строку из самих объединяемых коммитов.</target>
        </trans-unit>
        <trans-unit id="e1adfa5cefd427bf7d3a2a21965629dcaf3c3388" translate="yes" xml:space="preserve">
          <source>With --no-signoff do not add a Signed-off-by line.</source>
          <target state="translated">С --no-signoff не добавляйте подпись по строке.</target>
        </trans-unit>
        <trans-unit id="268060b1be32cd8bc70e7e3bb40c821b809c90c3" translate="yes" xml:space="preserve">
          <source>With --no-squash perform the merge and commit the result. This option can be used to override --squash.</source>
          <target state="translated">С помощью --no-squash выполните слияние и зафиксируйте результат.Эта опция может быть использована для переопределения --squash.</target>
        </trans-unit>
        <trans-unit id="2060c61f3742702f58530c81f5eefb302aeb60c1" translate="yes" xml:space="preserve">
          <source>With --squash, --commit is not allowed, and will fail.</source>
          <target state="translated">С --squash,--commit не разрешается,и будет провал.</target>
        </trans-unit>
        <trans-unit id="865b225dd999d9769e36118a7e13e933131732f5" translate="yes" xml:space="preserve">
          <source>With -n or --no-stat do not show a diffstat at the end of the merge.</source>
          <target state="translated">С -n или --no-stat не показывают дифстата в конце слияния.</target>
        </trans-unit>
        <trans-unit id="008f5911b332311009571603d4810039f3b0a542" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of changing existing URLs, new URL is added.</source>
          <target state="translated">С помощью &lt;code&gt;--add&lt;/code&gt; вместо изменения существующих URL-адресов добавляется новый URL-адрес.</target>
        </trans-unit>
        <trans-unit id="6b50c366c66c543504b13b437403fc08b0e99b0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of replacing the list of currently tracked branches, adds to that list.</source>
          <target state="translated">С &lt;code&gt;--add&lt;/code&gt; , вместо замены списка отслеживаемых в настоящее время ветвей, добавляет в этот список.</target>
        </trans-unit>
        <trans-unit id="b5c6ad97197083d8f93283087955bd70bd89f95f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt; flag, all refs that exist locally are transferred to the remote side. You cannot specify any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; if you use this flag.</source>
          <target state="translated">С флагом &lt;code&gt;--all&lt;/code&gt; все ссылки, которые существуют локально, передаются удаленной стороне. Вы не можете указать какой-либо &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; , если используете этот флаг.</target>
        </trans-unit>
        <trans-unit id="487cd0ed38992f1c8c21d61869ab0ba8c9131e91" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt;, all URLs for the remote will be listed.</source>
          <target state="translated">С &lt;code&gt;--all&lt;/code&gt; будут перечислены все URL-адреса для удаленного.</target>
        </trans-unit>
        <trans-unit id="ea729f224a85b66147f6e662a1c5d14a2abdd751" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--contains&lt;/code&gt;, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), &lt;code&gt;--no-contains&lt;/code&gt; inverts it. With &lt;code&gt;--merged&lt;/code&gt;, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With &lt;code&gt;--no-merged&lt;/code&gt; only branches not merged into the named commit will be listed. If the &amp;lt;commit&amp;gt; argument is missing it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch).</source>
          <target state="translated">С &lt;code&gt;--contains&lt;/code&gt; , показывает только те ветви, которые содержат названный коммит (другими словами, ветки, чьи концы коммитов являются потомками названного коммита), &lt;code&gt;--no-contains&lt;/code&gt; инвертирует его. С &lt;code&gt;--merged&lt;/code&gt; будут перечислены только ветки, слитые в названный коммит (т. Е. Ветки, чьи вершины коммитов доступны из названного коммита). С параметром &lt;code&gt;--no-merged&lt;/code&gt; будут перечислены только ветки, не объединенные в названный коммит. Если аргумент &amp;lt;commit&amp;gt; отсутствует, по умолчанию используется &lt;code&gt;HEAD&lt;/code&gt; (т.е. вершина текущей ветви).</target>
        </trans-unit>
        <trans-unit id="a1afc8d7fd506e98e5a974a8f26c84b23238fb92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create-reflog&lt;/code&gt;, update-ref will create a reflog for each ref even if one would not ordinarily be created.</source>
          <target state="translated">С &lt;code&gt;--create-reflog&lt;/code&gt; update-ref создаст журнал ссылок для каждой ссылки, даже если он обычно не создавался.</target>
        </trans-unit>
        <trans-unit id="7fef88021ca55186dc4070339cc8624e9a30485c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--delete&lt;/code&gt;, instead of changing existing URLs, all URLs matching regex &amp;lt;url&amp;gt; are deleted for remote &amp;lt;name&amp;gt;. Trying to delete all non-push URLs is an error.</source>
          <target state="translated">С &lt;code&gt;--delete&lt;/code&gt; вместо изменения существующих URL-адресов все URL-адреса, соответствующие регулярному выражению &amp;lt;url&amp;gt;, удаляются для удаленного &amp;lt;name&amp;gt;. Попытка удалить все URL-адреса без принудительной отправки является ошибкой.</target>
        </trans-unit>
        <trans-unit id="30918cb51e4372be35c787127ec3b8958bb72e8d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches will be pruned, but do not actually prune them.</source>
          <target state="translated">С параметром &lt;code&gt;--dry-run&lt;/code&gt; сообщайте, какие ветви будут обрезаны, но не обрезайте их на самом деле.</target>
        </trans-unit>
        <trans-unit id="5189cda6779864f8bd2f5726b39c4529ff52ddf8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff-only&lt;/code&gt;, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.</source>
          <target state="translated">С &lt;code&gt;--ff-only&lt;/code&gt; разрешите слияние как перемотку вперед, когда это возможно. Если это невозможно, откажитесь от слияния и выйдите с ненулевым статусом.</target>
        </trans-unit>
        <trans-unit id="7e8f4fddd68a3a89ff49906c538a7ca7b5ef9dea" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff&lt;/code&gt;, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.</source>
          <target state="translated">С &lt;code&gt;--ff&lt;/code&gt; , когда это возможно, разрешите слияние как перемотку вперед (только обновите указатель ветки, чтобы он соответствовал объединенной ветке; не создавайте фиксацию слияния). Когда это невозможно (когда объединенная история не является потомком текущей истории), создайте фиксацию слияния.</target>
        </trans-unit>
        <trans-unit id="1362a77896d8f49d16b2f9c5015389cf3c365072" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--force&lt;/code&gt;, the fast-forward check is disabled for all refs.</source>
          <target state="translated">С помощью &lt;code&gt;--force&lt;/code&gt; проверка перемотки вперед отключена для всех ссылок.</target>
        </trans-unit>
        <trans-unit id="ba76b155ec3c447a87cfd160419204d256e0f486" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--keep-cr&lt;/code&gt;, call &lt;code&gt;git mailsplit&lt;/code&gt; (see &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;) with the same option, to prevent it from stripping CR at the end of lines. &lt;code&gt;am.keepcr&lt;/code&gt; configuration variable can be used to specify the default behaviour. &lt;code&gt;--no-keep-cr&lt;/code&gt; is useful to override &lt;code&gt;am.keepcr&lt;/code&gt;.</source>
          <target state="translated">С помощью &lt;code&gt;--keep-cr&lt;/code&gt; вызовите &lt;code&gt;git mailsplit&lt;/code&gt; (см. &lt;a href=&quot;git-mailsplit&quot;&gt;Git-mailsplit [1]&lt;/a&gt; ) с той же опцией, чтобы предотвратить удаление CR в конце строк. &lt;code&gt;am.keepcr&lt;/code&gt; конфигурации am.keepcr может использоваться для определения поведения по умолчанию. &lt;code&gt;--no-keep-cr&lt;/code&gt; полезно переопределить &lt;code&gt;am.keepcr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22e7d426b38d094430582cb84fc0432b42834058" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-ff&lt;/code&gt;, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.</source>
          <target state="translated">С &lt;code&gt;--no-ff&lt;/code&gt; во всех случаях создавайте фиксацию слияния, даже если слияние может быть разрешено как перемотка вперед.</target>
        </trans-unit>
        <trans-unit id="5aa5b8e96804090cb89f3aab6cdc283e2c00d87e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; does not import tags from the remote repository.</source>
          <target state="translated">С &lt;code&gt;--no-tags&lt;/code&gt; вариант, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; не импортирует теги из удаленного хранилища.</target>
        </trans-unit>
        <trans-unit id="37eed19521c790d78f1c0615d39722d6298a6cc8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">С помощью &lt;code&gt;--patch&lt;/code&gt; вы можете в интерактивном режиме выбирать блоки из разницы между HEAD и рабочим деревом, которые нужно сохранить. Запись тайника построена так, что ее состояние индекса совпадает с состоянием индекса вашего репозитория, а ее рабочее дерево содержит только изменения, которые вы выбрали в интерактивном режиме. Затем выбранные изменения откатываются от вашего рабочего дерева. См. Раздел &amp;laquo;Интерактивный режим&amp;raquo; в &lt;a href=&quot;git-add&quot;&gt;git-add [1],&lt;/a&gt; чтобы узнать, как работать в режиме &lt;code&gt;--patch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d4d7e74d0f493c9b38977e43daed9cfd8d04693" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--pretty&lt;/code&gt; format other than &lt;code&gt;oneline&lt;/code&gt; and &lt;code&gt;reference&lt;/code&gt; (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as &lt;code&gt;ref@{Nth}&lt;/code&gt; (where &lt;code&gt;Nth&lt;/code&gt; is the reverse-chronological index in the reflog) or as &lt;code&gt;ref@{timestamp}&lt;/code&gt; (with the timestamp for that entry), depending on a few rules:</source>
          <target state="translated">С форматом &lt;code&gt;--pretty&lt;/code&gt; , отличным от &lt;code&gt;oneline&lt;/code&gt; и &lt;code&gt;reference&lt;/code&gt; (по очевидным причинам), это приводит к тому, что в выводе будут две дополнительные строки информации, взятые из журнала ссылок. Обозначение рефлога в выходных данных может отображаться как &lt;code&gt;ref@{Nth}&lt;/code&gt; (где &lt;code&gt;Nth&lt;/code&gt; - это обратный хронологический индекс в рефлоге) или как &lt;code&gt;ref@{timestamp}&lt;/code&gt; (с меткой времени для этой записи), в зависимости от нескольких правил:</target>
        </trans-unit>
        <trans-unit id="35b7bcaa0d1a12c16e7ebe5749afd0aa0913b69d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--prune&lt;/code&gt; option, run pruning against all the remotes that are updated.</source>
          <target state="translated">С параметром &lt;code&gt;--prune&lt;/code&gt; запустите обрезку для всех обновляемых пультов.</target>
        </trans-unit>
        <trans-unit id="9a993d0e8bfe45705897018a009a33a68fb547fb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are manipulated instead of fetch URLs.</source>
          <target state="translated">С помощью &lt;code&gt;--push&lt;/code&gt; управляются URL-адреса push вместо URL-адресов выборки.</target>
        </trans-unit>
        <trans-unit id="d0c8d67cd6d67334176bbc781201963c60a05697" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are queried rather than fetch URLs.</source>
          <target state="translated">С параметром &lt;code&gt;--push&lt;/code&gt; запрашиваются URL-адреса push, а не URL-адреса получения.</target>
        </trans-unit>
        <trans-unit id="a26943d9e66efe8045d055005cf22b61dc280b47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--stdin&lt;/code&gt;, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:</source>
          <target state="translated">С &lt;code&gt;--stdin&lt;/code&gt; update-ref считывает инструкции со стандартного ввода и выполняет все изменения вместе. Укажите команды формы:</target>
        </trans-unit>
        <trans-unit id="46644e8c0f7ae9adba68ae4958242044a646f477" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; imports every tag from the remote repository.</source>
          <target state="translated">С параметром &lt;code&gt;--tags&lt;/code&gt; &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; импортирует каждый тег из удаленного репозитория.</target>
        </trans-unit>
        <trans-unit id="9afd8cc2d67d37867f3891e80c5ed22f0441334c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--topo-order&lt;/code&gt;, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.</source>
          <target state="translated">С &lt;code&gt;--topo-order&lt;/code&gt; они будут показывать 8 6 5 3 7 4 2 1 (или 8 7 4 2 6 5 3 1); некоторые старые коммиты показаны перед новыми, чтобы не показывать смешанные вместе коммиты из двух параллельных треков разработки.</target>
        </trans-unit>
        <trans-unit id="bbe3bdb143c872f8bc3522bea317a2ad84af9235" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &quot;&lt;code&gt;git remote set-head origin -a&lt;/code&gt;&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">С помощью &lt;code&gt;-a&lt;/code&gt; или &lt;code&gt;--auto&lt;/code&gt; удаленный запрашивается, чтобы определить его &lt;code&gt;HEAD&lt;/code&gt; , затем символическая ссылка &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; устанавливается на ту же ветку. например, если удаленный &lt;code&gt;HEAD&lt;/code&gt; указывает на &lt;code&gt;next&lt;/code&gt; , &quot; &lt;code&gt;git remote set-head origin -a&lt;/code&gt; &quot; установит для символической ссылки &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; значение &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; . Это будет работать, только если &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; уже существует; в противном случае он должен быть получен первым.</target>
        </trans-unit>
        <trans-unit id="5f69d8ea721996a0e954b69bd77400aaa01f9c55" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; flag, it deletes the named &amp;lt;ref&amp;gt; after verifying it still contains &amp;lt;oldvalue&amp;gt;.</source>
          <target state="translated">С флагом &lt;code&gt;-d&lt;/code&gt; он удаляет названный &amp;lt;ref&amp;gt; после проверки, что он все еще содержит &amp;lt;oldvalue&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="da9e1b9da40421df76a154165f2b54d479838ea5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;--delete&lt;/code&gt;, the symbolic ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is deleted.</source>
          <target state="translated">С &lt;code&gt;-d&lt;/code&gt; или &lt;code&gt;--delete&lt;/code&gt; удаляется символическая ссылка &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b0b5064fe468e227911615a2b7fcbafb431eef7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-f&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; is run immediately after the remote information is set up.</source>
          <target state="translated">С параметром &lt;code&gt;-f&lt;/code&gt; &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; запускается сразу после настройки удаленной информации.</target>
        </trans-unit>
        <trans-unit id="4c11581a6169e0a17084bd502989c1df6d5ff9b6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; option, a symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set up to point at remote&amp;rsquo;s &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; branch. See also the set-head command.</source>
          <target state="translated">С параметром &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; , символическая ссылка &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; устанавливается так, чтобы указывать на удаленную ветку &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; . См. Также команду set-head.</target>
        </trans-unit>
        <trans-unit id="734f06f2f4ad450ab9efcf1cd7537f18bb0a22f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-n&lt;/code&gt; option, the remote heads are not queried first with &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt;; cached information is used instead.</source>
          <target state="translated">С параметром &lt;code&gt;-n&lt;/code&gt; удаленные головы не запрашиваются сначала с помощью &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt; ; Вместо этого используется кэшированная информация.</target>
        </trans-unit>
        <trans-unit id="dd75e538fb39d452e807a34068040583ee9147bc" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; option, instead of the default glob refspec for the remote to track all branches under the &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; namespace, a refspec to track only &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is created. You can give more than one &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; to track multiple branches without grabbing all branches.</source>
          <target state="translated">С параметром &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; вместо стандартной glob refspec для удаленного отслеживания всех ветвей в пространстве имен &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; создается refspec для отслеживания только &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; . Вы можете указать более одного &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; для отслеживания нескольких ветвей, не захватывая все ветки.</target>
        </trans-unit>
        <trans-unit id="3a17d1e0c132aee2d2be1ec1ea02b9a88fab2a36" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added, even if some trailers with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair are already in the message.</source>
          <target state="translated">При &lt;code&gt;add&lt;/code&gt; новый трейлер будет добавлен, даже если несколько трейлеров с такой же парой (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) уже есть в сообщении.</target>
        </trans-unit>
        <trans-unit id="bdb99f7baa9796a7b973194e1a5ab4a7e3d82b92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added.</source>
          <target state="translated">С &lt;code&gt;add&lt;/code&gt; будет добавлен новый трейлер.</target>
        </trans-unit>
        <trans-unit id="6b61b0983644b0774834807009f4d278bb642b5a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to HEAD. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">С помощью &lt;code&gt;add&lt;/code&gt; создайте новую ветку с именем &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; , начиная с &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , и извлеките &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; в новое рабочее дерево. Если &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; опущено, по умолчанию используется HEAD. По умолчанию &lt;code&gt;-b&lt;/code&gt; отказывается создавать новую ветку, если она уже существует. &lt;code&gt;-B&lt;/code&gt; отменяет эту защиту, сбрасывая &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; на &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a273ddd960841784db1a589aad98c4feff6c226" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach HEAD in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">С помощью &lt;code&gt;add&lt;/code&gt; отсоедините HEAD в новом рабочем дереве. См. &amp;laquo;ОТДЕЛЕННАЯ ГОЛОВА&amp;raquo; в &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="187a01bfec37522a00b693f68238b703a4e0897c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, suppress feedback messages.</source>
          <target state="translated">С помощью &lt;code&gt;add&lt;/code&gt; подавить сообщения обратной связи.</target>
        </trans-unit>
        <trans-unit id="45995ca3706219a58e816f38cd1d9bf0922ce8ca" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferent&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is already in the message.</source>
          <target state="translated">С &lt;code&gt;addIfDifferent&lt;/code&gt; новый трейлер будет добавлен только в том случае, если в сообщении уже нет трейлера с такой же парой (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="6e3bd24c09b16e87e69f4ad565a18cc8f733f593" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is above or below the line where the new trailer will be added.</source>
          <target state="translated">С &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; новый трейлер будет добавлен только в том случае, если трейлер с такой же парой (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) не находится выше или ниже линии, в которую будет добавлен новый трейлер.</target>
        </trans-unit>
        <trans-unit id="c538516bcb20191b3fc9da51228fff3eefb68cdf" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done.</source>
          <target state="translated">С &lt;code&gt;doNothing&lt;/code&gt; ничего делать не будет.</target>
        </trans-unit>
        <trans-unit id="91898a3512235050c32c7a99a50c8394d7a8397d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done; that is no new trailer will be added if there is already one with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">С &lt;code&gt;doNothing&lt;/code&gt; ничего не будет сделано; то есть новый трейлер не будет добавлен, если в сообщении уже есть трейлер с таким же &amp;lt;token&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="fafece11b5178185f0dda98fe61f1218eca3ec1e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (or variants thereof, e.g. with &lt;code&gt;--cover-letter&lt;/code&gt; or using &lt;code&gt;Z..C&lt;/code&gt; instead of &lt;code&gt;-3 C&lt;/code&gt; to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:</source>
          <target state="translated">С &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (или его вариантами, например, с &lt;code&gt;--cover-letter&lt;/code&gt; или с использованием &lt;code&gt;Z..C&lt;/code&gt; вместо &lt;code&gt;-3 C&lt;/code&gt; для указания диапазона) информационный блок базового дерева отображается в конец первого сообщения, которое выводит команда (либо первый патч, либо сопроводительное письмо), например:</target>
        </trans-unit>
        <trans-unit id="0dbfc249aea522f6a40d4b8be190d1fc0f0eadd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list&lt;/code&gt;, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">С помощью &lt;code&gt;list&lt;/code&gt; вывод в удобном для анализа формате для скриптов. Этот формат останется стабильным для всех версий Git и независимо от конфигурации пользователя. Подробнее см. Ниже.</target>
        </trans-unit>
        <trans-unit id="021957faebf0fa8a6ba6fb4276abb6b8c72afba9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lock&lt;/code&gt;, an explanation why the working tree is locked.</source>
          <target state="translated">С &lt;code&gt;lock&lt;/code&gt; объяснение, почему рабочее дерево заблокировано.</target>
        </trans-unit>
        <trans-unit id="bbe63cab2529b193584b4f7d1c86ee0207fc9968" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, do not remove anything; just report what it would remove.</source>
          <target state="translated">С &lt;code&gt;prune&lt;/code&gt; ничего не удаляйте; просто сообщите, что он удалит.</target>
        </trans-unit>
        <trans-unit id="97f5cdb302d7f0a46689004724feb3d1aca29383" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">С &lt;code&gt;prune&lt;/code&gt; только неиспользуемые рабочие деревья старше &amp;lt;time&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="92ffa86e9306849b846038bae2a07ad322d0f86c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, report all removals.</source>
          <target state="translated">С помощью &lt;code&gt;prune&lt;/code&gt; сообщайте обо всех удалениях.</target>
        </trans-unit>
        <trans-unit id="f6631b122f785beeb20cb0ef884a421b144138ae" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;replace&lt;/code&gt;, an existing trailer with the same &amp;lt;token&amp;gt; will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same &amp;lt;token&amp;gt;) to the place where the new one will be added.</source>
          <target state="translated">При &lt;code&gt;replace&lt;/code&gt; существующий трейлер с тем же символом &amp;lt;token&amp;gt; будет удален, а новый трейлер будет добавлен. Удаленный трейлер будет ближайшим (с тем же &amp;lt;token&amp;gt;) к месту, где будет добавлен новый.</target>
        </trans-unit>
        <trans-unit id="7b787c22358696a7fd63895c838388aed6d7912a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">С &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; , без &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , вместо создания новой ветки из HEAD, если существует ветвь отслеживания ровно на одном удаленном компьютере, соответствующем базовому имени &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; , создайте новую ветвь на удаленном отслеживании ветвь и отметьте ветвь удаленного отслеживания как &amp;laquo;восходящую&amp;raquo; от новой ветки.</target>
        </trans-unit>
        <trans-unit id="660d18378dc3af084a2ac18df92d87c9aea68c5a" translate="yes" xml:space="preserve">
          <source>With Git bisect it&amp;rsquo;s a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it&amp;rsquo;s rarely more than an hour.</source>
          <target state="translated">С Git bisect это совсем несложно: в лучшем случае я смогу сделать ~ 15 шагов ядра пополам за 20-30 минут, автоматически. Даже с ручной помощью или при разделении пополам нескольких перекрывающихся ошибок редко бывает больше часа.</target>
        </trans-unit>
        <trans-unit id="46d101f0f209ac246ff187c45b6b808668e526b7" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted.</source>
          <target state="translated">С &lt;code&gt;-d&lt;/code&gt; или &lt;code&gt;-D&lt;/code&gt; опции &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; будут удалены. Вы можете указать более одной ветви для удаления. Если в ветке в настоящее время есть журнал ссылок, он также будет удален.</target>
        </trans-unit>
        <trans-unit id="f74d36fd60998cbf589b7f2b7f7bc156998c0334" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-M&lt;/code&gt; option, &amp;lt;oldbranch&amp;gt; will be renamed to &amp;lt;newbranch&amp;gt;. If &amp;lt;oldbranch&amp;gt; had a corresponding reflog, it is renamed to match &amp;lt;newbranch&amp;gt;, and a reflog entry is created to remember the branch renaming. If &amp;lt;newbranch&amp;gt; exists, -M must be used to force the rename to happen.</source>
          <target state="translated">С опцией &lt;code&gt;-m&lt;/code&gt; или &lt;code&gt;-M&lt;/code&gt; &amp;lt;oldbranch&amp;gt; будет переименован в &amp;lt;newbranch&amp;gt;. Если &amp;lt;oldbranch&amp;gt; имел соответствующий журнал ссылок, он переименовывается в соответствии с &amp;lt;newbranch&amp;gt;, и создается запись журнала ссылок для запоминания переименования ветки. Если &amp;lt;newbranch&amp;gt; существует, необходимо использовать -M для принудительного переименования.</target>
        </trans-unit>
        <trans-unit id="078f9b93867e54fc6fd5cb6cccb717d173a4bdbb" translate="yes" xml:space="preserve">
          <source>With a small group, developers may just pull changes from each other&amp;rsquo;s repositories without the need for a central maintainer.</source>
          <target state="translated">В небольшой группе разработчики могут просто извлекать изменения из репозиториев друг друга без необходимости в центральном сопровождающем.</target>
        </trans-unit>
        <trans-unit id="d93af44627c4056a70413d4d1086a466c1eb6057" translate="yes" xml:space="preserve">
          <source>With an optional &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">С необязательным аргументом &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; используйте ссылку, чтобы найти заметки для отображения. Ссылка может указать полное имя ссылки, если она начинается с &lt;code&gt;refs/notes/&lt;/code&gt; ; когда он начинается с &lt;code&gt;notes/&lt;/code&gt; , &lt;code&gt;refs/&lt;/code&gt; и в противном случае &lt;code&gt;refs/notes/&lt;/code&gt; имеет префикс, чтобы сформировать полное имя ссылки.</target>
        </trans-unit>
        <trans-unit id="5888510f888416379a4d4b5651fc198f809cb1eb" translate="yes" xml:space="preserve">
          <source>With an optional argument, you can return to a different commit instead:</source>
          <target state="translated">С необязательным аргументом вы можете вернуться к другому коммиту:</target>
        </trans-unit>
        <trans-unit id="70761b9c0ed85e86f5fe4551851f4fb12dda8ef2" translate="yes" xml:space="preserve">
          <source>With centralized revision control systems this is often accomplished by including every module in one single repository. Developers can check out all modules or only the modules they need to work with. They can even modify files across several modules in a single commit while moving things around or updating APIs and translations.</source>
          <target state="translated">С централизованными системами контроля ревизий это часто достигается путем включения каждого модуля в одно хранилище.Разработчики могут проверить все модули или только те,с которыми им необходимо работать.Они даже могут изменять файлы в нескольких модулях за один коммит,перемещая их или обновляя API и переводы.</target>
        </trans-unit>
        <trans-unit id="34547cdab6bbebc8d70f8627cf92ce4ed49693c0" translate="yes" xml:space="preserve">
          <source>With no arguments, shows a list of existing remotes. Several subcommands are available to perform operations on the remotes.</source>
          <target state="translated">Без аргументов,показывает список существующих пультов.Для выполнения операций на пультах имеется несколько подкоманд.</target>
        </trans-unit>
        <trans-unit id="2d8eac222dcf5b2fb83219646b45ebbea55b5081" translate="yes" xml:space="preserve">
          <source>With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules.</source>
          <target state="translated">Без аргументов,показывает статус существующих субмодулей.Для выполнения операций над подмодулями доступно несколько подкоманд.</target>
        </trans-unit>
        <trans-unit id="2955e54fe9fa9b7446c513283cbd98f27b722daf" translate="yes" xml:space="preserve">
          <source>With no arguments, this will:</source>
          <target state="translated">Без всяких аргументов,это будет:</target>
        </trans-unit>
        <trans-unit id="07ab1293ff3b475c814f1fed59da838b442b2582" translate="yes" xml:space="preserve">
          <source>With no options and no COMMAND or GUIDE given, the synopsis of the &lt;code&gt;git&lt;/code&gt; command and a list of the most commonly used Git commands are printed on the standard output.</source>
          <target state="translated">Без параметров и без указания КОМАНДЫ или РУКОВОДСТВА синопсис команды &lt;code&gt;git&lt;/code&gt; и список наиболее часто используемых команд Git выводятся на стандартный вывод.</target>
        </trans-unit>
        <trans-unit id="5afd0acc1bfdb6a1daab0a26aea947b62407909e" translate="yes" xml:space="preserve">
          <source>With something like git.git current tree, I get:</source>
          <target state="translated">С чем-то вроде дерева Git.git current,я понял:</target>
        </trans-unit>
        <trans-unit id="48292de53da5a3060e12b426e889eefbf2d24e76" translate="yes" xml:space="preserve">
          <source>With that configuration the full path to browse repositories would be:</source>
          <target state="translated">При такой конфигурации будет полный путь к просмотру репозиториев:</target>
        </trans-unit>
        <trans-unit id="de963656527f9e7a6067d643ee4aa5bfca1b2d08" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--append&lt;/code&gt; option, include all commits that are present in the existing commit-graph file.</source>
          <target state="translated">С параметром &lt;code&gt;--append&lt;/code&gt; включите все коммиты, которые присутствуют в существующем файле графика фиксации.</target>
        </trans-unit>
        <trans-unit id="14495f11a1a9217fb75c7d6db611a80cccd6e859" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--branch&lt;/code&gt; option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state. The rule &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; implements may be stricter than what &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name). When run with &lt;code&gt;--branch&lt;/code&gt; option in a repository, the input is first expanded for the &amp;ldquo;previous checkout syntax&amp;rdquo; &lt;code&gt;@{-n}&lt;/code&gt;. For example, &lt;code&gt;@{-1}&lt;/code&gt; is a way to refer the last thing that was checked out using &quot;git switch&quot; or &quot;git checkout&quot; operation. This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the &amp;ldquo;previous checkout operation&amp;rdquo; might result in a commit object name when the N-th last thing checked out was not a branch.</source>
          <target state="translated">С параметром &lt;code&gt;--branch&lt;/code&gt; команда берет имя и проверяет, можно ли его использовать в качестве допустимого имени ветки (например, при создании новой ветки). Но будьте осторожны при использовании предыдущего синтаксиса извлечения, который может относиться к отключенному состоянию HEAD. Правило &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; реализует может быть строже, чем указано в &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; (например, в начале компонента ref может появиться тире, но это явно запрещено в начале имени ветки). При запуске с опцией &lt;code&gt;--branch&lt;/code&gt; в репозитории ввод сначала расширяется для &amp;laquo;синтаксиса предыдущей проверки&amp;raquo; &lt;code&gt;@{-n}&lt;/code&gt; . Например, &lt;code&gt;@{-1}&lt;/code&gt; это способ указать последнее, что было проверено с помощью операции &amp;laquo;git switch&amp;raquo; или &amp;laquo;git checkout&amp;raquo;. Эта опция должна использоваться фарфором, чтобы принять этот синтаксис везде, где ожидается имя ветки, чтобы они могли действовать так, как если бы вы ввели имя ветки. В качестве исключения обратите внимание, что &amp;laquo;предыдущая операция проверки&amp;raquo; может привести к получению имени объекта фиксации, если N-я последняя извлеченная вещь не была ветвью.</target>
        </trans-unit>
        <trans-unit id="f26f07033bd08bfdb6102afbc60e4bb690a51e35" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--reachable&lt;/code&gt; option, generate the new commit graph by walking commits starting at all refs. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--stdin-packs&lt;/code&gt;.)</source>
          <target state="translated">С параметром &lt;code&gt;--reachable&lt;/code&gt; сгенерируйте новый граф коммитов, пройдя коммиты, начиная со всех ссылок. (Нельзя сочетать с &lt;code&gt;--stdin-commits&lt;/code&gt; &lt;code&gt;--stdin-packs&lt;/code&gt; или --stdin-packs .)</target>
        </trans-unit>
        <trans-unit id="bced3fa737464959bcb0c4d4992aedaa6293d7b5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--shallow&lt;/code&gt; option, only check the tip commit-graph file in a chain of split commit-graphs.</source>
          <target state="translated">С параметром &lt;code&gt;--shallow&lt;/code&gt; проверяйте только файл графа фиксации подсказки в цепочке разделенных графов фиксации.</target>
        </trans-unit>
        <trans-unit id="023fb87ae200847a2eb976930adb7f7ff9a576bb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">С параметром &lt;code&gt;--split&lt;/code&gt; запишите график фиксации как цепочку из нескольких файлов графа фиксации, хранящихся в &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; . Новые коммиты, которых еще нет в графе коммитов, добавляются в новый файл &quot;подсказок&quot;. Этот файл объединяется с существующим файлом, если выполняются следующие условия объединения:</target>
        </trans-unit>
        <trans-unit id="0f402e69b2097f87a53ae26564ee053ba1f630ec" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">С параметром &lt;code&gt;--stdin-commits&lt;/code&gt; сгенерируйте новый граф коммитов, пройдя коммиты, начиная с коммитов, указанных в stdin в виде списка OID в шестнадцатеричном формате, по одному OID на строку. (Нельзя сочетать с &lt;code&gt;--stdin-packs&lt;/code&gt; или &lt;code&gt;--reachable&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="eaf73ef52d157ce1e4ddc4b827c0a6415ea79de1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-packs&lt;/code&gt; option, generate the new commit graph by walking objects only in the specified pack-indexes. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">С параметром &lt;code&gt;--stdin-packs&lt;/code&gt; сгенерируйте новый граф фиксации, перемещая объекты только в указанных индексах пакетов. (Нельзя сочетать с &lt;code&gt;--stdin-commits&lt;/code&gt; &lt;code&gt;--reachable&lt;/code&gt; или --reachable .)</target>
        </trans-unit>
        <trans-unit id="17857b1a19de2786ab177b98550f7755d5958169" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;subsystem&lt;/code&gt; reflog: after &lt;code&gt;git fetch&lt;/code&gt;, the old tip of &lt;code&gt;subsystem&lt;/code&gt; is at &lt;code&gt;subsystem@{1}&lt;/code&gt;. Subsequent fetches will increase the number. (See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.)</source>
          <target state="translated">С &lt;code&gt;subsystem&lt;/code&gt; reflog: после &lt;code&gt;git fetch&lt;/code&gt; старая подсказка &lt;code&gt;subsystem&lt;/code&gt; находится в &lt;code&gt;subsystem@{1}&lt;/code&gt; . Последующие выборки увеличат число. (См. &lt;a href=&quot;git-reflog&quot;&gt;Git-reflog [1]&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="b4f2100600cd65d2bb507aefd40b38b428ed31a7" translate="yes" xml:space="preserve">
          <source>With the example above that would give:</source>
          <target state="translated">На приведенном выше примере:</target>
        </trans-unit>
        <trans-unit id="a003c8ea87ae62c71ced8657b18db066ae621f53" translate="yes" xml:space="preserve">
          <source>With the exception of raw file data (which Git does not interpret) the fast-import input format is text (ASCII) based. This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used.</source>
          <target state="translated">За исключением исходных файловых данных (которые Git не интерпретирует),формат быстрого импорта-текстовый (ASCII).Этот текстовый формат упрощает разработку и отладку фронтендовых программ,особенно когда используется язык более высокого уровня,такой как Perl,Python или Ruby.</target>
        </trans-unit>
        <trans-unit id="832b24adba81a74f8f3c27d1a374c3c9abe6eae9" translate="yes" xml:space="preserve">
          <source>With the latter, you can use the manual viewer of your choice; see &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information.</source>
          <target state="translated">В последнем случае вы можете использовать любое средство просмотра вручную; см. &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="fd552b2cf02d64fea6c3a2fbecdcfeec69fa5199" translate="yes" xml:space="preserve">
          <source>With the right arguments, &lt;code&gt;git diff&lt;/code&gt; can also show us the difference between the working directory and the last commit, or between the index and the last commit:</source>
          <target state="translated">С правильными аргументами &lt;code&gt;git diff&lt;/code&gt; также может показать нам разницу между рабочим каталогом и последней фиксацией или между индексом и последней фиксацией:</target>
        </trans-unit>
        <trans-unit id="6936b3f47f8ae1f272ba09aecb9105ac3f327d8a" translate="yes" xml:space="preserve">
          <source>With the strategies that use 3-way merge (including the default, &lt;code&gt;recursive&lt;/code&gt;), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.</source>
          <target state="translated">В стратегиях, использующих 3-стороннее слияние (включая &lt;code&gt;recursive&lt;/code&gt; по умолчанию ), если изменение было сделано в обеих ветвях, но позже было отменено в одной из ветвей, это изменение будет присутствовать в результате слияния; некоторых людей это поведение сбивает с толку. Это происходит потому, что при выполнении слияния учитываются только заголовки и база слияния, а не отдельные коммиты. Следовательно, алгоритм слияния рассматривает отмененное изменение как полное отсутствие изменений и заменяет вместо этого измененную версию.</target>
        </trans-unit>
        <trans-unit id="993a54cdc4357f066aea765f4571bf68eff0acc7" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git cherry-pick&lt;/code&gt; will let you edit the commit message prior to committing.</source>
          <target state="translated">С этой опцией &lt;code&gt;git cherry-pick&lt;/code&gt; позволит вам редактировать сообщение фиксации перед фиксацией.</target>
        </trans-unit>
        <trans-unit id="333853f3b4bc551496449cd51ab3f625f2fd83b5" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git gc&lt;/code&gt; checks whether any housekeeping is required; if not, it exits without performing any work.</source>
          <target state="translated">С этой опцией &lt;code&gt;git gc&lt;/code&gt; проверяет, требуется ли какая-либо уборка; в противном случае он выходит без выполнения каких-либо действий.</target>
        </trans-unit>
        <trans-unit id="71e625d3b0cf2785820345a3c9b0fc38126ae685" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.</source>
          <target state="translated">С этой опцией &lt;code&gt;git revert&lt;/code&gt; позволит вам редактировать сообщение фиксации перед фиксацией возврата. Это значение по умолчанию, если вы запускаете команду из терминала.</target>
        </trans-unit>
        <trans-unit id="c4b763c3b176a1288a147104d8354f56c0e27e09" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will not start the commit message editor.</source>
          <target state="translated">С этой опцией &lt;code&gt;git revert&lt;/code&gt; не запустит редактор сообщений фиксации.</target>
        </trans-unit>
        <trans-unit id="8c4fe13a9c7d1e41585a8e2b5418a2b1ca5a28f1" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;merge-recursive&lt;/code&gt; spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--patience&lt;/code&gt;.</source>
          <target state="translated">С этой опцией &lt;code&gt;merge-recursive&lt;/code&gt; тратит немного больше времени, чтобы избежать ошибочных слияний, которые иногда возникают из-за несущественных совпадающих строк (например, фигурных скобок из разных функций). Используйте это, когда ветви, которые нужно объединить, сильно разошлись. См. Также &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--patience&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b7fa933690b4dfe40d9dc500f9cfa6ba3897c3d" translate="yes" xml:space="preserve">
          <source>With this option, diff output for a merge commit shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">С помощью этой опции вывод diff для фиксации слияния показывает различия от каждого родителя к результату слияния одновременно,вместо того,чтобы показывать пару различий между родителем и результатом по одному за раз.Более того,в нем перечислены только файлы,которые были изменены от всех родителей.</target>
        </trans-unit>
        <trans-unit id="3524864d6b6fccf88decb6caefb79eeb0a8e7c7e" translate="yes" xml:space="preserve">
          <source>With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data. Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced.</source>
          <target state="translated">С помощью этой опции git заменит все имена обновлений,пути,содержимое блоков,сообщения коммитов и тегов,имена и адреса электронной почты в выводе на анонимизированные данные.Два экземпляра одной и той же строки будут заменены эквивалентно (например,два коммита с одним и тем же автором будут иметь в выводе один и тот же анонимизированный автор,но не будут иметь сходства с исходной строкой автора).Сохраняется связь между коммитами,ветками и тегами,а также метки времени коммита (но сообщения и имена коммитов не имеют сходства с оригиналами).Сохраняется относительная структура дерева (например,если у вас есть корневое дерево с 10 файлами и 3 деревьями,то и вывод тоже),но их имена и содержимое файлов будут заменены.</target>
        </trans-unit>
        <trans-unit id="cbb1ff7744c2585e2c6b4c0275539aaae99818d7" translate="yes" xml:space="preserve">
          <source>With this option, parents that are hidden by grafts are packed nevertheless.</source>
          <target state="translated">С помощью этой опции родители,которые скрыты под прививками,тем не менее,упаковываются.</target>
        </trans-unit>
        <trans-unit id="64d24b372615e7424e92210d8b3079a3b6d54b46" translate="yes" xml:space="preserve">
          <source>With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line.</source>
          <target state="translated">С помощью этой опции команда включает текущую ветку в список оборотов,которые будут показаны,когда она не задана в командной строке.</target>
        </trans-unit>
        <trans-unit id="a7994938c4128018ec7f46d918cac8d359a1f2eb" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;git show-branch&lt;/code&gt; without extra parameters would show only the primary branches. In addition, if you happen to be on your topic branch, it is shown as well.</source>
          <target state="translated">При этом &lt;code&gt;git show-branch&lt;/code&gt; без дополнительных параметров будет отображать только основные ветки. Кроме того, если вы оказались в своей тематической ветке, она также отображается.</target>
        </trans-unit>
        <trans-unit id="7d389d82d11c207ddbcbb54d477d308b2e5d9f7f" translate="yes" xml:space="preserve">
          <source>With this, Alice can perform the first part of the &quot;pull&quot; operation alone using the &lt;code&gt;git fetch&lt;/code&gt; command without merging them with her own branch, using:</source>
          <target state="translated">При этом Алиса может выполнить первую часть операции &amp;laquo;вытягивания&amp;raquo; самостоятельно, используя команду &lt;code&gt;git fetch&lt;/code&gt; , не объединяя их со своей собственной веткой, используя:</target>
        </trans-unit>
        <trans-unit id="6062bf6506f2ab2b976dee38aa5322c59a129e2f" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, $GIT_DIR is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and $GIT_COMMON_DIR is set to point back to the main working tree&amp;rsquo;s $GIT_DIR (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">Внутри связанного рабочего дерева $ GIT_DIR настроен так, чтобы указывать на этот частный каталог (например, &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; в примере), а $ GIT_COMMON_DIR настроен так, чтобы указывать обратно на $ GIT_DIR основного рабочего дерева (например, &lt;code&gt;/path/main/.git&lt;/code&gt; ). Эти настройки выполняются в файле &lt;code&gt;.git&lt;/code&gt; , расположенном в верхнем каталоге связанного рабочего дерева.</target>
        </trans-unit>
        <trans-unit id="f531335c76344721aaf744205582ff3be68651bd" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--all&lt;/code&gt; and without any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;, the heads that exist both on the local side and on the remote side are updated.</source>
          <target state="translated">Без &lt;code&gt;--all&lt;/code&gt; и без &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; обновляются заголовки, существующие как на локальной, так и на удаленной стороне.</target>
        </trans-unit>
        <trans-unit id="af870a4c72e2ec7c668a803b1e745b16df6d1c9d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--follow-symlinks&lt;/code&gt;, these would print data about the symlink itself. In the case of &lt;code&gt;HEAD:link&lt;/code&gt;, you would see</source>
          <target state="translated">Без &lt;code&gt;--follow-symlinks&lt;/code&gt; они будут печатать данные о самой символической ссылке . В случае &lt;code&gt;HEAD:link&lt;/code&gt; вы увидите</target>
        </trans-unit>
        <trans-unit id="a213d6298e44415b29925050ee6ffa235637e828" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--force&lt;/code&gt;, the &amp;lt;src&amp;gt; ref is stored at the remote only if &amp;lt;dst&amp;gt; does not exist, or &amp;lt;dst&amp;gt; is a proper subset (i.e. an ancestor) of &amp;lt;src&amp;gt;. This check, known as &quot;fast-forward check&quot;, is performed in order to avoid accidentally overwriting the remote ref and lose other peoples' commits from there.</source>
          <target state="translated">Без &lt;code&gt;--force&lt;/code&gt; ссылка &amp;lt;src&amp;gt; сохраняется на удаленном компьютере только в том случае, если &amp;lt;dst&amp;gt; не существует или &amp;lt;dst&amp;gt; является правильным подмножеством (т. Е. Предком) &amp;lt;src&amp;gt;. Эта проверка, известная как &amp;laquo;ускоренная проверка вперед&amp;raquo;, выполняется, чтобы избежать случайной перезаписи удаленной ссылки и потери оттуда коммитов других людей.</target>
        </trans-unit>
        <trans-unit id="44aa5155d389a8a00fc9a9c0d5c5dc24c0b6b423" translate="yes" xml:space="preserve">
          <source>Without additional configuration, pushes the current branch to the configured upstream (&lt;code&gt;remote.origin.merge&lt;/code&gt; configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.</source>
          <target state="translated">Без дополнительной настройки &lt;code&gt;remote.origin.merge&lt;/code&gt; текущую ветвь в настроенный восходящий поток ( переменная конфигурации remote.origin.merge ), если она имеет то же имя, что и текущая ветвь, и выводит ошибку, не нажимая в противном случае.</target>
        </trans-unit>
        <trans-unit id="0d4981e0bf66e69e6f534946531426d82d26ec6d" translate="yes" xml:space="preserve">
          <source>Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.</source>
          <target state="translated">Без необязательного параметра path все файлы и подкаталоги текущей рабочей директории включаются в архив.Если указан один или несколько путей,то включаются только они.</target>
        </trans-unit>
        <trans-unit id="0aaf17e36c6d625d7976371bb21725d2cea205e0" translate="yes" xml:space="preserve">
          <source>Without any credential helpers defined, Git will try the following strategies to ask the user for usernames and passwords:</source>
          <target state="translated">Если не определены помощники авторизации,Git попробует следующие стратегии,чтобы запросить у пользователя имена пользователей и пароли:</target>
        </trans-unit>
        <trans-unit id="6f8c2669a27a9c22abf3f515b27b1a9a5be3b6dc" translate="yes" xml:space="preserve">
          <source>Without disambiguating &lt;code&gt;--&lt;/code&gt;, Git makes a reasonable guess, but errors out and asking you to disambiguate when ambiguous. E.g. if you have a file called HEAD in your work tree, &lt;code&gt;git diff HEAD&lt;/code&gt; is ambiguous, and you have to say either &lt;code&gt;git diff HEAD --&lt;/code&gt; or &lt;code&gt;git diff -- HEAD&lt;/code&gt; to disambiguate.</source>
          <target state="translated">Без устранения неоднозначности &lt;code&gt;--&lt;/code&gt; Git делает разумное предположение, но выдает ошибку и просит вас устранить неоднозначность, если она неоднозначна. Например, если у вас есть файл с именем HEAD в вашем рабочем дереве, &lt;code&gt;git diff HEAD&lt;/code&gt; неоднозначен, и вы должны сказать либо &lt;code&gt;git diff HEAD --&lt;/code&gt; либо &lt;code&gt;git diff -- HEAD&lt;/code&gt; чтобы устранить неоднозначность.</target>
        </trans-unit>
        <trans-unit id="636ef8b24660180a9f9d02cde9f707a809036029" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Без опции &lt;code&gt;-z&lt;/code&gt; пути с &amp;laquo;необычными&amp;raquo; символами заключаются в кавычки, как описано для переменной конфигурации &lt;code&gt;core.quotePath&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fbf6695514712c3a8e39b514953f35111f6c3ca8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Using &lt;code&gt;-z&lt;/code&gt; the filename is output verbatim and the line is terminated by a NUL byte.</source>
          <target state="translated">Без опции &lt;code&gt;-z&lt;/code&gt; пути с &amp;laquo;необычными&amp;raquo; символами заключаются в кавычки, как описано для переменной конфигурации &lt;code&gt;core.quotePath&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ). При использовании &lt;code&gt;-z&lt;/code&gt; имя файла выводится дословно, а строка заканчивается байтом NUL.</target>
        </trans-unit>
        <trans-unit id="94da29d7f90d6f6f16856adba693bd0f5ed5aeb9" translate="yes" xml:space="preserve">
          <source>Without the &lt;em&gt;--more=1&lt;/em&gt; option, &lt;em&gt;git show-branch&lt;/em&gt; would not output the &lt;em&gt;[master^]&lt;/em&gt; commit, as &lt;em&gt;[mybranch]&lt;/em&gt; commit is a common ancestor of both &lt;em&gt;master&lt;/em&gt; and &lt;em&gt;mybranch&lt;/em&gt; tips. Please see &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">Без &lt;em&gt;--Больше = 1&lt;/em&gt; вариант, &lt;em&gt;мерзавец шоу-отрасль&lt;/em&gt; не будет выводить &lt;em&gt;[мастер ^]&lt;/em&gt; совершить, так как &lt;em&gt;[mybranch]&lt;/em&gt; совершить является общим предком как &lt;em&gt;мастеров&lt;/em&gt; и &lt;em&gt;mybranch&lt;/em&gt; советов. Подробности см. В &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c29d8269d6df0a76bd7b7031ef1a5a35a844def8" translate="yes" xml:space="preserve">
          <source>Without this flag, &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that &quot;&amp;lt;path&amp;gt;&amp;hellip;​&quot; limits only commits, and doesn&amp;rsquo;t limit diff for those commits.</source>
          <target state="translated">Без этого флага &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; показывает коммиты, которые касаются указанных путей, и сравнивает примерно те же указанные пути. При этом отображается полная разница для коммитов, которые касаются указанных путей; это означает, что &amp;laquo;&amp;lt;path&amp;gt;&amp;hellip;&amp;raquo; ограничивает только коммиты и не ограничивает diff для этих коммитов.</target>
        </trans-unit>
        <trans-unit id="b86cf57585935f6e60cc9059e45208393d99c9a8" translate="yes" xml:space="preserve">
          <source>Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Без этой опции пути с &amp;laquo;необычными&amp;raquo; символами заключаются в кавычки, как описано для переменной конфигурации &lt;code&gt;core.quotePath&lt;/code&gt; (см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8450aafea5471fb336aa6711b707fb955fd65d91" translate="yes" xml:space="preserve">
          <source>Workflow for a third party library</source>
          <target state="translated">Рабочий процесс для сторонней библиотеки</target>
        </trans-unit>
        <trans-unit id="8dfb0e4b50fd82c5ff8bc5fed81147f5e4aadb05" translate="yes" xml:space="preserve">
          <source>Workflow for an artificially split repo</source>
          <target state="translated">Рабочий процесс для искусственно разделенного репо</target>
        </trans-unit>
        <trans-unit id="825ce9e97dc41179ec167b83be91179b5dacd316" translate="yes" xml:space="preserve">
          <source>Workflows</source>
          <target state="translated">Workflows</target>
        </trans-unit>
        <trans-unit id="72b02433b5041ac5ef6045242ff8d0e2784944a3" translate="yes" xml:space="preserve">
          <source>Working branch; defaults to HEAD.</source>
          <target state="translated">Рабочее отделение;по умолчанию-HEAD.</target>
        </trans-unit>
        <trans-unit id="a2b68acce45b31c1701e61880a9ac430bd217ef5" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file for the main working directory in multiple working directory setup (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;).</source>
          <target state="translated">Специальный файл конфигурации рабочего каталога для основного рабочего каталога при настройке нескольких рабочих каталогов (см. &lt;a href=&quot;git-worktree&quot;&gt;Git-worktree [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29f32a47a3074cae8d2558abdc45a4c7a3f4de27" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file.</source>
          <target state="translated">Конфигурационный файл для конкретной рабочей директории.</target>
        </trans-unit>
        <trans-unit id="b7010e71f35d363293e1c71cea9eb7b673f227d7" translate="yes" xml:space="preserve">
          <source>Working trees can be identified by path, either relative or absolute.</source>
          <target state="translated">Рабочие деревья могут быть идентифицированы по пути,относительному или абсолютному.</target>
        </trans-unit>
        <trans-unit id="e5850a4e043e763eb3c70b51337df764ed12f013" translate="yes" xml:space="preserve">
          <source>Working with others</source>
          <target state="translated">Работать с другими</target>
        </trans-unit>
        <trans-unit id="883363a342498bf776fadbacf0d9322246ddce5d" translate="yes" xml:space="preserve">
          <source>Working with others, shared repository style</source>
          <target state="translated">Работа с другими,общий стиль репозитория</target>
        </trans-unit>
        <trans-unit id="62159bf12f9108d11431e1d1114bdbbeecf78451" translate="yes" xml:space="preserve">
          <source>Works just like --signature except the signature is read from a file.</source>
          <target state="translated">Работает так же,как и --подпись,за исключением того,что подпись считывается из файла.</target>
        </trans-unit>
        <trans-unit id="097006f59137099e2d2ccff414198fea83903044" translate="yes" xml:space="preserve">
          <source>Works just like format.signature except the contents of the file specified by this variable will be used as the signature.</source>
          <target state="translated">В качестве сигнатуры будет использовано содержимое файла,указанного этой переменной.</target>
        </trans-unit>
        <trans-unit id="c45647582ec4fc92bdcd3ecd1a16e9638ca339a8" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt;, where &amp;lt;remote&amp;gt; is the current branch&amp;rsquo;s remote (or &lt;code&gt;origin&lt;/code&gt;, if no remote is configured for the current branch).</source>
          <target state="translated">Работает аналогично &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt; , где &amp;lt;remote&amp;gt; - это удаленный узел текущей ветки (или &lt;code&gt;origin&lt;/code&gt; , если для текущей ветки не настроен пульт).</target>
        </trans-unit>
        <trans-unit id="96f0b3b7db8530493b30466426fa80c5c21f66c1" translate="yes" xml:space="preserve">
          <source>Wrap code spawning child processes.</source>
          <target state="translated">Обертывание кода икрометание детских процессов.</target>
        </trans-unit>
        <trans-unit id="1f9c72af7bca7c9666626fcb471d6065e154c93d" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in an alternate object store.</source>
          <target state="translated">Запишите MIDX-файл для пакетных файлов в альтернативное объектное хранилище.</target>
        </trans-unit>
        <trans-unit id="36b48ab2e331354b7c3cc2f14ff9d8ea9d1001c3" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">Запишите MIDX-файл для пакетных файлов в текущей папке .git.</target>
        </trans-unit>
        <trans-unit id="b42a0c66496716fcd8c88f5906d20e5cf08f4975" translate="yes" xml:space="preserve">
          <source>Write a chapter on using plumbing and writing scripts.</source>
          <target state="translated">Напишите главу об использовании сантехники и написании сценариев.</target>
        </trans-unit>
        <trans-unit id="c8e128b9f546fd58c7e614d0f8b8821821084ae1" translate="yes" xml:space="preserve">
          <source>Write a commit-graph after fetching. This overrides the config setting &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt;.</source>
          <target state="translated">Напишите график фиксации после получения. Это отменяет настройку конфигурации &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e518a1279678087b263b8a6d5d4572c2e8b9dd3b" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles.</source>
          <target state="translated">Напишите графический файл коммита на основе коммитов,найденных в пакетных файлах.</target>
        </trans-unit>
        <trans-unit id="a8a7e9f2485bf10bd9980490fdf55b0594e99b5f" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all commits in the current commit-graph file along with those reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Напишите файл графика фиксации, содержащий все фиксации в текущем файле графика фиксации, а также те, которые доступны из &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c34e4cbacab76dc7a95f5e0f46081aab1f59603" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all reachable commits.</source>
          <target state="translated">Написать графический файл с коммитами,содержащий все доступные коммиты.</target>
        </trans-unit>
        <trans-unit id="e1238f6b25cc5d29bebfcc60e794e1647b6dd786" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file for the packed commits in your local &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">Напишите файл графика фиксации для упакованных коммитов в локальном каталоге &lt;code&gt;.git&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ba716e808cc8cf569e10d2453e1761bc59eae40" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file, extending the current commit-graph file using commits in &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Напишите файл графика фиксации, расширяя текущий файл графика фиксации, используя фиксации в &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73c3a355bd823c82bb9b3a929df0d2e920a5e648" translate="yes" xml:space="preserve">
          <source>Write a new MIDX file.</source>
          <target state="translated">Запишите новый MIDX-файл.</target>
        </trans-unit>
        <trans-unit id="b0d7b6d61dd4b6501290a029b72f9ed15f8cc305" translate="yes" xml:space="preserve">
          <source>Write a reachability bitmap index as part of the repack. This only makes sense when used with &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-A&lt;/code&gt;, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of &lt;code&gt;repack.writeBitmaps&lt;/code&gt;. This option has no effect if multiple packfiles are created.</source>
          <target state="translated">Напишите индекс растрового изображения достижимости как часть переупаковки. Это имеет смысл только при использовании с &lt;code&gt;-a&lt;/code&gt; или &lt;code&gt;-A&lt;/code&gt; , поскольку точечные рисунки должны иметь возможность ссылаться на все достижимые объекты. Эта опция отменяет установку &lt;code&gt;repack.writeBitmaps&lt;/code&gt; . Этот параметр не действует, если создано несколько файлов пакетов.</target>
        </trans-unit>
        <trans-unit id="0ec591cf31eda36450bc843a926c4fd529f9a0da" translate="yes" xml:space="preserve">
          <source>Write a set of patterns to the sparse-checkout file, as given as a list of arguments following the &lt;code&gt;set&lt;/code&gt; subcommand. Update the working directory to match the new patterns. Enable the core.sparseCheckout config setting if it is not already enabled.</source>
          <target state="translated">Запишите набор шаблонов в файл sparse-checkout в виде списка аргументов, следующих за подкомандой &lt;code&gt;set&lt;/code&gt; . Обновите рабочий каталог, чтобы он соответствовал новым шаблонам. Включите параметр конфигурации core.sparseCheckout, если он еще не включен.</target>
        </trans-unit>
        <trans-unit id="041470620f3506e6e154d55da89dd48b2bba6ec8" translate="yes" xml:space="preserve">
          <source>Write and verify Git commit-graph files</source>
          <target state="translated">Запись и проверка файлов коммит-графика Git'а.</target>
        </trans-unit>
        <trans-unit id="fbde21d9f61e2faa3e597fb0c951212436d2d05f" translate="yes" xml:space="preserve">
          <source>Write and verify multi-pack-indexes</source>
          <target state="translated">Пишите и проверяйте мульти-пакеты-индексы</target>
        </trans-unit>
        <trans-unit id="0874d3d36a3af067f281de19e268427b067828a4" translate="yes" xml:space="preserve">
          <source>Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type. If the object is a blob, the contents are written into the file, rather than its object name.</source>
          <target state="translated">Запишите висячие объекты в .git/lost-found/commit/или .git/lost-found/other/,в зависимости от типа.Если объект является блобом,то в файл записывается его содержимое,а не имя объекта.</target>
        </trans-unit>
        <trans-unit id="d9accbc71f1215e3614372f554930a021fe71b0a" translate="yes" xml:space="preserve">
          <source>Write into pairs of files (.pack and .idx), using &amp;lt;base-name&amp;gt; to determine the name of the created file. When this option is used, the two files in a pair are written in &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;.{pack,idx} files. &amp;lt;SHA-1&amp;gt; is a hash based on the pack content and is written to the standard output of the command.</source>
          <target state="translated">Запишите в пары файлов (.pack и .idx), используя &amp;lt;base-name&amp;gt; для определения имени созданного файла. Когда используется эта опция, два файла в паре записываются в файлы &amp;lt;base-name&amp;gt; - &amp;lt;SHA-1&amp;gt;. {Pack, idx}. &amp;lt;SHA-1&amp;gt; - это хэш, основанный на содержимом пакета, который записывается в стандартный вывод команды.</target>
        </trans-unit>
        <trans-unit id="7fe0c30065baa84a0511c3d3081d91c7d606dfea" translate="yes" xml:space="preserve">
          <source>Write or verify a multi-pack-index (MIDX) file.</source>
          <target state="translated">Запись или верификация мультипак-индексного (MIDX)файла.</target>
        </trans-unit>
        <trans-unit id="e39d29fa27aa3fd795b76126771a3ffa6c08d16a" translate="yes" xml:space="preserve">
          <source>Write responses to &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, and &lt;code&gt;ls&lt;/code&gt; queries to the file descriptor &amp;lt;fd&amp;gt; instead of &lt;code&gt;stdout&lt;/code&gt;. Allows &lt;code&gt;progress&lt;/code&gt; output intended for the end-user to be separated from other output.</source>
          <target state="translated">Записывать ответы на запросы &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; и &lt;code&gt;ls&lt;/code&gt; в файловый дескриптор &amp;lt;fd&amp;gt; вместо &lt;code&gt;stdout&lt;/code&gt; . Позволяет отделить вывод о &lt;code&gt;progress&lt;/code&gt; предназначенный для конечного пользователя, от другого вывода.</target>
        </trans-unit>
        <trans-unit id="e189db14fd9c8dacb74b437fa25a566d7b39760b" translate="yes" xml:space="preserve">
          <source>Write the archive to &amp;lt;file&amp;gt; instead of stdout.</source>
          <target state="translated">Записывайте архив в &amp;lt;файл&amp;gt; вместо стандартного вывода.</target>
        </trans-unit>
        <trans-unit id="7dc7fd5fc893589e612150dc5a94bc95c63f6644" translate="yes" xml:space="preserve">
          <source>Write the generated pack index into the specified file. Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack).</source>
          <target state="translated">Запишите сгенерированный индекс пакета в указанный файл.Без этой опции имя файла индекса пакета строится из имени упакованного архивного файла путем замены .pack на .idx (и программа дает сбой,если имя упакованного архива не заканчивается на .pack).</target>
        </trans-unit>
        <trans-unit id="7ee51e3bc5f984d1828334228be7ce34fc987d1e" translate="yes" xml:space="preserve">
          <source>Write the pack contents (what would have been written to .pack file) out to the standard output.</source>
          <target state="translated">Запишите содержимое пакета (то,что было бы записано в файл .pack)в стандартный выходной файл.</target>
        </trans-unit>
        <trans-unit id="f8fab17bc8f3e5385c26a96bd869170c9b748651" translate="yes" xml:space="preserve">
          <source>Write the resulting index out in the named on-disk format version. Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as &lt;code&gt;git add -N&lt;/code&gt;.</source>
          <target state="translated">Запишите получившийся индекс в названной версии формата на диске. Поддерживаются версии 2, 3 и 4. Текущая версия по умолчанию - 2 или 3, в зависимости от того, используются ли дополнительные функции, такие как &lt;code&gt;git add -N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efedecbf7e9a176a45aaee6d10ad017d653ffad6" translate="yes" xml:space="preserve">
          <source>Write to standard error. Note that if &lt;code&gt;--detach&lt;/code&gt; is specified, the process disconnects from the real standard error, making this destination effectively equivalent to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">Пишите в стандартную ошибку. Обратите внимание, что если &lt;code&gt;--detach&lt;/code&gt; , процесс отключается от реальной стандартной ошибки, что делает этот пункт назначения эквивалентным &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04570d31869f8fe0ff9437709cb2be3000b6efb7" translate="yes" xml:space="preserve">
          <source>Write to syslog, using the &lt;code&gt;git-daemon&lt;/code&gt; identifier.</source>
          <target state="translated">Запишите в системный журнал, используя идентификатор &lt;code&gt;git-daemon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b06c59a883065a2aa7a048f19cdd388e420a56a1" translate="yes" xml:space="preserve">
          <source>Write whatever message you want, and all the lines that start with &lt;code&gt;#&lt;/code&gt; will be pruned out, and the rest will be used as the commit message for the change. If you decide you don&amp;rsquo;t want to commit anything after all at this point (you can continue to edit things and update the index), you can just leave an empty message. Otherwise &lt;code&gt;git commit&lt;/code&gt; will commit the change for you.</source>
          <target state="translated">Напишите любое сообщение, которое хотите, и все строки, начинающиеся с символа &lt;code&gt;#&lt;/code&gt; , будут удалены, а остальные будут использоваться в качестве сообщения фиксации для изменения. Если вы решите, что не хотите ничего фиксировать на этом этапе (вы можете продолжать редактировать данные и обновлять индекс), вы можете просто оставить пустое сообщение. В противном случае &lt;code&gt;git commit&lt;/code&gt; зафиксирует изменение за вас.</target>
        </trans-unit>
        <trans-unit id="61b122f3a92e6ba319a161e3ee36a5061ca2ea4c" translate="yes" xml:space="preserve">
          <source>Writes a tree object that represents a subdirectory &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. This can be used to write the tree object for a subproject that is in the named subdirectory.</source>
          <target state="translated">Записывает объект дерева, представляющий подкаталог &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; . Это можно использовать для записи объекта дерева для подпроекта, который находится в названном подкаталоге.</target>
        </trans-unit>
        <trans-unit id="157114a94f76dd225b6968a998012309617b01fe" translate="yes" xml:space="preserve">
          <source>Writes the commit-id into the filename under $GIT_DIR/refs/&amp;lt;filename&amp;gt; on the local end after the transfer is complete.</source>
          <target state="translated">Записывает идентификатор фиксации в имя файла в $ GIT_DIR / refs / &amp;lt;filename&amp;gt; на локальном конце после завершения передачи.</target>
        </trans-unit>
        <trans-unit id="e02c77bcdadadb66d0f7703e015b6bcd89a6c5e3" translate="yes" xml:space="preserve">
          <source>X: &quot;unknown&quot; change type (most probably a bug, please report it)</source>
          <target state="translated">X:&quot;неизвестный&quot; тип изменения (скорее всего,ошибка,пожалуйста,сообщите об этом).</target>
        </trans-unit>
        <trans-unit id="c4701ab33311f5af4d25d032b9d36f7ee2d229e7" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;must&lt;/code&gt; therefore ensure that the most recent commit of the branch you want to dcommit to is the &lt;code&gt;first&lt;/code&gt; parent of the merge. Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch.</source>
          <target state="translated">Следовательно, вы &lt;code&gt;must&lt;/code&gt; убедиться, что самая последняя фиксация ветки, которую вы хотите зафиксировать, является &lt;code&gt;first&lt;/code&gt; родительским элементом слияния. В противном случае произойдет хаос, особенно если первый родительский коммит является более старым коммитом в той же ветке SVN.</target>
        </trans-unit>
        <trans-unit id="33b03e34a8212275c562b3fd47359312e9fb9f26" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">Вы также можете сказать &lt;code&gt;c&lt;/code&gt; или &lt;code&gt;clean&lt;/code&gt; выше, если выбор уникален.</target>
        </trans-unit>
        <trans-unit id="3633df0f340d7a5b00e10a65751fa4510ce91fa7" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;sta&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">Можно также сказать , &lt;code&gt;s&lt;/code&gt; или &lt;code&gt;sta&lt;/code&gt; или &lt;code&gt;status&lt;/code&gt; выше, пока выбор уникален.</target>
        </trans-unit>
        <trans-unit id="80dcbb43282a1e399b57f0acd29e7d516598c299" translate="yes" xml:space="preserve">
          <source>You also need to ensure that each repository is &quot;bare&quot; (without a Git index file) for &lt;code&gt;cvs commit&lt;/code&gt; to work. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Вам также необходимо убедиться, что каждый репозиторий является &amp;laquo;пустым&amp;raquo; (без индексного файла Git), чтобы &lt;code&gt;cvs commit&lt;/code&gt; работал. См. &lt;a href=&quot;gitcvs-migration&quot;&gt;Gitcvs-migration [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63d1d5a88c78a80cfc3950acb2e452ff58df3b69" translate="yes" xml:space="preserve">
          <source>You also should not rewind branches in a submodule beyond commits that were ever recorded in any superproject.</source>
          <target state="translated">Также не следует перематывать ветки в подмодуле за пределами коммитов,которые когда-либо были записаны в каком-либо суперпроекте.</target>
        </trans-unit>
        <trans-unit id="9cb8652293d991a8fc334c9f946fb5900f566815" translate="yes" xml:space="preserve">
          <source>You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run &lt;code&gt;git diff&lt;/code&gt;, because you plan to work on other files and changes with these files are distracting.</source>
          <target state="translated">Вы с удовольствием над чем-то работаете и обнаруживаете, что изменения в этих файлах в порядке. Вы не хотите видеть их при запуске &lt;code&gt;git diff&lt;/code&gt; , потому что вы планируете работать с другими файлами, а изменения в этих файлах отвлекают.</target>
        </trans-unit>
        <trans-unit id="48f9e78ec61620aadfc7c1e71bab372f08845a6f" translate="yes" xml:space="preserve">
          <source>You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don&amp;rsquo;t want to risk disturbing any of it. Instead, you create a temporary linked working tree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.</source>
          <target state="translated">Вы находитесь в середине сеанса рефакторинга, и ваш босс приходит и требует, чтобы вы немедленно что-то исправили. Обычно вы можете использовать &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; для временного хранения ваших изменений, однако ваше рабочее дерево находится в таком беспорядочном состоянии (с новыми, перемещенными и удаленными файлами и другими частями разбросаны вокруг), что вы не делаете Я не хочу рисковать, чтобы что-то нарушить. Вместо этого вы создаете временное связанное рабочее дерево, чтобы внести аварийное исправление, удалить его, когда закончите, а затем возобновить предыдущий сеанс рефакторинга.</target>
        </trans-unit>
        <trans-unit id="bb2df2ca18755cbd46a4ed871293669f22530506" translate="yes" xml:space="preserve">
          <source>You are now ready to commit. You can see what is about to be committed using &lt;code&gt;git diff&lt;/code&gt; with the --cached option:</source>
          <target state="translated">Теперь вы готовы к совершению. Вы можете увидеть, что будет совершено, используя &lt;code&gt;git diff&lt;/code&gt; с параметром --cached:</target>
        </trans-unit>
        <trans-unit id="074e56336e1be0630703b280d6a3b60899f28a4c" translate="yes" xml:space="preserve">
          <source>You can adjust how pages generated by gitweb look using the variables described below. You can change the site name, add common headers and footers for all pages, and add a description of this gitweb installation on its main page (which is the projects list page), etc.</source>
          <target state="translated">Вы можете настроить внешний вид страниц,генерируемых gitweb,используя переменные,описанные ниже.Вы можете изменить название сайта,добавить общие заголовки и колонтитулы для всех страниц,а также добавить описание этой gitweb-инсталляции на его главной странице (это страница со списком проектов)и т.д.</target>
        </trans-unit>
        <trans-unit id="f5130cbe18f25cdc12700266fadc1f554b9c37ce" translate="yes" xml:space="preserve">
          <source>You can also ask git log to show patches:</source>
          <target state="translated">Вы также можете попросить git-журнал показать патчи:</target>
        </trans-unit>
        <trans-unit id="f5378640dc8884e7695fa8d24ebc61aad94be600" translate="yes" xml:space="preserve">
          <source>You can also check out &lt;code&gt;origin/todo&lt;/code&gt; directly to examine it or write a one-off patch. See &lt;a href=&quot;#detached-head&quot;&gt;detached head&lt;/a&gt;.</source>
          <target state="translated">Вы также можете проверить &lt;code&gt;origin/todo&lt;/code&gt; напрямую, чтобы изучить его или написать одноразовый патч. Увидеть &lt;a href=&quot;#detached-head&quot;&gt;оторванную голову&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1dba829f7b6e6b2354184e851e59ecadab491f50" translate="yes" xml:space="preserve">
          <source>You can also edit a patch series with an interactive rebase. This is the same as &lt;a href=&quot;#reordering-patch-series&quot;&gt;reordering a patch series using &lt;code&gt;format-patch&lt;/code&gt;&lt;/a&gt;, so use whichever interface you like best.</source>
          <target state="translated">Вы также можете редактировать серию патчей с помощью интерактивной перебазировки. Это то же самое, что &lt;a href=&quot;#reordering-patch-series&quot;&gt;переупорядочить серию патчей с помощью &lt;code&gt;format-patch&lt;/code&gt; &lt;/a&gt; , поэтому используйте тот интерфейс, который вам больше нравится.</target>
        </trans-unit>
        <trans-unit id="a56f9e1e04034dbb228cdfc1e0cb38c07a8bcbf1" translate="yes" xml:space="preserve">
          <source>You can also fetch branches from other repositories; so</source>
          <target state="translated">Вы также можете получать ветки из других репозиториев;поэтому</target>
        </trans-unit>
        <trans-unit id="bb4e25e283a061b1bebe5a9dd36fbbd03f0e1b4b" translate="yes" xml:space="preserve">
          <source>You can also give &lt;code&gt;git log&lt;/code&gt; a &quot;range&quot; of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches &quot;stable&quot; and &quot;master&quot; diverged from a common commit some time ago, then</source>
          <target state="translated">Вы также можете &lt;code&gt;git log&lt;/code&gt; &amp;laquo;диапазон&amp;raquo; коммитов, первый из которых не обязательно является предком второго; например, если некоторое время назад концы веток &amp;laquo;стабильный&amp;raquo; и &amp;laquo;мастер&amp;raquo; расходились от общего коммита, то</target>
        </trans-unit>
        <trans-unit id="c219057e4d44e965fab9fe1f77892cd8f09c5753" translate="yes" xml:space="preserve">
          <source>You can also give commits names of your own; after running</source>
          <target state="translated">Вы также можете дать свои собственные имена коммитов;после запуска</target>
        </trans-unit>
        <trans-unit id="cecebc054603ae5ff87afcd3e6caec5420b5c866" translate="yes" xml:space="preserve">
          <source>You can also override locations of gitweb configuration files during runtime by setting the following environment variables: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; to a non-empty value.</source>
          <target state="translated">Вы также можете переопределить расположение файлов конфигурации gitweb во время выполнения, установив следующие переменные среды: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; и &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; на непустое значение.</target>
        </trans-unit>
        <trans-unit id="c335f539c67224e67ef9ba8bcb55a78f32c2ba64" translate="yes" xml:space="preserve">
          <source>You can also revert an earlier change, for example, the next-to-last:</source>
          <target state="translated">Вы также можете вернуть более раннее изменение,например,следующее за последним:</target>
        </trans-unit>
        <trans-unit id="f6f0f4e5da7f74f3d7e6aefa5597ca88126ce358" translate="yes" xml:space="preserve">
          <source>You can also run &lt;code&gt;git daemon&lt;/code&gt; as an inetd service; see the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; man page for details. (See especially the examples section.)</source>
          <target state="translated">Вы также можете запустить &lt;code&gt;git daemon&lt;/code&gt; как службу inetd; подробности смотрите на странице руководства &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; . (См. Особенно раздел примеров.)</target>
        </trans-unit>
        <trans-unit id="f0a51538febea0717277859dfbb5418b689055cc" translate="yes" xml:space="preserve">
          <source>You can also see what references it offers:</source>
          <target state="translated">Вы также можете посмотреть,какие ссылки он предлагает:</target>
        </trans-unit>
        <trans-unit id="f06fdd5b89ee465ae510128ba09f10dd8adf5eac" translate="yes" xml:space="preserve">
          <source>You can also skip a range of commits, instead of just one commit, using range notation. For example:</source>
          <target state="translated">Вы также можете пропустить ряд коммитов,вместо одного,используя нотацию диапазона.Например:</target>
        </trans-unit>
        <trans-unit id="54e517ee1d2086de2439776d35ac41cdff2f30f7" translate="yes" xml:space="preserve">
          <source>You can also track branches from repositories other than the one you cloned from, using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;:</source>
          <target state="translated">Вы также можете отслеживать ветки из репозиториев, отличных от того, из которого вы клонировали, используя &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="28b63a93050077dfe73e5bbbcd2b4df244cc4f26" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; to create commits, view changes in the index and the working tree files, and individually select diff hunks for inclusion in the index (by right-clicking on the diff hunk and choosing &quot;Stage Hunk For Commit&quot;).</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; для создания коммитов, просмотра изменений в индексе и файлах рабочего дерева, а также индивидуального выбора блоков различий для включения в индекс (щелкнув правой кнопкой мыши блок различий и выбрав &amp;laquo;Stage Hunk For Commit &quot;).</target>
        </trans-unit>
        <trans-unit id="2d89b19204028ed2768f0a7d6951c7af3234e547" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; для создания патчей для A, B и C, а идентификаторы для P, X, Y, Z добавляются в конце первого сообщения.</target>
        </trans-unit>
        <trans-unit id="2c144befb1f45c546071ce64e48b303dc0e810a7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git show&lt;/code&gt; to see any such file:</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;git show&lt;/code&gt; , чтобы увидеть любой такой файл:</target>
        </trans-unit>
        <trans-unit id="49c3eff4b4dfbb20ea17f1bea994d4ab08b8a178" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; instead of &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; if you don&amp;rsquo;t wish to keep commits with a single parent and that makes no change to the tree.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; вместо &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; если вы не хотите сохранять коммиты с единственным родителем и это не меняет дерево.</target>
        </trans-unit>
        <trans-unit id="015df615c0d1b650e7dd0d33e1d03af134ab36e3" translate="yes" xml:space="preserve">
          <source>You can always just jump back to your original &lt;code&gt;master&lt;/code&gt; branch by doing</source>
          <target state="translated">Вы всегда можете просто вернуться к исходной &lt;code&gt;master&lt;/code&gt; ветке, выполнив</target>
        </trans-unit>
        <trans-unit id="e3173f9b04378ce969d4435b57687de248be9e7d" translate="yes" xml:space="preserve">
          <source>You can always view an old version of a file by just checking out the correct revision first. But sometimes it is more convenient to be able to view an old version of a single file without checking anything out; this command does that:</source>
          <target state="translated">Вы всегда можете просмотреть старую версию файла,просто проверив сначала правильную ревизию.Но иногда удобнее иметь возможность просмотреть старую версию одного файла,ничего не извлекая;эта команда делает это:</target>
        </trans-unit>
        <trans-unit id="ac57e48df46d91546d0b6c2ab36f112078813032" translate="yes" xml:space="preserve">
          <source>You can at any time create a new branch by just picking an arbitrary point in the project history, and just writing the SHA-1 name of that object into a file under &lt;code&gt;.git/refs/heads/&lt;/code&gt;. You can use any filename you want (and indeed, subdirectories), but the convention is that the &quot;normal&quot; branch is called &lt;code&gt;master&lt;/code&gt;. That&amp;rsquo;s just a convention, though, and nothing enforces it.</source>
          <target state="translated">Вы можете в любой момент создать новую ветку, просто выбрав произвольную точку в истории проекта и просто записав имя SHA-1 этого объекта в файл в &lt;code&gt;.git/refs/heads/&lt;/code&gt; . Вы можете использовать любое имя файла (и действительно подкаталоги), но по соглашению &quot;нормальная&quot; ветвь называется &lt;code&gt;master&lt;/code&gt; . Однако это всего лишь условность, и ничто не заставляет ее соблюдать.</target>
        </trans-unit>
        <trans-unit id="28fdfbc805da6922683f26cc12f785c6a111b6ce" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;. The URL in this file will be used to access the repository. This file should have the following format:</source>
          <target state="translated">Вы можете &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; имя файла в $ GIT_DIR / branch . URL-адрес в этом файле будет использоваться для доступа к репозиторию. Этот файл должен иметь следующий формат:</target>
        </trans-unit>
        <trans-unit id="184c3e9bbc8e0af36908329654dfda91364d6a99" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:</source>
          <target state="translated">Вы можете &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; имя файла в $ GIT_DIR / remotes . URL-адрес в этом файле будет использоваться для доступа к репозиторию. Refspec в этом файле будет использоваться по умолчанию, если вы не укажете refspec в командной строке. Этот файл должен иметь следующий формат:</target>
        </trans-unit>
        <trans-unit id="a92f2a4a63c6c2d142357d1e5947af0b6de272f3" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a remote which you had previously configured using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or even by a manual edit to the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:</source>
          <target state="translated">Вы можете указать имя пульта дистанционного управления, которое вы ранее настроили с помощью &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; , &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; или даже вручную отредактировав файл &lt;code&gt;$GIT_DIR/config&lt;/code&gt; . URL-адрес этого пульта дистанционного управления будет использоваться для доступа к репозиторию. Refspec этого пульта дистанционного управления будет использоваться по умолчанию, если вы не укажете refspec в командной строке. Запись в конфигурационном файле будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d377d9322805f2d9d1e87d74e556de9916d572ec" translate="yes" xml:space="preserve">
          <source>You can choose whether you want to trust the index file entirely (using the &lt;code&gt;--cached&lt;/code&gt; flag) or ask the diff logic to show any files that don&amp;rsquo;t match the stat state as being &quot;tentatively changed&quot;. Both of these operations are very useful indeed.</source>
          <target state="translated">Вы можете выбрать, хотите ли вы полностью доверять индексному файлу (используя флаг &lt;code&gt;--cached&lt;/code&gt; ) или попросить логику сравнения отображать любые файлы, которые не соответствуют состоянию статистики, как &amp;laquo;предварительно измененные&amp;raquo;. Обе эти операции действительно очень полезны.</target>
        </trans-unit>
        <trans-unit id="7c0716128ee4fbd827cb316e0652131c44810ab6" translate="yes" xml:space="preserve">
          <source>You can configure gitweb to only list and allow viewing of the explicitly exported repositories, via &lt;code&gt;$export_ok&lt;/code&gt; variable in gitweb config file; see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; manpage. If it evaluates to true, gitweb shows repositories only if this file named by &lt;code&gt;$export_ok&lt;/code&gt; exists in its object database (if directory has the magic file named &lt;code&gt;$export_ok&lt;/code&gt;).</source>
          <target state="translated">Вы можете настроить gitweb так, чтобы он отображал только список и разрешал просмотр явно экспортированных репозиториев с помощью переменной &lt;code&gt;$export_ok&lt;/code&gt; export_ok в файле конфигурации gitweb; см. &lt;a href=&quot;gitweb.conf&quot;&gt;справочную страницу gitweb.conf [5]&lt;/a&gt; . Если он имеет значение true, gitweb показывает репозитории только в том случае, если этот файл с именем &lt;code&gt;$export_ok&lt;/code&gt; существует в его базе данных объектов (если в каталоге есть волшебный файл с именем &lt;code&gt;$export_ok&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="03a65df391294815ab470e62357c9e62de1fcfb2" translate="yes" xml:space="preserve">
          <source>You can configure individual repositories shown in gitweb by creating file in the &lt;code&gt;GIT_DIR&lt;/code&gt; of Git repository, or by setting some repo configuration variable (in &lt;code&gt;GIT_DIR/config&lt;/code&gt;, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Вы можете настроить отдельные репозитории, отображаемые в gitweb, создав файл в &lt;code&gt;GIT_DIR&lt;/code&gt; репозитория Git или установив некоторую переменную конфигурации репозитория (в &lt;code&gt;GIT_DIR/config&lt;/code&gt; , см. &lt;a href=&quot;git-config&quot;&gt;Git-config [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="45321feeff0945f0a2ba053e8ab969c82cc417c8" translate="yes" xml:space="preserve">
          <source>You can configure the database backend with the following configuration variables:</source>
          <target state="translated">Бэкэнд БД можно настроить с помощью следующих конфигурационных переменных:</target>
        </trans-unit>
        <trans-unit id="d268b7f609741cf4701b8230b6d95314deb17a7a" translate="yes" xml:space="preserve">
          <source>You can create a new commit that undoes whatever was done by the old commit. This is the correct thing if your mistake has already been made public.</source>
          <target state="translated">Вы можете создать новый коммит,который отменяет все,что было сделано старым коммитом.Это правильная вещь,если ваша ошибка уже была обнародована.</target>
        </trans-unit>
        <trans-unit id="d8a9d4babf707e6fca47541eba4fa0b4e8c8edd2" translate="yes" xml:space="preserve">
          <source>You can customize the rules that &lt;code&gt;git diff --word-diff&lt;/code&gt; uses to split words in a line, by specifying an appropriate regular expression in the &quot;diff.*.wordRegex&quot; configuration variable. For example, in TeX a backslash followed by a sequence of letters forms a command, but several such commands can be run together without intervening whitespace. To separate them, use a regular expression in your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">Вы можете настроить правила, которые &lt;code&gt;git diff --word-diff&lt;/code&gt; использует для разделения слов в строке, указав соответствующее регулярное выражение в переменной конфигурации &quot;diff. *. WordRegex&quot;. Например, в TeX обратная косая черта, за которой следует последовательность букв, образует команду, но несколько таких команд можно запускать вместе, не вставляя пробелов. Чтобы разделить их, используйте регулярное выражение в вашем &lt;code&gt;$GIT_DIR/config&lt;/code&gt; (или файле &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ), например:</target>
        </trans-unit>
        <trans-unit id="38bcfec4c9f80337cd439b12b7afb0a63bb0fcb7" translate="yes" xml:space="preserve">
          <source>You can declare that a filter turns a content that by itself is unusable into a usable content by setting the filter.&amp;lt;driver&amp;gt;.required configuration variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Вы можете объявить, что фильтр превращает контент, который сам по себе непригоден для использования, в полезный, установив для переменной конфигурации filter. &amp;lt;driver&amp;gt; .required значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7aeeb9d27bdf323aad4937a225d2c2d1d7d6f4b" translate="yes" xml:space="preserve">
          <source>You can easily create such a branch with Git using interactive rebase.</source>
          <target state="translated">Вы можете легко создать такую ветку с помощью Git'а,используя интерактивный rebase.</target>
        </trans-unit>
        <trans-unit id="2f7816df4cc860a9cfdb50146ff125e3acb46178" translate="yes" xml:space="preserve">
          <source>You can enforce finer grained permissions using update hooks. See &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Controlling access to branches using update hooks&lt;/a&gt;.</source>
          <target state="translated">Вы можете применить более детализированные разрешения с помощью обработчиков обновлений. См. Раздел &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Управление доступом к веткам с помощью обработчиков обновлений&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dca6628a0b53b9b002cd44ea35104ed275c53c21" translate="yes" xml:space="preserve">
          <source>You can examine one of those dangling commits with, for example,</source>
          <target state="translated">Например,вы можете изучить один из этих висячих коммитов,</target>
        </trans-unit>
        <trans-unit id="4807484ba96d5012055b128c8602211fd418a27a" translate="yes" xml:space="preserve">
          <source>You can examine such index state with &lt;code&gt;git ls-files --unmerged&lt;/code&gt; command. An example:</source>
          <target state="translated">Вы можете проверить такое состояние индекса с помощью команды &lt;code&gt;git ls-files --unmerged&lt;/code&gt; . Пример:</target>
        </trans-unit>
        <trans-unit id="b5f066a300ab7fb920ca504e5ef4559d46dabfb5" translate="yes" xml:space="preserve">
          <source>You can examine the data represented in the object database and the index with various helper tools. For every object, you can use &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; to examine details about the object:</source>
          <target state="translated">Вы можете изучить данные, представленные в базе данных объектов и индексе, с помощью различных вспомогательных инструментов. Для каждого объекта вы можете использовать &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1],&lt;/a&gt; чтобы изучить детали об объекте:</target>
        </trans-unit>
        <trans-unit id="fd093df539bb25e8d4c6b75d7c53e29317d7deb5" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;difftool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git difftool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">Вы можете явно &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; полный путь к инструменту, установив конфигурационную переменную difftool. &amp;lt;tool&amp;gt; .path . Например, вы можете настроить абсолютный путь к kdiff3, установив &lt;code&gt;difftool.kdiff3.path&lt;/code&gt; . В противном случае &lt;code&gt;git difftool&lt;/code&gt; предполагает, что инструмент доступен в PATH.</target>
        </trans-unit>
        <trans-unit id="146074b490cdd862abeb41d866c18f9aaa225cf8" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">Вы можете явно &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; полный путь к инструменту, установив переменную конфигурации mergetool. &amp;lt;tool&amp;gt; .path . Например, вы можете настроить абсолютный путь к kdiff3, установив &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt; . В противном случае &lt;code&gt;git mergetool&lt;/code&gt; предполагает, что инструмент доступен в PATH.</target>
        </trans-unit>
        <trans-unit id="1d73514fe413b4199a0b5fc2096f965b3e1620ee" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred man viewer by setting the configuration variable &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to konqueror by setting &lt;code&gt;man.konqueror.path&lt;/code&gt;. Otherwise, &lt;code&gt;git help&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">Вы можете явно &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt; полный путь к предпочитаемой вами программе просмотра man, установив конфигурационную переменную man. &amp;lt;tool&amp;gt; .path . Например, вы можете настроить абсолютный путь к konqueror, установив &lt;code&gt;man.konqueror.path&lt;/code&gt; . В противном случае &lt;code&gt;git help&lt;/code&gt; предполагает, что инструмент доступен в PATH.</target>
        </trans-unit>
        <trans-unit id="11d166169fafafa437c100a2b764012cf5981ced" translate="yes" xml:space="preserve">
          <source>You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don&amp;rsquo;t pass you can use &quot;git bisect&quot; (or better &quot;git bisect run&quot;). So you should perform roughly:</source>
          <target state="translated">Вы можете сосредоточить свои усилия на нескольких точках проверки (например, выпусках RC и бета-версии), что все тестовые примеры T проходят для всех N конфигураций. А когда некоторые тесты не проходят, вы можете использовать &amp;laquo;git bisect&amp;raquo; (или лучше &amp;laquo;git bisect run&amp;raquo;). Итак, вам следует примерно выполнить:</target>
        </trans-unit>
        <trans-unit id="59d0d873078b4f91b40c2ee1e2770f185d430915" translate="yes" xml:space="preserve">
          <source>You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">Вы можете дополнительно сократить количество испытаний, если знаете, какая часть дерева вовлечена в проблему, которую вы отслеживаете, указав параметры пути при выполнении команды &lt;code&gt;bisect start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e5857d2949fb11d516cd50de71765499d023b3f6" translate="yes" xml:space="preserve">
          <source>You can generate diffs between any two versions using &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;:</source>
          <target state="translated">Вы можете генерировать различия между любыми двумя версиями, используя &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="98e4a2c67e91124741c5ae666b50315da705ecdc" translate="yes" xml:space="preserve">
          <source>You can generate the projects list index file using the project_index action (the &lt;code&gt;TXT&lt;/code&gt; link on projects list page) directly from gitweb; see also &quot;Generating projects list using gitweb&quot; section below.</source>
          <target state="translated">Вы можете сгенерировать индексный файл списка проектов с помощью действия project_index ( ссылка &lt;code&gt;TXT&lt;/code&gt; на странице списка проектов) непосредственно из gitweb; см. также раздел &amp;laquo;Создание списка проектов с помощью gitweb&amp;raquo; ниже.</target>
        </trans-unit>
        <trans-unit id="5b042e446e3f9ebd4b31fc02aac55f5c329ead7e" translate="yes" xml:space="preserve">
          <source>You can get a list of all available encodings on your platform with the following command:</source>
          <target state="translated">Вы можете получить список всех доступных кодировок на вашей платформе с помощью следующей команды:</target>
        </trans-unit>
        <trans-unit id="3d921181a0df868b1892f0a3e234a9c29e516883" translate="yes" xml:space="preserve">
          <source>You can get just the old (respectively new) term with &lt;code&gt;git bisect terms
--term-old&lt;/code&gt; or &lt;code&gt;git bisect terms --term-good&lt;/code&gt;.</source>
          <target state="translated">Вы можете получить только старый (соответственно новый) термин с помощью &lt;code&gt;git bisect terms --term-old&lt;/code&gt; или &lt;code&gt;git bisect terms --term-good&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41b9643f0720517e2c1772471e0c09d5c46b9644" translate="yes" xml:space="preserve">
          <source>You can give the &lt;code&gt;-m&lt;/code&gt; flag to the command, which would try a three-way merge:</source>
          <target state="translated">Вы можете &lt;code&gt;-m&lt;/code&gt; флаг -m команде, которая попытается выполнить трехстороннее слияние:</target>
        </trans-unit>
        <trans-unit id="36617ae8104572554e1e13e9574934aea0623eb3" translate="yes" xml:space="preserve">
          <source>You can go back and modify the old commit. You should never do this if you have already made the history public; Git does not normally expect the &quot;history&quot; of a project to change, and cannot correctly perform repeated merges from a branch that has had its history changed.</source>
          <target state="translated">Вы можете вернуться и изменить старый коммит.Вам никогда не следует этого делать,если вы уже сделали историю публичной;обычно Git не ожидает,что &quot;история&quot; проекта изменится,и не может корректно выполнять повторные слияния из ветки,история которой изменилась.</target>
        </trans-unit>
        <trans-unit id="427cec7db1c8d9c41ec669de64df63aacc49a26f" translate="yes" xml:space="preserve">
          <source>You can grow a new branch from any commit. For example, switch to &quot;HEAD~3&quot; and create branch &quot;fixup&quot;:</source>
          <target state="translated">Ты можешь вырастить новый филиал из любого коммитета.Например,переключиться на &quot;HEAD~3&quot; и создать &quot;фикс&quot; ветки:</target>
        </trans-unit>
        <trans-unit id="8abddb96169bb94a7080d5c82ed5cac7b229954a" translate="yes" xml:space="preserve">
          <source>You can have a mixture of files show up as &quot;has been updated&quot; and &quot;is still dirty in the working directory&quot; together. You can always tell which file is in which state, since the &quot;has been updated&quot; ones show a valid sha1, and the &quot;not in sync with the index&quot; ones will always have the special all-zero sha1.</source>
          <target state="translated">Вы можете иметь смесь файлов,которые вместе отображаются как &quot;было обновлено&quot; и &quot;все еще грязно в рабочем каталоге&quot;.Вы всегда можете сказать,какой файл находится в каком состоянии,так как &quot;был обновлен&quot; показывает действительный sha1,а &quot;не синхронизирован с индексом&quot; всегда будет иметь специальный all-zero sha1.</target>
        </trans-unit>
        <trans-unit id="ae3f7bca446e950bd716349b25ee5d05aaee6a26" translate="yes" xml:space="preserve">
          <source>You can include a config file from another by setting the special &lt;code&gt;include.path&lt;/code&gt; (or &lt;code&gt;includeIf.*.path&lt;/code&gt;) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times.</source>
          <target state="translated">Вы можете включить файл конфигурации из другого файла, установив в специальной &lt;code&gt;include.path&lt;/code&gt; (или &lt;code&gt;includeIf.*.path&lt;/code&gt; ) имя включаемого файла. Переменная принимает в качестве значения путь и может быть расширена тильдой. Эти переменные можно указывать несколько раз.</target>
        </trans-unit>
        <trans-unit id="5145f6f36a43ec5e98537ca833d15e8282538fcf" translate="yes" xml:space="preserve">
          <source>You can include a config file from another conditionally by setting a &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; variable to the name of the file to be included.</source>
          <target state="translated">Вы можете условно включить файл конфигурации из другого файла, установив в переменной &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; имя включаемого файла.</target>
        </trans-unit>
        <trans-unit id="509dfc228243cbfccb732c55df31d8f926c42b85" translate="yes" xml:space="preserve">
          <source>You can include other configuration file using read_config_file() subroutine. For example, one might want to put gitweb configuration related to access control for viewing repositories via Gitolite (one of Git repository management tools) in a separate file, e.g. in &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt;. To include it, put</source>
          <target state="translated">Вы можете включить другой файл конфигурации, используя подпрограмму read_config_file (). Например, можно поместить конфигурацию gitweb, связанную с контролем доступа для просмотра репозиториев через Gitolite (один из инструментов управления репозиториями Git), в отдельный файл, например, в &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt; . Чтобы включить его, положите</target>
        </trans-unit>
        <trans-unit id="645452c6d997e8f480a9efb060142f580408b9f7" translate="yes" xml:space="preserve">
          <source>You can make a different change on the master branch:</source>
          <target state="translated">Вы можете сделать другое изменение на главной ветке:</target>
        </trans-unit>
        <trans-unit id="9d56811ee77d2943d64ee7741c452578a4d84979" translate="yes" xml:space="preserve">
          <source>You can make interesting things happen to a repository every time you push into it, by setting up &lt;code&gt;hooks&lt;/code&gt; there. See documentation for &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;.</source>
          <target state="translated">Вы можете делать что-то интересное с репозиторием каждый раз, когда в него заходите, установив там &lt;code&gt;hooks&lt;/code&gt; . См. Документацию для &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31caee42f233cd83de2778af5287eb406c23a1ef" translate="yes" xml:space="preserve">
          <source>You can make sure &lt;code&gt;git show-branch&lt;/code&gt; matches the state before those two &lt;code&gt;git merge&lt;/code&gt; you just did. Then, instead of running two &lt;code&gt;git merge&lt;/code&gt; commands in a row, you would merge these two branch heads (this is known as &lt;code&gt;making an Octopus&lt;/code&gt;):</source>
          <target state="translated">Вы можете убедиться, что &lt;code&gt;git show-branch&lt;/code&gt; соответствует состоянию до того, как вы только что сделали &lt;code&gt;git merge&lt;/code&gt; этих двух git . Затем вместо того, чтобы запускать две команды &lt;code&gt;git merge&lt;/code&gt; подряд, вы должны объединить эти две головки веток (это известно как &lt;code&gt;making an Octopus&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="9f748b043bbe97de82ec4f7b6a5308c58b703d36" translate="yes" xml:space="preserve">
          <source>You can make the server use the end-of-line conversion attributes to set the &lt;code&gt;-k&lt;/code&gt; modes for files by setting the &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config variable. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for more information about end-of-line conversion.</source>
          <target state="translated">Вы можете заставить сервер использовать атрибуты преобразования конца строки для установки режимов &lt;code&gt;-k&lt;/code&gt; для файлов, установив конфигурационную переменную &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; . См. &lt;a href=&quot;gitattributes&quot;&gt;Gitattributes [5]&lt;/a&gt; для получения дополнительной информации о преобразовании конца строки.</target>
        </trans-unit>
        <trans-unit id="015443f769a79760c1933372fa244563a6a25aba" translate="yes" xml:space="preserve">
          <source>You can omit having to type return here, by setting the configuration variable &lt;code&gt;interactive.singleKey&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Вы можете не вводить здесь return, установив для переменной конфигурации &lt;code&gt;interactive.singleKey&lt;/code&gt; значение &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="358c29af25eb707e9507c2c41ba2c41fddac22f4" translate="yes" xml:space="preserve">
          <source>You can override these rules either by command-line options or by environment variables. The &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--system&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; options will limit the file used to the global, system-wide or per-worktree file respectively. The &lt;code&gt;GIT_CONFIG&lt;/code&gt; environment variable has a similar effect, but you can specify any filename you want.</source>
          <target state="translated">Вы можете переопределить эти правила с помощью параметров командной строки или переменных среды. Параметры &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--system&lt;/code&gt; и &lt;code&gt;--worktree&lt;/code&gt; ограничивают используемый файл глобальным, общесистемным файлом или файлом для каждого рабочего дерева соответственно. &lt;code&gt;GIT_CONFIG&lt;/code&gt; переменной среды имеет такой же эффект, но вы можете указать любое имя файла , который вы хотите.</target>
        </trans-unit>
        <trans-unit id="b9256a8bfff0f4e1e2098927e9ff118ae66b3eab" translate="yes" xml:space="preserve">
          <source>You can perform &quot;git pull&quot;, resolve potential conflicts, and &quot;git push&quot; the result. A &quot;git pull&quot; will create a merge commit C between commits A and B.</source>
          <target state="translated">Вы можете выполнить &quot;git-тянуть&quot;,разрешить потенциальные конфликты и &quot;подтолкнуть&quot; результат.При &quot;проталкивании git'а&quot; создаётся коммит слияния C между коммитами A и B.</target>
        </trans-unit>
        <trans-unit id="189a9ed33e189223869b33620d09d0f720bf3fe1" translate="yes" xml:space="preserve">
          <source>You can provide options via the credential.helper configuration variable (this example drops the cache time to 5 minutes):</source>
          <target state="translated">Вы можете предоставить опции через конфигурационную переменную credential.helper (в этом примере время кэша снижается до 5 минут):</target>
        </trans-unit>
        <trans-unit id="82656460f1d1171626ca7a2547e75d0458741fd5" translate="yes" xml:space="preserve">
          <source>You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped.</source>
          <target state="translated">С помощью этой команды вы можете запросить/установить/заменить/отключить опции.Имя на самом деле является секцией и ключом,разделенным точкой,и значение будет экранировано.</target>
        </trans-unit>
        <trans-unit id="10e463ee2669848fa9bb9fc90b4474d38bbf73be" translate="yes" xml:space="preserve">
          <source>You can rejoin two diverging branches of development using &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;:</source>
          <target state="translated">Вы можете &lt;a href=&quot;git-merge&quot;&gt;объединить&lt;/a&gt; две расходящиеся ветви разработки с помощью git-merge [1] :</target>
        </trans-unit>
        <trans-unit id="3e4277417393477fbeb632e41395d74e0a0e4169" translate="yes" xml:space="preserve">
          <source>You can repack this private repository whenever you feel like.</source>
          <target state="translated">Вы можете переупаковать этот личный репозиторий,когда захотите.</target>
        </trans-unit>
        <trans-unit id="3425cb44f3c2a0393cb24a6806cf1648e47fe578" translate="yes" xml:space="preserve">
          <source>You can repeat steps 2-4 multiple times to break the original code into any number of commits.</source>
          <target state="translated">Вы можете повторить шаги 2-4 раза,чтобы разбить исходный код на любое количество коммитов.</target>
        </trans-unit>
        <trans-unit id="f016259f2ce9ae7193e573b7fa2135698ca39f54" translate="yes" xml:space="preserve">
          <source>You can rewrite the commit log messages using &lt;code&gt;--msg-filter&lt;/code&gt;. For example, &lt;code&gt;git svn-id&lt;/code&gt; strings in a repository created by &lt;code&gt;git svn&lt;/code&gt; can be removed this way:</source>
          <target state="translated">Вы можете переписать сообщения журнала фиксации, используя &lt;code&gt;--msg-filter&lt;/code&gt; . Например, строки &lt;code&gt;git svn-id&lt;/code&gt; в репозитории, созданном &lt;code&gt;git svn&lt;/code&gt; , можно удалить следующим образом:</target>
        </trans-unit>
        <trans-unit id="6928e91b0b4a87a6f0188b338ec935fa803e932d" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;git-bundle verify&lt;/code&gt; to see if you can extract from a bundle that was created with a basis:</source>
          <target state="translated">Вы можете запустить &lt;code&gt;git-bundle verify&lt;/code&gt; , чтобы узнать, можете ли вы извлечь из пакета, который был создан на основе:</target>
        </trans-unit>
        <trans-unit id="28f57e6715a38d45260ef8d226913fe9d5e46420" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;gitk --all&lt;/code&gt; again to see how the commit ancestry looks like, or run &lt;code&gt;show-branch&lt;/code&gt;, which tells you this.</source>
          <target state="translated">Вы можете снова запустить &lt;code&gt;gitk --all&lt;/code&gt; , чтобы увидеть, как выглядит предок фиксации, или запустить &lt;code&gt;show-branch&lt;/code&gt; , который сообщает вам об этом.</target>
        </trans-unit>
        <trans-unit id="ee22a2dcf21325c45ae74e5933824496ebc88dee" translate="yes" xml:space="preserve">
          <source>You can save space and make Git faster by moving these loose objects in to a &quot;pack file&quot;, which stores a group of objects in an efficient compressed format; the details of how pack files are formatted can be found in &lt;a href=&quot;pack-format&quot;&gt;pack format&lt;/a&gt;.</source>
          <target state="translated">Вы можете сэкономить место и ускорить Git, переместив эти незакрепленные объекты в &amp;laquo;файл упаковки&amp;raquo;, в котором группа объектов хранится в эффективном сжатом формате; подробности о том, как форматируются файлы пакетов, можно найти в &lt;a href=&quot;pack-format&quot;&gt;формате пакета&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="923ef556c5ea1d367a9ceb952e817561488d6f46" translate="yes" xml:space="preserve">
          <source>You can see easily that the above is a rename.</source>
          <target state="translated">Легко заметить,что вышеперечисленное-это переименование.</target>
        </trans-unit>
        <trans-unit id="5724c58e846fc905ad55d8bc9c332033225407c5" translate="yes" xml:space="preserve">
          <source>You can set this to &lt;code&gt;link&lt;/code&gt;, in which case a hardlink followed by a delete of the source are used to make sure that object creation will not overwrite existing objects.</source>
          <target state="translated">Вы можете установить это как &lt;code&gt;link&lt;/code&gt; , и в этом случае жесткая ссылка с последующим удалением источника используется, чтобы гарантировать, что создание объекта не будет перезаписывать существующие объекты.</target>
        </trans-unit>
        <trans-unit id="02df8661fe031a54ab42701feedaa37cd7c87875" translate="yes" xml:space="preserve">
          <source>You can setup one single value (single entry/item in this list) at build time by setting the &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; build-time configuration variable. By default it is set to (), i.e. an empty list. This means that gitweb would not try to create project URL (to fetch) from project name.</source>
          <target state="translated">Вы можете установить одно значение (отдельная запись / элемент в этом списке) во время сборки, установив переменную конфигурации &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; во время сборки. По умолчанию он установлен в (), т.е. пустой список. Это означает, что gitweb не будет пытаться создать URL-адрес проекта (для извлечения) из имени проекта.</target>
        </trans-unit>
        <trans-unit id="af5fba33ca90f8278cecf2701efca5c8b71085ca" translate="yes" xml:space="preserve">
          <source>You can specify a list of allowed directories. If no directories are given, all are allowed. This is an additional restriction, gitcvs access still needs to be enabled by the &lt;code&gt;gitcvs.enabled&lt;/code&gt; config option unless &lt;code&gt;--export-all&lt;/code&gt; was given, too.</source>
          <target state="translated">Вы можете указать список разрешенных каталогов. Если каталоги не указаны, разрешены все. Это дополнительное ограничение, доступ к gitcvs по-прежнему должен быть включен с помощью &lt;code&gt;gitcvs.enabled&lt;/code&gt; конфигурации &lt;code&gt;--export-all&lt;/code&gt; если также не был указан --export-all .</target>
        </trans-unit>
        <trans-unit id="a2f1a86c57fcd513fcca4d9c2bf5f81069f36bf3" translate="yes" xml:space="preserve">
          <source>You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add &quot;To:&quot; or &quot;Cc:&quot; headers, configure attachments, change the patch output directory, and sign off patches with configuration variables.</source>
          <target state="translated">Вы можете указать дополнительные строки почтового заголовка,которые будут добавляться к каждому сообщению,настройки по умолчанию для префикса темы и суффикса файла,номер патча при выводе более одного патча,добавить заголовки &quot;To:&quot; или &quot;Cc:&quot;,настроить вложения,изменить каталог вывода патча,а также подписать патчи с помощью конфигурационных переменных.</target>
        </trans-unit>
        <trans-unit id="c33dd2cd2261f81cbd0fc492df4e16b1e747c25d" translate="yes" xml:space="preserve">
          <source>You can specify the information shown for each object by using a custom &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is copied literally to stdout for each object, with placeholders of the form &lt;code&gt;%(atom)&lt;/code&gt; expanded, followed by a newline. The available atoms are:</source>
          <target state="translated">Вы можете указать информацию, отображаемую для каждого объекта, с помощью настраиваемого &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; . &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; копируется буквально на стандартный вывод для каждого объекта, с заполнителями вида &lt;code&gt;%(atom)&lt;/code&gt; расширенной, с последующим переводом строки. Доступные атомы:</target>
        </trans-unit>
        <trans-unit id="5a94d83b2aa4f52ca10b82e1786cdc28d9f55e56" translate="yes" xml:space="preserve">
          <source>You can tell Git to ignore certain files by creating a file called &lt;code&gt;.gitignore&lt;/code&gt; in the top level of your working directory, with contents such as:</source>
          <target state="translated">Вы можете указать Git игнорировать определенные файлы, создав файл с именем &lt;code&gt;.gitignore&lt;/code&gt; на верхнем уровне вашего рабочего каталога с таким содержимым, как:</target>
        </trans-unit>
        <trans-unit id="491f06c247008ffc2db5fcd9f930c35d5e25a466" translate="yes" xml:space="preserve">
          <source>You can tell Git to split the Git internal information from the directory that it tracks, but we&amp;rsquo;ll ignore that for now: it&amp;rsquo;s not how normal projects work, and it&amp;rsquo;s really only meant for special uses. So the mental model of &quot;the Git information is always tied directly to the working tree that it describes&quot; may not be technically 100% accurate, but it&amp;rsquo;s a good model for all normal use.</source>
          <target state="translated">Вы можете указать Git отделить внутреннюю информацию Git от каталога, который он отслеживает, но пока мы проигнорируем это: это не то, как работают обычные проекты, и на самом деле оно предназначено только для специального использования. Таким образом, ментальная модель &amp;laquo;информация Git всегда напрямую связана с рабочим деревом, которое она описывает&amp;raquo; может быть технически не точной на 100%, но это хорошая модель для любого обычного использования.</target>
        </trans-unit>
        <trans-unit id="eba2ddb51d288f0b3a9988b4f1ccbdcde132a1f4" translate="yes" xml:space="preserve">
          <source>You can test whether the filesystem supports that with the &lt;code&gt;--test-untracked-cache&lt;/code&gt; option. The &lt;code&gt;--untracked-cache&lt;/code&gt; option used to implicitly perform that test in older versions of Git, but that&amp;rsquo;s no longer the case.</source>
          <target state="translated">Вы можете проверить, поддерживает ли файловая система это с помощью параметра &lt;code&gt;--test-untracked-cache&lt;/code&gt; . Параметр &lt;code&gt;--untracked-cache&lt;/code&gt; использовался для неявного выполнения этого теста в старых версиях Git, но теперь это уже не так.</target>
        </trans-unit>
        <trans-unit id="33337304817f97abbb584fa2c7541a14abb9bfcd" translate="yes" xml:space="preserve">
          <source>You can then fix the conflicts during the rebase. Presumably you have not published your topic other than by mail, so rebasing it is not a problem.</source>
          <target state="translated">Тогда вы сможете исправить конфликты во время перезагрузки.Предположительно,вы не публиковали свою тему,кроме как по почте,поэтому ребейзинг не является проблемой.</target>
        </trans-unit>
        <trans-unit id="d6b74e3d43432e56c49f83bf0e8c1bc1b7ac50b8" translate="yes" xml:space="preserve">
          <source>You can then import these into your mail client and send them by hand. However, if you have a lot to send at once, you may prefer to use the &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; script to automate the process. Consult the mailing list for your project first to determine their requirements for submitting patches.</source>
          <target state="translated">Затем вы можете импортировать их в свой почтовый клиент и отправлять вручную. Однако, если вам нужно сразу много отправить, вы можете предпочесть сценарий &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; для автоматизации процесса. Сначала обратитесь к списку рассылки вашего проекта, чтобы определить их требования к отправке исправлений.</target>
        </trans-unit>
        <trans-unit id="ad2194dc994cc556c2451e6a9d4c256f90b5afd4" translate="yes" xml:space="preserve">
          <source>You can then transplant the old &lt;code&gt;subsystem..topic&lt;/code&gt; to the new tip by saying (for the reflog case, and assuming you are on &lt;code&gt;topic&lt;/code&gt; already):</source>
          <target state="translated">Затем вы можете перенести старую &lt;code&gt;subsystem..topic&lt;/code&gt; на новую подсказку, сказав (для случая рефлога и при условии, что вы уже в &lt;code&gt;topic&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="b5bb69809c9820257d5f27c5ec379a4130c453d8" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits given on the command line form a set of commits that are reachable from any of them, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">Вы можете думать об этом как об операции по установке. Коммиты, заданные в командной строке, образуют набор коммитов, которые достижимы из любого из них, а затем коммиты, достижимые из любых коммитов, указанных с &lt;code&gt;^&lt;/code&gt; впереди, вычитаются из этого набора. Остальные коммиты - это то, что отображается в выводе команды. Для дальнейшего ограничения результата можно использовать различные другие параметры и параметры путей.</target>
        </trans-unit>
        <trans-unit id="eacfd2b96f144de251fd3721b44d6ad9ca988b86" translate="yes" xml:space="preserve">
          <source>You can try running &lt;code&gt;find .git/objects -type f&lt;/code&gt; before and after you run &lt;code&gt;git prune-packed&lt;/code&gt; if you are curious. Also &lt;code&gt;git
count-objects&lt;/code&gt; would tell you how many unpacked objects are in your repository and how much space they are consuming.</source>
          <target state="translated">Вы можете попробовать запустить &lt;code&gt;find .git/objects -type f&lt;/code&gt; до и после запуска &lt;code&gt;git prune-packed&lt;/code&gt; если вам интересно. Также &lt;code&gt;git count-objects&lt;/code&gt; сообщит вам, сколько распакованных объектов находится в вашем репозитории и сколько места они занимают.</target>
        </trans-unit>
        <trans-unit id="78c0fba98badb6e25ce1949ee53cb8839b8be51a" translate="yes" xml:space="preserve">
          <source>You can update the shared repository with your changes by first committing your changes, and then using the &lt;code&gt;git push&lt;/code&gt; command:</source>
          <target state="translated">Вы можете обновить общий репозиторий своими изменениями, сначала зафиксировав свои изменения, а затем используя команду &lt;code&gt;git push&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="fe24364fca4da5268b93a1c7c864762589bec5d4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; to examine the contents of a blob; take, for example, the blob in the entry for &lt;code&gt;COPYING&lt;/code&gt; from the tree above:</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;git-show&quot;&gt;git-show [1],&lt;/a&gt; чтобы проверить содержимое большого двоичного объекта; возьмем, например, blob в записи для &lt;code&gt;COPYING&lt;/code&gt; из дерева выше:</target>
        </trans-unit>
        <trans-unit id="cdee252fbf6b663369bb36f7a81711483c778043" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;git stash push --keep-index&lt;/code&gt; , если хотите сделать две или более фиксации изменений в рабочем дереве, и вы хотите протестировать каждое изменение перед фиксацией:</target>
        </trans-unit>
        <trans-unit id="b954fc6ff3f193031cbeca4547760f3425491805" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash&lt;/code&gt; to simplify the above, like this:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;git stash&lt;/code&gt; , чтобы упростить приведенное выше, например:</target>
        </trans-unit>
        <trans-unit id="c482710749f3dcad6cbdc9701b2eb8b0d7f62e6a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;stable-1&lt;/code&gt; to refer to the commit 1b2e1d63ff.</source>
          <target state="translated">Вы можете использовать &lt;code&gt;stable-1&lt;/code&gt; для ссылки на фиксацию 1b2e1d63ff.</target>
        </trans-unit>
        <trans-unit id="783e49ef6897108ce62c504df5bb1071160ba897" translate="yes" xml:space="preserve">
          <source>You can use a basis based on time:</source>
          <target state="translated">Вы можете использовать основу,основанную на времени:</target>
        </trans-unit>
        <trans-unit id="0dcaab83279bcfe9c2e3dbaa6b4f0d035029ab31" translate="yes" xml:space="preserve">
          <source>You can use a tag that is present in both:</source>
          <target state="translated">Вы можете использовать метку,которая присутствует в обоих:</target>
        </trans-unit>
        <trans-unit id="0967772702daca79ec55cd9be52c70fe75848751" translate="yes" xml:space="preserve">
          <source>You can use different &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; values to control this behavior:</source>
          <target state="translated">Вы можете использовать разные значения &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; для управления этим поведением:</target>
        </trans-unit>
        <trans-unit id="72733e82f897a2af21fcfc3df3447e66ece75165" translate="yes" xml:space="preserve">
          <source>You can use it as a human-readable bundle replacement (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;), or as a format that can be edited before being fed to &lt;code&gt;git fast-import&lt;/code&gt; in order to do history rewrites (an ability relied on by tools like &lt;code&gt;git filter-repo&lt;/code&gt;).</source>
          <target state="translated">Вы можете использовать его как удобочитаемую замену пакета (см. &lt;a href=&quot;git-bundle&quot;&gt;Git-bundle [1]&lt;/a&gt; ) или как формат, который можно редактировать перед передачей в &lt;code&gt;git fast-import&lt;/code&gt; для перезаписи истории (возможность, зависящая от инструментов как &lt;code&gt;git filter-repo&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b34e82e0ff80209e7866272f371ddd1420b0f13" translate="yes" xml:space="preserve">
          <source>You can use mod_perl with gitweb. You must install Apache::Registry (for mod_perl 1.x) or ModPerl::Registry (for mod_perl 2.x) to enable this support.</source>
          <target state="translated">Вы можете использовать mod_perl с gitweb.Вы должны установить Apache::Registry (для mod_perl 1.x)или ModPerl::Registry (для mod_perl 2.x),чтобы включить эту поддержку.</target>
        </trans-unit>
        <trans-unit id="625924bfa2e6c050ea9730ca7a0edb6cfce2bfdc" translate="yes" xml:space="preserve">
          <source>You can use notes to add annotations with information that was not available at the time a commit was written.</source>
          <target state="translated">Вы можете использовать примечания для добавления аннотаций с информацией,которая была недоступна на момент написания коммита.</target>
        </trans-unit>
        <trans-unit id="0bbbcd5b5890880e82d452d584e7cf77013dabac" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@&lt;/code&gt; construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch &lt;code&gt;blabla&lt;/code&gt; then &lt;code&gt;@{1}&lt;/code&gt; means the same as &lt;code&gt;blabla@{1}&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать конструкцию &lt;code&gt;@&lt;/code&gt; с пустой частью ссылки, чтобы получить запись журнала ссылок текущей ветки. Например, если вы находитесь в ветке &lt;code&gt;blabla&lt;/code&gt; , тогда &lt;code&gt;@{1}&lt;/code&gt; означает то же, что и &lt;code&gt;blabla@{1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3a4b2dd2cada66b7023aa9fae3c933422c9fcc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit checked out using &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать синтаксис &lt;code&gt;@{-N}&lt;/code&gt; для ссылки на N-ю последнюю ветвь / фиксацию, извлеченную с помощью операции &amp;laquo;git checkout&amp;raquo;. Вы также можете указать &lt;code&gt;-&lt;/code&gt; что является синонимом &lt;code&gt;@{-1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e21f11f93a4b8bdb963de3cd700b58b5db33242a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit switched to using &quot;git switch&quot; or &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.</source>
          <target state="translated">Вы можете использовать синтаксис &lt;code&gt;@{-N}&lt;/code&gt; для ссылки на N-ю последнюю ветвь / фиксацию, переключенную на использование операции &amp;laquo;git switch&amp;raquo; или &amp;laquo;git checkout&amp;raquo;. Вы также можете указать &lt;code&gt;-&lt;/code&gt; что является синонимом &lt;code&gt;@{-1}&lt;/code&gt; . Это часто используется для быстрого переключения между двумя ветвями или для отмены переключения ветвей по ошибке.</target>
        </trans-unit>
        <trans-unit id="736fc09a09a7b16017fd49ac75e258e953294134" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;gitweb.owner&lt;/code&gt; repository configuration variable to set repository&amp;rsquo;s owner. It is displayed in the project list and summary page.</source>
          <target state="translated">Вы можете использовать переменную конфигурации репозитория &lt;code&gt;gitweb.owner&lt;/code&gt; , чтобы установить владельца репозитория. Он отображается в списке проектов и на странице сводки.</target>
        </trans-unit>
        <trans-unit id="b3762dc0cf78ebbd7cf935ac045ade59a2e3acbf" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;htpasswd&lt;/code&gt; facility that comes with Apache to make these files, but Apache&amp;rsquo;s MD5 crypt method differs from the one used by most C library&amp;rsquo;s crypt() function, so don&amp;rsquo;t use the -m option.</source>
          <target state="translated">Вы можете использовать средство &lt;code&gt;htpasswd&lt;/code&gt; , поставляемое с Apache, для создания этих файлов, но метод шифрования MD5 Apache отличается от метода, используемого большинством функций crypt () библиотеки C, поэтому не используйте параметр -m.</target>
        </trans-unit>
        <trans-unit id="80aa1363be3995d4ec384e59561a0e7a0903c070" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map&lt;/code&gt; convenience function in this filter, and other convenience functions, too. For example, calling &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; will leave out the current commit (but not its changes! If you want that, use &lt;code&gt;git rebase&lt;/code&gt; instead).</source>
          <target state="translated">Вы можете использовать функцию удобства &lt;code&gt;map&lt;/code&gt; в этом фильтре, а также другие функции удобства. Например, вызов &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; оставит текущий коммит (но не его изменения! Если вы этого хотите, используйте вместо этого &lt;code&gt;git rebase&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c32abff787b36e9c877031d224291d8c643f61f1" translate="yes" xml:space="preserve">
          <source>You can use the following files in repository:</source>
          <target state="translated">Вы можете использовать следующие файлы в репозитории:</target>
        </trans-unit>
        <trans-unit id="b6c6eac74692734c5ec1dc3c689d37b0eb0dcea6" translate="yes" xml:space="preserve">
          <source>You can use the number of commits:</source>
          <target state="translated">Вы можете использовать количество коммитов:</target>
        </trans-unit>
        <trans-unit id="4a928f707b340dd3df65a93fa7f9942c5a65d9b2" translate="yes" xml:space="preserve">
          <source>You can very easily automatically bisect broken builds using something like:</source>
          <target state="translated">Вы можете очень легко автоматически бисектировать сломанные сборки,используя что-то вроде:</target>
        </trans-unit>
        <trans-unit id="77487b0c89edd8fd842e99d65a1b39d2c6b378f5" translate="yes" xml:space="preserve">
          <source>You can work through the conflict with a number of tools:</source>
          <target state="translated">Вы можете проработать конфликт с помощью ряда инструментов:</target>
        </trans-unit>
        <trans-unit id="918d78d55a9c451b1a86101242b3194591c9e6cc" translate="yes" xml:space="preserve">
          <source>You can write the mandatory option parameter to an option as a separate word on the command line. That means that all the following uses work:</source>
          <target state="translated">Обязательный параметр опции можно записать в качестве отдельного слова в командной строке.Это означает,что все перечисленное ниже использует работу:</target>
        </trans-unit>
        <trans-unit id="d7f91f3a076bca347349424f4008dca0a1518c15" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials. See credential.h for details.</source>
          <target state="translated">Вы можете написать свои собственные помощники,чтобы взаимодействовать с любой системой,в которой у вас есть учетные данные.Подробности см.на сайте credential.h.</target>
        </trans-unit>
        <trans-unit id="c06b90a2f16de670e5df5d7464445ae0f28559f2" translate="yes" xml:space="preserve">
          <source>You could be using the &lt;code&gt;objects/info/alternates&lt;/code&gt; or &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; mechanisms to &lt;code&gt;borrow&lt;/code&gt; objects from other object stores. A repository with this kind of incomplete object store is not suitable to be published for use with dumb transports but otherwise is OK as long as &lt;code&gt;objects/info/alternates&lt;/code&gt; points at the object stores it borrows from.</source>
          <target state="translated">Вы можете использовать механизмы &lt;code&gt;objects/info/alternates&lt;/code&gt; или &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; для &lt;code&gt;borrow&lt;/code&gt; объектов из других хранилищ объектов. Репозиторий с таким неполным хранилищем объектов не подходит для публикации для использования с немыми транспортами, но в остальном все в порядке, пока &lt;code&gt;objects/info/alternates&lt;/code&gt; указывает в хранилищах объектов, из которых он заимствует.</target>
        </trans-unit>
        <trans-unit id="e2e5ecc00e320fd7f95c1d7def9e5cd07e7e5d74" translate="yes" xml:space="preserve">
          <source>You could do without using any branches at all, by keeping as many local repositories as you would like to have branches, and merging between them with &lt;em&gt;git pull&lt;/em&gt;, just like you merge between branches. The advantage of this approach is that it lets you keep a set of files for each &lt;code&gt;branch&lt;/code&gt; checked out and you may find it easier to switch back and forth if you juggle multiple lines of development simultaneously. Of course, you will pay the price of more disk usage to hold multiple working trees, but disk space is cheap these days.</source>
          <target state="translated">Вы можете вообще обойтись без использования каких-либо веток, сохранив столько локальных репозиториев, сколько вы хотели бы иметь веток, и слияние между ними с помощью &lt;em&gt;git pull&lt;/em&gt; , точно так же, как вы объединяете ветки. Преимущество этого подхода состоит в том, что он позволяет вам сохранять набор файлов для каждой &lt;code&gt;branch&lt;/code&gt; , и вам может быть проще переключаться туда и обратно, если вы одновременно манипулируете несколькими линиями разработки. Конечно, вы заплатите цену большего использования диска для хранения нескольких рабочих деревьев, но в наши дни дисковое пространство дешево.</target>
        </trans-unit>
        <trans-unit id="8ff03510fc9dfa2f41199478909f4845fc0f0bb6" translate="yes" xml:space="preserve">
          <source>You could have an incomplete but locally usable repository by creating a shallow clone. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">Вы можете получить неполный, но доступный локально репозиторий, создав неглубокий клон. См. &lt;a href=&quot;git-clone&quot;&gt;Git-clone [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f736fa76fc678c4f130db13f45faf6b48f41687a" translate="yes" xml:space="preserve">
          <source>You could just visually inspect the commits since e05db0fd:</source>
          <target state="translated">Вы можете просто визуально осмотреть коммиты с e05db0fd:</target>
        </trans-unit>
        <trans-unit id="0d78b2a8d8354041e789d882f2348db69275bdcd" translate="yes" xml:space="preserve">
          <source>You could omit &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, in which case the command degenerates to &quot;check out the current branch&quot;, which is a glorified no-op with rather expensive side-effects to show only the tracking information, if exists, for the current branch.</source>
          <target state="translated">Вы можете опустить &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; , и в этом случае команда вырождается в &amp;laquo;проверить текущую ветвь&amp;raquo;, что является прославленным запретом на выполнение операций с довольно дорогими побочными эффектами, чтобы показать только информацию отслеживания, если она существует, для текущей ветки.</target>
        </trans-unit>
        <trans-unit id="7c5b22847ee058ce78c26cbc63e773fbbc9499cd" translate="yes" xml:space="preserve">
          <source>You create a commit object by giving it the tree that describes the state at the time of the commit, and a list of parents:</source>
          <target state="translated">Вы создаёте объект коммита,предоставляя ему дерево,описывающее состояние на момент коммита,и список родителей:</target>
        </trans-unit>
        <trans-unit id="0fca09140e6ecd8df23b487785db8ea6f6692c80" translate="yes" xml:space="preserve">
          <source>You do not want any end-of-line conversions applied to, nor textual diffs produced for, any binary file you track. You would need to specify e.g.</source>
          <target state="translated">Вы не хотите,чтобы какие-либо преобразования в конце строки применялись к любому бинарному файлу,который вы отслеживаете,или чтобы для него не создавались текстовые различия.Вам нужно будет указать,например</target>
        </trans-unit>
        <trans-unit id="3b6ec2c54535f15330b4b3b431cf4481da43a55b" translate="yes" xml:space="preserve">
          <source>You do random edits, without running &lt;code&gt;git update-index&lt;/code&gt;. And then you notice that the tip of your &quot;upstream&quot; tree has advanced since you pulled from him:</source>
          <target state="translated">Вы вносите случайные изменения без запуска &lt;code&gt;git update-index&lt;/code&gt; . А затем вы замечаете, что верхушка вашего &amp;laquo;восходящего&amp;raquo; дерева продвинулась вперед с тех пор, как вы вытащили его:</target>
        </trans-unit>
        <trans-unit id="96b7f9c5e1f885ad6155a2dabe0351e9e08cd246" translate="yes" xml:space="preserve">
          <source>You do your real work in your working tree that has your primary repository hanging under it as its &lt;code&gt;.git&lt;/code&gt; subdirectory. You &lt;strong&gt;could&lt;/strong&gt; make that repository accessible remotely and ask people to pull from it, but in practice that is not the way things are usually done. A recommended way is to have a public repository, make it reachable by other people, and when the changes you made in your primary working tree are in good shape, update the public repository from it. This is often called &lt;code&gt;pushing&lt;/code&gt;.</source>
          <target state="translated">Вы делаете свою реальную работу в своем рабочем дереве, под которым находится ваш основной репозиторий в виде подкаталога &lt;code&gt;.git&lt;/code&gt; . Вы &lt;strong&gt;можете&lt;/strong&gt; сделать этот репозиторий доступным удаленно и попросить людей извлечь из него данные, но на практике это обычно не так. Рекомендуемый способ - создать общедоступный репозиторий, сделать его доступным для других людей, и когда изменения, внесенные вами в основное рабочее дерево, находятся в хорошей форме, обновить общедоступный репозиторий из него. Это часто называют &lt;code&gt;pushing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0911499c26fd93762ba87b20e89843bed2558fd8" translate="yes" xml:space="preserve">
          <source>You have made some commits, but realize they were premature to be in the &lt;code&gt;master&lt;/code&gt; branch. You want to continue polishing them in a topic branch, so create &lt;code&gt;topic/wip&lt;/code&gt; branch off of the current &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">Вы сделали несколько коммитов, но понимаете, что они преждевременны для включения в &lt;code&gt;master&lt;/code&gt; ветку. Вы хотите продолжить их полировку в ветке темы, поэтому создайте ветку &lt;code&gt;topic/wip&lt;/code&gt; от текущей &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9321ccbae87a4bc4f97065bb17cb67a1a81520be" translate="yes" xml:space="preserve">
          <source>You have now created your first Git repository. Of course, since it&amp;rsquo;s empty, that&amp;rsquo;s not very useful, so let&amp;rsquo;s start populating it with data.</source>
          <target state="translated">Вы создали свой первый репозиторий Git. Конечно, поскольку он пуст, это не очень полезно, поэтому давайте начнем заполнять его данными.</target>
        </trans-unit>
        <trans-unit id="d177c25ea329a8110bbd819e0cb66c6b6619b0d7" translate="yes" xml:space="preserve">
          <source>You have now successfully copied somebody else&amp;rsquo;s (mine) remote repository, and checked it out.</source>
          <target state="translated">Теперь вы успешно скопировали чужой (мой) удаленный репозиторий и проверили его.</target>
        </trans-unit>
        <trans-unit id="3cc6b09871d23a7d903d56d9d6eb61d9c29d1dd4" translate="yes" xml:space="preserve">
          <source>You have performed no merges into mywork, so it is just a simple linear sequence of patches on top of &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">Вы не выполнили никаких слияний с моей работой, так что это простая линейная последовательность патчей поверх &lt;code&gt;origin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8744f866557cd48a608818edcb46f21bfb3d75" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;git submodule update&lt;/code&gt; after &lt;code&gt;git pull&lt;/code&gt; if you want to update submodules, too.</source>
          <target state="translated">Вам нужно запустить &lt;code&gt;git submodule update&lt;/code&gt; после &lt;code&gt;git pull&lt;/code&gt; , если вы тоже хотите обновить подмодули.</target>
        </trans-unit>
        <trans-unit id="f82b6e7678c4aeade044d41684916154b148e08d" translate="yes" xml:space="preserve">
          <source>You haven&amp;rsquo;t specified any nodes as heads so it won&amp;rsquo;t be possible to differentiate between un-parented commits and root nodes.</source>
          <target state="translated">Вы не указали какие-либо узлы в качестве заголовков, поэтому будет невозможно отличить коммиты без родителей от корневых узлов.</target>
        </trans-unit>
        <trans-unit id="60617aeef2563268db523c5fdc5a619452e83d26" translate="yes" xml:space="preserve">
          <source>You may also add new content that does not exist in the patch; simply add new lines, each starting with &quot;+&quot;. The addition will appear reverted in the working tree.</source>
          <target state="translated">Вы также можете добавить новый контент,которого нет в патче;просто добавьте новые строки,каждая из которых начинается с &quot;+&quot;.Добавление появится в рабочем дереве.</target>
        </trans-unit>
        <trans-unit id="ef502914f7e8ab4571571ef4343614d654bb655c" translate="yes" xml:space="preserve">
          <source>You may also have third-party helpers installed; search for &lt;code&gt;credential-*&lt;/code&gt; in the output of &lt;code&gt;git help -a&lt;/code&gt;, and consult the documentation of individual helpers. Once you have selected a helper, you can tell Git to use it by putting its name into the credential.helper variable.</source>
          <target state="translated">У вас также могут быть установлены сторонние помощники; найдите &lt;code&gt;credential-*&lt;/code&gt; в выводе &lt;code&gt;git help -a&lt;/code&gt; и обратитесь к документации отдельных помощников. После того, как вы выбрали помощника, вы можете указать Git использовать его, указав его имя в переменной credential.helper.</target>
        </trans-unit>
        <trans-unit id="f2298abd2d14c4384844acf0edbfaf0baea1ecae" translate="yes" xml:space="preserve">
          <source>You may also include a &lt;code&gt;!&lt;/code&gt; in front of the ref name to negate the entry, explicitly exposing it, even if an earlier entry marked it as hidden. If you have multiple hideRefs values, later entries override earlier ones (and entries in more-specific config files override less-specific ones).</source>
          <target state="translated">Вы также можете включить &lt;code&gt;!&lt;/code&gt; перед именем ссылки, чтобы отрицать запись, явно раскрывая ее, даже если более ранняя запись пометила ее как скрытую. Если у вас есть несколько значений hideRefs, более поздние записи переопределяют более ранние (а записи в более конкретных файлах конфигурации переопределяют менее конкретные).</target>
        </trans-unit>
        <trans-unit id="ea31f49a09c0b721c12c5805f99a1757f98a096f" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;, which lets you merge the unmerged files using external tools such as Emacs or kdiff3.</source>
          <target state="translated">Вы также можете использовать &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt; , который позволяет объединять не объединенные файлы с помощью внешних инструментов, таких как Emacs или kdiff3.</target>
        </trans-unit>
        <trans-unit id="9adc4f69fd1939534db6a41ec486285df53ebd63" translate="yes" xml:space="preserve">
          <source>You may execute several commands by either using one instance of &lt;code&gt;--exec&lt;/code&gt; with several commands:</source>
          <target state="translated">Вы можете выполнить несколько команд, используя один экземпляр &lt;code&gt;--exec&lt;/code&gt; с несколькими командами:</target>
        </trans-unit>
        <trans-unit id="a70c5e0fed390964e6d887a35161883ab1754024" translate="yes" xml:space="preserve">
          <source>You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to &quot;revert the reversion&quot; (see the &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge How-To&lt;/a&gt; for details).</source>
          <target state="translated">Вы можете найти это полезным после отката слияния ветки темы, так как этот параметр воссоздает ветку темы со свежими коммитами, чтобы ее можно было успешно повторно объединить без необходимости &amp;laquo;отменить реверсию&amp;raquo; (см. &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;Инструкции revert-a-faulty-merge&lt;/a&gt; для подробности).</target>
        </trans-unit>
        <trans-unit id="08631c52a6efa8d7c45c6edcb816f877829615bc" translate="yes" xml:space="preserve">
          <source>You may force &lt;code&gt;git push&lt;/code&gt; to perform the update anyway by preceding the branch name with a plus sign:</source>
          <target state="translated">Вы можете заставить &lt;code&gt;git push&lt;/code&gt; выполнить обновление в любом случае, поставив перед именем ветки знак плюса:</target>
        </trans-unit>
        <trans-unit id="ae2bd0ef4c886d9dfce1ee8146a7755d847ffcc2" translate="yes" xml:space="preserve">
          <source>You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or &quot;revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in&quot;) applied to the revision being tested.</source>
          <target state="translated">Часто можно обнаружить,что во время бисектного сеанса к тестируемой ревизии применяются временные изменения (например,s/#define DEBUG 0/#define DEBUG 1/в заголовочном файле,или &quot;ревизии,в которой нет этой фиксации,этот патч должен применяться для работы над другой проблемой,в которой эта биссекция не заинтересована&quot;).</target>
        </trans-unit>
        <trans-unit id="014dba50ebab24a63a38baad57ed8364492c1d37" translate="yes" xml:space="preserve">
          <source>You may override individual configuration parameters when running any git command by using the &lt;code&gt;-c&lt;/code&gt; option. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Вы можете переопределить отдельные параметры конфигурации при запуске любой команды git, используя параметр &lt;code&gt;-c&lt;/code&gt; . Подробнее см. &lt;a href=&quot;git&quot;&gt;Git [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac5fdcda86efd0f875c444e1e9c4b64fbcccd8a8" translate="yes" xml:space="preserve">
          <source>You may specify configuration in your .git/config</source>
          <target state="translated">Вы можете указать конфигурацию в вашем .git/config</target>
        </trans-unit>
        <trans-unit id="13fb0fac683620e44c1d9b40bc74efe99d0db2f0" translate="yes" xml:space="preserve">
          <source>You may still choose to publish branches whose history is rewritten, and it may be useful for others to be able to fetch those branches in order to examine or test them, but they should not attempt to pull such branches into their own work.</source>
          <target state="translated">Вы все равно можете выбрать публикацию веток,история которых переписана,и другим может быть полезно получить эти ветки для проверки или тестирования,но они не должны пытаться втянуть такие ветки в свою собственную работу.</target>
        </trans-unit>
        <trans-unit id="2cb3e9e45a2fe07905a833e4999cf989715a0ad3" translate="yes" xml:space="preserve">
          <source>You might need to instead use: folder = &quot;[Google Mail]/Drafts&quot; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">Вам может потребоваться вместо этого использовать: folder = &quot;[Google Mail] / Drafts&quot;, если вы получите сообщение об ошибке &amp;laquo;Папка не существует&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ce52beb4e545845637d5d5a0a1bc64e60b253c82" translate="yes" xml:space="preserve">
          <source>You might want to build on one of these remote-tracking branches on a branch of your own, just as you would for a tag:</source>
          <target state="translated">Возможно,вы захотите построить на одной из этих удалённых отслеживаемых ветвей свою собственную ветку,точно так же,как и для тега:</target>
        </trans-unit>
        <trans-unit id="d0620c25fa90dc1aefb86ac91dfbd9e4eb8b29d0" translate="yes" xml:space="preserve">
          <source>You might want to recreate merge commits, e.g. if you have a history like this:</source>
          <target state="translated">Возможно,вы захотите воссоздать коммиты слияния,например,если у вас есть такая история:</target>
        </trans-unit>
        <trans-unit id="76dbf6258421c615799bec755123a1d09c6ae993" translate="yes" xml:space="preserve">
          <source>You need to push the new tag to a public Git server (see &quot;DISTRIBUTED WORKFLOWS&quot; below). This makes the tag available to others tracking your project. The push could also trigger a post-update hook to perform release-related items such as building release tarballs and preformatted documentation pages.</source>
          <target state="translated">Вам необходимо подтолкнуть новый тэг к публичному Git-серверу (см.ниже &quot;DISTRIBUTED WORKFLOWS&quot;).Это сделает тег доступным для других,отслеживающих ваш проект.Этот толчок может также вызвать пост-обновление для выполнения связанных с релизом элементов,таких как тарболы для сборки релиза и страницы с предварительно отформатированной документацией.</target>
        </trans-unit>
        <trans-unit id="23c2bb7cb1fc9b6f4a240d36b5b4f0b94079730d" translate="yes" xml:space="preserve">
          <source>You need to set the configuration variable &lt;code&gt;rerere.enabled&lt;/code&gt; in order to enable this command.</source>
          <target state="translated">Вам нужно установить переменную конфигурации &lt;code&gt;rerere.enabled&lt;/code&gt; , чтобы включить эту команду.</target>
        </trans-unit>
        <trans-unit id="beb1062efd31de3a255af22760556d9dc5fafa01" translate="yes" xml:space="preserve">
          <source>You normally only do signed tags for major releases or things like that, while the light-weight tags are useful for any marking you want to do &amp;mdash; any time you decide that you want to remember a certain point, just create a private tag for it, and you have a nice symbolic name for the state at that point.</source>
          <target state="translated">Обычно вы делаете подписанные теги только для основных выпусков или тому подобного, в то время как облегченные теги полезны для любой маркировки, которую вы хотите сделать - каждый раз, когда вы решаете, что хотите запомнить определенный момент, просто создайте для него частный тег , и у вас есть хорошее символическое имя для состояния в этот момент.</target>
        </trans-unit>
        <trans-unit id="0eafb62c845e9f30a39264ada6b686e1d1ebb7b8" translate="yes" xml:space="preserve">
          <source>You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, &lt;code&gt;git fetch&lt;/code&gt; allows you to configure &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">Вы часто взаимодействуете с одним и тем же удаленным репозиторием, регулярно и многократно выполняя выборку из него. Чтобы отслеживать прогресс такого удаленного репозитория, &lt;code&gt;git fetch&lt;/code&gt; позволяет вам настраивать переменные конфигурации &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b67cab4bffb98d3ad72ff6748f9f8b98887d9f3" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">Вероятно, вы не захотите вызывать эту команду напрямую; он предназначен для использования в качестве помощника по учетным данным другими частями Git. См. &lt;a href=&quot;gitcredentials&quot;&gt;Gitcredentials [7]&lt;/a&gt; или &lt;code&gt;EXAMPLES&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="467e6fc50e0615f651de6ffbcc6e0f17ecbae432" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">Вероятно, вы не захотите вызывать эту команду напрямую; он предназначен для использования в качестве помощника по учетным данным другими частями git. См. &lt;a href=&quot;gitcredentials&quot;&gt;Gitcredentials [7]&lt;/a&gt; или &lt;code&gt;EXAMPLES&lt;/code&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="c924d93ebd8e89f99e14509235b47dec1acfaa5d" translate="yes" xml:space="preserve">
          <source>You read a &quot;tree&quot; file from the object database, and use that to populate (and overwrite&amp;mdash;​don&amp;rsquo;t do this if your index contains any unsaved state that you might want to restore later!) your current index. Normal operation is just</source>
          <target state="translated">Вы читаете &amp;laquo;древовидный&amp;raquo; файл из объектной базы данных и используете его для заполнения (и перезаписи - не делайте этого, если ваш индекс содержит несохраненное состояние, которое вы, возможно, захотите восстановить позже!) Вашего текущего индекса. Нормальная работа просто</target>
        </trans-unit>
        <trans-unit id="e01bf60bb2a8e848b7516e87eb6405fb0e476f7b" translate="yes" xml:space="preserve">
          <source>You really filtered all refs: use &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; when calling git-filter-branch.</source>
          <target state="translated">Вы действительно отфильтровали все ссылки: используйте &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; при вызове git-filter-branch.</target>
        </trans-unit>
        <trans-unit id="0cb205f517a67a8e523ed9cfa8681dc8f8d7b0ce" translate="yes" xml:space="preserve">
          <source>You really removed all variants of a filename, if a blob was moved over its lifetime. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; can help you find renames.</source>
          <target state="translated">Вы действительно удалили все варианты имени файла, если большой двоичный объект был перемещен за время своего существования. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; может помочь вам найти переименования.</target>
        </trans-unit>
        <trans-unit id="a347f016fee70b8901448b2a81ecd1980ba100a9" translate="yes" xml:space="preserve">
          <source>You see, Git is actually the best tool to find out about the source of Git itself!</source>
          <target state="translated">Видите ли,на самом деле Git-лучший инструмент,позволяющий узнать об источнике самого Git'а!</target>
        </trans-unit>
        <trans-unit id="2f7c7430f5ab3ddee895946cce58e0edcbc9b3f3" translate="yes" xml:space="preserve">
          <source>You should &lt;strong&gt;never&lt;/strong&gt; do any work of your own on the branches that are created by &lt;code&gt;git cvsimport&lt;/code&gt;. By default initial import will create and populate a &quot;master&quot; branch from the CVS repository&amp;rsquo;s main branch which you&amp;rsquo;re free to work with; after that, you need to &lt;code&gt;git merge&lt;/code&gt; incremental imports, or any CVS branches, yourself. It is advisable to specify a named remote via -r to separate and protect the incoming branches.</source>
          <target state="translated">Вы &lt;strong&gt;никогда&lt;/strong&gt; не должны выполнять какую-либо собственную работу с ветками, созданными &lt;code&gt;git cvsimport&lt;/code&gt; . По умолчанию при первоначальном импорте создается и заполняется &amp;laquo;главная&amp;raquo; ветвь из основной ветки репозитория CVS, с которой вы можете свободно работать; после этого вам нужно самостоятельно выполнить &lt;code&gt;git merge&lt;/code&gt; инкрементный импорт или любые ветки CVS. Рекомендуется указать именованный удаленный сервер с помощью -r для разделения и защиты входящих ветвей.</target>
        </trans-unit>
        <trans-unit id="ac5b50c688e69b32b2a523ca6520323d9259e65e" translate="yes" xml:space="preserve">
          <source>You should consider using &lt;code&gt;dcommit&lt;/code&gt; instead of this command. Commit specified commit or tree objects to SVN. This relies on your imported fetch data being up to date. This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit. All merging is assumed to have taken place independently of &lt;code&gt;git svn&lt;/code&gt; functions.</source>
          <target state="translated">Вам следует подумать об использовании &lt;code&gt;dcommit&lt;/code&gt; вместо этой команды. Зафиксировать указанные объекты фиксации или дерева в SVN. Это зависит от актуальности импортированных данных выборки. Это не делает абсолютно никаких попыток исправления при фиксации в SVN, он просто перезаписывает файлы теми, которые указаны в дереве или фиксации. Предполагается, что все слияние происходило независимо от функций &lt;code&gt;git svn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0db0149a7a61b2b34d3de583889773851c606fb" translate="yes" xml:space="preserve">
          <source>You should now compile the checked-out version and test it. If that version works correctly, type</source>
          <target state="translated">Теперь вы должны скомпилировать проверенную версию и протестировать ее.Если эта версия работает корректно,введите</target>
        </trans-unit>
        <trans-unit id="4ce522d2b57e2c5b1484c387e3121e7cf3c762ef" translate="yes" xml:space="preserve">
          <source>You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.</source>
          <target state="translated">Вы должны воздержаться от злоупотребления этой опцией,чтобы тайком внести существенные изменения в фиксацию слияния.Приемлемы небольшие исправления,такие как удаление имени релиза/версии.</target>
        </trans-unit>
        <trans-unit id="de1993c72b3b1ad3dd18c76738408f9f041af6eb" translate="yes" xml:space="preserve">
          <source>You should understand the implications of rewriting history if you amend a commit that has already been published. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.)</source>
          <target state="translated">Вы должны понимать последствия перезаписи истории, если вы изменяете коммит, который уже был опубликован. (См. Раздел &amp;laquo;ВОССТАНОВЛЕНИЕ ИЗ UPSTREAM REBASE&amp;raquo; в &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="a5048e0c5c1221139fe969fc6db15713d2b83eb5" translate="yes" xml:space="preserve">
          <source>You should understand the implications of using &lt;code&gt;git rebase&lt;/code&gt; on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below.</source>
          <target state="translated">Вы должны понимать последствия использования &lt;code&gt;git rebase&lt;/code&gt; для общего репозитория. См. Также ВОССТАНОВЛЕНИЕ ИЗ UPSTREAM REBASE ниже.</target>
        </trans-unit>
        <trans-unit id="7550fee71eb33261ce4427a0e3743a34c95d7107" translate="yes" xml:space="preserve">
          <source>You should work through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; before reading this tutorial.</source>
          <target state="translated">Перед чтением этого руководства вы должны &lt;a href=&quot;gittutorial&quot;&gt;изучить gittutorial [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33b464d633d5d3d359d8c081bd1ef24a08ba23d1" translate="yes" xml:space="preserve">
          <source>You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it.</source>
          <target state="translated">Затем вы переносите пучок на другую машину для замены /home/me/tmp/file.bundle и вытаскиваете из него.</target>
        </trans-unit>
        <trans-unit id="98122f0a874f3f8b610fdbc33b228a3b5afee64a" translate="yes" xml:space="preserve">
          <source>You update your working directory from the index by &quot;checking out&quot; files. This is not a very common operation, since normally you&amp;rsquo;d just keep your files updated, and rather than write to your working directory, you&amp;rsquo;d tell the index files about the changes in your working directory (i.e. &lt;code&gt;git update-index&lt;/code&gt;).</source>
          <target state="translated">Вы обновляете свой рабочий каталог из индекса, &amp;laquo;извлекая&amp;raquo; файлы. Это не очень распространенная операция, поскольку обычно вы просто обновляете свои файлы и вместо того, чтобы писать в свой рабочий каталог, вы сообщаете индексным файлам об изменениях в вашем рабочем каталоге (например, &lt;code&gt;git update-index&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="57134770b9c7f61c90927970f67f3d2eceaa4a12" translate="yes" xml:space="preserve">
          <source>You will continue to do your day-to-day work in your personal repository, but periodically &quot;push&quot; changes from your personal repository into your public repository, allowing other developers to pull from that repository. So the flow of changes, in a situation where there is one other developer with a public repository, looks like this:</source>
          <target state="translated">Вы будете продолжать выполнять свою повседневную работу в вашем личном репозитории,но периодически &quot;проталкивать&quot; изменения из вашего личного репозитория в ваше публичное хранилище,позволяя другим разработчикам извлекать изменения из этого хранилища.Таким образом,поток изменений в ситуации,когда есть еще один разработчик с публичным репозиторием,выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="8876e4496883cded62698bb08d4c1d5f289e1dee" translate="yes" xml:space="preserve">
          <source>You will see both of these things throughout the code.</source>
          <target state="translated">Вы увидите обе эти вещи по всему кодексу.</target>
        </trans-unit>
        <trans-unit id="4dda56fbfc3230573e73ab526d0f70db698497a1" translate="yes" xml:space="preserve">
          <source>You will see informational messages on dangling objects. They are objects that still exist in the repository but are no longer referenced by any of your branches, and can (and will) be removed after a while with &lt;code&gt;gc&lt;/code&gt;. You can run &lt;code&gt;git fsck --no-dangling&lt;/code&gt; to suppress these messages, and still view real errors.</source>
          <target state="translated">Вы увидите информационные сообщения о висящих объектах. Это объекты, которые все еще существуют в репозитории, но на которые больше не ссылается ни одна из ваших веток, и могут (и будут) через некоторое время удалены с помощью &lt;code&gt;gc&lt;/code&gt; . Вы можете запустить &lt;code&gt;git fsck --no-dangling&lt;/code&gt; , чтобы подавить эти сообщения и по-прежнему просматривать реальные ошибки.</target>
        </trans-unit>
        <trans-unit id="f2fc4e070409aa778dc2444037511e0ef4801d3d" translate="yes" xml:space="preserve">
          <source>You will see two files, &lt;code&gt;pack-*.pack&lt;/code&gt; and &lt;code&gt;pack-*.idx&lt;/code&gt;, in &lt;code&gt;.git/objects/pack&lt;/code&gt; directory. They are closely related to each other, and if you ever copy them by hand to a different repository for whatever reason, you should make sure you copy them together. The former holds all the data from the objects in the pack, and the latter holds the index for random access.</source>
          <target state="translated">Вы увидите два файла, &lt;code&gt;pack-*.pack&lt;/code&gt; и &lt;code&gt;pack-*.idx&lt;/code&gt; , в каталоге &lt;code&gt;.git/objects/pack&lt;/code&gt; . Они тесно связаны друг с другом, и если вы когда-либо копируете их вручную в другой репозиторий по какой-либо причине, вам следует убедиться, что вы копируете их вместе. Первый содержит все данные от объектов в пакете, а второй содержит индекс для произвольного доступа.</target>
        </trans-unit>
        <trans-unit id="266addba668945d927bfdfb63b85369114140000" translate="yes" xml:space="preserve">
          <source>You will still have to tell people by other means, such as mail. (Git provides the &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to send preformatted pull requests to upstream maintainers to simplify this task.)</source>
          <target state="translated">Вам все равно придется сообщить людям другие средства, например, по почте. (Git предоставляет &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt; для отправки предварительно отформатированных запросов на вытягивание вышестоящим разработчикам, чтобы упростить эту задачу.)</target>
        </trans-unit>
        <trans-unit id="67a2c97a3fe15102ccbc39363d071f9caa744775" translate="yes" xml:space="preserve">
          <source>You would normally use &lt;code&gt;git merge-index&lt;/code&gt; with supplied &lt;code&gt;git merge-one-file&lt;/code&gt; to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge.</source>
          <target state="translated">Обычно вы используете &lt;code&gt;git merge-index&lt;/code&gt; с прилагаемым &lt;code&gt;git merge-one-file&lt;/code&gt; для выполнения этого последнего шага. Сценарий обновляет файлы в рабочем дереве по мере объединения каждого пути и в конце успешного объединения.</target>
        </trans-unit>
        <trans-unit id="acf5d70c570af359d1fc1b3db4b2e1cb44907ec4" translate="yes" xml:space="preserve">
          <source>You wouldn&amp;rsquo;t need to ever change it in gitweb config file.</source>
          <target state="translated">Вам не нужно когда-либо менять его в конфигурационном файле gitweb.</target>
        </trans-unit>
        <trans-unit id="065eff42d50778a1002dd0b7a890143f4063288e" translate="yes" xml:space="preserve">
          <source>You write your current index file to a &quot;tree&quot; object with the program</source>
          <target state="translated">Вы записываете свой текущий индексный файл в &quot;древовидный&quot; объект с программой</target>
        </trans-unit>
        <trans-unit id="49012e7b5c219e4c44033d7ce0ec88b78d68a780" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now initialized the working directory&amp;mdash;​you may notice a new directory created, named &quot;.git&quot;.</source>
          <target state="translated">Теперь вы инициализировали рабочий каталог - вы можете заметить, что создан новый каталог с именем &quot;.git&quot;.</target>
        </trans-unit>
        <trans-unit id="8e4b96aa3f69a0a980be2d48bd9eb2298bc44f3c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now made your first real Git commit. And if you&amp;rsquo;re interested in looking at what &lt;code&gt;git commit&lt;/code&gt; really does, feel free to investigate: it&amp;rsquo;s a few very simple shell scripts to generate the helpful (?) commit message headers, and a few one-liners that actually do the commit itself (&lt;code&gt;git commit&lt;/code&gt;).</source>
          <target state="translated">Теперь вы сделали свой первый настоящий коммит Git. И если вам интересно посмотреть, что на самом деле делает &lt;code&gt;git commit&lt;/code&gt; , не стесняйтесь исследовать: это несколько очень простых сценариев оболочки для генерации полезных (?) Заголовков сообщений фиксации и несколько однострочных сообщений, которые фактически выполняют саму фиксацию ( &lt;code&gt;git commit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6fd65e242e5023949f1979a313cb8892375303bf" translate="yes" xml:space="preserve">
          <source>Your &quot;public repository&quot; is now ready to accept your changes. Come back to the machine you have your private repository. From there, run this command:</source>
          <target state="translated">Ваш &quot;общедоступный репозиторий&quot; теперь готов принять ваши изменения.Возвращайтесь на машину,на которой у вас есть ваше личное хранилище.Оттуда запустите эту команду:</target>
        </trans-unit>
        <trans-unit id="77f5c1536424041eff5dddce9b9dc699480c5921" translate="yes" xml:space="preserve">
          <source>Your private repository&amp;rsquo;s Git directory is usually &lt;code&gt;.git&lt;/code&gt;, but your public repository is often named after the project name, i.e. &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt;. Let&amp;rsquo;s create such a public repository for project &lt;code&gt;my-git&lt;/code&gt;. After logging into the remote machine, create an empty directory:</source>
          <target state="translated">Каталог Git вашего личного репозитория обычно &lt;code&gt;.git&lt;/code&gt; , но ваш публичный репозиторий часто называют в честь имени проекта, то есть &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; . Создадим такой публичный репозиторий для проекта &lt;code&gt;my-git&lt;/code&gt; . После входа на удаленный компьютер создайте пустой каталог:</target>
        </trans-unit>
        <trans-unit id="b96e6decf426a8986abe42a514d0d538e2f36071" translate="yes" xml:space="preserve">
          <source>Your work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven&amp;rsquo;t, then does the right thing. So with the following sequence:</source>
          <target state="translated">Ваше дерево работ по-прежнему основано на вашем HEAD ($ JC), но с тех пор в него внесены некоторые изменения. Трехстороннее слияние гарантирует, что вы не добавляли или не изменяли записи индекса с $ JC, а если нет, то поступает правильно. Итак, в следующей последовательности:</target>
        </trans-unit>
        <trans-unit id="8ff2148494456dea5c056275d6718302d7ecd982" translate="yes" xml:space="preserve">
          <source>Zero or more &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands may be included to update the contents of the branch prior to creating the commit. These commands may be supplied in any order. However it is recommended that a &lt;code&gt;filedeleteall&lt;/code&gt; command precede all &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands in the same commit, as &lt;code&gt;filedeleteall&lt;/code&gt; wipes the branch clean (see below).</source>
          <target state="translated">Ноль или более &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; и &lt;code&gt;notemodify&lt;/code&gt; могут быть включены для обновления содержимого ветки до создания фиксации. Эти команды могут подаваться в любом порядке. Однако рекомендуется, &lt;code&gt;filedeleteall&lt;/code&gt; команда filedeleteall предшествовала всем &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; и &lt;code&gt;notemodify&lt;/code&gt; в одной фиксации, поскольку &lt;code&gt;filedeleteall&lt;/code&gt; очищает ветку (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="480b45cead8c71eaa647209c97491be4a36ea289" translate="yes" xml:space="preserve">
          <source>Zero or more protocol options may be entered after the last &lt;code&gt;push&lt;/code&gt; command, before the batch&amp;rsquo;s terminating blank line.</source>
          <target state="translated">После последней команды &lt;code&gt;push&lt;/code&gt; перед завершающей пустой строкой пакета можно ввести ноль или более параметров протокола .</target>
        </trans-unit>
        <trans-unit id="fbdec3db39874b3b5b75476184662777ddc44fd6" translate="yes" xml:space="preserve">
          <source>[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="b3a075bbccfeeb4bedba2aca4addb159d1acee3d" translate="yes" xml:space="preserve">
          <source>[&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;path&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="d31c8b5c3af548ff2d95f4e227ea28f0f9277441" translate="yes" xml:space="preserve">
          <source>[&amp;lt;refname&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;refname&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="e961d55ee5b355694495464c07c86f7fba23e9a9" translate="yes" xml:space="preserve">
          <source>[--] &amp;lt;path&amp;gt;&amp;hellip;​</source>
          <target state="translated">[-] &amp;lt;путь&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="1eb3d578c1f910d18345d8eb23a781efa2f8d23d" translate="yes" xml:space="preserve">
          <source>[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium work item for: Multi-Pack Index (MIDX)</source>
          <target state="translated">[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Рабочий элемент Chromium для: Multi-Pack Index (MIDX)</target>
        </trans-unit>
        <trans-unit id="25a96ba2d3b7a7d8ee2c18075362c090194ac1d0" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; An earlier RFC for the multi-pack-index feature</source>
          <target state="translated">[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; Более ранний RFC для функции multi-pack-index</target>
        </trans-unit>
        <trans-unit id="347fffb72e72a788a9461ff2e246ae61494e14d7" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 Contributor&amp;rsquo;s summit notes (includes discussion of MIDX)</source>
          <target state="translated">[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Заметки участников саммита Git Merge 2018 (включая обсуждение MIDX)</target>
        </trans-unit>
        <trans-unit id="feea73f842c5a1ec74b307b98128568bae22544a" translate="yes" xml:space="preserve">
          <source>[DEPRECATED: use &lt;code&gt;--rebase-merges&lt;/code&gt; instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved.</source>
          <target state="translated">[УСТАРЕЛО: вместо этого используйте &lt;code&gt;--rebase-merges&lt;/code&gt; ] Воссоздавать коммиты слияния вместо сглаживания истории путем воспроизведения коммитов, которые вводит коммит слияния. Разрешение конфликтов слияния или ручные поправки к коммитам слияния не сохраняются.</target>
        </trans-unit>
        <trans-unit id="a59f280e0e654176579fad979c6b2390d4560b5d" translate="yes" xml:space="preserve">
          <source>[EXPERIMENTAL] Set to &lt;code&gt;true&lt;/code&gt; to use the experimental built-in implementation of the interactive version of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; instead of the Perl script version. Is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">[ЭКСПЕРИМЕНТАЛЬНЫЙ] Установите значение &lt;code&gt;true&lt;/code&gt; , чтобы использовать экспериментальную встроенную реализацию интерактивной версии &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; вместо версии сценария Perl. Является ли &lt;code&gt;false&lt;/code&gt; по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f8205d704abeeab8758bae84f0f9eac80a6c4899" translate="yes" xml:space="preserve">
          <source>[NOTE] &lt;code&gt;git rerere&lt;/code&gt; relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, &lt;code&gt;git rerere&lt;/code&gt; may fail to record a conflict resolution. To work around this, the &lt;code&gt;conflict-marker-size&lt;/code&gt; setting in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; can be used.</source>
          <target state="translated">[ПРИМЕЧАНИЕ] &lt;code&gt;git rerere&lt;/code&gt; использует маркеры конфликта в файле для обнаружения конфликта. Если файл уже содержит строки, которые выглядят так же, как строки с маркерами конфликта, &lt;code&gt;git rerere&lt;/code&gt; может не записать разрешение конфликта. Чтобы обойти это, можно использовать настройку &lt;code&gt;conflict-marker-size&lt;/code&gt; в &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac4bc8630c3c03bfd813e3fe5057d1c466974ce5" translate="yes" xml:space="preserve">
          <source>[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;The Economic Impacts of Inadequate Infratructure for Software Testing&lt;/em&gt;. Nist Planning Report 02-3&lt;/a&gt;, see Executive Summary and Chapter 8.</source>
          <target state="translated">[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;Экономические последствия неадекватной инфраструктуры для тестирования программного обеспечения&lt;/em&gt; . Отчет о планировании Nist 02-3&lt;/a&gt; , см. Резюме и главу 8.</target>
        </trans-unit>
        <trans-unit id="e5f919a0494a6ccb56ff39496ebf8651f04232d2" translate="yes" xml:space="preserve">
          <source>[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Code Conventions for the Java Programming Language&lt;/em&gt;. Sun Microsystems.&lt;/a&gt;</source>
          <target state="translated">[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Соглашения о коде для языка программирования Java&lt;/em&gt; . Sun Microsystems.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de6da26d7d92c3d4bdee11d004d96506e88a1b00" translate="yes" xml:space="preserve">
          <source>[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Software maintenance&lt;/em&gt;. Wikipedia.&lt;/a&gt;</source>
          <target state="translated">[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Обслуживание программного обеспечения&lt;/em&gt; . Wikipedia.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a21dac2771422b1ce396ac7103119df3289ef40d" translate="yes" xml:space="preserve">
          <source>[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano. &lt;em&gt;Automated bisect success story&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Джунио Си Хамано. &lt;em&gt;Автоматическая история успеха пополам&lt;/em&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e39006ce98590e4632510795aafbc71a8d5177" translate="yes" xml:space="preserve">
          <source>[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Christian Couder. &lt;em&gt;Fully automated bisecting with &quot;git bisect run&quot;&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Кристиан Кудер. &lt;em&gt;Полностью автоматизированное деление пополам с помощью &quot;git bisect run&quot;&lt;/em&gt; . LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a12b60ab9e79fee2e4613d666532029fdb7e1f4d" translate="yes" xml:space="preserve">
          <source>[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection divides users and developers&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Джонатан Корбет. &lt;em&gt;Разделение пополам разделяет пользователей и разработчиков&lt;/em&gt; . LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb3a1d698c871451809a03759d2052ad730db3fa" translate="yes" xml:space="preserve">
          <source>[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar. &lt;em&gt;Re: BUG 2.6.23-rc3 can&amp;rsquo;t see sd partitions on Alpha&lt;/em&gt;. Linux-kernel mailing list.&lt;/a&gt;</source>
          <target state="translated">[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Инго Мольнар. &lt;em&gt;Re: ОШИБКА 2.6.23-rc3 не может видеть разделы sd на Alpha&lt;/em&gt; . Список рассылки ядра Linux.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91adb50bf54c20a1b51a7a5bd4f97f72154e309d" translate="yes" xml:space="preserve">
          <source>[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano and the git-list. &lt;em&gt;git-bisect(1) Manual Page&lt;/em&gt;. Linux Kernel Archives.&lt;/a&gt;</source>
          <target state="translated">[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Джунио Си Хамано и git-list. &lt;em&gt;git-bisect (1) Страница руководства&lt;/em&gt; . Архивы ядра Linux.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e3bcbb19b635de003c473322577e0da443bd26" translate="yes" xml:space="preserve">
          <source>[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf. &lt;em&gt;bbchop&lt;/em&gt;. GitHub.&lt;/a&gt;</source>
          <target state="translated">[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Элдвульф. &lt;em&gt;bbchop&lt;/em&gt; . GitHub.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4720dfbb1b4c30f403e79c3ea73865f0f4c5faef" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:/~[user]/path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:/~[user]/path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="5995beae7c11faa4cc7064555dea6942a8fa3779" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="8bc9eff643c5f26b1d25ab8fdf5a5ddc87d11ead" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.</source>
          <target state="translated">\ 0 завершение строки при выводе и не заключайте имена файлов в кавычки. Для получения дополнительной информации см. ФОРМАТ ВЫВОДА ниже.</target>
        </trans-unit>
        <trans-unit id="d0b23d6e6728ae49ec5909ad48b79671e7245999" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT below for more information.</source>
          <target state="translated">\ 0 завершение строки при выводе и не заключайте имена файлов в кавычки. См. ВЫХОД ниже для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="ec441d8e621550cb4deb96e2b1ad67311ed0768f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; directory that is a &lt;code&gt;bare&lt;/code&gt; repository (i.e. without its own working tree), that is typically used for exchanging histories with others by pushing into it and fetching from it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; каталог , который является &lt;code&gt;bare&lt;/code&gt; хранилищем (т.е. без его собственного рабочего дерева), который обычно используется для обмена историй с другими, нажав на него , и извлечение из него.</target>
        </trans-unit>
        <trans-unit id="ea844fb65222d001b2e2f561d577c3d6a932db4a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;.git&lt;/code&gt; directory at the root of the working tree;</source>
          <target state="translated">&lt;code&gt;.git&lt;/code&gt; каталог в корне рабочего дерева;</target>
        </trans-unit>
        <trans-unit id="f0d4bf33608fee8383e25a39f62fec37be3db742" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;lot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc234069c4e3ee03ef8f7670cb491ed5411b65b6" translate="yes" xml:space="preserve">
          <source>a NUL (only exists if renamed/copied);</source>
          <target state="translated">NUL (существует только в случае переименования/копирования);</target>
        </trans-unit>
        <trans-unit id="079f5a842faae1ecf0933e998354e66093295bb8" translate="yes" xml:space="preserve">
          <source>a NUL.</source>
          <target state="translated">NUL.</target>
        </trans-unit>
        <trans-unit id="e9278592288a5c5c028d9d1d04c2201af670c4f7" translate="yes" xml:space="preserve">
          <source>a URL like &quot;git://example.org/path/to/repo.git&quot; will be rewritten to &quot;ssh://example.org/path/to/repo.git&quot; for pushes, but pulls will still use the original URL.</source>
          <target state="translated">URL типа &quot;git://example.org/path/to/repo.git&quot; будет переписан на &quot;ssh://example.org/path/to/repo.git&quot; для pushhes,но pulls все равно будет использовать оригинальный URL.</target>
        </trans-unit>
        <trans-unit id="96a7d2b2a7356a40bc207f3d1e0038c9f743ef8f" translate="yes" xml:space="preserve">
          <source>a URL like &quot;work:repo.git&quot; or like &quot;host.xz:/path/to/repo.git&quot; will be rewritten in any context that takes a URL to be &quot;git://git.host.xz/repo.git&quot;.</source>
          <target state="translated">URL типа &quot;work:repo.git&quot; или типа &quot;host.xz:/path/to/repo.git&quot; будет переписан в любом контексте,который принимает URL как &quot;git://git.host.xz/repo.git&quot;.</target>
        </trans-unit>
        <trans-unit id="da90a472a42edab28f6103dd507b377a59e39919" translate="yes" xml:space="preserve">
          <source>a colon.</source>
          <target state="translated">двоеточие.</target>
        </trans-unit>
        <trans-unit id="07112c294a121f7cc6ed6654ce50e53f206b098f" translate="yes" xml:space="preserve">
          <source>a comment describing this commit.</source>
          <target state="translated">комментарий,описывающий этот коммит.</target>
        </trans-unit>
        <trans-unit id="6fd45c543fb44740f3ae2218676d1d2f809372d6" translate="yes" xml:space="preserve">
          <source>a committer: The name of the person who actually created the commit, with the date it was done. This may be different from the author, for example, if the author was someone who wrote a patch and emailed it to the person who used it to create the commit.</source>
          <target state="translated">коммиттером:Имя человека,который на самом деле создал коммит,с датой,когда он был сделан.Это может отличаться от автора,например,если автором был кто-то,кто написал патч и отправил его по электронной почте человеку,который использовал его для создания коммита.</target>
        </trans-unit>
        <trans-unit id="475363380919fa9dad3daaa5151af4a7ecf7fe63" translate="yes" xml:space="preserve">
          <source>a file called &lt;code&gt;HEAD&lt;/code&gt;, that has &lt;code&gt;ref: refs/heads/master&lt;/code&gt; in it. This is similar to a symbolic link and points at &lt;code&gt;refs/heads/master&lt;/code&gt; relative to the &lt;code&gt;HEAD&lt;/code&gt; file.</source>
          <target state="translated">файл с именем &lt;code&gt;HEAD&lt;/code&gt; , в котором есть &lt;code&gt;ref: refs/heads/master&lt;/code&gt; . Это похоже на символическую ссылку и указывает на &lt;code&gt;refs/heads/master&lt;/code&gt; относительно файла &lt;code&gt;HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956892125b0edbb5f2b693d0431acccf4dd5c1cd" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; directory.</source>
          <target state="translated">файл в &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8f92bb4f6fe9e686ed78d483dc8804c1d0837c" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; directory, or</source>
          <target state="translated">файл в &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; , или</target>
        </trans-unit>
        <trans-unit id="6fb331171394d95fbb7a35c4b995f2a83f23618c" translate="yes" xml:space="preserve">
          <source>a file that has &lt;code&gt;any&lt;/code&gt; difference what-so-ever in the three trees will stay as separate entries in the index. It&amp;rsquo;s up to &quot;porcelain policy&quot; to determine how to remove the non-0 stages, and insert a merged version.</source>
          <target state="translated">файл, который имеет &lt;code&gt;any&lt;/code&gt; различие в трех деревьях, останется в индексе как отдельные записи. Это дело &amp;laquo;фарфоровой политики&amp;raquo;, чтобы определить, как удалить этапы, отличные от 0, и вставить объединенную версию.</target>
        </trans-unit>
        <trans-unit id="fcb1d336b0be584d8054e8f7d63b3480aea0ee1d" translate="yes" xml:space="preserve">
          <source>a function called &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt;, typically defined in &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (note that older versions of Git used to have it in &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; instead), and declared in &lt;code&gt;builtin.h&lt;/code&gt;.</source>
          <target state="translated">функция с именем &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt; , обычно определяемая в &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (обратите внимание, что в старых версиях Git она использовалась вместо &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; ) и объявлялась в &lt;code&gt;builtin.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d20b77e1575c57d2803f17741070661ffe1f7923" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;Index: &quot;</source>
          <target state="translated">строка,которая начинается с &quot;Индекса&quot;:&quot;</target>
        </trans-unit>
        <trans-unit id="eac485dbe3dc8258452b85ab1fdc03917425590f" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;diff -&quot;, or</source>
          <target state="translated">строка,которая начинается с &quot;diff -&quot;,или</target>
        </trans-unit>
        <trans-unit id="8cb077e79c6b205418cec26b6f4930fe1ae56b3b" translate="yes" xml:space="preserve">
          <source>a newline.</source>
          <target state="translated">новую линию.</target>
        </trans-unit>
        <trans-unit id="678e3fa85625ddb634df3223f890cd55081ea7cd" translate="yes" xml:space="preserve">
          <source>a raw &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">необработанный &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a839de3aabe2c207992e1add851477714b9c5e" translate="yes" xml:space="preserve">
          <source>a remote in the Git configuration file: &lt;code&gt;$GIT_DIR/config&lt;/code&gt;,</source>
          <target state="translated">пульт в файле конфигурации Git: &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f9af7071efb1bd7dd22ebf85f05d8810442b8586" translate="yes" xml:space="preserve">
          <source>a space between time and time zone</source>
          <target state="translated">промежуток между временем и часовым поясом</target>
        </trans-unit>
        <trans-unit id="65b604e2f985f7317d6866f6730d409a3832783e" translate="yes" xml:space="preserve">
          <source>a space instead of the &lt;code&gt;T&lt;/code&gt; date/time delimiter</source>
          <target state="translated">пробел вместо разделителя даты / времени &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bc00ebd3440c4f401b07128f1c136e115562dd8" translate="yes" xml:space="preserve">
          <source>a space.</source>
          <target state="translated">место.</target>
        </trans-unit>
        <trans-unit id="97a7ee5f8a960df69981e9527fa176cfdf9705cf" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;objects&lt;/code&gt;, which will contain all the objects of your project. You should never have any real reason to look at the objects directly, but you might want to know that these objects are what contains all the real &lt;code&gt;data&lt;/code&gt; in your repository.</source>
          <target state="translated">подкаталог с именем &lt;code&gt;objects&lt;/code&gt; , который будет содержать все объекты вашего проекта. У вас никогда не должно быть реальной причины смотреть на объекты напрямую, но вы можете знать, что именно эти объекты содержат все реальные &lt;code&gt;data&lt;/code&gt; в вашем репозитории.</target>
        </trans-unit>
        <trans-unit id="045a27e5aab449465c7a517674ebf98a06438921" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;refs&lt;/code&gt;, which contains references to objects.</source>
          <target state="translated">подкаталог с именем &lt;code&gt;refs&lt;/code&gt; , содержащий ссылки на объекты.</target>
        </trans-unit>
        <trans-unit id="03097f133fc01ec710880af30fddc9a8cd7c34db" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used.</source>
          <target state="translated">табуляция или NUL при использовании опции &lt;code&gt;-z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9346da07fb77dd97b82dc62a47eb3edc36d2b7a0" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used; only exists for C or R.</source>
          <target state="translated">табуляция или NUL при использовании опции &lt;code&gt;-z&lt;/code&gt; ; существует только для C или R.</target>
        </trans-unit>
        <trans-unit id="c40734bc76bdc997f13a3bade66db88cc0dc137e" translate="yes" xml:space="preserve">
          <source>a tab;</source>
          <target state="translated">закладка;</target>
        </trans-unit>
        <trans-unit id="19150edbe2f84d3c01f8f24ddf7de6b06a212def" translate="yes" xml:space="preserve">
          <source>a tree: The SHA-1 name of a tree object (as defined below), representing the contents of a directory at a certain point in time.</source>
          <target state="translated">дерево:SHA-1 имя объекта дерева (как определено ниже),представляющего содержимое директории в определенный момент времени.</target>
        </trans-unit>
        <trans-unit id="013edfaa8480f23dc64a9a565714902a0f70e19a" translate="yes" xml:space="preserve">
          <source>a valid head &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">допустимое &lt;code&gt;name&lt;/code&gt; &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; (т.е. ссылка refs / heads / &amp;lt;head&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="c3796b26d9f35f82d5c7ba0548ce633809586698" translate="yes" xml:space="preserve">
          <source>a valid tag &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">допустимое &lt;code&gt;name&lt;/code&gt; тега (например, ссылка &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fdbf716e8cd4fd3ff778984618bbe33ffeee814c" translate="yes" xml:space="preserve">
          <source>a) are ancestor of the &quot;bad&quot; commit (including the &quot;bad&quot; commit itself), b) are not ancestor of a &quot;good&quot; commit (excluding the &quot;good&quot; commits).</source>
          <target state="translated">a)являются предком &quot;плохого&quot; коммита (включая сам &quot;плохой&quot; коммит),b)не являются предком &quot;хорошего&quot; коммита (исключая &quot;хорошие&quot; коммиты).</target>
        </trans-unit>
        <trans-unit id="8682c02d1bc4bfce128a794497013605d86c32b6" translate="yes" xml:space="preserve">
          <source>a) regular use</source>
          <target state="translated">а)регулярное использование</target>
        </trans-unit>
        <trans-unit id="4ff2759bc14568ced83be0be38a4abafea668a32" translate="yes" xml:space="preserve">
          <source>abbreviated commit hash</source>
          <target state="translated">сокращённое обязательство хэш</target>
        </trans-unit>
        <trans-unit id="83baab4c4f5445b3450e34e24f8066fea1ac11f2" translate="yes" xml:space="preserve">
          <source>abbreviated parent hashes</source>
          <target state="translated">сокращённые скобки</target>
        </trans-unit>
        <trans-unit id="33579b1cb5338205dc784843012a5c0a9e8cacae" translate="yes" xml:space="preserve">
          <source>abbreviated tree hash</source>
          <target state="translated">укороченный древесный гашиш</target>
        </trans-unit>
        <trans-unit id="832e60dfe198126ed45442b9d54f0a366515eefc" translate="yes" xml:space="preserve">
          <source>absorbgitdirs</source>
          <target state="translated">absorbgitdirs</target>
        </trans-unit>
        <trans-unit id="f412f21dd1d844e9ed4c1cbd73b06dc725c5d8bd" translate="yes" xml:space="preserve">
          <source>access method (one of &quot;ext&quot; or &quot;pserver&quot;)</source>
          <target state="translated">способ доступа (один из &quot;ext&quot; или &quot;pserver&quot;)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="6d8bcdb6bdc1c6a236c5092142b208eb67008cee" translate="yes" xml:space="preserve">
          <source>add &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</source>
          <target state="translated">добавить &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="89052c7d90a34c914815c621a3c8abaf890dfcb5" translate="yes" xml:space="preserve">
          <source>add [-b &amp;lt;branch&amp;gt;] [-f|--force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [--] &amp;lt;repository&amp;gt; [&amp;lt;path&amp;gt;]</source>
          <target state="translated">добавить [-b &amp;lt;ветка&amp;gt;] [-f | --force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [-] &amp;lt;repository&amp;gt; [&amp;lt;путь &amp;gt;]</target>
        </trans-unit>
        <trans-unit id="96b545065b00a5b7501087e2c1e93926449febd5" translate="yes" xml:space="preserve">
          <source>add a missing &lt;code&gt;\n&lt;/code&gt; to the last line if necessary.</source>
          <target state="translated">при необходимости добавьте отсутствующий &lt;code&gt;\n&lt;/code&gt; в последнюю строку.</target>
        </trans-unit>
        <trans-unit id="90bc127779a3e8fd8565532d33e4a134cd45f11d" translate="yes" xml:space="preserve">
          <source>add everything under the current directory.</source>
          <target state="translated">добавить все под текущую директорию.</target>
        </trans-unit>
        <trans-unit id="cb81f0f2d76a3c8759a19442b315f5c3a72e8b01" translate="yes" xml:space="preserve">
          <source>add untracked</source>
          <target state="translated">добавить бесследный</target>
        </trans-unit>
        <trans-unit id="c22e3f3bd42e15a0bc002a5cba9cb2e9cb547df3" translate="yes" xml:space="preserve">
          <source>add.ignore-errors (deprecated)</source>
          <target state="translated">add.ignore-errors (устаревшие)</target>
        </trans-unit>
        <trans-unit id="0d6211d85b6c5ebebd00bc700587b97d87d96f79" translate="yes" xml:space="preserve">
          <source>add.ignoreErrors</source>
          <target state="translated">add.ignoreErrors</target>
        </trans-unit>
        <trans-unit id="47d07ea3a984d5f17b8a52280b424c7e874d91e2" translate="yes" xml:space="preserve">
          <source>add.interactive.useBuiltin</source>
          <target state="translated">add.interactive.useBuiltin</target>
        </trans-unit>
        <trans-unit id="e441bfa1c3e8c860d35d02080c0d58234a3dc31b" translate="yes" xml:space="preserve">
          <source>addEmbeddedRepo</source>
          <target state="translated">addEmbeddedRepo</target>
        </trans-unit>
        <trans-unit id="ceb99972d01848a4af9e45ab5cd53f0d9ea700b4" translate="yes" xml:space="preserve">
          <source>added content</source>
          <target state="translated">добавленное содержимое</target>
        </trans-unit>
        <trans-unit id="782f82176de20dd76d4373d2acfc3406073964ff" translate="yes" xml:space="preserve">
          <source>adding context (&quot; &quot;) or removal (&quot;-&quot;) lines</source>
          <target state="translated">добавление строк контекста (&quot; &quot;)или удаление (&quot;-&quot;)</target>
        </trans-unit>
        <trans-unit id="39de4cfc4c6e6827c5f11475b89460e1b545a7f9" translate="yes" xml:space="preserve">
          <source>adds the following to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">добавляет в &lt;code&gt;.git/config&lt;/code&gt; следующее :</target>
        </trans-unit>
        <trans-unit id="f6acb502d3f3dcf967568ec1f1f05756c7001015" translate="yes" xml:space="preserve">
          <source>advice.*</source>
          <target state="translated">advice.*</target>
        </trans-unit>
        <trans-unit id="0608c4054662dd902e1314f7e450e3eaa81c1143" translate="yes" xml:space="preserve">
          <source>agent</source>
          <target state="translated">agent</target>
        </trans-unit>
        <trans-unit id="dc642557f3a1ed15b666c3bf8c010e9d1bceffe0" translate="yes" xml:space="preserve">
          <source>alias.*</source>
          <target state="translated">alias.*</target>
        </trans-unit>
        <trans-unit id="16f3bac085c702b24dd56dd8fdf474c5d21e6639" translate="yes" xml:space="preserve">
          <source>alice and cindy can push into master, only bob can push into doc-update. david is the release manager and is the only person who can create and push version tags.</source>
          <target state="translated">alice и Cindy могут проталкивать в мастер,только bob может проталкивать в doc-update.david является менеджером релизов и единственным человеком,который может создавать и проталкивать теги версий.</target>
        </trans-unit>
        <trans-unit id="ae21c64a87f6bb0b8e16e55c48be4cc638d7bd3f" translate="yes" xml:space="preserve">
          <source>align</source>
          <target state="translated">align</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="29702e41afdcf565d852a6355913f10360a2f8b0" translate="yes" xml:space="preserve">
          <source>all parent object ids</source>
          <target state="translated">идентификаторы всех родительских объектов</target>
        </trans-unit>
        <trans-unit id="6664a4a284b9aeecc837369fce6272fe3547f795" translate="yes" xml:space="preserve">
          <source>allow-indentation-change</source>
          <target state="translated">allow-indentation-change</target>
        </trans-unit>
        <trans-unit id="890c8ad25c4c255f4dda7bba71ccde4b6eb54f1a" translate="yes" xml:space="preserve">
          <source>allows you to browse any commits from the last 2 weeks of commits that modified files under the &quot;drivers&quot; directory. (Note: you can adjust gitk&amp;rsquo;s fonts by holding down the control key while pressing &quot;-&quot; or &quot;+&quot;.)</source>
          <target state="translated">позволяет вам просматривать любые коммиты за последние 2 недели, которые изменяли файлы в каталоге &quot;drivers&quot;. (Примечание: вы можете настроить шрифты gitk, удерживая клавишу Control и одновременно нажимая &amp;laquo;-&amp;raquo; или &amp;laquo;+&amp;raquo;.)</target>
        </trans-unit>
        <trans-unit id="8733169fb7d8912aa579031eed0a4b26ef5718fe" translate="yes" xml:space="preserve">
          <source>alternate object database</source>
          <target state="translated">БД альтернативного объекта</target>
        </trans-unit>
        <trans-unit id="385d97ddc2cf0f165b1e517e2de9a74c662d0d92" translate="yes" xml:space="preserve">
          <source>alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.</source>
          <target state="translated">альтернативный:абсолютный путь к базам данных альтернативных объектов;может появляться несколько раз,по одной строке на каждый путь.Обратите внимание,что если путь содержит непечатаемые символы,то он может быть окружен двойными кавычками и содержать обратно зашифрованные экранирующие последовательности в стиле C.</target>
        </trans-unit>
        <trans-unit id="459a9aeba984b09598ccfb2133b8ae65d179153d" translate="yes" xml:space="preserve">
          <source>although the full, 40-character SHA-1s would be supplied. If the foreign ref does not yet exist the &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If a ref is to be deleted, the &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; will be supplied as &lt;code&gt;(delete)&lt;/code&gt; and the &lt;code&gt;&amp;lt;local
SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If the local commit was specified by something other than a name which could be expanded (such as &lt;code&gt;HEAD~&lt;/code&gt;, or a SHA-1) it will be supplied as it was originally given.</source>
          <target state="translated">хотя будут предоставлены полные 40-символьные SHA-1. Если внешняя ссылка еще не существует, &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; будет 40 &lt;code&gt;0&lt;/code&gt; . Если ссылка должна быть удалена, &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; будет предоставлен как &lt;code&gt;(delete)&lt;/code&gt; а &lt;code&gt;&amp;lt;local SHA-1&amp;gt;&lt;/code&gt; будет равен 40 &lt;code&gt;0&lt;/code&gt; . Если локальная фиксация была указана чем-то другим, кроме имени, которое может быть расширено (например, &lt;code&gt;HEAD~&lt;/code&gt; или SHA-1), оно будет предоставлено в том виде, в котором оно было изначально задано.</target>
        </trans-unit>
        <trans-unit id="b16bb5afab4c1802eaeada40ac59f4ec78c01be8" translate="yes" xml:space="preserve">
          <source>always show in columns</source>
          <target state="translated">всегда показываться колонками</target>
        </trans-unit>
        <trans-unit id="b0c4ba6a734338f8b0a5e21fcbb05d3afcd198af" translate="yes" xml:space="preserve">
          <source>always shows the difference between the HEAD and the index file&amp;mdash;​this is what you&amp;rsquo;d commit if you created the commit now&amp;mdash;​and that</source>
          <target state="translated">всегда показывает разницу между HEAD и индексным файлом - это то, что вы бы зафиксировали, если бы создали фиксацию сейчас - и что</target>
        </trans-unit>
        <trans-unit id="96e8155732e8324ae26f64d4516eb6fe696ac84f" translate="yes" xml:space="preserve">
          <source>am</source>
          <target state="translated">am</target>
        </trans-unit>
        <trans-unit id="400226a3b8758d7d662c424a478d16cceecd29ed" translate="yes" xml:space="preserve">
          <source>am.keepcr</source>
          <target state="translated">am.keepcr</target>
        </trans-unit>
        <trans-unit id="80b11664f9cdc0c4da5b2cf9cbae91e78f24cb5f" translate="yes" xml:space="preserve">
          <source>am.threeWay</source>
          <target state="translated">am.threeWay</target>
        </trans-unit>
        <trans-unit id="d9de89ed653daadc282d17fa341547ccd80f5e0c" translate="yes" xml:space="preserve">
          <source>amWorkDir</source>
          <target state="translated">amWorkDir</target>
        </trans-unit>
        <trans-unit id="b1cc99b811681fb579eeabe4a14a5e1ec1bab455" translate="yes" xml:space="preserve">
          <source>amend the previous commit, adding all your new changes, using your original message.</source>
          <target state="translated">изменить предыдущий коммит,добавить все новые изменения,используя оригинальное сообщение.</target>
        </trans-unit>
        <trans-unit id="461152b367e8ab9740fb2e9ee2da4d7175e9e2a2" translate="yes" xml:space="preserve">
          <source>an LF or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used, to terminate the record.</source>
          <target state="translated">LF или NUL при использовании параметра &lt;code&gt;-z&lt;/code&gt; для завершения записи.</target>
        </trans-unit>
        <trans-unit id="75eada615f3da2b986734d58bb672366de760679" translate="yes" xml:space="preserve">
          <source>an author: The name of the person responsible for this change, together with its date.</source>
          <target state="translated">автор:Имя лица,ответственного за это изменение,вместе с его датой.</target>
        </trans-unit>
        <trans-unit id="b441fe44ea3ab3bff759abb792c8a7f4c7974b0c" translate="yes" xml:space="preserve">
          <source>an entry in &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">запись в &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; в &lt;code&gt;Makefile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d25597e1ded62863dd59e418a49b42af285a609" translate="yes" xml:space="preserve">
          <source>an entry in the &lt;code&gt;commands[]&lt;/code&gt; array in &lt;code&gt;git.c&lt;/code&gt;, and</source>
          <target state="translated">запись в массиве &lt;code&gt;commands[]&lt;/code&gt; в &lt;code&gt;git.c&lt;/code&gt; и</target>
        </trans-unit>
        <trans-unit id="5037f82b8aa7002eda9aed7d8c0898525bc2f00d" translate="yes" xml:space="preserve">
          <source>and Git will continue applying the rest of the patches.</source>
          <target state="translated">и Гит продолжит применение остальных патчей.</target>
        </trans-unit>
        <trans-unit id="b3b2e45f7b37ac14dc28b61e29aee3c419229fda" translate="yes" xml:space="preserve">
          <source>and Git will create the commit for you and continue applying the remaining patches from the mailbox.</source>
          <target state="translated">и Git создаст для вас коммит и продолжит применение оставшихся патчей из почтового ящика.</target>
        </trans-unit>
        <trans-unit id="7067f391e9f25da3da4a562c780b468101adb659" translate="yes" xml:space="preserve">
          <source>and Git will prompt you for a commit message and then create the new commit. Check to make sure it looks like what you expected with</source>
          <target state="translated">и Git запросит у вас сообщение о фиксации,а затем создаст новый коммит.Проверьте,выглядит ли сообщение так,как вы ожидали.</target>
        </trans-unit>
        <trans-unit id="11bda7867b55ea900931dbe2ab8c87a36a0443d9" translate="yes" xml:space="preserve">
          <source>and bundle topic branches still cooking.</source>
          <target state="translated">и объединять тематические ветки,которые еще готовят.</target>
        </trans-unit>
        <trans-unit id="06675e26cc6f5bedf7b0e9b9d71e33fb64fa4ef8" translate="yes" xml:space="preserve">
          <source>and email them.</source>
          <target state="translated">и отправить их по электронной почте.</target>
        </trans-unit>
        <trans-unit id="d5d63b233efdc161b2104f0e091d210beeb2fe60" translate="yes" xml:space="preserve">
          <source>and hack away. The equivalent of &lt;code&gt;cvs update&lt;/code&gt; is</source>
          <target state="translated">и взломать. Эквивалент &lt;code&gt;cvs update&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d4b59596148297f0688711ac4f92721dbc18215b" translate="yes" xml:space="preserve">
          <source>and if it detects that the file &quot;file0&quot; is completely rewritten, it changes it to:</source>
          <target state="translated">и если он обнаруживает,что файл &quot;file0&quot; полностью переписан,он меняет его на другой:</target>
        </trans-unit>
        <trans-unit id="e1426704be98b9dd3d938c5a6a31b3fe4ee9a995" translate="yes" xml:space="preserve">
          <source>and in fact a lot of the common Git command combinations can be scripted with the &lt;code&gt;git xyz&lt;/code&gt; interfaces. You can learn things by just looking at what the various git scripts do. For example, &lt;code&gt;git reset&lt;/code&gt; used to be the above two lines implemented in &lt;code&gt;git reset&lt;/code&gt;, but some things like &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; are slightly more complex scripts around the basic Git commands.</source>
          <target state="translated">и на самом деле многие стандартные комбинации команд Git могут быть написаны с помощью интерфейсов &lt;code&gt;git xyz&lt;/code&gt; . Вы можете узнать многое, просто посмотрев, что делают различные сценарии git. Например, &lt;code&gt;git reset&lt;/code&gt; - это две приведенные выше строки, реализованные в &lt;code&gt;git reset&lt;/code&gt; , но некоторые вещи, такие как &lt;code&gt;git status&lt;/code&gt; и &lt;code&gt;git commit&lt;/code&gt; , представляют собой несколько более сложные сценарии вокруг основных команд Git.</target>
        </trans-unit>
        <trans-unit id="c2f880dab39040d1bcbb6d73323cfccc9f1141f6" translate="yes" xml:space="preserve">
          <source>and it is assumed unchanged.</source>
          <target state="translated">и предполагается,что она не изменилась.</target>
        </trans-unit>
        <trans-unit id="6fdb49363e42ba495e98dac786aceef7ea588734" translate="yes" xml:space="preserve">
          <source>and it will be gone. There&amp;rsquo;s no external repository, and there&amp;rsquo;s no history outside the project you created.</source>
          <target state="translated">и его не будет. Нет внешнего репозитория и нет истории вне созданного вами проекта.</target>
        </trans-unit>
        <trans-unit id="14be792a7fbd836c220980afe820c5835c201a25" translate="yes" xml:space="preserve">
          <source>and it would create the new branch &lt;code&gt;mybranch&lt;/code&gt; at the earlier commit, and check out the state at that time.</source>
          <target state="translated">и он создаст новую ветку &lt;code&gt;mybranch&lt;/code&gt; при предыдущей фиксации и проверит состояние в это время.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
