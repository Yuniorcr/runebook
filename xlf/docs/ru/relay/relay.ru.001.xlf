<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy; 2013 &amp;ndash; настоящее время Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="62a57a41103550669d926f2e0d40ca12b0b6a458" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2020&amp;ndash;present Facebook Inc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c885f04e75b4bbf0d9edbb67f250e651d298c71" translate="yes" xml:space="preserve">
          <source>(subsequent sections explain how these types are used in practice):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2bb4599b07dd7b4cea35d8e273b367c0b66305" translate="yes" xml:space="preserve">
          <source>* Modern API doesn't support mutation fragments. You might have to inline the mutation fragments from your legacy mutation in the fragment of the component.</source>
          <target state="translated">* Современный API не поддерживает фрагменты мутации. Возможно, вам придется встроить фрагменты мутации из устаревшей мутации во фрагмент компонента.</target>
        </trans-unit>
        <trans-unit id="3c78bed46629a737d7ec7580861338032fb6f8d8" translate="yes" xml:space="preserve">
          <source>...which calls the callbacks for any &lt;code&gt;subscribe()&lt;/code&gt;-ers whose results have changed. Each subscription is checked as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c225bfc176636425ea153120adefbee642d75cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt; returns a basic container that cannot fetch additional data beyond what is declared in its fragment(s). Relay Modern also provides more advanced containers for dynamic use cases (which were previously handled in Relay Classic via &lt;code&gt;setVariables&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt; возвращает базовый контейнер, который не может получать дополнительные данные, помимо тех, что объявлены в его фрагменте (ах). Relay Modern также предоставляет более продвинутые контейнеры для динамических вариантов использования (которые ранее обрабатывались в Relay Classic с помощью &lt;code&gt;setVariables&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="77688ea0d1fdf22bab3df470e72bfe7de6cb4724" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome Extension&lt;/a&gt; creates a Relay tab in the developer tools interface for debugging apps in Chrome</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Расширение Chrome&lt;/a&gt; создает вкладку Relay в интерфейсе инструментов разработчика для отладки приложений в Chrome.</target>
        </trans-unit>
        <trans-unit id="fad91719b9218a6ae11551221b84fc32086535ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; allows views to be defined as components where every component is responsible for rendering a part of the UI. Composing other components is how to build complex UIs. Each React component doesn't need to know the inner workings of the composed components.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; позволяет определять представления как компоненты, где каждый компонент отвечает за отрисовку части пользовательского интерфейса. Составление других компонентов - это способ создания сложных пользовательских интерфейсов. Каждому компоненту React не нужно знать внутреннюю работу составных компонентов.</target>
        </trans-unit>
        <trans-unit id="a1980b0d9659b15299523fce23afa9e64733250c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Electron App&lt;/a&gt; that connects to React Native apps running Relay</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Приложение Electron,&lt;/a&gt; которое подключается к приложениям React Native, работающим под управлением Relay</target>
        </trans-unit>
        <trans-unit id="0f80ef8cc2241c7509e6613ced8779935dc25b6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; manages the execution of the GraphQL query. It sends the query with given variables, parses the response, saves the data to the internal cache, and finally renders the view.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; управляет выполнением запроса GraphQL. Он отправляет запрос с заданными переменными, анализирует ответ, сохраняет данные во внутреннем кэше и, наконец, отображает представление.</target>
        </trans-unit>
        <trans-unit id="cfac86ab065f686a94d7eabf085884e964606374" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;createRefetchContainer&lt;/code&gt;&lt;/a&gt; is a variation of &lt;code&gt;createFragmentContainer&lt;/code&gt; that addresses the &quot;see more&quot; use case, where a subset of data is rendered initially and then additional data is fetched on demand. Refetch containers initially fetch data for their fragments just like fragment containers, but also offer a &lt;code&gt;refetch()&lt;/code&gt; method by which additional data can be fetched, or the container can be re-rendered to read data using different variables.</source>
          <target state="translated">&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;createRefetchContainer&lt;/code&gt; &lt;/a&gt; - это вариант &lt;code&gt;createFragmentContainer&lt;/code&gt; , предназначенныйдля варианта использования &amp;laquo;увидеть больше&amp;raquo;, когда сначала отображается подмножество данных, а затем по запросу извлекаются дополнительные данные. Контейнеры Refetch первоначально извлекают данные для своих фрагментов так же, как контейнеры фрагментов, но также предлагаютметод &lt;code&gt;refetch()&lt;/code&gt; помощью которого могут быть извлечены дополнительные данные, или контейнер может быть повторно визуализирован для чтения данных с использованием других переменных.</target>
        </trans-unit>
        <trans-unit id="f6f0afa9606f188df5aa2880a96f0796da66589e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;relay-compat&quot;&gt;Compat mode&lt;/a&gt; allows the Relay Modern APIs to be incrementally adopted in an existing Relay app. This approach enables the following features compared to Relay Classic:</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;Режим совместимости&lt;/a&gt; позволяет постепенно внедрять современные API-интерфейсы Relay в существующее приложение Relay. Этот подход обеспечивает следующие функции по сравнению с Relay Classic:</target>
        </trans-unit>
        <trans-unit id="3cc7b1d6acf9a6a36373b7d2788a819c007a696a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; receives a &lt;code&gt;user&lt;/code&gt; prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; получает опору &lt;code&gt;user&lt;/code&gt; с простыми данными JavaScript - объектами, массивами, строками - и отображает как обычно.</target>
        </trans-unit>
        <trans-unit id="540f04ea4575b6b8ef0b102ef7464ad435fbcfde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@argumentDefinitions&lt;/code&gt; is a directive used to specify arguments taken by a fragment. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1b1f1da3ceb037a205f174a8917520d0d4ffd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@arguments&lt;/code&gt; is a directive used to pass arguments to a fragment that was defined using &lt;a href=&quot;#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115b4c121f9af58bd42ac1ea726c7c948a8dafc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@connection&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; директива @connection</target>
        </trans-unit>
        <trans-unit id="1bc35103d12ff175f274fc790197926805195584" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@relay(mask: false)&lt;/code&gt; can be used to prevent data masking; when including a fragment and annotating it with &lt;code&gt;@relay(mask: false)&lt;/code&gt;, its data will be available directly to the parent instead of being masked for a different container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d3bbc3f0308d432f9237679fd4198f106ffc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</source>
          <target state="translated">&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; - транзакция была поставлена ​​в очередь для фиксации, но другая транзакция с тем же ключом столкновения не удалась. Все транзакции в очереди конфликтов, включая эту, были неудачными. Транзакцию можно подтвердить или откатить.</target>
        </trans-unit>
        <trans-unit id="8093d07e77e9be3790d54f76445c918f46849774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; Transaction is waiting for the server to respond.</source>
          <target state="translated">&lt;code&gt;COMMITTING&lt;/code&gt; - транзакция ожидает ответа от сервера.</target>
        </trans-unit>
        <trans-unit id="72fc89ccfca88827066da906d579a404ab74ce01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was sent to the server for comitting but failed.</source>
          <target state="translated">&lt;code&gt;COMMIT_FAILED&lt;/code&gt; - транзакция была отправлена ​​на сервер для завершения, но не удалась.</target>
        </trans-unit>
        <trans-unit id="3ea90f9f79de8b7da5c3c317bc9a5b13f75106bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</source>
          <target state="translated">&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; - транзакция зафиксирована, но ожидает выполнения другой транзакции с тем же ключом конфликта, поэтому транзакция поставлена ​​в очередь для отправки на сервер.</target>
        </trans-unit>
        <trans-unit id="d35b1de34e23cc42d8709b3e3b9f29da3640030e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CompilerContext&lt;/code&gt;: an immutable representation of a corpus of GraphQL documents. It contains the schema and a mapping of document names to document representations (as IR, see above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f3d026fc6b13bd99ef80b56496208f62a08c9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Component&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; Контейнер Component Relay, который определяет фрагменты и представление для рендеринга.</target>
        </trans-unit>
        <trans-unit id="7e0e496215e40a981e6b2de27c4b054fef09ee84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConnectionHandler&lt;/code&gt; is a utility module exposed by &lt;code&gt;relay-runtime&lt;/code&gt; that aids in the manipulation of connections. &lt;code&gt;ConnectionHandler&lt;/code&gt; exposes the following interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfead01c2b218e3cb68f309d9651d5634bcc584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Container&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Container&lt;/code&gt; Relay - контейнер, который определяет фрагменты и представление для рендеринга.</target>
        </trans-unit>
        <trans-unit id="6e013f788fda8dc5f1f6d2035114dc14dbf0b578" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DataID&lt;/code&gt; (type): A globally unique or client-generated identifier for a record, stored as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce201c06fa6c11d5f36ef9be515d40d9178e1a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Environment&lt;/code&gt; (type): Represents an encapsulated environment combining a &lt;code&gt;Store&lt;/code&gt; and &lt;code&gt;Network&lt;/code&gt;, providing a high-level API for interacting with both. This is the main public API of &lt;code&gt;RelayRuntime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e3ea2f8d9422eb5a55274a578df6f8f2c6bd0ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FlattenTransform&lt;/code&gt;: Reduces extraneous levels of indirection in a query, inlining fields from anonymous fragments wherever they match the parent type. This can be beneficial when generating code to read the results of a query or process query results, as it reduces duplicate field processing. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8491c1573884a469fe6759e485e0a2a6e275e8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GenerateRequisiteFieldTransform&lt;/code&gt;: This optional, Relay-specific transform inserts &lt;code&gt;id&lt;/code&gt; fields for globally identifiable objects and &lt;code&gt;__typename&lt;/code&gt; fields wherever the type cannot be statically determined (e.g. for unions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa5e3950beed71919f93e9725e12ccd2524ec5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IR&lt;/code&gt; (Intermediate Representation): an (effectively immutable) representation of a GraphQL document (query, fragment, field, etc) as a tree structure, including type information from a schema. Compared to the standard GraphQL AST (produced by e.g. &lt;code&gt;graphql-js&lt;/code&gt;) the main difference is that it encodes more of the semantics of GraphQL. For example, conditional branches (&lt;code&gt;@include&lt;/code&gt; and &lt;code&gt;@skip&lt;/code&gt;) are represented directly, making it easier to target optimizations for these directives (One such optimization is to merge sibling fields with the same condition, potentially reducing the number of conditionals that must be evaluated at runtime).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80030d53df3c7d765455bf7613659bf4eb278701" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Network&lt;/code&gt; (type): Provides methods for fetching query data from and executing mutations against an external data source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52ff52d23e6ad23c71ab30789b670011882899f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PaginationContainer&lt;/code&gt; is designed to simplify the workflow of loading more items in a list -- in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PaginationContainer&lt;/code&gt; разработан для упрощения рабочего процесса по загрузке большего количества элементов в список - во многих случаях мы не хотим получать все данные сразу, а лениво загружать больше данных. Он полагается на сервер GraphQL, предоставляющий соединения стандартизированным способом. Для получения подробной информации посетите &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;эту страницу&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36a682fa10b4ab6dd0259f5b624dca4803e8ff33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Parser&lt;/code&gt;: Converts a GraphQL schema and raw GraphQL text into typed IR objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f603ad3da9b9bbbb0030816e3352c33635f9a1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Printer&lt;/code&gt;: a function that accepts IR and converts it to a GraphQL string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5406da34447a5b22b7d56f6fce92e419b505424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; is the root of a Relay tree. It takes a query, fetches the data and calls the &lt;code&gt;render&lt;/code&gt; callback with the data.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; - это корень дерева ретрансляции. Он принимает запрос, извлекает данные и вызывает обратный вызов &lt;code&gt;render&lt;/code&gt; с данными.</target>
        </trans-unit>
        <trans-unit id="593061a9841e95181922e32bf061e078ec44605a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; supports rendering small amounts of data directly, instead of requiring a container to access data. &lt;a href=&quot;fragment-container&quot;&gt;Containers&lt;/a&gt; are optional and can be used as your application grows in size and complexity.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; поддерживает рендеринг небольших объемов данных напрямую, вместо того, чтобы требовать для доступа к данным контейнер. &lt;a href=&quot;fragment-container&quot;&gt;Контейнеры не&lt;/a&gt; являются обязательными и могут использоваться по мере увеличения размера и сложности вашего приложения.</target>
        </trans-unit>
        <trans-unit id="99e84e643c97bf62b99096002ffcdeabf9974b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; will then fetch the data and render &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. Just as React allows developers to render views without directly manipulating the underlying view, Relay removes the need to directly communicate with the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5389da6f3012b6c1290dfc4aabb66ac37a4a88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Record&lt;/code&gt; (type): A representation of a distinct data entity with an identity, type, and fields. Note that the actual runtime representation is opaque to the system: all accesses to &lt;code&gt;Record&lt;/code&gt; objects (including record creation) is mediated through the &lt;code&gt;RelayModernRecord&lt;/code&gt; module. This allows the representation itself to be changed in a single place (e.g. to use &lt;code&gt;Map&lt;/code&gt;s or a custom class). It is important that other code does not assume that &lt;code&gt;Record&lt;/code&gt;s will always be plain objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c286a93f7d02b418c79e236a3f655909cd0828b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RecordSource&lt;/code&gt; (type): A collection of records keyed by their data ID, used both to represent the cache and updates to it. For example the store's record cache is a &lt;code&gt;RecordSource&lt;/code&gt; and the results of queries/mutations/subscriptions are normalized into &lt;code&gt;RecordSource&lt;/code&gt;s that are published to a store. Sources also define methods for asynchronously loading records in order to (eventually) support offline use-cases. Currently the only implementation of this interface is &lt;code&gt;RelayInMemoryRecordSource&lt;/code&gt;; future implementations may add support for loading records from disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dcadb6bea3b3b49c5e438342092e725abab0a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; doesn't provide any bells and whistles such as fat queries or tracked queries (that is, automatic synthesis at runtime of the mutation query to be sent to the server), instead having the user define a static and explicit query. Restricting yourself to the low-level API is a useful preparatory step that will help you ready your codebase for migration to the new static Relay core. In the meantime, if you want those dynamic features, you can opt in to the higher-level &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; не предоставляет никаких наворотов, таких как толстые запросы или отслеживаемые запросы (то есть автоматический синтез во время выполнения запроса на мутацию, отправляемого на сервер), вместо этого пользователь определяет статический и явный запрос. Ограничение низкоуровневого API - это полезный подготовительный шаг, который поможет вам подготовить кодовую базу для миграции на новое статическое ядро ​​Relay. Между тем, если вам нужны эти динамические функции, вы можете выбрать &lt;code&gt;Relay.Mutation&lt;/code&gt; API Relay.Mutation .</target>
        </trans-unit>
        <trans-unit id="b9dbe21f8c1dda099d24350958022ccc0bb3f410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; is a low-level API for modeling a GraphQL mutation.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; - это низкоуровневый API для моделирования мутации GraphQL.</target>
        </trans-unit>
        <trans-unit id="127b1aff45435298c344787323bda31e37d71df8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.QL&lt;/code&gt; objects are used by the following APIs:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; Объекты Relay.QL используются следующими API:</target>
        </trans-unit>
        <trans-unit id="7e9cc4a6100437d109392de9c4dd32579e5bef54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.Renderer&lt;/code&gt; can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the &lt;code&gt;render&lt;/code&gt; prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and &lt;code&gt;Relay.Renderer&lt;/code&gt; remove the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;Relay.Renderer&lt;/code&gt; может организовать получение запросов; сравнение их с кэшированными данными, выборка любой недостающей информации, обновление кеша и, наконец, рендеринг &lt;code&gt;StoryContainer&lt;/code&gt; , когда данные станут доступны. По умолчанию во время выборки данных ничего не отображается, но представление загрузки можно настроить с помощью свойства &lt;code&gt;render&lt;/code&gt; . Подобно тому, как React позволяет разработчикам визуализировать представления, не манипулируя напрямую базовым представлением, Relay и &lt;code&gt;Relay.Renderer&lt;/code&gt; устраняют необходимость прямого взаимодействия с сетью.</target>
        </trans-unit>
        <trans-unit id="af18c48993c9562a944639b49a29f4455950bbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay&lt;/code&gt; is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can &lt;code&gt;require()&lt;/code&gt; it.</source>
          <target state="translated">&lt;code&gt;Relay&lt;/code&gt; - это точка входа в библиотеку Relay. Если вы используете один из готовых пакетов, он доступен как глобальный; если вы используете модули CommonJS, вы можете &lt;code&gt;require()&lt;/code&gt; это.</target>
        </trans-unit>
        <trans-unit id="5c66e5b2f381152669b034d6f6167ad8cf6ed012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayContainer&lt;/code&gt; is a higher-order React component that lets a React component encode its data requirements.</source>
          <target state="translated">&lt;code&gt;RelayContainer&lt;/code&gt; - это компонент React более высокого порядка, который позволяет компоненту React кодировать свои требования к данным.</target>
        </trans-unit>
        <trans-unit id="df2d84ab4a50cd1673857a423e00806293940147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendMutation&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayMutationRequest&lt;/code&gt; инкапсулирует мутацию, которую Relay необходимо отправить на сервер. Они становятся доступными для сетевых уровней через метод &lt;code&gt;sendMutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4dc52a29a31a839078a5cad953c9628f74f0f0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; can return one of the following strings:</source>
          <target state="translated">&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; может возвращать одну из следующих строк:</target>
        </trans-unit>
        <trans-unit id="242d9ea8a1f2fba8d773760a8233ecf37bf7b5f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsulates a query that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendQueries&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayQueryRequest&lt;/code&gt; инкапсулирует запрос, который Relay должен отправить на сервер. Они становятся доступными для сетевых уровней с помощью метода &lt;code&gt;sendQueries&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa983dda38587dddabcba1aaf5a70bd38e50d1c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Selector&lt;/code&gt; (type): A selector defines the starting point for a traversal into the graph for the purposes of targeting a subgraph, combining a GraphQL fragment, variables, and the Data ID for the root object from which traversal should progress. Intuitively, this &quot;selects&quot; a portion of the object graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3c71166345fc66296a2fcfde6e211df573f098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SkipRedundantNodeTransform&lt;/code&gt;: A more advanced version of flattening, this eliminates more complex cases of field duplication such as when a field is fetched both unconditionally and conditionally, or is fetched by two different sub-fragments. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba6d300e8d2beebd7043543022bbc6158c521d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Snapshot&lt;/code&gt; (type): The (immutable) results of executing a &lt;code&gt;Selector&lt;/code&gt; at a given point in time. This includes the selector itself, the results of executing it, and a list of the Data IDs from which data was retrieved (useful in determining when these results might change).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6f9d1898c7f71f61996e47d31e4669e9f6ea00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Store&lt;/code&gt; (type): The source of truth for an instance of &lt;code&gt;RelayRuntime&lt;/code&gt;, holding the canonical set of records in the form of a &lt;code&gt;RecordSource&lt;/code&gt; (though this is not required). Currently the only implementation is &lt;code&gt;RelayModernStore&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6953a65cec76dd55ffb8686c4013c2fe83a10320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Transform&lt;/code&gt;: a &quot;map&quot;-like function that accepts a &lt;code&gt;CompilerContext&lt;/code&gt; as input and returns a new, modified context as output. Examples below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df62ea345a45d0a5fabcd2fdbf901148c6e5a8b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</source>
          <target state="translated">&lt;code&gt;UNCOMMITTED&lt;/code&gt; - Транзакция еще не отправлена ​​на сервер. Транзакция может быть подтверждена или отменена.</target>
        </trans-unit>
        <trans-unit id="251d369c69abccbd72c957636015d12c5ab2df7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44015182f39e2d46ef207ac1787ea9eab09b8733" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options, i.e. &lt;code&gt;force: true&lt;/code&gt; requires the fetch to be issued regardless of the state of any configured response cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e2ffe769d943340c0e937aef710727a6236ec6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cacheConfig?&lt;/code&gt;: Optional object containing a set of cache configuration options, i.e. &lt;code&gt;force: true&lt;/code&gt; requires the fetch to be issued regardless of the state of any configured response cache. See &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/relay-runtime/lib/util/RelayRuntimeTypes.d.ts#L22-L35&quot;&gt;the types&lt;/a&gt; for more &lt;code&gt;cacheConfig&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c165e6157296f7bcc1ff33984b3b1b9a2c82c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt;: Function called when the new page has been fetched. If an error occurred during refetch, this function will receive that error as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a549ab3ecb985d7c1e6a0bcdb2975890cf8213e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt;: Function to be called after the refetch has completed. If an error occurred during refetch, this function will receive that error as an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ddb9c091b2339b506a0b25d46c1b43d0aec3f3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;component&lt;/code&gt;: The React Component &lt;em&gt;class&lt;/em&gt; of the component requiring the fragment data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84b6d9b41c57662dbad63044ec256b7ffeb4679" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="06f15b2aa1dd0d5d58698483052939daa832e202" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: Array containing objects describing &lt;code&gt;optimisticUpdater&lt;/code&gt;/&lt;code&gt;updater&lt;/code&gt; configurations. &lt;code&gt;configs&lt;/code&gt; provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior without having to write an &lt;code&gt;updater&lt;/code&gt; function. See our section on &lt;a href=&quot;#updater-configs&quot;&gt;Updater Configs&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a52e374bfb1a67a3f6d2363ba22492f2e2e80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the different optimisticUpdater/updater configurations. It provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; : массив, содержащий различные конфигурации optimisticUpdater / updater. Это удобный способ указать поведение средства &lt;code&gt;updater&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cc60f97e29bfb6ea62a807eae2cc5e7a17f3eb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; : массив, содержащий конфигурации программы обновления. &lt;code&gt;commitMutation&lt;/code&gt; же, что &lt;a href=&quot;mutations#configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt; в commitMutation .</target>
        </trans-unit>
        <trans-unit id="62ed1b32bc4ea099a4726b7185046d66828e634b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#updater-configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007117b0cb1510ebdd6ccffcf08576a3c37cde5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionConfig&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;connectionConfig&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="9394dd3d6a30c68a04fbce9521aacc5342c5da92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior:
string}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).</source>
          <target state="translated">&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior: string}&amp;gt;&lt;/code&gt; : массив объектов, содержащих ключ подключения, объект, содержащий дополнительные фильтры, и поведение диапазона в зависимости от ожидаемого поведения (добавление, добавление, или игнорировать).</target>
        </trans-unit>
        <trans-unit id="43c66a2069ec0b2d4be35833e1ae8977d9b93edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key and optionally filters.</source>
          <target state="translated">&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt; : массив объектов, содержащих ключ подключения и, при необходимости, фильтров.</target>
        </trans-unit>
        <trans-unit id="3d66112758b5fe7d9ec709917fc9645fa7ce2017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createFragmentContainer&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38957bb815ee45a69777b60c1f154618685af8ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createPaginationContainer&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3466a399b65ec8fadadd39718cdbdde5b6b2fc57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createRefetchContainer&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19b3e482db84864f686a4ee3759da01773329b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; : имя поля в ответе, которое содержит DataID удаленного узла или путь к узлу, удаленному из соединения.</target>
        </trans-unit>
        <trans-unit id="876617472fa789679ebf9a0b7c9f1eb24f355aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID or DataIDs of the removed node or nodes, or the path to the node or nodes removed from the connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e977f6b2b4f562aa7af31b00751819ad50d520ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; : имя поля в ответе, которое содержит DataID удаленного узла.</target>
        </trans-unit>
        <trans-unit id="bf1fd5c8652f9301a307527a2205d4d2b4a75a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID or DataIDs of the deleted node or nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999f3fdfc8dda2a0f3aa0796444cc77a3d69202e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;direction&lt;/code&gt;: Either &quot;forward&quot; to indicate forward pagination using after/first, or &quot;backward&quot; to indicate backwards pagination using before/last. If not provided, Relay will infer the direction based on the provided &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22bd764f98c24605fee21c6e86534a102d352d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edgeName: string&lt;/code&gt;: The field name in the response that represents the newly created edge</source>
          <target state="translated">&lt;code&gt;edgeName: string&lt;/code&gt; : имя поля в ответе, которое представляет вновь созданное ребро</target>
        </trans-unit>
        <trans-unit id="b7ab967dc3d9dac41042965f33de5bbacae6b0e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt; An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; Экземпляр Relay.Environment или любой объект, реализующий интерфейс RelayEnvironment.</target>
        </trans-unit>
        <trans-unit id="934fc584b2cbd07fff4713741be349d8db57ed53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04830e6cd3cb5a81acacd5ef47ab3c8d851603a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. &lt;strong&gt;Note:&lt;/strong&gt; To ensure the mutation is performed on the correct &lt;code&gt;environment&lt;/code&gt;, it's recommended to use the environment available within components (from &lt;code&gt;this.props.relay.environment&lt;/code&gt;), instead of referencing a global environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c42e0b6673753c1ecd9043bed1858fc0974cabb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt;: The current &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516a6ee32a7083dc25663e4b1b51d53113bbfc43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error&lt;/code&gt;: Error will be defined if an error has occurred while fetching the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="933f09a28ce1c93df86693d7ec2e3b4c3c2c539a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetchPolicy&lt;/code&gt;: If the data is already present in the store, using the &lt;code&gt;'store-or-network'&lt;/code&gt; option will use that data without making an additional network request. Using the &lt;code&gt;'network-only'&lt;/code&gt; option, which is the default behavior, will ignore any data present in the store and make a network request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094d53375b81243f7e2c05c1de339c8e282ff5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fetchPolicy?&lt;/code&gt;: Optional prop to indicate if data already present in the store should be used to render immediately and updated from the network afterwards using the &lt;code&gt;store-and-network&lt;/code&gt; key. Using the &lt;code&gt;network-only&lt;/code&gt; key, which is the default behavior, ignores data already present in the store and waits for the network results to come back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b9d698f04dcb6c9b4de74dbaccc7db4327ebbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: &lt;strong&gt;Optional&lt;/strong&gt; Array of strings that belong to the set of argument variables defined for the connection field (e.g. &lt;code&gt;orderBy&lt;/code&gt;, &lt;code&gt;searchTerm&lt;/code&gt;, etc). The values for the variables specified in this array will be used alongside the user-supplied &lt;code&gt;key&lt;/code&gt; to uniquely identify a connection. If &lt;code&gt;filters&lt;/code&gt; is not provided, by default Relay will use the set of all of the arguments the connection field takes, excluding pagination specific arguments (i.e. &lt;code&gt;first&lt;/code&gt;/&lt;code&gt;last&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;/&lt;code&gt;before&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a65d389a718020e07ebee40da7bdd44c16a4420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: An object containing GraphQL calls e.g. &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; : объект, содержащий вызовы GraphQL, например, &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="499b17304b2bef431abd97d0542599af80ca0ff3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;force&lt;/code&gt;: If the &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; has been configured with a cache, this option forces a refetch even if the data for this query and variables is already available in the cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41eb5ef20bb9fe4e11e5a7ba243c250838991a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; Whether to send a server request regardless of data available on the client.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; Следует ли отправлять запрос к серверу независимо от данных, доступных на клиенте.</target>
        </trans-unit>
        <trans-unit id="d556d0cc8a6f2287f3af67eacd90ec1629094411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; может быть вызван с пустым набором частичных переменных, что означает, что он может запускать обновление текущего визуализированного набора данных.</target>
        </trans-unit>
        <trans-unit id="7c4e5ec515c48d1d775f76f1e41f31d520e97786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; is similar to &lt;code&gt;setVariables&lt;/code&gt; because it is also used to change the data requirements by altering &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; похож на &lt;code&gt;setVariables&lt;/code&gt; , потому что он также используется для изменения требований к данным путем изменения &lt;code&gt;variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="690e2c556d1d75133f45a6c4a69283c5b06e6d4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentSpec&lt;/code&gt;: Specifies the data requirements for the Component via a GraphQL fragment. It is expected that one of the fragments specified here will contain a &lt;a href=&quot;#connection&quot;&gt;&lt;code&gt;@connection&lt;/code&gt;&lt;/a&gt; for pagination. The required data will be available on the component as props that match the shape of the provided fragment. &lt;code&gt;fragmentSpec&lt;/code&gt; should be an object whose keys are prop names and values are &lt;code&gt;graphql&lt;/code&gt; tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebe3bc29a0cf52244f436e5b9f683f8e5e726a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentSpec&lt;/code&gt;: Specifies the data requirements for the Component via a GraphQL fragment. The required data will be available on the component as props that match the shape of the provided fragment. &lt;code&gt;fragmentSpec&lt;/code&gt; should be an object whose keys are prop names and values are &lt;code&gt;graphql&lt;/code&gt; tagged fragments. Each key specified in this object will correspond to a prop available to the resulting Component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c6f70e52f47838301be68f3a7fc35ddbd14be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragments&lt;/code&gt; Declare the component's data requirements using fragments.</source>
          <target state="translated">&lt;code&gt;fragments&lt;/code&gt; Объявите требования компонента к данным с помощью фрагментов.</target>
        </trans-unit>
        <trans-unit id="f347d7322bb64c982a8914c374d1d9989d23caa9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getConnectionFromProps&lt;/code&gt;: Function that should indicate which connection to paginate over, given the fragment props (i.e. the props corresponding to the &lt;code&gt;fragmentSpec&lt;/code&gt;). This is necessary in most cases because the Relay can't automatically tell which connection you mean to paginate over (a container might fetch multiple fragments and connections, but can only paginate one of them). If not provided, Relay will try infer the correct connection to paginate over based on the provided &lt;code&gt;@connection&lt;/code&gt; directive. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffcebb96656094f38726e63b34eb65150f50c9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Get a reference to a container fragment for inclusion in a parent fragment.</source>
          <target state="translated">&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Получить ссылку на фрагмент контейнера для включения в родительский фрагмент.</target>
        </trans-unit>
        <trans-unit id="cff5af6182f7fb8ef3f8ecccc18f0ba0cbe50adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragmentVariables&lt;/code&gt;: Function that should return the bag of variables to use for reading out the data from the store when re-rendering the component. This function takes the previous set of variables passed to the pagination &lt;code&gt;query&lt;/code&gt;, and the number of elements that have been fetched in total so far. Specifically, this indicates which variables to use when reading out the data from the local data store &lt;em&gt;after&lt;/em&gt; the new pagination &lt;code&gt;query&lt;/code&gt; has been fetched. If not specified, Relay will default to using all of the previous variables and using the total count for the &lt;code&gt;count&lt;/code&gt; variable. This option is analogous to &lt;a href=&quot;refetch-container#refetch&quot;&gt;&lt;code&gt;renderVariables&lt;/code&gt;&lt;/a&gt; in the Refetch Container. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="626651fb7fc8a336ea351887a559499388854ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getVariables&lt;/code&gt;: Function that should return the variables to pass to the pagination &lt;code&gt;query&lt;/code&gt; when fetching it from the server, given the current &lt;code&gt;props&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;cursor&lt;/code&gt;. You may set whatever variables here, as well as modify the defaults to use for after/first/before/last arguments. See our &lt;a href=&quot;#pagination-example&quot;&gt;example&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a5a41dfd716e53597f64c88977873298358ac32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasMore&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. This function indicates whether there are more pages to fetch from the server or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1035c3f8ef8bea7423860896c5ab932f003bfcca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasMore&lt;/code&gt;: See &lt;code&gt;hasMore&lt;/code&gt;&lt;a href=&quot;#hasmore&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2af946a8f787de1546269d02d1783ad16d7ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialVariables&lt;/code&gt; The initial set of variable values available to this component's fragments.</source>
          <target state="translated">&lt;code&gt;initialVariables&lt;/code&gt; Начальный набор значений переменных, доступных для фрагментов этого компонента.</target>
        </trans-unit>
        <trans-unit id="b0b6cb762b7bc1dde73e00ccfd867874ca46a854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isLoading&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. This function indicates if a previous call to &lt;a href=&quot;#loadmore&quot;&gt;&lt;code&gt;loadMore()&lt;/code&gt;&lt;/a&gt; is still pending. This is convenient for avoiding duplicate load calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3cf1633778c794a6d5137a6fc7ee91e9dc015a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isLoading&lt;/code&gt;: See &lt;code&gt;isLoading&lt;/code&gt;&lt;a href=&quot;#isloading&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96bf65801e1e45617b0b7293698801c726cb5a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key&lt;/code&gt;: &lt;strong&gt;Required&lt;/strong&gt; String that serves as a unique identifier for the connection under the parent field type. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699706e765e60007f25a7dad7551d2b11ce95c76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadMore&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. You can call &lt;code&gt;loadMore()&lt;/code&gt; to fetch more items from the server based on the &lt;code&gt;connectionConfig&lt;/code&gt; provided to the container. This will return null if there are no more items to fetch, otherwise it will fetch more items and return a Disposable that can be used to cancel the fetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fe3cacb8f804fae55fb785b3fe1234cd03400a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loadMore&lt;/code&gt;: See &lt;code&gt;loadMore&lt;/code&gt;&lt;a href=&quot;#loadmore&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76264748ee4f7e2b85f5ec429b655faa6e2afb7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lookup(selector: Selector): Snapshot&lt;/code&gt;: Reads the results of a selector from the store, returning the value given the data currently in the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b36321c1572c121ad403c4633eda3e50781805" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563c728f73a72af11f9bfebcd489b1605c4ad5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; : &lt;code&gt;graphql&lt;/code&gt; на мутацию с тегами graphql .</target>
        </trans-unit>
        <trans-unit id="8757e61c041c5769ac4b56cae5108d1ce8243f0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify(): void&lt;/code&gt;: Calls any &lt;code&gt;subscribe()&lt;/code&gt;-ers whose results have changed due to intervening &lt;code&gt;publish()&lt;/code&gt;-es. Separating &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; allows for multiple payloads to be published before performing any downstream update logic (such as rendering).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bfa68e762b718f3167374497af4ce681b706e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: Callback function executed when the request is completed and the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt; function. Takes a &lt;code&gt;response&lt;/code&gt; object, which is the updated response from the store, and &lt;code&gt;errors&lt;/code&gt;, an array containing any errors from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6a934fa0ef96a565381122a89d9aee1a4fba9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed when the subscription is closed by the peer without error.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; : функция обратного вызова, выполняемая, когда подписка закрывается одноранговым узлом без ошибок.</target>
        </trans-unit>
        <trans-unit id="a715680a7bcdc7a8e18cff64218bee6c4c5f714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed with the 'raw' response and errors from the server after the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; : функция обратного вызова, выполняемая с &amp;laquo;необработанным&amp;raquo; ответом и ошибками от сервера после обновления хранилища реле в памяти с помощью средства &lt;code&gt;updater&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c178dbfaff171f363cbc5ee015a82adb2c39a56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: Callback function executed if Relay encounters an error during the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e17c27700518dd0a0d9e3907f0ead05f610d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay encounters an error.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; : функция обратного вызова, выполняемая, когда Relay обнаруживает ошибку.</target>
        </trans-unit>
        <trans-unit id="5632405e91380cb8466949662b4346c6b8f63bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay or the server encounters an error processing the subscription.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; : функция обратного вызова, выполняемая, когда Relay или сервер обнаруживает ошибку при обработке подписки.</target>
        </trans-unit>
        <trans-unit id="13f38fe85bb18ed69b3110347c91c063ca63f296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">&lt;code&gt;onFailure&lt;/code&gt; вызывается, если мутация не удалась.</target>
        </trans-unit>
        <trans-unit id="34b282489eb2fc659bf8f182ecccfa58a4f98bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; : функция обратного вызова, выполняемая каждый раз при получении ответа от сервера с необработанными полезными данными ответа GraphQL.</target>
        </trans-unit>
        <trans-unit id="b0c18e8b6186d7338bef8b15b59ec6ca63cd0225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded.</source>
          <target state="translated">&lt;code&gt;onSuccess&lt;/code&gt; вызывается, если мутация прошла успешно.</target>
        </trans-unit>
        <trans-unit id="f106ec445789577b27b8a00bf7ea0a1de269df16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: Object containing the data to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. This object must have the same shape as the mutation's response type, as defined by the GraphQL schema. If provided, Relay will use the &lt;code&gt;optimisticResponse&lt;/code&gt; data to update the fields on the relevant records in the local data store, &lt;em&gt;before&lt;/em&gt;&lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. If an error occurs during the mutation request, the optimistic update will be rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1dc36be8e9a3f9069b3ce5c93735b18dee1d9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: an object conforming to the mutation's response type definition. If provided, the optimistic response will be normalized to the proxy store before &lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. We suggest you provide an &lt;code&gt;optimisticResponse&lt;/code&gt; for two benefits:</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; : объект, соответствующий определению типа ответа мутации. Если предоставляется, оптимистичный ответ будет нормализован для прокси-хранилища перед выполнением &lt;code&gt;optimisticUpdater&lt;/code&gt; . Мы предлагаем вам дать &lt;code&gt;optimisticResponse&lt;/code&gt; на два преимущества:</target>
        </trans-unit>
        <trans-unit id="bbad0ba283ad50214764ae5e67837a37a21bb012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: Function used to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. If an error occurs during the mutation request, the optimistic update will be rolled back. This function takes a &lt;code&gt;store&lt;/code&gt;, which is a proxy of the in-memory &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;. In this function, the client defines 'how to' update the local data via the &lt;code&gt;store&lt;/code&gt; instance. For details on how to use the &lt;code&gt;store&lt;/code&gt;, please refer to our &lt;a href=&quot;relay-store&quot;&gt;Relay Store API Reference&lt;/a&gt;. &lt;strong&gt;Please note:&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace8dc4f2ade074a4518666a5d5ce3fc892c20c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: a function that takes in a proxy of the in-memory Relay store. In this function, the client defines 'how to' update the store through the proxy in an imperative way.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; : функция, которая принимает прокси хранилища реле в памяти. В этой функции клиент императивно определяет &amp;laquo;как&amp;raquo; обновлять хранилище через прокси.</target>
        </trans-unit>
        <trans-unit id="5c56eae08c5039c703ead5297dcb43b136ebc215" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options&lt;/code&gt;: Optional object containing set of options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1ee884cdcbedfd5023f2b423e04d3d21c8d4a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pageSize&lt;/code&gt;: The number of &lt;strong&gt;additional&lt;/strong&gt; items to fetch (not the total).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45ed0f29925a557b65dfee5d20499e8f93783ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parentID: string&lt;/code&gt;: The DataID of the parent node that contains the connection.</source>
          <target state="translated">&lt;code&gt;parentID: string&lt;/code&gt; : DataID родительского узла, содержащего соединение.</target>
        </trans-unit>
        <trans-unit id="90d6f234e369d7056e4a4a384ce4d56b75c66508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt;: An array containing the field names between the parent and the connection, including the parent and the connection.</source>
          <target state="translated">&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt; : массив, содержащий имена полей между родительским элементом и соединением, включая родительский элемент и соединение.</target>
        </trans-unit>
        <trans-unit id="ca3a99f863b6d6006d89f122d91acd2466426ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pendingVariables&lt;/code&gt; contains the set of variables that are being used to fetch the new props, i.e. when &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; or &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; are called and the corresponding request is in flight.</source>
          <target state="translated">&lt;code&gt;pendingVariables&lt;/code&gt; содержит набор переменных, которые используются для получения новых свойств, то есть когда &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; или &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; и соответствующий запрос находится в полете.</target>
        </trans-unit>
        <trans-unit id="5294d02523abdadc7890c4089fd2d771e0103adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment or previous variable values.</source>
          <target state="translated">&lt;code&gt;prepareVariables&lt;/code&gt; Метод изменения переменных на основе среды выполнения или предыдущих значений переменных.</target>
        </trans-unit>
        <trans-unit id="27da47c52c7e5a8a5a90e5286ef17b4aff5e91dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt;: Object containing data obtained from the query; the shape of this object will match the shape of the query. If this object is not defined, it means that the data is still being fetched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5f419565d76e695cd1691d3b10750a870140ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;publish(source: RecordSource): void&lt;/code&gt;: Update the store with new information. All updates to the store are expressed in this form, including the results of queries/mutation/subscriptions as well as optimistic mutation updates. All of those operations internally create a new &lt;code&gt;RecordSource&lt;/code&gt; instance and ultimately publish it to the store. Note that &lt;code&gt;publish()&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; immediately update any &lt;code&gt;subscribe()&lt;/code&gt;-ers. Internally, the store compares the new &lt;code&gt;RecordSource&lt;/code&gt; with its internal source, updating it as necessary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dddbd60d4182ffffea94bf3a02f0ae852dd10463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: A &lt;code&gt;graphql&lt;/code&gt; tagged query to be used as the pagination query to fetch more data upon calling &lt;a href=&quot;#loadmore&quot;&gt;&lt;code&gt;loadMore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7736ddcb416c3d04d04b11455e591b874d6eeb31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged query. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces the query to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="676a2960bbec143afaff222f0801213498fb3f55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;query&lt;/code&gt;: The &lt;code&gt;graphql&lt;/code&gt; tagged query. &lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces the query to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;Query&lt;/code&gt;. Optional, if not provided, an empty &lt;code&gt;props&lt;/code&gt; object is passed to the &lt;code&gt;render&lt;/code&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e836212ec7a6f4cf39b03986865be121a0bbd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` or `Relay.Route` that defines the query roots.</source>
          <target state="translated">&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` или` Relay.Route`, который определяет корни запроса.</target>
        </trans-unit>
        <trans-unit id="660ec684b77a45a8bf1e84dae51a6cda4f520d7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58466669d85d4a95720a5f7d66d78440d31839cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt; which can be used to execute the &lt;code&gt;refetchQuery&lt;/code&gt; and potentially re-render the component with the newly fetched data. Specifically, upon fetching the &lt;code&gt;refetchQuery&lt;/code&gt;, its result will be normalized into the store, and any relevant subscriptions associated with the changed records will be fired, causing relevant components to re-render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac65c56250fa7ff709fdc7de7fca9f97dfd96bfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetch&lt;/code&gt;: See &lt;code&gt;refetch&lt;/code&gt;&lt;a href=&quot;#refetch&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ca6f4f7119df5fafa685e8fb3699107703e078" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchConnection&lt;/code&gt; is a function available on the &lt;code&gt;relay&lt;/code&gt;&lt;a href=&quot;#available-props&quot;&gt;prop&lt;/a&gt;. You can call &lt;code&gt;refetchConnection&lt;/code&gt; to restart pagination on a connection from scratch, with optionally a completely new set of variables to pass to the pagination &lt;code&gt;query&lt;/code&gt;. This is useful for example if you are paginating over a collection based on a userID and the userID changes, you'd want to start paginating over the new collection for the new user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef81b21678260e29c69b60a2bcfd25a86847861" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchConnection&lt;/code&gt;: See &lt;code&gt;refetchConnection&lt;/code&gt;&lt;a href=&quot;#refetchconnection&quot;&gt;docs&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10676cecd666f761ab642682bd7775c74b16d502" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchQuery&lt;/code&gt;: A &lt;code&gt;graphql&lt;/code&gt; tagged query to be fetched upon calling &lt;a href=&quot;#refetch&quot;&gt;&lt;code&gt;props.relay.refetch&lt;/code&gt;&lt;/a&gt;. As with any query, upon fetching this query, its result will be normalized into the store, any relevant subscriptions associated with the changed records will be fired, and subscribed components will re-render.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d83449d21fcdf971b3e1c1d76474fe6f62d3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt; is either a bag of variables or a function that takes in the previous fragment variables and returns new variables.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; - это либо набор переменных, либо функция, которая принимает переменные предыдущего фрагмента и возвращает новые переменные.</target>
        </trans-unit>
        <trans-unit id="d29742cf5cf442b9264eba2a1008fd847c52bb3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="82c4436a668f413322c65f8837cdeba1c55ebf58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt;: A potentially new bag of variables to pass to the pagination &lt;code&gt;query&lt;/code&gt; when fetching it from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccac01b26009021b9b8585de4682fa623cd62b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;relay&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;relay&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="4ae4f5a5447be2154beefea2867a35b518a781d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; Вызывается для рендеринга при выполнении требований к данным.</target>
        </trans-unit>
        <trans-unit id="3a3d4b8d0af15655fd443916c3671fd28e5c8260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt;: Function of type &lt;code&gt;({error, props, retry}) =&amp;gt; React.Node&lt;/code&gt;. The output of this function will be rendered by the &lt;code&gt;QueryRenderer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e1260e99e337d383bed6b4b9c2df2228a1e749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFailure&lt;/code&gt; Called to render when data failed to be fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; Вызывается для рендеринга, когда данные не могут быть выполнены.</target>
        </trans-unit>
        <trans-unit id="a6131b3d70611a404b4ea7dd80f5758c5105f7c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFetched&lt;/code&gt; Called to render when data requirements are fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; Вызывается для визуализации при выполнении требований к данным.</target>
        </trans-unit>
        <trans-unit id="1901f50529efd372e2c626214284f332709348a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderLoading&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; Вызывается для визуализации при выполнении требований к данным.</target>
        </trans-unit>
        <trans-unit id="b0fe2435dec450eee6998923c41267267d40d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt; is an optional param that tells Relay which variables to use at when the component is re-rendered after fetching. Without this, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. You might use this for more advanced usage, for example, to implement pagination, where you would fetch an additional page with variables like &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt;, but you would then render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; - это необязательный параметр, который сообщает Relay, какие переменные использовать при повторной визуализации компонента после выборки. Без этого будут использоваться &lt;code&gt;refetchVariables&lt;/code&gt; . Вы можете использовать это для более продвинутого использования, например, для реализации разбивки на страницы, когда вы будете извлекать дополнительную страницу с такими переменными, как &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt; , но затем вы бы визуализировали полную коллекцию с помощью &lt;code&gt;{first: 10}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d435346ad63d7a3c79570642e3436876c685e77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt;: Optional bag of variables that indicate which variables to use for reading out the data from the store when re-rendering the component. Specifically, this indicates which variables to use when querying the data from the local data store &lt;em&gt;after&lt;/em&gt; the new query has been fetched. If not specified, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. This is useful when the data you need to render in your component doesn't necessarily match the data you queried the server for. For example, to implement pagination, you would fetch a page with variables like &lt;code&gt;{first: 5, after: '&amp;lt;cursor&amp;gt;'}&lt;/code&gt;, but you might want to render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a7275c94b7363157c7bfb49920e6d9a95cf6ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retain(selector: Selector): Disposable&lt;/code&gt;: Ensure that all the records necessary to fulfill the given selector are retained in-memory. The records will not be eligible for garbage collection until the returned reference is disposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d78182a7d6ce562110f2264694e37c53c96b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;retry&lt;/code&gt;: Reload the data. It is null if &lt;code&gt;query&lt;/code&gt; was not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cef4511de2692e7e2831022f07230dabf3496cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt; Route that defines the query roots.</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; Маршрут, определяющий корни запроса.</target>
        </trans-unit>
        <trans-unit id="de20a20a67577265acad0e1c8760490f6ae7d671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setVariables&lt;/code&gt; does not immediately mutate &lt;code&gt;variables&lt;/code&gt;, but creates a pending state transition. &lt;code&gt;variables&lt;/code&gt; will continue returning the previous values until &lt;code&gt;this.props&lt;/code&gt; has been populated with data that fulfills the new variable values.</source>
          <target state="translated">&lt;code&gt;setVariables&lt;/code&gt; не изменяет &lt;code&gt;variables&lt;/code&gt; немедленно , но создает отложенный переход состояния. &lt;code&gt;variables&lt;/code&gt; будут продолжать возвращать предыдущие значения до тех пор, пока &lt;code&gt;this.props&lt;/code&gt; не будет заполнен данными, которые соответствуют новым значениям переменных.</target>
        </trans-unit>
        <trans-unit id="943d019e3b13e343df13a6484ab6136c7156b4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Optionally override RelayContainer's default implementation of `shouldComponentUpdate`.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Необязательно переопределить реализацию RelayContainer по умолчанию shouldComponentUpdate.</target>
        </trans-unit>
        <trans-unit id="c12be4a70a038cd4741cb2b9e30195491469abee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid Relay container.</source>
          <target state="translated">&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; Валидатор типа свойства, утверждающий, что свойство является допустимым контейнером Relay.</target>
        </trans-unit>
        <trans-unit id="3b4467abcecc2f5f6147438c2f223473973407a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid route.</source>
          <target state="translated">&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; Валидатор типа свойства, утверждающий, что свойство является допустимым маршрутом.</target>
        </trans-unit>
        <trans-unit id="40e983f1da84aaeb0774f71c8242e17b35be1f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Adds a MutationTransaction to the queue without committing it.</source>
          <target state="translated">&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Добавляет MutationTransaction в очередь, не фиксируя ее.</target>
        </trans-unit>
        <trans-unit id="b4d03961b864a4ab573535d598407abfc411cce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Initiate processing of a mutation.</source>
          <target state="translated">&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Инициировать обработку мутации.</target>
        </trans-unit>
        <trans-unit id="9eebf1a07ed283d2bbed2b968ffb38df36fad9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Create a static mutation</source>
          <target state="translated">&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Создать статическую мутацию</target>
        </trans-unit>
        <trans-unit id="658d18c4b39964f6d9e02a8d4f13d6ca5179a919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Creates a Relay Container.</source>
          <target state="translated">&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Создает контейнер ретрансляции.</target>
        </trans-unit>
        <trans-unit id="ac50a770322cba5b662ec0bbf60235d57453db96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Create a static mutation that accepts a &quot;files&quot; object</source>
          <target state="translated">&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Создать статическую мутацию, которая принимает объект &quot;файлы&quot;</target>
        </trans-unit>
        <trans-unit id="a985a4f33765191da82de5eb97d6c665b299a3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static fragments&lt;/code&gt; Declare this mutation's data dependencies here</source>
          <target state="translated">&lt;code&gt;static fragments&lt;/code&gt; Объявите здесь зависимости данных мутации</target>
        </trans-unit>
        <trans-unit id="a1697fb2f2da73763242483e979b5b34e6797e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static initialVariables&lt;/code&gt; A default set of variables to make available to this mutation's fragment builders</source>
          <target state="translated">&lt;code&gt;static initialVariables&lt;/code&gt; Набор переменных по умолчанию, которые будут доступны разработчикам фрагментов этой мутации.</target>
        </trans-unit>
        <trans-unit id="9ac61312fa144b893336d3bbdf88826d0034494e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Customize how queries and mutations are sent to the server.</source>
          <target state="translated">&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Настроить, как запросы и мутации отправляются на сервер.</target>
        </trans-unit>
        <trans-unit id="49b31e2fd0ee618819eb9668ad9fab057dc448c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure when Relay processing occurs.</source>
          <target state="translated">&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Настроить при обработке ретрансляции.</target>
        </trans-unit>
        <trans-unit id="3e8afe33d507124df2cb20b712a24c4d395ceeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determine if a given object is a Relay.Container.</source>
          <target state="translated">&lt;code&gt;static isContainer(Component)&lt;/code&gt; Определяет, является ли данный объект Relay.Container.</target>
        </trans-unit>
        <trans-unit id="7938dae1f9d2455348151916c16933ea1c4109f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static paramDefinitions&lt;/code&gt; Declare the expected parameters.</source>
          <target state="translated">&lt;code&gt;static paramDefinitions&lt;/code&gt; Объявите ожидаемые параметры.</target>
        </trans-unit>
        <trans-unit id="047db3ec3d910088d59dd144e9064188d5d64b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareParams&lt;/code&gt; Declare additional parameters or conversion for parameters.</source>
          <target state="translated">&lt;code&gt;static prepareParams&lt;/code&gt; Объявляет дополнительные параметры или преобразование для параметров.</target>
        </trans-unit>
        <trans-unit id="4b2b9762a4218dc52cee63114d0eee0ed5d04c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment, previous variables, or the meta route</source>
          <target state="translated">&lt;code&gt;static prepareVariables&lt;/code&gt; Метод для изменения переменных на основе среды выполнения, предыдущих переменных или мета-маршрута.</target>
        </trans-unit>
        <trans-unit id="2b49e3d2f4dae0d69deb0f6c24085a44cc8a3c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static queries&lt;/code&gt; Declare the set of query roots.</source>
          <target state="translated">&lt;code&gt;static queries&lt;/code&gt; Объявите набор корней запроса.</target>
        </trans-unit>
        <trans-unit id="0c43ab95deb00b1e6ba46964ae86ac05d717b874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static routeName&lt;/code&gt; Declare the name of this route class.</source>
          <target state="translated">&lt;code&gt;static routeName&lt;/code&gt; Объявите имя этого класса маршрута.</target>
        </trans-unit>
        <trans-unit id="4d2883724190fe655277a940ee21fbf4028c5557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe(snapshot: Snapshot, callback: (snapshot: Snapshot) =&amp;gt; void): Disposable&lt;/code&gt;: Subscribe to changes to the results of a selector. The callback is called when data has been published to the store that would cause the results of the snapshot's selector to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91acf728df7357ed2ba9977f2e4aae1aa271198d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscription&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged subscription query.</source>
          <target state="translated">&lt;code&gt;subscription&lt;/code&gt; : &lt;code&gt;graphql&lt;/code&gt; подписки с тегами graphql .</target>
        </trans-unit>
        <trans-unit id="12ff8bacf233237929ba38ec484648a655ad7959" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</source>
          <target state="translated">&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; может быть вызван для обновления подмножества или всех переменных одновременно. В свою очередь, Relay будет использовать новые переменные, чтобы попытаться выполнить новый фрагмент. Это может включать отправку запроса на сервер, если данные еще не доступны на клиенте.</target>
        </trans-unit>
        <trans-unit id="c005f6461f75206bcbc927906f1de20a4cf2e450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exports the following API to execute the refetch query:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; экспортирует следующий API для выполнения запроса refetch:</target>
        </trans-unit>
        <trans-unit id="7d9577972a7c4a8c614b22a037eaeff82248e3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exposes the following APIs:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; предоставляет следующие API:</target>
        </trans-unit>
        <trans-unit id="3d07b37e84a778ceb1461d9bbc1f056984d50a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.setVariables&lt;/code&gt; from the old API does not have a direct equivalent in the new API. A big reason for this change is that the new core no longer tracks how to refetch any specific sub-tree from the query. This makes the new core a lot faster, but requires explicit queries for how to fetch new data. Check out these four different scenarios:</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; из старого API не имеет прямого эквивалента в новом API. Основная причина этого изменения заключается в том, что новое ядро ​​больше не отслеживает, как повторно выбирать какое-либо конкретное поддерево из запроса. Это делает новое ядро ​​намного быстрее, но требует явных запросов о том, как получать новые данные. Посмотрите на эти четыре разных сценария:</target>
        </trans-unit>
        <trans-unit id="63392efb72105686affa5267c72c15150a57d7b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;totalCount&lt;/code&gt;: The total number of elements to fetch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ba6c9e4640fb1b2e64f085573522ecee404aff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt; and &lt;code&gt;optimisticUpdater&lt;/code&gt; are functions that you can pass to a &lt;code&gt;commitMutation&lt;/code&gt; call when you need full control over how to update the local data store, either optimistically, or based on a server response. Often times, both of these can be the same function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259e28d5505528a6b53e6871c75fe6204e8b732e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: Function used to update the local in-memory store based on the &lt;strong&gt;real&lt;/strong&gt; server response from the mutation. If &lt;code&gt;updater&lt;/code&gt; is not provided, by default, Relay will know to automatically update the fields on the records referenced in the mutation response; however, you should pass an &lt;code&gt;updater&lt;/code&gt; if you need to make more complicated updates than just updating fields (e.g. deleting records or adding items to collections). When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and will then execute &lt;code&gt;updater&lt;/code&gt;. This function takes a &lt;code&gt;store&lt;/code&gt;, which is a proxy of the in-memory &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;. In this function, the client defines 'how to' update the local data based on the server response via the &lt;code&gt;store&lt;/code&gt; instance. For details on how to use the &lt;code&gt;store&lt;/code&gt;, please refer to our &lt;a href=&quot;relay-store&quot;&gt;Relay Store API Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ab1a5db284767b82e6bbe83b1d6bb7782d76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: a function that updates the in-memory Relay store based on the &lt;strong&gt;real&lt;/strong&gt; server response. When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and then applies the &lt;code&gt;updater&lt;/code&gt; to the store.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; : функция, которая обновляет хранилище реле в памяти на основе &lt;strong&gt;реального&lt;/strong&gt; ответа сервера. Когда возвращается ответ сервера, Relay сначала отменяет любые изменения, внесенные &lt;code&gt;optimisticUpdater&lt;/code&gt; или &lt;code&gt;optimisticResponse&lt;/code&gt; , а затем применяет &lt;code&gt;updater&lt;/code&gt; к хранилищу.</target>
        </trans-unit>
        <trans-unit id="9e752995a456f07b23c9c5955036c90c0eaa7d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; : дополнительная функция, которая может предоставлять настраиваемую логику для обновления хранилища реле в памяти на основе ответа сервера.</target>
        </trans-unit>
        <trans-unit id="ed67a9853586c7a825bf549e62d6668d890318cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt; contains the set of variables that was used to fetch the current set of props.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; содержат набор переменных, которые использовались для получения текущего набора свойств.</target>
        </trans-unit>
        <trans-unit id="90132fff5a43a587dfddbf62f547768d85225cbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2d4dca964b4002488e5ba0931c7fdd0e1843a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing set of variables to pass to the GraphQL query, i.e. a mapping from variable name to value. &lt;strong&gt;Note:&lt;/strong&gt; If a new set of variables is passed, the &lt;code&gt;QueryRenderer&lt;/code&gt; will re-fetch the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0475335b0b11da8a5bdf97828dbf873aa0e03035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: Object containing the variables needed for the mutation. For example, if the mutation defines an &lt;code&gt;$input&lt;/code&gt; variable, this object should contain an &lt;code&gt;input&lt;/code&gt; key, whose shape must match the shape of the data expected by the mutation as defined by the GraphQL schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e388933696fbe367df975da86d5ab73799cb8d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the mutation.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; : объект, содержащий переменные, необходимые для мутации.</target>
        </trans-unit>
        <trans-unit id="6e219c17510eb13b16577519ca778d9468c7499a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the subscription.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; : объект, содержащий переменные, необходимые для подписки.</target>
        </trans-unit>
        <trans-unit id="a3d9fd11099be9837becddb07ecac412bfe16922" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt; is deprecated. Use &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt;&lt;code&gt;babel-plugin-relay&lt;/code&gt;&lt;/a&gt; with Relay Classic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; устарел. Используйте &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt; &lt;code&gt;babel-plugin-relay&lt;/code&gt; &lt;/a&gt; с Relay Classic.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="885b12f18c1ce790e1ceb37bdac14666bf969046" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Container Specification&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Спецификация контейнера&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc48bdb0f1a664344b42c6cc9f80bf54c93c0af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Methods&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="372322cdb4339a090833f173c5459433d9f3a2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties and Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Свойства и методы&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e24a7da3b4c78d1c9bb8ad4a5672d259fcf1c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b288f7cf5165d63b23f3a477f7c62696473947e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Props&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Props&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c13abeef99d46d6cc5a5891d80bde92ef26cfbac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Статические методы&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0677ff5e5e4c313a098291e00353714c69a25eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; в&lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a854faa5d5c2fb2a3f2a62f519c3dae0ea44c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; на&lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6882e7b1150b43a134cd9463ab13037397e9d8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; на&lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4615a7abdf175713f1dd713a45e9b36b49db0dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; в&lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt; npm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cf00569ac1dc01caeaaea97e38c45c13b4f2663" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/relay-tools/react-relay-network-modern&quot;&gt;react-relay-network-modern&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/react-relay-network-modern&quot;&gt;npm&lt;/a&gt; - is a Network Layer for Relay Modern which has built-in highly customizable middlewares for commonly used scenarios: batching query requests, caching, authentication, request retrying, logging. Moreover, you may write your own middlewares with custom logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57698c2dcaa9317f5b6564784890d536ca0db31a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;Quickstart tutorial&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;strong&gt; Краткое&lt;/strong&gt;&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt; руководство&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3ff63fe8231293f18f4614046a48a3f375957330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An optimistic update may only be applied once.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Оптимистичное обновление можно применить только один раз.</target>
        </trans-unit>
        <trans-unit id="5a6c17b257e2cfbdb037b374e043ded0a3a0687b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Equivalent &lt;code&gt;applyUpdate&lt;/code&gt; and &lt;code&gt;commitUpdate&lt;/code&gt; methods are also provided on the &lt;code&gt;this.props.relay&lt;/code&gt; prop that is passed to components by &lt;code&gt;Relay.Container&lt;/code&gt;. These dispatch mutations in the context of the currently active &lt;code&gt;Relay.Environment&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Эквивалентные &lt;code&gt;applyUpdate&lt;/code&gt; и &lt;code&gt;commitUpdate&lt;/code&gt; также предоставляются в опоре &lt;code&gt;this.props.relay&lt;/code&gt; , которое передается компонентам с помощью &lt;code&gt;Relay.Container&lt;/code&gt; . Эти отправляют мутации в контексте текущего активного &lt;code&gt;Relay.Environment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ddd68157613fe72f3a31d973424adc5689fd03d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The relay-compiler will maintain any directives supported by your server (such as &lt;code&gt;@include&lt;/code&gt; or &lt;code&gt;@skip&lt;/code&gt;) so they remain part of the request to the GraphQL server and won't alter generated runtime artifacts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9339553ac0cb3d1045417a0b2b8896e539d03c5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;refetch&lt;/code&gt; is meant to be used for changing variables in the component's fragment. Specifically, in order for &lt;em&gt;this&lt;/em&gt; component to re-render, it must be subscribed to changes in the records affected by this query. If the fragment for the component doesn't use variables, the component won't be subscribed to changes to new records that might be fetched by this query. A common example of this is using &lt;code&gt;refetch&lt;/code&gt; to fetch a new node and re-render the component with the data for the new node; in this case the fragment needs to use a variable for the node's id, otherwise the component won't pick up the changes for the new node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce6daad416ee7ed28c950cdb80e05140a6ea38d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;relay-compiler&lt;/code&gt; enforces fragments to be named as &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cab013d8e57c0158f4b400d4d762529e18b3a5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this will not remove it from any connection it might be in. If you want to remove a node from a connection, take a look at &lt;a href=&quot;#RANGE_DELETE&quot;&gt;RANGE_DELETE&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b283c8b5fe80a6754d48027d166c1b33cf5b5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React/Relay:&lt;/strong&gt; A high-level &lt;em&gt;product API&lt;/em&gt; that integrates the Relay Runtime with React. This is the primary public interface to Relay for most product developers, featuring APIs to fetch the data for a query or define data dependencies for reusable components (aka containers).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdd8302b44cc971aea46ff3458176ce0281a174" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay Compiler:&lt;/strong&gt; A GraphQL to GraphQL optimizing &lt;em&gt;compiler&lt;/em&gt;, providing general utilities for transforming and optimizing queries as well as generating build artifacts. A novel feature of the compiler is that it facilitates experimentation with new GraphQL features - in the form of custom directives - by making it easy to translate code using these directives into standard, spec-compliant GraphQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b7a80e6d04a3ccce4e25ffec6090751cc2e7f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay Runtime:&lt;/strong&gt; A full-featured, high-performance GraphQL &lt;em&gt;runtime&lt;/em&gt; that can be used to build higher-level client APIs. The runtime features a normalized object cache, optimized &quot;write&quot; and &quot;read&quot; operations, a generic abstraction for incrementally fetching field data (such as for pagination), garbage collection for removing unreferenced cache entries, optimistic mutations with arbitrary logic, support for building subscriptions and live queries, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d08f9d41d143a0795971f924c815549c54cd145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Container&lt;/strong&gt; lets components declare fragments.</source>
          <target state="translated">&lt;strong&gt;Relay.Container&lt;/strong&gt; позволяет компонентам объявлять фрагменты.</target>
        </trans-unit>
        <trans-unit id="90f9832c4e0fd7965e487450fd253cb3d30e8335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Renderer&lt;/strong&gt; is a replacement for &lt;code&gt;Relay.RootContainer&lt;/code&gt; that composes a &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; and performs data fetching for a given &lt;code&gt;queryConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.Renderer&lt;/strong&gt; является заменой &lt;code&gt;Relay.RootContainer&lt;/code&gt; , который составляет &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; и выполняет выборку данных для заданного &lt;code&gt;queryConfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e196f3c49ca550a94a96a6bd405ee5ae569ab33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; принимает три необязательных обратных вызова в качестве &lt;strong&gt;свойств,&lt;/strong&gt; которые дают нам более точный контроль над поведением рендеринга.</target>
        </trans-unit>
        <trans-unit id="39c403bfc5a5ae739fbb717b4e88e8b5cb484d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; also supports the &lt;code&gt;onReadyStateChange&lt;/code&gt; prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; также поддерживает &lt;strong&gt;опцию &lt;/strong&gt; &lt;code&gt;onReadyStateChange&lt;/code&gt; , которая позволяет нам получать детализированные события по мере их возникновения при соблюдении требований к данным.</target>
        </trans-unit>
        <trans-unit id="3d6f9d2435421026549fceef7e0844d153a49bfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt; for a given &lt;code&gt;route&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; - это компонент React, который пытается выполнить данные, необходимые для рендеринга экземпляра &lt;code&gt;Component&lt;/code&gt; для заданного &lt;code&gt;route&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2469cd762b58409f3e67b96bf307621bbbfad9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that, given a &lt;code&gt;Component&lt;/code&gt; and a &lt;code&gt;route&lt;/code&gt;, attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; - это компонент React, который, учитывая &lt;code&gt;Component&lt;/code&gt; и &lt;code&gt;route&lt;/code&gt; , пытается выполнить данные, необходимые для визуализации экземпляра &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a1abc25b49b43dce645669aa17f103661474d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; changes.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; отображает состояние загрузки всякий раз, когда не может сразу выполнить данные, необходимые для визуализации. Это часто происходит при первоначальном рендеринге, но также может произойти при изменении &lt;code&gt;Component&lt;/code&gt; или &lt;code&gt;route&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81df685053c0d0bd1d2397325ab50c0f55f7ca06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Route&lt;/strong&gt; lets us declare query roots.</source>
          <target state="translated">&lt;strong&gt;Relay.Route&lt;/strong&gt; позволяет нам объявлять корни запросов.</target>
        </trans-unit>
        <trans-unit id="c9948e83f56c83dcc4c3f5e36e015ebfe88bc455" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React Component at the root of a Relay component tree. It takes a query, fetches the given query, and uses the &lt;code&gt;render&lt;/code&gt; prop to render the resulting data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d333726339af1440c557b36d8dd062e5747d248a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React component, so it can be rendered anywhere that a React component can be rendered, not just at the top level. A &lt;code&gt;QueryRenderer&lt;/code&gt; can be rendered &lt;em&gt;within&lt;/em&gt; other Relay components, for example to lazily fetch additional data for a popover. However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to avoidable request waterfalls if used unnecessarily.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; является React компонента, поэтому он может быть вынесен в любом месте , что React компонент может быть вынесено, а не только на верхнем уровне. &lt;code&gt;QueryRenderer&lt;/code&gt; может быть вынесен в &lt;em&gt;рамках&lt;/em&gt; других компонентов Relay, например , для извлечения лениво дополнительные данных для пирог. Однако &lt;code&gt;QueryRenderer&lt;/code&gt; не начнет загружать свои данные до тех пор, пока он не будет смонтирован, поэтому вложенные компоненты &lt;code&gt;QueryRenderer&lt;/code&gt; могут привести к предотвращаемым водопадам запросов, если они используются без необходимости.</target>
        </trans-unit>
        <trans-unit id="27c70649f28d5c13e5a545686407c1d433b45c24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</source>
          <target state="translated">&lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; конфигурация используется для добавления дополнительных детей к запросу мутации. Вам может потребоваться использовать это, например, для выборки полей нового объекта, созданного мутацией (и который Relay обычно не будет пытаться получить, потому что он ранее ничего не извлекал для этого объекта).</target>
        </trans-unit>
        <trans-unit id="b0405a3f3745cc21b6e57c41715133d0cedd35b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RefetchContainer&lt;/code&gt; first renders like a regular &lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;FragmentContainer&lt;/code&gt;&lt;/a&gt;, but has the option to execute a new query with different variables and render the response of that query instead when the request comes back.</source>
          <target state="translated">&lt;code&gt;RefetchContainer&lt;/code&gt; первым делает как обычный &lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;FragmentContainer&lt;/code&gt; &lt;/a&gt; , но имеет возможность выполнить новый запрос с различными переменными и визуализировать реакцию этого запроса вместо когда запрос возвращается.</target>
        </trans-unit>
        <trans-unit id="0b6b1500d0098058dc174f969740040bdd6fdf14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;renderLoading&lt;/code&gt; callback can simulate the default behavior by returning &lt;code&gt;undefined&lt;/code&gt;. Notice that this is different from a &lt;code&gt;renderLoading&lt;/code&gt; callback that returns &lt;code&gt;null&lt;/code&gt;, which would render nothing whenever data is loading, even if there was a previous view rendered.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; обратного вызова может имитировать поведение по умолчанию, возвращая &lt;code&gt;undefined&lt;/code&gt; . Обратите внимание, что это отличается от обратного вызова &lt;code&gt;renderLoading&lt;/code&gt; , который возвращает значение &lt;code&gt;null&lt;/code&gt; , которое ничего не будет отображать при загрузке данных, даже если было выполнено предыдущее представление.</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">Полный пример</target>
        </trans-unit>
        <trans-unit id="961bc4600b75e68461ede605310ceced00dd4863" translate="yes" xml:space="preserve">
          <source>A Fragment Container is a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt; that allows components to specify their data requirements. A container does not directly fetch data, but instead declares a &lt;em&gt;specification&lt;/em&gt; of the data needed for rendering, and then Relay will guarantee that this data is available &lt;em&gt;before&lt;/em&gt; rendering occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584bb673c7430dcef36b698acb079dd72be2262f" translate="yes" xml:space="preserve">
          <source>A GraphQL Schema</source>
          <target state="translated">Схема GraphQL</target>
        </trans-unit>
        <trans-unit id="b1a1d3fc840a0a6e5e8ca2b278d7769c45a98c33" translate="yes" xml:space="preserve">
          <source>A GraphQL Server</source>
          <target state="translated">Графический сервер GraphQL</target>
        </trans-unit>
        <trans-unit id="a7ee882612fb64b227df291f19a923de85574e53" translate="yes" xml:space="preserve">
          <source>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; and &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; to build our schema.</source>
          <target state="translated">Схема GraphQL описывает вашу модель данных и предоставляет серверу GraphQL связанный набор методов разрешения, которые знают, как получать данные. Мы будем использовать &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; и &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; для построения нашей схемы.</target>
        </trans-unit>
        <trans-unit id="48b78b689c15abba06f0159436cde03009fad264" translate="yes" xml:space="preserve">
          <source>A Refetch Container is also a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt; that works like a regular &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;, but provides the additional ability to fetch a new GraphQL query with different variables and re-render the component with the new result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc6cdf397779ac0008665fa5d7d262a02b419170" translate="yes" xml:space="preserve">
          <source>A bag of variables to pass to the &lt;code&gt;refetchQuery&lt;/code&gt; when fetching it from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6d86fdd10ea1168eecc22cdc48b9e22a21ad2d" translate="yes" xml:space="preserve">
          <source>A complete example</source>
          <target state="translated">Полный пример</target>
        </trans-unit>
        <trans-unit id="1b0ee223956194b51488ec093f18ce49cf32ed77" translate="yes" xml:space="preserve">
          <source>A description of how to page through connections.</source>
          <target state="translated">Описание того,как просматривать страницы через соединения.</target>
        </trans-unit>
        <trans-unit id="97b03c635c48a56b721c11e955de7b0b12f2ab52" translate="yes" xml:space="preserve">
          <source>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</source>
          <target state="translated">Описание вашей модели данных с соответствующим набором методов разрешения,которые знают,как получить любые данные,которые могут когда-либо понадобиться вашему приложению.</target>
        </trans-unit>
        <trans-unit id="cab997b4cd24ec902e4b83aaf3bf43dce9ec7836" translate="yes" xml:space="preserve">
          <source>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</source>
          <target state="translated">У фракции много кораблей во вселенной Звездных войн.Реле содержит функциональность,позволяющую легко манипулировать отношениями &quot;один-ко-многим&quot;,используя стандартизированный способ выражения этих отношений &quot;один-ко-многим&quot;.Эта стандартная модель соединения предлагает способы нарезки и пагинации через соединение.</target>
        </trans-unit>
        <trans-unit id="af85210772abecb804d78217a7325698b05fe83e" translate="yes" xml:space="preserve">
          <source>A generic mechanism for intercepting data prior to publishing it to the cache and either synthesizing new data or merging new and existing data together (which among other things enables the creation of a variety of pagination schemes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6dbe38242ad9f607665dc6e4fa2db4283cdd16" translate="yes" xml:space="preserve">
          <source>A map between a &lt;code&gt;fieldName&lt;/code&gt; in the response and one or more DataIDs in the store.</source>
          <target state="translated">&lt;code&gt;fieldName&lt;/code&gt; между fieldName в ответе и одним или несколькими DataID в магазине.</target>
        </trans-unit>
        <trans-unit id="6d94fea08321dcd17e29b42a404746fc50da107f" translate="yes" xml:space="preserve">
          <source>A map between printed, dot-separated GraphQL calls &lt;em&gt;in alphabetical order&lt;/em&gt; and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</source>
          <target state="translated">Карта между напечатанными, разделенными точками вызовами GraphQL &lt;em&gt;в алфавитном порядке&lt;/em&gt; и поведением, которое мы хотим, чтобы Relay демонстрировал при добавлении нового ребра к соединениям под влиянием этих вызовов или функции, принимающей массив аргументов соединения, возвращающей это поведение.</target>
        </trans-unit>
        <trans-unit id="df6534fbc976a915dd2ab9e7fdb121c13f0a1f35" translate="yes" xml:space="preserve">
          <source>A mechanism for reading data from the cache and subscribing for updates when these results change due to a mutation, subscription update, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cccdfbe7fde630bea189ab2f8f17ca043aff9a4" translate="yes" xml:space="preserve">
          <source>A mechanism for refetching an object.</source>
          <target state="translated">Механизм перезарядки объекта.</target>
        </trans-unit>
        <trans-unit id="dd1a050f9a41554bdba5570ef7cbd29c8928f1fa" translate="yes" xml:space="preserve">
          <source>A naming convention of &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; for fragments is advised. This restriction is required while migrating from classic to modern APIs to allow for cross-compatibility.</source>
          <target state="translated">Для фрагментов рекомендуется использовать соглашение об именах &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; . Это ограничение требуется при переходе с классических API на современные для обеспечения перекрестной совместимости.</target>
        </trans-unit>
        <trans-unit id="b4223851fbff0df13ddb07d4c23c59818ab413eb" translate="yes" xml:space="preserve">
          <source>A normalized cache ensures that the &lt;em&gt;cache&lt;/em&gt; is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</source>
          <target state="translated">Нормализованный кеш обеспечивает согласованность &lt;em&gt;кеша&lt;/em&gt; . Но как насчет наших взглядов? В идеале наши представления React всегда отражали бы текущую информацию из кеша.</target>
        </trans-unit>
        <trans-unit id="ae22c4f42331ba6c74de6dc551bc9f18b6a1ae62" translate="yes" xml:space="preserve">
          <source>A normalized, in-memory object graph/cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="921546babe023949163725db08488e51b22729dc" translate="yes" xml:space="preserve">
          <source>A number of more detailed usage examples can be found &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;in the test suite&lt;/a&gt;.</source>
          <target state="translated">Ряд более подробных примеров использования можно найти &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;в наборе тестов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bf37966659d061a8f053bad6bab73f29aaece2b" translate="yes" xml:space="preserve">
          <source>A parent component will pass in a reference to some &lt;code&gt;User&lt;/code&gt; &quot;record&quot;.</source>
          <target state="translated">Родитель компонент будет передать ссылку на какой - то &lt;code&gt;User&lt;/code&gt; &amp;laquo;записи&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="3024b82cc133bf6a9ef4feda5d9be663e786bae2" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for Relay using &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; to support older browsers might look like:</source>
          <target state="translated">Полифиллированная среда для Relay, использующая &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; для поддержки старых браузеров, может выглядеть так:</target>
        </trans-unit>
        <trans-unit id="d9c2b7e55915b27a1958903b288baadab9b9ebc4" translate="yes" xml:space="preserve">
          <source>A query like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d2ab53d28c9ffa3a83c917db0c7132ab0ec11a" translate="yes" xml:space="preserve">
          <source>A reference for translating between the Relay Classic and Relay Modern APIs.</source>
          <target state="translated">Ссылка на перевод между Relay Classic и Relay Modern API.</target>
        </trans-unit>
        <trans-unit id="0b8683fbbd3c98251a45756a2f2f8175837a100c" translate="yes" xml:space="preserve">
          <source>A simple database</source>
          <target state="translated">Простая база данных</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">простой пример</target>
        </trans-unit>
        <trans-unit id="dd8ebc46434f8d14a177b5c72d5934bab414bb47" translate="yes" xml:space="preserve">
          <source>A simpler, more predictable mutation API. The restrictions on mutation queries from Relay Classic are also removed: mutation queries are static, fields can be arbitrarily nested, and may use arbitrary arguments.</source>
          <target state="translated">Более простой,более предсказуемый API мутации.Также сняты ограничения на запросы на мутацию из Relay Classic:запросы на мутацию статичны,поля могут произвольно вставляться и использовать произвольные аргументы.</target>
        </trans-unit>
        <trans-unit id="789d37a7cd03e8b6bdc2af935f5617d2f61be663" translate="yes" xml:space="preserve">
          <source>A standard response is to &quot;just use immutable data structures&quot; &amp;mdash; but let's see what would happen if we did:</source>
          <target state="translated">Стандартный ответ - &amp;laquo;просто использовать неизменяемые структуры данных&amp;raquo;, но давайте посмотрим, что произойдет, если мы это сделаем:</target>
        </trans-unit>
        <trans-unit id="e5e4cf2d26ffa89b62883fa16b09362f316c9090" translate="yes" xml:space="preserve">
          <source>A summary of the improvements and new features in Relay Modern.</source>
          <target state="translated">Краткое описание усовершенствований и новых функций в Relay Modern.</target>
        </trans-unit>
        <trans-unit id="95da6cd41846ca1d215d52c18cb18c520fe5b668" translate="yes" xml:space="preserve">
          <source>A working copy of the treasure hunt can be found in the &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; repository.</source>
          <target state="translated">Рабочую копию поиска сокровищ можно найти в репозитории &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aec4806edaa35984901f978cbb068b50698edb4" translate="yes" xml:space="preserve">
          <source>API Cheatsheet</source>
          <target state="translated">шаблонный лист API</target>
        </trans-unit>
        <trans-unit id="2c3de2092b0a547759dcfed154c12293c6bfa562" translate="yes" xml:space="preserve">
          <source>API and Runtime</source>
          <target state="translated">API и время выполнения</target>
        </trans-unit>
        <trans-unit id="30decd745bda6efb9c328a25620c92f31665d9ed" translate="yes" xml:space="preserve">
          <source>Accessing a plain connection field like this is the same as other regular field:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42949c00e99b70b6ffba23e406246cfa31564e49" translate="yes" xml:space="preserve">
          <source>Achieving View Consistency</source>
          <target state="translated">Достижение согласованности взглядов</target>
        </trans-unit>
        <trans-unit id="81f2d6f8bacd029d8646faa85a14672311eb28b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins your .babelrc file. See &lt;a href=&quot;babel-plugin-relay&quot;&gt;the docs&lt;/a&gt; if upgrading an existing Relay app.</source>
          <target state="translated">Добавьте &lt;code&gt;&quot;relay&quot;&lt;/code&gt; в список плагинов вашего .babelrc файла. См. &lt;a href=&quot;babel-plugin-relay&quot;&gt;Документацию&lt;/a&gt; при обновлении существующего приложения Relay.</target>
        </trans-unit>
        <trans-unit id="0a60bf5aa8ddfd89ba31ac71650847ae24721ce0" translate="yes" xml:space="preserve">
          <source>Add the variable to the queries that use the fragment and pass it in when fetching the query. For this it can be useful to have a module with a collection of variables for your product.</source>
          <target state="translated">Добавьте переменную к запросам,использующим фрагмент,и передайте ее при получении запроса.Для этого может быть полезно иметь модуль с коллекцией переменных для вашего продукта.</target>
        </trans-unit>
        <trans-unit id="0a4d555b6a81430095f4070dee6163a543de304b" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;handlerProvider&lt;/code&gt;</source>
          <target state="translated">Добавление &lt;code&gt;handlerProvider&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c313de6babf318503fdf433e2471023cd78a727c" translate="yes" xml:space="preserve">
          <source>Additional Options</source>
          <target state="translated">Дополнительные опции</target>
        </trans-unit>
        <trans-unit id="94c2eff0e92e7480eb248740c04ee58edd887616" translate="yes" xml:space="preserve">
          <source>Additionally, you need a directory containing &lt;code&gt;.js&lt;/code&gt; files that use the &lt;code&gt;graphql&lt;/code&gt; tag to describe GraphQL queries and fragments. Let's call this &lt;code&gt;./src&lt;/code&gt;.</source>
          <target state="translated">Кроме того, вам понадобится каталог, содержащий файлы &lt;code&gt;.js&lt;/code&gt; , которые используют тег &lt;code&gt;graphql&lt;/code&gt; для описания запросов и фрагментов GraphQL. Назовем это &lt;code&gt;./src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c13cb060f72ef8e06bc9f0779c54871d13ff35" translate="yes" xml:space="preserve">
          <source>Advanced Mutation Example</source>
          <target state="translated">Расширенный пример мутации</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">Расширенное использование</target>
        </trans-unit>
        <trans-unit id="65b03cca363991c35ae10c0088f588b27ac28625" translate="yes" xml:space="preserve">
          <source>After global invalidation, any query that is checked before refetching it will be considered stale:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78bdcba5217f6a92239c4e8dde28377bb7815364" translate="yes" xml:space="preserve">
          <source>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as &lt;code&gt;author&lt;/code&gt;:</source>
          <target state="translated">После первоначальной загрузки этой истории наш кеш может выглядеть следующим образом. Обратите внимание, что и история, и комментарий ссылаются на ту же запись, что и &lt;code&gt;author&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2dd7e26249b6d8637a717ed4d6b92305ed4d8d7" translate="yes" xml:space="preserve">
          <source>After invalidating a record, any query that references the invalidated record and that is checked before refetching it will be considered stale:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d5e5845a458c2e48e4a1e3d9fcce05c093f36b" translate="yes" xml:space="preserve">
          <source>After the network comes back, if any optimistic update was applied, it will be rolled back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cefb28e5c89ebf89740e7f56f62c4e404d2462a6" translate="yes" xml:space="preserve">
          <source>All data is fetched in a single round trip.</source>
          <target state="translated">Все данные собираются за один рейс.</target>
        </trans-unit>
        <trans-unit id="40454335b535c042b908582ab2dd06293106ac63" translate="yes" xml:space="preserve">
          <source>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</source>
          <target state="translated">Все мутации,которые мы выполнили до сих пор,ждали ответа от сервера,прежде чем обновлять клиентское хранилище.Relay предлагает нам шанс создать оптимистичный ответ такой же формы,основываясь на том,что мы ожидаем от ответа сервера в случае успешной мутации.</target>
        </trans-unit>
        <trans-unit id="6e5ef228d93a867965453c9210e08a5fc6427932" translate="yes" xml:space="preserve">
          <source>Alternatively a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; can also be used.</source>
          <target state="translated">В качестве &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt; также можно использовать RefetchContainer .</target>
        </trans-unit>
        <trans-unit id="3cb1f93043bd5b1e4766b2a5f1a916dfbf98f41c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can install &lt;code&gt;relay-compiler&lt;/code&gt; globally so you can access it directly:</source>
          <target state="translated">В качестве альтернативы вы можете установить &lt;code&gt;relay-compiler&lt;/code&gt; глобально, чтобы иметь к нему прямой доступ:</target>
        </trans-unit>
        <trans-unit id="4e7be8aae845923a0feac81e1f7b4b0b1b6931db" translate="yes" xml:space="preserve">
          <source>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</source>
          <target state="translated">Хотя ответ иерархичен,мы кэшируем его,сглаживая все записи.Вот пример того,как Relay будет кэшировать ответ на этот запрос:</target>
        </trans-unit>
        <trans-unit id="c6ec18663142d1b37b9759d8f91cf8ac740a2752" translate="yes" xml:space="preserve">
          <source>An area we've gotten a lot of questions on was mutations and their configs. Relay Modern introduces a new mutation API that allows records and fields to be updated in a more direct manner.</source>
          <target state="translated">Область,в которой мы получили много вопросов,была мутациями и их конфигурациями.Relay Modern представляет новый API для мутаций,который позволяет обновлять записи и поля более непосредственно.</target>
        </trans-unit>
        <trans-unit id="16a242bdcfab9509fa528a20336ea8be61d5d155" translate="yes" xml:space="preserve">
          <source>An array containing the field names between the parent and the connection, including the parent and the connection</source>
          <target state="translated">Массив,содержащий имена полей между родителем и соединением,включая родителя и соединение</target>
        </trans-unit>
        <trans-unit id="ab5c749afdc7ed704bf1427839cff1f6c54727ed" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;fetch&lt;/code&gt; looks like this:</source>
          <target state="translated">Пример использования &lt;code&gt;fetch&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="ecb9a82e766e01fb5997898864c15b00f3207e54" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; encapsulates an in-memory cache of GraphQL data and a network layer that provides access to your GraphQL server. The Environment object is typically not used by developers directly, instead it is passed to each &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, which uses the environment to access, modify, and fetch data. Within a container, the current environment can be accessed via &lt;code&gt;this.props.relay.environment&lt;/code&gt;. This is most commonly used to &lt;a href=&quot;mutations&quot;&gt;execute a mutation&lt;/a&gt;.</source>
          <target state="translated">Экземпляр &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; инкапсулирует кэш данных GraphQL в памяти и сетевой уровень, который обеспечивает доступ к вашему серверу GraphQL. Объект Environment обычно не используется разработчиками напрямую, вместо этого он передается каждому &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; , который использует среду для доступа, изменения и выборки данных. Доступ к текущей среде внутри контейнера можно получить через &lt;code&gt;this.props.relay.environment&lt;/code&gt; . Это чаще всего используется для &lt;a href=&quot;mutations&quot;&gt;выполнения мутации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd9dc1929b158a9c5ea7752c056cc104664b1ef" translate="yes" xml:space="preserve">
          <source>An object that conforms to the &lt;code&gt;Relay.Environment&lt;/code&gt; interface, such as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">Объект, соответствующий интерфейсу &lt;code&gt;Relay.Environment&lt;/code&gt; , например &lt;code&gt;Relay.Store&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31091cd5447f1a5facd7ba679b86a188b803a23a" translate="yes" xml:space="preserve">
          <source>An optimized &quot;write&quot; operation for updating the cache with the results of queries/mutations/subscriptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7cf5ea35aac5de7114e6afc02d20f82b3316f0" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;onReadyStateChange&lt;/code&gt; callback can be supplied to respond to the events involved with the data fulfillment.</source>
          <target state="translated">Необязательный обратный вызов &lt;code&gt;onReadyStateChange&lt;/code&gt; может быть предоставлен для ответа на события, связанные с выполнением данных.</target>
        </trans-unit>
        <trans-unit id="7303f03f73c25d8e0d64d93962d92858e7741e4b" translate="yes" xml:space="preserve">
          <source>And here's a possible response:</source>
          <target state="translated">И вот возможная реакция:</target>
        </trans-unit>
        <trans-unit id="369fe458331664a040bf70efbb8b99da198958aa" translate="yes" xml:space="preserve">
          <source>And this fragment can then be used to define the Story container:</source>
          <target state="translated">И этот фрагмент может быть использован для определения контейнера Story:</target>
        </trans-unit>
        <trans-unit id="4dfa35597a4d927f5cbf51a45486138efe15e61b" translate="yes" xml:space="preserve">
          <source>Another way to enable optimistic updates is via the &lt;code&gt;optimisticUpdater&lt;/code&gt;, which can be used for more complicated update scenarios. Using &lt;code&gt;optimisticUpdater&lt;/code&gt; is covered in the section &lt;a href=&quot;#using-updater-and-optimisticupdater&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="880246192858f60438eac48b83d096fc7d5b0a5d" translate="yes" xml:space="preserve">
          <source>Any arguments defined inside &lt;code&gt;@argumentDefinitions&lt;/code&gt; will be local variables available inside the fragment's scope. However, a fragment can also reference global variables that were defined in the root query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605ea43af6ae69ff62a257b6fd0223b045c71edf" translate="yes" xml:space="preserve">
          <source>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</source>
          <target state="translated">Любое поле в полезной нагрузке,которое может быть соотнесено DataID с одной или несколькими записями в клиентском магазине,будет объединено с записью(ами)в магазине.</target>
        </trans-unit>
        <trans-unit id="0fefe11020485e10d8f3308edf7710a3715bb28f" translate="yes" xml:space="preserve">
          <source>Any fields specified in the client schema, can be fetched from the &lt;a href=&quot;relay-store&quot;&gt;Relay Store&lt;/a&gt;, by selecting it in a query or fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfe1cdd7971ecdf1250f379fc5280623f121ecd7" translate="yes" xml:space="preserve">
          <source>Any props that we pass to the constructor of a mutation will become available to its instance methods as &lt;code&gt;this.props&lt;/code&gt;. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</source>
          <target state="translated">Любые свойства, которые мы передаем конструктору мутации, станут доступны его методам экземпляра как &lt;code&gt;this.props&lt;/code&gt; . Как и в компонентах, используемых в контейнерах Relay, свойства, для которых был определен соответствующий фрагмент, будут заполнены Relay данными запроса:</target>
        </trans-unit>
        <trans-unit id="2c3c3b69096651daf12db619c2e7045eb0884046" translate="yes" xml:space="preserve">
          <source>Any server can be taught to load a schema and speak GraphQL. Our &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;examples&lt;/a&gt; use Express.</source>
          <target state="translated">Любой сервер можно научить загружать схему и говорить на GraphQL. В наших &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;примерах&lt;/a&gt; используется Express.</target>
        </trans-unit>
        <trans-unit id="8a830514fbc11a8668a4369e6666ef8944337af6" translate="yes" xml:space="preserve">
          <source>Applications must supply a &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; when creating an instance of a Relay Environment. The network layer is an object conforming to a simple interface through which Relay can execute queries, mutations, and subscriptions. Essentially, this object teaches Relay how to talk to your GraphQL server.</source>
          <target state="translated">При создании экземпляра среды ретрансляции приложения должны предоставлять &lt;a href=&quot;network-layer&quot;&gt;сетевой уровень&lt;/a&gt; . Сетевой уровень - это объект, соответствующий простому интерфейсу, через который Relay может выполнять запросы, изменения и подписки. По сути, этот объект учит Relay, как общаться с вашим сервером GraphQL.</target>
        </trans-unit>
        <trans-unit id="b73a641a18b041c9d0f67faadd8eeb909c673be7" translate="yes" xml:space="preserve">
          <source>Applied to a fragment definition, &lt;code&gt;@relay(mask: false)&lt;/code&gt; changes the generated Flow types to be better usable when the fragment is included with the same directive. The Flow types will no longer be exact objects and no longer contain internal marker fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77cbe978decf7e18ac53e8ff64911f09e83509bc" translate="yes" xml:space="preserve">
          <source>Architecture Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="dd4d4251ad9eea93ba8b6656973531a29f150428" translate="yes" xml:space="preserve">
          <source>Array fields</source>
          <target state="translated">Массивные поля</target>
        </trans-unit>
        <trans-unit id="db828dbd3d02709c19e5c4f2577f94833837f6ee" translate="yes" xml:space="preserve">
          <source>As React components, &lt;code&gt;QueryRenderer&lt;/code&gt;s can be rendered anywhere that a React component can be rendered, i.e. not just at the top level but &lt;em&gt;within&lt;/em&gt; other components or containers; for example, to lazily fetch additional data for a popover.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3aab73669ac6dc9de81f7b41eeb64591c4e0ee7" translate="yes" xml:space="preserve">
          <source>As an example, we can log each mutation that is sent to the server as follows:</source>
          <target state="translated">В качестве примера,мы можем заносить в журнал каждую мутацию,которая отправляется на сервер,следующим образом:</target>
        </trans-unit>
        <trans-unit id="93df315a58852563161dbb62a33b18e1c4b63051" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; can be embedded not only in &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt;, but any container that fetches a field of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Как мы узнали, контейнеры Relay объявляют требования к данным как фрагменты GraphQL. Это означает, что, например, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; может быть встроен не только в &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; , но и в любой контейнер, который выбирает поле типа &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="923622cbd0c4bbb9c49d319a01f53817606d02a1" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers declare data requirements as GraphQL fragments. We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; fragment in a GraphQL query.</source>
          <target state="translated">Как мы узнали, контейнеры фрагментов Relay объявляют требования к данным как фрагменты GraphQL. Мы почти готовы позволить Relay выполнить требования к данным для этих компонентов и отобразить их. Однако есть одна проблема. Чтобы действительно получать данные с помощью GraphQL, нам нужен корень запроса. Например, нам нужно &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; фрагмент &amp;lt;TodoList&amp;gt; в запросе GraphQL.</target>
        </trans-unit>
        <trans-unit id="aca9c86fb3d13923d8fed77382029e60cce8b3f9" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers only declare data requirements as GraphQL fragments. In order to actually fetch and render the specified data, we need to use a &lt;code&gt;QueryRenderer&lt;/code&gt; component to render a root query and any fragment containers included within. Please refer to our &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; docs for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a71de49f031297e07457bef14ae0f8572e55b44" translate="yes" xml:space="preserve">
          <source>At this point, you can delete everything up until &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt;.</source>
          <target state="translated">На этом этапе вы можете удалить все до &lt;code&gt;queryType&lt;/code&gt; в &lt;code&gt;./data/schema.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="207aae1b1d93e0ae663b416c543d4e3848a98ef0" translate="yes" xml:space="preserve">
          <source>Authoring a schema</source>
          <target state="translated">Создание схемы</target>
        </trans-unit>
        <trans-unit id="f959176d994ae939a23354811509dadf3863fa24" translate="yes" xml:space="preserve">
          <source>Available Props</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb220f88ae787a8eafb5d737da557d0ab6ff6ca" translate="yes" xml:space="preserve">
          <source>Babel Relay Plugin</source>
          <target state="translated">плагин Вавилонского реле</target>
        </trans-unit>
        <trans-unit id="0351d5a9ef82b115e9ed00101cebdddfe0dbad30" translate="yes" xml:space="preserve">
          <source>Base React Component</source>
          <target state="translated">Компонент базовой реакции</target>
        </trans-unit>
        <trans-unit id="a6551059bdb95efc2dfbc4b7c2ce6ccc9fcd0365" translate="yes" xml:space="preserve">
          <source>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</source>
          <target state="translated">Прежде чем двигаться дальше,нам нужно сериализовать нашу исполняемую схему в JSON для использования транспайлером Relay.QL,а затем запустить сервер.Из командной строки:</target>
        </trans-unit>
        <trans-unit id="97cecb9e6bdc8256a26df17eef65a9b41e163cee" translate="yes" xml:space="preserve">
          <source>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; to create a custom mutation that we can use to like a story.</source>
          <target state="translated">Прежде чем углубляться в API мутаций, давайте рассмотрим полный пример. Здесь мы создаем подкласс &lt;code&gt;Relay.Mutation&lt;/code&gt; для создания настраиваемой мутации, которую мы можем использовать, чтобы лайкнуть историю.</target>
        </trans-unit>
        <trans-unit id="949c7a85f6d836f247f0195b7eaa99f0c336e992" translate="yes" xml:space="preserve">
          <source>Behaviors can be one of &lt;code&gt;'append'&lt;/code&gt;, &lt;code&gt;'ignore'&lt;/code&gt;, &lt;code&gt;'prepend'&lt;/code&gt;, &lt;code&gt;'refetch'&lt;/code&gt;, or &lt;code&gt;'remove'&lt;/code&gt;.</source>
          <target state="translated">Поведение может быть одним из следующих: &lt;code&gt;'append'&lt;/code&gt; , &lt;code&gt;'ignore'&lt;/code&gt; , &lt;code&gt;'prepend'&lt;/code&gt; , &lt;code&gt;'refetch'&lt;/code&gt; или &lt;code&gt;'remove'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a13e0d17d14c44107ca60ab513e5d71d5662c000" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Faction&lt;/code&gt; and &lt;code&gt;Ship&lt;/code&gt; have identifiers that we can use to refetch them. We expose this capability to Relay through the &lt;code&gt;Node&lt;/code&gt; interface and the &lt;code&gt;node&lt;/code&gt; field on the root query type.</source>
          <target state="translated">И у &lt;code&gt;Faction&lt;/code&gt; и у &lt;code&gt;Ship&lt;/code&gt; есть идентификаторы, которые мы можем использовать для их получения. Выставляет эту возможность для ретрансляции через &lt;code&gt;Node&lt;/code&gt; интерфейс и &lt;code&gt;node&lt;/code&gt; поле по типу корневого запроса.</target>
        </trans-unit>
        <trans-unit id="3148373f94223f76742328ea5464dd9f30817fe7" translate="yes" xml:space="preserve">
          <source>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the &lt;code&gt;userID&lt;/code&gt; query parameter, we might use:</source>
          <target state="translated">Но теперь мы также можем создавать маршруты для произвольных идентификаторов пользователей. Например, если мы хотим построить маршрут, который извлекает данные для пользователя, определенного параметром запроса &lt;code&gt;userID&lt;/code&gt; , мы могли бы использовать:</target>
        </trans-unit>
        <trans-unit id="1862f3355eff810374142f7e656f80df21c55213" translate="yes" xml:space="preserve">
          <source>By convention, mutations are named as verbs, their inputs are the name with &quot;Input&quot; appended at the end, and they return an object that is the name with &quot;Payload&quot; appended.</source>
          <target state="translated">По условию,мутации называются глаголами,их вход-это имя с приложением &quot;Input&quot; в конце,и они возвращают объект,который является именем с приложением &quot;Payload&quot;.</target>
        </trans-unit>
        <trans-unit id="178b930518b904dbc5bd0f441c18fc870aac28c3" translate="yes" xml:space="preserve">
          <source>By default, Relay assumes that GraphQL is served at &lt;code&gt;/graphql&lt;/code&gt; relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</source>
          <target state="translated">По умолчанию Relay предполагает, что GraphQL обслуживается в &lt;code&gt;/graphql&lt;/code&gt; относительно источника, в котором обслуживается наше приложение. Это можно перенастроить, внедрив пользовательский экземпляр сетевого уровня по умолчанию.</target>
        </trans-unit>
        <trans-unit id="cb2b20c497e96eb4a4f4f36c0d7cc25608d4e73c" translate="yes" xml:space="preserve">
          <source>By default, Relay will only expose the data for fields explicitly requested by a &lt;a href=&quot;fragment-container#createfragmentcontainer&quot;&gt;component's fragment&lt;/a&gt;, which is known as &lt;a href=&quot;thinking-in-relay#data-masking&quot;&gt;data masking&lt;/a&gt;. Fragment data is unmasked for use in React components by &lt;code&gt;createFragmentContainer&lt;/code&gt;. However, you may want to use fragment data in non-React functions that are called from React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01482f7fe504d2a5e3cc944236d88811dd8d351" translate="yes" xml:space="preserve">
          <source>By default, nothing is rendered while loading data for the initial render. If a previous set of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;route&lt;/code&gt; were fulfilled and rendered, the default behavior is to continue rendering the previous view.</source>
          <target state="translated">По умолчанию при загрузке данных для первоначального рендеринга ничего не отображается. Если предыдущий набор &lt;code&gt;Component&lt;/code&gt; и &lt;code&gt;route&lt;/code&gt; был выполнен и визуализирован, поведение по умолчанию - продолжить визуализацию предыдущего вида.</target>
        </trans-unit>
        <trans-unit id="4375c1481c81a0b6d8e08ac19523704d5d4da90b" translate="yes" xml:space="preserve">
          <source>Cache Consistency</source>
          <target state="translated">Согласованность кэша</target>
        </trans-unit>
        <trans-unit id="14776554d5693e023c3ac7a5a65e4a5058537dfe" translate="yes" xml:space="preserve">
          <source>Cache Updates</source>
          <target state="translated">обновления кэша</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="eed1812845bba88a7ea96dc0731ed87a6365fcc0" translate="yes" xml:space="preserve">
          <source>Caching A Graph</source>
          <target state="translated">Кэширование графика</target>
        </trans-unit>
        <trans-unit id="c3fbd240479228aa26381115ef997022e9773856" translate="yes" xml:space="preserve">
          <source>Call this to optimistically apply an update to the store.</source>
          <target state="translated">Вызовите это,чтобы оптимистично применить обновление к магазину.</target>
        </trans-unit>
        <trans-unit id="ef28016b715246d53e3c0aef32bef448a5df1961" translate="yes" xml:space="preserve">
          <source>Call this to send the mutation to the server.</source>
          <target state="translated">Позвоните сюда,чтобы отправить мутацию на сервер.</target>
        </trans-unit>
        <trans-unit id="36653c1ff08edcb50e3d0e9893272cf6219ebfe7" translate="yes" xml:space="preserve">
          <source>Callers must provide an appropriate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. As per the GraphQL Relay Specification:</source>
          <target state="translated">Вызывающие должны предоставить соответствующий &lt;code&gt;query&lt;/code&gt; и &lt;code&gt;variables&lt;/code&gt; . Согласно спецификации реле GraphQL:</target>
        </trans-unit>
        <trans-unit id="ec585c24a23bd7001c34d954b9fe9b0796cec5f2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; with a record from &lt;code&gt;this.props&lt;/code&gt; will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</source>
          <target state="translated">Вызов &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; с записью из &lt;code&gt;this.props&lt;/code&gt; вернет, затронута ли данная запись оптимистической мутацией. Это позволяет компоненту отображать локальные оптимистические изменения иначе, чем данные, успешно синхронизированные с сервером.</target>
        </trans-unit>
        <trans-unit id="7e92933047a9a8b8023050178520d6236fd1d0bd" translate="yes" xml:space="preserve">
          <source>Calling Component Instance Methods</source>
          <target state="translated">Методы определения компонентной субстанции</target>
        </trans-unit>
        <trans-unit id="539001ff0ade75c366a1d2f2ae990718f2b4bd9b" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Classic Environment (&lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt;) use:</source>
          <target state="translated">Может ли QueryRenderer в классической среде ( &lt;code&gt;Store&lt;/code&gt; в react &lt;code&gt;react-relay/classic&lt;/code&gt; ) использовать:</target>
        </trans-unit>
        <trans-unit id="4aacaa8308c0d89cb19bc6280f172bcb3027eef8" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Modern Environment use:</source>
          <target state="translated">Can QueryRenderer с использованием современной среды:</target>
        </trans-unit>
        <trans-unit id="1003218887eb40c1f0a58bc7b7505d15f23175bf" translate="yes" xml:space="preserve">
          <source>Can React Classic Component use:</source>
          <target state="translated">Может реагировать на использование классических компонентов:</target>
        </trans-unit>
        <trans-unit id="84238b1b418a17b213190530f83d669483ad4f99" translate="yes" xml:space="preserve">
          <source>Can React Compat Component use:</source>
          <target state="translated">Может реагировать на использование компонентов компаунда:</target>
        </trans-unit>
        <trans-unit id="1c53c8d6a82f41f51bcb44a951f6d42bbd674773" translate="yes" xml:space="preserve">
          <source>Can React Modern Component use:</source>
          <target state="translated">Может реагировать на использование современных компонентов:</target>
        </trans-unit>
        <trans-unit id="ce811e756a396388182f7a8551a77979cea636ea" translate="yes" xml:space="preserve">
          <source>Can RelayRootContainer use:</source>
          <target state="translated">Может ли использование контейнера RelayRootContainer:</target>
        </trans-unit>
        <trans-unit id="918e312c8dc15e096c8aa60a584cd24fb9b592cd" translate="yes" xml:space="preserve">
          <source>Changing Arguments</source>
          <target state="translated">Изменяющиеся аргументы</target>
        </trans-unit>
        <trans-unit id="51cdd39226322d9d0efb448c0d03eb64cb6c777d" translate="yes" xml:space="preserve">
          <source>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</source>
          <target state="translated">Изменение одной вещи в системе может иметь пульсационный эффект,который приводит к тому,что другие вещи,в свою очередь,меняются.Представьте себе мутацию,которую мы можем использовать,чтобы принять запрос друга.Это может иметь широкие последствия:</target>
        </trans-unit>
        <trans-unit id="bb73c6b849ccfd7df64b939d3890bbba8b94e10a" translate="yes" xml:space="preserve">
          <source>Classic Component</source>
          <target state="translated">Классический компонент</target>
        </trans-unit>
        <trans-unit id="9e402ea82ec577f1a7b994361d91b4f9ac1cf510" translate="yes" xml:space="preserve">
          <source>Classic Mutation</source>
          <target state="translated">Классическая мутация</target>
        </trans-unit>
        <trans-unit id="76be385c076bd3cf6a0e76bbefee914b22199f01" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Классический: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9450d4893299b4475b958954ce614f6339c011c9" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;Relay.createContainer&lt;/code&gt;</source>
          <target state="translated">Классический: &lt;code&gt;Relay.createContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdacd86df881f947250264b6f74153f74ca2e17b" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</source>
          <target state="translated">Классический: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4496ce0ff60c519ddb23c737b94a8c3d0f8fae44" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</source>
          <target state="translated">Классический: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4718307cda6ad09eb778eec75ee2c5f20cd45961" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</source>
          <target state="translated">Классический: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88cd760542eea1905cd9d8225750e276c483cde" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</source>
          <target state="translated">Классический: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f5633b3ae0188027fabbde415e0f3fcc71e6c3" translate="yes" xml:space="preserve">
          <source>Client Caching</source>
          <target state="translated">Кэширование клиентов</target>
        </trans-unit>
        <trans-unit id="d4d64d5c478ea7fd0df7b8579f158dc6ea90455b" translate="yes" xml:space="preserve">
          <source>Client Schema Extensions (Experimental)</source>
          <target state="translated">Расширения клиентской схемы (экспериментальные)</target>
        </trans-unit>
        <trans-unit id="825764a68e0dc6e933619f703142c815e2415444" translate="yes" xml:space="preserve">
          <source>Client schema extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d72336fa3d155eac5f2b8f6e5f8d2e326546c2" translate="yes" xml:space="preserve">
          <source>Committing Local Updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a359c7ebffb6706034dbf0f013aa73bcc550292c" translate="yes" xml:space="preserve">
          <source>Comparing Relay Classic and Relay Modern</source>
          <target state="translated">Сравнение классических и современных реле</target>
        </trans-unit>
        <trans-unit id="fb10d488b2ce3717647b6821e5a1c02381aeca3a" translate="yes" xml:space="preserve">
          <source>Comparison to Classic Relay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54dbbae41b051460dcc8e3c9aa6f310af3f2775" translate="yes" xml:space="preserve">
          <source>Compat Component</source>
          <target state="translated">Компонент Compat</target>
        </trans-unit>
        <trans-unit id="2171ca54b3db409d7e88bfa689ea2ab5583955c6" translate="yes" xml:space="preserve">
          <source>Compat Mode</source>
          <target state="translated">Компасный режим</target>
        </trans-unit>
        <trans-unit id="ef1a53514cc801546fdbf4bd01e2b4b764618f78" translate="yes" xml:space="preserve">
          <source>Compat Mutation</source>
          <target state="translated">Мутация компата</target>
        </trans-unit>
        <trans-unit id="7ae7318a99d95f75927a3ae6b936e04d175cc04e" translate="yes" xml:space="preserve">
          <source>Compatibility Cheatsheet</source>
          <target state="translated">Краткий список совместимости</target>
        </trans-unit>
        <trans-unit id="6d9f235cb9c7c65f0cf0b1b0814cadde6d86abcb" translate="yes" xml:space="preserve">
          <source>Compatibility Mode</source>
          <target state="translated">Режим совместимости</target>
        </trans-unit>
        <trans-unit id="e2e7a6441928ea51ba685ebeb68d5198d58d0008" translate="yes" xml:space="preserve">
          <source>Compiler Architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e9d1be17321688f8d0501eb1a3bf2c6ca26c3e" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; spec.</source>
          <target state="translated">Полная информация о том, как должен вести себя сервер, доступна в спецификации &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29619ae00dc1b1f13f0d8573c5ca62184c0a6a94" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL Input Object Mutations&lt;/a&gt; spec.</source>
          <target state="translated">Полная информация о том, как должен вести себя сервер, доступна в &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;спецификации GraphQL Input Object Mutations&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd80bd3e0728573910ceff942d6bf05bb7333573" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; spec.</source>
          <target state="translated">Полная информация о том, как должен вести себя сервер, доступна в спецификации &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="725a4ffad64df11f9defa669f85ec107f9dc492d" translate="yes" xml:space="preserve">
          <source>Component and Route</source>
          <target state="translated">Компонент и маршрут</target>
        </trans-unit>
        <trans-unit id="94c5c072cfb48e6d9ea12f613a057a202a5c287b" translate="yes" xml:space="preserve">
          <source>Components can change their data requirements by using &lt;code&gt;setVariables&lt;/code&gt; to request an update to the current set of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">Компоненты могут изменять свои требования к данным, используя &lt;code&gt;setVariables&lt;/code&gt; для запроса обновления текущего набора &lt;code&gt;variables&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31ae8b82fb482703d4497f95cafdbd464174a12e" translate="yes" xml:space="preserve">
          <source>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling &lt;code&gt;getPendingTransactions&lt;/code&gt; with a record will return a list of the pending mutation transactions that affect that particular record.</source>
          <target state="translated">Компоненты могут проверять ожидающие изменения в любой записи (т. Е. Данные, доступные в реквизитах с соответствующим фрагментом). Вызов &lt;code&gt;getPendingTransactions&lt;/code&gt; с записью вернет список ожидающих транзакций мутации, которые влияют на эту конкретную запись.</target>
        </trans-unit>
        <trans-unit id="deee480cd52fae7c121c1d7b8b86ecda66617156" translate="yes" xml:space="preserve">
          <source>Composing Fragments</source>
          <target state="translated">Составляющие фрагменты</target>
        </trans-unit>
        <trans-unit id="0c70e5846878a796dcb7c94e3f0ca5de9a047eee" translate="yes" xml:space="preserve">
          <source>Composing Views</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a321a9ac4f3111d95368aba4e87b1917d75348e" translate="yes" xml:space="preserve">
          <source>Composing Views - It's Plain React</source>
          <target state="translated">Сочиняемые взгляды-это обычная реакция.</target>
        </trans-unit>
        <trans-unit id="723e2c15fe85b32b7d864e21eb29e93116b04e14" translate="yes" xml:space="preserve">
          <source>Composing child component fragments in a parent fragment.</source>
          <target state="translated">Составление фрагментов дочерних компонентов в родительском фрагменте.</target>
        </trans-unit>
        <trans-unit id="f82641d3cbab73b5e585b20db3196f350cb839d5" translate="yes" xml:space="preserve">
          <source>Composing fragments defined as local variables.</source>
          <target state="translated">Составление фрагментов,определенных как локальные переменные.</target>
        </trans-unit>
        <trans-unit id="114b9abd3f0b27b8a9b5084318c5af838acdb163" translate="yes" xml:space="preserve">
          <source>Composing the data descriptions.</source>
          <target state="translated">Составление описаний данных.</target>
        </trans-unit>
        <trans-unit id="59d6b2067a223146a5ead92a4c5fe072d43c9a1e" translate="yes" xml:space="preserve">
          <source>Composing the fragments of child components is discussed in detail in the &lt;a href=&quot;guides-containers&quot;&gt;Containers Guide&lt;/a&gt;, but here's a quick example:</source>
          <target state="translated">Составление фрагментов дочерних компонентов подробно обсуждается в &lt;a href=&quot;guides-containers&quot;&gt;Руководстве&lt;/a&gt; по контейнерам , но вот небольшой пример:</target>
        </trans-unit>
        <trans-unit id="a7b041783bd841c2982c635611a14b9b0478fc32" translate="yes" xml:space="preserve">
          <source>Composing the view logic, and</source>
          <target state="translated">Составляя логику представления,и</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9d60520748b88da0348eeb8f6543f6f98cdbd262" translate="yes" xml:space="preserve">
          <source>Conditional fields</source>
          <target state="translated">Условные поля</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="2de632b51a33bf8e3ed45599633fb58061f6d4dc" translate="yes" xml:space="preserve">
          <source>Configure Network</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="2d3d0c339708a6485641055e4d0d9e905ec021cc" translate="yes" xml:space="preserve">
          <source>ConnectionHandler</source>
          <target state="translated">ConnectionHandler</target>
        </trans-unit>
        <trans-unit id="81ea0a30d213381b26e05bce9c491003535b147a" translate="yes" xml:space="preserve">
          <source>Consider an input with a server-defined placeholder text and an imperative method to focus the input node:</source>
          <target state="translated">Рассмотрим ввод с текстом,определяемым сервером и обязательным методом фокусировки входного узла:</target>
        </trans-unit>
        <trans-unit id="1956d506ca97255f5713770475161b61eb6cde73" translate="yes" xml:space="preserve">
          <source>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</source>
          <target state="translated">Рассмотрим возможность отрисовки текста и комментариев сюжета вместе с соответствующими именами и фотографиями авторов.Вот запрос GraphQL:</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="0d5a8d03518c194626d6e3e124e7de20c17a7fe5" translate="yes" xml:space="preserve">
          <source>Container Composition</source>
          <target state="translated">Контейнерный состав</target>
        </trans-unit>
        <trans-unit id="b625b62c69e181700306e0871c20a6c94eaa2510" translate="yes" xml:space="preserve">
          <source>Container Specification</source>
          <target state="translated">Спецификация контейнера</target>
        </trans-unit>
        <trans-unit id="dfe33c87ae0783b9497dae2f22418a5e90385aa4" translate="yes" xml:space="preserve">
          <source>Container.getFragment()</source>
          <target state="translated">Container.getFragment()</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="4b51306faf49817c8299a221a2777da9319cb8d3" translate="yes" xml:space="preserve">
          <source>Containers are Higher-Order Components</source>
          <target state="translated">Контейнеры-это компоненты более высокого качества.</target>
        </trans-unit>
        <trans-unit id="46e795775ec1e8e3e71a6a5641d35b084e19a5a9" translate="yes" xml:space="preserve">
          <source>Containers can define a &lt;code&gt;prepareVariables&lt;/code&gt; method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist) in addition to the runtime environment.</source>
          <target state="translated">Контейнеры могут определять метод &lt;code&gt;prepareVariables&lt;/code&gt; , который дает возможность изменять переменные, доступные для фрагментов. Новые переменные могут быть сгенерированы на основе предыдущих переменных (или &lt;code&gt;initialVariables&lt;/code&gt; если предыдущие не существуют) в дополнение к среде выполнения.</target>
        </trans-unit>
        <trans-unit id="ad0eb4a22e44d99ae045c52ec3f202dc664a29f9" translate="yes" xml:space="preserve">
          <source>Containers declare data requirements on &lt;code&gt;fragments&lt;/code&gt; using GraphQL fragments.</source>
          <target state="translated">Контейнеры объявляют требования к данным для &lt;code&gt;fragments&lt;/code&gt; с помощью фрагментов GraphQL.</target>
        </trans-unit>
        <trans-unit id="8928f5de2a918d60f1bbb5d72e6a68cb7502e86a" translate="yes" xml:space="preserve">
          <source>Convenience method that wraps the constructor, passing some default parameters and returning an instance.</source>
          <target state="translated">Удобный метод,обертывающий конструктор,передающий некоторые параметры по умолчанию и возвращающий экземпляр.</target>
        </trans-unit>
        <trans-unit id="dd226f43ba5c8ff842931a3ca2796d7c444510a9" translate="yes" xml:space="preserve">
          <source>Conversion Playbook</source>
          <target state="translated">Плэйбук конвертации</target>
        </trans-unit>
        <trans-unit id="aca075e23eed144339279d097d6fa88dc0718ec3" translate="yes" xml:space="preserve">
          <source>Conversion Scripts</source>
          <target state="translated">Сценарии преобразования</target>
        </trans-unit>
        <trans-unit id="bc6e3a410aa372c2487ec123aa51c13c61ba9355" translate="yes" xml:space="preserve">
          <source>Core Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ee6cde901e483137128dd1aaa541e9ba1b4f92" translate="yes" xml:space="preserve">
          <source>Core primitives for building offline/persisted caching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b3852c7992c04bd7a1c305779c938fba2763c16" translate="yes" xml:space="preserve">
          <source>Core primitives to enable subscriptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93c185376ad3e3749d528694597be4eb780596d" translate="yes" xml:space="preserve">
          <source>Create a mutation instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some props. Note that &lt;code&gt;this.props&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; available inside the constructor function, but are set for all the methods mentioned below (&lt;code&gt;getCollisionKey&lt;/code&gt;, &lt;code&gt;getOptimisticResponse&lt;/code&gt;, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with &lt;code&gt;applyUpdate&lt;/code&gt; or &lt;code&gt;commitUpdate&lt;/code&gt;.</source>
          <target state="translated">Создайте экземпляр мутации, используя ключевое слово &lt;code&gt;new&lt;/code&gt; , при желании передав ему некоторые свойства. Обратите внимание , что &lt;code&gt;this.props&lt;/code&gt; это &lt;em&gt;не&lt;/em&gt; доступно внутри функции конструктора, но установлены для всех методов указанных ниже ( &lt;code&gt;getCollisionKey&lt;/code&gt; , &lt;code&gt;getOptimisticResponse&lt;/code&gt; , и т.д.). Это ограничение связано с тем, что свойства мутации могут зависеть от данных из RelayEnvironment, которые неизвестны, пока мутация не будет применена с помощью &lt;code&gt;applyUpdate&lt;/code&gt; или &lt;code&gt;commitUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70fb5b0ec1a182be6e0a0d9950900f7bbb367668" translate="yes" xml:space="preserve">
          <source>Create a route instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some params.</source>
          <target state="translated">Создайте экземпляр маршрута, используя ключевое слово &lt;code&gt;new&lt;/code&gt; , при необходимости передав ему некоторые параметры.</target>
        </trans-unit>
        <trans-unit id="22330ce575ca322006e65a1cba21c0878bcce956" translate="yes" xml:space="preserve">
          <source>Creates a new Relay Container - see the &lt;a href=&quot;guides-containers&quot;&gt;Container Guide&lt;/a&gt; for more details and examples.</source>
          <target state="translated">Создает новый контейнер ретрансляции - см. &lt;a href=&quot;guides-containers&quot;&gt;Руководство&lt;/a&gt; по контейнерам для получения дополнительных сведений и примеров.</target>
        </trans-unit>
        <trans-unit id="59d477c173081caca582f697a308e90dad49d280" translate="yes" xml:space="preserve">
          <source>Creates a new record in the store given a &lt;code&gt;dataID&lt;/code&gt; and the &lt;code&gt;typeName&lt;/code&gt; as defined by the GraphQL schema. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the newly created record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21efb0843ee16f4a18b237b51a057d09100b1064" translate="yes" xml:space="preserve">
          <source>Creates an edge given a &lt;a href=&quot;#recordsourceselectorproxy&quot;&gt;&lt;code&gt;store&lt;/code&gt;&lt;/a&gt;, a connection, the edge type, and a record that holds that connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc084a8dfcc6a7bce1de7aefac278e961edc50ea" translate="yes" xml:space="preserve">
          <source>Currently the easiest way to create a network layer is via a helper from the &lt;code&gt;relay-runtime&lt;/code&gt; package:</source>
          <target state="translated">В настоящее время самый простой способ создать сетевой уровень - использовать помощник из пакета &lt;code&gt;relay-runtime&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="461be9b9f59ebf2cd3bfe288b44d41bb20a992dc" translate="yes" xml:space="preserve">
          <source>Custom HTTP headers can be configured by providing a &lt;code&gt;headers&lt;/code&gt; object:</source>
          <target state="translated">Пользовательские заголовки HTTP можно настроить, предоставив объект &lt;code&gt;headers&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e441c87bb7618c55b15a3915a29a65fc20c0d1cd" translate="yes" xml:space="preserve">
          <source>Custom Network Layers</source>
          <target state="translated">Пользовательские сетевые слои</target>
        </trans-unit>
        <trans-unit id="c604943e72b71d4741cddde2419706b8dc35d372" translate="yes" xml:space="preserve">
          <source>Custom Routing and More</source>
          <target state="translated">Пользовательские маршруты и многое другое</target>
        </trans-unit>
        <trans-unit id="3fe80ac6912200b4e6e928a52d6c87fd5c777197" translate="yes" xml:space="preserve">
          <source>Custom network layers must conform to the following &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</source>
          <target state="translated">Пользовательские сетевые уровни должны соответствовать следующему интерфейсу &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; . Несмотря на то, что сетевой уровень по умолчанию представляет собой инстанцируемый класс, который принимает некоторую конфигурацию, это не является требованием внедренного сетевого уровня.</target>
        </trans-unit>
        <trans-unit id="342f49485ae8bc8e1ade62ea93e337457051f472" translate="yes" xml:space="preserve">
          <source>Custom network layers that must conform to the &lt;code&gt;RelayNetworkLayer&lt;/code&gt; interface.</source>
          <target state="translated">Настраиваемые сетевые уровни, которые должны соответствовать интерфейсу &lt;code&gt;RelayNetworkLayer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e195dc960c4de2f5938ab244ca476e61a3b512b" translate="yes" xml:space="preserve">
          <source>Custom open-source implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c9c9c8ea99084415bd2064a41ac8fc43148678" translate="yes" xml:space="preserve">
          <source>Data Components aka Containers</source>
          <target state="translated">Компоненты данных,также известные как Контейнеры</target>
        </trans-unit>
        <trans-unit id="682fde2c24e47bc1edbae33948606de2438e015b" translate="yes" xml:space="preserve">
          <source>Data Dependencies With GraphQL</source>
          <target state="translated">Зависимость данных с помощью GraphQL</target>
        </trans-unit>
        <trans-unit id="d3ef9a304a148420eba3a55c129f2235b1f9e1ec" translate="yes" xml:space="preserve">
          <source>Data Flow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8344c50bb3999d69b17cd5abd2f78e4f029419a" translate="yes" xml:space="preserve">
          <source>Data Masking</source>
          <target state="translated">Маскировка данных</target>
        </trans-unit>
        <trans-unit id="9f570bdcfd6b031f335934a6700ab99601783168" translate="yes" xml:space="preserve">
          <source>Data Model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18842877f84be9bb3ae10673c4e60242f22c160" translate="yes" xml:space="preserve">
          <source>Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e75bbe26916d6856acc894895802461b7a14ea" translate="yes" xml:space="preserve">
          <source>Data Types &amp;amp; Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7054bcb2316977418a434163d17919c53dc34953" translate="yes" xml:space="preserve">
          <source>Data fetched as a result of a &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is not written into the client store, but you can add code that processes it in the &lt;code&gt;onSuccess&lt;/code&gt; callback that you pass into &lt;code&gt;commitUpdate()&lt;/code&gt;:</source>
          <target state="translated">Данные принес в результате &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; конфигурации не написано в клиентском хранилище, но вы можете добавить код , который обрабатывает его в &lt;code&gt;onSuccess&lt;/code&gt; обратного вызова , который вы передаете в &lt;code&gt;commitUpdate()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af0a7349a2e7fc64dce9051e92bfe24510a15ba4" translate="yes" xml:space="preserve">
          <source>Data-Fetching APIs</source>
          <target state="translated">API для сбора данных</target>
        </trans-unit>
        <trans-unit id="303a7cb486f5bdd65204f79dab8db7f52fcbe4b2" translate="yes" xml:space="preserve">
          <source>Data/View Consistency</source>
          <target state="translated">Согласованность данных/видов</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="ed85a15e615bc7cc2aa9ef71ae94ad5fcb7456cf" translate="yes" xml:space="preserve">
          <source>Debugging Programmatically</source>
          <target state="translated">Отладка программно</target>
        </trans-unit>
        <trans-unit id="45cae91f4ddfa0491f43cb639f9ed34ee522658d" translate="yes" xml:space="preserve">
          <source>Debugging Visually</source>
          <target state="translated">Отладка Визуально</target>
        </trans-unit>
        <trans-unit id="f33d59090001ed2c388b4cc1db43054af86f06dd" translate="yes" xml:space="preserve">
          <source>Default Network Layer</source>
          <target state="translated">Сетевой уровень по умолчанию</target>
        </trans-unit>
        <trans-unit id="20f0fc44b4326d9865c55f56d274d841f7d0587e" translate="yes" xml:space="preserve">
          <source>DefaultNetworkLayer (static property)</source>
          <target state="translated">DefaultNetworkLayer (статическое свойство)</target>
        </trans-unit>
        <trans-unit id="cc401fba47cbe2915424897d3b03537f262c5e09" translate="yes" xml:space="preserve">
          <source>Defining Containers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c761cb3b3af168784bb525eb6cc8bdda8deb1143" translate="yes" xml:space="preserve">
          <source>Deletes a record from the store given its &lt;code&gt;dataID&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5bf36afc63e00856e220e9305692ac4cae2b78" translate="yes" xml:space="preserve">
          <source>Design a fat query that covers every possible field that could change:</source>
          <target state="translated">Спроектируйте жирный запрос,который охватывает все возможные поля,которые могут измениться:</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="ef7942184e9ad574a626b6cd3619cdb041e9c029" translate="yes" xml:space="preserve">
          <source>During this migration, use the &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; tools and APIs to work with both Relay Classic and Relay Modern.</source>
          <target state="translated">Во время этой миграции используйте инструменты и API &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; для работы как с Relay Classic, так и с Relay Modern.</target>
        </trans-unit>
        <trans-unit id="7c5b3fea8b3510ceda05e64bba7877572b147261" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RelayMutationTransaction&lt;/code&gt; has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</source>
          <target state="translated">В каждом &lt;code&gt;RelayMutationTransaction&lt;/code&gt; есть методы для проверки состояния мутации и предоставления способов отката или повторной отправки мутации по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="fbce231c1e8a474ca4ecbc6efb0b7e9a89704719" translate="yes" xml:space="preserve">
          <source>Edge creation and insertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd362bb1462055d845230a17457c0b8e8d86a3b8" translate="yes" xml:space="preserve">
          <source>Either an instance of &lt;code&gt;Relay.Route&lt;/code&gt; or an object with the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;queries&lt;/code&gt;, and optionally the &lt;code&gt;params&lt;/code&gt; properties.</source>
          <target state="translated">Либо экземпляр &lt;code&gt;Relay.Route&lt;/code&gt; , либо объект с &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;queries&lt;/code&gt; и, необязательно, свойствами &lt;code&gt;params&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="b887632c87cffc81f6686f76c25016e576fb2182" translate="yes" xml:space="preserve">
          <source>Even though we have access to the &lt;code&gt;data&lt;/code&gt; object in &lt;code&gt;renderFetched&lt;/code&gt;, the actual data is intentionally opaque. This prevents the &lt;code&gt;renderFetched&lt;/code&gt; from creating an implicit dependency on the fragments declared by &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">Несмотря на то, что у нас есть доступ к объекту &lt;code&gt;data&lt;/code&gt; в &lt;code&gt;renderFetched&lt;/code&gt; , фактические данные намеренно непрозрачны. Это предотвращает создание &lt;code&gt;renderFetched&lt;/code&gt; неявной зависимости от фрагментов, объявленных &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="ee6ee8c5dded943d0aabd760c567c92f2ee1cb72" translate="yes" xml:space="preserve">
          <source>Example Data Flow: Fetching Query Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a85f686c00fd7f5967d3cbaebf03180ef14d5b" translate="yes" xml:space="preserve">
          <source>Example Data Flow: Reading and Observing the Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b92abde2e68af5a3c565dacca8e8cfd97caced5" translate="yes" xml:space="preserve">
          <source>Example of a simple mutation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="47edfe63fdfee7ee20d0d17ccd2198d126f5e61d" translate="yes" xml:space="preserve">
          <source>Examples on how to migrate &lt;code&gt;this.props.setVariables&lt;/code&gt; calls from the old API.</source>
          <target state="translated">Примеры переноса вызовов &lt;code&gt;this.props.setVariables&lt;/code&gt; из старого API.</target>
        </trans-unit>
        <trans-unit id="dba94b198da2fb33fd23ea18f305f3d0a3ec1059" translate="yes" xml:space="preserve">
          <source>Extensible Core</source>
          <target state="translated">Расширяемое ядро</target>
        </trans-unit>
        <trans-unit id="2dd50f5706aa755699729587eac1b10f1cff5f0e" translate="yes" xml:space="preserve">
          <source>FIELDS_CHANGE</source>
          <target state="translated">FIELDS_CHANGE</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">Получение данных</target>
        </trans-unit>
        <trans-unit id="9fa4dbe72754c9ca8a7a48295981890f655e2aba" translate="yes" xml:space="preserve">
          <source>Fetching Data For a View</source>
          <target state="translated">Сбор данных для просмотра</target>
        </trans-unit>
        <trans-unit id="ec6417097316a1a14f3a999d488c8c77877598bd" translate="yes" xml:space="preserve">
          <source>Fetching Data from the Server</source>
          <target state="translated">Получение данных с сервера</target>
        </trans-unit>
        <trans-unit id="a342eda81c049d657e5bd1f80671b4b62b62acba" translate="yes" xml:space="preserve">
          <source>Fetching all the data for a view hierarchy.</source>
          <target state="translated">Получение всех данных для иерархии представлений.</target>
        </trans-unit>
        <trans-unit id="448b955ee10782eac37b116fa4e7872f8363dbf4" translate="yes" xml:space="preserve">
          <source>Fewer Requirements around Routing</source>
          <target state="translated">Меньше требований к маршруту</target>
        </trans-unit>
        <trans-unit id="90c0db66830e63b9ba0686e057e6915aaf66921d" translate="yes" xml:space="preserve">
          <source>Finally, GraphQL is printed (e.g. to files, saved to a database, etc) and any artifacts are generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0e1cc40fccace9c870f52b415d915d429a858c" translate="yes" xml:space="preserve">
          <source>Finally, let's tie it all together in &lt;code&gt;./js/components/App.js&lt;/code&gt;:</source>
          <target state="translated">Наконец, давайте &lt;code&gt;./js/components/App.js&lt;/code&gt; все это вместе в ./js/components/App.js :</target>
        </trans-unit>
        <trans-unit id="81320abd4244f533456ecdb31fa9235954b4c027" translate="yes" xml:space="preserve">
          <source>Finally, subscriptions whose data actually changed are notified via their callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="794475575e8e8e88251415839f49042175570f60" translate="yes" xml:space="preserve">
          <source>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</source>
          <target state="translated">Наконец,мы строим нашу схему (начальный тип запроса-это тип запроса,который мы определили выше)и экспортируем ее.</target>
        </trans-unit>
        <trans-unit id="f5d8e52e096ba49348c23c94d52fb5128a53fc82" translate="yes" xml:space="preserve">
          <source>Finds or creates a single record associated with a mutable record. This is a shortcut to &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; with &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; should the associated record be non-existant.</source>
          <target state="translated">Находит или создает отдельную запись, связанную с изменяемой записью. Это ярлык для &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; с &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; , если связанная запись не существует.</target>
        </trans-unit>
        <trans-unit id="d4726e1215a3598f0b285dcd1fdabf31356a5b5b" translate="yes" xml:space="preserve">
          <source>First, install the plugin (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">Сначала установите плагин (обычно как &lt;code&gt;devDependency&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="37434c70c94c9bba372cffd8d1a31c930d66efb8" translate="yes" xml:space="preserve">
          <source>First, let's take a look at a plain connection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee7304a030b3188f69053199e1aa24d2c7e6c40" translate="yes" xml:space="preserve">
          <source>First, let's take a look at the &lt;code&gt;environment&lt;/code&gt; input. To perform the mutation on the correct &lt;code&gt;environment&lt;/code&gt; with the relevant data, it's a good idea to use the &lt;code&gt;environment&lt;/code&gt; used to render the components. It's accessible at &lt;code&gt;this.props.relay.environment&lt;/code&gt; from the component.</source>
          <target state="translated">Во-первых, давайте посмотрим на ввод &lt;code&gt;environment&lt;/code&gt; . Чтобы выполнить мутацию в правильной &lt;code&gt;environment&lt;/code&gt; с соответствующими данными, рекомендуется использовать &lt;code&gt;environment&lt;/code&gt; используемую для визуализации компонентов. Он доступен в &lt;code&gt;this.props.relay.environment&lt;/code&gt; из компонента.</target>
        </trans-unit>
        <trans-unit id="c30bc0a2078d4d797890b53dd71501499ca6f601" translate="yes" xml:space="preserve">
          <source>First, the list of data IDs that have changed since the last &lt;code&gt;notify()&lt;/code&gt; is compared against data IDs listed in the subscription's latest &lt;code&gt;Snapshot&lt;/code&gt;. If there is no overlap, the subscription's results cannot possibly have changed (if you imagine the graph visually, there is no overlap between the part of the graph that changed and the part that is selected). In this case the subscription is ignored, otherwise processing continues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3aab624101e00feee75c13777205ffcca8d11b0" translate="yes" xml:space="preserve">
          <source>First, you need &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchman&lt;/a&gt; installed:</source>
          <target state="translated">Во-первых, вам нужно установить &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;сторожа&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0a54de1cc9f2aff2bed1cf76593938b1ded20fcf" translate="yes" xml:space="preserve">
          <source>Flat Routes</source>
          <target state="translated">Плоские маршруты</target>
        </trans-unit>
        <trans-unit id="995180ea866af99054ca25768d4bd2ff5d5c8968" translate="yes" xml:space="preserve">
          <source>Flow Type Generation</source>
          <target state="translated">Генерация типа потока</target>
        </trans-unit>
        <trans-unit id="6d01829e4505f8d6171af1d3b3cae8dab5a6ee84" translate="yes" xml:space="preserve">
          <source>Following our &lt;code&gt;TodoList_list&lt;/code&gt; example, we would pass arguments to the fragment like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46edacfc204a583603ecb9b72b53c55f60dbc6a" translate="yes" xml:space="preserve">
          <source>For a complete example of how to load a &lt;code&gt;schema.js&lt;/code&gt; file, run the introspection query to get schema information, and save it to a JSON file, check out the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;starter kit&lt;/a&gt;.</source>
          <target state="translated">Чтобы получить полный пример того, как загрузить файл &lt;code&gt;schema.js&lt;/code&gt; , запустить запрос самоанализа, чтобы получить информацию о схеме, и сохранить ее в файл JSON, ознакомьтесь с &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;начальным комплектом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfe4ba012b2b664f6e8a52e5430ca8b838d37291" translate="yes" xml:space="preserve">
          <source>For a simple application that's already a nice improvement.</source>
          <target state="translated">Для простого приложения,которое уже является хорошим улучшением.</target>
        </trans-unit>
        <trans-unit id="c72ede783eff4e07fb8b68b24df1f1f2ee6802eb" translate="yes" xml:space="preserve">
          <source>For connections like the above, &lt;code&gt;ConnectionHandler&lt;/code&gt; helps us find the record:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889156520813e19bcd7a5e0e8e569875e2029955" translate="yes" xml:space="preserve">
          <source>For details on how to interact with the Relay Store, please refer to our Relay Store &lt;a href=&quot;relay-store&quot;&gt;docs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c534ed5280cce92d6b2b0550da3496f193200e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;rangeBehaviors&lt;/code&gt; could be written this way:</source>
          <target state="translated">Например, &lt;code&gt;rangeBehaviors&lt;/code&gt; можно записать так:</target>
        </trans-unit>
        <trans-unit id="4999f2258aff41aa7c828698a3d72fe291b86eb2" translate="yes" xml:space="preserve">
          <source>For example, a network layer can be a simple object that conforms to the interface:</source>
          <target state="translated">Например,сетевой уровень может быть простым объектом,который соответствует интерфейсу:</target>
        </trans-unit>
        <trans-unit id="2aa5827894bb94d499f20a1d29faefe22d07cad1" translate="yes" xml:space="preserve">
          <source>For example, a user and their address might be represented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5650972e3a1efbfc7e79658033f2f192552c13cb" translate="yes" xml:space="preserve">
          <source>For example, assuming the server schema &lt;code&gt;./schema.graphql&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ffcdf17f2ad817cd3da93a900284bc63c193056" translate="yes" xml:space="preserve">
          <source>For example, given the two files:</source>
          <target state="translated">Например,учитывая два файла:</target>
        </trans-unit>
        <trans-unit id="12bad1fdad02e0f5d5569bcccc232e7c8357d9c5" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;currentDate&lt;/code&gt; is set in &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;variables&lt;/code&gt;, then $currentDate may be referenced in any fragment included in the &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">Например, если &lt;code&gt;currentDate&lt;/code&gt; установлен в &lt;code&gt;variables&lt;/code&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; , то на $ currentDate можно ссылаться в любом фрагменте, включенном в &lt;code&gt;query&lt;/code&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="384dd94e051eb1541d94fe85b1aa65cfc4b8720e" translate="yes" xml:space="preserve">
          <source>For example, let's redefine our &lt;code&gt;TodoList_list&lt;/code&gt; fragment to take some arguments using &lt;code&gt;@argumentDefinitions&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1178c99ccfd9629da7c347f69a733ccb2674242f" translate="yes" xml:space="preserve">
          <source>For examples of more complex optimistic updates, including adding and removing from a list, see the &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todo example app&lt;/a&gt;.</source>
          <target state="translated">Примеры более сложных оптимистичных обновлений, включая добавление и удаление из списка, см. В &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;примере приложения Relay Modern Todo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a82abfdd90416cbeaffe64d3e50d78377188efce" translate="yes" xml:space="preserve">
          <source>For more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an &lt;code&gt;updater&lt;/code&gt; function:</source>
          <target state="translated">Для более сложных случаев использования вы можете захотеть выполнить настраиваемую логику для обновления кеша в памяти Relay при получении каждого ответа подписки. Для этого передайте функцию &lt;code&gt;updater&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2ac9b5543bc0f49df0cfb3a851760d47fc555d44" translate="yes" xml:space="preserve">
          <source>For more complicated mutations, &lt;code&gt;optimisticUpdater&lt;/code&gt; and &lt;code&gt;updater&lt;/code&gt; can be the same function.</source>
          <target state="translated">Для более сложных мутаций &lt;code&gt;optimisticUpdater&lt;/code&gt; и &lt;code&gt;updater&lt;/code&gt; могут быть одной и той же функцией.</target>
        </trans-unit>
        <trans-unit id="1137480158b92303f1522341248742d418f8a480" translate="yes" xml:space="preserve">
          <source>For more details on creating a Network, see the &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer guide&lt;/a&gt;.</source>
          <target state="translated">Для получения дополнительных сведений о создании сети см. &lt;a href=&quot;network-layer&quot;&gt;Руководство&lt;/a&gt; по сетевому слою .</target>
        </trans-unit>
        <trans-unit id="6a8624a85744c6bfa958d4ffba2ebcba068cf3d0" translate="yes" xml:space="preserve">
          <source>For more details, refer to the &lt;a href=&quot;local-state-management&quot;&gt;Local state management section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d4a5435c3cb6cdfd5a8c58ab671072ab888ff3" translate="yes" xml:space="preserve">
          <source>For more details, refer to the &lt;a href=&quot;persisted-queries&quot;&gt;Persisted Queries section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf88bc6b3b6a4c187092ec351a5b1077c1d26272" translate="yes" xml:space="preserve">
          <source>For new Relay apps or existing apps that have been fully converted to the Compat API, the Relay Modern runtime can be enabled to activate even more features. In addition to those described above, this includes:</source>
          <target state="translated">Для новых приложений Relay или существующих приложений,которые были полностью преобразованы в Compat API,время выполнения Relay Modern может быть включено для активации еще большего количества функций.В дополнение к описанным выше,это включает в себя:</target>
        </trans-unit>
        <trans-unit id="d800dc29a67ae0f7e1c89e3fa88acf537112a2a4" translate="yes" xml:space="preserve">
          <source>For users of classic Relay, note that the runtime makes as few assumptions as possible about GraphQL. Compared to earlier versions of Relay there is no concept of routes, there are no limitations on mutation input arguments or side-effects, arbitrary root fields just work, etc. At present, the main restriction from classic Relay that remains is the use of the &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;id&lt;/code&gt; field for object identification. However there is no fundamental reason that this restriction can't be relaxed (there is a single place in the codebase where object identity is determined), and we welcome feedback from the community about ways to support customizable object identity without negatively impacting performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18fbf073a81951774f334f655935c2dac6e6377a" translate="yes" xml:space="preserve">
          <source>Force Fetching</source>
          <target state="translated">Форсированное завлечение</target>
        </trans-unit>
        <trans-unit id="96bbe9b850cec5fbab27d61fde4b1fa63d06e24d" translate="yes" xml:space="preserve">
          <source>Force Fetching with Data from the Client</source>
          <target state="translated">Форсированное получение данных от клиента</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="365b08de44008517ff803d0c36a644ac290dba44" translate="yes" xml:space="preserve">
          <source>Found offers integration with Relay Modern and Relay Classic via &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;. Found Relay runs queries for matched routes in parallel, and supports fetching Relay data in parallel with downloading async bundles from code splitting when using Relay Modern.</source>
          <target state="translated">Found предлагает интеграцию с Relay Modern и Relay Classic через &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt; . Found Relay выполняет запросы для совпадающих маршрутов параллельно и поддерживает выборку данных Relay параллельно с загрузкой пакетов async из разделения кода при использовании Relay Modern.</target>
        </trans-unit>
        <trans-unit id="e58abca7c5abd6b02071e05687c03305e61f7adb" translate="yes" xml:space="preserve">
          <source>Fragment Composition</source>
          <target state="translated">Фрагмент Состав</target>
        </trans-unit>
        <trans-unit id="44548256a4fe02219452b999f31774df4d7788f3" translate="yes" xml:space="preserve">
          <source>Fragment Container</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9b8ee7dc2184d0aab89be194eb15b57be40cef" translate="yes" xml:space="preserve">
          <source>Fragment composition is achieved via ES6 template string interpolation and &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">Композиция фрагмента достигается с помощью интерполяции строки шаблона &lt;code&gt;getFragment&lt;/code&gt; и getFragment :</target>
        </trans-unit>
        <trans-unit id="99eb0c4810611d5c803d75a7ca10220fd2d2cfea" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;User&lt;/code&gt; that is required by &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Композиция фрагмента работает аналогично - фрагмент родительского контейнера составляет фрагмент для каждого из своих дочерних элементов. В этом случае &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; должен получить информацию о &lt;code&gt;User&lt;/code&gt; которая требуется для &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2f68d40663d52153573dd0abe042e691b281b53" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c1ec38ec0f0411751ca1a7fa59d2e3f75e878a" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Композиция фрагмента работает аналогично - фрагмент родительского контейнера составляет фрагмент для каждого из своих дочерних элементов. В этом случае &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; необходимо получить информацию о &lt;code&gt;Todo&lt;/code&gt; , которые требуются &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7eb65ef2204b222cba330bf9518e103ffff4a9" translate="yes" xml:space="preserve">
          <source>Fragment variables</source>
          <target state="translated">Переменные фрагментов</target>
        </trans-unit>
        <trans-unit id="6c4797fcf380c1ad929a06c044c27ce633b8a89b" translate="yes" xml:space="preserve">
          <source>FragmentContainer</source>
          <target state="translated">FragmentContainer</target>
        </trans-unit>
        <trans-unit id="e8e4adae3ec551af9e8edf80d04fd880f87f33b9" translate="yes" xml:space="preserve">
          <source>Fragments can be composed in one of two ways:</source>
          <target state="translated">Фрагменты могут быть составлены одним из двух способов:</target>
        </trans-unit>
        <trans-unit id="1ec5c60b97bf9a572f6951db4d37f812151af82e" translate="yes" xml:space="preserve">
          <source>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user &lt;code&gt;123&lt;/code&gt;'s profile photo:</source>
          <target state="translated">Фрагменты могут быть встроены в другие фрагменты или запросы. Например, приведенный выше фрагмент можно использовать для получения фотографии профиля пользователя &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5749ddc88402f36f29ad8ff8b7fc5a5626b02527" translate="yes" xml:space="preserve">
          <source>Fragments may also compose other fragments that are assigned to local variables:</source>
          <target state="translated">Фрагменты могут также составлять другие фрагменты,которые присваиваются локальным переменным:</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">Сбор мусора</target>
        </trans-unit>
        <trans-unit id="202728ddee5584ce607f4aab869a3630ba743b82" translate="yes" xml:space="preserve">
          <source>Garbage collection to evict entries from the cache when they can no longer be referenced by any view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e8bde6a75cc8bafc18233096a72b0f6248985e" translate="yes" xml:space="preserve">
          <source>General-purpose tools for building a GraphQL schema using JavaScript</source>
          <target state="translated">Инструменты общего назначения для построения GraphQL-схемы с использованием JavaScript</target>
        </trans-unit>
        <trans-unit id="2b67d1eb9affe329c622f0576365f0ee268cf097" translate="yes" xml:space="preserve">
          <source>Gets a fragment reference for use in a parent's query fragment.</source>
          <target state="translated">Получает ссылку на фрагмент для использования в родительском фрагменте запроса.</target>
        </trans-unit>
        <trans-unit id="efadaa65e42a5128618d6d70d6e5f16a32ea9213" translate="yes" xml:space="preserve">
          <source>Gets a reference to a child container's fragment for inclusion in a parent fragment.</source>
          <target state="translated">Получает ссылку на дочерний фрагмент контейнера для включения в родительский фрагмент.</target>
        </trans-unit>
        <trans-unit id="bab08a8b8e5697e21edf5ba8471a6d2976e052d5" translate="yes" xml:space="preserve">
          <source>Gets a string name used to refer to this request for printing debug output.</source>
          <target state="translated">Получает имя строки,используемое для ссылки на этот запрос для печати отладочного вывода.</target>
        </trans-unit>
        <trans-unit id="c66f9fff87afddb71ece32a2129c20b745b3303d" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL mutation.</source>
          <target state="translated">Получает строковое представление мутации GraphQL.</target>
        </trans-unit>
        <trans-unit id="f2fb6164e4d92fdf7bb9de20c1488df58f14ec49" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL query.</source>
          <target state="translated">Получает строковое представление GraphQL-запроса.</target>
        </trans-unit>
        <trans-unit id="abe1bcf50d4649b6cc620e50d25b565688c7d9a1" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</source>
          <target state="translated">Получает уникальный идентификатор для этой мутации.Эти идентификаторы полезны при назначении полезной нагрузки ответа на соответствующие мутации при отправке одного GraphQL-запроса.</target>
        </trans-unit>
        <trans-unit id="96e072f6fa8b2d20b9da83302dbda948494674bf" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</source>
          <target state="translated">Получает уникальный идентификатор для данного запроса.Эти идентификаторы полезны при назначении полезной нагрузки ответа на соответствующие запросы при отправке одного GraphQL-запроса.</target>
        </trans-unit>
        <trans-unit id="5406c8eaf62c01411092558cd572b43c5b89bfa6" translate="yes" xml:space="preserve">
          <source>Gets an optional map from name to File objects.</source>
          <target state="translated">Получает необязательную карту от имени до объектов Файла.</target>
        </trans-unit>
        <trans-unit id="1daf2e35612607247d326239b96ef7bd4c0deb13" translate="yes" xml:space="preserve">
          <source>Gets the type of the current record, as defined by the GraphQL schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee3ecb0267703f60ff46d5ccfae9291bc39b826" translate="yes" xml:space="preserve">
          <source>Gets the value of a field in the current record given the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118b9b0bfba623072bfed30c4a7c6d4b769ead2a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</source>
          <target state="translated">Получает переменные,используемые при мутации.Эти переменные должны быть сериализованы и отправлены в GraphQL-запросе.</target>
        </trans-unit>
        <trans-unit id="5f68839c1e374f581aaccfdd2584db85f5d5531a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</source>
          <target state="translated">Получает переменные,используемые в запросе.Эти переменные должны быть сериализованы и отправлены в GraphQL-запросе.</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="c50a651b10d01a7deafc80b4e09d60a50246f2f1" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;deletedIDFieldName&lt;/code&gt;, Relay will remove the node(s) from the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d609f05a6d3bf2ce92708edc4808c22e3566e07f" translate="yes" xml:space="preserve">
          <source>Given a connection, deletes any edges whose id matches the given id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d379af210d311a7a256db3fa6fe039dcbf2cbd54" translate="yes" xml:space="preserve">
          <source>Given a connection, inserts the edge at the beginning of the connection, or before the specified &lt;code&gt;cursor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bffc05ebf924c05ffda3d323c9605a38ad10f80" translate="yes" xml:space="preserve">
          <source>Given a connection, inserts the edge at the end of the connection, or after the specified &lt;code&gt;cursor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b19260759d77673b9a877795f157d4044253944" translate="yes" xml:space="preserve">
          <source>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">При наличии соединения,одного или нескольких идентификаторов данных в ответной нагрузке и пути между родителем и соединением,Реле удалит узел(ы)из соединения,но оставит соответствующую запись(и)в хранилище.</target>
        </trans-unit>
        <trans-unit id="e48271c6488ce169319e6996a17416ab8db56489" translate="yes" xml:space="preserve">
          <source>Given a deletedIDFieldName, Relay will remove the node(s) from the connection.</source>
          <target state="translated">Получив удаленное IDFieldName,Relay удалит узел(ы)из соединения.</target>
        </trans-unit>
        <trans-unit id="720b1124168e2fcea493421f01efb6519477f619" translate="yes" xml:space="preserve">
          <source>Given a parent, &lt;code&gt;connectionKeys&lt;/code&gt;, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47de81551f168ce6aed9196d0adf126b977177b6" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</source>
          <target state="translated">Учитывая родителя,соединение и один или несколько идентификаторов данных в ответной нагрузке,Реле удалит узел(ы)из соединения и удалит соответствующую(ые)запись(ы)из хранилища.</target>
        </trans-unit>
        <trans-unit id="a51dc0bfb8bd3ee42a7194ed76f6218686158817" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</source>
          <target state="translated">При наличии родителя,соединения и имени вновь созданного фронта в ответе полезной нагрузки Реле добавит узел в магазин и прикрепит его к соединению в соответствии с заданным поведением диапазона.</target>
        </trans-unit>
        <trans-unit id="524a22d3cb952e409df0e138141726ed755fe115" translate="yes" xml:space="preserve">
          <source>Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">При наличии родителя,ключей соединения,одного или нескольких идентификаторов данных в ответной нагрузке и пути между родителем и соединением,Relay удалит узел(ы)из соединения,но оставит соответствующую запись(и)в хранилище.</target>
        </trans-unit>
        <trans-unit id="6c8602a6c8072fdb24f4522613cbc2f7cfcca2ed" translate="yes" xml:space="preserve">
          <source>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</source>
          <target state="translated">Учитывая родителя,информация о соединении и имя вновь созданного фронта в ответе полезной нагрузки Реле добавит узел в магазин и прикрепит его к соединению в соответствии с поведением(ями)диапазона,указанного в connectionInfo.</target>
        </trans-unit>
        <trans-unit id="a9b1b0a91341253151fdb0d5e41db14af5ba2ef3" translate="yes" xml:space="preserve">
          <source>Given a record and a connection key, and optionally a set of filters, &lt;code&gt;getConnection&lt;/code&gt; retrieves a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; that represents a connection that was annotated with a &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5933a7dc46c436f13a884a4a3f5f844894c6ee04" translate="yes" xml:space="preserve">
          <source>Given the GraphQL document:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0fa81ee1013085b7d63ff166408f30527ff41a" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a &lt;code&gt;Container&lt;/code&gt; to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">Учитывая простой компонент React и фрагмент GraphQL, теперь мы можем определить &lt;code&gt;Container&lt;/code&gt; чтобы сообщить Relay о требованиях к данным этого компонента. Давайте сначала посмотрим на код, а потом посмотрим, что происходит:</target>
        </trans-unit>
        <trans-unit id="78d8c89827c5602fc6d1d40331d005ddbc42de59" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a Fragment Container to specify this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e96a8e96d952292ce981325cfa1fcff52e52c7e" translate="yes" xml:space="preserve">
          <source>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas &amp;mdash; let's look at them briefly in order to understand why Relay uses the approach that it does:</source>
          <target state="translated">Учитывая эти реальные ограничения, подход в GraphQL заключается в том, чтобы клиенты запрашивали вещи, которые могут измениться после мутации. Но что именно мы вкладываем в этот запрос? Во время разработки Relay мы исследовали несколько идей - давайте кратко рассмотрим их, чтобы понять, почему Relay использует именно такой подход:</target>
        </trans-unit>
        <trans-unit id="5c41e44eb6db12a7dd58862cf6f3cc1584c314eb" translate="yes" xml:space="preserve">
          <source>Globally invalidates the Relay store. This will cause any data that was written to the store before invalidation occurred to be considered stale, and will be considered to require refetch the next time a query is checked with &lt;code&gt;environment.check()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4eb1ab683c392399fa825b2dea3b7e5f8189912" translate="yes" xml:space="preserve">
          <source>GraphQL</source>
          <target state="translated">GraphQL</target>
        </trans-unit>
        <trans-unit id="d1104d2d1c77df98433b7b7cb498cfbba782bab4" translate="yes" xml:space="preserve">
          <source>GraphQL Relay Specification</source>
          <target state="translated">Спецификация реле GraphQL</target>
        </trans-unit>
        <trans-unit id="2462160d86cfb1c5d092d0aa517b3b680333ccb3" translate="yes" xml:space="preserve">
          <source>GraphQL Schema</source>
          <target state="translated">Графическая Схема GraphQL</target>
        </trans-unit>
        <trans-unit id="37f3b6a18cf42e1932e52d60a342d388f522602a" translate="yes" xml:space="preserve">
          <source>GraphQL Subscriptions &amp;amp; Live Queries</source>
          <target state="translated">Подписки GraphQL и живые запросы</target>
        </trans-unit>
        <trans-unit id="55705029d139bf2fb4343a8dd5d01c514bb24b08" translate="yes" xml:space="preserve">
          <source>GraphQL in Relay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6884fbda0403c3eb6a361b276df83698590e1779" translate="yes" xml:space="preserve">
          <source>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification&lt;/a&gt;.</source>
          <target state="translated">GraphQL разработан для поддержки широкого спектра шаблонов доступа к данным. Чтобы понять структуру данных приложения, Relay требует, чтобы вы следовали определенным соглашениям при определении схемы. Они задокументированы в &lt;a href=&quot;graphql-relay-specification&quot;&gt;Спецификации реле GraphQL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55711b09c6616aea30b39a64a358b0d9490999c3" translate="yes" xml:space="preserve">
          <source>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</source>
          <target state="translated">GraphQL представляет новые способы получения данных клиентами,ориентируясь на потребности разработчиков продуктов и клиентских приложений.Он предоставляет разработчикам возможность указать точные данные,необходимые для просмотра,и позволяет клиенту получать эти данные в одном сетевом запросе.По сравнению с традиционными подходами,такими как REST,GraphQL помогает приложениям получать данные более эффективно (по сравнению с ресурсно-ориентированными REST-подходами)и избегать дублирования логики сервера (что может происходить с пользовательскими конечными точками).Кроме того,GraphQL помогает разработчикам развязывать код продукта и логику сервера.Например,продукт может получать больше или меньше информации,не требуя внесения изменений в каждую соответствующую конечную точку сервера.Это отличный способ получения данных.</target>
        </trans-unit>
        <trans-unit id="cd5d1ec7247a2826222f29ae64e2e192abb30c33" translate="yes" xml:space="preserve">
          <source>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for &lt;strong&gt;declarative data-fetching&lt;/strong&gt;. By separating &lt;em&gt;what&lt;/em&gt; data to fetch from &lt;em&gt;how&lt;/em&gt; it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies &amp;mdash; React, Relay, and GraphQL &amp;mdash; are powerful on their own, the combination is a &lt;strong&gt;UI platform&lt;/strong&gt; that allows us to &lt;em&gt;move fast&lt;/em&gt; and &lt;em&gt;ship high-quality apps at scale&lt;/em&gt;.</source>
          <target state="translated">GraphQL предоставляет мощный инструмент для создания эффективных, независимых клиентских приложений. Relay основывается на этой функциональности, чтобы обеспечить основу для &lt;strong&gt;декларативной выборки данных&lt;/strong&gt; . Разделяя , &lt;em&gt;что&lt;/em&gt; данные выборки из , &lt;em&gt;как&lt;/em&gt; он забирается, реле помогает разработчикам создавать приложения , которые являются надежными, прозрачными и производительными по умолчанию. Это отличное дополнение к компонентно-центричному мышлению, отстаиваемому React. Хотя каждая из этих технологий - React, Relay и GraphQL - мощна сама по себе, комбинация представляет собой &lt;strong&gt;платформу пользовательского интерфейса,&lt;/strong&gt; которая позволяет нам &lt;em&gt;быстро двигаться&lt;/em&gt; и &lt;em&gt;поставлять высококачественные приложения в большом масштабе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fe79f455fe739b1f1e04461fc0dc38be9fbb5f79" translate="yes" xml:space="preserve">
          <source>GraphQL text is extracted from source files and &quot;parsed&quot; into an intermediate representation (IR) using information from the schema.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e541828d19d4a8e98d359b78f14f53ce50019b3d" translate="yes" xml:space="preserve">
          <source>Here are a few examples of some of the included transforms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de18940b97877b6ff77ae9e81b1c868cf154cdc" translate="yes" xml:space="preserve">
          <source>Here are a quick example of adding a todo item to a Todo list using this &lt;a href=&quot;https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36&quot;&gt;example schema&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1745637b6e7ac2208886e0fe73413f315dc1d52e" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">Вот базовая реализация &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; , которая игнорирует стили, чтобы подчеркнуть функциональность:</target>
        </trans-unit>
        <trans-unit id="622275495084316cce6011efe3c5533f0b505dd1" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7acba2d971e69e956adf8a6ecc2371b0bf96df3" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">Вот базовая реализация &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; , которая игнорирует стили, чтобы подчеркнуть функциональность:</target>
        </trans-unit>
        <trans-unit id="dbbbbf44b31cd11738f96ef61375f12e9722988b" translate="yes" xml:space="preserve">
          <source>Here's an example of this mutation in use by a &lt;code&gt;LikeButton&lt;/code&gt; component:</source>
          <target state="translated">Вот пример этой мутации, используемой компонентом &lt;code&gt;LikeButton&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="385d7c0cfbb336e0125f7ea51dde1cd3078887da" translate="yes" xml:space="preserve">
          <source>Here's an example query that fetches a story's text and its author's name:</source>
          <target state="translated">Вот пример запроса,в котором запрашивается текст истории и имя ее автора:</target>
        </trans-unit>
        <trans-unit id="0694e515f41dabfcc348f2df0677999ef99af1ea" translate="yes" xml:space="preserve">
          <source>Here's what happens when the container is rendered:</source>
          <target state="translated">Вот что происходит,когда контейнер выставляется:</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="05531ed7907681dd3a6ac4e94e82348c1af49264" translate="yes" xml:space="preserve">
          <source>Historically, Relay started out internally at Facebook as a routing framework. However, Relay no longer makes any assumptions about routing, and works with a variety of routing options.</source>
          <target state="translated">Исторически сложилось так,что &quot;Реле&quot; начинала свою работу внутри Facebook как фреймворк для маршрутизации.Однако,Relay больше не делает никаких предположений о маршрутизации,и работает с различными вариантами маршрутизации.</target>
        </trans-unit>
        <trans-unit id="f96c9aa85d59b7983b33495b149e7fee5f7bf418" translate="yes" xml:space="preserve">
          <source>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called &lt;code&gt;PageInfo&lt;/code&gt;. So let's issue the two queries that got us ships again, but this time ask for &lt;code&gt;hasNextPage&lt;/code&gt;:</source>
          <target state="translated">Хм. Кораблей больше не было; Думаю, повстанцев в системе было всего пять. Было бы неплохо узнать, что мы достигли конца соединения, без необходимости делать еще один обход, чтобы это проверить. Модель подключения предоставляет эту возможность с помощью типа &lt;code&gt;PageInfo&lt;/code&gt; . Итак, давайте &lt;code&gt;hasNextPage&lt;/code&gt; два запроса, которые снова вернули нам корабли, но на этот раз попросим hasNextPage :</target>
        </trans-unit>
        <trans-unit id="c2d977e2354e1f199b20eba8fe4202828b60baf5" translate="yes" xml:space="preserve">
          <source>However components using the Relay Modern API (&lt;code&gt;'react-relay'&lt;/code&gt;) and the Relay Classic API (&lt;code&gt;'react-relay/classic'&lt;/code&gt;) cannot be used with each other.</source>
          <target state="translated">Однако компоненты, использующие Relay Modern API ( &lt;code&gt;'react-relay'&lt;/code&gt; ) и Relay Classic API ( &lt;code&gt;'react-relay/classic'&lt;/code&gt; ), не могут использоваться друг с другом.</target>
        </trans-unit>
        <trans-unit id="502eeb0d2871522e994df777d19577771dfe2094" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates &lt;a href=&quot;https://flow.org&quot;&gt;Flow&lt;/a&gt; types as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. For example, you can import the generated Flow types like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6bd5564a2d8d3eed39f5285b27795de9e86379" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates flow types, as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. To import the types:</source>
          <target state="translated">Однако компилятор Relay также автоматически генерирует типы потоков в &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;виде комментариев к типам&lt;/a&gt; . Чтобы импортировать типы:</target>
        </trans-unit>
        <trans-unit id="10b177310affbe7aa4dd35d3f040c504f1597c28" translate="yes" xml:space="preserve">
          <source>However, Relay Modern expects modern JavaScript global types (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Object.assign&lt;/code&gt;) to be defined. If you support older browsers and devices which may not yet provide these natively, consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">Однако Relay Modern ожидает, что будут определены современные глобальные типы JavaScript ( &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Object.assign&lt;/code&gt; ). Если вы поддерживаете старые браузеры и устройства, которые могут еще не иметь их изначально, подумайте о включении глобального полифилла в ваше связанное приложение, например &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; или &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e508d49142051371922e56dda4689dd05e8567d5" translate="yes" xml:space="preserve">
          <source>However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to request waterfalls if used unnecessarily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a07f8e11c88d99ebfa0ba8926d9d2bf8daec90" translate="yes" xml:space="preserve">
          <source>However, the fragment could also fetch each of user &lt;code&gt;123&lt;/code&gt;'s friends' profile photos:</source>
          <target state="translated">Тем не менее, фрагмент может также получить фотографии профиля каждого из друзей пользователя &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a72518acd301cccb79e4d618aa2b5df43d443663" translate="yes" xml:space="preserve">
          <source>However, when &lt;a href=&quot;#createpaginationcontainer&quot;&gt;specifying connection fragments&lt;/a&gt; for a Pagination Container, it is expected that at least one of the fragments contains a &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;GraphQL connection&lt;/a&gt; to paginate over, and that the connection field is annotated with a &lt;code&gt;@connection&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd69a4732fe12702d5ff5838852eb29e4a9e2e02" translate="yes" xml:space="preserve">
          <source>Idea</source>
          <target state="translated">Idea</target>
        </trans-unit>
        <trans-unit id="0daab153956ffb0745c3d2cf4823ed87bf8cdc9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optimisticResponse&lt;/code&gt; is provided, Relay will use it to update the fields under the records as specified by the ids in the &lt;code&gt;optimisticResponse&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e63eef54ae07ad9832be86ae57e57b86e1543dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optimisticUpdater&lt;/code&gt; is provided, Relay will execute it and update the store accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd280c6059870c93a4668954d90f25f6c6ff4e2" translate="yes" xml:space="preserve">
          <source>If a &quot;force fetch&quot; occurs and there is insufficient data on the client, the same behavior as &lt;strong&gt;Fetching Data from the Server&lt;/strong&gt; can be expected. However, if a &quot;force fetch&quot; occurs and there &lt;em&gt;is&lt;/em&gt; sufficient data on the client to render, we can expect the following behavior:</source>
          <target state="translated">Если происходит &amp;laquo;принудительная выборка&amp;raquo; и на клиенте недостаточно данных, можно ожидать того же поведения, что и при получении &lt;strong&gt;данных с сервера&lt;/strong&gt; . Однако, если &amp;laquo;сила выборки&amp;raquo; происходит и там &lt;em&gt;есть&lt;/em&gt; достаточные данные о клиенте , чтобы сделать, мы можем ожидать следующее поведение:</target>
        </trans-unit>
        <trans-unit id="7ed138709fbda62e44a180d5f323c654e6cc766a" translate="yes" xml:space="preserve">
          <source>If a fragment uses variables that are determined at runtime, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;see below&lt;/a&gt;.</source>
          <target state="translated">Если фрагмент использует переменные, которые определяются во время выполнения, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;см. Ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5dc5ba510b8cc7e8340243c616a8461f6de45a" translate="yes" xml:space="preserve">
          <source>If a server request results in a failure to load data, we can expect the following behavior:</source>
          <target state="translated">Если запрос сервера приводит к невозможности загрузки данных,то можно ожидать следующего поведения:</target>
        </trans-unit>
        <trans-unit id="c11a40394f41454ad18de679c37d7363316ff63c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;updater&lt;/code&gt; was provided, Relay will execute it and update the store accordingly. The server payload will be available to the &lt;code&gt;updater&lt;/code&gt; as a root field in the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="500f13b73830f97ef3d0785c40a8e9be8e6865fb" translate="yes" xml:space="preserve">
          <source>If an error occurs that prevents &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; from fetching the data required for rendering &lt;code&gt;Component&lt;/code&gt;, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the &lt;code&gt;renderFailure&lt;/code&gt; prop:</source>
          <target state="translated">Если возникает ошибка, из-за которой &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; не может получить данные, необходимые для рендеринга &lt;code&gt;Component&lt;/code&gt; , по умолчанию ничего не будет отображаться. Поведение при обработке ошибок можно настроить, предоставив обратный вызов &lt;code&gt;renderFailure&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e4eb5b8214d4c82b80af57f3c1c0471dea0d3c7b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; ever changes, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will immediately start attempting to fulfill the new data requirements.</source>
          <target state="translated">Если &lt;code&gt;Component&lt;/code&gt; или &lt;code&gt;route&lt;/code&gt; когда-либо &lt;strong&gt;изменятся&lt;/strong&gt; , &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; немедленно начнет попытки выполнить новые требования к данным.</target>
        </trans-unit>
        <trans-unit id="e7c4473f87af75e4695d24734fbf44e9808a4049" translate="yes" xml:space="preserve">
          <source>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</source>
          <target state="translated">Если недостаточно данных на клиенте приводит Relay к отправке запроса сервера на получение дополнительных данных,можно ожидать следующего поведения:</target>
        </trans-unit>
        <trans-unit id="e7125117da9f12ab4891151c4ede73bbfc431ad0" translate="yes" xml:space="preserve">
          <source>If no request is in flight pendingVariables is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Если запрос не выполняется, pendingVariables имеет значение &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e94ccf62b4c7fbeeff1884ed8210524c0aaf3f8f" translate="yes" xml:space="preserve">
          <source>If not supplied, a unique collision key is derived (meaning that the created mutation will be independent and not collide with any other).</source>
          <target state="translated">Если он не поставляется,то получается уникальный ключ столкновения (это означает,что созданная мутация будет независимой и не столкнется ни с каким другим).</target>
        </trans-unit>
        <trans-unit id="9f1093c79885887f1a46e11c2dbc9de6bfd2239c" translate="yes" xml:space="preserve">
          <source>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</source>
          <target state="translated">Если на клиенте имеется достаточно данных,чтобы Relay не нужно было посылать запрос серверу,то можно ожидать следующего поведения:</target>
        </trans-unit>
        <trans-unit id="1753e3219d9e6a6f6bf62bc19a7f313caa79226f" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</source>
          <target state="translated">В случае поставки и установки значения true,запрос данных всегда будет сделан на сервер,независимо от того,доступны ли уже данные на клиенте.</target>
        </trans-unit>
        <trans-unit id="b8cb57719ab0a4774595aab7b466840e3a324de3" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</source>
          <target state="translated">Если данные будут предоставлены и установлены в true,то запрос данных всегда будет сделан на сервер,независимо от того,доступны ли данные на клиенте для немедленного выполнения требований к данным.</target>
        </trans-unit>
        <trans-unit id="9652265c2b29a20de6e20099f7748481a1d4b122" translate="yes" xml:space="preserve">
          <source>If the Relay part of an application is some widget or single view as part of a larger application, you don't need any routing. You can just render a &lt;code&gt;QueryRenderer&lt;/code&gt; somewhere on the page to fetch and render the data you need there. This option is simple and should be used when sufficient.</source>
          <target state="translated">Если ретрансляционная часть приложения представляет собой некоторый виджет или отдельное представление как часть более крупного приложения, вам не нужна маршрутизация. Вы можете просто отобразить &lt;code&gt;QueryRenderer&lt;/code&gt; где-нибудь на странице, чтобы получить и отобразить там нужные вам данные. Этот вариант прост, и его следует использовать, когда его достаточно.</target>
        </trans-unit>
        <trans-unit id="9c687f957f6123e9a6702a53723c6fbcdd75a426" translate="yes" xml:space="preserve">
          <source>If the callback returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one &lt;code&gt;queryConfig&lt;/code&gt; to another).</source>
          <target state="translated">Если обратный вызов возвращает значение &lt;code&gt;undefined&lt;/code&gt; , отображается ранее визуализированное представление (или ничего, если предыдущее представление не было) (например, при переходе от одного &lt;code&gt;queryConfig&lt;/code&gt; к другому).</target>
        </trans-unit>
        <trans-unit id="fa97f983a844f15bf5a18032a6bd22f04fd47eea" translate="yes" xml:space="preserve">
          <source>If the component doesn't actually use &lt;code&gt;setVariables()&lt;/code&gt;, and just uses &lt;code&gt;initialVariables&lt;/code&gt; to share values between JS and GraphQL, there are two alternative approaches:</source>
          <target state="translated">Если компонент на самом деле не использует &lt;code&gt;setVariables()&lt;/code&gt; , а просто использует &lt;code&gt;initialVariables&lt;/code&gt; для обмена значениями между JS и GraphQL, есть два альтернативных подхода:</target>
        </trans-unit>
        <trans-unit id="6f707589cc2da01315091844b3b383efdccb634c" translate="yes" xml:space="preserve">
          <source>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</source>
          <target state="translated">Если мутация определяет оптимистическую полезную нагрузку-набор данных для локального применения в ожидании ответа сервера-Relay применяет это изменение и обновляет все затронутые React компоненты (обратите внимание,что оптимистические обновления не перезаписывают известные данные сервера в кэш).</target>
        </trans-unit>
        <trans-unit id="9d815af768aaeea304d01b0f060f4bcc34f6f6e5" translate="yes" xml:space="preserve">
          <source>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its &lt;code&gt;getCollisionKey&lt;/code&gt; implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</source>
          <target state="translated">Если мутация не будет &amp;laquo;конфликтовать&amp;raquo; (перекрываться) с другими ожидающими мутациями - как указано в ее реализации &lt;code&gt;getCollisionKey&lt;/code&gt; - она ​​отправляется на сервер. В случае конфликта он ставится в очередь до завершения конфликтующих мутаций.</target>
        </trans-unit>
        <trans-unit id="e86698a9dbbdbb49974d25aeca449ae1fbb9e654" translate="yes" xml:space="preserve">
          <source>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</source>
          <target state="translated">Если render callback не предоставляется,то по умолчанию выводится контейнер,если данные доступны,существующий вид,если он существует,или ничего.</target>
        </trans-unit>
        <trans-unit id="1a73cc6d4c2d46fb79932c374ed9da299d065e97" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; suffix, the &lt;code&gt;data&lt;/code&gt; prop name will be used:</source>
          <target state="translated">Если суффикс &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; отсутствует , будет использовано имя свойства &lt;code&gt;data&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="62768ad0f3d9c4db4330d79d61d8599e64fd7a9c" translate="yes" xml:space="preserve">
          <source>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</source>
          <target state="translated">Если мы сделаем то же самое с Империей,мы обнаружим,что она возвращает другой идентификатор,и мы сможем получить его заново:</target>
        </trans-unit>
        <trans-unit id="62f00a1501647642fb670b9befaa1fb2d5b19d8f" translate="yes" xml:space="preserve">
          <source>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</source>
          <target state="translated">Если мы предоставим мутации метод, который соответствует описанной выше сигнатуре, ему будет предоставлена ​​возможность изменять переменные построителей фрагментов на основе предыдущих переменных (или &lt;code&gt;initialVariables&lt;/code&gt; если предыдущие не существуют), мета-маршрута, и среда выполнения. Какие бы переменные ни возвращал этот метод, они станут доступными для построителей фрагментов этой мутации.</target>
        </trans-unit>
        <trans-unit id="29d042cd073944a1316b1c84fe494fc214ee7caa" translate="yes" xml:space="preserve">
          <source>If we replace &lt;code&gt;2&lt;/code&gt; with a new immutable record, we'll also get a new immutable instance of the cache object. However, records &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are untouched. Because the data is normalized, we can't tell that &lt;code&gt;story&lt;/code&gt;'s contents have changed just by looking at the &lt;code&gt;story&lt;/code&gt; record alone.</source>
          <target state="translated">Если мы заменим &lt;code&gt;2&lt;/code&gt; новой неизменяемой записью, мы также получим новый неизменяемый экземпляр объекта кеша. Однако записи &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;3&lt;/code&gt; остались нетронутыми. Поскольку данные нормализованы, мы не можем сказать, что содержание &lt;code&gt;story&lt;/code&gt; изменилось, просто взглянув только на запись &lt;code&gt;story&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3442e671845ad2d6f63d621dcbdd2a0032b009d1" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this route for arbitrary users, we can subclass the &lt;code&gt;Relay.Route&lt;/code&gt; abstract class. &lt;code&gt;Relay.Route&lt;/code&gt; makes it easy to define a set of queries and required parameters to be re-used multiple times:</source>
          <target state="translated">Если мы хотим создать экземпляр этого маршрута для произвольных пользователей, мы можем &lt;code&gt;Relay.Route&lt;/code&gt; подкласс абстрактного класса Relay.Route . &lt;code&gt;Relay.Route&lt;/code&gt; упрощает определение набора запросов и необходимых параметров для многократного повторного использования:</target>
        </trans-unit>
        <trans-unit id="1e290d52905763c30ab6c18d70c7f5a099e17ab8" translate="yes" xml:space="preserve">
          <source>If you do decide to use an &lt;code&gt;optimisticUpdater&lt;/code&gt;, often times it can be the same function as &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf233e85c6ba7e3a45e4100d4c2cae37e5ec06e0" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of Flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b62113e72e08231a01f5d4a07e448ee27964d21" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">Если вы обнаружите, что вам нужно сделать что-то уникальное (например, сгенерировать типы, соответствующие более старой версии потока, или проанализировать исходные файлы, отличные от javascript), вы можете создать свою собственную версию компилятора, заменив свои собственные &lt;code&gt;FileWriter&lt;/code&gt; и &lt;code&gt;ASTCache&lt;/code&gt; , или добавив дополнительный &lt;code&gt;IRTransform&lt;/code&gt; . Обратите внимание, что внутренние API &lt;code&gt;RelayCompiler&lt;/code&gt; находятся в постоянной итерации, поэтому развертывание вашей собственной версии может привести к несовместимости с будущими выпусками.</target>
        </trans-unit>
        <trans-unit id="7224441b6f15886cd449f3742b23181788ee9b99" translate="yes" xml:space="preserve">
          <source>If you wish to provide your own &lt;code&gt;handlerProvider&lt;/code&gt;, you can do so:</source>
          <target state="translated">Если вы хотите предоставить свой собственный &lt;code&gt;handlerProvider&lt;/code&gt; , вы можете сделать это:</target>
        </trans-unit>
        <trans-unit id="49a21b30f5b3a1b121343f35b747fe542d51dbf3" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;createRefetchContainer&lt;/code&gt; then your &lt;code&gt;refetch&lt;/code&gt; method may also update these variables to render with new values.</source>
          <target state="translated">Если вы используете &lt;code&gt;createRefetchContainer&lt;/code&gt; , ваш метод &lt;code&gt;refetch&lt;/code&gt; также может обновлять эти переменные для отображения с новыми значениями.</target>
        </trans-unit>
        <trans-unit id="0ccc0940cec44b44c366f2d98c395662eb2f306c" translate="yes" xml:space="preserve">
          <source>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</source>
          <target state="translated">Если вы используете другую реализацию GraphQL сервера,мы рекомендуем адаптировать приведенный выше пример для загрузки схемы с вашего GraphQL сервера (например,через HTTP запрос),а затем сохранить результат в виде JSON.</target>
        </trans-unit>
        <trans-unit id="2e76567f0db1f25cdaed090474feff64180bb110" translate="yes" xml:space="preserve">
          <source>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</source>
          <target state="translated">Представьте себе,что у нас есть простое приложение,которое получает список историй и некоторые подробности о каждой из них.Вот как это может выглядеть в ресурсо-ориентированном REST:</target>
        </trans-unit>
        <trans-unit id="448e3d99f5bde0fa9efac34be83b204ae98c345a" translate="yes" xml:space="preserve">
          <source>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</source>
          <target state="translated">Реализуйте этот метод в случаях,когда конфигурация мутатора,необходимая для обработки оптимистического ответа,должна отличаться от той,которая обрабатывает ответ сервера.</target>
        </trans-unit>
        <trans-unit id="62181f13d4fff5bed161f01ef77d8db655301bec" translate="yes" xml:space="preserve">
          <source>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</source>
          <target state="translated">Реализуйте этот метод,чтобы создать оптимистичный ответ,имеющий такую же форму,как и полезная нагрузка ответа сервера.Этот оптимистичный ответ будет использоваться для упреждающего обновления клиентского кэша перед возвращением сервера,создавая впечатление,что мутация завершилась мгновенно.</target>
        </trans-unit>
        <trans-unit id="24bc32f306fba32d2cbf91f2cd1999f36a16435a" translate="yes" xml:space="preserve">
          <source>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</source>
          <target state="translated">Реализуйте этот метод,чтобы вернуть ключ от столкновения.Реле будет посылать любые мутации,имеющие один и тот же ключ столкновения,на сервер последовательно и по порядку.</target>
        </trans-unit>
        <trans-unit id="1e3fee95e387e2e4175f4c37de616bb736c7491c" translate="yes" xml:space="preserve">
          <source>Implement this method to return a map of &lt;code&gt;File&lt;/code&gt; objects to upload as part of a mutation.</source>
          <target state="translated">Реализуйте этот метод, чтобы вернуть карту объектов &lt;code&gt;File&lt;/code&gt; для загрузки как часть мутации.</target>
        </trans-unit>
        <trans-unit id="48d0a56a8bcb298a554f5516aac54d6f77d81acd" translate="yes" xml:space="preserve">
          <source>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</source>
          <target state="translated">Реализуйте этот метод для возврата true,когда поставляемые параметры поддерживаются этим сетевым уровнем.Он используется для объявления того,какие функции сетевого уровня поддерживаются.</target>
        </trans-unit>
        <trans-unit id="b153e451079dd8470ac1e1681b4c8e4668b52b86" translate="yes" xml:space="preserve">
          <source>Implement this method to send mutations to the server. When the server response is obtained, this method must either call &lt;code&gt;mutationRequest.resolve&lt;/code&gt; with the response data, or &lt;code&gt;mutationRequest.reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Реализуйте этот метод для отправки изменений на сервер. При получении ответа сервера этот метод должен либо вызвать &lt;code&gt;mutationRequest.resolve&lt;/code&gt; с данными ответа, либо &lt;code&gt;mutationRequest.reject&lt;/code&gt; с объектом &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d31efc29644775c604543b99db2b73a14120012" translate="yes" xml:space="preserve">
          <source>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call &lt;code&gt;resolve&lt;/code&gt; with the response data, or &lt;code&gt;reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Реализуйте этот метод для отправки запросов на сервер. Для каждого запроса запроса, когда получен ответ сервера, этот метод должен либо вызвать &lt;code&gt;resolve&lt;/code&gt; с данными ответа, либо &lt;code&gt;reject&lt;/code&gt; с помощью объекта &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1774e52d0e556763970083c582a2823556fad1d9" translate="yes" xml:space="preserve">
          <source>Implement this required method to design a &amp;lsquo;fat query&amp;rsquo; &amp;ndash; one that represents every field in your data model that could change as a result of this mutation.</source>
          <target state="translated">Реализуйте этот обязательный метод для разработки &amp;laquo;толстого запроса&amp;raquo; - такого, который представляет каждое поле в вашей модели данных, которое может измениться в результате этой мутации.</target>
        </trans-unit>
        <trans-unit id="55c82c1ede81ef7c75eb0f5ad805b7c8131bec8a" translate="yes" xml:space="preserve">
          <source>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</source>
          <target state="translated">Реализуйте этот требуемый метод,чтобы дать ретранслятору инструкции о том,как использовать полезную нагрузку отклика от каждой мутации для обновления клиентского магазина.</target>
        </trans-unit>
        <trans-unit id="17378e1f66fb4d758998ffc792b8f969174e1a87" translate="yes" xml:space="preserve">
          <source>Implement this required method to prepare variables to be used as input to the mutation.</source>
          <target state="translated">Реализуйте этот требуемый метод для подготовки переменных,которые будут использоваться в качестве входных данных для мутации.</target>
        </trans-unit>
        <trans-unit id="e0d5783849893b65928056a3e01f878a4ebb371a" translate="yes" xml:space="preserve">
          <source>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</source>
          <target state="translated">Реализуйте этот требуемый метод для возврата операции мутации GraphQL,которая представляет собой выполняемую мутацию.</target>
        </trans-unit>
        <trans-unit id="d8c789b0ff99a369ebb08eda75d64a2002a8918e" translate="yes" xml:space="preserve">
          <source>Importing generated definitions</source>
          <target state="translated">Импорт сгенерированных определений</target>
        </trans-unit>
        <trans-unit id="a8c0b4ec0c84b678651530ba2d81f9beb98a2561" translate="yes" xml:space="preserve">
          <source>In GraphQL, &lt;strong&gt;queries&lt;/strong&gt; declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">В GraphQL &lt;strong&gt;запросы&lt;/strong&gt; объявляют поля, которые существуют в корневом типе запроса. Например, следующий запрос может получать имя пользователя с &lt;code&gt;id&lt;/code&gt; из &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42cc08262fb0bb543ca0770499256c848ef63cb2" translate="yes" xml:space="preserve">
          <source>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</source>
          <target state="translated">В React Native,мы можем запланировать обработку реле,чтобы избежать прерывания сенсорных жестов следующим образом:</target>
        </trans-unit>
        <trans-unit id="8ebfcf2d8faf5ad639fc9d0514f8f7159330d866" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;QueryRenderer query={...} variables={...} render={...}&amp;gt;&lt;/code&gt; for this purpose. The &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt; define what data to fetch and &lt;code&gt;render&lt;/code&gt; defines what to render. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5187bfb626e29a7807af4b6499d8505f13e32b2" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; for this purpose. The container is the item to render, and the queryConfig provides queries that specify &lt;em&gt;which&lt;/em&gt; item to fetch. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">В React для рендеринга представления требуются два входа: &lt;em&gt;компонент&lt;/em&gt; для рендеринга и &lt;em&gt;корневой&lt;/em&gt; узел DOM (UI) для рендеринга. Рендеринг контейнеров Relay аналогичен: нам нужен &lt;em&gt;контейнер&lt;/em&gt; для рендеринга и &lt;em&gt;корень&lt;/em&gt; в графе, с которого можно начать наш запрос. Мы также должны убедиться, что запросы к контейнеру выполняются, и может потребоваться отображение индикатора загрузки во время выборки данных. Подобно &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; , Relay предоставляет для этой цели &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; . Контейнер - это элемент для рендеринга, а queryConfig предоставляет запросы, которые указывают, &lt;em&gt;какой&lt;/em&gt; элемент нужно извлечь. Вот как мы можем визуализировать &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f9d43e8de662b43a98bf53a133be5a295724798" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">В Relay зависимости данных описываются с помощью &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt; . Для &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; зависимость может быть выражена следующим образом. Обратите внимание, что это точно соответствует форме, которую компонент ожидал для &lt;code&gt;user&lt;/code&gt; опоры.</target>
        </trans-unit>
        <trans-unit id="eba544839f5e404d357e1b726ac9db4aa7980297" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1084307d05023abf80689279ae0f77b70f810919" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">В Relay зависимости данных описываются с помощью &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt; . Для &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; зависимость может быть выражена следующим образом. Обратите внимание, что это точно соответствует форме, которую компонент ожидал для свойства &lt;code&gt;item&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8218e7619ef161652f44088010026d35f36055e0" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;QueryRenderer&lt;/strong&gt; so check out that section for more details.</source>
          <target state="translated">В Relay корень запроса определяется &lt;strong&gt;QueryRenderer,&lt;/strong&gt; поэтому ознакомьтесь с этим разделом для получения дополнительных сведений.</target>
        </trans-unit>
        <trans-unit id="30d65c55146011871e1262a4566a24588803dc0d" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;Route&lt;/strong&gt;. Continue to learn about Relay routes.</source>
          <target state="translated">В Relay корень запроса определяется &lt;strong&gt;маршрутом&lt;/strong&gt; . Продолжайте узнавать о маршрутах ретрансляции.</target>
        </trans-unit>
        <trans-unit id="8403870f1b9487ea70facda9683cbaadf51f154c" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;pagination-container&quot;&gt;pagination container&lt;/a&gt;, we usually annotate the actual connection field with &lt;code&gt;@connection&lt;/code&gt; to tell Relay which part needs to be paginated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21389450ed39ca7f4877ce1712aa3326324e6a9" translate="yes" xml:space="preserve">
          <source>In a resource-oriented REST system, we can maintain a &lt;strong&gt;response cache&lt;/strong&gt; based on URIs:</source>
          <target state="translated">В ресурсо-ориентированной системе REST мы можем поддерживать &lt;strong&gt;кеш ответов&lt;/strong&gt; на основе URI:</target>
        </trans-unit>
        <trans-unit id="ddc4813b133487bd46b76268444d4db66fd4598c" translate="yes" xml:space="preserve">
          <source>In a simple mutation, you only need &lt;code&gt;mutation&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;:</source>
          <target state="translated">В простой мутации вам нужны только &lt;code&gt;mutation&lt;/code&gt; и &lt;code&gt;variables&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="753db9b3fed6b02e90a81f5ecfd3b20ecf1201c5" translate="yes" xml:space="preserve">
          <source>In a simple subscription, you only need &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. This is appropriate when you are only changing the properties of existing records that can be identified by their &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">В простой подписке вам нужны только &lt;code&gt;subscription&lt;/code&gt; и &lt;code&gt;variables&lt;/code&gt; . Это уместно, когда вы изменяете только свойства существующих записей, которые можно идентифицировать по их &lt;code&gt;id&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d35beb84697160944c091bfc4ea7475ddba8bba" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">В дополнение к сценарию bin пакет &lt;code&gt;relay-compiler&lt;/code&gt; также &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;экспортирует код библиотеки,&lt;/a&gt; который вы можете использовать для создания более сложных конфигураций для компилятора или для расширения компилятора с помощью собственных пользовательских выходных данных.</target>
        </trans-unit>
        <trans-unit id="d61a016e90e92a84f22e5f4a46d1a7c70ba615d3" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/index.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee7cb663ba30043049419a3987f32bf98b8e3b6" translate="yes" xml:space="preserve">
          <source>In order to incrementally convert an existing codebase, we will need to use the Relay Modern API while continuing to use the Relay Classic runtime until all components are converted.</source>
          <target state="translated">Для того,чтобы постепенно конвертировать существующую кодовую базу,нам необходимо использовать Relay Modern API,продолжая использовать Relay Classic до тех пор,пока все компоненты не будут преобразованы.</target>
        </trans-unit>
        <trans-unit id="b06055f46a51395cce09c8715fc83f412863f99f" translate="yes" xml:space="preserve">
          <source>In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the &lt;code&gt;NetworkLayer&lt;/code&gt; interface when creating an instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</source>
          <target state="translated">Чтобы узнать, как получить доступ к вашему серверу GraphQL, Relay Modern требует от разработчиков предоставления объекта, реализующего интерфейс &lt;code&gt;NetworkLayer&lt;/code&gt; при создании экземпляра &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; . Среда использует этот сетевой уровень для выполнения запросов, изменений и (если ваш сервер их поддерживает) подписок. Это позволяет разработчикам использовать любой транспорт (HTTP, WebSockets и т. Д.) И аутентификацию, наиболее подходящую для их приложения, отделяя среду от особенностей сетевой конфигурации каждого приложения.</target>
        </trans-unit>
        <trans-unit id="9751687b059f090db3539850209951869b6090c4" translate="yes" xml:space="preserve">
          <source>In order to pass arguments to a fragment that has &lt;code&gt;@argumentDefinitions&lt;/code&gt;, you need to use the &lt;a href=&quot;graphql-in-relay#arguments&quot;&gt;&lt;code&gt;@arguments&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7aba64216b1cd4d2d2e3ad530a1f3188fad50d" translate="yes" xml:space="preserve">
          <source>In order to resolve a fragment into an array of objects you have to use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive.</source>
          <target state="translated">Чтобы преобразовать фрагмент в массив объектов, вы должны использовать &lt;code&gt;@relay(plural: true)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6f38813eb9d2dd5b73b9500e984665cfcbc9419" translate="yes" xml:space="preserve">
          <source>In our experience, the overwhelming majority of products want one specific behavior: fetch &lt;em&gt;all&lt;/em&gt; the data for a view hierarchy while displaying a loading indicator, and then render the &lt;em&gt;entire&lt;/em&gt; view once the data is ready.</source>
          <target state="translated">По нашему опыту, подавляющему большинству продуктов требуется одно конкретное поведение: выборка &lt;em&gt;всех&lt;/em&gt; данных для иерархии представлений при отображении индикатора загрузки, а затем визуализация &lt;em&gt;всего&lt;/em&gt; представления после того, как данные готовы.</target>
        </trans-unit>
        <trans-unit id="6a8da0b71c4c64aea6ae6834a91b9401918c3e7e" translate="yes" xml:space="preserve">
          <source>In that last example, think of &lt;code&gt;$format&lt;/code&gt; and &lt;code&gt;variables.format&lt;/code&gt; as the same value.</source>
          <target state="translated">В последнем примере подумайте о &lt;code&gt;$format&lt;/code&gt; и &lt;code&gt;variables.format&lt;/code&gt; как об одном и том же значении.</target>
        </trans-unit>
        <trans-unit id="3888fb491d2876bafea276807002a772ce2740fc" translate="yes" xml:space="preserve">
          <source>In the diagram above:</source>
          <target state="translated">На диаграмме выше:</target>
        </trans-unit>
        <trans-unit id="fafabc5dfb7d6fbb341fd52614abab0575f4bf79" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields.</source>
          <target state="translated">В приведенном ниже примере опора &lt;code&gt;user&lt;/code&gt; будет включать данные для полей &lt;code&gt;id&lt;/code&gt; и &lt;code&gt;name&lt;/code&gt; везде, где &lt;code&gt;...Component_internUser&lt;/code&gt; включен вместо обычного поведения Relay для маскировки этих полей.</target>
        </trans-unit>
        <trans-unit id="ec241670d9655070dff253ce613242b187214f42" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4294ed53c4279bdd7158ab4d044dda1b52e51b3" translate="yes" xml:space="preserve">
          <source>In the example below, the function &lt;code&gt;processItemData&lt;/code&gt; is called from a React component. It requires an item object with a specific set of fields. All React components that use this function should spread the &lt;code&gt;processItemData_item&lt;/code&gt; fragment to ensure all of the correct item data is loaded for this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b357ad1aa217f6b814380c122b67ca81691203" translate="yes" xml:space="preserve">
          <source>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</source>
          <target state="translated">В будущем расширенные возможности ретранслятора могут зависеть от того,сможет ли сетевой уровень поддерживать определенные функции.</target>
        </trans-unit>
        <trans-unit id="db9e71215ab64e7c01402f6a78301e1bc8b38923" translate="yes" xml:space="preserve">
          <source>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for &lt;em&gt;declarative data-fetching&lt;/em&gt;. Let's start at the beginning and fetch some data!</source>
          <target state="translated">В этой статье мы исследуем, что означает создание клиентской среды GraphQL и как это соотносится с клиентами для более традиционных систем REST. Попутно мы рассмотрим проектные решения, лежащие в основе Relay, и увидим, что это не только клиент GraphQL, но и платформа для &lt;em&gt;декларативной выборки данных&lt;/em&gt; . Давайте начнем с самого начала и получим некоторые данные!</target>
        </trans-unit>
        <trans-unit id="88a02e183add9d1c24413aa47baf530897708969" translate="yes" xml:space="preserve">
          <source>In this example the Route should be initialized with a &lt;code&gt;userID&lt;/code&gt; which gets passed on to the query. That &lt;code&gt;userID&lt;/code&gt; variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a &lt;code&gt;user&lt;/code&gt; fragment with the fields to be queried.</source>
          <target state="translated">В этом примере маршрут должен быть инициализирован &lt;code&gt;userID&lt;/code&gt; который передается в запрос. Эта переменная &lt;code&gt;userID&lt;/code&gt; будет автоматически передана в контейнер верхнего уровня и может быть использована там при необходимости. Кроме того, ожидается, что RelayContainer верхнего уровня будет иметь &lt;code&gt;user&lt;/code&gt; фрагмент с запрашиваемыми полями.</target>
        </trans-unit>
        <trans-unit id="fc3d9a2430b8dd6fdd1855b01aae967a1a86922c" translate="yes" xml:space="preserve">
          <source>In this example we are using a Refetch Container to fetch more stories in a story feed component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e65c0999502b8d880342481e43745e86b87bd15" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; will be fetched for the intial render.</source>
          <target state="translated">В этом примере &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; будет извлечен для начального рендеринга.</target>
        </trans-unit>
        <trans-unit id="b029685528e8da2f8ce2cf427c32ff8fbbf0ee00" translate="yes" xml:space="preserve">
          <source>In this example, create an inspector object based on the same source as passed into your &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. Later you can use this inspector object to inspect records. Inspector is only available in the development build.</source>
          <target state="translated">В этом примере создайте объект инспектора на основе того же источника, который передан в вашу &lt;a href=&quot;relay-environment&quot;&gt;среду ретрансляции&lt;/a&gt; . Позже вы можете использовать этот объект инспектора для проверки записей. Инспектор доступен только в разрабатываемой сборке.</target>
        </trans-unit>
        <trans-unit id="4e1907e8aedfd3075f12c9bb08511b6424b05151" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;width&lt;/code&gt; of the rendered image will always correspond to the &lt;code&gt;$size&lt;/code&gt; variable used to fetch the current version of &lt;code&gt;profilePicture.uri&lt;/code&gt;.</source>
          <target state="translated">В этом примере &lt;code&gt;width&lt;/code&gt; визуализированного изображения всегда будет соответствовать переменной &lt;code&gt;$size&lt;/code&gt; используемой для получения текущей версии &lt;code&gt;profilePicture.uri&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86e6e74d266fdaa434ba59fe220a17114ef82453" translate="yes" xml:space="preserve">
          <source>In this example, the fields associated with the &lt;code&gt;ship&lt;/code&gt; fragment will be made available on &lt;code&gt;this.props.ship&lt;/code&gt;.</source>
          <target state="translated">В этом примере поля, связанные с фрагментом &lt;code&gt;ship&lt;/code&gt; будут доступны на &lt;code&gt;this.props.ship&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85172d5db32fabb64291c47b382ebcc9097ed293" translate="yes" xml:space="preserve">
          <source>In this example, whenever &lt;code&gt;Parent&lt;/code&gt; is fetched, &lt;code&gt;Child&lt;/code&gt;'s fragment will also be fetched. When rendering, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; will only have access to the &lt;code&gt;props.foo.id&lt;/code&gt; field; data from the child fragment will be &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;masked&lt;/em&gt;&lt;/a&gt;. By default, &lt;code&gt;childFragment&lt;/code&gt; will use its corresponding initial variables. Relay will fetch &lt;code&gt;photo(size: 64)&lt;/code&gt;. When &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; is rendered it will also make the initial variables available as &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt;.</source>
          <target state="translated">В этом примере всякий раз, когда выбирается &lt;code&gt;Parent&lt;/code&gt; , также будет извлечен фрагмент &lt;code&gt;Child&lt;/code&gt; . При рендеринге &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; будет иметь доступ только к полю &lt;code&gt;props.foo.id&lt;/code&gt; ; данные из дочернего фрагмента будут &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;замаскированы&lt;/em&gt;&lt;/a&gt; . По умолчанию &lt;code&gt;childFragment&lt;/code&gt; будет использовать соответствующие начальные переменные. Реле загрузит &lt;code&gt;photo(size: 64)&lt;/code&gt; . Когда &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; отображается, он также делает исходные переменные доступными как &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f26e8bd2ce0d98aed5c314fad80d4d64f729d8" translate="yes" xml:space="preserve">
          <source>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</source>
          <target state="translated">В этом примере при загрузке картинки с новым размером вместо картинки отображается спиннер.</target>
        </trans-unit>
        <trans-unit id="11c9642bf0d68f60f8223631d67d9ed8e587f204" translate="yes" xml:space="preserve">
          <source>In this particular example, the only field that the &lt;code&gt;LikeButton&lt;/code&gt; cares about is &lt;code&gt;viewerDoesLike&lt;/code&gt;. That field will form part of the tracked query that Relay will intersect with the fat query of &lt;code&gt;LikeStoryMutation&lt;/code&gt; to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the &lt;code&gt;LikeButton&lt;/code&gt; need not worry about requesting them explicitly.</source>
          <target state="translated">В этом конкретном примере единственное поле, о &lt;code&gt;LikeButton&lt;/code&gt; заботится &lt;code&gt;viewerDoesLike&lt;/code&gt; - это viewerDoesLike . Это поле будет составлять часть отслеживаемого запроса, который Relay будет пересекать с толстым запросом &lt;code&gt;LikeStoryMutation&lt;/code&gt; , чтобы определить, какие поля запрашивать как часть полезной нагрузки ответа сервера для мутации. Другой компонент в другом месте приложения может интересоваться подсчетом лайков или подобным предложением. Поскольку эти поля будут автоматически добавлены в отслеживаемый запрос Relay, &lt;code&gt;LikeButton&lt;/code&gt; не нужно беспокоиться о том, чтобы запрашивать их явно.</target>
        </trans-unit>
        <trans-unit id="73de0e214eb1fe6fc2a92866867bd0a77a34d53e" translate="yes" xml:space="preserve">
          <source>In this simple example, let's assume we want to fetch the latest data for a &lt;code&gt;TodoItem&lt;/code&gt; from the server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877c9e959c13a50bd6cd2c0684ab7d5def3e1397" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay &amp;ndash; from the GraphQL schema on the server, to the React application on the client.</source>
          <target state="translated">В этом уроке мы создадим игру, используя мутации GraphQL. Цель игры - найти спрятанное сокровище в сетке из 9 квадратов. Мы дадим игрокам три попытки найти клад. Это должно дать нам полное представление о Relay - от схемы GraphQL на сервере до приложения React на клиенте.</target>
        </trans-unit>
        <trans-unit id="c1f61deb9bd75956e5146dd965f4efa1acf76ef5" translate="yes" xml:space="preserve">
          <source>Incrementally modernize your Relay Classic app in these steps:</source>
          <target state="translated">Инкрементально модернизируйте ваше приложение Relay Classic в этих шагах:</target>
        </trans-unit>
        <trans-unit id="0e8c879968a7b304e9792c15d95365ae89d2aa45" translate="yes" xml:space="preserve">
          <source>Injectable Custom Field Handlers</source>
          <target state="translated">Инжектируемые обработчики поля клиента</target>
        </trans-unit>
        <trans-unit id="e69c600fe29f0ed75880fd3b696888c254caf34f" translate="yes" xml:space="preserve">
          <source>Inline Fragments</source>
          <target state="translated">Фрагменты в сети</target>
        </trans-unit>
        <trans-unit id="1889c37693175c0225de5e6837f2ed3f9f529fe3" translate="yes" xml:space="preserve">
          <source>Inline the value in the GraphQL query, potentially annotating with a GraphQL comment (i.e. &lt;code&gt;# PAGE_SIZE&lt;/code&gt;).</source>
          <target state="translated">Вставьте значение в запрос GraphQL, потенциально аннотируя его комментарием GraphQL (например, &lt;code&gt;# PAGE_SIZE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0de09ec0beb82594d04ee09d8aeb812d06a3d58b" translate="yes" xml:space="preserve">
          <source>Install the latest version of Relay from the &lt;a href=&quot;relay-modern&quot;&gt;getting started guide&lt;/a&gt;.</source>
          <target state="translated">Установите последнюю версию Relay из &lt;a href=&quot;relay-modern&quot;&gt;руководства по началу работы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6603c8ba1e08fe9cd6b6dad35da64e9d939e1d23" translate="yes" xml:space="preserve">
          <source>Integration options are available for open-source routing libraries that can instead fetch data for nested routes in parallel. In many of these cases, using a batching network layer can bring additional benefits in avoiding sending multiple HTTP requests.</source>
          <target state="translated">Опции интеграции доступны для библиотек маршрутизации с открытым исходным кодом,которые могут вместо этого получать данные для вложенных параллельных маршрутов.Во многих из этих случаев использование пакетного сетевого уровня может принести дополнительные преимущества,позволяя избежать отправки нескольких HTTP-запросов.</target>
        </trans-unit>
        <trans-unit id="ba3a36612e2c9eeb3ee746032e0c52004c3b84f8" translate="yes" xml:space="preserve">
          <source>Integration with Relay Classic for React Router v2 or v3 is available via &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt;&lt;code&gt;react-router-relay&lt;/code&gt;&lt;/a&gt;, which will aggregate the queries for matched routes, and request data for all routes in parallel.</source>
          <target state="translated">Интеграция с Relay Classic для React Router v2 или v3 доступна через &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt; &lt;code&gt;react-router-relay&lt;/code&gt; &lt;/a&gt; , который будет агрегировать запросы для согласованных маршрутов и запрашивать данные для всех маршрутов параллельно.</target>
        </trans-unit>
        <trans-unit id="5681686d7dd00f9ec2ed83d86065fe5a9aa47328" translate="yes" xml:space="preserve">
          <source>Introduction to Relay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6f57623e58b4619d24d2a4a11fc39e22aace3a" translate="yes" xml:space="preserve">
          <source>Introduction to Relay Modern</source>
          <target state="translated">Введение в современную эстафету</target>
        </trans-unit>
        <trans-unit id="ede0b81585211d6b9897a8c1877bb4add0712d66" translate="yes" xml:space="preserve">
          <source>Invalidates the record. This will cause any query that references this record to be considered stale until the next time it is refetched, and will be considered to require a refetch the next time such a query is checked with &lt;code&gt;environment.check()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaf67797686a7d4a210975b6064cb3ac3259374" translate="yes" xml:space="preserve">
          <source>It is also assumed that the reader is already familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt;; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</source>
          <target state="translated">Также предполагается, что читатель уже знаком со &amp;laquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Звездными войнами&amp;raquo;&lt;/a&gt; ; Если нет, то лучше всего начать с версии &amp;laquo;Звездных войн&amp;raquo; 1977 года, хотя Специальное издание 1997 года будет служить целям этого документа.</target>
        </trans-unit>
        <trans-unit id="df2797c242fbac686a5646e3f8d0990c4c69631c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is already familiar with GraphQL; if not, the README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; is a good place to start.</source>
          <target state="translated">Предполагается, что читатель уже знаком с GraphQL; в противном случае README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; - хорошее место для начала.</target>
        </trans-unit>
        <trans-unit id="1c307b4b2396ebcfc67f090b9356192c30ee3e15" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;code&gt;@relay(mask: false)&lt;/code&gt;. Please instead consider using the &lt;code&gt;@inline&lt;/code&gt; fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f22d6b7169a71e14f872d1e3e6975d4ba68fa7" translate="yes" xml:space="preserve">
          <source>It is usually preferable to just pass an &lt;code&gt;optimisticResponse&lt;/code&gt; option instead of an &lt;code&gt;optimisticUpdater&lt;/code&gt;, unless you need to perform updates on the local records that are more complicated than just updating fields (e.g. deleting records or adding items to collections).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efecd775937b634754af4f65cbef5c8b4a7d96ba" translate="yes" xml:space="preserve">
          <source>It returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">Он возвращает &lt;code&gt;Disposable&lt;/code&gt; , для которого вы можете вызвать dispose &lt;code&gt;dispose()&lt;/code&gt; чтобы отменить повторную выборку.</target>
        </trans-unit>
        <trans-unit id="196589ac6e2b21bbd604e37c3b6f49f22ed50655" translate="yes" xml:space="preserve">
          <source>JavaScript environment requirements</source>
          <target state="translated">требования к среде JavaScript</target>
        </trans-unit>
        <trans-unit id="0b490a2df160ed0c71b8320c42d90d77b3406679" translate="yes" xml:space="preserve">
          <source>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</source>
          <target state="translated">JavaScript-помощники для определения связей между данными и мутациями,таким образом,чтобы плавно интегрироваться с Relay.</target>
        </trans-unit>
        <trans-unit id="3763226e2b043a56c9ba7559341b0774c3ea862d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is typically considered an &lt;strong&gt;anti-pattern&lt;/strong&gt; to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.</source>
          <target state="translated">Имейте в виду, что обычно считается &lt;strong&gt;анти-шаблоном&lt;/strong&gt; создание единого фрагмента, совместно используемого во многих контейнерах. Злоупотребление этой директивой может привести к избыточной выборке в вашем приложении.</target>
        </trans-unit>
        <trans-unit id="25fe5a3c2698d53807ead685c86822cf47cc3073" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;code&gt;onReadyStateChange&lt;/code&gt; in our next guide, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;.</source>
          <target state="translated">Узнайте, как использовать &lt;code&gt;onReadyStateChange&lt;/code&gt; в нашем следующем руководстве, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4f4fc8ca8973cbce4f7744b6aee5bccdaab0f6" translate="yes" xml:space="preserve">
          <source>Let's associate the mutation we just created with the root mutation type:</source>
          <target state="translated">Давайте свяжем только что созданную мутацию с типом мутации корня:</target>
        </trans-unit>
        <trans-unit id="f8acb98279c7a33b14354f6c3ef2bfe03f2deca1" translate="yes" xml:space="preserve">
          <source>Let's craft an optimistic response for the &lt;code&gt;LikeStoryMutation&lt;/code&gt; example above:</source>
          <target state="translated">Давайте &lt;code&gt;LikeStoryMutation&lt;/code&gt; оптимистичный ответ для приведенного выше примера LikeStoryMutation :</target>
        </trans-unit>
        <trans-unit id="ba32433c3c054db31c3adabcaef06296860fad94" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">Давайте рассмотрим, как это работает, с помощью компонента &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; , который составляет &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; сверху.</target>
        </trans-unit>
        <trans-unit id="25a086b22a4ba22a2ce589d6573f5857d3b2c109" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; we defined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89835a8e4dc90be9c02f2fb3d5af523e7de7cee2" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">Давайте рассмотрим, как это работает, с помощью компонента &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; , который составляет &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; сверху.</target>
        </trans-unit>
        <trans-unit id="8eb1ff4062deba895e97692f949a6733e97ad5f6" translate="yes" xml:space="preserve">
          <source>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</source>
          <target state="translated">Давайте посмотрим на некоторые примеры использования продуктов,чтобы понять,как мы включили эти идеи в Relay.Мы предположим,что имеем базовые знания о Реакции.</target>
        </trans-unit>
        <trans-unit id="839d4a2135069fbb40df14cc776556712d98fa6a" translate="yes" xml:space="preserve">
          <source>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</source>
          <target state="translated">Давайте откроем схему стартового набора и заменим импорт баз данных на только что созданные:</target>
        </trans-unit>
        <trans-unit id="a72ca83abcd8602717039b5f64a5b5a2b89c81e1" translate="yes" xml:space="preserve">
          <source>Let's see this in action, and query for the ID of the rebels:</source>
          <target state="translated">Давайте посмотрим на это в действии и запросим идентификатор повстанцев:</target>
        </trans-unit>
        <trans-unit id="c673a2bcf682f78fa812bcbefa0360994ed37548" translate="yes" xml:space="preserve">
          <source>Let's start a project using the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; as a base.</source>
          <target state="translated">Давайте начнем проект, &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;взяв&lt;/a&gt; за основу комплект Relay Starter Kit .</target>
        </trans-unit>
        <trans-unit id="a71dc4b410048806e0d1bbd75c4e909652f2f534" translate="yes" xml:space="preserve">
          <source>Let's take the rebels, and ask for their first ship:</source>
          <target state="translated">Давайте возьмем мятежников и попросим их первый корабль:</target>
        </trans-unit>
        <trans-unit id="510f4b78cd5f8fbd49c14a5834839d1ab18bb893" translate="yes" xml:space="preserve">
          <source>Let's tweak the file &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; to anchor our game to the &lt;code&gt;game&lt;/code&gt; root field of the schema:</source>
          <target state="translated">Давайте подправить файл &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; , чтобы закрепить нашу игру в &lt;code&gt;game&lt;/code&gt; корневой области схемы:</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">Лицензия BSD.</target>
        </trans-unit>
        <trans-unit id="8882f419c30a0460f51c5ec6edaf87949c2d7459" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;updater&lt;/code&gt;, there is no need to provide &lt;code&gt;optimisticUpdater&lt;/code&gt; for simple mutations (field change).</source>
          <target state="translated">Как и &lt;code&gt;updater&lt;/code&gt; , не требуется предоставлять &lt;code&gt;optimisticUpdater&lt;/code&gt; для простых мутаций (изменение поля).</target>
        </trans-unit>
        <trans-unit id="35b9502f3f76f952801534521de9830a54b15a16" translate="yes" xml:space="preserve">
          <source>Like it can be done with &lt;a href=&quot;guides-containers&quot;&gt;Relay containers&lt;/a&gt;, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</source>
          <target state="translated">Подобно тому, как это может быть сделано с &lt;a href=&quot;guides-containers&quot;&gt;контейнерами Relay&lt;/a&gt; , мы можем подготовить переменные для использования нашими построителями фрагментов мутации на основе предыдущих переменных и среды выполнения.</target>
        </trans-unit>
        <trans-unit id="3715b94c23f4ec20e0da2f29449a3c4646b3d581" translate="yes" xml:space="preserve">
          <source>Like most of the Relay APIs, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the &lt;code&gt;forceFetch&lt;/code&gt; boolean prop.</source>
          <target state="translated">Как и большинство API-интерфейсов Relay, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; пытается разрешить данные с помощью клиентского хранилища перед отправкой запроса на сервер. Если бы мы вместо этого хотели принудительно запросить сервер, даже если данные доступны на клиенте, мы могли бы использовать логическое &lt;code&gt;forceFetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f856144ecb9d05326c6d97badc1a9b834b075ac1" translate="yes" xml:space="preserve">
          <source>Like the GraphQL URI, the timeout and retry behavior can be configured:</source>
          <target state="translated">Как и GraphQL URI,таймаут и поведение повторных попыток могут быть настроены:</target>
        </trans-unit>
        <trans-unit id="4bcca57dadd610f8dfd235a855de5feef290f38a" translate="yes" xml:space="preserve">
          <source>Loading more data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a466fb1a66e2ac77ce3c14782794ae94365211" translate="yes" xml:space="preserve">
          <source>Managing asynchronous state transitions and coordinating concurrent requests.</source>
          <target state="translated">Управление асинхронными переходами состояния и координация параллельных запросов.</target>
        </trans-unit>
        <trans-unit id="52b2066f0ecc6504fa0d1683e70c5884d55a8b13" translate="yes" xml:space="preserve">
          <source>Managing errors.</source>
          <target state="translated">Управление ошибками.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="9973640b391cb4b42f93e3afba3395c46f6a7823" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Миграция приложения Relay Classic в Relay Modern не требует переписывания с нуля.Вместо этого,преобразовать по одному компоненту за раз в Relay Modern API,продолжая при этом иметь рабочее приложение.После того,как все компоненты были преобразованы,меньший и более быстрый режим работы Relay Modern может быть использован.</target>
        </trans-unit>
        <trans-unit id="a496d014360b49f4df7da034a0313b6a98aa03a1" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, you can convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Миграция приложения Relay Classic в Relay Modern не требует переписывания с нуля.Вместо этого,вы можете преобразовать один компонент за раз в Relay Modern API,продолжая при этом иметь рабочее приложение.После того,как все компоненты были преобразованы,меньший и более быстрый режим работы Relay Modern может быть использован.</target>
        </trans-unit>
        <trans-unit id="89ca9763c43ac3c5a6b549a8936812ce36f490d5" translate="yes" xml:space="preserve">
          <source>Migrating to Relay Modern</source>
          <target state="translated">Миграция в Релейный Модерн</target>
        </trans-unit>
        <trans-unit id="a2d0fdbac2d058cc7df5b6a959221d8c7b0c5956" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;createRefetchContainer&lt;/code&gt;</source>
          <target state="translated">Современный &lt;code&gt;createRefetchContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ddebd72b3485cb649586cd882bbc4a0abdd841" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">Современный &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; в контейнере разбиения на страницы</target>
        </trans-unit>
        <trans-unit id="eb7d95f729e7a3975428e61ddb5eb7d7241b4fd9" translate="yes" xml:space="preserve">
          <source>Modern Component</source>
          <target state="translated">Современный компонент</target>
        </trans-unit>
        <trans-unit id="43dee33213cedaefc62f54e39a529109b27d00fd" translate="yes" xml:space="preserve">
          <source>Modern Mutation</source>
          <target state="translated">Современная мутация</target>
        </trans-unit>
        <trans-unit id="f4c44d48df48d618739f0b3ad40791ec870c9181" translate="yes" xml:space="preserve">
          <source>Modern Runtime</source>
          <target state="translated">Современное время выполнения</target>
        </trans-unit>
        <trans-unit id="d9c1afdc6ae257e230b98cd64d31e69e21611588" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Современный: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a5e6e8b97a1927e12c72c467f5aebd11a8b3d28" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</source>
          <target state="translated">Современный: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08b3c5d91eb7d6d9c801374dc1e47b603bba9b4b" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createFragmentContainer&lt;/code&gt;</source>
          <target state="translated">Современный: &lt;code&gt;createFragmentContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f02b7506a9375f3a261dab66ee915f347b72fd85" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createPaginationContainer&lt;/code&gt;</source>
          <target state="translated">Современный: &lt;code&gt;createPaginationContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48a2a55168fdc7ce4613937fb203cff48a67840" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">Современный: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; в контейнере Refetch</target>
        </trans-unit>
        <trans-unit id="189e341013a3594080b144a6999f9577b74abee9" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">Современный: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; в контейнере пагинации</target>
        </trans-unit>
        <trans-unit id="b11a8c01d122a0561a2dbd1098a225c3e43e4308" translate="yes" xml:space="preserve">
          <source>Most applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.</source>
          <target state="translated">Большинство приложений создадут один экземпляр среды и будут использовать его везде.В определенных ситуациях,однако,вы можете захотеть создать несколько окружений для различных целей.Например,вы можете создать новый экземпляр окружения всякий раз,когда пользователь входит или выходит из системы,чтобы предотвратить совместное кэширование данных для разных пользователей.Аналогично,приложение,отрисовываемое сервером,может создавать новый экземпляр среды для каждого запроса,чтобы каждый запрос получал свой собственный кэш,а пользовательские данные не пересекались.В качестве альтернативы,у вас может быть несколько продуктов или функций в большом приложении,и вы хотите,чтобы каждый из них имел специфический продукт для работы в сети или кэширования.</target>
        </trans-unit>
        <trans-unit id="01c289d32b7203303850eb1c7dd2fdae6842ce3a" translate="yes" xml:space="preserve">
          <source>Must be a valid &lt;code&gt;RelayContainer&lt;/code&gt;. Relay will attempt to fulfill its data requirements before rendering it.</source>
          <target state="translated">Должен быть допустимый &lt;code&gt;RelayContainer&lt;/code&gt; . Перед отрисовкой Relay попытается выполнить свои требования к данным.</target>
        </trans-unit>
        <trans-unit id="7b7385bcbd1923e030dad3540db44e565ab25b47" translate="yes" xml:space="preserve">
          <source>Mutates the current record by copying the fields over from the passed in record &lt;code&gt;sourceRecord&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b750075e624836051694833f9672b6324629ee12" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new linked record on the given the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadad1577753ee37f1c2b694617c261c6134b034" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new set of linked records on the given the field name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e494f6c0a48343de5c18f2dbf8649d300cc34c93" translate="yes" xml:space="preserve">
          <source>Mutates the current record by setting a new value on the specified field. Returns the mutated record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c55f198bc8c7844e5e05f72964532f5dace071a0" translate="yes" xml:space="preserve">
          <source>Mutation props</source>
          <target state="translated">Мутационный реквизит</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="9d2e9b27d80bdf1627930a58bb10705ab9b7d295" translate="yes" xml:space="preserve">
          <source>Mutations with optimistic updates and the ability to update the cache with arbitrary logic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731fdeead88e01d93d0976eb789d77d6c8ba6428" translate="yes" xml:space="preserve">
          <source>Mutator configuration</source>
          <target state="translated">Конфигурация мутатора</target>
        </trans-unit>
        <trans-unit id="aeecae05e67a82b3d9ddc32f18bafb250167d7b8" translate="yes" xml:space="preserve">
          <source>NODE_DELETE</source>
          <target state="translated">NODE_DELETE</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">Вложенные маршруты</target>
        </trans-unit>
        <trans-unit id="67269d974acb388f118a96d5b0eb90541c783c5f" translate="yes" xml:space="preserve">
          <source>Nested routes with Relay data dependencies introduce an additional complication. While it's possible to render a &lt;code&gt;QueryRenderer&lt;/code&gt; per route, doing so will lead to request waterfalls in the general case where parent routes do not render their child routes until the data for those parent routes are available. This generally leads to an unnecessary additional delay in loading the data for the page, but may be acceptable for small applications or for applications with shallow route trees.</source>
          <target state="translated">Вложенные маршруты с зависимостями данных Relay вносят дополнительную сложность. Хотя можно отобразить &lt;code&gt;QueryRenderer&lt;/code&gt; для каждого маршрута, это приведет к водопадам запросов в общем случае, когда родительские маршруты не отображают свои дочерние маршруты, пока не будут доступны данные для этих родительских маршрутов. Обычно это приводит к ненужной дополнительной задержке при загрузке данных для страницы, но может быть приемлемым для небольших приложений или для приложений с неглубокими деревьями маршрутов.</target>
        </trans-unit>
        <trans-unit id="72e403f095e27b7f00c62a3bd59aa377165b5a4c" translate="yes" xml:space="preserve">
          <source>Network Layer</source>
          <target state="translated">Сетевой уровень</target>
        </trans-unit>
        <trans-unit id="87869155f5f3484fd0f094292d35a709172baa8a" translate="yes" xml:space="preserve">
          <source>Network layer</source>
          <target state="translated">Уровень сети</target>
        </trans-unit>
        <trans-unit id="f41f095614dba0f32736c3af7fc6b7b54e8b4b7f" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.props.relay.variables&lt;/code&gt; directly as it will not trigger data to be fetched properly. Treat &lt;code&gt;this.props.relay.variables&lt;/code&gt; as if it were immutable, just like props.</source>
          <target state="translated">Никогда не изменяйте &lt;code&gt;this.props.relay.variables&lt;/code&gt; напрямую, так как это не приведет к правильной выборке данных. Относитесь к &lt;code&gt;this.props.relay.variables&lt;/code&gt; как к неизменяемым, как к props.</target>
        </trans-unit>
        <trans-unit id="a945aa9cbd03a748373e539cadd72f60595b9951" translate="yes" xml:space="preserve">
          <source>New in Relay Modern</source>
          <target state="translated">Новое в эстафете &quot;Модерн</target>
        </trans-unit>
        <trans-unit id="34d3ac7ad9c7ff0b33bb48c822077feedfac1008" translate="yes" xml:space="preserve">
          <source>Next, install the compiler (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">Затем установите компилятор (обычно как &lt;code&gt;devDependency&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="0a3100d6aa2ad29924f0f56bdda1c226229ea566" translate="yes" xml:space="preserve">
          <source>Next, it will &lt;code&gt;subscribe()&lt;/code&gt; using this snapshot in order to be notified of any changes - see the above diagram for &lt;code&gt;publish()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11d6766a232735ae2588359ce0e697727bb4a84" translate="yes" xml:space="preserve">
          <source>Next, let's create a file in &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; and create subclass of &lt;code&gt;Relay.Mutation&lt;/code&gt; called &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; to hold our mutation implementation:</source>
          <target state="translated">Затем давайте создадим файл в &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; и создадим подкласс &lt;code&gt;Relay.Mutation&lt;/code&gt; под названием &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; для хранения нашей реализации мутации:</target>
        </trans-unit>
        <trans-unit id="8d0415201da41a689310dea9dfd9de53cb8630b3" translate="yes" xml:space="preserve">
          <source>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</source>
          <target state="translated">Далее определим интерфейс и тип узла.Нужно только указать способ для Relay отображать от объекта к GraphQL типу,связанному с этим объектом,и от глобального идентификатора к объекту,на который он указывает:</target>
        </trans-unit>
        <trans-unit id="adc67eef09450d30c9ae37eeb2376e191eb49c0d" translate="yes" xml:space="preserve">
          <source>Next, let's define our game and hiding spot types, and the fields that are available on each.</source>
          <target state="translated">Далее определимся с типом нашей игры и типами скрытых мест,а также полями,доступными на каждом из них.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5b3016b7b65c75156425ea4affe66b9292dbd049" translate="yes" xml:space="preserve">
          <source>No Routing</source>
          <target state="translated">Нет Маршрутизации</target>
        </trans-unit>
        <trans-unit id="2daa1a58378d3c4f7ceb9d6531c197c5be4d948b" translate="yes" xml:space="preserve">
          <source>Non-React functions can also take advantage of data masking. A fragment can be defined with the &lt;code&gt;@inline&lt;/code&gt; directive and stored in a local variable. The non-React function can then &quot;unmask&quot; the data using the &lt;code&gt;readInlineData&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="8591e7ed2e6e97908da94c56b629b41aa4eb0746" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;graphql&lt;/code&gt; template tags are &lt;strong&gt;never executed at runtime&lt;/strong&gt;. Instead, they are compiled ahead of time by the &lt;a href=&quot;#relay-compiler&quot;&gt;Relay Compiler&lt;/a&gt; into generated artifacts that live alongside your source code, and which Relay requires to operate at runtime. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded70becacd440a8a5293ee572a86c4c58319833" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; will continue to be false.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;ready&lt;/code&gt; и &lt;code&gt;done&lt;/code&gt; прежнему будет ложным.</target>
        </trans-unit>
        <trans-unit id="7c2002c29e0fca7efc2e3f32bc61fca5000503d9" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;em&gt;highly&lt;/em&gt; recommended that &lt;code&gt;Relay.Container&lt;/code&gt;s define their own fragments and avoid sharing inline &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</source>
          <target state="translated">Обратите внимание, что &lt;em&gt;настоятельно&lt;/em&gt; рекомендуется, чтобы &lt;code&gt;Relay.Container&lt;/code&gt; определяли свои собственные фрагменты и избегали совместного использования встроенных значений &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; между контейнерами или файлами. Если вы обнаружите, что хотите поделиться встроенными фрагментами, это, вероятно, знак того, что пришло время провести рефакторинг и представить новый контейнер.</target>
        </trans-unit>
        <trans-unit id="0e023c69475bbeb6872432af3864e74233382b71" translate="yes" xml:space="preserve">
          <source>Note that these modules are &lt;em&gt;loosely coupled&lt;/em&gt;. For example, the compiler emits representations of queries in a well-defined format that the runtime consumes (the &quot;Concrete&quot; node interfaces in &lt;code&gt;RelayConcreteNode&lt;/code&gt;), such that the compiler implementation can be swapped out if desired. React/Relay relies only on the well-documented public interface of the runtime, such that the actual implementation can be swapped out (in fact, we've upgraded the classic Relay core to also implement this same API). We hope that this loose coupling will allow the community to explore new use-cases such as the development of specialized product APIs using the Relay runtime or integrations of the runtime with view libraries other than React.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6251d7c444bd5ea65a8e620b067b7ace419f0985" translate="yes" xml:space="preserve">
          <source>Note that this approach requires &lt;em&gt;n+1&lt;/em&gt; requests to the server: 1 to fetch the list, and &lt;em&gt;n&lt;/em&gt; to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</source>
          <target state="translated">Обратите внимание, что этот подход требует &lt;em&gt;n + 1&lt;/em&gt; запросов к серверу: 1 для получения списка и &lt;em&gt;n&lt;/em&gt; для получения каждого элемента. С GraphQL мы можем получить одни и те же данные в одном сетевом запросе на сервер (без создания настраиваемой конечной точки, которую нам затем придется поддерживать):</target>
        </trans-unit>
        <trans-unit id="41a9a091d399394a5944c5c0a394fb244440e004" translate="yes" xml:space="preserve">
          <source>Note that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when &lt;code&gt;cacheConfig.force&lt;/code&gt; is false) and uploading form data for mutations (the &lt;code&gt;uploadables&lt;/code&gt; parameter).</source>
          <target state="translated">Обратите внимание, что это базовый пример, который поможет вам начать работу. Этот пример может быть расширен дополнительными функциями, такими как кэширование запросов / ответов (включено, например, когда &lt;code&gt;cacheConfig.force&lt;/code&gt; имеет значение false) и загрузка данных формы для мутаций ( параметр &lt;code&gt;uploadables&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="18e979539b69c286787704dcc6ebc81753f2b6c9" translate="yes" xml:space="preserve">
          <source>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</source>
          <target state="translated">Обратите внимание,что эта нормализованная структура кэша позволяет кэшировать результаты перекрытия без дублирования.Каждая запись сохраняется один раз,независимо от того,как она была получена.Давайте вернемся к более раннему примеру противоречивых данных и посмотрим,как этот кэш помогает в этом сценарии.</target>
        </trans-unit>
        <trans-unit id="6a3998469edc7ffa18da69953898b4c848c54481" translate="yes" xml:space="preserve">
          <source>Note that this solution will also work for &lt;em&gt;writes&lt;/em&gt;: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</source>
          <target state="translated">Обратите внимание, что это решение также будет работать для &lt;em&gt;записи&lt;/em&gt; : любое обновление кеша будет уведомлять затронутые представления, а записи - это просто еще одна вещь, которая обновляет кеш.</target>
        </trans-unit>
        <trans-unit id="ac8054c10594bdd95e89a5e8a8673034de9d793b" translate="yes" xml:space="preserve">
          <source>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type &lt;code&gt;Story&lt;/code&gt; into a parent's field of type &lt;code&gt;User&lt;/code&gt;. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</source>
          <target state="translated">Обратите внимание, что при составлении фрагментов тип составного фрагмента должен соответствовать полю родительского элемента, в который он встроен. Например, не имеет смысла вставлять фрагмент типа &lt;code&gt;Story&lt;/code&gt; в родительское поле типа &lt;code&gt;User&lt;/code&gt; . Relay и GraphQL предоставят полезные сообщения об ошибках, если вы ошибетесь (и если они не помогут, дайте нам знать!).</target>
        </trans-unit>
        <trans-unit id="0cb3b8bd044c603524ff2409189dcccf98b3f39b" translate="yes" xml:space="preserve">
          <source>Note: Determining variable values at runtime</source>
          <target state="translated">Примечание:Определение значений переменных во время исполнения</target>
        </trans-unit>
        <trans-unit id="6eb6c807aac98e74096f64d7f8585ee557b93a39" translate="yes" xml:space="preserve">
          <source>Note: In most cases, it is possible to rely on the default singleton instance of the environment, which is exposed as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">Примечание. В большинстве случаев можно полагаться на одноэлементный экземпляр среды по умолчанию, который &lt;code&gt;Relay.Store&lt;/code&gt; как Relay.Store .</target>
        </trans-unit>
        <trans-unit id="06bd725e4a6c3e529d4b86297fa0d602b821e04c" translate="yes" xml:space="preserve">
          <source>Note: This method may only be called once per instance.</source>
          <target state="translated">Примечание:Этот метод может быть вызван только один раз в каждом экземпляре.</target>
        </trans-unit>
        <trans-unit id="a0e48b33fadd08f907218ada431ccb61eb2d094e" translate="yes" xml:space="preserve">
          <source>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</source>
          <target state="translated">Обратите внимание,что он немедленно выполняет следующее задание.Реле управляет порядком выполнения задач,чтобы обеспечить правильный порядок действий-планировщик не может пропустить или переупорядочить задачи,а только решить,когда выполнять следующую.</target>
        </trans-unit>
        <trans-unit id="c79f05d35d0a7eb36506bd3ab33a1f2773cfa554" translate="yes" xml:space="preserve">
          <source>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the &lt;code&gt;after&lt;/code&gt; argument to the &lt;code&gt;ships&lt;/code&gt; field, which will let us ask for the next three ships after the last one in the previous result:</source>
          <target state="translated">Обратите внимание, что курсор представляет собой строку base64. Это шаблон из предыдущего: сервер напоминает нам, что это непрозрачная строка. Мы можем передать эту строку обратно на сервер в качестве аргумента &lt;code&gt;after&lt;/code&gt; поля &lt;code&gt;ships&lt;/code&gt; , что позволит нам запросить следующие три корабля после последнего в предыдущем результате:</target>
        </trans-unit>
        <trans-unit id="3aca59c767d5ed557222dbb5b8557469ae3a4a7f" translate="yes" xml:space="preserve">
          <source>Notice that we're querying for data that &lt;em&gt;may&lt;/em&gt; have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over &lt;em&gt;any&lt;/em&gt; data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</source>
          <target state="translated">Обратите внимание, что мы запрашиваем данные, которые &lt;em&gt;могли&lt;/em&gt; измениться в результате мутации. Возникает очевидный вопрос: почему сервер не может просто сказать нам, что изменилось? Ответ: это сложно. GraphQL абстрагируется по &lt;em&gt;любому&lt;/em&gt; уровню хранения данных (или по совокупности нескольких источников) и работает с любым языком программирования. Более того, цель GraphQL - предоставить данные в форме, которая будет полезна разработчикам продуктов, создающим представление.</target>
        </trans-unit>
        <trans-unit id="056ee5771da852e979294339f6d61f3371dc9784" translate="yes" xml:space="preserve">
          <source>Now Relay will both fetch the larger photo size &lt;em&gt;and&lt;/em&gt;&lt;code&gt;Child&lt;/code&gt; will know to render it.</source>
          <target state="translated">Теперь Relay будет извлекать фото большего размера, &lt;em&gt;а &lt;/em&gt; &lt;code&gt;Child&lt;/code&gt; будет знать, как их отрендерить.</target>
        </trans-unit>
        <trans-unit id="359fab9a105cb172833a57b904a4f78ae21bf6b3" translate="yes" xml:space="preserve">
          <source>Now Relay will fetch the photo with size 128 - but the &lt;code&gt;Child&lt;/code&gt; container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</source>
          <target state="translated">Теперь Relay получит фотографию размером 128, но контейнер &lt;code&gt;Child&lt;/code&gt; не узнает об этой переменной волшебным образом. Мы должны сообщить об этом, передав значение переменной как опору:</target>
        </trans-unit>
        <trans-unit id="8f4ea81858f10f7f357b3da216fb14eb06c577cc" translate="yes" xml:space="preserve">
          <source>Now let's associate these types with the root query type.</source>
          <target state="translated">Теперь свяжем эти типы с типом корневого запроса.</target>
        </trans-unit>
        <trans-unit id="ee5dbc563862c37bd2eddab0d2faa5a3c1303875" translate="yes" xml:space="preserve">
          <source>Now let's take a closer look at the &lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">А теперь давайте подробнее рассмотрим &lt;code&gt;config&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c63c75c8f04bcbaded3abd8323247dbc014c15ac" translate="yes" xml:space="preserve">
          <source>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</source>
          <target state="translated">Теперь,когда мы рассмотрели это руководство,давайте погрузимся в то,что значит построить клиентский фреймворк GraphQL и как это сравнивается с клиентами для более традиционных REST систем.</target>
        </trans-unit>
        <trans-unit id="3c8e0a4e6791c0f1c68af7b94cb67e9dddbecd93" translate="yes" xml:space="preserve">
          <source>Now we can instantiate a &lt;code&gt;ProfileRoute&lt;/code&gt; that fetches data for user &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">Теперь мы можем создать экземпляр &lt;code&gt;ProfileRoute&lt;/code&gt; , который извлекает данные для пользователя &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3cbdecefa56176a7edca66548a54ce86a3ed688" translate="yes" xml:space="preserve">
          <source>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</source>
          <target state="translated">Теперь на запросы ранее кэшированных данных можно ответить немедленно,не делая сетевого запроса.Это практический подход к улучшению воспринимаемой производительности приложения.Однако,этот метод кэширования может вызвать проблемы с последовательностью данных.</target>
        </trans-unit>
        <trans-unit id="c7d436121cc7de83cd8afcc9e5b08145f88e3d72" translate="yes" xml:space="preserve">
          <source>Object Identification</source>
          <target state="translated">Идентификация объекта</target>
        </trans-unit>
        <trans-unit id="509d0e819f7363f119680482f06c06df5503cfc0" translate="yes" xml:space="preserve">
          <source>On the Relay Container the prop &lt;code&gt;bars&lt;/code&gt; will be an array instead of an object.</source>
          <target state="translated">В релейном контейнере опорные &lt;code&gt;bars&lt;/code&gt; будут массивом, а не объектом.</target>
        </trans-unit>
        <trans-unit id="258ab7d6dd3b683b7bd3f1f1a9e4c26dc064e05d" translate="yes" xml:space="preserve">
          <source>On the other hand, GraphQL &lt;strong&gt;fragments&lt;/strong&gt; declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for &lt;em&gt;some&lt;/em&gt;&lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">С другой стороны, &lt;strong&gt;фрагменты&lt;/strong&gt; GraphQL объявляют поля, которые существуют в любом произвольном типе. Например, следующий фрагмент извлекает URI изображения профиля для &lt;em&gt;некоторого &lt;/em&gt; &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e77ad76d86248c3f5b3430ab7a50cf954c824781" translate="yes" xml:space="preserve">
          <source>Once a few or all of your views are using &lt;code&gt;QueryRenderer&lt;/code&gt;, &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; could be replaced with a &lt;code&gt;RelayModernEnvironment&lt;/code&gt;. Keep in mind that &lt;code&gt;RelayModernEnvironment&lt;/code&gt; and &lt;code&gt;Store&lt;/code&gt; do not share any data. You might want to hold off on this step until views that have significant data overlap can be switched over at the same time. This step is what unlocks the perf wins for your app. Apps using the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; get to send persisted query IDs instead of the full query strings to the server, as well as much more optimized data normalizing and processing.</source>
          <target state="translated">Как только некоторые или все ваши представления будут использовать &lt;code&gt;QueryRenderer&lt;/code&gt; , &lt;code&gt;Store&lt;/code&gt; из response &lt;code&gt;'react-relay/classic'&lt;/code&gt; можно заменить на &lt;code&gt;RelayModernEnvironment&lt;/code&gt; . Помните, что &lt;code&gt;RelayModernEnvironment&lt;/code&gt; и &lt;code&gt;Store&lt;/code&gt; не передают никаких данных. Возможно, вы захотите отложить этот шаг до тех пор, пока представления, которые имеют значительное перекрытие данных, не могут быть переключены одновременно. Этот шаг - это то, что разблокирует производительность вашего приложения. Приложения, использующие &lt;code&gt;RelayModernEnvironment&lt;/code&gt; , могут отправлять на сервер постоянные идентификаторы запросов вместо полных строк запроса, а также выполнять гораздо более оптимизированную нормализацию и обработку данных.</target>
        </trans-unit>
        <trans-unit id="aa26441141ed7039f7d3b90dda06bb5985300871" translate="yes" xml:space="preserve">
          <source>Once all the components and mutations have been converted to use the Relay Modern APIs, convert to using &lt;code&gt;QueryRenderer&lt;/code&gt; instead of using &lt;code&gt;Relay.Renderer&lt;/code&gt; or &lt;code&gt;Relay.RootContainer&lt;/code&gt;. You may supply &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; as the &lt;code&gt;environment&lt;/code&gt; for most cases.</source>
          <target state="translated">После того, как все компоненты и мутации были преобразованы для использования API-интерфейсов Relay Modern, выполните преобразование с помощью &lt;code&gt;QueryRenderer&lt;/code&gt; вместо использования &lt;code&gt;Relay.Renderer&lt;/code&gt; или &lt;code&gt;Relay.RootContainer&lt;/code&gt; . В большинстве случаев вы можете предоставить &lt;code&gt;Store&lt;/code&gt; из &lt;code&gt;'react-relay/classic'&lt;/code&gt; в качестве &lt;code&gt;environment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="526a2470452cfa759c69b07a4cdac3145513395b" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;error&lt;/code&gt; set to an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">Один раз с &lt;code&gt;error&lt;/code&gt; установленной в объект &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d30a28f0a20b5fda3d127c2ba900c1393a0c802c" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true, but &lt;code&gt;stale&lt;/code&gt; set to false.</source>
          <target state="translated">Когда-то с &lt;code&gt;ready&lt;/code&gt; и &lt;code&gt;done&lt;/code&gt; установлено значение true, а для &lt;code&gt;stale&lt;/code&gt; установлено значение false.</target>
        </trans-unit>
        <trans-unit id="c510443cbc7ffd35f869abc94218360943f66d9e" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true.</source>
          <target state="translated">После того, как с &lt;code&gt;ready&lt;/code&gt; и &lt;code&gt;done&lt;/code&gt; набором к истине.</target>
        </trans-unit>
        <trans-unit id="9b048c01bc7fa82617b39cb08502f943e54b8d4a" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; set to false.</source>
          <target state="translated">Однажды с &lt;code&gt;ready&lt;/code&gt; установкой на ложь.</target>
        </trans-unit>
        <trans-unit id="fe545c0159939d91c25a89db650c07bece33f470" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, and &lt;code&gt;stale&lt;/code&gt; set to true.</source>
          <target state="translated">Один раз с &lt;code&gt;ready&lt;/code&gt; , &lt;code&gt;done&lt;/code&gt; и &lt;code&gt;stale&lt;/code&gt; установлено значение true.</target>
        </trans-unit>
        <trans-unit id="c8f5f6a359004092335c67ac77552d54cac29a5a" translate="yes" xml:space="preserve">
          <source>Once you have an environment, you can pass it in to your &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; instance, or into mutations via the &lt;code&gt;commitUpdate&lt;/code&gt; function (see &quot;&lt;a href=&quot;mutations&quot;&gt;Mutations&lt;/a&gt;&quot;).</source>
          <target state="translated">Когда у вас есть среда, вы можете передать ее в свой экземпляр &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; или в мутации с помощью функции &lt;code&gt;commitUpdate&lt;/code&gt; (см. &amp;laquo; &lt;a href=&quot;mutations&quot;&gt;Мутации&lt;/a&gt; &amp;raquo;).</target>
        </trans-unit>
        <trans-unit id="3445237f2d0762c974ff895551ac18ecb7b0fd39" translate="yes" xml:space="preserve">
          <source>One of the big ideas behind the new API is that execution can be made a lot more efficient by moving work ahead-of-time: from the runtime of the app to the build-time. As such, changes to GraphQL fragments require a build step to regenerate a set of artifacts. More on &lt;a href=&quot;relay-compiler&quot;&gt;the Relay Compiler&lt;/a&gt;.</source>
          <target state="translated">Одна из важных идей, лежащих в основе нового API, заключается в том, что выполнение можно сделать намного более эффективным, если перенести работу на опережение: от времени выполнения приложения до времени сборки. Таким образом, изменения во фрагментах GraphQL требуют этапа сборки для восстановления набора артефактов. Подробнее о &lt;a href=&quot;relay-compiler&quot;&gt;компиляторе реле&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e9e3088ad7030f31124174e1ea72f79d6e9860c5" translate="yes" xml:space="preserve">
          <source>One of the main goals of the compiler is to provide a consistent platform for writing tools that transform or optimize GraphQL. This includes the ability to experiment with new directives by transforming them away at compile time. Transform functions should typically perform a single type of modification - it's expected that an app will have multiple transforms configured in the compiler instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad501b8fa6c8a155c72db2494b37eb05a27af8e5" translate="yes" xml:space="preserve">
          <source>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing &lt;em&gt;any&lt;/em&gt; root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in &lt;em&gt;components&lt;/em&gt;.</source>
          <target state="translated">Одно из решений состоит в том, чтобы корневой компонент извлекал данные для всех своих дочерних элементов. Однако это привело бы к связыванию: каждое изменение компонента потребовало бы изменения &lt;em&gt;любого&lt;/em&gt; корневого компонента, который мог бы его отображать, и часто некоторых компонентов между ним и корнем. Эта связь может означать больше шансов для ошибок и замедлить темпы разработки. В конечном итоге этот подход не использует преимущества компонентной модели React. Естественным местом для указания зависимостей данных были &lt;em&gt;компоненты&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6b5a7ba3ecdf80b9b9c9285e7c15e081d2c4cfd9" translate="yes" xml:space="preserve">
          <source>One thing is left in the example above &amp;mdash; implementing &lt;code&gt;setSize()&lt;/code&gt;, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a &lt;code&gt;relay&lt;/code&gt; prop that has Relay-specific methods and metadata. These include &lt;code&gt;variables&lt;/code&gt; &amp;mdash; the active variables used to fetch the current &lt;code&gt;props&lt;/code&gt; &amp;mdash; and &lt;code&gt;setVariables()&lt;/code&gt; &amp;mdash; a callback that can be used to request data for different variable values.</source>
          <target state="translated">В приведенном выше примере осталось одно - реализация &lt;code&gt;setSize()&lt;/code&gt; , которая должна изменять размер фотографии при изменении значений ползунка. Помимо передачи результатов каждого запроса компоненту, Relay также предоставляет опору &lt;code&gt;relay&lt;/code&gt; которая имеет методы и метаданные, специфичные для Relay. Они включают в себя &lt;code&gt;variables&lt;/code&gt; - активном переменном , используемых для извлечения текущего &lt;code&gt;props&lt;/code&gt; - и &lt;code&gt;setVariables()&lt;/code&gt; - обратный вызов , который может быть использован для запроса данных для различных значений переменных.</target>
        </trans-unit>
        <trans-unit id="43ec0f0f8cb785cd4021b95098b6011da01043b4" translate="yes" xml:space="preserve">
          <source>Only fields specified by these fragments will be populated in &lt;code&gt;this.props&lt;/code&gt; when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</source>
          <target state="translated">Только поля, указанные этими фрагментами, будут заполнены в &lt;code&gt;this.props&lt;/code&gt; при визуализации компонента. Это гарантирует отсутствие неявных зависимостей от компонента от его родительского компонента или любых дочерних компонентов.</target>
        </trans-unit>
        <trans-unit id="cda4387bc6920d739a4c52a2c0a31c33103f5562" translate="yes" xml:space="preserve">
          <source>Optimistic Updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="544901021486ff794813761281a30a85a9ea2561" translate="yes" xml:space="preserve">
          <source>Optimistic updates</source>
          <target state="translated">Оптимистичные обновления</target>
        </trans-unit>
        <trans-unit id="75e97d82c2ab23fae3c5ae0de671aad8aaab254b" translate="yes" xml:space="preserve">
          <source>Optimistically updating the UI while waiting for the server to respond to mutations.</source>
          <target state="translated">Оптимистично обновлять пользовательский интерфейс в ожидании ответа сервера на мутации.</target>
        </trans-unit>
        <trans-unit id="a30573ebcc5462272b8ba6828cf0b15e88284677" translate="yes" xml:space="preserve">
          <source>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the &lt;em&gt;entire&lt;/em&gt; query, wait to download the results, and wait to process them again. This is very inefficient.</source>
          <target state="translated">Вариант 1. Получите повторно все, что когда-либо запрашивало приложение. Несмотря на то, что на самом деле изменится лишь небольшая часть этих данных, нам все равно придется ждать, пока сервер выполнит &lt;em&gt;весь&lt;/em&gt; запрос, дождаться загрузки результатов и дождаться их повторной обработки. Это очень неэффективно.</target>
        </trans-unit>
        <trans-unit id="7c7f0ed28de8faafd0afd103f17d025324ed7cc5" translate="yes" xml:space="preserve">
          <source>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that &lt;em&gt;isn't&lt;/em&gt; currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</source>
          <target state="translated">Вариант 2. Получите повторно только те запросы, которые требуются для активно отображаемых представлений. Это небольшое улучшение по сравнению с вариантом 1. Однако кэшированные данные, которые &lt;em&gt;в&lt;/em&gt; настоящее время не просматриваются, не будут обновлены. Если эти данные каким-либо образом не помечены как устаревшие или исключены из кеша, последующие запросы будут читать устаревшую информацию.</target>
        </trans-unit>
        <trans-unit id="1fc54acb388aaf56464909787927f5c9cc6c305b" translate="yes" xml:space="preserve">
          <source>Option 3: Re-fetch a fixed list of fields that &lt;em&gt;may&lt;/em&gt; change after the mutation. We'll call this list a &lt;strong&gt;fat query&lt;/strong&gt;. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</source>
          <target state="translated">Вариант 3: повторно получить фиксированный список полей, которые &lt;em&gt;могут&lt;/em&gt; измениться после мутации. Назовем этот список &lt;strong&gt;жирным запросом&lt;/strong&gt; . Мы обнаружили, что это также неэффективно, потому что типичные приложения обрабатывают только подмножество толстого запроса, но этот подход потребует выборки всех этих полей.</target>
        </trans-unit>
        <trans-unit id="4be11d572e3b53b4fc22dae76efc2d670f4be4bb" translate="yes" xml:space="preserve">
          <source>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called &lt;strong&gt;tracked queries&lt;/strong&gt;. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</source>
          <target state="translated">Вариант 4 (ретрансляция): повторно получить пересечение того, что может измениться (жирный запрос), и данных в кеше. Помимо кеша данных, Relay также запоминает запросы, используемые для получения каждого элемента. Это так называемые &lt;strong&gt;отслеживаемые запросы&lt;/strong&gt; . Пересекая отслеживаемые и толстые запросы, Relay может запрашивать именно тот набор информации, который необходимо обновить приложению, и ничего более.</target>
        </trans-unit>
        <trans-unit id="6718713de12ca02e84822e47bd7f3094f39d3c0a" translate="yes" xml:space="preserve">
          <source>Optionally install globally</source>
          <target state="translated">Опционально установить глобально</target>
        </trans-unit>
        <trans-unit id="b30829da1c673e16f6adae2f5da589d2b2d65970" translate="yes" xml:space="preserve">
          <source>Optionally, follow up with a call to &lt;code&gt;commit()&lt;/code&gt; to send the mutation to the server.</source>
          <target state="translated">Необязательно, выполните вызов &lt;code&gt;commit()&lt;/code&gt; чтобы отправить мутацию на сервер.</target>
        </trans-unit>
        <trans-unit id="2495cf5d8b7fcd84a593bb8a6590867f01c41c54" translate="yes" xml:space="preserve">
          <source>Optionally, if the field takes arguments, you can pass a bag of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59edbb8c9de82b3a53b356bdf14020ccb99fbd8d" translate="yes" xml:space="preserve">
          <source>Optionally, if the linked record takes arguments, you can pass a bag of &lt;code&gt;variables&lt;/code&gt; as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a603142c92a8b820560fb3bf1b12553420c3f4e" translate="yes" xml:space="preserve">
          <source>Optionally, precede with a call to &lt;code&gt;applyOptimistic()&lt;/code&gt; to apply an update optimistically to the store.</source>
          <target state="translated">Необязательно, перед этим вызовите &lt;code&gt;applyOptimistic()&lt;/code&gt; чтобы оптимистично применить обновление к магазину.</target>
        </trans-unit>
        <trans-unit id="ae17e1897a8cc791f789d5b34d32406b1c727d64" translate="yes" xml:space="preserve">
          <source>Or this way, with the same results:</source>
          <target state="translated">Или так,с теми же результатами:</target>
        </trans-unit>
        <trans-unit id="fb12379af7dcaf01e91c059811ab5e2548a2134c" translate="yes" xml:space="preserve">
          <source>Or, a function that receives the previous set of variables used to query the data, and returns a new set of variables to pass to the &lt;code&gt;refetchQuery&lt;/code&gt; when fetching it from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50300a6866222e559def812f5df571c9176ba61e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;.</source>
          <target state="translated">Переопределяет &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd55d4fdc76dc273300987b3c56489168f507c74" translate="yes" xml:space="preserve">
          <source>Overriding Fragment Variables</source>
          <target state="translated">Переменные части Переменные</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1847eac49f0862bab8cf4f3614ad739655005e7f" translate="yes" xml:space="preserve">
          <source>Pagination Container</source>
          <target state="translated">контейнер для пагинации</target>
        </trans-unit>
        <trans-unit id="0ca043a41b0b3d0ddc8649acdd7e8b58bdcfa73a" translate="yes" xml:space="preserve">
          <source>Pagination Container is also a &lt;a href=&quot;https://reactjs.org/docs/higher-order-components.html&quot;&gt;higher-order component&lt;/a&gt;, similar to a &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt;, that is designed to simplify the workflow of loading more items in a list &amp;mdash; in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b747c351b01284c892ae1864f74451400f8ded9b" translate="yes" xml:space="preserve">
          <source>Pagination Container works in a very similar way to the &lt;a href=&quot;fragment-container&quot;&gt;Fragment Container&lt;/a&gt; in that you also specify the data requirements for a component via GraphQL fragments in the &lt;code&gt;fragmentSpec&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41bdd858e1fe37bddb1f310d8bfca6222b7c844d" translate="yes" xml:space="preserve">
          <source>Pagination Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cd194918cca0919b19b5c19a6632d8edf7c051" translate="yes" xml:space="preserve">
          <source>PaginationContainer</source>
          <target state="translated">PaginationContainer</target>
        </trans-unit>
        <trans-unit id="aede896343f70495123a4970ce699b9a49ceb28f" translate="yes" xml:space="preserve">
          <source>Passing Arguments to a Fragment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="1037cd9d1a4502e08db2f7acc00d0bfad2fb05f5" translate="yes" xml:space="preserve">
          <source>Persisted queries can be enabled by instructing Relay Compiler to emit metadata about each query, mutation, and subscription into a JSON file. The generated file will contain a mapping of query identifiers to query text, which you can then save to your server. To enable persisted queries, use the &lt;code&gt;--persist-output&lt;/code&gt; flag to the compiler:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55665b87f33041af7083942a79f605ac2526995" translate="yes" xml:space="preserve">
          <source>Persisting queries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9a81786a3cd10e92834a3ac1d48bcd7f39e6e3" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; plugin should run before other plugins or presets to ensure the &lt;code&gt;graphql&lt;/code&gt; template literals are correctly transformed. See Babel's &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentation on this topic&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что подключаемый модуль &lt;code&gt;&quot;relay&quot;&lt;/code&gt; должен запускаться раньше других подключаемых модулей или предустановок, чтобы обеспечить правильное преобразование литералов шаблона &lt;code&gt;graphql&lt;/code&gt; . См. &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;Документацию&lt;/a&gt; Babel по этой теме .</target>
        </trans-unit>
        <trans-unit id="02a0a62fe61678e8a433343395761ce593ca76c7" translate="yes" xml:space="preserve">
          <source>Please note that this replaces the &lt;a href=&quot;guides-babel-plugin&quot;&gt;older Babel Relay plugin&lt;/a&gt;. It is not necessary to include both plugins.</source>
          <target state="translated">Обратите внимание, что это заменяет &lt;a href=&quot;guides-babel-plugin&quot;&gt;старый плагин Babel Relay&lt;/a&gt; . Нет необходимости включать оба плагина.</target>
        </trans-unit>
        <trans-unit id="c6a15b9b600a39666d059f44d5e217d0eadd28f6" translate="yes" xml:space="preserve">
          <source>Populating The Cache</source>
          <target state="translated">Популяуляризация кэша</target>
        </trans-unit>
        <trans-unit id="9ef1894fd67a6660f9dc545b85fdd7563a957682" translate="yes" xml:space="preserve">
          <source>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash; how should we store &lt;code&gt;photo&lt;/code&gt;? Using &lt;code&gt;photo&lt;/code&gt; as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. &lt;code&gt;photo(size: 64) {...}&lt;/code&gt;). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt;, these new results should be &lt;em&gt;appended&lt;/em&gt; to the existing list.</source>
          <target state="translated">Заполнение кеша включает просмотр иерархического ответа GraphQL и создание или обновление нормализованных записей кеша. Сначала может показаться, что одного ответа достаточно для обработки ответа, но на самом деле это верно только для очень простых запросов. Рассмотрим &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; - как нам хранить &lt;code&gt;photo&lt;/code&gt; ? Использование &lt;code&gt;photo&lt;/code&gt; качестве имени поля в кеше не будет работать, потому что другой запрос может получить то же поле, но с разными значениями аргументов (например, &lt;code&gt;photo(size: 64) {...}&lt;/code&gt; ). Аналогичная проблема возникает с разбивкой на страницы. Если мы извлекаем истории с 11-го по 20-й с &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt; , эти новые результаты должны быть &lt;em&gt;добавлены&lt;/em&gt; к существующему списку.</target>
        </trans-unit>
        <trans-unit id="178213e972c712d32c9b754e0fae0660405a3262" translate="yes" xml:space="preserve">
          <source>Processing the schema</source>
          <target state="translated">Обработка схемы</target>
        </trans-unit>
        <trans-unit id="2765c8e15a74b74082d61d103e52529812b42ae8" translate="yes" xml:space="preserve">
          <source>Products access the store primarily via &lt;code&gt;lookup()&lt;/code&gt; and &lt;code&gt;subscribe()&lt;/code&gt;. Lookup reads the initial results of a fragment, and subscribe observes that result for any changes. Note that the output of &lt;code&gt;lookup()&lt;/code&gt; - a &lt;code&gt;Snapshot&lt;/code&gt; - is the input to &lt;code&gt;subscribe()&lt;/code&gt;. This is important because the snapshot contains important information that can be used to optimize the subscription - if &lt;code&gt;subscribe()&lt;/code&gt; accepted only a &lt;code&gt;Selector&lt;/code&gt;, it would have to re-read the results in order to know what to subscribe to, which is less efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="1100c030f3dc539b64e7700624cabb080430dd57" translate="yes" xml:space="preserve">
          <source>Properties and Methods</source>
          <target state="translated">Свойства и методы</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="f626c322addc21ad81e099b4b257742e4b44fa03" translate="yes" xml:space="preserve">
          <source>Publishing the results updates the store but does &lt;em&gt;not&lt;/em&gt; immediately notify any subscribers. This is accomplished by calling &lt;code&gt;notify()&lt;/code&gt;...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bb9f0eed56ead65c951dc161935d4389c8dfcc" translate="yes" xml:space="preserve">
          <source>QL</source>
          <target state="translated">QL</target>
        </trans-unit>
        <trans-unit id="0fa0f7a77beffe015e3dbe50d9707a0cef073bae" translate="yes" xml:space="preserve">
          <source>Queries vs. Fragments</source>
          <target state="translated">Запросы против фрагментов</target>
        </trans-unit>
        <trans-unit id="715a8fe94c1d42fc9dfbb4b5057bd51288856fd1" translate="yes" xml:space="preserve">
          <source>Query Naming Convention</source>
          <target state="translated">Конвенция о наименовании запросов</target>
        </trans-unit>
        <trans-unit id="0f4abb2dc94c20672b1e17a54e1138df9766d152" translate="yes" xml:space="preserve">
          <source>Query Renderer</source>
          <target state="translated">Рендерер запросов</target>
        </trans-unit>
        <trans-unit id="64c6ced3f69ca25be02a6b4eb81804275f87ea3e" translate="yes" xml:space="preserve">
          <source>QueryConfig</source>
          <target state="translated">QueryConfig</target>
        </trans-unit>
        <trans-unit id="92ed502ab1f6d9e04d58803b1ef2281c76306e49" translate="yes" xml:space="preserve">
          <source>QueryRenderer</source>
          <target state="translated">QueryRenderer</target>
        </trans-unit>
        <trans-unit id="004b0b56745c5867ceb6c95eccae46bc9634eca6" translate="yes" xml:space="preserve">
          <source>Queuing mutations to avoid race conditions.</source>
          <target state="translated">Мутации в очереди,чтобы избежать расовых условий.</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">Быстрый старт</target>
        </trans-unit>
        <trans-unit id="c22fa04a8b6a77a7856984111524e39134e2d44d" translate="yes" xml:space="preserve">
          <source>RANGE_ADD</source>
          <target state="translated">RANGE_ADD</target>
        </trans-unit>
        <trans-unit id="a5c0b5daae0eddce515d43e69bbf8ebe6c085aa7" translate="yes" xml:space="preserve">
          <source>RANGE_DELETE</source>
          <target state="translated">RANGE_DELETE</target>
        </trans-unit>
        <trans-unit id="65b00e2a3b97ba71c6979a03111363ff814865c1" translate="yes" xml:space="preserve">
          <source>REQUIRED_CHILDREN</source>
          <target state="translated">REQUIRED_CHILDREN</target>
        </trans-unit>
        <trans-unit id="dd3cac660da0ea89c0136a235305fc5bdb24dcc3" translate="yes" xml:space="preserve">
          <source>React Component</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca02c4d8d1e211afacc19bb40a490a44ae66f21" translate="yes" xml:space="preserve">
          <source>React Native Configuration</source>
          <target state="translated">Реакция Внутренняя конфигурация</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">Реакторный маршрутизатор</target>
        </trans-unit>
        <trans-unit id="0d4f22b3a7ca96ed45a6ce530b418585fac69067" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb70948dc19f1bb32a259898fca2dfd714e7448" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</source>
          <target state="translated">React и Relay поддерживают создание произвольно сложных приложений посредством &lt;em&gt;композиции&lt;/em&gt; . Компоненты большего размера могут быть созданы путем компоновки более мелких компонентов, что помогает нам создавать модульные и надежные приложения. Составление компонентов в Relay имеет два аспекта:</target>
        </trans-unit>
        <trans-unit id="1b75cb8007be8e88622c14d5835273832c1645c5" translate="yes" xml:space="preserve">
          <source>React component classes may have methods, often accessed via &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;. Since Relay composes these component instances in a container, you need to use the &lt;code&gt;componentRef&lt;/code&gt; prop to access them:</source>
          <target state="translated">Классы компонентов React могут иметь методы, к которым часто обращаются через &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;ссылки&lt;/a&gt; . Поскольку Relay составляет эти экземпляры компонентов в контейнере, вам необходимо использовать свойство &lt;code&gt;componentRef&lt;/code&gt; для доступа к ним:</target>
        </trans-unit>
        <trans-unit id="4414b37377cdce419545fa9b20f3ee40db7ae79f" translate="yes" xml:space="preserve">
          <source>Reading From Cache</source>
          <target state="translated">Чтение из кэша</target>
        </trans-unit>
        <trans-unit id="65ef251f859a908e6a35bac8ecaf436651601f86" translate="yes" xml:space="preserve">
          <source>Reads the value of an attribute on a record by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">Читает значение атрибута в записи по имени поля и объекта,представляющего значения предопределенных аргументов.</target>
        </trans-unit>
        <trans-unit id="e3c57930509c5101e93fa1b560decb910e955968" translate="yes" xml:space="preserve">
          <source>Ready State</source>
          <target state="translated">состояние готовности</target>
        </trans-unit>
        <trans-unit id="e276b1dc6fd5b2e2feab8b52644788511fadacad" translate="yes" xml:space="preserve">
          <source>Ready State Change</source>
          <target state="translated">Изменение состояния готовности</target>
        </trans-unit>
        <trans-unit id="e61f9d2b516c40c24af8003c73bb3ff7c6a828c5" translate="yes" xml:space="preserve">
          <source>RecordProxy</source>
          <target state="translated">RecordProxy</target>
        </trans-unit>
        <trans-unit id="240b0ea75b5e63f3dae5e35c084b7cb6df230fd2" translate="yes" xml:space="preserve">
          <source>RecordSourceSelectorProxy</source>
          <target state="translated">RecordSourceSelectorProxy</target>
        </trans-unit>
        <trans-unit id="8d339e7dedea41faa4ebfe2fcdc6d599b8f484b5" translate="yes" xml:space="preserve">
          <source>Records that are null in the published source are deleted (set to null) in the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b363b61849ee47f18ae2be0f0d65a8808b2dfa9" translate="yes" xml:space="preserve">
          <source>Records that exist in both are merged into a new record (inputs unchanged), with the result added to the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b512c3d477cc494940cbc3511367f3bc8c1733" translate="yes" xml:space="preserve">
          <source>Records that exist only in the published source are added to the store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff3c14aded3e6ad067ba4f314fd7efd64ebd5df" translate="yes" xml:space="preserve">
          <source>Records with a special sentinel value are removed from the store. This supports un-publishing optimistically created records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5e8ed94444d1cf7d3d3d0307cd8aaf8c3d6040fc" translate="yes" xml:space="preserve">
          <source>Refetch Container</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c412dd10a0e8cb0c1899aa86989fec9f2b0413" translate="yes" xml:space="preserve">
          <source>RefetchContainer</source>
          <target state="translated">RefetchContainer</target>
        </trans-unit>
        <trans-unit id="638e5005315e0cabef699577f78933ca4cc7db6a" translate="yes" xml:space="preserve">
          <source>Refetching Data (aka &quot;See More&quot;)</source>
          <target state="translated">Обновление данных (он же &quot;См.подробнее&quot;).</target>
        </trans-unit>
        <trans-unit id="c9bb21f0d54fefc21f3fe3cd21ff7bc0b0847f63" translate="yes" xml:space="preserve">
          <source>Refetching latest data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f437a4450523abebb9b8a6327af806c6dfe250" translate="yes" xml:space="preserve">
          <source>Related APIs</source>
          <target state="translated">Связанные API</target>
        </trans-unit>
        <trans-unit id="9f537f977fa2ecd1f91ff057ce1667e98ab04729" translate="yes" xml:space="preserve">
          <source>Relay</source>
          <target state="translated">Relay</target>
        </trans-unit>
        <trans-unit id="88dd507e8359bb2fd7a7702cfdc9ffaecb218c8a" translate="yes" xml:space="preserve">
          <source>Relay Classic API</source>
          <target state="translated">Релейный классический API</target>
        </trans-unit>
        <trans-unit id="d6764a98d68a0f585f067a880fb7f047e42e5295" translate="yes" xml:space="preserve">
          <source>Relay Classic Guides</source>
          <target state="translated">Эстафетные классические руководства</target>
        </trans-unit>
        <trans-unit id="aef721f4de8f071bed34bec165e9e8e9422d904c" translate="yes" xml:space="preserve">
          <source>Relay Classic Interfaces</source>
          <target state="translated">Классические интерфейсы реле</target>
        </trans-unit>
        <trans-unit id="8ee884f2695bfbad6a7a6dae4d48bf3348965934" translate="yes" xml:space="preserve">
          <source>Relay Compat</source>
          <target state="translated">релейный компат</target>
        </trans-unit>
        <trans-unit id="c546e3c1729605fb70a2db1deb7870608f3445c7" translate="yes" xml:space="preserve">
          <source>Relay Compat is part of &lt;code&gt;'react-relay'&lt;/code&gt; which allows you to do exactly this, providing an identical API to Relay Modern, while allowing interoperability with both runtimes.</source>
          <target state="translated">Relay Compat является частью &amp;laquo;react &lt;code&gt;'react-relay'&lt;/code&gt; которая позволяет вам делать именно это, предоставляя API, идентичный Relay Modern, при этом обеспечивая взаимодействие с обеими средами выполнения.</target>
        </trans-unit>
        <trans-unit id="ddef7758830f719ed90adce373f8f83b9acf721d" translate="yes" xml:space="preserve">
          <source>Relay Compiler</source>
          <target state="translated">релейный компилятор</target>
        </trans-unit>
        <trans-unit id="9e9a58b9be4e5093877d58bb37e46ff2f5998988" translate="yes" xml:space="preserve">
          <source>Relay Compiler supports the use of &lt;strong&gt;persisted queries&lt;/strong&gt;, in which each version of a query is associated to a unique ID on the server and the runtime uploads only the persisted ID instead of the full query text. This has several benefits: it can significantly reduce the time to send a query (and the upload bytes) and enables &lt;em&gt;whitelisting&lt;/em&gt; of queries. For example, you may choose to disallow queries in text form and only allow queries that have been persisted (and that presumably have passed your internal code review process).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c34dd9f9f2001d5f2a7c52af35f1be4b138b177" translate="yes" xml:space="preserve">
          <source>Relay Compiler will then create the id =&amp;gt; query text mapping in the path you specify. You can then use this complete json file in your server side to map query ids to operation text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2b89d58206687eafd6b5f1f94bb37fb0baa8fb" translate="yes" xml:space="preserve">
          <source>Relay Containers</source>
          <target state="translated">Контейнеры реле</target>
        </trans-unit>
        <trans-unit id="e0d9a631ef93e7ccb54370c0af336f421599b386" translate="yes" xml:space="preserve">
          <source>Relay DevTools is tool designed to help developers inspect their Relay state and understand how store changes overtime. Relay DevTools ships in two ways:</source>
          <target state="translated">Relay DevTools-это инструмент,который помогает разработчикам проверять состояние реле и понимать,как хранятся изменения сверхурочных.Relay DevTools поставляется двумя способами:</target>
        </trans-unit>
        <trans-unit id="426c398ee54f1b774dac3a903f0125ae20a5c9e6" translate="yes" xml:space="preserve">
          <source>Relay Documentation</source>
          <target state="translated">релейная документация</target>
        </trans-unit>
        <trans-unit id="1443cd7ff63d89730c443bd7786d90a6df7d1998" translate="yes" xml:space="preserve">
          <source>Relay Environment</source>
          <target state="translated">релейная среда</target>
        </trans-unit>
        <trans-unit id="d699ddf70a567d16a64d34cd746d0cc2172e4ec9" translate="yes" xml:space="preserve">
          <source>Relay Modern</source>
          <target state="translated">Релейный Модерн</target>
        </trans-unit>
        <trans-unit id="125aa7abbb0a0bc142817f98c7e32cd828f1f474" translate="yes" xml:space="preserve">
          <source>Relay Modern comes with automatic Flow type generation for the fragments used in Relay containers based on the GraphQL schema. Using these Flow types can help make an application less error-prone, by ensuring all possible &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; cases are considered even if they don't happen frequently.</source>
          <target state="translated">Relay Modern поставляется с автоматической генерацией типа потока для фрагментов, используемых в контейнерах Relay, на основе схемы GraphQL. Использование этих типов потока может помочь сделать приложение менее подверженным ошибкам, &lt;code&gt;undefined&lt;/code&gt; учитываются все возможные &lt;code&gt;null&lt;/code&gt; или неопределенные случаи, даже если они не происходят часто.</target>
        </trans-unit>
        <trans-unit id="fe351802f53838c0d3ff7ec944643ab9992b7020" translate="yes" xml:space="preserve">
          <source>Relay Modern containers combine standard React components with a description of their data requirements, expressed as one or more GraphQL fragments. Each container is itself a standard React component that can be rendered using the standard React API (e.g. &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt;). When rendered, a container will read the data for its fragment from the Relay cache. As the fragment data changes - for example due to a mutation, subscription, or updated query response - the container will automatically re-render the component.</source>
          <target state="translated">Контейнеры Relay Modern объединяют стандартные компоненты React с описанием их требований к данным, выраженным в виде одного или нескольких фрагментов GraphQL. Каждый контейнер сам по себе является стандартным компонентом React, который можно отобразить с помощью стандартного API React (например, &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt; ). При рендеринге контейнер будет читать данные для своего фрагмента из кэша Relay. По мере изменения данных фрагмента - например, из-за мутации, подписки или обновления ответа на запрос - контейнер автоматически повторно визуализирует компонент.</target>
        </trans-unit>
        <trans-unit id="b783df53e509475b97db41df7f512b5cdf7adf0d" translate="yes" xml:space="preserve">
          <source>Relay Modern enables a variety of new features. Some are available via the Compat API, while others require upgrading fully to the Modern runtime. See &lt;a href=&quot;new-in-relay-modern&quot;&gt;what's new in Relay Modern&lt;/a&gt; for more details.</source>
          <target state="translated">Relay Modern предоставляет множество новых функций. Некоторые из них доступны через API совместимости, другие требуют полного обновления до современной среды выполнения. Дополнительные сведения см. &lt;a href=&quot;new-in-relay-modern&quot;&gt;В новых возможностях Relay Modern&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02ee7840306dae496dace1fe86750e32e8b8c807" translate="yes" xml:space="preserve">
          <source>Relay Modern is a new version of Relay designed from the ground up to be easier to use, more extensible and, most of all, able to improve performance on mobile devices. Relay Modern accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay Modern-это новая версия реле,разработанная с нуля,чтобы быть более простой в использовании,более расширяемой и,прежде всего,способной улучшить производительность на мобильных устройствах.Relay Modern достигает этого с помощью статических запросов и опережающего генерирования кода.</target>
        </trans-unit>
        <trans-unit id="45d888a1b92fa795f57aa8cf7b25c2d182f14c5c" translate="yes" xml:space="preserve">
          <source>Relay Modern is composed of three core modules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451008aa294b51a951e1a6a9073f36b4296c782c" translate="yes" xml:space="preserve">
          <source>Relay Modern requires a Babel plugin to convert GraphQL to runtime artifacts:</source>
          <target state="translated">Relay Modern требует плагина Babel для преобразования GraphQL в артефакты времени исполнения:</target>
        </trans-unit>
        <trans-unit id="0d2944c329394a1cfc563059eabe3a8681e7e2bc" translate="yes" xml:space="preserve">
          <source>Relay Modern supports GraphQL Subscriptions, using the imperative update API to allow modifications to the store whenever a payload is received. It also features experimental support for GraphQL Live Queries via polling.</source>
          <target state="translated">Relay Modern поддерживает Подписку на GraphQL,используя API для обязательного обновления,что позволяет вносить изменения в магазин всякий раз,когда поступает полезная нагрузка.Также в нем реализована экспериментальная поддержка GraphQL Live Queries через опрос.</target>
        </trans-unit>
        <trans-unit id="372f8f866ff79038477865a8b1e68cc2436d4212" translate="yes" xml:space="preserve">
          <source>Relay Modern supports the following directives</source>
          <target state="translated">Реле Модерн поддерживает следующие директивы</target>
        </trans-unit>
        <trans-unit id="4fcb24b9dcd43c8532db4d056e1af150670c742a" translate="yes" xml:space="preserve">
          <source>Relay Modern uses the Relay Compiler to convert &lt;code&gt;graphql&lt;/code&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relay Modern использует Relay Compiler для преобразования литералов &lt;code&gt;graphql&lt;/code&gt; в сгенерированные файлы, которые находятся рядом с вашими исходными файлами.</target>
        </trans-unit>
        <trans-unit id="604519e05335c47d085692b3d5c93c6c0cf24a81" translate="yes" xml:space="preserve">
          <source>Relay Modern's ahead-of-time compilation requires the new Relay Compiler:</source>
          <target state="translated">Опережающая компиляция Relay Modern требует нового компилятора реле:</target>
        </trans-unit>
        <trans-unit id="d344ad7e0e46f9326c5126f3f06dc4800f23f6c8" translate="yes" xml:space="preserve">
          <source>Relay Modern's core is essentially an un-opinionated store for GraphQL data. It can be used independent of rendering views using React and can be extended to be used with other frameworks.</source>
          <target state="translated">Ядро Relay Modern,по сути,является универсальным хранилищем данных GraphQL.Оно может быть использовано независимо от рендеринга представлений с помощью React и может быть расширено для использования с другими фреймворками.</target>
        </trans-unit>
        <trans-unit id="e31b26fed868774cce2fc303006fb272761f29e5" translate="yes" xml:space="preserve">
          <source>Relay Runtime is designed for use with GraphQL schemas that describe &lt;strong&gt;object graphs&lt;/strong&gt; in which objects have a type, an identity, and a set of fields with values. Objects may reference each other, which is represented by fields whose values are one or more other objects in the graph [1]. To distinguish from JavaScript &lt;code&gt;Object&lt;/code&gt;s, these units of data are referred to as &lt;code&gt;Record&lt;/code&gt;s. Relay represents both its internal cache as well as query/mutation/etc results as a mapping of &lt;strong&gt;data ID&lt;/strong&gt;s to &lt;strong&gt;records&lt;/strong&gt;. The data ID is the unique (with respect to the cache) identifier for a record - it may be the value of an actual &lt;code&gt;id&lt;/code&gt; field or based on the path to the record from the nearest object with an &lt;code&gt;id&lt;/code&gt; (such path-based ids are called &lt;strong&gt;client ids&lt;/strong&gt;). Each &lt;code&gt;Record&lt;/code&gt; stores its data ID, type, and any fields that have been fetched. Multiple records are stored together as a &lt;code&gt;RecordSource&lt;/code&gt;: a mapping of data IDs to &lt;code&gt;Record&lt;/code&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881bc62d6225c769dfa7c14c7288aba40be25da2" translate="yes" xml:space="preserve">
          <source>Relay Specification</source>
          <target state="translated">Спецификация реле</target>
        </trans-unit>
        <trans-unit id="5d0eda024fc816c22ea59a24e3cd5865e39cffa0" translate="yes" xml:space="preserve">
          <source>Relay Store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd195ecee5d7e7a6df1ecbbf4a909cee95b601b9" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48799f13f2ac51d5720b5a4e683e4a8844cdd877" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">Relay позволяет разработчикам аннотировать свои компоненты React зависимостями данных путем создания &lt;strong&gt;контейнеров&lt;/strong&gt; . Это обычные компоненты React, которые обертывают оригиналы. Ключевым ограничением дизайна является то, что компоненты React предназначены для многократного использования, поэтому контейнеры Relay должны быть такими же. Например, компонент &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; может реализовать представление для визуализации любого элемента &lt;code&gt;Story&lt;/code&gt; . Фактическая история для рендеринга будет определяться данными, передаваемыми в компонент: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; . Эквивалентом в GraphQL являются &lt;strong&gt;фрагменты&lt;/strong&gt; : именованные сниппеты запросов, которые указывают, какие данные нужно извлекать &lt;em&gt;для объекта данного типа&lt;/em&gt; . Мы могли бы описать данные, необходимые &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; , следующим образом:</target>
        </trans-unit>
        <trans-unit id="76c99c886cf994dd48c328f17b234bd016edf810" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="254c939fb761720339a3dd3ad863697bebf60c3f" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">Relay также идет дальше: он использует непрозрачные идентификаторы на &lt;code&gt;props&lt;/code&gt; для проверки того, что мы явно получили данные для компонента перед его рендерингом. Если &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; отображает &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; , но забывает включить его фрагмент, Relay предупредит, что данные для &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; отсутствуют. Фактически, Relay будет предупреждать, &lt;em&gt;даже если&lt;/em&gt; какой-то другой компонент получил те же данные, которые требуются &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; . Это предупреждение говорит нам о том, что, хотя сейчас все &lt;em&gt;может&lt;/em&gt; работать, очень вероятно, что сломается позже.</target>
        </trans-unit>
        <trans-unit id="c212579d453e98cbd0a4dcbacffef8088e5ab28f" translate="yes" xml:space="preserve">
          <source>Relay also lets us completely replace the default network layer.</source>
          <target state="translated">Реле также позволяет нам полностью заменить сетевой уровень по умолчанию.</target>
        </trans-unit>
        <trans-unit id="f200764a518868ca3b31ea98a1353b5d9f2dd1fc" translate="yes" xml:space="preserve">
          <source>Relay can be thought of as two parts which work together: an API for building data-driven components and a runtime which fetches and stores data from GraphQL to populate your app. Relay Modern brings both a new API and a new runtime.</source>
          <target state="translated">Реле можно рассматривать как две части,которые работают вместе:API для построения компонентов,управляемых данными,и время выполнения,которое извлекает и сохраняет данные из GraphQL,чтобы заполнить ваше приложение.Relay Modern приносит как новый API,так и новое время выполнения.</target>
        </trans-unit>
        <trans-unit id="edc443fe11fe9992f4eb82855f77153b4705147b" translate="yes" xml:space="preserve">
          <source>Relay containers are created using &lt;code&gt;Relay.createContainer&lt;/code&gt;.</source>
          <target state="translated">Контейнеры ретрансляции создаются с помощью &lt;code&gt;Relay.createContainer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2748ac007f286936a91fb67b3ca6e11462a7fe21" translate="yes" xml:space="preserve">
          <source>Relay containers are higher-order components &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the &lt;code&gt;state&lt;/code&gt; of the inner component.</source>
          <target state="translated">Контейнеры ретрансляции - это компоненты более высокого порядка. &lt;code&gt;Relay.createContainer&lt;/code&gt; - это функция, которая принимает компонент React в качестве входных данных и возвращает новый компонент в качестве выходных данных. Это означает, что контейнер может управлять логикой выборки и разрешения данных, не влияя на &lt;code&gt;state&lt;/code&gt; внутреннего компонента.</target>
        </trans-unit>
        <trans-unit id="1c357d13b1cce8a1c46ccc30afeeb5fd2f902c5a" translate="yes" xml:space="preserve">
          <source>Relay containers provide a static &lt;code&gt;getFragment()&lt;/code&gt; method that returns a reference to that component's fragment:</source>
          <target state="translated">Контейнеры-ретрансляторы предоставляют статический &lt;code&gt;getFragment()&lt;/code&gt; который возвращает ссылку на фрагмент этого компонента:</target>
        </trans-unit>
        <trans-unit id="5a410cc37e6396592aa37827cec122428cb2d984" translate="yes" xml:space="preserve">
          <source>Relay couples React with GraphQL and develops the idea of encapsulation further. It allows components to specify what data they need and the Relay framework provides the data. This makes the data needs of inner components opaque and allows composition of those needs. Thinking about what data an app needs becomes localized to the component making it easier to reason about what fields are needed or no longer needed.</source>
          <target state="translated">Релейные пары реагируют с GraphQL и развивают идею инкапсуляции дальше.Это позволяет компонентам указывать,какие данные им нужны,а каркас Реле предоставляет данные.Это делает потребности в данных внутренних компонентов непрозрачными и позволяет составить эти потребности.Размышления о том,какие данные нужны приложению,становятся локализованными по отношению к компоненту,что облегчает рассуждение о том,какие поля нужны или больше не нужны.</target>
        </trans-unit>
        <trans-unit id="934fd827600b774b11b92dcf9269d690870fb9bb" translate="yes" xml:space="preserve">
          <source>Relay ensures that this data is available before the component is rendered.</source>
          <target state="translated">Реле гарантирует,что эти данные будут доступны до того,как компонент будет визуализирован.</target>
        </trans-unit>
        <trans-unit id="b556a8542493c85c6ab714e7efdb1e48fb0c7ece" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to create subscriptions.</source>
          <target state="translated">Реле раскрывает следующие API для создания подписок.</target>
        </trans-unit>
        <trans-unit id="8076714ed2f663c62d9c70223ceef029bffc6fc4" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to perform mutations.</source>
          <target state="translated">Реле подвергает воздействию следующие API для выполнения мутаций.</target>
        </trans-unit>
        <trans-unit id="9a9f6b192104115130a465f5d1b347425625bd6d" translate="yes" xml:space="preserve">
          <source>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with &lt;code&gt;Relay.QL&lt;/code&gt;. For example:</source>
          <target state="translated">Фрагменты ретрансляции, мутации и запросы должны быть указаны с использованием литералов шаблона ES6, помеченных &lt;code&gt;Relay.QL&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="f94ab02e4b36f1c69a9b192786b3451a5578f530" translate="yes" xml:space="preserve">
          <source>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</source>
          <target state="translated">Реле имеет абстракцию сетевого уровня,которая отделяет мутации и запросы от реального оборудования,которое посылает запросы на GraphQL сервер.Это дает нам возможность гибко настраивать или даже полностью заменять сетевой уровень по умолчанию с помощью инъекций.</target>
        </trans-unit>
        <trans-unit id="3e093a4c47e1f292b6f2a4693a9f28a6e839881f" translate="yes" xml:space="preserve">
          <source>Relay implements several variations of &lt;strong&gt;query traversal&lt;/strong&gt;: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</source>
          <target state="translated">Relay реализует несколько вариантов &lt;strong&gt;обхода запроса&lt;/strong&gt; : операции, которые обрабатывают запрос вместе с некоторыми другими данными, такими как кеш или полезная нагрузка ответа. Например, при получении запроса Relay выполняет обход &amp;laquo;diff&amp;raquo;, чтобы определить, какие поля отсутствуют (подобно тому, как React различает виртуальные деревья DOM). Это может уменьшить объем данных, извлекаемых во многих распространенных случаях, и даже позволить Relay вообще избегать сетевых запросов, когда запросы полностью кэшированы.</target>
        </trans-unit>
        <trans-unit id="1f7225f6558a177e37be9ba84410fe63b32cde06" translate="yes" xml:space="preserve">
          <source>Relay introduces two new classes of objects: &lt;code&gt;RelayContainer&lt;/code&gt; and &lt;code&gt;Relay.Route&lt;/code&gt;. &lt;code&gt;Relay.PropTypes&lt;/code&gt; provides prop validators used to assert that props are of these types.</source>
          <target state="translated">Relay представляет два новых класса объектов: &lt;code&gt;RelayContainer&lt;/code&gt; и &lt;code&gt;Relay.Route&lt;/code&gt; . &lt;code&gt;Relay.PropTypes&lt;/code&gt; предоставляет валидаторы свойств, используемые для подтверждения того, что свойства относятся к этим типам.</target>
        </trans-unit>
        <trans-unit id="2948c3c748b1764a34a269ea9919759693eaf027" translate="yes" xml:space="preserve">
          <source>Relay is a JavaScript framework for building data-driven React applications powered by GraphQL, designed from the ground up to be easy to use, extensible and, most of all, performant. Relay accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f52c1bbd17e02a2c6367d7476a6ac21c258276" translate="yes" xml:space="preserve">
          <source>Relay is pre-configured to use a default network layer that works with &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;. This default network layer is exposed via &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt;.</source>
          <target state="translated">Relay предварительно настроен для использования сетевого уровня по умолчанию, который работает с &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt; . Этот сетевой уровень по умолчанию предоставляется через &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54171fd2fa20a9c4bec1be11d3879a92bfa7df55" translate="yes" xml:space="preserve">
          <source>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; and implement, at minimum, the four abstract methods listed below.</source>
          <target state="translated">Relay использует мутации GraphQL; операции, которые позволяют нам изменять данные на клиенте и сервере. Чтобы создать мутацию для использования в нашем приложении, мы создаем подкласс &lt;code&gt;Relay.Mutation&lt;/code&gt; и реализуем, как минимум, четыре абстрактных метода, перечисленных ниже.</target>
        </trans-unit>
        <trans-unit id="973d2e671c894478b465827d5c3826264541eadd" translate="yes" xml:space="preserve">
          <source>Relay modern makes no assumptions about what to cache and will garbage collect any data that is no longer referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd31c1805e052611332ba16c37162381a4a626a" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</source>
          <target state="translated">Релейные маршруты не реализуют никакой специфической логики URL-маршрутизации и не работают с History API.В будущем мы,возможно,переименуем RelayRoute в RelayQueryRoots или RelayQueryConfig.</target>
        </trans-unit>
        <trans-unit id="589e99096a0b6781ff51073c2234321dc486a027" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">Маршруты ретрансляции на самом деле не реализуют никакой логики маршрутизации URL-адресов или не работают с History API. В будущем мы, возможно, переименуем RelayRoute, чтобы он был больше похож на RelayQueryRoots или RelayQueryConfig. Дополнительные сведения о том, почему Relay не предоставляет функции маршрутизации URL-адресов, и предложения по таким решениям см. В &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;этом сообщении&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef480060aa47ef1a958a5c003bdd30a4e3354405" translate="yes" xml:space="preserve">
          <source>Relay speaks to GraphQL servers through a network layer. The &lt;a href=&quot;guides-network-layer&quot;&gt;network layer&lt;/a&gt; that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</source>
          <target state="translated">Relay общается с серверами GraphQL через сетевой уровень. &lt;a href=&quot;guides-network-layer&quot;&gt;Сетевой уровень&lt;/a&gt; , который поставляется с реле совместят с экспресс-graphql из коробки, и будет продолжать развиваться по мере добавления новых функций к перевозке.</target>
        </trans-unit>
        <trans-unit id="256546be326de4c5533a50332088277d259f1856" translate="yes" xml:space="preserve">
          <source>Relay updates the component whenever the underlying data has changed.</source>
          <target state="translated">Реле обновляет компонент всякий раз,когда изменяются базовые данные.</target>
        </trans-unit>
        <trans-unit id="7f2f7458912547fdfa17a726b3bd42f898c10724" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;Babel&lt;/strong&gt; plugin to convert &lt;code&gt;graphql&lt;/code&gt; literals into requires of the code generated by Relay Compiler.</source>
          <target state="translated">Relay использует плагин &lt;strong&gt;Babel&lt;/strong&gt; для преобразования литералов &lt;code&gt;graphql&lt;/code&gt; в требования кода, сгенерированного Relay Compiler.</target>
        </trans-unit>
        <trans-unit id="9cbd2a4fac093602e7724812345c1426293f1cd9" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;babel&lt;/strong&gt; plugin to convert from &lt;code&gt;Relay.QL&lt;/code&gt; string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</source>
          <target state="translated">Relay использует плагин &lt;strong&gt;babel&lt;/strong&gt; для преобразования строковых шаблонов &lt;code&gt;Relay.QL&lt;/code&gt; в код JavaScript, который описывает каждый запрос и включает данные из схемы GraphQL.</target>
        </trans-unit>
        <trans-unit id="5ab5569c1247a6342fa21f23bd4fe7b1d8d672c4" translate="yes" xml:space="preserve">
          <source>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, &lt;code&gt;input&lt;/code&gt;, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</source>
          <target state="translated">Relay использует общий шаблон для мутаций, где они являются корневыми полями для типа мутации с одним аргументом, &lt;code&gt;input&lt;/code&gt; , и где вход и выход содержат идентификатор мутации клиента, используемый для согласования запросов и ответов.</target>
        </trans-unit>
        <trans-unit id="dd4a65f25979a2d6ac22ff73e832b56882a6731f" translate="yes" xml:space="preserve">
          <source>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</source>
          <target state="translated">Relay использует всю эту функциональность для построения абстракций вокруг соединений,чтобы сделать их простыми для эффективной работы без необходимости вручную управлять курсорами на клиенте.</target>
        </trans-unit>
        <trans-unit id="3dc783e9ac2c6bb867e37e0f714a2ddf7651506d" translate="yes" xml:space="preserve">
          <source>Relay uses directives to add additional information to GraphQL documents, which are used by the &lt;a href=&quot;#relay-compiler&quot;&gt;Relay Compiler&lt;/a&gt; to generate the appropriate runtime artifacts. These directives only appear in your application code and are removed from requests sent to your GraphQL server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7215a332ba837f6189ba19038b406a179e835435" translate="yes" xml:space="preserve">
          <source>Relay uses routes to define entry points into a Relay application.</source>
          <target state="translated">Реле использует маршруты для определения точек входа в приложение Реле.</target>
        </trans-unit>
        <trans-unit id="c47cadca2b04900115d6a0cc7ce416c63eeb2c11" translate="yes" xml:space="preserve">
          <source>Relay uses the Relay Compiler to convert &lt;a href=&quot;#graphql&quot;&gt;&lt;code&gt;graphql&lt;/code&gt;&lt;/a&gt; literals into generated files that live alongside your source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84f12bb76c08fcf1ebc1d56caf39b1024a1f70b" translate="yes" xml:space="preserve">
          <source>Relay v1.0 introduces the Relay Modern API:</source>
          <target state="translated">Relay v1.0 представляет Relay Modern API:</target>
        </trans-unit>
        <trans-unit id="59061b6874678f961da16dff064bafb7cf4ff327" translate="yes" xml:space="preserve">
          <source>Relay will then automatically update the fields under the record corresponding to the ids in the response payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3c5e271e633d2cf5f26344b18759ea44b95380" translate="yes" xml:space="preserve">
          <source>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize &lt;em&gt;when&lt;/em&gt; these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</source>
          <target state="translated">Relay оборачивает свои основные функции обработки в облегченные задачи, которые по умолчанию выполняются немедленно (т. Е. Синхронно). Чтобы настроить &lt;em&gt;время выполнения&lt;/em&gt; этих задач - например, чтобы не прерывать анимацию во время сенсорного жеста - приложения могут предоставлять настраиваемую функцию планирования.</target>
        </trans-unit>
        <trans-unit id="576baa5c970e0023c6b7f930fc5b22d07e80b876" translate="yes" xml:space="preserve">
          <source>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable &lt;strong&gt;components&lt;/strong&gt;, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are &lt;strong&gt;declarative&lt;/strong&gt;: they allow developers to specify &lt;em&gt;what&lt;/em&gt; the UI should look like for a given state, and not have to worry about &lt;em&gt;how&lt;/em&gt; to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</source>
          <target state="translated">Подход Relay к выборке данных во многом основан на нашем опыте работы с React. В частности, React разбивает сложные интерфейсы на повторно используемые &lt;strong&gt;компоненты&lt;/strong&gt; , позволяя разработчикам рассуждать о дискретных единицах приложения изолированно и уменьшая взаимосвязь между разрозненными частями приложения. Еще важнее то, что эти компоненты являются &lt;strong&gt;декларативными&lt;/strong&gt; : они позволяют разработчикам указывать, &lt;em&gt;как&lt;/em&gt; пользовательский интерфейс должен выглядеть для данного состояния, и им не нужно беспокоиться о &lt;em&gt;том, как&lt;/em&gt; показать этот пользовательский интерфейс. В отличие от предыдущих подходов, которые использовали императивные команды для управления собственными представлениями (например, DOM), React использует описание пользовательского интерфейса для автоматического определения необходимых команд.</target>
        </trans-unit>
        <trans-unit id="6b33d0db31f7976b67c0c833688c3f1a2f3ed1a7" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation</source>
          <target state="translated">Relay.GraphQLMutation</target>
        </trans-unit>
        <trans-unit id="1dd1eeecd4591e6fc51ed50ccec4372072ef5f58" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#applyOptimistic()</source>
          <target state="translated">Relay.GraphQLMutation#applyOptimistic()</target>
        </trans-unit>
        <trans-unit id="778c7e41e609c680486529c141869bd60529ad4f" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#commit()</source>
          <target state="translated">Relay.GraphQLMutation#commit()</target>
        </trans-unit>
        <trans-unit id="3dd83b3b4baca74ae215635dc8057361bd27c698" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#constructor()</source>
          <target state="translated">Relay.GraphQLMutation#constructor()</target>
        </trans-unit>
        <trans-unit id="c60b9c934ff71ffb2a3ed3d72c60871bbe0e468e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#rollback()</source>
          <target state="translated">Relay.GraphQLMutation#rollback()</target>
        </trans-unit>
        <trans-unit id="3340870222c54d4e58da2c45216a0f9201d39a18" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.create()</source>
          <target state="translated">Relay.GraphQLMutation.create()</target>
        </trans-unit>
        <trans-unit id="a23c2d405f689b19dfd1fd7c28df5c48a68add1e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.createWithFiles()</source>
          <target state="translated">Relay.GraphQLMutation.createWithFiles()</target>
        </trans-unit>
        <trans-unit id="03551f79ebf3cd05d7c2ceaa3bea55c92b64e6d0" translate="yes" xml:space="preserve">
          <source>Relay.Mutation</source>
          <target state="translated">Relay.Mutation</target>
        </trans-unit>
        <trans-unit id="3ba32adda774e85164beb595e60d2e216978176e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#constructor()</source>
          <target state="translated">Relay.Mutation#constructor()</target>
        </trans-unit>
        <trans-unit id="04100c1f256b9742428fc3ccbb91ce26474f7916" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getCollisionKey()</source>
          <target state="translated">Relay.Mutation#getCollisionKey()</target>
        </trans-unit>
        <trans-unit id="6239b4b0c4bd148ddc88ff80a2414323538280f1" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getConfigs()</source>
          <target state="translated">Relay.Mutation#getConfigs()</target>
        </trans-unit>
        <trans-unit id="ef63d6cc19f0b592de123cd60ec1e1b1998d6f17" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFatQuery()</source>
          <target state="translated">Relay.Mutation#getFatQuery()</target>
        </trans-unit>
        <trans-unit id="712207e70740181f3ab2120dc0f2bcc301c5f54e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFiles()</source>
          <target state="translated">Relay.Mutation#getFiles()</target>
        </trans-unit>
        <trans-unit id="e97a189b3ae9338d83696e14598b587f01455562" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getMutation()</source>
          <target state="translated">Relay.Mutation#getMutation()</target>
        </trans-unit>
        <trans-unit id="9ef4e47c4ce8d138fc8484b73b762f8325ab6d50" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticConfigs()</source>
          <target state="translated">Relay.Mutation#getOptimisticConfigs()</target>
        </trans-unit>
        <trans-unit id="9c72c0ca95feabd409adccf873cc396f84f49fa7" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticResponse()</source>
          <target state="translated">Relay.Mutation#getOptimisticResponse()</target>
        </trans-unit>
        <trans-unit id="0407ffada104593511af47973fbf4f161321629f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getVariables()</source>
          <target state="translated">Relay.Mutation#getVariables()</target>
        </trans-unit>
        <trans-unit id="25241731d9b8a5e3bb893a8a7166ea0d07b29738" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.fragments</source>
          <target state="translated">Relay.Mutation.fragments</target>
        </trans-unit>
        <trans-unit id="b7852fe98838e6fc1d72feab70dfa349933b9a4f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.getFragment()</source>
          <target state="translated">Relay.Mutation.getFragment()</target>
        </trans-unit>
        <trans-unit id="d9618c47616902c437879ab1fb98a8eb932feeeb" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.initialVariables</source>
          <target state="translated">Relay.Mutation.initialVariables</target>
        </trans-unit>
        <trans-unit id="88607afefb79afbc0a5c6c2204c3c59784086c6d" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.prepareVariables</source>
          <target state="translated">Relay.Mutation.prepareVariables</target>
        </trans-unit>
        <trans-unit id="15cdd01f7f3228bf705c67fcca4cc7376e38847b" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes</source>
          <target state="translated">Relay.PropTypes</target>
        </trans-unit>
        <trans-unit id="0af8bcf2b06b250091c5a6a9f45a93a8ec335270" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes.QueryConfig: ReactPropTypeValidator</source>
          <target state="translated">Реле.Типы ретрансляторов.Запросы:ReactPropTypeValidator .</target>
        </trans-unit>
        <trans-unit id="991536fff9faf615e80c1b42bfda61b3395074a1" translate="yes" xml:space="preserve">
          <source>Relay.QL</source>
          <target state="translated">Relay.QL</target>
        </trans-unit>
        <trans-unit id="e66127f684a064c2b23590835fd5fc4afce5e3bc" translate="yes" xml:space="preserve">
          <source>Relay.Renderer</source>
          <target state="translated">Relay.Renderer</target>
        </trans-unit>
        <trans-unit id="1e64d297283159c1fd5f3c0f4f7f2590f52aeaf0" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#Container</source>
          <target state="translated">Relay.Renderer#Container</target>
        </trans-unit>
        <trans-unit id="0f68d914b2de005998fdb01ba1b1095a495e227d" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#environment</source>
          <target state="translated">Relay.Renderer#environment</target>
        </trans-unit>
        <trans-unit id="8e4cc916528c14e528833e3f79df2da75fd53acb" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#forceFetch</source>
          <target state="translated">Relay.Renderer#forceFetch</target>
        </trans-unit>
        <trans-unit id="bf0a7bc1a436c9a32f0f42831033b65d5cfbaf43" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#onReadyStateChange</source>
          <target state="translated">Relay.Renderer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="9c4d750f130c80ae940ddef73d72538928767978" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#queryConfig</source>
          <target state="translated">Relay.Renderer#queryConfig</target>
        </trans-unit>
        <trans-unit id="ff227ea702919a6f75cb559ade588c7d11c20c78" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#render</source>
          <target state="translated">Relay.Renderer#render</target>
        </trans-unit>
        <trans-unit id="2761fdabd570b4cb3fdee157bed2ad5cb9ae4930" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer</source>
          <target state="translated">Relay.RootContainer</target>
        </trans-unit>
        <trans-unit id="543cce18705fbddda91e09c015e6da78c821e550" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#Component</source>
          <target state="translated">Relay.RootContainer#Component</target>
        </trans-unit>
        <trans-unit id="4c1d8599b11aa80027feab65c33b5f34aece2fe8" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#forceFetch</source>
          <target state="translated">Relay.RootContainer#forceFetch</target>
        </trans-unit>
        <trans-unit id="69120820a45037f7a9e51a705842b61000d0ac96" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#onReadyStateChange</source>
          <target state="translated">Relay.RootContainer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="0b9faeb15a496f220a6b405a981a20f8ef453965" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFailure</source>
          <target state="translated">Relay.RootContainer#renderFailure</target>
        </trans-unit>
        <trans-unit id="7bd3ce353967f7aff355ff3522f40b703a8bd047" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFetched</source>
          <target state="translated">Relay.RootContainer#renderFetched</target>
        </trans-unit>
        <trans-unit id="8e6dba1eefc9476de73a3eb76f6a4bb45f2d9827" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderLoading</source>
          <target state="translated">Relay.RootContainer#renderLoading</target>
        </trans-unit>
        <trans-unit id="a9647a1d13d1b00fb81a049cb69e0f50d9005610" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#route</source>
          <target state="translated">Relay.RootContainer#route</target>
        </trans-unit>
        <trans-unit id="2163890d6b8486ab713e8307739f1fc8ffdc4051" translate="yes" xml:space="preserve">
          <source>Relay.Route</source>
          <target state="translated">Relay.Route</target>
        </trans-unit>
        <trans-unit id="ec4ec0225d1b12f051db712106148d8b26db80c7" translate="yes" xml:space="preserve">
          <source>Relay.Route#constructor()</source>
          <target state="translated">Relay.Route#constructor()</target>
        </trans-unit>
        <trans-unit id="933d2afe910e8eed75954f1ef8511fc9c8104ede" translate="yes" xml:space="preserve">
          <source>Relay.Route.paramDefinitions</source>
          <target state="translated">Relay.Route.paramDefinitions</target>
        </trans-unit>
        <trans-unit id="be2c5425ec7dbd5886d4716f82a79360b73375a7" translate="yes" xml:space="preserve">
          <source>Relay.Route.prepareParams</source>
          <target state="translated">Relay.Route.prepareParams</target>
        </trans-unit>
        <trans-unit id="632587b7cd190cd1537600ee207e20b1ff9030d5" translate="yes" xml:space="preserve">
          <source>Relay.Route.queries</source>
          <target state="translated">Relay.Route.queries</target>
        </trans-unit>
        <trans-unit id="90af1f420232cc590b9eb96c3c9344d637dded41" translate="yes" xml:space="preserve">
          <source>Relay.Route.routeName</source>
          <target state="translated">Relay.Route.routeName</target>
        </trans-unit>
        <trans-unit id="596c88b6dd79bb8e709c7b945308e399ac2abc3a" translate="yes" xml:space="preserve">
          <source>Relay.Store</source>
          <target state="translated">Relay.Store</target>
        </trans-unit>
        <trans-unit id="1ca8451821663a9beeafb5041c9c0bfdf4aff046" translate="yes" xml:space="preserve">
          <source>Relay.Store.applyUpdate()</source>
          <target state="translated">Relay.Store.applyUpdate()</target>
        </trans-unit>
        <trans-unit id="23f95eef5a8ff15d45d59ef33e2757420f465ed8" translate="yes" xml:space="preserve">
          <source>Relay.Store.commitUpdate()</source>
          <target state="translated">Relay.Store.commitUpdate()</target>
        </trans-unit>
        <trans-unit id="5435b8d8380c04f42e516eb3bd9326e46359b1b6" translate="yes" xml:space="preserve">
          <source>Relay.createContainer()</source>
          <target state="translated">Relay.createContainer()</target>
        </trans-unit>
        <trans-unit id="12f5066f2601943d9aac424bb916a7d3e8a44732" translate="yes" xml:space="preserve">
          <source>Relay.injectNetworkLayer()</source>
          <target state="translated">Relay.injectNetworkLayer()</target>
        </trans-unit>
        <trans-unit id="1a735b56a61cab41febb27320e2f243ed493b94f" translate="yes" xml:space="preserve">
          <source>Relay.injectTaskScheduler()</source>
          <target state="translated">Relay.injectTaskScheduler()</target>
        </trans-unit>
        <trans-unit id="309387769d52bfb1d6f330d2a6e3ecd71ecb41e1" translate="yes" xml:space="preserve">
          <source>Relay.isContainer()</source>
          <target state="translated">Relay.isContainer()</target>
        </trans-unit>
        <trans-unit id="c772f86aadb639ca41aafc4ec6f52aaae43e0acf" translate="yes" xml:space="preserve">
          <source>RelayContainer</source>
          <target state="translated">RelayContainer</target>
        </trans-unit>
        <trans-unit id="76e743848043959a7f2bfa720b5616417bb798e1" translate="yes" xml:space="preserve">
          <source>RelayContainer implements a conservative default &lt;code&gt;shouldComponentUpdate&lt;/code&gt; that returns &lt;code&gt;false&lt;/code&gt; if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a &lt;code&gt;shouldComponentUpdate&lt;/code&gt; function.</source>
          <target state="translated">RelayContainer реализует консервативное значение по умолчанию &lt;code&gt;shouldComponentUpdate&lt;/code&gt; , которое возвращает &lt;code&gt;false&lt;/code&gt; , если никакие свойства фрагмента не изменились, а все остальные свойства имеют равные скалярные значения. Это может блокировать обновления компонентов, которые получают данные через контекст. Чтобы гарантировать обновление в этом случае, переопределите поведение по умолчанию, указав функцию &lt;code&gt;shouldComponentUpdate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83d048709f5073df975dc9c425226f037d2ced9a" translate="yes" xml:space="preserve">
          <source>RelayContainer#forceFetch()</source>
          <target state="translated">RelayContainer#forceFetch()</target>
        </trans-unit>
        <trans-unit id="12306a7598448404edb2c73ef03ebd3b1459df33" translate="yes" xml:space="preserve">
          <source>RelayContainer#fragments</source>
          <target state="translated">RelayContainer#fragments</target>
        </trans-unit>
        <trans-unit id="fa4bac3fc05c361b8142cf895c4dec7b9136e491" translate="yes" xml:space="preserve">
          <source>RelayContainer#getFragment()</source>
          <target state="translated">RelayContainer#getFragment()</target>
        </trans-unit>
        <trans-unit id="0f0d5c6a56d86ccbcf94f9197715dbb511dcccda" translate="yes" xml:space="preserve">
          <source>RelayContainer#getPendingTransactions()</source>
          <target state="translated">RelayContainer#getPendingTransactions()</target>
        </trans-unit>
        <trans-unit id="3583e47f56ed32f6527e40cae51e9cd4226d6b8a" translate="yes" xml:space="preserve">
          <source>RelayContainer#hasOptimisticUpdate()</source>
          <target state="translated">RelayContainer#hasOptimisticUpdate()</target>
        </trans-unit>
        <trans-unit id="f6baca904aa4a3f9af8b6cef6a7995ee09553ec3" translate="yes" xml:space="preserve">
          <source>RelayContainer#initialVariables</source>
          <target state="translated">RelayContainer#initialVariables</target>
        </trans-unit>
        <trans-unit id="67aea36b1c5b679f64f0d153f256c81a818ebe83" translate="yes" xml:space="preserve">
          <source>RelayContainer#pendingVariables</source>
          <target state="translated">RelayContainer#pendingVariables</target>
        </trans-unit>
        <trans-unit id="9cce83d93b864bd7fad1aa07826c61d9a6ef284e" translate="yes" xml:space="preserve">
          <source>RelayContainer#prepareVariables</source>
          <target state="translated">RelayContainer#prepareVariables</target>
        </trans-unit>
        <trans-unit id="ef93161b93af5f5e98d21bb920dbacc9ffd1f25e" translate="yes" xml:space="preserve">
          <source>RelayContainer#route</source>
          <target state="translated">RelayContainer#route</target>
        </trans-unit>
        <trans-unit id="707b6138cca39388519379f5f0473ddd29369f7f" translate="yes" xml:space="preserve">
          <source>RelayContainer#setVariables()</source>
          <target state="translated">RelayContainer#setVariables()</target>
        </trans-unit>
        <trans-unit id="13dc088a9a8f1b885a4b30d133ebfc79f65f8a56" translate="yes" xml:space="preserve">
          <source>RelayContainer#shouldComponentUpdate</source>
          <target state="translated">RelayContainer#shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="562b0d971d42af3b685406a662899de6e23e0ff8" translate="yes" xml:space="preserve">
          <source>RelayContainer#variables</source>
          <target state="translated">RelayContainer#variables</target>
        </trans-unit>
        <trans-unit id="cf0a077ddadfb043fbdeb8a931f05f97f9dec4db" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest</source>
          <target state="translated">RelayMutationRequest</target>
        </trans-unit>
        <trans-unit id="459733a291121fc4443f52543c52bf1ba049dc6a" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getDebugName()</source>
          <target state="translated">RelayMutationRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="e6aac4071918a71d5a4437bcf00846a0803cb431" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getFiles()</source>
          <target state="translated">RelayMutationRequest#getFiles()</target>
        </trans-unit>
        <trans-unit id="98f8235cb1f82e31b63e4abc739976992bfb5247" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getID()</source>
          <target state="translated">RelayMutationRequest#getID()</target>
        </trans-unit>
        <trans-unit id="aced70c9403a7f1d9071b6bdae3bf77f17f27954" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getQueryString()</source>
          <target state="translated">RelayMutationRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="f6fd4f67bc834b8917c668afd31ee438a325f452" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getVariables()</source>
          <target state="translated">RelayMutationRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="20f8806483b79b8a279be2b49be8c750a67cdb41" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer</source>
          <target state="translated">RelayNetworkLayer</target>
        </trans-unit>
        <trans-unit id="7f0a8ef7b7a43a9933addcbaef565eff07884834" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendMutation()</source>
          <target state="translated">RelayNetworkLayer#sendMutation()</target>
        </trans-unit>
        <trans-unit id="67d40797657bd24a84a171e652a9bea818a15d96" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendQueries()</source>
          <target state="translated">RelayNetworkLayer#sendQueries()</target>
        </trans-unit>
        <trans-unit id="eacde2e3a9c41d29b2ee433848dfea8232a5d22a" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#supports()</source>
          <target state="translated">RelayNetworkLayer#supports()</target>
        </trans-unit>
        <trans-unit id="5113dd07f144f50d7677810b044a345b89e66e0e" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest</source>
          <target state="translated">RelayQueryRequest</target>
        </trans-unit>
        <trans-unit id="4a9c272793946b8bdd3a09cdfbde6dc8574faf62" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getDebugName()</source>
          <target state="translated">RelayQueryRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="481aa62146f5343b4ba1062802709201d6d4d7af" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getID()</source>
          <target state="translated">RelayQueryRequest#getID()</target>
        </trans-unit>
        <trans-unit id="0f467922406404a5eac2d6f11b736b9d66633025" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getQueryString()</source>
          <target state="translated">RelayQueryRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="981023af3724c0e925cbc3f99f867f132178c714" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getVariables()</source>
          <target state="translated">RelayQueryRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="8324e4ecabe765d0034c56fc8f4c857ecfa3e2ae" translate="yes" xml:space="preserve">
          <source>RelayRecordProxy</source>
          <target state="translated">RelayRecordProxy</target>
        </trans-unit>
        <trans-unit id="69b9a9d8ad89e9af43d214607d3ff0018325568c" translate="yes" xml:space="preserve">
          <source>RelayRecordStore</source>
          <target state="translated">RelayRecordStore</target>
        </trans-unit>
        <trans-unit id="8aa27a7e83012be706218f33db1f656ebf3d0b47" translate="yes" xml:space="preserve">
          <source>Render Callbacks</source>
          <target state="translated">Рендер Обратные вызовы</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="db86b99e5c8c7fa5281608698558232d5c55e13b" translate="yes" xml:space="preserve">
          <source>Rendering Containers</source>
          <target state="translated">Рендерные контейнеры</target>
        </trans-unit>
        <trans-unit id="af597671c6dcfa1df34e2e38251238001351c84d" translate="yes" xml:space="preserve">
          <source>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: &lt;em&gt;caching&lt;/em&gt;.</source>
          <target state="translated">Повторное получение информации с сервера может выполняться довольно медленно. Например, переход от списка историй к элементу списка и обратно к списку историй означает, что нам нужно повторно выбрать весь список. Решим это стандартным решением: &lt;em&gt;кешированием&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3341adcc90aa2cf65b0ed4f78d46fafd5dfc9cd5" translate="yes" xml:space="preserve">
          <source>Requesting Different Data</source>
          <target state="translated">Запрос различных данных</target>
        </trans-unit>
        <trans-unit id="b092a39c824d57357df89b0ece2eb1e4c9834cca" translate="yes" xml:space="preserve">
          <source>Require the Relay Compat API from &lt;code&gt;'react-relay/compat'&lt;/code&gt; and use it as you would Relay Modern. The components using Relay Compat can be referred to by both other Relay Modern and Relay Classic components.</source>
          <target state="translated">Требуйте API-интерфейс Relay Compat от &lt;code&gt;'react-relay/compat'&lt;/code&gt; react -relay / compat&amp;raquo; и используйте его так же, как Relay Modern. Компоненты, использующие Relay Compat, могут упоминаться как другими компонентами Relay Modern, так и Relay Classic.</target>
        </trans-unit>
        <trans-unit id="61ac8791c7043a10705ecb741c56abf9848abf0a" translate="yes" xml:space="preserve">
          <source>Resolving Data from the Client</source>
          <target state="translated">Регулирование данных от клиента</target>
        </trans-unit>
        <trans-unit id="3281bf767244e09b6483581e4d93f748c54eb136" translate="yes" xml:space="preserve">
          <source>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</source>
          <target state="translated">Кэширование ответов также может быть применено к GraphQL.Базовый подход будет работать аналогично REST версии.Текст самого запроса может быть использован в качестве ключа кэширования:</target>
        </trans-unit>
        <trans-unit id="1daed2e622c367b716a7da87b2e2edd04d8d8e79" translate="yes" xml:space="preserve">
          <source>Retrieves a record associated with the current record given the field name, as defined by the GraphQL document. Returns a &lt;code&gt;RecordProxy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a06b7b5f5bbad1dc68e21eaac11574c07de428a8" translate="yes" xml:space="preserve">
          <source>Retrieves a record from the store given its &lt;code&gt;dataID&lt;/code&gt;. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12402592aaf37a5d3ace23c3d09e0cda3355dad6" translate="yes" xml:space="preserve">
          <source>Retrieves a root field from the store given the &lt;code&gt;fieldName&lt;/code&gt;, as defined by the GraphQL document. Returns a &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; which serves as an interface to mutate the record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17061c12897cde333bc27d9d3b5b4885efbba0b0" translate="yes" xml:space="preserve">
          <source>Retrieves a root field that represents a collection from the store given the &lt;code&gt;fieldName&lt;/code&gt;, as defined by the GraphQL document. Returns an array of &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxies&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81554eb7c1007a0bac823cb3e3ca325777b63f97" translate="yes" xml:space="preserve">
          <source>Retrieves record(s) associated with the given record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">Извлекает запись(и),связанную с данной записью,передавая источник по имени поля и объект,представляющий значения предопределенных аргументов.</target>
        </trans-unit>
        <trans-unit id="0df40cacc16f0f75e7289c7b00fb27121dcf4af7" translate="yes" xml:space="preserve">
          <source>Retrieves the a record associated with the current record given the field name, as defined by the GraphQL document. If the linked record does not exist, it will be created given the type name. Returns a &lt;code&gt;RecordProxy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379be92d54161c2f80dceac4cdce0230264cb208" translate="yes" xml:space="preserve">
          <source>Retrieves the set of records associated with the current record given the field name, as defined by the GraphQL document. Returns an array of &lt;code&gt;RecordProxies&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e013c79a69f7fdde5c1472633a22316f0ef0ef72" translate="yes" xml:space="preserve">
          <source>Retrying failed requests.</source>
          <target state="translated">Повторение неудачных запросов.</target>
        </trans-unit>
        <trans-unit id="4ed1a51e3c7c6cf43a3633b3e58f69e74b9dd263" translate="yes" xml:space="preserve">
          <source>Return Value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e358acbbc41f30837ea01e45fb712ceb42c930a" translate="yes" xml:space="preserve">
          <source>Returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56de3c3d136f4071d757cabe4b6ed2c52a5dad01" translate="yes" xml:space="preserve">
          <source>Returns a proxy class for manipulating records from a record source, for example a query, mutation, or the store.</source>
          <target state="translated">Возвращает прокси-класс для манипулирования записями из источника записи,например,запрос,мутация или хранилище.</target>
        </trans-unit>
        <trans-unit id="91f8449d9fa8e9ef7aa99597a20ab0dcfe5b332a" translate="yes" xml:space="preserve">
          <source>Returns a read-only view of the store's internal RecordSource that holds all records.</source>
          <target state="translated">Возвращает доступный только для чтения вид внутреннего RecordSource магазина,в котором хранятся все записи.</target>
        </trans-unit>
        <trans-unit id="ddc37b98bab248dd41f22f1276390ce274609bd3" translate="yes" xml:space="preserve">
          <source>Returns the &lt;a href=&quot;#recordproxy&quot;&gt;&lt;code&gt;RecordProxy&lt;/code&gt;&lt;/a&gt; representing the root of the GraphQL document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9d68c06d14e4ad8d6a81f1e355b118c27b1408" translate="yes" xml:space="preserve">
          <source>Returns the GraphQL type name for a given record.</source>
          <target state="translated">Возвращает имя типа GraphQL для данной записи.</target>
        </trans-unit>
        <trans-unit id="d43e7555e127344d4f989c546065e0799ff790bb" translate="yes" xml:space="preserve">
          <source>Returns the dataID of the current record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384ac89b24069cf234b54ff56b3d6d5c565f33c7" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier string for a record.</source>
          <target state="translated">Возвращает строку глобального уникального идентификатора для записи.</target>
        </trans-unit>
        <trans-unit id="7d0eb64e469d72e6ccf94d6d96498f73ad0e6f27" translate="yes" xml:space="preserve">
          <source>Reusable fragments to compose within the above use cases.</source>
          <target state="translated">Фрагменты многоразового использования,которые могут быть собраны в вышеуказанных случаях использования.</target>
        </trans-unit>
        <trans-unit id="72e1985969f053f8609f492cf63340c5c4f7f3fc" translate="yes" xml:space="preserve">
          <source>Rolls back an optimistic mutation.</source>
          <target state="translated">Отворачивает оптимистическую мутацию.</target>
        </trans-unit>
        <trans-unit id="0dfddbb0a122d3a2969eb11e085210ba893e7399" translate="yes" xml:space="preserve">
          <source>Root Container</source>
          <target state="translated">корневой контейнер</target>
        </trans-unit>
        <trans-unit id="1bf5197778bc12b8d4edfe1a0c2de1ced169d30b" translate="yes" xml:space="preserve">
          <source>RootContainer</source>
          <target state="translated">RootContainer</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="52c021a7e89ad4e72cef6096b3c6424e78876574" translate="yes" xml:space="preserve">
          <source>Route is useful in providing the context which a component is being rendered in. It includes information about the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, and &lt;code&gt;queries&lt;/code&gt; of the current route.</source>
          <target state="translated">Маршрут полезен для предоставления контекста, в котором выполняется рендеринг компонента. Он включает информацию об &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;params&lt;/code&gt; и &lt;code&gt;queries&lt;/code&gt; текущего маршрута.</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="0bd75f049435ac9bea4df8ce63749bdcfaaef9e4" translate="yes" xml:space="preserve">
          <source>Routes and Queries</source>
          <target state="translated">Маршруты и запросы</target>
        </trans-unit>
        <trans-unit id="a476715db16204d7e6fb7743a314ee35337241d4" translate="yes" xml:space="preserve">
          <source>Routes are now optional: &lt;code&gt;QueryRenderer&lt;/code&gt; can be used without defining a route. More in the &lt;a href=&quot;routing&quot;&gt;routing guide&lt;/a&gt;.</source>
          <target state="translated">Маршруты теперь необязательны: &lt;code&gt;QueryRenderer&lt;/code&gt; можно использовать без определения маршрута. Подробнее в &lt;a href=&quot;routing&quot;&gt;руководстве&lt;/a&gt; по маршрутизации .</target>
        </trans-unit>
        <trans-unit id="ca283153940483bc802b34b41123871d483749c7" translate="yes" xml:space="preserve">
          <source>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user &lt;code&gt;123&lt;/code&gt;'s profile:</source>
          <target state="translated">Маршруты - это объекты, которые определяют набор корневых запросов и входных параметров. Вот простой маршрут, который можно использовать для визуализации профиля пользователя &lt;code&gt;123&lt;/code&gt; :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
