<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">Маршруты отвечают за определение точек входа в приложение &quot;Реле&quot;.Но чтобы понять,зачем нужны маршруты,сначала нужно понять разницу между GraphQL-запросами и фрагментами.</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">Маршруты могут объявлять набор имен параметров,которые необходимо предоставить конструктору.Это также удобное место для документирования набора действующих параметров.</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">Маршруты могут использовать &lt;code&gt;prepareParams&lt;/code&gt; для предоставления параметров по умолчанию или для передачи, преобразования или подавления переданных параметров.</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">Маршруты должны объявлять набор корней запросов с помощью &lt;code&gt;Relay.QL&lt;/code&gt; . Эти запросы будут автоматически составлять соответствующий фрагмент с именем &lt;code&gt;queryName&lt;/code&gt; в контейнере Relay, используемом с этим маршрутом в &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">Маршруты должны определять имя строки.</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">Маршрутам больше не нужно ничего знать о корне запроса в Relay Modern. Компоненты реле могут отображаться в любом месте в &lt;code&gt;QueryRenderer&lt;/code&gt; . Это должно обеспечить большую гибкость при выборе фреймворков маршрутизации.</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">Запустите Relay Compiler после внесения изменений в любой GraphQL в вашем приложении Relay. Может быть полезно добавить его как &lt;code&gt;yarn script&lt;/code&gt; . Добавьте запись в &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; в файле package.json.</target>
        </trans-unit>
        <trans-unit id="3c5a064ba8a60e5ab65def399ab519978d73b564" translate="yes" xml:space="preserve">
          <source>Runtime Architecture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">Схема JSON</target>
        </trans-unit>
        <trans-unit id="114b03b7a51c1001385ac516c6fa621d46453f66" translate="yes" xml:space="preserve">
          <source>Second, any subscriptions that do have overlapping data IDs are re-read, and the new/previous results are compared. If the result has not changed, the subscription is ignored (this can occur if a field of a record changed that is not relevant to the subscription's selector), otherwise processing continues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">См. В &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; методы, доступные для объекта аргумента.</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">См. В &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; методы, доступные для объектов аргументов.</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См.также</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt; Конструктор&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Контейнеры&amp;gt; Контейнеры реле&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Контейнеры&amp;gt; Запрос различных данных&lt;/a&gt; , состояние &lt;a href=&quot;guides-ready-state&quot;&gt;готовности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Мутации&amp;gt; Переменные фрагмента&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Мутации&amp;gt; Переменные фрагментов&lt;/a&gt; и &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;мутации&amp;gt; Оптимистические обновления&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Мутации&amp;gt; Конфигурация мутатора&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Мутации&amp;gt; Оптимистические обновления&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Мутации&amp;gt; Оптимистичные обновления&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Мутации&amp;gt; Жирный запрос&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-ready-state&quot;&gt;Состояние готовности&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Корневой контейнер&amp;gt; Компонент и маршрут&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Корневой контейнер&amp;gt; Принудительная выборка&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Корневой контейнер&amp;gt; renderFailure&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Корневой контейнер&amp;gt; renderFetched&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Корневой контейнер&amp;gt; renderLoading&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">См. Также: &lt;a href=&quot;guides-routes&quot;&gt;Маршруты&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ebcb2b8f4a703f0b6653cd4eb5e389d3a9e4f41" translate="yes" xml:space="preserve">
          <source>See our relay-compiler section in our &lt;a href=&quot;installation-and-setup#set-up-relay-compiler&quot;&gt;Installation and Setup guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;Справку по API PropTypes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Справку по API Relay.QL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">См. Справку по &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e868bde5bb210d570e0bf68dfd4f714decc2503" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;fragment-container#passing-arguments-to-a-fragment&quot;&gt;Fragment Container docs&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;guides-mutations&quot;&gt;Руководство&lt;/a&gt; по мутациям .</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;guides-network-layer&quot;&gt;Руководство&lt;/a&gt; по сетевому уровню .</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;guides-root-container&quot;&gt;Руководство&lt;/a&gt; по RootContainer .</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">См. &lt;a href=&quot;guides-routes&quot;&gt;Руководство&lt;/a&gt; по маршрутам .</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">Ошибка сервера</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">Установить бабеля-плагин-реле</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">Установить релейный компилятор</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">Компилятор реле настройки</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">Настройка бабеля-плагина-релиза</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">Показать больше</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">Подобно тому, как метод &lt;code&gt;render&lt;/code&gt; компонента React не изменяет напрямую собственные представления, контейнеры Relay не извлекают данные напрямую. Вместо этого контейнеры объявляют &lt;em&gt;спецификацию&lt;/em&gt; данных, необходимых для рендеринга. Relay гарантирует, что эти данные доступны &lt;em&gt;до&lt;/em&gt; рендеринга.</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">Простой API мутации</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">Поскольку контейнеры Relay определяют фрагменты,а не запросы,их можно легко встраивать в различные контексты.Как и в случае с реактивными компонентами,контейнеры для реле имеют высокую степень пригодности к многократному использованию.</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">Поскольку в одной игре может быть много скрытых мест,нам нужно создать соединение,которое мы сможем использовать для их объединения.</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">Маленький размер пакета</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">До сих пор мы смотрели на более низкие аспекты сбора данных и видели,как различные знакомые понятия транслируются в GraphQL.Далее давайте сделаем шаг назад и рассмотрим некоторые проблемы более высокого уровня,с которыми разработчики продуктов часто сталкиваются при сборе данных:</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">Пока мы просто используем GraphQL как более эффективную версию типичных REST подходов.Обратите внимание на два важных преимущества версии GraphQL:</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">До сих пор мы рассматривали процесс запроса данных и поддержания представлений в актуальном состоянии, но не рассматривали записи. В GraphQL операции записи называются &lt;strong&gt;мутациями&lt;/strong&gt; . Мы можем рассматривать их как запросы с побочными эффектами. Вот пример вызова мутации, которая может пометить данную историю как понравившуюся текущему пользователю:</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">Пока что мы рассмотрели две части,каждая из которых способствует декларированию данных:</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">Так что для нашей &lt;code&gt;introduceShip&lt;/code&gt; мутации, мы создаем два типа: &lt;code&gt;IntroduceShipInput&lt;/code&gt; и &lt;code&gt;IntroduceShipPayload&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">Итак, как нам использовать этот кеш? Рассмотрим две операции: запись в кеш при получении ответа и чтение из кеша, чтобы определить, может ли запрос быть выполнен локально (эквивалент &lt;code&gt;_cache.has(key)&lt;/code&gt; выше, но для графика).</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">Итак,теперь мы знаем ID повстанцев в нашей системе.Теперь мы можем перехватить их:</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">Итак,по первому запросу на корабли,GraphQL сказал нам,что есть следующая страница,но на следующей она сказала нам,что мы дошли до конца соединения.</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">Некоторые поля-особенно для постраничных данных-могут требовать постобработки на клиенте для объединения ранее полученных данных с новой информацией.Relay Modern поддерживает пользовательские обработчики полей,которые могут быть использованы для обработки этих полей для работы с различными шаблонами разбивки по страницам и другими случаями использования.</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">Иногда родителю необходимо переопределить переменные по умолчанию дочернего компонента. Представьте, что мы хотим визуализировать &lt;code&gt;Child&lt;/code&gt; с размером фотографии 128 вместо 64 по умолчанию. Для этого мы должны убедиться, что и фрагмент, &lt;em&gt;и&lt;/em&gt; контейнер знают о пользовательской переменной. Чтобы установить пользовательскую переменную в &lt;em&gt;запросе&lt;/em&gt; , используйте второй аргумент &lt;code&gt;getFragment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">Исходные файлы</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">Укажите зависимости данных `Relay.Container` как фрагменты GraphQL.</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">Укажите поле мутации в `Relay.Mutation`.</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">Укажите запросы `Relay.Route`.</target>
        </trans-unit>
        <trans-unit id="82c2f41708c8462a6d94834b8d39a6c652c2ac2b" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066b54007a4c37add5703334fe870041528f5a58" translate="yes" xml:space="preserve">
          <source>Specifying just the &lt;code&gt;key&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">Начните преобразование компонентов и мутаций для использования современных API-интерфейсов Relay из модуля &amp;laquo; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;code&gt;'react-relay/compat'&lt;/code&gt; ( createFragmentContainer , &lt;code&gt;createRefetchContainer&lt;/code&gt; , &lt;code&gt;createPaginationContainer&lt;/code&gt; , &lt;code&gt;commitMutation&lt;/code&gt; ). Проще будет идти от листовых компонентов вверх. В &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;сценарии преобразования&lt;/a&gt; должны сделать этот шаг менее утомительным.</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">Статические методы</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">Шаг 0:Установить реле v1.0</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">Шаг 1:Инкрементально преобразовать в релейный компат</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">Шаг 2. Представьте &amp;lt;QueryRenderer&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">Шаг 3:Внедрение реле Современное время работы</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">Шаг 4:Очистите,заменив релейный компат на Relay Modern.</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="aec0a8c625d33f2410286cd7972018e4c401dd0d" translate="yes" xml:space="preserve">
          <source>Store Operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">Структура вокруг мутаций,чтобы сделать их предсказуемыми.</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="501433bf93135f5b327aa2f2f9a8b9652febd9e8" translate="yes" xml:space="preserve">
          <source>Support for live queries where supported by the network/server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поддерживается как в режиме совместимости, так и в современном режиме. При использовании контейнера разбивки на страницы Relay ожидает, что поле соединения будет аннотировано директивой &lt;code&gt;@connection&lt;/code&gt; , для получения более подробной информации и примера перейдите в &lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Поддерживается в классическом, совместном и современном режимах. Подробное использование объясняется в &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">Мило! Давайте продолжим и получим следующие четыре!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">Переключите ссылки &amp;laquo; &lt;code&gt;'react-relay/compat'&lt;/code&gt; в вашем приложении на &lt;code&gt;'react-relay'&lt;/code&gt; . Это скорее этап очистки, который не позволяет вашему приложению втягивать ненужный код &lt;code&gt;'react-relay/classic'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c64e9942fb642977fbd70ec197abeadd198f3103" translate="yes" xml:space="preserve">
          <source>Table of Contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">Этот входной аргумент должен содержать (строковое) свойство clientMutationId для согласования запросов и ответов (автоматически добавляется API &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">Это использовало &lt;code&gt;first&lt;/code&gt; аргумент для &lt;code&gt;ships&lt;/code&gt; чтобы разрезать результат до первого. Но что, если бы мы захотели пролистать его по страницам? На каждом краю будет отображаться курсор, который мы можем использовать для разбивки на страницы. Давайте на этот раз запросим первые два и тоже получим курсор:</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">Интерфейс &lt;code&gt;Node&lt;/code&gt; и поле &lt;code&gt;node&lt;/code&gt; предполагают глобально уникальные идентификаторы для этой повторной выборки. Система без глобально уникальных идентификаторов обычно может синтезировать их, комбинируя тип с идентификатором, зависящим от типа, что и было сделано в этом примере.</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">Интерфейс &lt;code&gt;Node&lt;/code&gt; содержит одно поле &lt;code&gt;id&lt;/code&gt; , которое является &lt;code&gt;ID!&lt;/code&gt; . Поле корня &lt;code&gt;node&lt;/code&gt; принимает единственный аргумент - &lt;code&gt;ID!&lt;/code&gt; , и возвращает &lt;code&gt;Node&lt;/code&gt; . Эти два работают вместе, чтобы разрешить повторную выборку; если мы передадим &lt;code&gt;id&lt;/code&gt; возвращенный в этом поле, в поле &lt;code&gt;node&lt;/code&gt; , мы получим объект обратно.</target>
        </trans-unit>
        <trans-unit id="de66ff0a79b624dd454deb3e772e5fb7a040eb35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordProxy&lt;/code&gt; serves as an interface to mutate records:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b179aabf77ea5e811ea7880878bfdfa6368ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; is the type of the &lt;code&gt;store&lt;/code&gt; that &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt; receive as an argument. The following is the &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; interface:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858f5c2de227f30eaba7fc1f9d4f04ab2b8c2484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RelayCompiler&lt;/code&gt; module is a helper class that demonstrates one way of combining these primitives. It takes IR transforms, and given IR definitions, constructs a CompilerContext from them, transforming them, and generating output artifacts intended for use with Relay runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a164901ca79b8b4a2a0866d3bc8b9028a8a90acb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Store&lt;/code&gt; is the source of truth for application data and provides the following core operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">&lt;code&gt;applyUpdate&lt;/code&gt; добавляет мутацию так же , как &lt;code&gt;update&lt;/code&gt; , но это не совершал. Он возвращает &lt;code&gt;RelayMutationTransaction&lt;/code&gt; , который можно зафиксировать или откатить.</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;babel-relay-plugin&lt;/code&gt; должен работать до того , как &lt;code&gt;react-native&lt;/code&gt; Babel предустановку. Таким образом, в &lt;code&gt;.babelrc&lt;/code&gt; &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; react -native&quot; должно идти после &lt;code&gt;babelRelayPlugin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">Метод &lt;code&gt;commitUpdate&lt;/code&gt; аналогичен отправке действия в Flux. Relay обрабатывает мутацию следующим образом:</target>
        </trans-unit>
        <trans-unit id="1e1d2e828d0bd7ad1f6ddc74cb042c491b6885f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;graphql&lt;/code&gt; template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the &lt;a href=&quot;http://graphql.org/learn/&quot;&gt;GraphQL&lt;/a&gt; language. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">Модуль &lt;code&gt;react-relay&lt;/code&gt; npm включает &lt;code&gt;react&lt;/code&gt; как &lt;em&gt;одноранговую зависимость&lt;/em&gt; . Ваше приложение должно явно указать React как зависимость.</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">&lt;code&gt;relay-compiler&lt;/code&gt; скрипт требует как каталога , который содержит исходные файлы, а также путь к вашей схеме GraphQL либо в .json или .graphql файл схемы.</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; обратного вызова вызывается с двумя аргументами: &lt;code&gt;Error&lt;/code&gt; объекта и функции повторить запрос. Если ошибка была результатом ошибки сервера, сообщенной в ответе сервера, полезная нагрузка ответа доступна для проверки на &lt;code&gt;error.source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; обратного вызова всегда вызываются с &lt;code&gt;data&lt;/code&gt; аргументом, который представляет собой отображение объекта из &lt;code&gt;propName&lt;/code&gt; для запроса данных. Ожидается, что &lt;code&gt;renderFetched&lt;/code&gt; вызов renderFetched визуализирует предоставленный &lt;code&gt;Component&lt;/code&gt; с ними (например, с помощью функции &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;атрибутов распространения JSX&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">API в целом более простой и предсказуемый.</target>
        </trans-unit>
        <trans-unit id="8e85966b9eda2ce8d0b649695a0687a896efc918" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createFragmentContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf72a96b855224dd8974796498f53a592b116371" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createPaginationContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4e8ac825308dd36be82a845d481fc8dfdffbd9f" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createRefetchContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">DataID родительского узла,содержащего соединение.Этот аргумент необязателен.</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">Идентификаторы, которые мы получили, были строками в формате base64. Идентификаторы спроектированы так, чтобы быть непрозрачными (единственное, что должно быть передано в аргумент &lt;code&gt;id&lt;/code&gt; на &lt;code&gt;node&lt;/code&gt; - это неизменный результат запроса &lt;code&gt;id&lt;/code&gt; для некоторого объекта в системе), а использование строки base64 является полезным соглашением в GraphQL, чтобы напомнить зрителям, что строка - непрозрачный идентификатор.</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">Реле &quot;Окружающая среда&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">Реле &quot;Среда&quot; объединяет в себе конфигурацию,кэш-память и сетевую обработку,необходимую для работы реле.</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">Реле &amp;laquo;Среда&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">Relay &lt;code&gt;Store&lt;/code&gt; предоставляет API для отправки изменений на сервер.</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Режимы Relay Classic и Relay Compat производят генерируемый контент в строке и могут ловить и регистрировать любые обнаруженные ошибки проверки GraphQL,оставляя эти ошибки брошенными во время выполнения.</target>
        </trans-unit>
        <trans-unit id="77da780670013088b3893d46cce4bc75359e000f" translate="yes" xml:space="preserve">
          <source>The Relay Compiler fully supports client-side schema extensions, which allows you to extend the server schema by defining additional GraphQL types and fields on the client. Relay expects the client schema to be located in your &lt;code&gt;--src&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c019c5395f2cd9ca47232f5e8ed64fa398b7ada0" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which can then be referenced at runtime. By building the query ahead of time, the Relay's runtime is not responsible for generating a query string, and various optimizations can be performed on the query that could be too expensive at runtime (for example, fields that are duplicated in the query can be merged during the build step, to improve efficiency of processing the GraphQL response).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">Relay Compiler отвечает за генерацию кода в рамках этапа сборки,который во время исполнения может использоваться статически.Заранее построив запрос,клиентское время выполнения JS не отвечает за генерацию строки запроса,а поля,дублирующиеся в запросе,могут быть объединены на этапе сборки для повышения эффективности разбора.Если у вас есть возможность сохранять запросы к серверу,то процесс генерации кода компилятора предоставляет удобное время для преобразования запроса или мутации текста в уникальный идентификатор,что значительно сокращает количество загружаемых байт.</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">В Relay Modern Core добавлена поддержка расширения клиентской схемы.Это позволяет удобно хранить некоторую дополнительную информацию с данными,полученными с сервера,и визуализировать ее,как и любое другое поле,полученное с сервера.Это должно быть в состоянии заменить некоторые случаи использования,которые ранее требовали хранилища Flux/Redux на стороне.</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">Пакеты Relay Modern,распространяемые на НПМ,используют широко поддерживаемую ES5 версию JavaScript для поддержки как можно большего количества браузерных сред.</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">Уровень релейной сети</target>
        </trans-unit>
        <trans-unit id="6ac0bfad74e5d02ff492fbabe1206cbc172f8a94" translate="yes" xml:space="preserve">
          <source>The Relay Store can be used to programmatically update client-side data inside &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt;. The following is a reference of the Relay Store interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">Пучок времени работы реле составляет примерно 20% от размера Relay Classic.</target>
        </trans-unit>
        <trans-unit id="d69ab39bff551c52cbb39536496919006e7104d5" translate="yes" xml:space="preserve">
          <source>The Relay runtime is a full-featured GraphQL client that is designed for high performance even on low-end mobile devices and is capable of scaling to large, complex apps. The runtime API is not intended to be used directly in product code, but rather to provide a foundation for building higher-level product APIs such as React/Relay. This foundation includes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">Эстафетный магазин может быть подвергнут программной мутации в сложных случаях,когда оптимистичные обновления требуют более гранулированного управления.Следующие методы API полезны для мутации ваших соединений и фрагментов.</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">Автор этой истории тоже это прокомментировал - довольно часто. Теперь представьте, что какое-то другое представление получает новую информацию об авторе, а его фотография профиля изменилась на новый URI. Вот &lt;em&gt;единственная&lt;/em&gt; часть наших кэшированных данных, которая изменяется:</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">Лучший способ начать прямо сейчас - взглянуть на то, как эти три части объединяются, чтобы сформировать рабочий пример. Учебник на следующей странице проведет вас через пример приложения, использующего &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; , чтобы дать вам представление о том, как вы можете начать использовать Relay на своем.</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">Клиент и сервер разделены: клиент указывает необходимые данные вместо того, чтобы &lt;em&gt;полагаться на&lt;/em&gt; конечную точку сервера для возврата правильных данных.</target>
        </trans-unit>
        <trans-unit id="859e2dd0a260c19654088e28b4f5cf103b3156ab" translate="yes" xml:space="preserve">
          <source>The compiler is a set of modules designed to extract GraphQL documents from across a codebase, transform/optimize them, and generate build artifacts. Examples of common types of artifacts include optimized GraphQL to persist to your server, runtime representations of the queries for use with GraphQL clients such as the Relay runtime, or generated source code for use with GraphQL frameworks for compiled languages (Java/Swift/etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa42964754dbecedd42dff5df9fe665b9c4e7306" translate="yes" xml:space="preserve">
          <source>The compiler module is composed of a set of core building blocks as well as a helper that packages them together in an easy to use API. Some of the main data types and modules in the compiler are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">Компонентный подход React Router v4 не позволяет с легкостью агрегировать требования к данным для вложенных маршрутов и, как таковой, не сразу допускает подход, который позволит избежать водопадов запросов из вложенных компонентов &lt;code&gt;QueryRenderer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">Контейнер с именем &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; для отладки будет получать ответ для каждого фрагмента GraphQL из локального хранилища.</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">Контейнер передает результаты каждого фрагмента (вместе с другими реквизитами) в компонент &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">Реализация по умолчанию выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">Указанные здесь значения по умолчанию станут доступными для наших сборщиков фрагментов:</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">На данный момент проще всего начать с &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - он включает пример файла схемы и настраивает &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; npm babel-relay-plugin для преобразования запросов.</target>
        </trans-unit>
        <trans-unit id="0041bb913fb29f03cef5bab2b320b6add29c71a8" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a built-in handler that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">В приведенном выше примере не настраивался &lt;code&gt;handlerProvider&lt;/code&gt; , что означает, что будет предоставлен параметр по умолчанию. Relay Modern поставляется с парой встроенных обработчиков, которые дополняют ядро ​​специальными функциями для обработки подключений (это не стандартная функция GraphQL, а набор соглашений о разбиении на страницы, используемых в Facebook, подробно &lt;a href=&quot;graphql-connections&quot;&gt;описанных в Спецификации подключений курсора Relay&lt;/a&gt; , и хорошо поддерживается самим Relay) и полем &lt;code&gt;viewer&lt;/code&gt; (опять же, это не стандартная функция схемы GraphQL, а та, которая традиционно широко используется в Facebook).</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">Приведенный выше пример очень похож на классический контейнерный API, но в современном API мы можем просто передать &lt;code&gt;graphql&lt;/code&gt; шаблона graphql непосредственно в качестве второго аргумента. Relay выведет имя &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; из имени фрагмента в соответствии с соглашением об именовании фрагментов &amp;lt;FileName&amp;gt; _ &amp;lt;propName&amp;gt; . Пример ниже эквивалентен приведенному выше:</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">Жировой запрос</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">Имя поля в ответе,содержащее идентификатор данных удаленного узла</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">Имя поля в ответе,содержащее идентификатор данных удаленного узла,или путь к узлу,удаленному из соединения</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">Имя поля в ответе,представляющем соединение.</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">Имя поля в ответе,которое представляет вновь созданный край.</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">Имя поля в ответе,которое представляет родителя соединения</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">Окончательная декларация данных эквивалентна следующему простому GraphQL:</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">Первым запросом был список историй:</target>
        </trans-unit>
        <trans-unit id="097faf4942075ea29d235eddd8bf227710e8b427" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74925f12cc72e89c1f9fb2151f85c26276ebca60" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Promise&lt;/code&gt; that resolves with an object containing data obtained from the query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ecd22bdcea1bdfd0329a697bfab6ff7e6e06a6" translate="yes" xml:space="preserve">
          <source>The high-level flow of data through the compiler is represented in the following diagram:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">Начальный набор значений переменных,доступных для фрагментов этого компонента.</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">Чаще всего используется функция &lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt; которая обертывает компоненты объявлениями данных.</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">Мутация должна принимать единственный аргумент с именем &quot;input&quot;.</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">Новое ядро Relay Modern легче и значительно быстрее,чем предыдущая версия.Оно переработано для работы со статическими запросами,что позволяет увеличить время сборки/компиляции.Современное ядро намного меньше в результате удаления множества сложных функций,необходимых для динамических запросов.Новое ядро также на порядок быстрее обрабатывает ответ с оптимизированным набором команд парсинга,который генерируется во время сборки.Мы больше не занимаемся отслеживанием информации,необходимой для динамической генерации запросов,что значительно снижает нагрузку на память при использовании Relay.Это означает,что остается больше памяти для того,чтобы пользователь чувствовал себя отзывчивым.Relay Modern также поддерживает постоянные запросы,уменьшая размер загружаемого запроса с полного текста запроса до простого идентификатора.</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">Следующий логический подход - использовать &lt;code&gt;render()&lt;/code&gt; в качестве средства инициирования выборки данных. Мы могли бы просто отрендерить приложение один раз, посмотреть, какие данные ему нужны, получить эти данные и отрендерить снова. Звучит здорово, но проблема в том, что &lt;em&gt;компоненты используют данные, чтобы понять, что нужно визуализировать!&lt;/em&gt; Другими словами, это приведет к поэтапной загрузке данных: сначала визуализируйте корень и посмотрите, какие данные ему нужны, затем визуализируйте его дочерние элементы и посмотрите, что им нужно, на всем протяжении дерева. Если на каждом этапе выполняется сетевой запрос, рендеринг потребует медленных последовательных циклов передачи данных. Нам нужен был способ определить все необходимые данные заранее или &lt;em&gt;статически&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">Необязательный параметр &lt;code&gt;config&lt;/code&gt; можно использовать для настройки &lt;code&gt;RANGE_ADD&lt;/code&gt; или другого типа мутации в соответствии с API &lt;code&gt;Relay.Mutation&lt;/code&gt; . Это сообщает Relay, как обрабатывать ответ.</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">Необязательный параметр &lt;code&gt;config&lt;/code&gt; можно использовать для настройки &lt;code&gt;RANGE_ADD&lt;/code&gt; или другого типа мутации, аналогичного API &lt;code&gt;Relay.Mutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">Перечисленные выше варианты не являются исчерпывающими. Если вам известны другие решения маршрутизации, которые хорошо работают с Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;сообщите нам об этом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">Контейнер разбиения на страницы ожидает, что поле подключения будет аннотировано &lt;code&gt;@connection(key: ...)&lt;/code&gt; , где ожидается , что &lt;code&gt;key&lt;/code&gt; будет уникальным идентификатором в родительском поле типа &lt;code&gt;User&lt;/code&gt; . Хорошей практикой может быть &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; . По умолчанию Relay генерирует ключ хранилища на основе введенного пользователем &lt;code&gt;key&lt;/code&gt; и всех переменных поля без фильтрации. Relay также предоставляет расширенную функцию &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; которая позволяет вам явно указать, какие переменные должны использоваться для генерации ключа хранения. В частности, если вы пишете &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; , Реле игнорирует все переменные.</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">Плагин должен понимать вашу схему - &lt;code&gt;schemaData&lt;/code&gt; в приведенном выше фрагменте. В зависимости от реализации GraphQL есть два способа получить эту информацию.</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">Предпосылкой примера является то,что мы хотим использовать GraphQL для запроса информации о кораблях и группировках в оригинальной трилогии &quot;Звездных войн&quot;.</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">Основной способ объявления требований к данным - через &lt;code&gt;Relay.Container&lt;/code&gt; - компонент React более высокого порядка, который позволяет компонентам React кодировать свои требования к данным.</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">Основной способ объявить требования к данным - через &lt;code&gt;createFragmentContainer&lt;/code&gt; - компонент React более высокого порядка, который позволяет компонентам React кодировать свои требования к данным.</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">К свойствам и методам, перечисленным ниже, можно получить доступ в &lt;code&gt;this.props.relay&lt;/code&gt; из обернутого компонента React.</target>
        </trans-unit>
        <trans-unit id="e0742e86024158a29e56877db07e441903db2b90" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;@connection&lt;/code&gt; directive is to allow Relay to uniquely identify different connections under a parent type. The &lt;code&gt;@connection&lt;/code&gt; directive takes 2 arguments that help identify the connection:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c7cfc24fbe1b8654256e17573b27f7600de24e" translate="yes" xml:space="preserve">
          <source>The query and response are traversed together, extracting the results into &lt;code&gt;Record&lt;/code&gt; objects which are added to a fresh &lt;code&gt;RecordSource&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb555f6bd692507da566c1e62919372415cf8fc" translate="yes" xml:space="preserve">
          <source>The query is fetched from the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">Запрос должен содержать запрос &quot;clientMutationId&quot; в виде субвыбора.</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">Причина в том, что если &lt;code&gt;babel-plugin-relay&lt;/code&gt; не запускается до &lt;code&gt;es2015-template-literals&lt;/code&gt; , он не будет правильно преобразовывать литералы шаблона Relay.QL. Также в Babel 6 вы не можете контролировать порядок плагинов. Таким образом, в React Native, где плагины в &lt;code&gt;.babelrc&lt;/code&gt; загружаются перед проектами &lt;code&gt;.babelrc&lt;/code&gt; , невозможно использовать плагин Babel Relay, не перекрывая весь список преобразований.</target>
        </trans-unit>
        <trans-unit id="e29f8bf44ff95dd21005f2f7bb6eccf4ec45e350" translate="yes" xml:space="preserve">
          <source>The result of using the &lt;code&gt;graphql&lt;/code&gt; template tag is a &lt;code&gt;GraphQLTaggedNode&lt;/code&gt;; a runtime representation of the GraphQL document which can be used to define &lt;a href=&quot;query-renderer&quot;&gt;Query Renderers&lt;/a&gt;, &lt;a href=&quot;fragment-container&quot;&gt;Fragment Containers&lt;/a&gt;, &lt;a href=&quot;refetch-container&quot;&gt;Refetch Containers&lt;/a&gt;, &lt;a href=&quot;pagination-container&quot;&gt;Pagination Containers&lt;/a&gt;, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">Во время выполнения автоматически удаляются кэшированные данные,на которые больше нет ссылок,что помогает уменьшить использование памяти.</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Схема, описанная ниже, будет использоваться для демонстрации функциональности, которую должен реализовать сервер GraphQL, используемый Relay. Два основных типа - это фракция и корабль во вселенной &amp;laquo;Звездных войн&amp;raquo;, где с фракцией связано множество кораблей. Схема ниже является результатом работы SchemaPrinter &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">Во втором запросе была запрошена информация для одной из этих историй:</target>
        </trans-unit>
        <trans-unit id="c7be7ec56f48de687831bf1d2b8ec095a4494b09" translate="yes" xml:space="preserve">
          <source>The set of IR documents forms a CompilerContext, which is then transformed and optimized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">Решение кеширования GraphQL состоит в том, чтобы преобразовать иерархический ответ в плоский набор &lt;strong&gt;записей&lt;/strong&gt; . Relay реализует этот кеш как карту от идентификаторов к записям. Каждая запись представляет собой карту от имен полей до значений полей. Записи могут также связываться с другими записями (что позволяет описывать циклический граф), и эти ссылки сохраняются как особый тип значения, который ссылается обратно на карту верхнего уровня. При таком подходе каждая запись сервера сохраняется &lt;em&gt;один раз,&lt;/em&gt; независимо от способа ее получения.</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">Термин &amp;laquo;переменные&amp;raquo; здесь относится к входным данным мутации на стороне сервера, а &lt;strong&gt;не&lt;/strong&gt; к переменным, доступным для построителей фрагментов этой мутации.</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">Три основных предположения,которые Relay делает о GraphQL сервере,это то,что он предоставляет:</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">Эти два метода отличаются тем, что вместо отправки запроса, который включает только поля, отсутствующие у клиента, &lt;code&gt;forceFetch&lt;/code&gt; отправляет запрос на повторную выборку каждого фрагмента. Это гарантирует, что реквизиты для компонента только что получены с сервера.</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">Изменилось значение поля &lt;code&gt;photo&lt;/code&gt; ; и поэтому запись &lt;code&gt;2&lt;/code&gt; тоже изменилась. И это все. Больше ничего в &lt;em&gt;кеше&lt;/em&gt; не затрагивается. Но ясно, что наше &lt;em&gt;представление&lt;/em&gt; должно отражать обновление: оба экземпляра автора в пользовательском интерфейсе (как автор истории и автор комментария) должны отображать новую фотографию.</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">Затем, после внесения изменений в файлы приложения, просто запустите &lt;code&gt;yarn run relay&lt;/code&gt; , чтобы сгенерировать новые файлы, или &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; чтобы запустить компилятор как долгоживущий процесс, который автоматически генерирует новые файлы при каждом сохранении.</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">Затем после внесения изменений в файлы приложения запустите &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; для создания новых файлов или &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; чтобы компилятор запускался как долгоживущий процесс, который автоматически генерирует новые файлы при каждом сохранении.</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">Затем запустите &lt;code&gt;yarn run relay&lt;/code&gt; хода пряжи, как было настроено ранее.</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">Затем добавьте &lt;code&gt;&quot;relay&quot;&lt;/code&gt; в список плагинов в вашем файле .babelrc. Например:</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">Существует множество решений для обновления представлений с помощью уплощенного кеша. Подход, который использует Relay, заключается в поддержании сопоставления каждого представления пользовательского интерфейса с набором идентификаторов, на которые он ссылается. В этом случае представление истории будет подписываться на обновления истории ( &lt;code&gt;1&lt;/code&gt; ), автора ( &lt;code&gt;2&lt;/code&gt; ) и комментариев ( &lt;code&gt;3&lt;/code&gt; и любых других). При записи данных в кэш Relay отслеживает, какие идентификаторы затронуты, и уведомляет &lt;em&gt;только&lt;/em&gt; те представления, которые подписаны на эти идентификаторы. Затронутые представления повторно отрисовываются, а незатронутые представления отказываются от повторного отрисовки для повышения производительности (Relay предоставляет безопасное, но эффективное значение по умолчанию &lt;code&gt;shouldComponentUpdate&lt;/code&gt; ). Без этой стратегии каждое представление было бы повторно отрисовано даже при малейшем изменении.</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">В настоящее время поддерживается только один способ динамической установки начального значения переменной: использование глобальных переменных, определенных в запросе, который включает фрагмент (или через &lt;code&gt;variables&lt;/code&gt; в &lt;code&gt;QueryRenderer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d42709663369aca59bb9f2ca4e4c05e806c0bb6" translate="yes" xml:space="preserve">
          <source>Therefore a typical data flow is as follows - note that this flow is managed automatically by higher-level APIs such as React/Relay. First a component will lookup the results of a selector against a record source (e.g. the store's canonical source):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">Следовательно, нормализованный кеш ответов для GraphQL требует параллельной обработки полезных данных и запросов. Например, поле &lt;code&gt;photo&lt;/code&gt; сверху может быть кэшировано с сгенерированным именем поля, таким как &lt;code&gt;photo_size(32)&lt;/code&gt; , чтобы однозначно идентифицировать поле и его значения аргументов.</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">Это методы и свойства, которые контейнер предоставит как &lt;code&gt;this.props.relay&lt;/code&gt; в простом компоненте React.</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">Эти функции можно использовать в паре распространенных сценариев:протоколирование состояния клиента для последующего просмотра или интерактивная прогулка по магазину из отладчика вашего браузера.</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">Мыслить в эфире</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">Мышление в GraphQL</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">Этот реквизит обратного вызова называется так как происходят различные события разрешения данных.</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">Этот реквизит обратного вызова называется так как происходят различные события разрешения данных.</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">Это можно &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; условно отрисовав QueryRenderer, который загрузит данные после их визуализации. Накладные расходы на код, связанные с этим, резко сокращаются с новым API.</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">Его можно обновить с помощью &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; ,&lt;/a&gt; который позволяет указать точный запрос, который будет использоваться для получения новых данных.</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">Это приводит к тому, что сгенерированный файл появляется в &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; как с артефактами времени выполнения (которые помогают читать и писать из хранилища ретрансляторов), так и с &lt;a href=&quot;https://flow.org/&quot;&gt;типами потока,&lt;/a&gt; чтобы помочь вам писать безопасный по типу код.</target>
        </trans-unit>
        <trans-unit id="a9ea7bef6484a7c1cbe254ffda535079f7700daf" translate="yes" xml:space="preserve">
          <source>This document, together with &lt;a href=&quot;runtime-architecture&quot;&gt;Runtime Architecture&lt;/a&gt; and &lt;a href=&quot;compiler-architecture&quot;&gt;Compiler Architecture&lt;/a&gt;, describes the high-level architecture of Relay &quot;Modern&quot;. The intended audience includes developers interested in contributing to Relay, developers hoping to utilize the building blocks of Relay to create higher-level APIs, and anyone interested in understanding more about Relay internals. For developers wanting to learn more about &lt;em&gt;using&lt;/em&gt; Relay to build products, the other sections might be more helpful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">Этот пример демонстрирует все три из этих предположений.</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">Этот пример не является исчерпывающим,но он предназначен для быстрого введения этих основных предположений,чтобы предоставить некоторый контекст перед тем,как погрузиться в более подробную спецификацию библиотеки.</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">Этот толстый запрос похож на любой другой запрос GraphQL с одним важным отличием. Мы знаем, что некоторые из этих полей не являются скалярными (например, &lt;code&gt;friendEdge&lt;/code&gt; и &lt;code&gt;friends&lt;/code&gt; ), но заметим, что мы не назвали ни одного из их дочерних полей с помощью подзапроса. Таким образом, мы указываем Relay, что &lt;em&gt;все&lt;/em&gt; , &lt;em&gt;что&lt;/em&gt; находится в этих нескалярных полях, может измениться в результате этой мутации.</target>
        </trans-unit>
        <trans-unit id="81b1261e20f66bafeb445251ddc3d3efb2158432" translate="yes" xml:space="preserve">
          <source>This fresh &lt;code&gt;RecordSource&lt;/code&gt; would then be published to the store:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">Это преобразуется в &quot;ленивое&quot; требование к сгенерированному файлу:</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">Это преобразуется в функцию немедленного вызова:</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">Это устанавливает &lt;code&gt;relay-compiler&lt;/code&gt; сценария bin в вашу папку node_modules. Рекомендуется запускать это из сценария yarn / npm, добавив сценарий в файл &lt;code&gt;package.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Это специализация универсального контейнера для повторной выборки, который адаптирован для обычного сценария разбивки на страницы по коллекции элементов путем последовательного извлечения большего количества страниц данных. Подробнее см. &lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">Это массив событий, полученных на данный момент (см. &lt;code&gt;ReadyStateEvent&lt;/code&gt; ниже).</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Это экземпляр &lt;code&gt;Error&lt;/code&gt; случае сбоя. В противном случае это &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">Это всего лишь простой пример:в реальности кэш должен обрабатывать от одного до многих ассоциаций и пагинации (среди прочего).</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">Это общий конструктор для создания экземпляров &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; с дополнительными &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;callbacks&lt;/code&gt; и аргументами &lt;code&gt;collisionKey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">Это самый низкий уровень абстракции, на котором код продукта может иметь дело с мутациями в Relay, и он соответствует операции мутации (&amp;laquo;запись с последующей &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;выборкой&lt;/a&gt; &amp;raquo;), описанной в Спецификации GraphQL . Вы указываете мутацию, входные данные и запрос.</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">Это верно, когда &lt;em&gt;все&lt;/em&gt; требования к данным готовы для рендеринга.</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">Это верно,когда подмножество данных,необходимых для рендеринга,готово.</target>
        </trans-unit>
        <trans-unit id="12c08d7a8f7eb77071004758dca7ab969bb7d7cb" translate="yes" xml:space="preserve">
          <source>This is where GraphQL comes into play. Components specify one or multiple GraphQL fragments for some of their props describing their data requirements. Each GraphQL fragment has a unique name within an application which allows us to determine the query needed to fetch the full query tree in a build step and load all the required data in a single network request efficiently at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">Это может быть полезно для сокращения избыточных фрагментов при работе с вложенными или рекурсивными данными в рамках одного Компонента.</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">Этот метод может опционально возвращать обещание,чтобы облегчить правильное распространение ошибок.</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">Этот метод также вызывается после применения частичного набора переменных из &lt;code&gt;setVariables&lt;/code&gt; . Возвращенные переменные используются для заполнения фрагментов.</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">Этот метод получает массив запросов (а не один запрос)для облегчения пакетной обработки запросов с целью повышения эффективности сети.</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Его следует обновить, чтобы использовать &lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">Этот фрагмент настраивает &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; для визуализации &lt;code&gt;ProfilePicture&lt;/code&gt; в компоненте &lt;code&gt;ScrollView&lt;/code&gt; , как только данные будут готовы.</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">Этот фрагмент настраивает &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; для отображения текста &amp;laquo;Загрузка ...&amp;raquo; всякий раз, когда ему необходимо получить данные.</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">Это создаст серию каталогов &lt;code&gt;__generated__&lt;/code&gt; , которые будут совмещены с соответствующими файлами, содержащими теги &lt;code&gt;graphql&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">Это проинформирует &lt;code&gt;Relay.QL&lt;/code&gt; , что это конкретное поле является массивом. Это также позволит вам использовать имя во множественном числе для фрагмента (например, &lt;code&gt;bars&lt;/code&gt; вместо &lt;code&gt;bar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">Это создаст три сгенерированных файла и два &lt;code&gt;__generated__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">Для добавления нового контейнера пагинального реле</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">Чтобы добавить новый контейнер реле</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">Для добавления нового контейнера реле,который имеет изменяющиеся требования к данным.</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">Чтобы добавить новый корень для компонентов реле</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">Чтобы вызвать этот метод для базового компонента, сначала предоставьте функцию &lt;code&gt;componentRef&lt;/code&gt; для контейнера Relay. Это отличается от предоставления функции &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; ,&lt;/a&gt; которая будет предоставлять ссылку на сам контейнер Relay, а не на базовый компонент React.</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">Чтобы совершить мутацию</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">Чтобы создать экземпляр среды в Relay Modern, используйте класс &lt;code&gt;RelayModernEnvironment&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">Чтобы включить &lt;a href=&quot;relay-compat&quot;&gt;режим совместимости&lt;/a&gt; , &lt;code&gt;relay-compiler&lt;/code&gt; применяет простое соглашение об именах для ваших запросов. Запросы должны иметь имя &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; , где &amp;laquo;&amp;lt;OperationType&amp;gt;&amp;raquo; - одно из &amp;laquo;Query&amp;raquo;, &amp;laquo;Mutation&amp;raquo; или &amp;laquo;Subscription&amp;raquo;. Вышеупомянутый запрос называется &lt;code&gt;ExampleQuery&lt;/code&gt; , поэтому его следует поместить в &lt;code&gt;Example.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">Для выполнения этого кода Relay необходим доступ к схеме, которая может быть слишком большой для объединения в приложение. Вместо этого эти &lt;code&gt;Relay.QL&lt;/code&gt; шаблона Relay.QL транслируются в описания JavaScript через &lt;code&gt;babel-relay-plugin&lt;/code&gt; . Эта информация о схеме позволяет Relay понимать такие вещи, как типы аргументов полей, какие поля являются соединениями или списками, и как эффективно получать записи с сервера.</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">Для того,чтобы вынудить забрать компонент</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">Чтобы начать строить релейные приложения,вам понадобятся три вещи:</target>
        </trans-unit>
        <trans-unit id="45fa77bbc0446347a81f6d5b23fa090e9c9d6856" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. The simplest way to do this is by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">Чтобы улучшить воспринимаемую отзывчивость, вы можете захотеть выполнить &amp;laquo;оптимистическое обновление&amp;raquo;, при котором клиент немедленно обновляется, чтобы отразить ожидаемое новое значение, даже до того, как ответ от сервера вернется. Мы делаем это, предоставляя &lt;code&gt;optimisticResponse&lt;/code&gt; и добавляя его в &lt;code&gt;config&lt;/code&gt; которую мы передаем в &lt;code&gt;commitMutation&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">Для пагинации через соединение</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">Чтобы читать из кеша, мы можем выполнить запрос и разрешить каждое поле. Но подождите: это звучит &lt;em&gt;точно&lt;/em&gt; так &lt;em&gt;же,&lt;/em&gt; как сервер GraphQL, когда обрабатывает запрос. И это! Чтение из кеша - это особый случай исполнителя, где а) нет необходимости в определяемых пользователем полевых функциях, потому что все результаты поступают из фиксированной структуры данных и б) результаты всегда синхронны - данные либо кешируются, либо нет. т.</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">Для начала давайте &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; простую версию React- компонента &amp;lt;ProfilePicture&amp;gt;, которая отображает фотографию профиля пользователя и ползунок для регулировки размера фотографии.</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">Для начала давайте &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; простую версию React компонента &amp;lt;TodoItem&amp;gt;, которая отображает текст и статус завершения &lt;code&gt;Todo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ac483e211ecf7cd1ac9ea59c0478cde75088452" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a hypothetical &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">Чтобы обновить переменную для моего компонента</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">Для использования Relay Compiler вам понадобится файл схемы GraphQL .graphql или .json, описывающий API вашего сервера GraphQL. Обычно эти файлы являются локальными представлениями серверного источника истины и не редактируются напрямую. Например, у нас может быть &lt;code&gt;schema.graphql&lt;/code&gt; вроде:</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">Чтобы использовать эти части для создания полноценного запроса GraphQL, который мы можем отправить на сервер для получения данных, нам нужно использовать &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0cef4df4d340703594fc301669e90430e959441b" translate="yes" xml:space="preserve">
          <source>Transforms</source>
          <target state="translated">Transforms</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="7634bede4230d278e0e78179b1dcae8473d4d33a" translate="yes" xml:space="preserve">
          <source>Types for working with queries and their results include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">Типичный классический код реле:</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">Типичный старый код:</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">Обычно вам не нужно импортировать созданные вами определения. &lt;a href=&quot;babel-plugin-relay&quot;&gt;Плагин Relay Бабель&lt;/a&gt; преобразует &lt;code&gt;graphql&lt;/code&gt; литералы &lt;code&gt;require()&lt;/code&gt; сгенерированные файлы.</target>
        </trans-unit>
        <trans-unit id="fe82c32a588b217dd555d86acd7cd881dee1801f" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">Под капотом сетевой уровень по умолчанию использует &lt;code&gt;fetch&lt;/code&gt; ( &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt; ). Конструктор &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; принимает необязательный второй аргумент, который принимает любое допустимое свойство инициализации, которое принимает &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">В отличие от запросов,неудачные запросы на мутации автоматически не перепроверяются.</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">До этого момента мы взаимодействовали только с конечной точкой GraphQL для выполнения запросов, извлекающих данные. В этом руководстве вы узнаете, как использовать Relay для выполнения мутаций - операций, которые состоят из записи в хранилище данных с последующей выборкой любых измененных полей.</target>
        </trans-unit>
        <trans-unit id="706a52f4ea94115123954122a8c78690d8a63036" translate="yes" xml:space="preserve">
          <source>Updater Configs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">Обновляет записи,связанные с мутирующей записью,передавая источник по имени поля и объект,представляющий значения предопределенных аргументов.</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">Обновляет значение атрибута мутируемой записи,заданного именем поля и объекта,представляющего значения предопределенных аргументов.</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">Обновление клиента по каждому ответу</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">Обновление клиента оптимистично</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">Обновление локального кэша после получения ответов на запросы/мутации.</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">Обновление магазина программно (продвинутое)</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">Обновление до версии 1.0.0.</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">Переменные</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="64cfd0b3a8ed6125a106524eb46cf6330e091d8e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitLocalUpdate&lt;/code&gt; when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations). The function takes in a Relay &lt;code&gt;environment&lt;/code&gt; and an &lt;code&gt;updater&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9443a1d180d1993141d5ed99d3c993a96f971b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitMutation&lt;/code&gt; to create and execute mutations. &lt;code&gt;commitMutation&lt;/code&gt; has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">Используйте &lt;code&gt;introspectionQuery&lt;/code&gt; , чтобы сгенерировать схему JSON для плагина Babel Relay, и используйте &lt;code&gt;printSchema&lt;/code&gt; для создания сокращенной системы типов, читаемых пользователем:</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">Использование &lt;code&gt;graphql&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">Использование других графических реализаций</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">Использование кэша</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">Использование при конвертации в &quot; &lt;a href=&quot;relay-compat&quot;&gt;режиме совместимости&lt;/a&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="410e9ae9e9ce0fe0fb15689548590810d66caa99" translate="yes" xml:space="preserve">
          <source>Using updater and optimisticUpdater</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">Использование с Relay Classic</target>
        </trans-unit>
        <trans-unit id="9ea691c61eebccf391fb8820180c4ca2beda5321" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are just standard React components. Here's the &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Композиция представления - это &lt;em&gt;именно&lt;/em&gt; то &lt;em&gt;, к&lt;/em&gt; чему вы привыкли - контейнеры Relay являются стандартными компонентами React. Вот компонент &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">Композиция представления - это &lt;em&gt;именно&lt;/em&gt; то &lt;em&gt;, к&lt;/em&gt; чему вы привыкли - контейнеры Relay являются стандартными компонентами React. Вот компонент &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">Разогреться</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">Мы создали несколько скриптов, которые помогут вам в процессе конвертации. Ознакомьтесь с ними на &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">Мы можем изменить это поведение, предоставив опору &lt;code&gt;renderLoading&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99418ef7bda442472813dd7c77c28063f221dc1b" translate="yes" xml:space="preserve">
          <source>We can create a &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; and define a new type called &lt;code&gt;Setting&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09384c922b7bcbae85b63823d4facb25583f0ebf" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a &lt;code&gt;configs&lt;/code&gt; array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following config types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">Мы можем дать инструкции Relay в виде конфигурационного массива о том,как использовать ответ от каждой мутации для обновления клиентского хранилища.Мы делаем это,настраивая мутацию с одним или несколькими из следующих типов мутаций:</target>
        </trans-unit>
        <trans-unit id="8b225a6bc0d167f8b54e806d442a842dc3c15baa" translate="yes" xml:space="preserve">
          <source>We can then extend existing server types in the client schema &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; with our new &lt;code&gt;Setting&lt;/code&gt; type, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">Здесь мы,как и в контейнере,декларируем зависимости данных наших мутаций.Это особенно полезно для того,чтобы убедиться,что набор полей,которые мы,возможно,захотим использовать в оптимистическом ответе на эту мутацию,был получен.</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">Нам нужно место,где можно спрятать сокровище,способ проверки мест,где можно спрятать сокровище,и способ отслеживания оставшихся поворотов.Для целей этого учебника мы спрячем эти данные в памяти.</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">Для обновления магазина на стороне клиента необходимо предоставить ретранслятору инструкции по использованию полезной нагрузки отклика от каждой мутации.Для этого мы настраиваем мутацию с одним или несколькими из следующих типов мутаций:</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">В конечном итоге мы остановились на статических методах; Компоненты фактически возвращали бы дерево запросов, отдельное от дерева представления, описывающее их зависимости данных. Затем Relay может использовать это дерево запросов для получения всей информации, необходимой на одном этапе, и использовать ее для визуализации компонентов. Проблема заключалась в поиске подходящего механизма для описания дерева запросов и способа его эффективного получения с сервера (то есть в одном сетевом запросе). Это идеальный вариант использования GraphQL, поскольку он обеспечивает синтаксис для &lt;em&gt;описания зависимостей данных как данных&lt;/em&gt; , без указания какого-либо конкретного API. Обратите внимание, что Promises и Observables часто предлагаются в качестве альтернативы, но они представляют &lt;em&gt;непрозрачные команды&lt;/em&gt; и исключают различные оптимизации, такие как пакетирование запросов.</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">Теперь мы увидим разные &lt;code&gt;likeCount&lt;/code&gt; в зависимости от способа доступа к истории. Представление, использующее первый запрос, увидит устаревшее количество, а представление, использующее второй запрос, увидит обновленное количество.</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">Мы почти готовы позволить Relay выполнить требования к данным для этих компонентов и отобразить их. Однако есть одна проблема. Чтобы действительно получать данные с помощью GraphQL, нам нужен корень запроса. Например, нам нужно заземлить фрагмент &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; в конкретный узел типа &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">Мы обнаружили, что схема GraphQL обычно немного или даже существенно отличается от формы, в которой данные хранятся на диске. Проще говоря: не всегда существует соответствие 1: 1 между изменениями данных в вашем базовом &lt;em&gt;хранилище данных&lt;/em&gt; (на диске) и изменениями данных в вашей &lt;em&gt;видимой&lt;/em&gt; для &lt;em&gt;продукта схеме&lt;/em&gt; (GraphQL). Прекрасным примером этого является конфиденциальность: для возврата поля, ориентированного на пользователя, такого как &lt;code&gt;age&lt;/code&gt; может потребоваться доступ к многочисленным записям на нашем уровне хранения данных, чтобы определить, может ли активный пользователь вообще &lt;em&gt;видеть&lt;/em&gt; этот &lt;code&gt;age&lt;/code&gt; (мы друзья? Мой возраст общий ? Я вас заблокировал? И т. Д.).</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">Мы обнаружили, что типичные подходы к извлечению данных - с обязательными API-интерфейсами - вынуждают разработчиков слишком много справляться с этой несущественной сложностью. Например, рассмотрите &lt;em&gt;оптимистичные обновления пользовательского интерфейса&lt;/em&gt; . Это способ обратной связи с пользователем во время ожидания ответа сервера. Логика того, &lt;em&gt;что&lt;/em&gt; делать, может быть довольно ясной: когда пользователь нажимает &amp;laquo;лайк&amp;raquo;, отметьте историю как понравившуюся и отправьте запрос на сервер. Но реализация часто бывает намного сложнее. Императивные подходы требуют, чтобы мы реализовали все эти шаги: войти в пользовательский интерфейс и переключить кнопку, инициировать сетевой запрос, повторить его, если необходимо, показать ошибку, если она не удалась (и отключить кнопку) и т. Д. То же самое касается данных -fetching: часто указывается, &lt;em&gt;какие&lt;/em&gt; данные нам нужны&lt;em&gt;как&lt;/em&gt; и &lt;em&gt;когда&lt;/em&gt; его доставят. Далее мы рассмотрим наш подход к решению этих проблем с помощью &lt;strong&gt;Relay&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">Мы видели, что контейнеры Relay обеспечивают выборку фрагментов GraphQL &lt;em&gt;до&lt;/em&gt; того, как компонент будет отрисован. Но контейнеры также предоставляют еще одно преимущество, которое не сразу очевидно: &lt;strong&gt;маскирование данных&lt;/strong&gt; . Relay позволяет компонентам получать доступ к данным, которые они специально запрашивают, &lt;code&gt;fragments&lt;/code&gt; - не более того. Таким образом, если один компонент запрашивает &lt;code&gt;text&lt;/code&gt; Истории , а другой - его &lt;code&gt;author&lt;/code&gt; , каждый может видеть &lt;em&gt;только&lt;/em&gt; то поле, которое они запросили. Фактически, компоненты даже не могут видеть данные, запрошенные их &lt;em&gt;дочерними&lt;/em&gt; элементами : это также нарушит инкапсуляцию.</target>
        </trans-unit>
        <trans-unit id="e1d701dcb15b88a66be26dfbe21cdfc47c48bde8" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in GraphQL fragments &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">То,что мы здесь написали,это имитационный интерфейс базы данных.Мы можем представить,что подключим его к реальной базе данных,но пока давайте двигаться дальше.</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">Что с чем работает? Relay Compat ( &lt;code&gt;'react-relay/compat'&lt;/code&gt; ) является наиболее гибким. Компоненты совместимости и мутации могут использоваться всем. Компоненты Compat также могут иметь дочерние элементы любого типа.</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">При &amp;laquo;принудительной выборке&amp;raquo; это истинно, если &lt;code&gt;ready&lt;/code&gt; истинно в результате того, что данные были доступны на клиенте до завершения запроса сервера.</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">Когда &lt;code&gt;forceFetch&lt;/code&gt; имеет значение true и &lt;code&gt;renderFetched&lt;/code&gt; вызывается в результате доступных клиентских данных, &lt;code&gt;renderFetched&lt;/code&gt; вызывается со вторым аргументом, имеющим &lt;code&gt;stale&lt;/code&gt; логическое свойство. Свойство &lt;code&gt;stale&lt;/code&gt; имеет значение true, если &lt;code&gt;renderFetched&lt;/code&gt; вызывается до завершения принудительного запроса сервера.</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">Когда &lt;code&gt;forceFetch&lt;/code&gt; истинно, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; всегда будет отправлять запрос на сервер. Однако, если все данные, необходимые для рендеринга, также доступны на клиенте, &lt;code&gt;renderFetched&lt;/code&gt; все равно может быть вызван до завершения запроса сервера.</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">Когда Relay &lt;code&gt;onReadyStateChange&lt;/code&gt; данные, обратный вызов onReadyStateChange вызывается один или несколько раз с объектом, который описывает текущее &amp;laquo;состояние готовности&amp;raquo;. Этот объект имеет следующие свойства:</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">Когда все данные, необходимые для рендеринга, становятся доступными, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; по умолчанию рендерит предоставленный &lt;code&gt;Component&lt;/code&gt; . Однако мы можем изменить это поведение, предоставив обратный вызов &lt;code&gt;renderFetched&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">Когда все требования к данным выполнены, &lt;code&gt;renderFetched&lt;/code&gt; для визуализации представления. Ожидается, что этот обратный вызов распространит &lt;code&gt;data&lt;/code&gt; в предоставленный &lt;code&gt;Container&lt;/code&gt; при его рендеринге.</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">При компиляции кода для производственного развертывания плагин можно настроить так,чтобы он сразу же бросался при возникновении проблемы с проверкой.Плагин может быть дополнительно настроен для различных сред со следующими опциями:</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">Когда не удалось выполнить требования к данным, &lt;code&gt;renderFailure&lt;/code&gt; для визуализации представления.</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">Когда требования к данным еще не выполнены, для &lt;code&gt;renderLoading&lt;/code&gt; представления вызывается renderLoading . Если это возвращает &lt;code&gt;undefined&lt;/code&gt; , визуализируется ранее визуализированное представление (или ничего, если предыдущее представление не было).</target>
        </trans-unit>
        <trans-unit id="9fd4594d265309e3ea2f8851c4e096213978657c" translate="yes" xml:space="preserve">
          <source>When defining a fragment for use with a Fragment container, you can use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive to indicate that container expects the prop for that fragment to be a list of items instead of a single item. A query or parent that spreads a &lt;code&gt;@relay(plural: true)&lt;/code&gt; fragment should do so within a plural field (ie a field backed by a &lt;a href=&quot;http://graphql.org/learn/schema/#lists-and-non-null&quot;&gt;GraphQL list&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619aba17233daa1e1d7ee5e3869b79e1331126b3" translate="yes" xml:space="preserve">
          <source>When defining a fragment, you can use the &lt;a href=&quot;graphql-in-relay#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt; directive to specify any arguments, with potentially default values, that the fragment expects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">При разработке толстого запроса учитывайте &lt;em&gt;все&lt;/em&gt; данные, которые могут измениться в результате мутации, а не только данные, которые в настоящее время используются вашим приложением. Нам не нужно беспокоиться о чрезмерной выборке; этот запрос никогда не выполняется без пересечения его с &amp;laquo;отслеживаемым запросом&amp;raquo; данных, которые действительно нужны нашему приложению. Если мы опустим поля в толстом запросе, мы можем наблюдать несогласованность данных в будущем, когда мы добавим представления с новыми зависимостями данных или добавим новые зависимости данных к существующим представлениям.</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">При постепенном преобразовании приложения Relay Classic в Relay Modern литералы &lt;code&gt;graphql&lt;/code&gt; могут быть преобразованы для использования в &lt;em&gt;обеих&lt;/em&gt; средах выполнения, если они настроены на использование режима совместимости:</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">Когда он посылает запросы,он автоматически завершает работу по истечении 15-секундного таймаута.Кроме того,неудачные запросы автоматически перепроверяются дважды,с задержкой в 1 секунду и 3 секунды соответственно.</target>
        </trans-unit>
        <trans-unit id="c328250268c48757d266a5578f320e2cd118ae4e" translate="yes" xml:space="preserve">
          <source>When not nesting routes with Relay data dependencies, such as when using flat routes, it is sufficient to just render a &lt;code&gt;QueryRenderer&lt;/code&gt; for the parts of your application that require Relay data. You can also use the options below that integrate your routes with their data dependencies.</source>
          <target state="translated">Если нет вложения маршрутов с зависимостями данных Relay, например при использовании плоских маршрутов, достаточно просто отобразить &lt;code&gt;QueryRenderer&lt;/code&gt; для частей вашего приложения, которым требуются данные Relay. Вы также можете использовать приведенные ниже параметры, которые интегрируют ваши маршруты с их зависимостями данных.</target>
        </trans-unit>
        <trans-unit id="c958feb46013f0ddcda8fd3772356651d46f8e8a" translate="yes" xml:space="preserve">
          <source>When problems arise developers would need an insight into Relay's store. Relay provides a couple of tools to inspect the store and its records programmatically and visually.</source>
          <target state="translated">При возникновении проблем разработчикам необходимо будет ознакомиться с магазином ретрансляторов.Relay предоставляет пару инструментов для проверки магазина и его записей программно и визуально.</target>
        </trans-unit>
        <trans-unit id="5d9ce00224dd61a4d32a2854970285a45cfbec29" translate="yes" xml:space="preserve">
          <source>When the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; above is rendered, Relay will construct a query and send it to the GraphQL server. As soon as all required data has been fetched, &lt;code&gt;ProfilePicture&lt;/code&gt; will be rendered. Props with fragments will contain data that was fetched from the server.</source>
          <target state="translated">Когда &lt;strong&gt;Relay.RootContainer отображается&lt;/strong&gt; выше, Relay &lt;strong&gt;сформирует&lt;/strong&gt; запрос и отправит его на сервер GraphQL. Как только будут получены все необходимые данные, &lt;code&gt;ProfilePicture&lt;/code&gt; . Реквизит с фрагментами будет содержать данные, полученные с сервера.</target>
        </trans-unit>
        <trans-unit id="c67a5c120de0df00997c004e146051bbad946df1" translate="yes" xml:space="preserve">
          <source>When the server response is received, one of the callbacks is invoked:</source>
          <target state="translated">При получении ответа сервера вызывается один из обратных вызовов:</target>
        </trans-unit>
        <trans-unit id="cea8475e3aa555845df5b9bb69835f08e0fe8ca8" translate="yes" xml:space="preserve">
          <source>When the transaction is committed and the response is received from the server, one of the callbacks is invoked: - &lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded. - &lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">Когда транзакция зафиксирована и от сервера получен ответ, вызывается один из обратных вызовов: - &lt;code&gt;onSuccess&lt;/code&gt; вызывается, если мутация прошла успешно. - &lt;code&gt;onFailure&lt;/code&gt; вызывается, если мутация не удалась.</target>
        </trans-unit>
        <trans-unit id="15eef2fb6be75cc68d0e3ddb99ea3d827fbcd3d5" translate="yes" xml:space="preserve">
          <source>When this response is normalized, Relay can detect that this result overlaps with existing data based on its &lt;code&gt;id&lt;/code&gt;. Rather than create a new record, Relay will update the existing &lt;code&gt;123&lt;/code&gt; record. The new &lt;code&gt;likeCount&lt;/code&gt; is therefore available to &lt;em&gt;both&lt;/em&gt; queries, as well as any other query that might reference this story.</source>
          <target state="translated">Когда этот ответ нормализован, Relay может определить, что этот результат перекрывается с существующими данными на основе его &lt;code&gt;id&lt;/code&gt; . Вместо того, чтобы создавать новую запись, Relay обновит существующую запись &lt;code&gt;123&lt;/code&gt; . Таким образом, новый &lt;code&gt;likeCount&lt;/code&gt; доступен для &lt;em&gt;обоих&lt;/em&gt; запросов, а также для любого другого запроса, который может ссылаться на эту историю.</target>
        </trans-unit>
        <trans-unit id="30790e3c432f6503a40e8e00ea839d4b3685867b" translate="yes" xml:space="preserve">
          <source>When upgrading an existing Relay app, replace all &lt;code&gt;require('react-relay')&lt;/code&gt; with &lt;code&gt;require('react-relay/classic')&lt;/code&gt; to continue to import the Relay Classic API.</source>
          <target state="translated">При обновлении существующего приложения Relay замените все &lt;code&gt;require('react-relay')&lt;/code&gt; на &lt;code&gt;require('react-relay/classic')&lt;/code&gt; чтобы продолжить импорт Relay Classic API.</target>
        </trans-unit>
        <trans-unit id="880864fa4e14c5e5caab7b10626e640aee6def2a" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, the restrictions on queries from Relay Classic are removed: queries may contain multiple root fields that use arbitrary arguments and return singular or plural values. The &lt;code&gt;viewer&lt;/code&gt; root field is now optional.</source>
          <target state="translated">При использовании &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; ограничения на запросы из Relay Classic снимаются: запросы могут содержать несколько корневых полей, которые используют произвольные аргументы и возвращают значения в единственном или множественном числе. &lt;code&gt;viewer&lt;/code&gt; поле Корневой теперь необязательно.</target>
        </trans-unit>
        <trans-unit id="eec48adcf595a6ca86caad379b181d97a2f010ca" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;pagination-container&quot;&gt;Pagination Container&lt;/a&gt;, Relay expects connection fields to be annotated with a &lt;code&gt;@connection&lt;/code&gt; directive. For more detailed information and an example, check out the &lt;a href=&quot;pagination-container#connection&quot;&gt;docs on using &lt;code&gt;@connection&lt;/code&gt; inside a Pagination Container&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdabb7b5c56a4bc287f21143e07d2eb721a2af6c" translate="yes" xml:space="preserve">
          <source>When you provide these functions, this is roughly what happens during the mutation request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384e273feee00773d8ac2cb8c10110ccc823425a" translate="yes" xml:space="preserve">
          <source>Whenever Relay is fulfilling data requirements, it can be useful to know when certain events occur. For example, we might want to record how long it takes for data to be available, or we might want to log errors to the server. These events are available on most Relay APIs via the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback.</source>
          <target state="translated">Когда Relay выполняет требования к данным, может быть полезно знать, когда происходят определенные события. Например, мы можем захотеть записать, сколько времени требуется, чтобы данные стали доступны, или мы могли бы захотеть регистрировать ошибки на сервере. Эти события доступны в большинстве API-интерфейсов Relay через обратный вызов &lt;code&gt;onReadyStateChange&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8cd144d9041c40f96f66e2aa651ea3465a4503f" translate="yes" xml:space="preserve">
          <source>Wherever the inverse grammar serves you better, you can use &lt;code&gt;@skip(if: ...)&lt;/code&gt; instead of &lt;code&gt;@include(if: ...)&lt;/code&gt;.</source>
          <target state="translated">Везде, где обратная грамматика вам лучше &lt;code&gt;@skip(if: ...)&lt;/code&gt; , вы можете использовать @skip (if: ...) вместо &lt;code&gt;@include(if: ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f3e2838c0630aa2c4914a0c2d4e6ea23e0c95ac" translate="yes" xml:space="preserve">
          <source>Whether the request was aborted.</source>
          <target state="translated">Был ли запрос отменен.</target>
        </trans-unit>
        <trans-unit id="422efd22184fb3e6c495b98266ee159c3842165d" translate="yes" xml:space="preserve">
          <source>While typically Relay only provides the data for fields explicitly requested by a component's fragment, &lt;code&gt;@relay(mask: false)&lt;/code&gt; can be added to a fragment spread to not mask that data, recursively including the data from the fields of the referenced fragment.</source>
          <target state="translated">Хотя обычно Relay предоставляет данные только для полей, явно запрошенных фрагментом компонента, &lt;code&gt;@relay(mask: false)&lt;/code&gt; может быть добавлена ​​к расширению фрагмента, чтобы не маскировать эти данные, рекурсивно включая данные из полей указанного фрагмента.</target>
        </trans-unit>
        <trans-unit id="ff506c81a21b554c2790ef2e5a963a42aff57850" translate="yes" xml:space="preserve">
          <source>While you type queries as follows:</source>
          <target state="translated">Пока вы набираете запросы следующим образом:</target>
        </trans-unit>
        <trans-unit id="0b57cc238bcb966947c54d303e25a36f527aba7b" translate="yes" xml:space="preserve">
          <source>While you type queries as:</source>
          <target state="translated">Пока вы печатаете запросы как:</target>
        </trans-unit>
        <trans-unit id="223f6c68b8dfddbadc2aa76589625320726b0252" translate="yes" xml:space="preserve">
          <source>Will cause a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d32def387eb6db627a1048487211194f68d2887" translate="yes" xml:space="preserve">
          <source>With GraphQL it is very common for the results of multiple queries to overlap. However, our response cache from the previous section doesn't account for this overlap &amp;mdash; it caches based on distinct queries. For example, if we issue a query to fetch stories:</source>
          <target state="translated">В GraphQL очень часто результаты нескольких запросов перекрываются. Однако наш кеш ответов из предыдущего раздела не учитывает это перекрытие - он кэширует на основе отдельных запросов. Например, если мы выдадим запрос на получение историй:</target>
        </trans-unit>
        <trans-unit id="326b4ac13e70484638c8e2c275bb7155ff73eafd" translate="yes" xml:space="preserve">
          <source>With a normalized response cache, a record would be created for each story in the list. The &lt;code&gt;stories&lt;/code&gt; field would store links to each of these records.</source>
          <target state="translated">При использовании нормализованного кэша ответов для каждой истории в списке будет создана запись. В поле &lt;code&gt;stories&lt;/code&gt; будут храниться ссылки на каждую из этих записей.</target>
        </trans-unit>
        <trans-unit id="9443a9eb3d5ff45b05255468c9ca88197b385e42" translate="yes" xml:space="preserve">
          <source>With some additional configuration, the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; babel plugin can also translate Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; literals. Most importantly, include a reference to your GraphQL Schema as either a json file or graphql schema file.</source>
          <target state="translated">При некоторой дополнительной настройке плагин babel &lt;code&gt;&quot;relay&quot;&lt;/code&gt; также может переводить литералы Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; . Самое главное, включите ссылку на вашу схему GraphQL в виде файла json или файла схемы graphql.</target>
        </trans-unit>
        <trans-unit id="b4fdf6745c6472ea632228aac1bf14006ef03d88" translate="yes" xml:space="preserve">
          <source>With the queries out of the way, let's start in on our only mutation: the one that spends a turn by checking a spot for treasure. Here, we define the input to the mutation (the id of a spot to check for treasure) and a list of all of the possible fields that the client might want updates about after the mutation has taken place. Finally, we implement a method that performs the underlying mutation.</source>
          <target state="translated">Когда запросы убраны с дороги,давайте начнем с единственной мутации:той,которая проводит поворот,проверяя место на наличие сокровищ.Здесь мы определяем входной сигнал для мутации (id места для проверки сокровища)и список всех возможных полей,о которых клиент может захотеть обновить после того,как мутация произошла.Наконец,мы реализуем метод,который выполняет мутацию,лежащую в основе.</target>
        </trans-unit>
        <trans-unit id="7ddd9cfe22f7c960a4c67535583b19ffb8497a42" translate="yes" xml:space="preserve">
          <source>With this input and payload, we can issue the following mutation:</source>
          <target state="translated">С помощью этого ввода и полезной нагрузки мы можем произвести следующую мутацию:</target>
        </trans-unit>
        <trans-unit id="dce3644542cd9fbd082b44d7cadd316ad1975d62" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e36e32aeb9398daa0c7117970d61b1237b724a3" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="translated">С помощью типичных подходов к выборке данных мы обнаружили, что два компонента часто имеют &lt;em&gt;неявные зависимости&lt;/em&gt; . Например, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; может использовать некоторые данные, не гарантируя, что данные были получены напрямую. Эти данные часто могут быть получены какой-либо другой частью системы, например &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; . Затем, когда мы изменили &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; и удалили эту логику выборки данных, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; внезапно и необъяснимо сломался. Ошибки такого типа не всегда проявляются сразу, особенно в более крупных приложениях, разрабатываемых более крупными командами. Ручное и автоматическое тестирование могут только очень помочь: это именно тот тип систематических проблем, который лучше решает фреймворк.</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="5c338a274513fe1f278459839f0c78f7e6b91728" translate="yes" xml:space="preserve">
          <source>Writing the game</source>
          <target state="translated">Написание игры</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="1696149c59259541ba3a1d3a3c3c107fc68c94e9" translate="yes" xml:space="preserve">
          <source>Yes*</source>
          <target state="translated">Yes*</target>
        </trans-unit>
        <trans-unit id="d38ce88b105c03a9bcdfa9b0ae57cef87a38afbe" translate="yes" xml:space="preserve">
          <source>You can also pass variables to the mutation's fragment builder from the outer fragment that contains it.</source>
          <target state="translated">Также можно передавать переменные конструктору фрагментов мутации из внешнего фрагмента,который в нем содержится.</target>
        </trans-unit>
        <trans-unit id="2a3a0a2cf926b5e31314761fde4d2b924ad01e95" translate="yes" xml:space="preserve">
          <source>You can conditionally include or skip a field based on the value of a boolean variable.</source>
          <target state="translated">Вы можете условно включить или пропустить поле,основанное на значении булевой переменной.</target>
        </trans-unit>
        <trans-unit id="e39e4e019fcddf87d5963ed450c0a585f3ac5a5c" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;InteractionManager&lt;/code&gt; on the &lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native API docs&lt;/a&gt;.</source>
          <target state="translated">Вы можете узнать больше о &lt;code&gt;InteractionManager&lt;/code&gt; в документации &lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db4f1b561c182f757185de947874831706c7c3d" translate="yes" xml:space="preserve">
          <source>You can read more about the API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface.</source>
          <target state="translated">Вы можете узнать больше об интерфейсе API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3732e8bd7b74351797baa672d29727cc8e4b2f3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;fetchQuery&lt;/code&gt; function to imperatively make GraphQL Requests. This is useful for cases where you want to make requests outside of React but still utilize the Relay store and network layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ec8ab0bbfcf6ce2aa1efbd2295912061dec672" translate="yes" xml:space="preserve">
          <source>You don't have to mimic the entire response payload. Here, we've punted on the like sentence, since it's difficult to localize on the client side. When the server responds, Relay will treat its payload as the source of truth, but in the meantime, the optimistic response will be applied right away, allowing the people who use our product to enjoy instant feedback after having taken an action.</source>
          <target state="translated">Тебе не нужно подражать всему грузу ответа.Вот,мы сделали ставку на подобное предложение,так как это трудно локализовать на стороне клиента.Когда сервер отвечает,Relay будет относиться к своей полезной нагрузке как к источнику истины,но в то же время,оптимистичный ответ будет применен сразу же,позволяя людям,которые используют наш продукт,наслаждаться мгновенной обратной связью после того,как действие было предпринято.</target>
        </trans-unit>
        <trans-unit id="db948a53ed55bdbbd4fa17526586780dad70f601" translate="yes" xml:space="preserve">
          <source>You have to implement your own cache strategy. A simple solution is to use &lt;code&gt;QueryResponseCache&lt;/code&gt; (an in-memory cache):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ae915d1a8b7fa12f92488b10423d30b2ad84e5" translate="yes" xml:space="preserve">
          <source>You will need to Configure your &lt;a href=&quot;networklayer&quot;&gt;Network&lt;/a&gt; to handle subscriptions. The below example uses &lt;a href=&quot;https://github.com/apollographql/subscriptions-transport-ws&quot;&gt;subscriptions-transport-ws&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eb998680ecc627ba04d1e2c348b212888c8f5b" translate="yes" xml:space="preserve">
          <source>[1] Note that GraphQL itself does not impose this constraint, and Relay Runtime may also be used for schemas that do not conform to it. For example, both systems can be used to query a single denormalized table. However, many of the features that Relay Runtime provides, such as caching and normalization, work best when the data is represented as a normalized graph with stable identities for discrete pieces of information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd3288de30464c56940d838b494bb246d25a587" translate="yes" xml:space="preserve">
          <source>an edge representing the new friend will be added to the viewer's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">край, представляющий нового друга, будет добавлен в соединение &lt;code&gt;friends&lt;/code&gt; зрителя</target>
        </trans-unit>
        <trans-unit id="33f0663df214f396a65e31c63ea1758c4a24ba18" translate="yes" xml:space="preserve">
          <source>an edge representing the viewer will be added to the new friend's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">край, представляющий зрителя, будет добавлен в соединение &lt;code&gt;friends&lt;/code&gt; нового друга</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="6a5703deebcf0535c19b19c1b0a27e8341e2ab4d" translate="yes" xml:space="preserve">
          <source>and then later refetch one of the stories whose &lt;code&gt;likeCount&lt;/code&gt; has since been incremented:</source>
          <target state="translated">а затем повторно загрузите одну из историй, значение &lt;code&gt;likeCount&lt;/code&gt; которой с тех пор увеличилось :</target>
        </trans-unit>
        <trans-unit id="6abe6d9392071037cb6a695b9da8b68f203db531" translate="yes" xml:space="preserve">
          <source>and we get back</source>
          <target state="translated">и мы вернёмся</target>
        </trans-unit>
        <trans-unit id="b74745ac136841f9501637f3fac7d913abeecf5d" translate="yes" xml:space="preserve">
          <source>and we'll get this result:</source>
          <target state="translated">и мы получим этот результат:</target>
        </trans-unit>
        <trans-unit id="f30392ad1d35a35355bcc5ff5b7ab1c4aa4b6b4d" translate="yes" xml:space="preserve">
          <source>applyOptimistic</source>
          <target state="translated">applyOptimistic</target>
        </trans-unit>
        <trans-unit id="481baa434ed8570c01e3d78b4a058c1cea4ffea5" translate="yes" xml:space="preserve">
          <source>applyUpdate (static method)</source>
          <target state="translated">applyUpdate (статический метод)</target>
        </trans-unit>
        <trans-unit id="e0d9b66d001ce91f916cb04de6514301d4191e1e" translate="yes" xml:space="preserve">
          <source>babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay</target>
        </trans-unit>
        <trans-unit id="804dd7a640e28824ae34b133455831c85cafaa66" translate="yes" xml:space="preserve">
          <source>both people's friend count will increment</source>
          <target state="translated">количество друзей обоих людей увеличится</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="ef1bbfb7f634722c33aa4d7f3c325a4a29ea88d1" translate="yes" xml:space="preserve">
          <source>commitUpdate (static method)</source>
          <target state="translated">commitUpdate (статический метод)</target>
        </trans-unit>
        <trans-unit id="8a1c1339801686eb9bf9a9ac5b4719b8c8b8fc9b" translate="yes" xml:space="preserve">
          <source>constructor</source>
          <target state="translated">constructor</target>
        </trans-unit>
        <trans-unit id="4b45c519aa27393b323501edc492900dac1e0a96" translate="yes" xml:space="preserve">
          <source>create (static method)</source>
          <target state="translated">создавать (статический метод)</target>
        </trans-unit>
        <trans-unit id="db646ca2b7d259a49537f70fff30ff3c2c3c18c5" translate="yes" xml:space="preserve">
          <source>createContainer (static method)</source>
          <target state="translated">createContainer (статический метод)</target>
        </trans-unit>
        <trans-unit id="2b28d0e79db5f9b1637a6d02fd886e0beb0a2a87" translate="yes" xml:space="preserve">
          <source>createWithFiles (static method)</source>
          <target state="translated">createWithFiles (статический метод)</target>
        </trans-unit>
        <trans-unit id="42cdc1d74453884d8861396360329db1f2583a19" translate="yes" xml:space="preserve">
          <source>fetchQuery</source>
          <target state="translated">fetchQuery</target>
        </trans-unit>
        <trans-unit id="da32c19d5a974ead91be2f8fa59b4a9c03db9888" translate="yes" xml:space="preserve">
          <source>forceFetch</source>
          <target state="translated">forceFetch</target>
        </trans-unit>
        <trans-unit id="446ce95fe1412056ff2efb4a2eddeb9b14b5b57b" translate="yes" xml:space="preserve">
          <source>fragments</source>
          <target state="translated">fragments</target>
        </trans-unit>
        <trans-unit id="348bf71ffb0d4407dbcecd15dd012e9ca4e50ec6" translate="yes" xml:space="preserve">
          <source>fragments (static property)</source>
          <target state="translated">фрагменты (статическое свойство)</target>
        </trans-unit>
        <trans-unit id="c7051a4ed355bcc5e03ff249da8ad3c8d98795de" translate="yes" xml:space="preserve">
          <source>getCollisionKey</source>
          <target state="translated">getCollisionKey</target>
        </trans-unit>
        <trans-unit id="9b9964fe7f200e2d2d723f2ce25c45e685f31c1a" translate="yes" xml:space="preserve">
          <source>getConfigs (abstract method)</source>
          <target state="translated">getConfigs (абстрактный метод)</target>
        </trans-unit>
        <trans-unit id="1af4f339fc74cdc2a2f63e9dec4d5c78820395ab" translate="yes" xml:space="preserve">
          <source>getDataID(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</source>
          <target state="translated">getDataID (): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0405ea062abe8cd4a0d287f9154a09079dc4bb4d" translate="yes" xml:space="preserve">
          <source>getDebugName</source>
          <target state="translated">getDebugName</target>
        </trans-unit>
        <trans-unit id="327b4db9411eb5735cd4d613988bd27603d51f28" translate="yes" xml:space="preserve">
          <source>getFatQuery (abstract method)</source>
          <target state="translated">getFatQuery (абстрактный метод)</target>
        </trans-unit>
        <trans-unit id="97f9623a23d5717ffebb67278d55b1afd1ffd725" translate="yes" xml:space="preserve">
          <source>getFiles</source>
          <target state="translated">getFiles</target>
        </trans-unit>
        <trans-unit id="1778700a36f50cd423696eb753bb860799ac9b24" translate="yes" xml:space="preserve">
          <source>getFragment</source>
          <target state="translated">getFragment</target>
        </trans-unit>
        <trans-unit id="d7c3b79969b5a91a9a376dcbffb251e4515b3ce9" translate="yes" xml:space="preserve">
          <source>getFragment (static method)</source>
          <target state="translated">getFragment (статический метод)</target>
        </trans-unit>
        <trans-unit id="e8166bd4ce0d5f8fe076afeb9c45240cc7d5f2b5" translate="yes" xml:space="preserve">
          <source>getID</source>
          <target state="translated">getID</target>
        </trans-unit>
        <trans-unit id="a73db9be39fc73bb1d8a15f030515c436d5a3453" translate="yes" xml:space="preserve">
          <source>getLinkedRecord(name: string, args?: ?Variables): ?RecordProxy</source>
          <target state="translated">getLinkedRecord(name:string,args?:?Variables):?RecordProxy</target>
        </trans-unit>
        <trans-unit id="88377de01a531764c854a5d87458832e26bb6d7d" translate="yes" xml:space="preserve">
          <source>getLinkedRecords(name: string, args?: ?Variables): ?Array&amp;lt;?RecordProxy&amp;gt;</source>
          <target state="translated">getLinkedRecords (имя: строка, аргументы ?:? Переменные):? Массив &amp;lt;? RecordProxy&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7fde427ab020029d422a06dc9a3f3cf60a0f286" translate="yes" xml:space="preserve">
          <source>getMutation (abstract method)</source>
          <target state="translated">getMutation (абстрактный метод)</target>
        </trans-unit>
        <trans-unit id="c3d4160e6945293e656522a92a11fe8535c041eb" translate="yes" xml:space="preserve">
          <source>getOptimisticConfigs</source>
          <target state="translated">getOptimisticConfigs</target>
        </trans-unit>
        <trans-unit id="e35ed410633190979352fe6ee6d4d885c8a18598" translate="yes" xml:space="preserve">
          <source>getOptimisticResponse</source>
          <target state="translated">getOptimisticResponse</target>
        </trans-unit>
        <trans-unit id="6bd679f8ef0f8733bd010559ff42cbedeb5983bf" translate="yes" xml:space="preserve">
          <source>getOrCreateLinkedRecord(name: string, typeName: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">getOrCreateLinkedRecord(name:string,typeName:string,args?:?Variables ):RecordProxy</target>
        </trans-unit>
        <trans-unit id="759956d4899d707dd6a33742489f969212a28756" translate="yes" xml:space="preserve">
          <source>getPendingTransactions</source>
          <target state="translated">getPendingTransactions</target>
        </trans-unit>
        <trans-unit id="5531a9db2f3b83555a0eff0afe4a7b4598c8f0de" translate="yes" xml:space="preserve">
          <source>getQueryString</source>
          <target state="translated">getQueryString</target>
        </trans-unit>
        <trans-unit id="5b70bfc75fe69a0ac1b8cf3046235fbb64e40599" translate="yes" xml:space="preserve">
          <source>getRootField(fieldName: string): ?RecordProxy</source>
          <target state="translated">getRootField(fieldName:string):?RecordProxy</target>
        </trans-unit>
        <trans-unit id="ab14bf198ad6c14dda7ba6cd7afe5b74fddbdc2e" translate="yes" xml:space="preserve">
          <source>getSource(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</source>
          <target state="translated">getSource (): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="264cb99bbdb88c3a503a7cd09445ab43ad54af52" translate="yes" xml:space="preserve">
          <source>getType(): RelayQLType</source>
          <target state="translated">getType():RelayQLType</target>
        </trans-unit>
        <trans-unit id="f5807036ab312a725491c64183d61cf7b9babe1d" translate="yes" xml:space="preserve">
          <source>getValue(name: string, args?: ?Variables): mixed</source>
          <target state="translated">getValue(name:string,args?:?Variables):mix</target>
        </trans-unit>
        <trans-unit id="43f55a80a8e191422ce37e5ebd8264867fc6316d" translate="yes" xml:space="preserve">
          <source>getVariables</source>
          <target state="translated">getVariables</target>
        </trans-unit>
        <trans-unit id="4349f8288befeff38404853658acf2b002ad2746" translate="yes" xml:space="preserve">
          <source>getVariables (abstract method)</source>
          <target state="translated">getVariables (абстрактный метод)</target>
        </trans-unit>
        <trans-unit id="3cfab35ae11b2420cf0d4e4900fa11d44d7f4976" translate="yes" xml:space="preserve">
          <source>gives us</source>
          <target state="translated">дает нам</target>
        </trans-unit>
        <trans-unit id="9fdcc7f29c59e6f9abaaab32c0a1a15b1b78226b" translate="yes" xml:space="preserve">
          <source>graphql</source>
          <target state="translated">graphql</target>
        </trans-unit>
        <trans-unit id="dde2cfc8d1d2de804008dfc4836831a0eccb8444" translate="yes" xml:space="preserve">
          <source>hasOptimisticUpdate</source>
          <target state="translated">hasOptimisticUpdate</target>
        </trans-unit>
        <trans-unit id="a205cb3bee524195c2fdce6610a417b6853a4c32" translate="yes" xml:space="preserve">
          <source>initialVariables</source>
          <target state="translated">initialVariables</target>
        </trans-unit>
        <trans-unit id="4bfbc265fe484eac76b0500e386617d6cf0e573e" translate="yes" xml:space="preserve">
          <source>initialVariables (static property)</source>
          <target state="translated">исходные переменные (статическое свойство)</target>
        </trans-unit>
        <trans-unit id="04dcd4fb3277dbb1127599ff7d32d5684b6a02dc" translate="yes" xml:space="preserve">
          <source>injectNetworkLayer (static method)</source>
          <target state="translated">инъекционныйNetworkLayer (статический метод)</target>
        </trans-unit>
        <trans-unit id="0a776c5ca0800d03ca78f47f75e9eb834365d304" translate="yes" xml:space="preserve">
          <source>injectTaskScheduler (static method)</source>
          <target state="translated">инъекцияТаскПланировщик (статический метод)</target>
        </trans-unit>
        <trans-unit id="bc813ae20708b8a347a4d53fb6e91311ea7bb33d" translate="yes" xml:space="preserve">
          <source>isContainer (static method)</source>
          <target state="translated">isContainer (статический метод)</target>
        </trans-unit>
        <trans-unit id="c53397edd355fc4e2d006653db94583eef513e6f" translate="yes" xml:space="preserve">
          <source>onReadyStateChange</source>
          <target state="translated">onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="fb05074bc118e549bee00caf3b25aeedd2a23fb9" translate="yes" xml:space="preserve">
          <source>or: &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">или: &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; в контейнере Refetch</target>
        </trans-unit>
        <trans-unit id="00525d7718b6def384814a704d781fd95161b685" translate="yes" xml:space="preserve">
          <source>paramDefinitions (static property)</source>
          <target state="translated">параметрыОпределения (статическое свойство)</target>
        </trans-unit>
        <trans-unit id="ab47b8a712d90d33736ca95a21ffd78e2edcbc43" translate="yes" xml:space="preserve">
          <source>pendingVariables</source>
          <target state="translated">pendingVariables</target>
        </trans-unit>
        <trans-unit id="46070ca5b7bac4a677b32597aa968e6707fb2947" translate="yes" xml:space="preserve">
          <source>prepareParams (static property)</source>
          <target state="translated">ГотПарамС (статическое свойство)</target>
        </trans-unit>
        <trans-unit id="4c8dd8321c7f8e03d9a33e3aac495748a5310da1" translate="yes" xml:space="preserve">
          <source>prepareVariables</source>
          <target state="translated">prepareVariables</target>
        </trans-unit>
        <trans-unit id="6399eda44b9a365d9ef2884378c34b3d150ac371" translate="yes" xml:space="preserve">
          <source>prepareVariables (static property)</source>
          <target state="translated">Готовые переменные (статическое свойство)</target>
        </trans-unit>
        <trans-unit id="d32d93402de4dcb749f059cba43572aa23bd03dc" translate="yes" xml:space="preserve">
          <source>queries (static property)</source>
          <target state="translated">запросы (статическое свойство)</target>
        </trans-unit>
        <trans-unit id="9dc632a4888b695f2a771b203d0887d10714caef" translate="yes" xml:space="preserve">
          <source>react-relay/classic</source>
          <target state="translated">react-relay/classic</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes" xml:space="preserve">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="62f23262fcec4cdc5eb17faabb63e059d6950930" translate="yes" xml:space="preserve">
          <source>renderFailure</source>
          <target state="translated">renderFailure</target>
        </trans-unit>
        <trans-unit id="2afd39a75e88681d175b8553ff1dce06613384a5" translate="yes" xml:space="preserve">
          <source>renderFetched</source>
          <target state="translated">renderFetched</target>
        </trans-unit>
        <trans-unit id="5e3932629379610ab259e44527d32162c9392f0b" translate="yes" xml:space="preserve">
          <source>renderLoading</source>
          <target state="translated">renderLoading</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">returns</target>
        </trans-unit>
        <trans-unit id="ff3a6f3b41f1c1e00b77429034bc912cfa7dd364" translate="yes" xml:space="preserve">
          <source>rollback</source>
          <target state="translated">rollback</target>
        </trans-unit>
        <trans-unit id="fc166eb81361ff31179cd3c83da3bfe088b851d3" translate="yes" xml:space="preserve">
          <source>route</source>
          <target state="translated">route</target>
        </trans-unit>
        <trans-unit id="e1d71ee40db65de4abc60e598cad15a41923e787" translate="yes" xml:space="preserve">
          <source>routeName (static property)</source>
          <target state="translated">routeName (статическое свойство)</target>
        </trans-unit>
        <trans-unit id="9f1125a04ebb1449bdd323a60a2950db5accfb80" translate="yes" xml:space="preserve">
          <source>sendMutation</source>
          <target state="translated">sendMutation</target>
        </trans-unit>
        <trans-unit id="435568d9e02408d6788ecdc6be513d72ccc6cb61" translate="yes" xml:space="preserve">
          <source>sendQueries</source>
          <target state="translated">sendQueries</target>
        </trans-unit>
        <trans-unit id="2880123c67d1aaedb821f0f247cd4c6c4345aab8" translate="yes" xml:space="preserve">
          <source>setLinkedRecord(record: RecordProxy, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setLinkedRecord(запись:RecordProxy,имя:string,args?:?Variables):RecordProxy</target>
        </trans-unit>
        <trans-unit id="7dc0722d5b1e977d588c3edf8515b019e788c174" translate="yes" xml:space="preserve">
          <source>setLinkedRecords(records: Array&amp;lt;?RecordProxy&amp;gt;, name: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">setLinkedRecords (записи: массив &amp;lt;? RecordProxy&amp;gt;, имя: строка, аргументы ?:? переменные): RecordProxy</target>
        </trans-unit>
        <trans-unit id="9a58f84fd8486e41fd7dcfc4d34aa90c06019e22" translate="yes" xml:space="preserve">
          <source>setValue(value: mixed, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setValue(value:mix,name:string,args?:?Variables):RecordProxy</target>
        </trans-unit>
        <trans-unit id="5548ee17e1e709bc17eb0b6bc474907bee14447b" translate="yes" xml:space="preserve">
          <source>setVariables</source>
          <target state="translated">setVariables</target>
        </trans-unit>
        <trans-unit id="ae2633f3722560d2ad1ff74c21f50ef81ea6b153" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate</source>
          <target state="translated">shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="8a14711da8b864c0b88fb3fe7e873c0b2894566e" translate="yes" xml:space="preserve">
          <source>supports</source>
          <target state="translated">supports</target>
        </trans-unit>
        <trans-unit id="09e391d372ecf222949d736538e76db78674604a" translate="yes" xml:space="preserve">
          <source>the viewer's friendship status with the requester will change</source>
          <target state="translated">статус дружбы зрителя с запрашивающим изменится.</target>
        </trans-unit>
        <trans-unit id="bc5af2310c7f15770a4ed0028648ce367e3e2ec0" translate="yes" xml:space="preserve">
          <source>variables</source>
          <target state="translated">variables</target>
        </trans-unit>
        <trans-unit id="87a0de569c57d54d8721ab12b504cc0797b8a57b" translate="yes" xml:space="preserve">
          <source>with these params:</source>
          <target state="translated">с этими парамедиками:</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
