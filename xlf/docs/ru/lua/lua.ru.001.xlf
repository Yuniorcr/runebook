<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="lua">
    <body>
      <group id="lua">
        <trans-unit id="85ee1dce4e7f426747bd89aef5bd47aa20d38aad" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;L&lt;/code&gt;&quot;:  reads the next line keeping the end-of-line character (if present), returning &lt;b&gt;nil&lt;/b&gt; on end of file.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;L&lt;/code&gt; &amp;raquo;: читает следующую строку, сохраняя символ конца строки (если есть), возвращая &lt;b&gt;ноль&lt;/b&gt; в конце файла.</target>
        </trans-unit>
        <trans-unit id="e0c82711681d3851f13f59346546cd0a034bb77a" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a+&lt;/code&gt;&quot;:  append update mode, previous data is preserved, writing is only allowed at the end of file.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;a+&lt;/code&gt; &amp;raquo;: добавить режим обновления, предыдущие данные сохраняются, запись разрешена только в конец файла.</target>
        </trans-unit>
        <trans-unit id="68f6a1b79e4ab4f973b74b712a8ec0055442f0ec" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a&lt;/code&gt;&quot;:  append mode;</source>
          <target state="translated">&amp;laquo; &lt;code&gt;a&lt;/code&gt; &amp;raquo;: режим добавления;</target>
        </trans-unit>
        <trans-unit id="da2c3d0b3051b286b1d0b50590784dedf845e53c" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a&lt;/code&gt;&quot;:  reads the whole file, starting at the current position. On end of file, it returns the empty string.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;a&lt;/code&gt; &amp;raquo;: читает весь файл, начиная с текущей позиции. В конце файла возвращается пустая строка.</target>
        </trans-unit>
        <trans-unit id="7fa0969179f03d1f39ed55770cfc19ab243badc2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;collect&lt;/code&gt;&quot;:  performs a full garbage-collection cycle. This is the default option.</source>
          <target state="translated">&quot; &lt;code&gt;collect&lt;/code&gt; &quot;: выполняет полный цикл сборки мусора. Это вариант по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4d2df6eb922319bf606a86a89e2fc83230795af9" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;count&lt;/code&gt;&quot;:  returns the total memory in use by Lua in Kbytes. The value has a fractional part, so that it multiplied by 1024 gives the exact number of bytes in use by Lua (except for overflows).</source>
          <target state="translated">&amp;laquo; &lt;code&gt;count&lt;/code&gt; &amp;raquo;: возвращает общий объем памяти, используемый Lua в килобайтах. Значение имеет дробную часть, поэтому умножение на 1024 дает точное количество байтов, используемых Lua (за исключением переполнения).</target>
        </trans-unit>
        <trans-unit id="ef21751d9473020b9e5da0603526fbc16553da86" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;cur&lt;/code&gt;&quot;:  base is current position;</source>
          <target state="translated">&quot; &lt;code&gt;cur&lt;/code&gt; &quot;: база - текущая позиция;</target>
        </trans-unit>
        <trans-unit id="45f4427c05fe67a6aadc962320833307f03356f2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;end&lt;/code&gt;&quot;:  base is end of file;</source>
          <target state="translated">&amp;laquo; &lt;code&gt;end&lt;/code&gt; &amp;raquo;: база - это конец файла;</target>
        </trans-unit>
        <trans-unit id="b6883b7ef8179370d3a9ce57af44e1806db3b5d3" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;exit&lt;/code&gt;&quot;:  the command terminated normally; the following number is the exit status of the command.</source>
          <target state="translated">&quot; &lt;code&gt;exit&lt;/code&gt; &quot;: команда завершилась нормально; следующий номер - статус выхода команды.</target>
        </trans-unit>
        <trans-unit id="f86582b43c224b125fce8af4c1bd39d83c959584" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;full&lt;/code&gt;&quot;:  full buffering; output operation is performed only when the buffer is full or when you explicitly &lt;code&gt;flush&lt;/code&gt; the file (see &lt;a href=&quot;#pdf-io.flush&quot;&gt;&lt;code&gt;io.flush&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&amp;laquo; &lt;code&gt;full&lt;/code&gt; &amp;raquo;: полная буферизация; операция вывода выполняется только тогда , когда буфер заполнен или когда вы явно &lt;code&gt;flush&lt;/code&gt; файл (см &lt;a href=&quot;#pdf-io.flush&quot;&gt; &lt;code&gt;io.flush&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8b36390a21d74199c7097e386abdc8966f9f3141" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;isrunning&lt;/code&gt;&quot;:  returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="translated">&quot; &lt;code&gt;isrunning&lt;/code&gt; &quot;: возвращает логическое значение, которое сообщает, работает ли сборщик (т.е. не остановлен).</target>
        </trans-unit>
        <trans-unit id="35126f6ad470130461b610dc64352ebf2d5ba8ac" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;l&lt;/code&gt;&quot;:  reads the next line skipping the end of line, returning &lt;b&gt;nil&lt;/b&gt; on end of file. This is the default format.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;l&lt;/code&gt; &amp;raquo;: читает следующую строку, минуя конец строки, возвращая &lt;b&gt;nil&lt;/b&gt; в конце файла. Это формат по умолчанию.</target>
        </trans-unit>
        <trans-unit id="0bf7bc41709a6ccf5aa6eae67b8f346e5001d8b6" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;line&lt;/code&gt;&quot;:  line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device).</source>
          <target state="translated">&amp;laquo; &lt;code&gt;line&lt;/code&gt; &amp;raquo;: буферизация строки; вывод буферизируется до тех пор, пока не будет выведена новая строка или не будет ввода из некоторых специальных файлов (например, терминального устройства).</target>
        </trans-unit>
        <trans-unit id="e4a59afc3c3aee61c303a6c6f2b2a762d2ad3d81" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;n&lt;/code&gt;&quot;:  reads a numeral and returns it as a float or an integer, following the lexical conventions of Lua. (The numeral may have leading spaces and a sign.) This format always reads the longest input sequence that is a valid prefix for a numeral; if that prefix does not form a valid numeral (e.g., an empty string, &quot;&lt;code&gt;0x&lt;/code&gt;&quot;, or &quot;&lt;code&gt;3.4e-&lt;/code&gt;&quot;), it is discarded and the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;n&lt;/code&gt; &amp;raquo;: читает число и возвращает его как число с плавающей запятой или целое число, следуя лексическим соглашениям Lua. (У числа могут быть начальные пробелы и знак.) Этот формат всегда считывает самую длинную входную последовательность, которая является допустимым префиксом для числа; если этот префикс не образует допустимое число (например, пустую строку, &amp;laquo; &lt;code&gt;0x&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;3.4e-&lt;/code&gt; &amp;raquo;), он отбрасывается, и функция возвращает &lt;b&gt;ноль&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="1a4495ab81e55566441b9ba9cd4267c1f76a8e00" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;no&lt;/code&gt;&quot;:  no buffering; the result of any output operation appears immediately.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;no&lt;/code&gt; &amp;raquo;: без буферизации; результат любой операции вывода появляется сразу.</target>
        </trans-unit>
        <trans-unit id="6aff03076b0cbaa7624920aed996ee3d088508ee" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;r+&lt;/code&gt;&quot;:  update mode, all previous data is preserved;</source>
          <target state="translated">&amp;laquo; &lt;code&gt;r+&lt;/code&gt; &amp;raquo;: режим обновления, все предыдущие данные сохраняются;</target>
        </trans-unit>
        <trans-unit id="482f32bfc1639381f140a1f788e0fb798f9e8562" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;r&lt;/code&gt;&quot;:  read mode (the default);</source>
          <target state="translated">&amp;laquo; &lt;code&gt;r&lt;/code&gt; &amp;raquo;: режим чтения (по умолчанию);</target>
        </trans-unit>
        <trans-unit id="1f0ba614002bce35b460ade5c8343fbd966c8766" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;restart&lt;/code&gt;&quot;:  restarts automatic execution of the garbage collector.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;restart&lt;/code&gt; &amp;raquo;: перезапускает автоматическое выполнение сборщика мусора.</target>
        </trans-unit>
        <trans-unit id="da9e4c23feee0a79d4abaaf5c61375cea61ef16e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;set&lt;/code&gt;&quot;:  base is position 0 (beginning of the file);</source>
          <target state="translated">&quot; &lt;code&gt;set&lt;/code&gt; &quot;: база - позиция 0 (начало файла);</target>
        </trans-unit>
        <trans-unit id="3ec56036cdf5df6fcc52e9cfbd8e2a8921f7aeb1" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;setpause&lt;/code&gt;&quot;:  sets &lt;code&gt;arg&lt;/code&gt; as the new value for the &lt;em&gt;pause&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Returns the previous value for &lt;em&gt;pause&lt;/em&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;setpause&lt;/code&gt; &quot;: устанавливает &lt;code&gt;arg&lt;/code&gt; как новое значение для &lt;em&gt;паузы&lt;/em&gt; сборщика (см. &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ). Возвращает предыдущее значение &lt;em&gt;паузы&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d1dc91f2ee994f6c3a3be7368d48037cc9c1b59c" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;setstepmul&lt;/code&gt;&quot;:  sets &lt;code&gt;arg&lt;/code&gt; as the new value for the &lt;em&gt;step multiplier&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Returns the previous value for &lt;em&gt;step&lt;/em&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;setstepmul&lt;/code&gt; &quot;: устанавливает &lt;code&gt;arg&lt;/code&gt; как новое значение &lt;em&gt;шагового множителя&lt;/em&gt; сборщика (см. &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ). Возвращает предыдущее значение &lt;em&gt;шага&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c115c4696628bd2659c03d76315d495492249e40" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;signal&lt;/code&gt;&quot;:  the command was terminated by a signal; the following number is the signal that terminated the command.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;signal&lt;/code&gt; &amp;raquo;: команда завершена сигналом; следующий номер - это сигнал о завершении команды.</target>
        </trans-unit>
        <trans-unit id="c28a219da2e678f08b09e43596cbee1a80cf4c50" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;step&lt;/code&gt;&quot;:  performs a garbage-collection step. The step &quot;size&quot; is controlled by &lt;code&gt;arg&lt;/code&gt;. With a zero value, the collector will perform one basic (indivisible) step. For non-zero values, the collector will perform as if that amount of memory (in KBytes) had been allocated by Lua. Returns &lt;b&gt;true&lt;/b&gt; if the step finished a collection cycle.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;step&lt;/code&gt; &amp;raquo;: выполняет шаг сборки мусора. Размер шага контролируется &lt;code&gt;arg&lt;/code&gt; . При нулевом значении коллектор выполнит один базовый (неделимый) шаг. Для ненулевых значений сборщик будет работать так, как если бы этот объем памяти (в килобайтах) был выделен Lua. Возвращает &lt;b&gt;истину,&lt;/b&gt; если шаг завершил цикл сбора.</target>
        </trans-unit>
        <trans-unit id="93ae23d840374f0e5fdda6d2e1995e17e2530e29" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;stop&lt;/code&gt;&quot;:  stops automatic execution of the garbage collector. The collector will run only when explicitly invoked, until a call to restart it.</source>
          <target state="translated">&amp;laquo; &lt;code&gt;stop&lt;/code&gt; &amp;raquo;: останавливает автоматическое выполнение сборщика мусора. Сборщик будет работать только при явном вызове, пока не будет вызван его перезапуск.</target>
        </trans-unit>
        <trans-unit id="630c88288eece276817c37c452c13aad30aeeac6" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;w+&lt;/code&gt;&quot;:  update mode, all previous data is erased;</source>
          <target state="translated">&amp;laquo; &lt;code&gt;w+&lt;/code&gt; &amp;raquo;: режим обновления, все предыдущие данные стираются;</target>
        </trans-unit>
        <trans-unit id="4c032e7180fccc925387c5e5d8ef02f876f66a43" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;w&lt;/code&gt;&quot;:  write mode;</source>
          <target state="translated">&amp;laquo; &lt;code&gt;w&lt;/code&gt; &amp;raquo;: режим записи;</target>
        </trans-unit>
        <trans-unit id="f33634dd2aed7619f53f32286917ce87f67cf9f3" translate="yes" xml:space="preserve">
          <source>&amp;copy; 1994&amp;ndash;2017 Lua.org, PUC-Rio.</source>
          <target state="translated">&amp;copy; 1994&amp;ndash;2017 Lua.org, PUC-Rio.</target>
        </trans-unit>
        <trans-unit id="726a699c479b955107f38c46bbe964c5bb86c9c1" translate="yes" xml:space="preserve">
          <source>'': (empty space) ignored</source>
          <target state="translated">'': (пустое пространство) игнорируется</target>
        </trans-unit>
        <trans-unit id="f90841632f7dd28deac05f9104f8757d4d938ddf" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;L&lt;/code&gt;':  pushes onto the stack a table whose indices are the numbers of the lines that are valid on the function. (A &lt;em&gt;valid line&lt;/em&gt; is a line with some associated code, that is, a line where you can put a break point. Non-valid lines include empty lines and comments.)</source>
          <target state="translated">' &lt;code&gt;L&lt;/code&gt; ': помещает в стек таблицу, индексы которой являются номерами строк, допустимых для функции. ( &lt;em&gt;Допустимая строка&lt;/em&gt; - это строка с некоторым связанным кодом, то есть строка, в которой вы можете поставить точку останова. Недействительные строки включают пустые строки и комментарии.)</target>
        </trans-unit>
        <trans-unit id="16fe771c19d862613ab04d78a26fbb806a4f2023" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;S&lt;/code&gt;':  fills in the fields &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;short_src&lt;/code&gt;, &lt;code&gt;linedefined&lt;/code&gt;, &lt;code&gt;lastlinedefined&lt;/code&gt;, and &lt;code&gt;what&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;S&lt;/code&gt; ': заполняет поля &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;short_src&lt;/code&gt; , &lt;code&gt;linedefined&lt;/code&gt; , &lt;code&gt;lastlinedefined&lt;/code&gt; , и &lt;code&gt;what&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="11a8d7eb3de20bf4074efa8302fa3ebc068c92db" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;c&lt;/code&gt;':  the hook is called every time Lua calls a function;</source>
          <target state="translated">' &lt;code&gt;c&lt;/code&gt; ': ловушка вызывается каждый раз, когда Lua вызывает функцию;</target>
        </trans-unit>
        <trans-unit id="5dcde03cc29cac4fbee975fd5c6324c0eb2f762a" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;f&lt;/code&gt;':  pushes onto the stack the function that is running at the given level;</source>
          <target state="translated">' &lt;code&gt;f&lt;/code&gt; ': помещает в стек функцию, которая выполняется на данном уровне;</target>
        </trans-unit>
        <trans-unit id="d52c4536e0d633bd2dc95275436338ca66e5b0e0" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;l&lt;/code&gt;':  fills in the field &lt;code&gt;currentline&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;l&lt;/code&gt; ': заполняет поле &lt;code&gt;currentline&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="06eefa71811d3d77eadfb569caf992bf00533260" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;l&lt;/code&gt;':  the hook is called every time Lua enters a new line of code.</source>
          <target state="translated">' &lt;code&gt;l&lt;/code&gt; ': ловушка вызывается каждый раз, когда Lua вводит новую строку кода.</target>
        </trans-unit>
        <trans-unit id="19b3d6db914e545df7410bf6ead714c645f9d90c" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;n&lt;/code&gt;':  fills in the field &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namewhat&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;n&lt;/code&gt; ': заполняет &lt;code&gt;name&lt;/code&gt; поля и &lt;code&gt;namewhat&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0af9c5fa72fd0ae40f86d69a634de5abaff185ba" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;r&lt;/code&gt;':  the hook is called every time Lua returns from a function;</source>
          <target state="translated">' &lt;code&gt;r&lt;/code&gt; ': ловушка вызывается каждый раз, когда Lua возвращается из функции;</target>
        </trans-unit>
        <trans-unit id="5aab32dc44a04b46cf39fd9dca7828f4e75632c3" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;t&lt;/code&gt;':  fills in the field &lt;code&gt;istailcall&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;t&lt;/code&gt; ': заполняет поле &lt;code&gt;istailcall&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="2995d9a5b2edfc5c4090bb5aeac40be286f51c1c" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;u&lt;/code&gt;':  fills in the fields &lt;code&gt;nups&lt;/code&gt;, &lt;code&gt;nparams&lt;/code&gt;, and &lt;code&gt;isvararg&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;u&lt;/code&gt; ': заполняет поля &lt;code&gt;nups&lt;/code&gt; , &lt;code&gt;nparams&lt;/code&gt; и &lt;code&gt;isvararg&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3ba9ac7e76f439728000e96df248ad5393e0be09" translate="yes" xml:space="preserve">
          <source>(A &quot;&lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;&quot; means an optional integral numeral.) Except for padding, spaces, and configurations (options &quot;&lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt;&quot;), each option corresponds to an argument (in &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;) or a result (in &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">(&amp;laquo; &lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; &amp;raquo; означает необязательное целое число.) За исключением заполнения, пробелов и конфигураций (параметры &amp;laquo; &lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt; &amp;raquo;), Каждая опция соответствует аргументу (в &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; ) или результату (в &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; . распаковать ).</target>
        </trans-unit>
        <trans-unit id="ff34abdb860538263e1592eaf5de0e2697e490fe" translate="yes" xml:space="preserve">
          <source>(Formally this is not an incompatibility, because Lua does not specify how numbers are formatted as strings, but some programs assumed a specific format.)</source>
          <target state="translated">(Формально это не несовместимость, потому что Lua не указывает, как числа форматируются как строки, но некоторые программы предполагают определенный формат.)</target>
        </trans-unit>
        <trans-unit id="83e737da7c8003cef965fa66244b7d4f0e811971" translate="yes" xml:space="preserve">
          <source>(In this manual, &lt;code&gt;--&amp;gt;&lt;/code&gt; indicates the result of the preceding expression.)</source>
          <target state="translated">(В этом руководстве &lt;code&gt;--&amp;gt;&lt;/code&gt; обозначает результат предыдущего выражения.)</target>
        </trans-unit>
        <trans-unit id="bf94fa4119b73b349cb3a869be243c96bbbd716b" translate="yes" xml:space="preserve">
          <source>(Note that it is very easy to exhaust the memory of your machine with a single call to this function.)</source>
          <target state="translated">(Обратите внимание, что очень легко исчерпать память вашей машины с помощью одного вызова этой функции.)</target>
        </trans-unit>
        <trans-unit id="15e67d53040898eb1d72848e8bf16a113fbe8148" translate="yes" xml:space="preserve">
          <source>(Of course, the location of the Lua interpreter may be different in your machine. If &lt;code&gt;lua&lt;/code&gt; is in your &lt;code&gt;PATH&lt;/code&gt;, then</source>
          <target state="translated">(Конечно, расположение интерпретатора Lua на вашем компьютере может быть другим. Если &lt;code&gt;lua&lt;/code&gt; находится в вашем &lt;code&gt;PATH&lt;/code&gt; , тогда</target>
        </trans-unit>
        <trans-unit id="81e3e714f7f80485e58bd929a17d4b2437cf6658" translate="yes" xml:space="preserve">
          <source>(This only makes a difference when the body of the function contains references to &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">(Это имеет значение только в том случае, если тело функции содержит ссылки на &lt;code&gt;f&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="cc7121f94b54a95b8b969917eaaadf1818bfdd84" translate="yes" xml:space="preserve">
          <source>1 &amp;ndash; Introduction</source>
          <target state="translated">1. Введение</target>
        </trans-unit>
        <trans-unit id="8f2807c1adb4cb8317971da9ae6f8750a47585a8" translate="yes" xml:space="preserve">
          <source>2 &amp;ndash; Basic Concepts</source>
          <target state="translated">2 - Основные понятия</target>
        </trans-unit>
        <trans-unit id="addc53e794c80e9178d488e577f3a4dea23392c9" translate="yes" xml:space="preserve">
          <source>2.1 &amp;ndash; Values and Types</source>
          <target state="translated">2.1 - Значения и типы</target>
        </trans-unit>
        <trans-unit id="3a2d12c82ff6ae933fc4f58e1c29dac173475282" translate="yes" xml:space="preserve">
          <source>2.2 &amp;ndash; Environments and the Global Environment</source>
          <target state="translated">2.2 - Окружающая среда и глобальная среда</target>
        </trans-unit>
        <trans-unit id="9ffa2c3b3aefb8ca31249b42217d40b45a53d14c" translate="yes" xml:space="preserve">
          <source>2.3 &amp;ndash; Error Handling</source>
          <target state="translated">2.3 - Обработка ошибок</target>
        </trans-unit>
        <trans-unit id="5c74738bb551c5852eee4f0c5bc1c1ba329666da" translate="yes" xml:space="preserve">
          <source>2.4 &amp;ndash; Metatables and Metamethods</source>
          <target state="translated">2.4 - Метатаблицы и метаметоды</target>
        </trans-unit>
        <trans-unit id="33aac5b72dac431d0193e5a027944729e242300d" translate="yes" xml:space="preserve">
          <source>2.5 &amp;ndash; Garbage Collection</source>
          <target state="translated">2.5 - Сборка мусора</target>
        </trans-unit>
        <trans-unit id="0f9506705cc9aac3384b718f0231b4eeaf53f83b" translate="yes" xml:space="preserve">
          <source>2.5.1 &amp;ndash; Garbage-Collection Metamethods</source>
          <target state="translated">2.5.1 - Метаметоды сбора мусора</target>
        </trans-unit>
        <trans-unit id="360b1c24eeac1e48dfe95fc741100e73b36bcc2b" translate="yes" xml:space="preserve">
          <source>2.5.2 &amp;ndash; Weak Tables</source>
          <target state="translated">2.5.2 - Слабые таблицы</target>
        </trans-unit>
        <trans-unit id="49622640c10cc5518dfa4cbdd39ec33d28b234e2" translate="yes" xml:space="preserve">
          <source>2.6 &amp;ndash; Coroutines</source>
          <target state="translated">2.6 - Сопрограммы</target>
        </trans-unit>
        <trans-unit id="44e5a7dffeb9301dcfea49c570d9242c8df4de45" translate="yes" xml:space="preserve">
          <source>3 &amp;ndash; The Language</source>
          <target state="translated">3 - Язык</target>
        </trans-unit>
        <trans-unit id="2e41c7c97446c4f1020d50a68126a5a0606e6e8f" translate="yes" xml:space="preserve">
          <source>3.1 &amp;ndash; Lexical Conventions</source>
          <target state="translated">3.1 - Лексические соглашения</target>
        </trans-unit>
        <trans-unit id="0612a6e0f7da40e6c864f4e6e097977a5b51bcbe" translate="yes" xml:space="preserve">
          <source>3.2 &amp;ndash; Variables</source>
          <target state="translated">3.2 - Переменные</target>
        </trans-unit>
        <trans-unit id="831eca58ed9634bf35d286b0652dd764c6225329" translate="yes" xml:space="preserve">
          <source>3.3 &amp;ndash; Statements</source>
          <target state="translated">3.3 - Заявления</target>
        </trans-unit>
        <trans-unit id="b9b8530dd3439338077cae5d9a81b0f8388246f9" translate="yes" xml:space="preserve">
          <source>3.3.1 &amp;ndash; Blocks</source>
          <target state="translated">3.3.1 - Блоки</target>
        </trans-unit>
        <trans-unit id="249018398e87db611b2f382c32e3c2029e7a3362" translate="yes" xml:space="preserve">
          <source>3.3.2 &amp;ndash; Chunks</source>
          <target state="translated">3.3.2 - Чанки</target>
        </trans-unit>
        <trans-unit id="93fdc1a5227f5f767eda4b33118ca26d4d3ec98f" translate="yes" xml:space="preserve">
          <source>3.3.3 &amp;ndash; Assignment</source>
          <target state="translated">3.3.3 - Назначение</target>
        </trans-unit>
        <trans-unit id="60ea5bc043174dd66add3628579020e9fd6149ea" translate="yes" xml:space="preserve">
          <source>3.3.4 &amp;ndash; Control Structures</source>
          <target state="translated">3.3.4 - Структуры управления</target>
        </trans-unit>
        <trans-unit id="b4e38214a26cbc13913d45fcdc42571b93281b8f" translate="yes" xml:space="preserve">
          <source>3.3.5 &amp;ndash; For Statement</source>
          <target state="translated">3.3.5 - Для заявления</target>
        </trans-unit>
        <trans-unit id="1f046a545135d5e9e1e65842299b34f6b36157ac" translate="yes" xml:space="preserve">
          <source>3.3.6 &amp;ndash; Function Calls as Statements</source>
          <target state="translated">3.3.6 - Вызов функций как утверждения</target>
        </trans-unit>
        <trans-unit id="19a6d2647263682fe5a7621ae89477d702d33727" translate="yes" xml:space="preserve">
          <source>3.3.7 &amp;ndash; Local Declarations</source>
          <target state="translated">3.3.7 - Местные объявления</target>
        </trans-unit>
        <trans-unit id="ac56f78d28bb6bfafede4821e374042b6d5ded3c" translate="yes" xml:space="preserve">
          <source>3.4 &amp;ndash; Expressions</source>
          <target state="translated">3.4 - Выражения</target>
        </trans-unit>
        <trans-unit id="11859fef39e3ab01288c6dd79b5e2b11fdad4c8d" translate="yes" xml:space="preserve">
          <source>3.4.1 &amp;ndash; Arithmetic Operators</source>
          <target state="translated">3.4.1 - Арифметические операторы</target>
        </trans-unit>
        <trans-unit id="5ba9603d3900196b96bc99dd68bef5ea214ec46d" translate="yes" xml:space="preserve">
          <source>3.4.10 &amp;ndash; Function Calls</source>
          <target state="translated">3.4.10 - Вызов функций</target>
        </trans-unit>
        <trans-unit id="d521e09f296fb652ca685e9986c89365b3a3a60e" translate="yes" xml:space="preserve">
          <source>3.4.11 &amp;ndash; Function Definitions</source>
          <target state="translated">3.4.11 - Определения функций</target>
        </trans-unit>
        <trans-unit id="0767b1e410d6366522683c5dea029dba330f750e" translate="yes" xml:space="preserve">
          <source>3.4.2 &amp;ndash; Bitwise Operators</source>
          <target state="translated">3.4.2 - Побитовые операторы</target>
        </trans-unit>
        <trans-unit id="7fcc429ce74b3bad7b171ca68ce6278ebc43bae9" translate="yes" xml:space="preserve">
          <source>3.4.3 &amp;ndash; Coercions and Conversions</source>
          <target state="translated">3.4.3 - Принуждение и преобразования</target>
        </trans-unit>
        <trans-unit id="a5cfc763ebbbdbc2d383f04e2795f848e29252e2" translate="yes" xml:space="preserve">
          <source>3.4.4 &amp;ndash; Relational Operators</source>
          <target state="translated">3.4.4 - Операторы отношения</target>
        </trans-unit>
        <trans-unit id="0813780c5158e7059551f2d8bd071c10fcd64a1e" translate="yes" xml:space="preserve">
          <source>3.4.5 &amp;ndash; Logical Operators</source>
          <target state="translated">3.4.5 - Логические операторы</target>
        </trans-unit>
        <trans-unit id="053f15c92c03eee025a09cbef6910c4913cf9628" translate="yes" xml:space="preserve">
          <source>3.4.6 &amp;ndash; Concatenation</source>
          <target state="translated">3.4.6 - Конкатенация</target>
        </trans-unit>
        <trans-unit id="48ea8196506d47e56086f0bd779ad133e81d539a" translate="yes" xml:space="preserve">
          <source>3.4.7 &amp;ndash; The Length Operator</source>
          <target state="translated">3.4.7 - Оператор длины</target>
        </trans-unit>
        <trans-unit id="b77361dfb2f580a09634468b4a92c293c9a90987" translate="yes" xml:space="preserve">
          <source>3.4.8 &amp;ndash; Precedence</source>
          <target state="translated">3.4.8 - Приоритет</target>
        </trans-unit>
        <trans-unit id="1716010a5bdaeeaa519496e7998b4394c6b17b0d" translate="yes" xml:space="preserve">
          <source>3.4.9 &amp;ndash; Table Constructors</source>
          <target state="translated">3.4.9 - Конструкторы таблиц</target>
        </trans-unit>
        <trans-unit id="c20fcbea7777ae7db816c4f7863db3c7e76c4be7" translate="yes" xml:space="preserve">
          <source>3.5 &amp;ndash; Visibility Rules</source>
          <target state="translated">3.5 - Правила видимости</target>
        </trans-unit>
        <trans-unit id="dd63ac66a4ed838d368dd76236f0026ba6aee449" translate="yes" xml:space="preserve">
          <source>4 &amp;ndash; The Application Program Interface</source>
          <target state="translated">4 - Интерфейс прикладной программы</target>
        </trans-unit>
        <trans-unit id="f79922b6ade2d7cb13fd986a703b2a74313e769b" translate="yes" xml:space="preserve">
          <source>4.1 &amp;ndash; The Stack</source>
          <target state="translated">4.1 - Стек</target>
        </trans-unit>
        <trans-unit id="5b51906b5985deb44043d8f246cfc18dd2ae60aa" translate="yes" xml:space="preserve">
          <source>4.2 &amp;ndash; Stack Size</source>
          <target state="translated">4.2 - Размер стека</target>
        </trans-unit>
        <trans-unit id="31b2949d1c9fcdf122a9e531b559332da4485f80" translate="yes" xml:space="preserve">
          <source>4.3 &amp;ndash; Valid and Acceptable Indices</source>
          <target state="translated">4.3 - Действительные и приемлемые индексы</target>
        </trans-unit>
        <trans-unit id="74f0c5c5ee47538264fae29f7657133d0d699462" translate="yes" xml:space="preserve">
          <source>4.4 &amp;ndash; C Closures</source>
          <target state="translated">4.4 - Закрытие C</target>
        </trans-unit>
        <trans-unit id="dc6aa4af1e5cbd9bad1a034dc03de85dd86ad779" translate="yes" xml:space="preserve">
          <source>4.5 &amp;ndash; Registry</source>
          <target state="translated">4.5 - Реестр</target>
        </trans-unit>
        <trans-unit id="d8452600dbf3930156ccc218b4b4ddb69035a3ec" translate="yes" xml:space="preserve">
          <source>4.6 &amp;ndash; Error Handling in C</source>
          <target state="translated">4.6 - Обработка ошибок в C</target>
        </trans-unit>
        <trans-unit id="275ecb37e4e88aebd92acb558147bf849a62c9bb" translate="yes" xml:space="preserve">
          <source>4.7 &amp;ndash; Handling Yields in C</source>
          <target state="translated">4.7 - Обработка урожайности в C</target>
        </trans-unit>
        <trans-unit id="bd1985494a7c3d7d1062380e781037ccb1f14dbf" translate="yes" xml:space="preserve">
          <source>4.8 &amp;ndash; Functions and Types[-o, +p, &lt;em&gt;x&lt;/em&gt;]</source>
          <target state="translated">4.8 - Функции и типы [-o, + p, &lt;em&gt;x&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="fd295b2094f1a31a0f8f4e3c5ef5c7874f795c82" translate="yes" xml:space="preserve">
          <source>4.9 &amp;ndash; The Debug Interface</source>
          <target state="translated">4.9 - Интерфейс отладки</target>
        </trans-unit>
        <trans-unit id="7ad85d079aa056f3c063c288f0c0093ca0f6c73d" translate="yes" xml:space="preserve">
          <source>5 &amp;ndash; The Auxiliary Library</source>
          <target state="translated">5 - Вспомогательная библиотека</target>
        </trans-unit>
        <trans-unit id="71d57e32825e907432cc4adf35e23a77ed97c0a2" translate="yes" xml:space="preserve">
          <source>5.1 &amp;ndash; Functions and Types</source>
          <target state="translated">5.1 - Функции и типы</target>
        </trans-unit>
        <trans-unit id="92cc3da65a13c96c43af92f1e98bfede2f153c83" translate="yes" xml:space="preserve">
          <source>6 &amp;ndash; Standard Libraries</source>
          <target state="translated">6 - Стандартные библиотеки</target>
        </trans-unit>
        <trans-unit id="c1cf8fe5aceb71994bc78f0adf755277b6681f00" translate="yes" xml:space="preserve">
          <source>6.1 &amp;ndash; Basic Functions</source>
          <target state="translated">6.1 - Основные функции</target>
        </trans-unit>
        <trans-unit id="6e24ce31a4d8a8b2c4bf3eaf4c953e980b335967" translate="yes" xml:space="preserve">
          <source>6.10 &amp;ndash; The Debug Library</source>
          <target state="translated">6.10 - Библиотека отладки</target>
        </trans-unit>
        <trans-unit id="03d2065bb3d3315a8c459cb76f8c692d4aabb3b3" translate="yes" xml:space="preserve">
          <source>6.2 &amp;ndash; Coroutine Manipulation</source>
          <target state="translated">6.2 - Манипуляции с сопрограммами</target>
        </trans-unit>
        <trans-unit id="7ab3ec70bbfde06cb8aacd9d27858f73840ca3e6" translate="yes" xml:space="preserve">
          <source>6.3 &amp;ndash; Modules</source>
          <target state="translated">6.3 - Модули</target>
        </trans-unit>
        <trans-unit id="1a9e8fe3268257be8690631f66b150e7b529fa25" translate="yes" xml:space="preserve">
          <source>6.4 &amp;ndash; String Manipulation</source>
          <target state="translated">6.4 - Манипуляции со строками</target>
        </trans-unit>
        <trans-unit id="c32244a851c4ca4fbd524d465d9ac63a62295558" translate="yes" xml:space="preserve">
          <source>6.4.1 &amp;ndash; Patterns</source>
          <target state="translated">6.4.1 - Паттерны</target>
        </trans-unit>
        <trans-unit id="117f4fd92a6a3918b099c684ab382f396d5eb6a0" translate="yes" xml:space="preserve">
          <source>6.4.2 &amp;ndash; Format Strings for Pack and Unpack</source>
          <target state="translated">6.4.2 - Форматные строки для упаковки и распаковки</target>
        </trans-unit>
        <trans-unit id="2c69cea016f7e6620297e4c1a14aee86bca54a5d" translate="yes" xml:space="preserve">
          <source>6.5 &amp;ndash; UTF-8 Support</source>
          <target state="translated">6.5 - Поддержка UTF-8</target>
        </trans-unit>
        <trans-unit id="63cc5647192e9aeb780e978b92120a1f45dd2739" translate="yes" xml:space="preserve">
          <source>6.6 &amp;ndash; Table Manipulation</source>
          <target state="translated">6.6 - Манипуляции с таблицей</target>
        </trans-unit>
        <trans-unit id="c32e233273be58074db0281b90ff78f133dadaa9" translate="yes" xml:space="preserve">
          <source>6.7 &amp;ndash; Mathematical Functions</source>
          <target state="translated">6.7 - Математические функции</target>
        </trans-unit>
        <trans-unit id="832907e7e19406cf81191180275a0cb50dea430b" translate="yes" xml:space="preserve">
          <source>6.8 &amp;ndash; Input and Output Facilities</source>
          <target state="translated">6.8 - Средства ввода и вывода</target>
        </trans-unit>
        <trans-unit id="cb34b15416a677114058591f5dd2c4ae7287d44b" translate="yes" xml:space="preserve">
          <source>6.9 &amp;ndash; Operating System Facilities</source>
          <target state="translated">6.9 - Средства операционной системы</target>
        </trans-unit>
        <trans-unit id="392af5f262337c8a47dea77fc574c5980a74525f" translate="yes" xml:space="preserve">
          <source>7 &amp;ndash; Lua Standalone</source>
          <target state="translated">7 - Автономный Lua</target>
        </trans-unit>
        <trans-unit id="8f903b288c9e6ac2b63f9c5ac1ae4e51b0452d1a" translate="yes" xml:space="preserve">
          <source>8 &amp;ndash; Incompatibilities with the Previous Version</source>
          <target state="translated">8 - Несовместимость с предыдущей версией</target>
        </trans-unit>
        <trans-unit id="3f8999c0013347303415ee512a5929d88176001f" translate="yes" xml:space="preserve">
          <source>8.1 &amp;ndash; Changes in the Language</source>
          <target state="translated">8.1 - Изменения в языке</target>
        </trans-unit>
        <trans-unit id="9e15fa697b4f86446516c25786580893e59e6a10" translate="yes" xml:space="preserve">
          <source>8.2 &amp;ndash; Changes in the Libraries</source>
          <target state="translated">8.2 - Изменения в библиотеках</target>
        </trans-unit>
        <trans-unit id="d089e3545870977ceda5c673010988a582c7e893" translate="yes" xml:space="preserve">
          <source>8.3 &amp;ndash; Changes in the API</source>
          <target state="translated">8.3 - Изменения в API</target>
        </trans-unit>
        <trans-unit id="d31e9eb94987aca4e6da693733376a5662dabd38" translate="yes" xml:space="preserve">
          <source>9 &amp;ndash; The Complete Syntax of Lua</source>
          <target state="translated">9 - Полный синтаксис Lua</target>
        </trans-unit>
        <trans-unit id="81d3ce176f56748de5e1f64f56afa6b88a0919fc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt; pushes the variable's value onto the stack and returns its name.</source>
          <target state="translated">&lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; помещает&lt;/a&gt; значение переменной в стек и возвращает ее имя.</target>
        </trans-unit>
        <trans-unit id="997a4ac3078b35c85f1fb0a338e5857990690995" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRGCMM&quot;&gt;&lt;code&gt;LUA_ERRGCMM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running a &lt;code&gt;__gc&lt;/code&gt; metamethod. (This error has no relation with the chunk being loaded. It is generated by the garbage collector.)</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRGCMM&quot;&gt; &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;ошибка при запуске &lt;code&gt;__gc&lt;/code&gt; . (Эта ошибка не имеет отношения к загружаемому фрагменту. Она создается сборщиком мусора.)</target>
        </trans-unit>
        <trans-unit id="0a62e7bf056e6b28156f4c231057917eae3f721a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; memory allocation (out-of-memory) error;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; &lt;/a&gt; : ошибка&lt;/b&gt; выделения памяти (&lt;b&gt; нехватка&lt;/b&gt; памяти);</target>
        </trans-unit>
        <trans-unit id="bb87b0a3626f8ed024c6ec50e4a5a62da84f1ba0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; no errors;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;ошибок нет;</target>
        </trans-unit>
        <trans-unit id="39a5a19fe9e5d2de47a8c090156531e8d630b23d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRERR&quot;&gt;&lt;code&gt;LUA_ERRERR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running the message handler.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRERR&quot;&gt; &lt;code&gt;LUA_ERRERR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;ошибка при запуске обработчика сообщений.</target>
        </trans-unit>
        <trans-unit id="58785899340ce91e0de9aca15120aa7cff3c9758" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRGCMM&quot;&gt;&lt;code&gt;LUA_ERRGCMM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running a &lt;code&gt;__gc&lt;/code&gt; metamethod. For such errors, Lua does not call the message handler (as this kind of error typically has no relation with the function being called).</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRGCMM&quot;&gt; &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;ошибка при запуске &lt;code&gt;__gc&lt;/code&gt; . Для таких ошибок Lua не вызывает обработчик сообщений (поскольку такого рода ошибки обычно не имеют отношения к вызываемой функции).</target>
        </trans-unit>
        <trans-unit id="0513936f3247fabebe04e7758e5c7c600069b199" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; memory allocation error. For such errors, Lua does not call the message handler.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;ошибка выделения памяти. Для таких ошибок Lua не вызывает обработчик сообщений.</target>
        </trans-unit>
        <trans-unit id="6d5a47c8aea539962fb70e275409743f8d4b5c7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRRUN&quot;&gt;&lt;code&gt;LUA_ERRRUN&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; a runtime error.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRRUN&quot;&gt; &lt;code&gt;LUA_ERRRUN&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;ошибка времени выполнения.</target>
        </trans-unit>
        <trans-unit id="d3a51e900c7e297ae9668bf44b0828218aa58bb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt;&lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; syntax error during precompilation;</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt; &lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;синтаксическая ошибка во время предварительной компиляции;</target>
        </trans-unit>
        <trans-unit id="069ddb6d3068bf3edc5b7f77df2372cab0d8f9ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (0): &lt;/b&gt; success.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; (0):&lt;/b&gt;успех.</target>
        </trans-unit>
        <trans-unit id="3ec3be0613ea3827ce544ed885c9f84ec41464e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPADD&quot;&gt;&lt;code&gt;LUA_OPADD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs addition (&lt;code&gt;+&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPADD&quot;&gt; &lt;code&gt;LUA_OPADD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет сложение ( &lt;code&gt;+&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6c814447a9527d908c1ce86da63fcae3cd57025f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBAND&quot;&gt;&lt;code&gt;LUA_OPBAND&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBAND&quot;&gt; &lt;code&gt;LUA_OPBAND&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет побитовое И ( &lt;code&gt;&amp;amp;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b84c3f3596e3f23015f094f8174ece0ce3d795e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBNOT&quot;&gt;&lt;code&gt;LUA_OPBNOT&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise NOT (&lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBNOT&quot;&gt; &lt;code&gt;LUA_OPBNOT&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;побитовое НЕ ( &lt;code&gt;~&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aa756b6d2d7eef20df16036a246330397dc748b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBOR&quot;&gt;&lt;code&gt;LUA_OPBOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise OR (&lt;code&gt;|&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBOR&quot;&gt; &lt;code&gt;LUA_OPBOR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет побитовое ИЛИ ( &lt;code&gt;|&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cadd32314c831b1dd6807904ee89f82906c6a5d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBXOR&quot;&gt;&lt;code&gt;LUA_OPBXOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise exclusive OR (&lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBXOR&quot;&gt; &lt;code&gt;LUA_OPBXOR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет побитовое исключающее ИЛИ ( &lt;code&gt;~&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0120c4dc4899ecd53a28bb0567448d1dfc295a55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPDIV&quot;&gt;&lt;code&gt;LUA_OPDIV&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs float division (&lt;code&gt;/&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPDIV&quot;&gt; &lt;code&gt;LUA_OPDIV&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет деление с плавающей запятой ( &lt;code&gt;/&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="297add48d11993decc4e07fa953033476d1943cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPEQ&quot;&gt;&lt;code&gt;LUA_OPEQ&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for equality (&lt;code&gt;==&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPEQ&quot;&gt; &lt;code&gt;LUA_OPEQ&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;сравнивает на равенство ( &lt;code&gt;==&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6ad36382d905550ab53f7c8b67e61d620b311419" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPIDIV&quot;&gt;&lt;code&gt;LUA_OPIDIV&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs floor division (&lt;code&gt;//&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPIDIV&quot;&gt; &lt;code&gt;LUA_OPIDIV&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет разделение этажа ( &lt;code&gt;//&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="65b04a9f94a548d3eb547be608241aacea9320cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLE&quot;&gt;&lt;code&gt;LUA_OPLE&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for less or equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLE&quot;&gt; &lt;code&gt;LUA_OPLE&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;сравнивает меньше или равно ( &lt;code&gt;&amp;lt;=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="475bd49677a764ed78bc57bf43886acf09d7bdab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLT&quot;&gt;&lt;code&gt;LUA_OPLT&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for less than (&lt;code&gt;&amp;lt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLT&quot;&gt; &lt;code&gt;LUA_OPLT&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;сравнивает меньше чем ( &lt;code&gt;&amp;lt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d59eb3b1ef4b950e8399516c5f783e0f11e809c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMOD&quot;&gt;&lt;code&gt;LUA_OPMOD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs modulo (&lt;code&gt;%&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMOD&quot;&gt; &lt;code&gt;LUA_OPMOD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет по модулю ( &lt;code&gt;%&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3be2f129960c9b22d8bed03fc870c9ddeb0d44a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMUL&quot;&gt;&lt;code&gt;LUA_OPMUL&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs multiplication (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMUL&quot;&gt; &lt;code&gt;LUA_OPMUL&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет умножение ( &lt;code&gt;*&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0df86847b8617d3071f5659dea048400514522e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPPOW&quot;&gt;&lt;code&gt;LUA_OPPOW&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs exponentiation (&lt;code&gt;^&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPPOW&quot;&gt; &lt;code&gt;LUA_OPPOW&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;возведение в степень ( &lt;code&gt;^&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5d397dbd765f0534ad52cb6ff558ee4e7202a360" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHL&quot;&gt;&lt;code&gt;LUA_OPSHL&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHL&quot;&gt; &lt;code&gt;LUA_OPSHL&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет сдвиг влево ( &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a57f78cb55bc79c59850850886b07440785fc250" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHR&quot;&gt;&lt;code&gt;LUA_OPSHR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHR&quot;&gt; &lt;code&gt;LUA_OPSHR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет сдвиг вправо ( &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5a256a2902d1801dfd4b235ec7de48d549ccf5af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSUB&quot;&gt;&lt;code&gt;LUA_OPSUB&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs subtraction (&lt;code&gt;-&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSUB&quot;&gt; &lt;code&gt;LUA_OPSUB&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет вычитание ( &lt;code&gt;-&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0079ed2e4b11f9492f31692fe85400731bec09ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPUNM&quot;&gt;&lt;code&gt;LUA_OPUNM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs mathematical negation (unary &lt;code&gt;-&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPUNM&quot;&gt; &lt;code&gt;LUA_OPUNM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;выполняет математическое отрицание (унарный &lt;code&gt;-&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="490be7142f1b450637c62dce5134a58b5b7cd4c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_GLOBALS&quot;&gt;&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; At this index the registry has the global environment.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_GLOBALS&quot;&gt; &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; &lt;/a&gt; : в&lt;/b&gt;этом индексе реестр имеет глобальную среду.</target>
        </trans-unit>
        <trans-unit id="67692b9acd7ece42dccee1c401f83f0322c87845" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_MAINTHREAD&quot;&gt;&lt;code&gt;LUA_RIDX_MAINTHREAD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; At this index the registry has the main thread of the state. (The main thread is the one created together with the state.)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_MAINTHREAD&quot;&gt; &lt;code&gt;LUA_RIDX_MAINTHREAD&lt;/code&gt; &lt;/a&gt; : по&lt;/b&gt;этому индексу в реестре есть главный поток состояния. (Основной поток создается вместе с состоянием.)</target>
        </trans-unit>
        <trans-unit id="3ad03bfffa23a0e90024b5cb186d8482335efd71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;em&gt;number&lt;/em&gt;: &lt;/b&gt; reads a string with up to this number of bytes, returning &lt;b&gt;nil&lt;/b&gt; on end of file. If &lt;code&gt;number&lt;/code&gt; is zero, it reads nothing and returns an empty string, or &lt;b&gt;nil&lt;/b&gt; on end of file.</source>
          <target state="translated">&lt;b&gt;&lt;em&gt;число&lt;/em&gt; :&lt;/b&gt; читает строку до этого числа байтов, возвращая&lt;b&gt; ноль&lt;/b&gt; в конце файла. Если &lt;code&gt;number&lt;/code&gt; равно нулю, он ничего не читает и возвращает пустую строку или&lt;b&gt; ноль&lt;/b&gt; в конце файла.</target>
        </trans-unit>
        <trans-unit id="2a0c3c0bea2d7e7832082339aece729a1babeddb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;em&gt;x&lt;/em&gt;: &lt;/b&gt; (where &lt;em&gt;x&lt;/em&gt; is not one of the &lt;em&gt;magic characters&lt;/em&gt;&lt;code&gt;^$()%.[]*+-?&lt;/code&gt;) represents the character &lt;em&gt;x&lt;/em&gt; itself.</source>
          <target state="translated">&lt;b&gt;&lt;em&gt;x&lt;/em&gt; :&lt;/b&gt; (где&lt;em&gt; x&lt;/em&gt; не является одним из&lt;em&gt; волшебных символов &lt;/em&gt; &lt;code&gt;^$()%.[]*+-?&lt;/code&gt; ) представляет сам символ&lt;em&gt; x&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3d2c4186a84e56cd4d03c088b58a9fb64d00944f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The call hook: &lt;/b&gt; is called when the interpreter calls a function. The hook is called just after Lua enters the new function, before the function gets its arguments.</source>
          <target state="translated">&lt;b&gt;Ловушка вызова:&lt;/b&gt; вызывается, когда интерпретатор вызывает функцию. Хук вызывается сразу после того, как Lua входит в новую функцию, до того, как функция получит свои аргументы.</target>
        </trans-unit>
        <trans-unit id="3586bc19f491f63ef8c6fbe8267e796599c9d56a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The count hook: &lt;/b&gt; is called after the interpreter executes every &lt;code&gt;count&lt;/code&gt; instructions. (This event only happens while Lua is executing a Lua function.)</source>
          <target state="translated">&lt;b&gt;Ловушка счетчика:&lt;/b&gt; вызывается после того, как интерпретатор выполняет все инструкции &lt;code&gt;count&lt;/code&gt; . (Это событие происходит только тогда, когда Lua выполняет функцию Lua.)</target>
        </trans-unit>
        <trans-unit id="dc132bdb212730eeb73d3b168b816f3020c8283b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The line hook: &lt;/b&gt; is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.)</source>
          <target state="translated">&lt;b&gt;Перехватчик строки:&lt;/b&gt; вызывается, когда интерпретатор собирается начать выполнение новой строки кода или когда он возвращается в код (даже на ту же строку). (Это событие происходит только тогда, когда Lua выполняет функцию Lua.)</target>
        </trans-unit>
        <trans-unit id="b0512dd920d52edfa2ad49b9db0251dfbc206479" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The return hook: &lt;/b&gt; is called when the interpreter returns from a function. The hook is called just before Lua leaves the function. There is no standard way to access the values to be returned by the function.</source>
          <target state="translated">&lt;b&gt;Ловушка возврата:&lt;/b&gt; вызывается, когда интерпретатор возвращается из функции. Хук вызывается непосредственно перед тем, как Lua покидает функцию. Не существует стандартного способа доступа к значениям, возвращаемым функцией.</target>
        </trans-unit>
        <trans-unit id="8805e2bcd652fa518016fd2d76cf56a7869fb8f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;![&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: sets maximum alignment to &lt;code&gt;n&lt;/code&gt; (default is native alignment)</source>
          <target state="translated">&lt;code&gt;![&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : устанавливает максимальное выравнивание равным &lt;code&gt;n&lt;/code&gt; (по умолчанию - собственное выравнивание)</target>
        </trans-unit>
        <trans-unit id="3acec99eacd1af7f2ca649aaae893e3003aadfa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;/code&gt;: modulo</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; : по модулю</target>
        </trans-unit>
        <trans-unit id="6309f6de64785e493ad21fb0175b5bdc8f6ad525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;, for &lt;em&gt;n&lt;/em&gt; between 1 and 9; such item matches a substring equal to the &lt;em&gt;n&lt;/em&gt;-th captured string (see below);</source>
          <target state="translated">&lt;code&gt;%&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; для &lt;em&gt;n&lt;/em&gt; от 1 до 9; такой элемент соответствует подстроке, равной &lt;em&gt;n&lt;/em&gt; -й захваченной строке (см. ниже);</target>
        </trans-unit>
        <trans-unit id="f20e837008e6cbff5b2ce584f8dd66b1ebff0267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt;:  (where &lt;em&gt;x&lt;/em&gt; is any non-alphanumeric character) represents the character &lt;em&gt;x&lt;/em&gt;. This is the standard way to escape the magic characters. Any non-alphanumeric character (including all punctuation characters, even the non-magical) can be preceded by a '&lt;code&gt;%&lt;/code&gt;' when used to represent itself in a pattern.</source>
          <target state="translated">&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt; : (где &lt;em&gt;x&lt;/em&gt; - любой не буквенно-цифровой символ) представляет символ &lt;em&gt;x&lt;/em&gt; . Это стандартный способ убежать от волшебных персонажей. Любому не буквенно-цифровому символу (включая все знаки препинания, даже немагические) может предшествовать &quot; &lt;code&gt;%&lt;/code&gt; &quot;, когда он используется для представления себя в шаблоне.</target>
        </trans-unit>
        <trans-unit id="e54e56bd80af5958ec4c201065fe5778f27f86df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%a&lt;/code&gt;:  represents all letters.</source>
          <target state="translated">&lt;code&gt;%a&lt;/code&gt; : представляет все буквы.</target>
        </trans-unit>
        <trans-unit id="cbfe0af04bd3d02f8310cc2561a3ed583449532b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%b&lt;em&gt;xy&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are two distinct characters; such item matches strings that start with &lt;em&gt;x&lt;/em&gt;, end with &lt;em&gt;y&lt;/em&gt;, and where the &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are &lt;em&gt;balanced&lt;/em&gt;. This means that, if one reads the string from left to right, counting &lt;em&gt;+1&lt;/em&gt; for an &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;-1&lt;/em&gt; for a &lt;em&gt;y&lt;/em&gt;, the ending &lt;em&gt;y&lt;/em&gt; is the first &lt;em&gt;y&lt;/em&gt; where the count reaches 0. For instance, the item &lt;code&gt;%b()&lt;/code&gt; matches expressions with balanced parentheses.</source>
          <target state="translated">&lt;code&gt;%b&lt;em&gt;xy&lt;/em&gt;&lt;/code&gt; , где &lt;em&gt;x&lt;/em&gt; и &lt;em&gt;y&lt;/em&gt; - два разных символа; Такой элемент соответствует строкам , которые начинаются с &lt;em&gt;й&lt;/em&gt; , с концом &lt;em&gt;у&lt;/em&gt; , и где &lt;em&gt;х&lt;/em&gt; и &lt;em&gt;у&lt;/em&gt; являются &lt;em&gt;сбалансированы&lt;/em&gt; . Это означает, что если кто-то читает строку слева направо, считая &lt;em&gt;+1&lt;/em&gt; для &lt;em&gt;x&lt;/em&gt; и &lt;em&gt;-1&lt;/em&gt; для &lt;em&gt;y&lt;/em&gt; , окончание &lt;em&gt;y&lt;/em&gt; будет первым &lt;em&gt;y,&lt;/em&gt; где счет достигает 0. Например, элемент &lt;code&gt;%b()&lt;/code&gt; соответствует выражения со сбалансированными круглыми скобками.</target>
        </trans-unit>
        <trans-unit id="3de9b6ffd559dcc163f65726d138b7349ce95ff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%c&lt;/code&gt;:  represents all control characters.</source>
          <target state="translated">&lt;code&gt;%c&lt;/code&gt; : представляет все управляющие символы.</target>
        </trans-unit>
        <trans-unit id="b8ad684e3be8e7587d3c8ce155f426f377443ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%d&lt;/code&gt;:  represents all digits.</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; : представляет все цифры.</target>
        </trans-unit>
        <trans-unit id="a6f3e3f52646f53a60bfe00b2ff656a09e89a4a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%f[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;, a &lt;em&gt;frontier pattern&lt;/em&gt;; such item matches an empty string at any position such that the next character belongs to &lt;em&gt;set&lt;/em&gt; and the previous character does not belong to &lt;em&gt;set&lt;/em&gt;. The set &lt;em&gt;set&lt;/em&gt; is interpreted as previously described. The beginning and the end of the subject are handled as if they were the character '&lt;code&gt;\0&lt;/code&gt;'.</source>
          <target state="translated">&lt;code&gt;%f[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; , &lt;em&gt;образец границы&lt;/em&gt; ; такой элемент соответствует пустой строке в любой позиции, так что следующий символ принадлежит &lt;em&gt;набору,&lt;/em&gt; а предыдущий символ не принадлежит &lt;em&gt;набору&lt;/em&gt; . Набор &lt;em&gt;набор&lt;/em&gt; интерпретируется , как описано ранее. Начало и конец темы обрабатываются так, как если бы они были символом ' &lt;code&gt;\0&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="d1068a849784cb8f30e250147da15aaa395b0729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%g&lt;/code&gt;:  represents all printable characters except space.</source>
          <target state="translated">&lt;code&gt;%g&lt;/code&gt; : представляет все печатаемые символы, кроме пробела.</target>
        </trans-unit>
        <trans-unit id="b46f710e58e77aaa525ff9403405ff161c474587" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%l&lt;/code&gt;:  represents all lowercase letters.</source>
          <target state="translated">&lt;code&gt;%l&lt;/code&gt; : представляет все буквы нижнего регистра.</target>
        </trans-unit>
        <trans-unit id="00faa1ce628bd5bbd5ebfc1430bf64ce8032b2e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%p&lt;/code&gt;:  represents all punctuation characters.</source>
          <target state="translated">&lt;code&gt;%p&lt;/code&gt; : представляет все символы пунктуации.</target>
        </trans-unit>
        <trans-unit id="409154041b5a8377f4c4a43f5e7a2daca1efae16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%s&lt;/code&gt;:  represents all space characters.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; : представляет все символы пробела.</target>
        </trans-unit>
        <trans-unit id="1d077077eba594eeb532db5bbbb344383bb9dc30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%u&lt;/code&gt;:  represents all uppercase letters.</source>
          <target state="translated">&lt;code&gt;%u&lt;/code&gt; : представляет все буквы в верхнем регистре.</target>
        </trans-unit>
        <trans-unit id="c778e1666515254950019edcc8b53bc7994b2c06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%w&lt;/code&gt;:  represents all alphanumeric characters.</source>
          <target state="translated">&lt;code&gt;%w&lt;/code&gt; : представляет все буквенно-цифровые символы.</target>
        </trans-unit>
        <trans-unit id="9d32033a43bf5e4d6d3a33f3c31f104d598f06a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%x&lt;/code&gt;:  represents all hexadecimal digits.</source>
          <target state="translated">&lt;code&gt;%x&lt;/code&gt; : представляет все шестнадцатеричные цифры.</target>
        </trans-unit>
        <trans-unit id="321eb4eafd66d05c141a030945ca6e42e18477a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;: bitwise AND</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; : побитовое И</target>
        </trans-unit>
        <trans-unit id="8997dce827f9650de2681505f986bfe4f56868cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;: right shift</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; : сдвиг вправо</target>
        </trans-unit>
        <trans-unit id="09075062c64c86a8670a7f150b47a6e95e038431" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: greater than</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; : больше чем</target>
        </trans-unit>
        <trans-unit id="4cf6b41db6ebd22069687677e294b12324a1aa22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: sets big endian</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; : устанавливает прямой порядок байтов</target>
        </trans-unit>
        <trans-unit id="84aa2a09e22da5344a9e8eb1d63a625c2e6ab9d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=&lt;/code&gt;: greater or equal</source>
          <target state="translated">&lt;code&gt;&amp;gt;=&lt;/code&gt; : больше или равно</target>
        </trans-unit>
        <trans-unit id="e1e0a0e88d4b268783cec444b7830a1c8a905396" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;: left shift</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; : сдвиг влево</target>
        </trans-unit>
        <trans-unit id="64760ee63a8e109d429eec539c3225463668a5c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: less than</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; : меньше чем</target>
        </trans-unit>
        <trans-unit id="0dc1199995acf8e834d1133c3d0ffe757a0c8c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: sets little endian</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; : устанавливает прямой порядок байтов</target>
        </trans-unit>
        <trans-unit id="539e9a1a68d56527181e6fda1757b93c7bb90872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;=&lt;/code&gt;: less or equal</source>
          <target state="translated">&lt;code&gt;&amp;lt;=&lt;/code&gt; : меньше или равно</target>
        </trans-unit>
        <trans-unit id="d93e49b81b005f7b70f3e457112527bfdf5d8afa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt;: multiplication</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; : умножение</target>
        </trans-unit>
        <trans-unit id="5a896065ff143b8d4e4525f134563235b2836309" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt;: addition</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; : сложение</target>
        </trans-unit>
        <trans-unit id="6e690d325ab205c7e3e2edc33dded7238d1e95e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt;:  stops handling options;</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; : прекращает обработку опций;</target>
        </trans-unit>
        <trans-unit id="7e30ca421360d9668078533affe3127fefa56922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;:  executes &lt;code&gt;stdin&lt;/code&gt; as a file and stops handling options.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : выполняет стандартный &lt;code&gt;stdin&lt;/code&gt; как файл и прекращает обработку параметров.</target>
        </trans-unit>
        <trans-unit id="fe732ff63697204d0a3854b3dd684f5776ef0028" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;: subtraction</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : вычитание</target>
        </trans-unit>
        <trans-unit id="769def5a060686cf3ed3fab103466f33fde9d1c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;: unary minus</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : унарный минус</target>
        </trans-unit>
        <trans-unit id="a62c9dea412713fabd70b0572ce384a36c8975a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-E&lt;/code&gt;:  ignores environment variables;</source>
          <target state="translated">&lt;code&gt;-E&lt;/code&gt; : игнорирует переменные окружения;</target>
        </trans-unit>
        <trans-unit id="666a8ef269cc241ff9e08c8b6b13c312ec6e0985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt;:  executes string &lt;em&gt;stat&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt; : выполняет строку &lt;em&gt;stat&lt;/em&gt; ;</target>
        </trans-unit>
        <trans-unit id="c08ce0d22173d753a71a183348f5899d3deb6286" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-i&lt;/code&gt;:  enters interactive mode after running &lt;em&gt;script&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; : входит в интерактивный режим после запуска &lt;em&gt;скрипта&lt;/em&gt; ;</target>
        </trans-unit>
        <trans-unit id="dacf10d39c10471335c9d03c807dc8f228a1a26f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt;:  &quot;requires&quot; &lt;em&gt;mod&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt; : &quot;требуется&quot; &lt;em&gt;мод&lt;/em&gt; ;</target>
        </trans-unit>
        <trans-unit id="0bb7b2827bd9676bf04daa9b6241bf4c4b937a87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-v&lt;/code&gt;:  prints version information;</source>
          <target state="translated">&lt;code&gt;-v&lt;/code&gt; : выводит информацию о версии;</target>
        </trans-unit>
        <trans-unit id="380d1b565924cf193969bb6016e909adf7faad53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.&lt;/code&gt;:  (a dot) represents all characters.</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; : (точка) представляет все символы.</target>
        </trans-unit>
        <trans-unit id="29471d9e07752a02a646c75289cc2200ed687ca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;//&lt;/code&gt;: floor division</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; : разделение этажей</target>
        </trans-unit>
        <trans-unit id="e74818859a32b3c68f9a537da22031801f01b845" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&lt;/code&gt;: float division</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; : деление с плавающей запятой</target>
        </trans-unit>
        <trans-unit id="61efe208b861a62c6b51bce3253be1558c21c997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;explist&lt;/em&gt;&lt;/code&gt; is evaluated only once. Its results are an &lt;em&gt;iterator&lt;/em&gt; function, a &lt;em&gt;state&lt;/em&gt;, and an initial value for the first &lt;em&gt;iterator variable&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;explist&lt;/em&gt;&lt;/code&gt; оценивается только один раз. Его результатами являютсяфункция&lt;em&gt; итератора&lt;/em&gt; ,&lt;em&gt; состояние&lt;/em&gt; и начальное значение для первой&lt;em&gt; переменной итератора&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="02c81725154593faf7b3b3f43b31b6aa30161b7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;f&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt;, and &lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; are invisible variables. The names are here for explanatory purposes only.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;f&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; и &lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; - невидимые переменные. Имена приведены здесь только для пояснения.</target>
        </trans-unit>
        <trans-unit id="562c795de59069a6c76dd75325349c2fc11e4bf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;&lt;em&gt;limit&lt;/em&gt;&lt;/code&gt;, and &lt;code&gt;&lt;em&gt;step&lt;/em&gt;&lt;/code&gt; are invisible variables. The names shown here are for explanatory purposes only.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;&lt;em&gt;limit&lt;/em&gt;&lt;/code&gt; и &lt;code&gt;&lt;em&gt;step&lt;/em&gt;&lt;/code&gt; - невидимые переменные. Имена, показанные здесь, предназначены только для пояснительных целей.</target>
        </trans-unit>
        <trans-unit id="2f71e0d38e440115b80b8062b2667073a2b99d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=&lt;/code&gt;: sets native endian</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; : устанавливает исходный порядок байтов</target>
        </trans-unit>
        <trans-unit id="0a197dcb32b592a6117175ac588ba58ade78518a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt;: equality</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; : равенство</target>
        </trans-unit>
        <trans-unit id="751cff1d44a9460c79c1d8247a3762226d5dc596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;B&lt;/code&gt;: an unsigned byte (&lt;code&gt;char&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; : беззнаковый байт ( &lt;code&gt;char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="78939819671012d7b27e3304caefff90a2896e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;H&lt;/code&gt;: an unsigned &lt;code&gt;short&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; : беззнаковый &lt;code&gt;short&lt;/code&gt; (собственный размер)</target>
        </trans-unit>
        <trans-unit id="7b789f63dd50ed7c3fda6b86e141977ab88fef74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;I[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: an unsigned &lt;code&gt;int&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; bytes (default is native size)</source>
          <target state="translated">&lt;code&gt;I[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : беззнаковое &lt;code&gt;int&lt;/code&gt; с &lt;code&gt;n&lt;/code&gt; байтами (по умолчанию - собственный размер)</target>
        </trans-unit>
        <trans-unit id="fb9847bb7bda0dddeaa7102eb5ff82fef56363b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;J&lt;/code&gt;: a &lt;code&gt;lua_Unsigned&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;J&lt;/code&gt; : a &lt;code&gt;lua_Unsigned&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="684450a0b3b1fdd57e3aba433e9b9488eff7d191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;L&lt;/code&gt;: an unsigned &lt;code&gt;long&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; : беззнаковый &lt;code&gt;long&lt;/code&gt; (собственный размер)</target>
        </trans-unit>
        <trans-unit id="25c78f460ce68a552941c0b856d21bb1212d5c60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt;:  performs a full garbage-collection cycle.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt; : выполняет полный цикл сборки мусора.</target>
        </trans-unit>
        <trans-unit id="feb5e716d218ca16ede442156a2c17fc22562d67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNT&lt;/code&gt;:  returns the current amount of memory (in Kbytes) in use by Lua.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOUNT&lt;/code&gt; : возвращает текущий объем памяти (в килобайтах), используемый Lua.</target>
        </trans-unit>
        <trans-unit id="5a68d642e09792078a82b22bae5351cbaac81a3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt;:  returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt; : возвращает остаток от деления текущего количества байтов памяти, используемой Lua, на 1024.</target>
        </trans-unit>
        <trans-unit id="98c1ec01d66de8e0320c4d93348ae60d493d3e9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt;:  returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="translated">&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt; : возвращает логическое значение, которое сообщает, запущен ли сборщик (т.е. не остановлен).</target>
        </trans-unit>
        <trans-unit id="b2278ee01aaa7877800006c384258d197cbdf9bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCRESTART&lt;/code&gt;:  restarts the garbage collector.</source>
          <target state="translated">&lt;code&gt;LUA_GCRESTART&lt;/code&gt; : перезапускает сборщик мусора.</target>
        </trans-unit>
        <trans-unit id="fa1ba56a5a60dabda23e38f6db79d5515a2addfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt;:  sets &lt;code&gt;data&lt;/code&gt; as the new value for the &lt;em&gt;pause&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;) and returns the previous value of the pause.</source>
          <target state="translated">&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt; : устанавливает &lt;code&gt;data&lt;/code&gt; как новое значение для &lt;em&gt;паузы&lt;/em&gt; сборщика (см. &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ) и возвращает предыдущее значение паузы.</target>
        </trans-unit>
        <trans-unit id="3b218eaca4b6e9893a3e16aea485fd11554bfd2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt;:  sets &lt;code&gt;data&lt;/code&gt; as the new value for the &lt;em&gt;step multiplier&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;) and returns the previous value of the step multiplier.</source>
          <target state="translated">&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt; : устанавливает &lt;code&gt;data&lt;/code&gt; как новое значение для &lt;em&gt;множителя шага&lt;/em&gt; сборщика (см. &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ) и возвращает предыдущее значение множителя шага.</target>
        </trans-unit>
        <trans-unit id="1d7e799ac56c4ff839b3019633b438fb825a18fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTEP&lt;/code&gt;:  performs an incremental step of garbage collection.</source>
          <target state="translated">&lt;code&gt;LUA_GCSTEP&lt;/code&gt; : выполняет инкрементный этап сборки мусора.</target>
        </trans-unit>
        <trans-unit id="450adac195733dc26043ca23487ff56033910e41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTOP&lt;/code&gt;:  stops the garbage collector.</source>
          <target state="translated">&lt;code&gt;LUA_GCSTOP&lt;/code&gt; : останавливает сборщик мусора.</target>
        </trans-unit>
        <trans-unit id="03ae56412dd5cb45458646b97dd071be591e5e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt;: a &lt;code&gt;size_t&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; : &lt;code&gt;size_t&lt;/code&gt; (собственный размер)</target>
        </trans-unit>
        <trans-unit id="0a8a0f3d7f67d7fd79f7990d2b94e59b8a7b4375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;X&lt;em&gt;op&lt;/em&gt;&lt;/code&gt;: an empty item that aligns according to option &lt;code&gt;op&lt;/code&gt; (which is otherwise ignored)</source>
          <target state="translated">&lt;code&gt;X&lt;em&gt;op&lt;/em&gt;&lt;/code&gt; : пустой элемент, который выравнивается в соответствии с опцией &lt;code&gt;op&lt;/code&gt; (которая в противном случае игнорируется)</target>
        </trans-unit>
        <trans-unit id="6bce72d0d5e32b91f85c07cd8060a5d09dda59ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;:  represents the class which is the union of all characters in &lt;em&gt;set&lt;/em&gt;. A range of characters can be specified by separating the end characters of the range, in ascending order, with a '&lt;code&gt;-&lt;/code&gt;'. All classes &lt;code&gt;%&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; described above can also be used as components in &lt;em&gt;set&lt;/em&gt;. All other characters in &lt;em&gt;set&lt;/em&gt; represent themselves. For example, &lt;code&gt;[%w_]&lt;/code&gt; (or &lt;code&gt;[_%w]&lt;/code&gt;) represents all alphanumeric characters plus the underscore, &lt;code&gt;[0-7]&lt;/code&gt; represents the octal digits, and &lt;code&gt;[0-7%l%-]&lt;/code&gt; represents the octal digits plus the lowercase letters plus the '&lt;code&gt;-&lt;/code&gt;' character.</source>
          <target state="translated">&lt;code&gt;[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; : представляет класс, который является объединением всех символов в &lt;em&gt;наборе&lt;/em&gt; . Диапазон символов можно указать, разделив конечные символы диапазона в порядке возрастания знаком &amp;laquo; &lt;code&gt;-&lt;/code&gt; &amp;raquo;. Все классы &lt;code&gt;%&lt;/code&gt; &lt;em&gt;x,&lt;/em&gt; описанные выше, также могут использоваться как компоненты в &lt;em&gt;наборе&lt;/em&gt; . Все остальные символы в &lt;em&gt;наборе&lt;/em&gt; представляют собой самих себя. Например, &lt;code&gt;[%w_]&lt;/code&gt; (или &lt;code&gt;[_%w]&lt;/code&gt; ) представляет все буквенно-цифровые символы плюс подчеркивание, &lt;code&gt;[0-7]&lt;/code&gt; представляет восьмеричные цифры, а &lt;code&gt;[0-7%l%-]&lt;/code&gt; представляет восьмеричные цифры плюс строчные буквы. буквы плюс символ &quot; &lt;code&gt;-&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="2bfa8d127c2e8935e2fff05f79f71c951f40cbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;:  represents the complement of &lt;em&gt;set&lt;/em&gt;, where &lt;em&gt;set&lt;/em&gt; is interpreted as above.</source>
          <target state="translated">&lt;code&gt;[^&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; : представляет собой дополнение &lt;em&gt;набора&lt;/em&gt; , где &lt;em&gt;набор&lt;/em&gt; интерпретируется, как указано выше.</target>
        </trans-unit>
        <trans-unit id="f38e7d51801e02a7747b20500a8b2e632836efe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;: exponentiation</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; : возведение в степень</target>
        </trans-unit>
        <trans-unit id="f5b98943f5025fa1cf7612c16dfff443caedc2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__add&lt;/code&gt;:  the addition (&lt;code&gt;+&lt;/code&gt;) operation. If any operand for an addition is not a number (nor a string coercible to a number), Lua will try to call a metamethod. First, Lua will check the first operand (even if it is valid). If that operand does not define a metamethod for &lt;code&gt;__add&lt;/code&gt;, then Lua will check the second operand. If Lua can find a metamethod, it calls the metamethod with the two operands as arguments, and the result of the call (adjusted to one value) is the result of the operation. Otherwise, it raises an error.</source>
          <target state="translated">&lt;code&gt;__add&lt;/code&gt; : операция сложения ( &lt;code&gt;+&lt;/code&gt; ). Если какой-либо операнд для добавления не является числом (или строкой, приводимой к числу), Lua попытается вызвать метаметод. Сначала Lua проверит первый операнд (даже если он действительный). Если этот операнд не определяет &lt;code&gt;__add&lt;/code&gt; для __add , то Lua проверит второй операнд. Если Lua может найти метаметод, он вызывает метаметод с двумя операндами в качестве аргументов, и результат вызова (с поправкой на одно значение) является результатом операции. В противном случае возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="bda95a3552fcf7eb5fbbb735dac806d610f70311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__band&lt;/code&gt;:  the bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod if any operand is neither an integer nor a value coercible to an integer (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__band&lt;/code&gt; : побитовая операция И ( &lt;code&gt;&amp;amp;&lt;/code&gt; ). Поведение аналогично операции сложения, за исключением того, что Lua будет пробовать метаметод, если какой-либо операнд не является ни целым числом, ни значением, приводимым к целому числу (см. &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8271d8f21a0a60ed616ec9f38e97d661ff31836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bnot&lt;/code&gt;:  the bitwise NOT (unary &lt;code&gt;~&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bnot&lt;/code&gt; : побитовая операция НЕ (унарная &lt;code&gt;~&lt;/code&gt; ). Поведение аналогично побитовой операции И.</target>
        </trans-unit>
        <trans-unit id="9e9026d2ac8c089b351feccecbb25019aa6cc74f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bor&lt;/code&gt;:  the bitwise OR (&lt;code&gt;|&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bor&lt;/code&gt; : побитовая операция ИЛИ ( &lt;code&gt;|&lt;/code&gt; ). Поведение аналогично побитовой операции И.</target>
        </trans-unit>
        <trans-unit id="3984b6f7c6542cb91c472a68f850228f86078c2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bxor&lt;/code&gt;:  the bitwise exclusive OR (binary &lt;code&gt;~&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bxor&lt;/code&gt; : побитовая операция исключающее ИЛИ (двоичное &lt;code&gt;~&lt;/code&gt; ). Поведение аналогично побитовой операции И.</target>
        </trans-unit>
        <trans-unit id="47f84fd28e5003b12c1cddb7e1213ad73677ce7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__call&lt;/code&gt;:  The call operation &lt;code&gt;func(args)&lt;/code&gt;. This event happens when Lua tries to call a non-function value (that is, &lt;code&gt;func&lt;/code&gt; is not a function). The metamethod is looked up in &lt;code&gt;func&lt;/code&gt;. If present, the metamethod is called with &lt;code&gt;func&lt;/code&gt; as its first argument, followed by the arguments of the original call (&lt;code&gt;args&lt;/code&gt;). All results of the call are the result of the operation. (This is the only metamethod that allows multiple results.)</source>
          <target state="translated">&lt;code&gt;__call&lt;/code&gt; : функция вызова &lt;code&gt;func(args)&lt;/code&gt; . Это событие происходит, когда Lua пытается вызвать значение, не являющееся функцией (то есть &lt;code&gt;func&lt;/code&gt; не является функцией). Метаметод ищется в &lt;code&gt;func&lt;/code&gt; . Если присутствует, метаметод вызывается с &lt;code&gt;func&lt;/code&gt; в качестве первого аргумента, за которым следуют аргументы исходного вызова ( &lt;code&gt;args&lt;/code&gt; ). Все результаты вызова являются результатом операции. (Это единственный метаметод, который позволяет получить несколько результатов.)</target>
        </trans-unit>
        <trans-unit id="790454d48e53027f216e2bf64f3530d0774dee89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__concat&lt;/code&gt;:  the concatenation (&lt;code&gt;..&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod if any operand is neither a string nor a number (which is always coercible to a string).</source>
          <target state="translated">&lt;code&gt;__concat&lt;/code&gt; : операция конкатенации ( &lt;code&gt;..&lt;/code&gt; ). Поведение аналогично операции сложения, за исключением того, что Lua будет пробовать метаметод, если какой-либо операнд не является ни строкой, ни числом (которое всегда может быть приведено к строке).</target>
        </trans-unit>
        <trans-unit id="ad91de859a0158bed21ee979ae23cedc031843c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__div&lt;/code&gt;:  the division (&lt;code&gt;/&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__div&lt;/code&gt; : операция деления ( &lt;code&gt;/&lt;/code&gt; ). Поведение аналогично операции сложения.</target>
        </trans-unit>
        <trans-unit id="7344afb47ab39dbb1dcc686092dbb2c33112ca27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__eq&lt;/code&gt;:  the equal (&lt;code&gt;==&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod only when the values being compared are either both tables or both full userdata and they are not primitively equal. The result of the call is always converted to a boolean.</source>
          <target state="translated">&lt;code&gt;__eq&lt;/code&gt; : операция равенства ( &lt;code&gt;==&lt;/code&gt; ). Поведение аналогично операции сложения, за исключением того, что Lua будет пробовать метаметод только тогда, когда сравниваемые значения являются либо обеими таблицами, либо обоими полными пользовательскими данными, и они примитивно не равны. Результат вызова всегда преобразуется в логическое значение.</target>
        </trans-unit>
        <trans-unit id="e98db71bbf36f23352f716c30f1f7a8ecfbe62c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__idiv&lt;/code&gt;:  the floor division (&lt;code&gt;//&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__idiv&lt;/code&gt; : операция деления этажа ( &lt;code&gt;//&lt;/code&gt; ). Поведение аналогично операции сложения.</target>
        </trans-unit>
        <trans-unit id="decd7b7eb1b7416a469f2fca59f8e4ddd7f2a85d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__index&lt;/code&gt;:  The indexing access &lt;code&gt;table[key]&lt;/code&gt;. This event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metamethod is looked up in &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__index&lt;/code&gt; : &lt;code&gt;table[key]&lt;/code&gt; доступа к индексации [ключ] . Это событие происходит, когда &lt;code&gt;table&lt;/code&gt; не является таблицей или когда &lt;code&gt;key&lt;/code&gt; отсутствует в &lt;code&gt;table&lt;/code&gt; . Метаметод ищется в &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f475d84a338693db6fd2862596f21c01f8175167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__le&lt;/code&gt;:  the less equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;) operation. Unlike other operations, the less-equal operation can use two different events. First, Lua looks for the &lt;code&gt;__le&lt;/code&gt; metamethod in both operands, like in the less than operation. If it cannot find such a metamethod, then it will try the &lt;code&gt;__lt&lt;/code&gt; metamethod, assuming that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; is equivalent to &lt;code&gt;not (b &amp;lt; a)&lt;/code&gt;. As with the other comparison operators, the result is always a boolean. (This use of the &lt;code&gt;__lt&lt;/code&gt; event can be removed in future versions; it is also slower than a real &lt;code&gt;__le&lt;/code&gt; metamethod.)</source>
          <target state="translated">&lt;code&gt;__le&lt;/code&gt; : операция меньшего равенства ( &lt;code&gt;&amp;lt;=&lt;/code&gt; ). В отличие от других операций, операция с меньшим равенством может использовать два разных события. Во-первых, Lua ищет &lt;code&gt;__le&lt;/code&gt; в обоих операндах, как в операции &amp;laquo;меньше чем&amp;raquo;. Если он не может найти такой метаметод, он попробует &lt;code&gt;__lt&lt;/code&gt; , предполагая, что &lt;code&gt;a &amp;lt;= b&lt;/code&gt; эквивалентно &lt;code&gt;not (b &amp;lt; a)&lt;/code&gt; . Как и в случае с другими операторами сравнения, результат всегда является логическим. (Это использование события &lt;code&gt;__lt&lt;/code&gt; может быть удалено в будущих версиях; оно также работает медленнее, чем настоящий &lt;code&gt;__le&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="c61fb722a1eddfcc88f7846f65e68ff08a2c65a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__len&lt;/code&gt;:  the length (&lt;code&gt;#&lt;/code&gt;) operation. If the object is not a string, Lua will try its metamethod. If there is a metamethod, Lua calls it with the object as argument, and the result of the call (always adjusted to one value) is the result of the operation. If there is no metamethod but the object is a table, then Lua uses the table length operation (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Otherwise, Lua raises an error.</source>
          <target state="translated">&lt;code&gt;__len&lt;/code&gt; : операция длины ( &lt;code&gt;#&lt;/code&gt; ). Если объект не является строкой, Lua попробует использовать свой метаметод. Если есть метаметод, Lua вызывает его с объектом в качестве аргумента, и результат вызова (всегда настроенный на одно значение) является результатом операции. Если метаметода нет, но объект является таблицей, то Lua использует операцию длины таблицы (см. &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ). В противном случае Lua выдаст ошибку.</target>
        </trans-unit>
        <trans-unit id="6902b36544db7b8d689de0371d69c1173727d394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__lt&lt;/code&gt;:  the less than (&lt;code&gt;&amp;lt;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod only when the values being compared are neither both numbers nor both strings. The result of the call is always converted to a boolean.</source>
          <target state="translated">&lt;code&gt;__lt&lt;/code&gt; : операция &amp;laquo;меньше&amp;raquo; ( &lt;code&gt;&amp;lt;&lt;/code&gt; ). Поведение аналогично операции сложения, за исключением того, что Lua будет пробовать метаметод только тогда, когда сравниваемые значения не являются ни числами, ни обеими строками. Результат вызова всегда преобразуется в логическое значение.</target>
        </trans-unit>
        <trans-unit id="a925135fe1afbe74d4fe523a8c1e22003b5c4f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__mod&lt;/code&gt;:  the modulo (&lt;code&gt;%&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__mod&lt;/code&gt; : операция по модулю ( &lt;code&gt;%&lt;/code&gt; ). Поведение аналогично операции сложения.</target>
        </trans-unit>
        <trans-unit id="1ff94de42579b732d623fc7c57cf9f6691cc124d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__mul&lt;/code&gt;:  the multiplication (&lt;code&gt;*&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__mul&lt;/code&gt; : операция умножения ( &lt;code&gt;*&lt;/code&gt; ). Поведение аналогично операции сложения.</target>
        </trans-unit>
        <trans-unit id="bae10caba1f39db8a0508384a96106120784c41c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__newindex&lt;/code&gt;:  The indexing assignment &lt;code&gt;table[key] = value&lt;/code&gt;. Like the index event, this event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metamethod is looked up in &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__newindex&lt;/code&gt; : Таблица назначения индексации &lt;code&gt;table[key] = value&lt;/code&gt; . Как и событие index, это событие происходит, когда &lt;code&gt;table&lt;/code&gt; не является таблицей или когда &lt;code&gt;key&lt;/code&gt; отсутствует в &lt;code&gt;table&lt;/code&gt; . Метаметод ищется в &lt;code&gt;table&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7488b0be1bc57b10dfdfc405a5e990f26a432a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__pow&lt;/code&gt;:  the exponentiation (&lt;code&gt;^&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__pow&lt;/code&gt; : операция возведения в степень ( &lt;code&gt;^&lt;/code&gt; ). Поведение аналогично операции сложения.</target>
        </trans-unit>
        <trans-unit id="fc7215a1c4f0ddfcac8bc0abef79b38818065a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__shl&lt;/code&gt;:  the bitwise left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__shl&lt;/code&gt; : операция побитового сдвига влево ( &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ). Поведение аналогично побитовой операции И.</target>
        </trans-unit>
        <trans-unit id="8da8f661ba59d8ea368c0a166410be846f25ed51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__shr&lt;/code&gt;:  the bitwise right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__shr&lt;/code&gt; : операция побитового сдвига вправо ( &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ). Поведение аналогично побитовой операции И.</target>
        </trans-unit>
        <trans-unit id="0839e6023e2c19b90e41d7d692715ae3bb15dd52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__sub&lt;/code&gt;:  the subtraction (&lt;code&gt;-&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__sub&lt;/code&gt; : операция вычитания ( &lt;code&gt;-&lt;/code&gt; ). Поведение аналогично операции сложения.</target>
        </trans-unit>
        <trans-unit id="a0a7b7005a2b1ce8342934d9e28b702f6591bbad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__unm&lt;/code&gt;:  the negation (unary &lt;code&gt;-&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__unm&lt;/code&gt; : операция отрицания (унарная &lt;code&gt;-&lt;/code&gt; ). Поведение аналогично операции сложения.</target>
        </trans-unit>
        <trans-unit id="2034132fb0cda57893ded314ea78d570a3b8a1a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;: a signed byte (&lt;code&gt;char&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; : байт со знаком ( &lt;code&gt;char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1f9d27a224e5a678dfac01895e2774339ad358a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;: a fixed-sized string with &lt;code&gt;n&lt;/code&gt; bytes</source>
          <target state="translated">&lt;code&gt;c&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; : строка фиксированного размера с &lt;code&gt;n&lt;/code&gt; байтами</target>
        </trans-unit>
        <trans-unit id="007ab16ec0f7187cc23f5c4f0e1b0b9ee75de945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkname&lt;/code&gt; is used as the name of the chunk for error messages and debug information (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;). When absent, it defaults to &lt;code&gt;chunk&lt;/code&gt;, if &lt;code&gt;chunk&lt;/code&gt; is a string, or to &quot;&lt;code&gt;=(load)&lt;/code&gt;&quot; otherwise.</source>
          <target state="translated">&lt;code&gt;chunkname&lt;/code&gt; используется как имя блока для сообщений об ошибках и отладочной информации (см. &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt; ). Если отсутствует, по умолчанию используется &lt;code&gt;chunk&lt;/code&gt; , если &lt;code&gt;chunk&lt;/code&gt; является строкой, или &quot; &lt;code&gt;=(load)&lt;/code&gt; &quot; в противном случае.</target>
        </trans-unit>
        <trans-unit id="d532eddb006ab7874f0dc6fb8cbdceb76c478728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;currentline&lt;/code&gt;:  the current line where the given function is executing. When no line information is available, &lt;code&gt;currentline&lt;/code&gt; is set to -1.</source>
          <target state="translated">&lt;code&gt;currentline&lt;/code&gt; : текущая строка, в которой выполняется данная функция. Если информация о строке недоступна, для &lt;code&gt;currentline&lt;/code&gt; устанавливается значение -1.</target>
        </trans-unit>
        <trans-unit id="166b1d8e53dd83b1f49810b36d2120d5fb8cf928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;: a &lt;code&gt;double&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; : &lt;code&gt;double&lt;/code&gt; (собственный размер)</target>
        </trans-unit>
        <trans-unit id="0e1028744aa421b0605c6b88904012494c91f125" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;: a &lt;code&gt;float&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; : &lt;code&gt;float&lt;/code&gt; (собственный размер)</target>
        </trans-unit>
        <trans-unit id="c592f8c4c1d4f47249d70ff1f5e192a26d8afe2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h&lt;/code&gt;: a signed &lt;code&gt;short&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; : &lt;code&gt;short&lt;/code&gt; подписанный (собственный размер)</target>
        </trans-unit>
        <trans-unit id="f5282762e143fb0df1d1386e42490a8eef06c695" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: a signed &lt;code&gt;int&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; bytes (default is native size)</source>
          <target state="translated">&lt;code&gt;i[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : подписанное &lt;code&gt;int&lt;/code&gt; с &lt;code&gt;n&lt;/code&gt; байтами (по умолчанию - собственный размер)</target>
        </trans-unit>
        <trans-unit id="77b05e59859fe1e74f32e61593a0eca919f3206e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;istailcall&lt;/code&gt;:  true if this function invocation was called by a tail call. In this case, the caller of this level is not in the stack.</source>
          <target state="translated">&lt;code&gt;istailcall&lt;/code&gt; : true, если этот вызов функции был вызван хвостовым вызовом. В этом случае вызывающего этого уровня нет в стеке.</target>
        </trans-unit>
        <trans-unit id="d69e22a542b48170e894be5d97f55fd47a232538" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isvararg&lt;/code&gt;:  true if the function is a vararg function (always true for C functions).</source>
          <target state="translated">&lt;code&gt;isvararg&lt;/code&gt; : true, если функция является функцией vararg (всегда верно для функций C).</target>
        </trans-unit>
        <trans-unit id="580dc9d1e4e90c03d788258153e5988096093196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;j&lt;/code&gt;: a &lt;code&gt;lua_Integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;j&lt;/code&gt; : a &lt;code&gt;lua_Integer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e758d0de7cc3d0f062a6819b73437ee9ec2a2b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l&lt;/code&gt;: a signed &lt;code&gt;long&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; : &lt;code&gt;long&lt;/code&gt; знак со знаком (собственный размер)</target>
        </trans-unit>
        <trans-unit id="f04a40c17b42b18f44495a16f52bfd52196ef418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastlinedefined&lt;/code&gt;:  the line number where the definition of the function ends.</source>
          <target state="translated">&lt;code&gt;lastlinedefined&lt;/code&gt; : номер строки, на которой заканчивается определение функции.</target>
        </trans-unit>
        <trans-unit id="c558e7acb9233839c3055af52ec8d17bbbf36292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linedefined&lt;/code&gt;:  the line number where the definition of the function starts.</source>
          <target state="translated">&lt;code&gt;linedefined&lt;/code&gt; : номер строки, с которой начинается определение функции.</target>
        </trans-unit>
        <trans-unit id="1814936b717a437d1f1941926869384106ce1392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addchar&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addchar&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="575546c5b83ac45ad492ca8e44de50943cdf9d36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addlstring&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addlstring&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ab2404026db427b81b929835fcc07320d0975966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addsize&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_addsize&lt;/code&gt; [- ?, + ?, -]</target>
        </trans-unit>
        <trans-unit id="6af536d80928bc10905ab3dce78e92ea76d54e77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addstring&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addstring&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f62f4ab7ab22c41889b8409e3b36723d81cabada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addvalue&lt;/code&gt;[-1, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addvalue&lt;/code&gt; [-1, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="32a97bb778b383afdcf82dbf302e1156a6cc0b2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_argcheck&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_argcheck&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="d807e00e947d759f9dcb553ac98ec1f1193a93e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_argerror&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_argerror&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="4db817fce2c3b28619d23198a312e17e8c0b41fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffinit&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_buffinit&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="76b56ecab1b6154600ac285b1b29eb963a213f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffinitsize&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_buffinitsize&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="15797d76578ab05f141375478dbdaccf46d64197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_callmeta&lt;/code&gt;[-0, +(0|1), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_callmeta&lt;/code&gt; [-0, + (0 | 1), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="85267089380208d1670ba57aca773cbfd01c3852" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkany&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkany&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="60a4f7f116afbde74193d5e8eb007754d432edfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkinteger&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkinteger&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="caad9f257f912ca30f4e0c4103ba996c9420a91b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checklstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checklstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="fb3b4e49519cf5dbd32c138191f993b8dc2a1534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checknumber&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checknumber&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="38dfb40ea1a004fd0d2b69fead480d9a49d8202a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkoption&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkoption&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="322257f7e30d47626338ffdee9062b057e90cd8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkstack&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkstack&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="817bb0029ff7aff6991eab710b919497a5dbc912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="341111dc53b49f417dcd96b3fc29b039a26ba056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checktype&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checktype&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="12123157de5a720309f6a7c63a2cfa0c299903b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkudata&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkudata&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="dffa7856bb9be8c95d07d1f17dadf607bf429ad1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkversion&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkversion&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="3374658d775d8aa7fb8fe52da4e6fc7cfd927d02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_dofile&lt;/code&gt;[-0, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_dofile&lt;/code&gt; [-0, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a582cca705f2cb3830ac7257f0eb21203b6e929b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_dostring&lt;/code&gt;[-0, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_dostring&lt;/code&gt; [-0, + ?, -]</target>
        </trans-unit>
        <trans-unit id="a5a15bfcee6d520f8c55a01f53ed494d8d316be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_error&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_error&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6faffe57f68b2e507d46bda2d67142fcf1bd3eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_execresult&lt;/code&gt;[-0, +3, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_execresult&lt;/code&gt; [-0, +3, &lt;em&gt;м&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="689d9709c543e39ba4b14f659761c6fbee59fb20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_fileresult&lt;/code&gt;[-0, +(1|3), &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_fileresult&lt;/code&gt; [-0, + (1 | 3), &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="26ad671f853e795fc32c1842c210c309e5737a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getmetafield&lt;/code&gt;[-0, +(0|1), &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getmetafield&lt;/code&gt; [-0, + (0 | 1), &lt;em&gt;м&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="86627657b2139b0ee31a53c83ad51ed9c63ee4f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getmetatable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getmetatable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f0429bf39eeee8b432bf2c4ac915eb9bd9c58fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getsubtable&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getsubtable&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="dcbde4eb043fd7a6a88005560668c86e718f4d64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_gsub&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_gsub&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6aa13480ee4b2afee4725e8c33c17ccef37dacb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_len&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_len&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1ff1186e40e0c45fe6b82e0cd030ddaab25d3514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadbuffer&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadbuffer&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="5c9c6205f5ab035f8481cc23adec6d68a927c21e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadbufferx&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadbufferx&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="3efa8a062aa5c6fd99fa30d9a6b615805d5f6633" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadfile&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_loadfile&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="bed752688a8097a24d7fe06f2d44fb3b8104d51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadfilex&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_loadfilex&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a1117ad9189ec1e73f1b81cc6ca7a6ca13b4d08a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadstring&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadstring&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="7006cdeb7d6e0f06f8bd85a3e8e67991899f625c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newlib&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newlib&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="4bb6d574631ce0eb10e53ee60cc236afb57494d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newlibtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newlibtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1597a9788daec91a227c519bb2f818e05f9f4c08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newmetatable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newmetatable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ce4b485fbcd4cc791900d08f23c6cdfdec7f1520" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newstate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_newstate&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="49f8165e8132fcb469103de8892f176c1f0def64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_openlibs&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_openlibs&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="83750c461dfda8dcc3cadb263ef7f900676721c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_opt&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_opt&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7ddba39b66f773750f9ae187c2d2d76d0f89ac96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optinteger&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optinteger&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="2fcf8ecf5a60e1bef873c06be25a18130a4d742f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optlstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optlstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="9f89308fc4e4595c99a38d039175c1137359ac54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optnumber&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optnumber&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="274c9ca5ceedb91c17aae3f6a7353a8fe5343712" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7a41c18601fede06cd92afc10561621476415195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_prepbuffer&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_prepbuffer&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6dd4e822d50779a6e2f55486d474e3cf4dc9a3a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_prepbuffsize&lt;/code&gt; [- ?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f4c1792dcbf5df89608d53cfa3c381e725d7c8dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_pushresult&lt;/code&gt;[-?, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_pushresult&lt;/code&gt; [- ?, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="56aef86b4910793d510e049e250c4ba15d08651b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_pushresultsize&lt;/code&gt;[-?, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_pushresultsize&lt;/code&gt; [- ?, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="cf9ba081e7beac774ea13e9e5e96e368f77f91b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_ref&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_ref&lt;/code&gt; [-1, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="964377d76c6003fa09c52e382c6f30d89d8e7733" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_requiref&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_requiref&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0fa64c78fb075f6bccbf9d15ca226451decea5ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_setfuncs&lt;/code&gt;[-nup, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_setfuncs&lt;/code&gt; [-nup, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="2e5d3d14dd1ede554838763a71c2eb2b30f00e10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_setmetatable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_setmetatable&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="b4785fa0b78405754bdd9e6816e0505e89bb2ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_testudata&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_testudata&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="87fa79dd9413aed4e20cd6a034ba315882e2e0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_tolstring&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_tolstring&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="306b764f016817d71c097f8443a6177598555795" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_traceback&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_traceback&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ca032fc0be8f16a7dbcab71e66bfe7be88723983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_typename&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_typename&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="f49e88ae95e2c08d4f66fb932d9bcde472eca71a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_unref&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_unref&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="e61c1eb9f0ad1ce243ab6024b692ea269b6a3ddc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_where&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_where&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="990854d58117af3aa9e8e4765776b83ce30f5cb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_absindex&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_absindex&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="b1819f228761942b7921d51557a46ebabdfda1ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_arith&lt;/code&gt;[-(2|1), +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_arith&lt;/code&gt; [- (2 | 1), +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f24f91865ac7127a8413e2ae152416f6c2ed006b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_atpanic&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_atpanic&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="e7479fe5b0585be43d2a995bebe0c8255ad26bbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_call&lt;/code&gt;[-(nargs+1), +nresults, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_call&lt;/code&gt; [- (nargs + 1), + nresults, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c65d2f6c1099ba05a81459947c26df8cf58a8ea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_callk&lt;/code&gt;[-(nargs + 1), +nresults, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_callk&lt;/code&gt; [- (nargs + 1), + nresults, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="acf13cf1bfb7ad750c4fa45422c658708c5d250e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_checkstack&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_checkstack&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="ce69674693f57931d2d994412ec490a58883fe0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_close&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_close&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="9f95f6e80bc09c2b612082485467d037fdabd286" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_compare&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_compare&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a04bab7507101355ee6351af1abfc06a7108a08a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_concat&lt;/code&gt;[-n, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_concat&lt;/code&gt; [-n, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="814bbfd9c45c7f18a87781bf3ee57bb270d7c603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_copy&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_copy&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="79ee61bf6bf5fa92650008381392b1a21cbabf69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_createtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_createtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e7551097f181c02c15fea59139836b798d27fd76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_dump&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_dump&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d1d8b7fcdc2438a4309209f0e66816aa345e3ea0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_error&lt;/code&gt;[-1, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_error&lt;/code&gt; [-1, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a66371d02bb2a5294ddc7ff965f4078200f059e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gc&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_gc&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="9956d0bc82cc5409c737543da96a541d83bfbf7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getallocf&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getallocf&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="59632bab17bc189c3148482bc4080f9bd4b84547" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getextraspace&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getextraspace&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="60f37f158845e124eace06ea63e2280a95012974" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getfield&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getfield&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c94c6fd2b7c14b3e3b6ad04d5fe36bf6add888c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getglobal&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getglobal&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ff4cee0e3a4e1d63522125ff34c46aca37313caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethook&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethook&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="ec0eadfb615abc82aff0c7990a50162481f09f63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethookcount&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethookcount&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d7f8a674ccfd65eff1082ce412eb29972a57b18c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethookmask&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethookmask&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="f71c31c54898e128df0441cf376c9e767064382d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_geti&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_geti&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ea4a9e14acd3cb3bbf7462b6fb68c3ad28de14f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getinfo&lt;/code&gt;[-(0|1), +(0|1|2), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getinfo&lt;/code&gt; [- (0 | 1), + (0 | 1 | 2), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="273e8c6ec216c7c83ca38a878d93b95631b13f24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getlocal&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getlocal&lt;/code&gt; [-0, + (0 | 1), -]</target>
        </trans-unit>
        <trans-unit id="e2eca7f4a92d49d560aa8d947a3a1e0961d07be4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getmetatable&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getmetatable&lt;/code&gt; [-0, + (0 | 1), -]</target>
        </trans-unit>
        <trans-unit id="7e3ce20be5f0c5d99b7e25b37999cb8bb5fd91e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getstack&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getstack&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="e01aa99ca62e5ceb24fa39ed4a6f4d31e572fa50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gettable&lt;/code&gt;[-1, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_gettable&lt;/code&gt; [-1, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8e15475f1fb39e9839166b70e212b31d2521646e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gettop&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gettop&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="75cc1327823f758a6a97b78b712f93d5c639d881" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getupvalue&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getupvalue&lt;/code&gt; [-0, + (0 | 1), -]</target>
        </trans-unit>
        <trans-unit id="06a9850be6a3681bd25c5c7e797cd88c22cc51e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getuservalue&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getuservalue&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="97ccd9464bf8253b4595901de1c28a281d630bca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_insert&lt;/code&gt;[-1, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_insert&lt;/code&gt; [-1, +1, -]</target>
        </trans-unit>
        <trans-unit id="ccf0205da2145136a72004529c69ef0d97389a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isboolean&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isboolean&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d8f9274340043a6fe5b4a6502b209dfbcbc8102f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_iscfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_iscfunction&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="344ac0a298f2d260c0cf30e7563213a6456c1391" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isfunction&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="95a6448d21c638bda4c1f328498fa19c59e41122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isinteger&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isinteger&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="906431d15e81d16a20736c110a889aa904f850f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_islightuserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_islightuserdata&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="c331f628d45e17d9badc04decdc73b3dfba9aa43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnil&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnil&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="b6f54dbbadf1568e10c49c9c8d51351826575cc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnone&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnone&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="6141fdc1edd3191ed965eb184782c4bcc77ab662" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnoneornil&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnoneornil&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="244c0aa7d5c38d7aff3d8a120df5d0ff4dedd191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnumber&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnumber&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="9c5842c76ba56cc7b434b470a13d5db9a2ae746b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isstring&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isstring&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="9e4d02a146e4faff57845d1d808d69e94d4d5760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_istable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_istable&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="fca695e4d6ae492d953e231c04e6456779c318ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isthread&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isthread&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="9054b192261af4e3df167d43972cc92d8f12c922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isuserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isuserdata&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="6558ec7a9edae7a2472cab5d36feb4a25937b33a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isyieldable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isyieldable&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="84ed319e4f41b15e379b0c80b8d751fb0a3350ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_len&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_len&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7a22e4332e1d809d6600680001552784b09874aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt; automatically detects whether the chunk is text or binary and loads it accordingly (see program &lt;code&gt;luac&lt;/code&gt;). The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;, with the addition that a &lt;code&gt;NULL&lt;/code&gt; value is equivalent to the string &quot;&lt;code&gt;bt&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; автоматически определяет, является ли фрагмент текстовым или двоичным, и загружает его соответственно (см. программу &lt;code&gt;luac&lt;/code&gt; ). Строковый &lt;code&gt;mode&lt;/code&gt; работает так же, как и функция &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; , с той лишь &lt;code&gt;NULL&lt;/code&gt; значение NULL эквивалентно строке &amp;laquo; &lt;code&gt;bt&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ccb7a1a988cb848b3d6f32fc68386067014fdd3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt; uses the stack internally, so the reader function must always leave the stack unmodified when returning.</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; использует стек внутри, поэтому функция чтения всегда должна оставлять стек неизмененным при возврате.</target>
        </trans-unit>
        <trans-unit id="c9ad4cdb5afe054e2d52630b341bddcd5318dcbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="7374aef019136058240eb91bf9d7d1be64edc6b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newstate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_newstate&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="1a38a1e48176080fdd830cbfa8d2959e31ce81e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0a032a953b6701cd3d3ac0a4241cf5e3af19ca63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newthread&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newthread&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="aa090c22b67b6e811e3f6576dbb546c21227c3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newuserdata&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newuserdata&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a2e6cbd4372d1f48086bd4ed0d56df437b0da92b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_next&lt;/code&gt;[-1, +(2|0), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_next&lt;/code&gt; [-1, + (2 | 0), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e26fc6d5a88b15e99cc4567b71c159df4ba7279c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pcall&lt;/code&gt;[-(nargs + 1), +(nresults|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pcall&lt;/code&gt; [- (nargs + 1), + (nresults | 1), -]</target>
        </trans-unit>
        <trans-unit id="850c75458d454fa1e854b2a9dc95240fca9f635c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pcallk&lt;/code&gt;[-(nargs + 1), +(nresults|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pcallk&lt;/code&gt; [- (nargs + 1), + (nresults | 1), -]</target>
        </trans-unit>
        <trans-unit id="88661d7b63266eddc349ccd0237a4a2fc79f215f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pop&lt;/code&gt;[-n, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pop&lt;/code&gt; [-n, +0, -]</target>
        </trans-unit>
        <trans-unit id="666e2142d3e457306d33378f3369679386a5b561" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushboolean&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushboolean&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="65a5e45fe5816a098fad98e557109633e97a1de8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushcclosure&lt;/code&gt;[-n, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushcclosure&lt;/code&gt; [-n, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="73447e0e4c9e92da86686da3e2f378b5e95bb556" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushcfunction&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushcfunction&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="6d9930915fc5c9a7d6f3b1983934256b1782cdce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushfstring&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushfstring&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6ca7a523e75628341dcb660957104bd730722b5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushglobaltable&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushglobaltable&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="a664d85fd673d8e5f2c1f86f70023732e187465e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushinteger&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushinteger&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="a766edeb81578b9f6c5186a1ef1e02ddf5cb9453" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushlightuserdata&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushlightuserdata&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="78d98a728cf4ae7cccb9296c51e6350cb444a216" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushliteral&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushliteral&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="52c39aa3679bdd694c82d8b6920a76e7887f4f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushlstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushlstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f18e9b33f026fcc7f0bb37b6518778960e0be147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushnil&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushnil&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="5b61a28ad71dd0c16bf5685880526849b74d1b22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushnumber&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushnumber&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="48093510761a8d9599932440e922c82a70bff0b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8941a8b85742686999473929b77ca66b0c29786c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushthread&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushthread&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="a01e6c270aa1f8c90cd63c088fc55f395501c232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushvalue&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushvalue&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="c4891a46279c1165ab6f6829b04d0f80e80af46f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushvfstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushvfstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="5301ff5e4db06f4a902ea6e4f46a536016dec115" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawequal&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawequal&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="e7190a64e66cfdbfaa05e771b86b2428ce0f0c4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawget&lt;/code&gt;[-1, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawget&lt;/code&gt; [-1, +1, -]</target>
        </trans-unit>
        <trans-unit id="d8f63e8c899fc2163ea12e1929521f16195b8027" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawgeti&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawgeti&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="fd2f5fea0059c2e1a9ec9f806dd9bc92085001d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawgetp&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawgetp&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="32af4b6d514d73f35935bd7c665974260bb2d400" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawlen&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawlen&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="1d4cc3e1e56562010c53810d955212d9e94456ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawset&lt;/code&gt;[-2, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawset&lt;/code&gt; [-2, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6ebc570fbad1c557a9df049aab4ab6766494d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawseti&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawseti&lt;/code&gt; [-1, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7c35ae056b934f9d827a204944f9eb45d6eac2c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawsetp&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawsetp&lt;/code&gt; [-1, +0, &lt;em&gt;м&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="13a48b8091c79dfb748c242e690a7dfb0126ad0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_register&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_register&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a0f12f7525f2b835c43c2bbb5726d22e75a7ad66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_remove&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_remove&lt;/code&gt; [-1, +0, -]</target>
        </trans-unit>
        <trans-unit id="e3aac1a6f4d80e971df8eaa5fd21798ce934e9c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_replace&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_replace&lt;/code&gt; [-1, +0, -]</target>
        </trans-unit>
        <trans-unit id="3a14b7df302fab9d83a4283a02b409867a164c3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_resume&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_resume&lt;/code&gt; [- ?, + ?, -]</target>
        </trans-unit>
        <trans-unit id="64b664566bc1133823238a94df36387e91cc4ce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rotate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rotate&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="01005f76c6b7629878b4c890f865d738f3e13645" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setallocf&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setallocf&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="69d7c876f5849763d0227a670cfb4cab56753235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setfield&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_setfield&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0afc85df066219abbaa2ee335f767a7b6896a049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setglobal&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_setglobal&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1b87726690c26be63f2ac34a4ef8702546d30a9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_sethook&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_sethook&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="f0d0da820dadc58bad264baff1243876ee500108" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_seti&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_seti&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="5673fc21d54441e768e98b5369226b29b8a4d4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setlocal&lt;/code&gt;[-(0|1), +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setlocal&lt;/code&gt; [- (0 | 1), +0, -]</target>
        </trans-unit>
        <trans-unit id="411f7433e89a45adb3e7009dbdd17fd585bc8560" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setmetatable&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setmetatable&lt;/code&gt; [-1, +0, -]</target>
        </trans-unit>
        <trans-unit id="20dcd39a78d5bdc5aa9f802eb25a1dd6a435cab5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_settable&lt;/code&gt;[-2, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_settable&lt;/code&gt; [-2, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8259b61e77e47265f15b0e9934536650ba6717ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_settop&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_settop&lt;/code&gt; [- ?, + ?, -]</target>
        </trans-unit>
        <trans-unit id="fd6996e775cf476c1f493f52a1afccf6f6c1f4c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setupvalue&lt;/code&gt;[-(0|1), +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setupvalue&lt;/code&gt; [- (0 | 1), +0, -]</target>
        </trans-unit>
        <trans-unit id="962bd088aac144ff787da78a548da45dbaa42a60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setuservalue&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setuservalue&lt;/code&gt; [-1, +0, -]</target>
        </trans-unit>
        <trans-unit id="cc614bc467cfc52c396d5f4863abfb818cf5cd26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_status&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_status&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="2ccbee67de9eb87f0444d554fe5e403f4ee12142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_stringtonumber&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_stringtonumber&lt;/code&gt; [-0, +1, -]</target>
        </trans-unit>
        <trans-unit id="3c297ec1e5647fff579f5d361ceaa2a83c13bc96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_toboolean&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_toboolean&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="2f40e6bccafddc0d0eb0d56fd2ebb507f4a741b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tocfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tocfunction&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="772105fa735d3f8e52e4dcf1f374a906313801c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tointeger&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tointeger&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="087ba9ee74385ce56dc7afa2421e9fe18d49cdf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tointegerx&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tointegerx&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d547274b13aa55e1f5b1a1ead3114fadb93ca9e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tolstring&lt;/code&gt; returns a pointer to a string inside the Lua state. This string always has a zero ('&lt;code&gt;\0&lt;/code&gt;') after its last character (as in C), but can contain other zeros in its body.</source>
          <target state="translated">&lt;code&gt;lua_tolstring&lt;/code&gt; возвращает указатель на строку внутри состояния Lua. Эта строка всегда имеет ноль (' &lt;code&gt;\0&lt;/code&gt; ') после последнего символа (как в C), но может содержать и другие нули в своем теле.</target>
        </trans-unit>
        <trans-unit id="784eecca5b67aab549cd43e3189c0b5977217c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tolstring&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_tolstring&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7687cab7b8801ef5abea1aaa0693b3341c3eb2a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tonumber&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tonumber&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="99cab8a87a9cde1e6e3d9aaa6081962667424cb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tonumberx&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tonumberx&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d77c2f1d7b9ab8de85633a1ac860cb38ef23ca1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_topointer&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_topointer&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="d7d11d995d3d1465098bd08f248711e428607f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tostring&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_tostring&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e8d8a7c874870b0198c1a9b7c8f6d3c505824583" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tothread&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tothread&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="2d3423346c67cf164db6ad8970bd4f2222cb7fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_touserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_touserdata&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="c0476212a8a15366d6ce4f81f04d030827e0066d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_type&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_type&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="f96cc4b0e1232bc22121e6810d74b42c2b1d3e06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_typename&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_typename&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="91a931321e8502b23d51c1a0a5c98f0c4165be7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvalueid&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvalueid&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="0ac955e136a22fb0a5cd4db3550046e858514163" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvalueindex&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvalueindex&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="27e8b4001de191561a219319ddfcf067f1e183b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvaluejoin&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvaluejoin&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="457f873509336f31072e0a6dc8f411b538781818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_version&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_version&lt;/code&gt; [-0, +0, -]</target>
        </trans-unit>
        <trans-unit id="bcb44f56e283569bb547217712306f8852f22cc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_xmove&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_xmove&lt;/code&gt; [- ?, + ?, -]</target>
        </trans-unit>
        <trans-unit id="76eecec65311fcc388227c521b10b1a314479323" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yield&lt;/code&gt;[-?, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_yield&lt;/code&gt; [- ?, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="81c6c643ec495e4991ca6c7475dab89f182c2cfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yieldk&lt;/code&gt;[-?, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_yieldk&lt;/code&gt; [- ?, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="96b82c4509109433cf6af1e0be37d96a7fd94922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;: a &lt;code&gt;lua_Number&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; : &lt;code&gt;lua_Number&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b29a4583bd00c0104cbe887c8111b95b42c3a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;:  a reasonable name for the given function. Because functions in Lua are first-class values, they do not have a fixed name: some functions can be the value of multiple global variables, while others can be stored only in a table field. The &lt;code&gt;lua_getinfo&lt;/code&gt; function checks how the function was called to find a suitable name. If it cannot find a name, then &lt;code&gt;name&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : разумное имя для данной функции. Поскольку функции в Lua являются первоклассными значениями, они не имеют фиксированного имени: некоторые функции могут быть значениями нескольких глобальных переменных, а другие могут храниться только в поле таблицы. Функция &lt;code&gt;lua_getinfo&lt;/code&gt; проверяет, как функция была вызвана, чтобы найти подходящее имя. Если не может найти имя, тогда &lt;code&gt;name&lt;/code&gt; устанавливается в &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c79c193a99a81d7281723cef6c12912cbf6433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namewhat&lt;/code&gt;:  explains the &lt;code&gt;name&lt;/code&gt; field. The value of &lt;code&gt;namewhat&lt;/code&gt; can be &lt;code&gt;&quot;global&quot;&lt;/code&gt;, &lt;code&gt;&quot;local&quot;&lt;/code&gt;, &lt;code&gt;&quot;method&quot;&lt;/code&gt;, &lt;code&gt;&quot;field&quot;&lt;/code&gt;, &lt;code&gt;&quot;upvalue&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&quot;&lt;/code&gt; (the empty string), according to how the function was called. (Lua uses the empty string when no other option seems to apply.)</source>
          <target state="translated">&lt;code&gt;namewhat&lt;/code&gt; : объясняет поле &lt;code&gt;name&lt;/code&gt; . Значение &lt;code&gt;namewhat&lt;/code&gt; может быть &lt;code&gt;&quot;global&quot;&lt;/code&gt; , &lt;code&gt;&quot;local&quot;&lt;/code&gt; , &lt;code&gt;&quot;method&quot;&lt;/code&gt; , &lt;code&gt;&quot;field&quot;&lt;/code&gt; , &lt;code&gt;&quot;upvalue&quot;&lt;/code&gt; или &lt;code&gt;&quot;&quot;&lt;/code&gt; (пустая строка), в зависимости от того, как была вызвана функция. (Lua использует пустую строку, когда кажется, что другой вариант не подходит.)</target>
        </trans-unit>
        <trans-unit id="1fa95e55dd4784388ede4cc0ae537a28a3080930" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparams&lt;/code&gt;:  the number of fixed parameters of the function (always 0 for C functions).</source>
          <target state="translated">&lt;code&gt;nparams&lt;/code&gt; : количество фиксированных параметров функции (всегда 0 для функций C).</target>
        </trans-unit>
        <trans-unit id="f379a6299ba3a449833511efbfb031b2dee8fac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nups&lt;/code&gt;:  the number of upvalues of the function.</source>
          <target state="translated">&lt;code&gt;nups&lt;/code&gt; : количество повышающих значений функции.</target>
        </trans-unit>
        <trans-unit id="3afc1431e3aae979f726ea70b785e9f045e81a13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: a string preceded by its length coded as an unsigned integer with &lt;code&gt;n&lt;/code&gt; bytes (default is a &lt;code&gt;size_t&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;s[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : строка, которой предшествует ее длина, закодированная как целое число без знака с &lt;code&gt;n&lt;/code&gt; байтами (по умолчанию &lt;code&gt;size_t&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="41b71842909a6cbea5231fb02ae01a15bb5d7485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short_src&lt;/code&gt;:  a &quot;printable&quot; version of &lt;code&gt;source&lt;/code&gt;, to be used in error messages.</source>
          <target state="translated">&lt;code&gt;short_src&lt;/code&gt; : &quot; печатная &quot; версия &lt;code&gt;source&lt;/code&gt; , которая будет использоваться в сообщениях об ошибках.</target>
        </trans-unit>
        <trans-unit id="8c0e50b9fe2c50cd274f54eaadc1fbca633a98ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;:  the name of the chunk that created the function. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;@&lt;/code&gt;', it means that the function was defined in a file where the file name follows the '&lt;code&gt;@&lt;/code&gt;'. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;=&lt;/code&gt;', the remainder of its contents describe the source in a user-dependent manner. Otherwise, the function was defined in a string where &lt;code&gt;source&lt;/code&gt; is that string.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; : имя блока, создавшего функцию. Если &lt;code&gt;source&lt;/code&gt; начинается с &amp;laquo; &lt;code&gt;@&lt;/code&gt; &amp;raquo;, это означает, что функция была определена в файле, имя которого следует за &amp;laquo; &lt;code&gt;@&lt;/code&gt; &amp;raquo;. Если &lt;code&gt;source&lt;/code&gt; начинается с ' &lt;code&gt;=&lt;/code&gt; ', остальная часть его содержимого описывает источник в зависимости от пользователя. В противном случае функция была определена в строке, где &lt;code&gt;source&lt;/code&gt; является эта строка.</target>
        </trans-unit>
        <trans-unit id="d2ee7088a398a6c05a7c0875bb94a590aab08cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;what&lt;/code&gt;:  the string &lt;code&gt;&quot;Lua&quot;&lt;/code&gt; if the function is a Lua function, &lt;code&gt;&quot;C&quot;&lt;/code&gt; if it is a C function, &lt;code&gt;&quot;main&quot;&lt;/code&gt; if it is the main part of a chunk.</source>
          <target state="translated">&lt;code&gt;what&lt;/code&gt; : строка &lt;code&gt;&quot;Lua&quot;&lt;/code&gt; если функция является функцией Lua, &lt;code&gt;&quot;C&quot;&lt;/code&gt; если это функция C, &lt;code&gt;&quot;main&quot;&lt;/code&gt; если это основная часть чанка.</target>
        </trans-unit>
        <trans-unit id="87cd3c11f99f314ecc367ad79ade7d620b0027d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt;: one byte of padding</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; : один байт заполнения</target>
        </trans-unit>
        <trans-unit id="001502b0ce7e783ed32ff78090d4ed094c235365" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z&lt;/code&gt;: a zero-terminated string</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; : строка с нулевым завершением</target>
        </trans-unit>
        <trans-unit id="35770f2a3e697f3d7fc1b9f9a92ee552d22bf261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: bitwise OR</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; : побитовое ИЛИ</target>
        </trans-unit>
        <trans-unit id="7d6fd4ec60e16166466f316ad472a99346ef7ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;: bitwise exclusive OR</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; : побитовое исключающее ИЛИ</target>
        </trans-unit>
        <trans-unit id="96b4aa7e1aec2aa10ad8536c6f27c6c544521708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;: unary bitwise NOT</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; : унарное побитовое НЕ</target>
        </trans-unit>
        <trans-unit id="acd6d8cce51a342c5b90bb1907903a7f4dbad3e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~=&lt;/code&gt;: inequality</source>
          <target state="translated">&lt;code&gt;~=&lt;/code&gt; : неравенство</target>
        </trans-unit>
        <trans-unit id="aa7f065407772e44a51b8ffb896bf3e031ec8b94" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Names&lt;/em&gt; (also called &lt;em&gt;identifiers&lt;/em&gt;) in Lua can be any string of letters, digits, and underscores, not beginning with a digit and not being a reserved word. Identifiers are used to name variables, table fields, and labels.</source>
          <target state="translated">&lt;em&gt;Имена&lt;/em&gt; (также называемые &lt;em&gt;идентификаторами&lt;/em&gt; ) в Lua могут быть любой строкой букв, цифр и знаков подчеркивания, не начинающейся с цифры и не являющейся зарезервированным словом. Идентификаторы используются для именования переменных, полей таблицы и меток.</target>
        </trans-unit>
        <trans-unit id="4aadb70307c23ca740f6eccdee86415794b36e75" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;break&lt;/b&gt; ends the innermost enclosing loop.</source>
          <target state="translated">&lt;b&gt;Перерыв&lt;/b&gt; заканчивает самую внутреннюю охватывающую петлю.</target>
        </trans-unit>
        <trans-unit id="144235cbc1ccef915119f45152ac47c5119d150b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;for&lt;/b&gt; statement like</source>
          <target state="translated">&lt;b&gt;Для&lt;/b&gt; заявления как</target>
        </trans-unit>
        <trans-unit id="8da2571ab7c7e060c4976d340da392d89313fdab" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character class&lt;/em&gt; is used to represent a set of characters. The following combinations are allowed in describing a character class:</source>
          <target state="translated">&lt;em&gt;Класс символов&lt;/em&gt; используется для представления набора символов. При описании класса символов допустимы следующие комбинации:</target>
        </trans-unit>
        <trans-unit id="11942e741b80827f49b57cea2ee7a3083c5c5105" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;comment&lt;/em&gt; starts with a double hyphen (&lt;code&gt;--&lt;/code&gt;) anywhere outside a string. If the text immediately after &lt;code&gt;--&lt;/code&gt; is not an opening long bracket, the comment is a &lt;em&gt;short comment&lt;/em&gt;, which runs until the end of the line. Otherwise, it is a &lt;em&gt;long comment&lt;/em&gt;, which runs until the corresponding closing long bracket. Long comments are frequently used to disable code temporarily.</source>
          <target state="translated">&lt;em&gt;Комментарий&lt;/em&gt; начинается с двойного дефиса ( &lt;code&gt;--&lt;/code&gt; ) в любом месте за пределами строки. Если текст сразу после &lt;code&gt;--&lt;/code&gt; не является открывающей длинной скобкой, комментарий будет &lt;em&gt;коротким комментарием&lt;/em&gt; , который длится до конца строки. В противном случае это &lt;em&gt;длинный комментарий&lt;/em&gt; , который продолжается до соответствующей закрывающей длинной скобки. Для временного отключения кода часто используются длинные комментарии.</target>
        </trans-unit>
        <trans-unit id="45246a537ee28cdd862e9e3b659c6215f07e13a0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;numeric constant&lt;/em&gt; (or &lt;em&gt;numeral&lt;/em&gt;) can be written with an optional fractional part and an optional decimal exponent, marked by a letter '&lt;code&gt;e&lt;/code&gt;' or '&lt;code&gt;E&lt;/code&gt;'. Lua also accepts hexadecimal constants, which start with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;. Hexadecimal constants also accept an optional fractional part plus an optional binary exponent, marked by a letter '&lt;code&gt;p&lt;/code&gt;' or '&lt;code&gt;P&lt;/code&gt;'. A numeric constant with a radix point or an exponent denotes a float; otherwise, if its value fits in an integer, it denotes an integer. Examples of valid integer constants are</source>
          <target state="translated">&lt;em&gt;Числовая константа&lt;/em&gt; (или &lt;em&gt;цифра&lt;/em&gt; ) может быть записана с помощью дополнительного дробной части и дополнительный десятичное показатель, отмеченный буквой &amp;laquo; &lt;code&gt;e&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;E&lt;/code&gt; &amp;raquo;. Lua также принимает шестнадцатеричные константы, которые начинаются с &lt;code&gt;0x&lt;/code&gt; или &lt;code&gt;0X&lt;/code&gt; . Шестнадцатеричные константы также принимают необязательную дробную часть плюс необязательную двоичную экспоненту, отмеченную буквой &amp;laquo; &lt;code&gt;p&lt;/code&gt; &amp;raquo; или &amp;laquo; &lt;code&gt;P&lt;/code&gt; &amp;raquo;. Числовая константа с точкой счисления или показателем степени обозначает число с плавающей запятой; в противном случае, если его значение соответствует целому числу, оно обозначает целое число. Примеры допустимых целочисленных констант:</target>
        </trans-unit>
        <trans-unit id="43c4164c55abb7933faf258648b8253172e7ddaf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pattern item&lt;/em&gt; can be</source>
          <target state="translated">&lt;em&gt;Элемент модели&lt;/em&gt; может быть</target>
        </trans-unit>
        <trans-unit id="9b3f67e64fdd3547c2b4af7f1362a66a7279295d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pattern&lt;/em&gt; is a sequence of pattern items. A caret '&lt;code&gt;^&lt;/code&gt;' at the beginning of a pattern anchors the match at the beginning of the subject string. A '&lt;code&gt;$&lt;/code&gt;' at the end of a pattern anchors the match at the end of the subject string. At other positions, '&lt;code&gt;^&lt;/code&gt;' and '&lt;code&gt;$&lt;/code&gt;' have no special meaning and represent themselves.</source>
          <target state="translated">&lt;em&gt;Шаблон&lt;/em&gt; представляет собой последовательность элементов образца. Каретка &amp;laquo; &lt;code&gt;^&lt;/code&gt; &amp;raquo; в начале шаблона закрепляет совпадение в начале строки темы. Символ &quot; &lt;code&gt;$&lt;/code&gt; &quot; в конце шаблона закрепляет совпадение в конце строки темы. В других позициях &lt;code&gt;^&lt;/code&gt; &quot; ^ &quot; и &quot; &lt;code&gt;$&lt;/code&gt; &quot; не имеют особого значения и обозначают сами себя.</target>
        </trans-unit>
        <trans-unit id="c9d93dadd47fb17d5c1f30a2f6969069891cffbe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;short literal string&lt;/em&gt; can be delimited by matching single or double quotes, and can contain the following C-like escape sequences: '&lt;code&gt;\a&lt;/code&gt;' (bell), '&lt;code&gt;\b&lt;/code&gt;' (backspace), '&lt;code&gt;\f&lt;/code&gt;' (form feed), '&lt;code&gt;\n&lt;/code&gt;' (newline), '&lt;code&gt;\r&lt;/code&gt;' (carriage return), '&lt;code&gt;\t&lt;/code&gt;' (horizontal tab), '&lt;code&gt;\v&lt;/code&gt;' (vertical tab), '&lt;code&gt;\\&lt;/code&gt;' (backslash), '&lt;code&gt;\&quot;&lt;/code&gt;' (quotation mark [double quote]), and '&lt;code&gt;\'&lt;/code&gt;' (apostrophe [single quote]). A backslash followed by a line break results in a newline in the string. The escape sequence '&lt;code&gt;\z&lt;/code&gt;' skips the following span of white-space characters, including line breaks; it is particularly useful to break and indent a long literal string into multiple lines without adding the newlines and spaces into the string contents. A short literal string cannot contain unescaped line breaks nor escapes not forming a valid escape sequence.</source>
          <target state="translated">&lt;em&gt;Короткая символьная строка&lt;/em&gt; может быть ограничена путем сопоставления одинарные или двойные кавычки, и может содержать следующую C-типа управляющих последовательностей: &amp;laquo; &lt;code&gt;\a&lt;/code&gt; &amp;raquo; (колокол), &amp;laquo; &lt;code&gt;\b&lt;/code&gt; &amp;raquo; (забой), &amp;laquo; &lt;code&gt;\f&lt;/code&gt; &amp;raquo; (форма подачи), ' &lt;code&gt;\n&lt;/code&gt; ' (новая строка), ' &lt;code&gt;\r&lt;/code&gt; ' (возврат каретки), ' &lt;code&gt;\t&lt;/code&gt; ' (горизонтальная табуляция), ' &lt;code&gt;\v&lt;/code&gt; ' (вертикальная табуляция), ' &lt;code&gt;\\&lt;/code&gt; ' (обратная косая черта), ' &lt;code&gt;\&quot;&lt;/code&gt; ' (кавычки [двойная кавычка]) и ' &lt;code&gt;\'&lt;/code&gt; '(апостроф [одинарная кавычка]). Обратная косая черта, за которой следует разрыв строки, приводит к новой строке в строке. Управляющая последовательность' &lt;code&gt;\z&lt;/code&gt; 'пропускает следующий диапазон символов пробела, включая разрывы строк; особенно полезно разбивать длинную буквальную строку и делать отступ на несколько строк без добавления новых строк и пробелов в содержимое строки. Короткая буквальная строка не может содержать неэкранированные разрывы строк или экранированные символы, не образующие допустимую escape-последовательность.</target>
        </trans-unit>
        <trans-unit id="28b71986dee98cd86a5bb65ac2e321dbab699546" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;valid index&lt;/em&gt; is an index that refers to a position that stores a modifiable Lua value. It comprises stack indices between 1 and the stack top (&lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt;) plus &lt;em&gt;pseudo-indices&lt;/em&gt;, which represent some positions that are accessible to C code but that are not in the stack. Pseudo-indices are used to access the registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;) and the upvalues of a C function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;Допустимый индекс&lt;/em&gt; представляет собой индекс , который относится к положению , которое хранит значение модифицируемого Луы. Он содержит индексы стека между 1 и вершиной стека ( &lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt; ) плюс &lt;em&gt;псевдоиндексы&lt;/em&gt; , которые представляют некоторые позиции, доступные для кода C, но которых нет в стеке. &lt;a href=&quot;#4.5&quot;&gt;Псевдоиндексы&lt;/a&gt; используются для доступа к реестру (см. &amp;sect;4.5 ) и восходящих значений функции C (см. &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc2ccfd57dd2ee13db0881ad932f1a878faf0c64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;weak table&lt;/em&gt; is a table whose elements are &lt;em&gt;weak references&lt;/em&gt;. A weak reference is ignored by the garbage collector. In other words, if the only references to an object are weak references, then the garbage collector will collect that object.</source>
          <target state="translated">&lt;em&gt;Слабая таблица&lt;/em&gt; представляет собой таблицу, элементы которой являются &lt;em&gt;слабыми ссылками&lt;/em&gt; . Слабая ссылка игнорируется сборщиком мусора. Другими словами, если единственными ссылками на объект являются слабые ссылки, то сборщик мусора соберет этот объект.</target>
        </trans-unit>
        <trans-unit id="9fa55e8031d6eb3c6d20f33859dde00134235bf3" translate="yes" xml:space="preserve">
          <source>A block can be explicitly delimited to produce a single statement:</source>
          <target state="translated">Блок может быть четко разграничен для получения одного заявления:</target>
        </trans-unit>
        <trans-unit id="ec51a298084d5b31d4dab8833e20239393ee6e1e" translate="yes" xml:space="preserve">
          <source>A block is a list of statements, which are executed sequentially:</source>
          <target state="translated">Блок-это список операторов,которые выполняются последовательно:</target>
        </trans-unit>
        <trans-unit id="1a46bdc4d8fc003e74bbca9567f9845260ef3e19" translate="yes" xml:space="preserve">
          <source>A call of the form &lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; is called a &lt;em&gt;tail call&lt;/em&gt;. Lua implements &lt;em&gt;proper tail calls&lt;/em&gt; (or &lt;em&gt;proper tail recursion&lt;/em&gt;): in a tail call, the called function reuses the stack entry of the calling function. Therefore, there is no limit on the number of nested tail calls that a program can execute. However, a tail call erases any debug information about the calling function. Note that a tail call only happens with a particular syntax, where the &lt;b&gt;return&lt;/b&gt; has one single function call as argument; this syntax makes the calling function return exactly the returns of the called function. So, none of the following examples are tail calls:</source>
          <target state="translated">Вызов формы &lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; называется &lt;em&gt;хвостовым вызовом&lt;/em&gt; . Lua реализует &lt;em&gt;правильные хвостовые вызовы&lt;/em&gt; (или &lt;em&gt;правильную хвостовую рекурсию&lt;/em&gt; ): в хвостовом вызове вызываемая функция повторно использует запись в стеке вызывающей функции. Следовательно, нет ограничений на количество вложенных хвостовых вызовов, которые может выполнить программа. Однако хвостовой вызов стирает любую отладочную информацию о вызывающей функции. Обратите внимание, что хвостовой вызов происходит только с определенным синтаксисом, где в качестве аргумента у &lt;b&gt;возврата&lt;/b&gt; есть один единственный вызов функции; этот синтаксис заставляет вызывающую функцию возвращать в точности то, что возвращает вызываемая функция. Итак, ни один из следующих примеров не является хвостовым вызовом:</target>
        </trans-unit>
        <trans-unit id="d2afda0df1ca02ec9a60e9c8cfd19f5d2f5a92aa" translate="yes" xml:space="preserve">
          <source>A chunk can be stored in a file or in a string inside the host program. To execute a chunk, Lua first &lt;em&gt;loads&lt;/em&gt; it, precompiling the chunk's code into instructions for a virtual machine, and then Lua executes the compiled code with an interpreter for the virtual machine.</source>
          <target state="translated">Фрагмент может храниться в файле или в строке внутри основной программы. Чтобы выполнить фрагмент, Lua сначала &lt;em&gt;загружает&lt;/em&gt; его, предварительно компилируя код фрагмента в инструкции для виртуальной машины, а затем Lua выполняет скомпилированный код с интерпретатором для виртуальной машины.</target>
        </trans-unit>
        <trans-unit id="c4ee67ff442e191f14dbdcdb9233561f4dc58f7c" translate="yes" xml:space="preserve">
          <source>A chunk is also a block (see &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt;), and so local variables can be declared in a chunk outside any explicit block.</source>
          <target state="translated">&lt;a href=&quot;#3.3.2&quot;&gt;Чанк&lt;/a&gt; также является блоком (см. &amp;sect;3.3.2 ), поэтому локальные переменные могут быть объявлены в блоке вне любого явного блока.</target>
        </trans-unit>
        <trans-unit id="89f058cf87035dfffc923b06bddc388bf582fef2" translate="yes" xml:space="preserve">
          <source>A coroutine can terminate its execution in two ways: normally, when its main function returns (explicitly or implicitly, after the last instruction); and abnormally, if there is an unprotected error. In case of normal termination, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;true&lt;/b&gt;, plus any values returned by the coroutine main function. In case of errors, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;false&lt;/b&gt; plus an error object.</source>
          <target state="translated">Сопрограмма может завершить свое выполнение двумя способами: обычно, когда возвращается ее основная функция (явно или неявно, после последней инструкции); и ненормально, если есть незащищенная ошибка. В случае нормального завершения, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; возвращает &lt;b&gt;true&lt;/b&gt; плюс любые значения, возвращаемые основной функцией сопрограммы. В случае ошибок &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; возвращает &lt;b&gt;false&lt;/b&gt; плюс объект ошибки.</target>
        </trans-unit>
        <trans-unit id="27ee02330bdc9c7efb921e9fa622f05fad377bb4" translate="yes" xml:space="preserve">
          <source>A coroutine yields by calling &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt;. When a coroutine yields, the corresponding &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns immediately, even if the yield happens inside nested function calls (that is, not in the main function, but in a function directly or indirectly called by the main function). In the case of a yield, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; also returns &lt;b&gt;true&lt;/b&gt;, plus any values passed to &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt;. The next time you resume the same coroutine, it continues its execution from the point where it yielded, with the call to &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt; returning any extra arguments passed to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сопрограмма выдает результат, вызывая &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; &lt;/a&gt; . Когда сопрограмма уступает, соответствующий &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; возвращается немедленно, даже если доходность происходит внутри вызовов вложенных функций (то есть не в основной функции, а в функции, прямо или косвенно вызываемой основной функцией). В случае yield &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; также возвращает &lt;b&gt;true&lt;/b&gt; плюс любые значения, переданные в &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; &lt;/a&gt; . В следующий раз, когда вы возобновите ту же сопрограмму, она продолжит выполнение с той точки, в которой она была завершена, при этом вызов &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; &lt;/a&gt; возвращает любые дополнительные аргументы, переданные в &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3088438d805eed5e3fbd8b4df355ce4b0938eb" translate="yes" xml:space="preserve">
          <source>A detailed list of events controlled by metatables is given next. Each operation is identified by its corresponding key.</source>
          <target state="translated">Далее приводится подробный список событий,контролируемых метаданными.Каждая операция идентифицируется соответствующим ключом.</target>
        </trans-unit>
        <trans-unit id="11ece8c655dc36e8d6319d68c95bcaac2d49dfe7" translate="yes" xml:space="preserve">
          <source>A file handle is implemented as a full userdata, with a metatable called &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; (where &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; is a macro with the actual metatable's name). The metatable is created by the I/O library (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; файла реализован как полные пользовательские данные с метатаблицей под названием LUA_FILEHANDLE (где &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; - это макрос с фактическим именем метатаблицы). Метатаблица создается библиотекой ввода-вывода (см. &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd31b6026ec306c9598314c7a4fb9720392f25d4" translate="yes" xml:space="preserve">
          <source>A format string is a sequence of conversion options. The conversion options are as follows:</source>
          <target state="translated">Строка формата-это последовательность параметров преобразования.Опции преобразования представлены ниже:</target>
        </trans-unit>
        <trans-unit id="bbe12450770ac90f140b941579b60535c8af83cf" translate="yes" xml:space="preserve">
          <source>A function call in Lua has the following syntax:</source>
          <target state="translated">Вызов функции в Луа имеет следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="0cb80c7bdf41b4df631b1f8aa57077bfb622b3ca" translate="yes" xml:space="preserve">
          <source>A function definition is an executable expression, whose value has type &lt;em&gt;function&lt;/em&gt;. When Lua precompiles a chunk, all its function bodies are precompiled too. Then, whenever Lua executes the function definition, the function is &lt;em&gt;instantiated&lt;/em&gt; (or &lt;em&gt;closed&lt;/em&gt;). This function instance (or &lt;em&gt;closure&lt;/em&gt;) is the final value of the expression.</source>
          <target state="translated">Определение функции - это исполняемое выражение, значение которого имеет тип &lt;em&gt;function&lt;/em&gt; . Когда Lua предварительно компилирует чанк, все его тела функций также предварительно компилируются. Затем, когда Lua выполняет определение функции, функция &lt;em&gt;создается&lt;/em&gt; (или &lt;em&gt;закрывается&lt;/em&gt; ). Этот экземпляр функции (или &lt;em&gt;замыкание&lt;/em&gt; ) является последним значением выражения.</target>
        </trans-unit>
        <trans-unit id="def5b5d3fc526d80ec07c94970f2e05b00532d11" translate="yes" xml:space="preserve">
          <source>A global variable (not a function) that holds a string containing the running Lua version. The current value of this variable is &quot;&lt;code&gt;Lua 5.3&lt;/code&gt;&quot;.</source>
          <target state="translated">Глобальная переменная (не функция), которая содержит строку, содержащую запущенную версию Lua. Текущее значение этой переменной - &amp;laquo; &lt;code&gt;Lua 5.3&lt;/code&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="353c97fb2432c2d977afa942e47185d3456b4910" translate="yes" xml:space="preserve">
          <source>A global variable (not a function) that holds the global environment (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Lua itself does not use this variable; changing its value does not affect any environment, nor vice versa.</source>
          <target state="translated">Глобальная переменная (не функция), которая содержит глобальное окружение (см. &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ). Сам Lua не использует эту переменную; изменение его значения не влияет ни на какое окружение, и наоборот.</target>
        </trans-unit>
        <trans-unit id="bb9da1771a20805caac7264030f37560221e3663" translate="yes" xml:space="preserve">
          <source>A hook is disabled by setting &lt;code&gt;mask&lt;/code&gt; to zero.</source>
          <target state="translated">Ловушка отключается установкой &lt;code&gt;mask&lt;/code&gt; в ноль.</target>
        </trans-unit>
        <trans-unit id="22f3c7023ea10aed55497eb7b7366ee3b6a6cb22" translate="yes" xml:space="preserve">
          <source>A label is visible in the entire block where it is defined, except inside nested blocks where a label with the same name is defined and inside nested functions. A goto may jump to any visible label as long as it does not enter into the scope of a local variable.</source>
          <target state="translated">Метка видна во всем блоке,где она определена,за исключением вложенных блоков,где определена метка с тем же именем,и внутри вложенных функций.Goto может перепрыгнуть на любую видимую метку,если она не входит в область видимости локальной переменной.</target>
        </trans-unit>
        <trans-unit id="933dd832c6b0be5ada1dd95c6bacc46f4be4f532" translate="yes" xml:space="preserve">
          <source>A metatable controls how an object behaves in arithmetic operations, bitwise operations, order comparisons, concatenation, length operation, calls, and indexing. A metatable also can define a function to be called when a userdata or a table is garbage collected (&lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;).</source>
          <target state="translated">Метатаблица управляет поведением объекта в арифметических операциях, побитовых операциях, сравнении порядка, конкатенации, операции длины, вызовах и индексировании. Метатаблица также может определять функцию, которая будет вызываться, когда пользовательские данные или таблица собираются сборщиком мусора ( &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3fbf280f4f9e4cb8aa41cf93549ddcd00b0d6b38" translate="yes" xml:space="preserve">
          <source>A path is a string containing a sequence of &lt;em&gt;templates&lt;/em&gt; separated by semicolons. For each template, the function replaces each interrogation mark (if any) in the template with a copy of &lt;code&gt;name&lt;/code&gt; wherein all occurrences of &lt;code&gt;sep&lt;/code&gt; (a dot, by default) were replaced by &lt;code&gt;rep&lt;/code&gt; (the system's directory separator, by default), and then tries to open the resulting file name.</source>
          <target state="translated">Путь - это строка, содержащая последовательность &lt;em&gt;шаблонов,&lt;/em&gt; разделенных точкой с запятой. Для каждого шаблона функция заменяет каждый знак вопроса (если есть) в шаблоне копией &lt;code&gt;name&lt;/code&gt; котором все вхождения &lt;code&gt;sep&lt;/code&gt; (точка по умолчанию) были заменены на &lt;code&gt;rep&lt;/code&gt; (разделитель системного каталога по умолчанию), а затем пытается открыть получившееся имя файла.</target>
        </trans-unit>
        <trans-unit id="3592c30e99bab5898e5564c352fa7c9c589dc5de" translate="yes" xml:space="preserve">
          <source>A pattern can contain sub-patterns enclosed in parentheses; they describe &lt;em&gt;captures&lt;/em&gt;. When a match succeeds, the substrings of the subject string that match captures are stored (&lt;em&gt;captured&lt;/em&gt;) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt;, the part of the string matching &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; is stored as the first capture (and therefore has number 1); the character matching &quot;&lt;code&gt;.&lt;/code&gt;&quot; is captured with number 2, and the part matching &quot;&lt;code&gt;%s*&lt;/code&gt;&quot; has number 3.</source>
          <target state="translated">Шаблон может содержать вложенные шаблоны, заключенные в круглые скобки; они описывают &lt;em&gt;захваты&lt;/em&gt; . При успешном совпадении подстроки строки темы, соответствующие &lt;em&gt;захваченным,&lt;/em&gt; сохраняются ( &lt;em&gt;захватываются&lt;/em&gt; ) для будущего использования. Захваты нумеруются в соответствии с их левыми скобками. Например, в шаблоне &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt; часть строки, соответствующей &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; , сохраняется как первая запись ( и поэтому имеет номер 1); соответствующий символ &quot; &lt;code&gt;.&lt;/code&gt; &quot; записывается под номером 2, а часть, соответствующая &quot; &lt;code&gt;%s*&lt;/code&gt; &quot;, имеет номер 3.</target>
        </trans-unit>
        <trans-unit id="38cf749bb9ad3579d6b255d66e52681d302f2ddf" translate="yes" xml:space="preserve">
          <source>A pointer to a thread must be passed as the first argument to every function in the library, except to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;, which creates a Lua state from scratch and returns a pointer to the &lt;em&gt;main thread&lt;/em&gt; in the new state.</source>
          <target state="translated">Указатель на поток должен быть передан в качестве первого аргумента каждой функции в библиотеке, кроме &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; , которая создает состояние Lua с нуля и возвращает указатель на &lt;em&gt;основной поток&lt;/em&gt; в новом состоянии.</target>
        </trans-unit>
        <trans-unit id="9f720f6817ac0c98d606b9b7538ff16874a21500" translate="yes" xml:space="preserve">
          <source>A pointer to this structure must be passed as the first argument to every function in the library, except to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;, which creates a Lua state from scratch.</source>
          <target state="translated">Указатель на эту структуру должен быть передан в качестве первого аргумента каждой функции в библиотеке, кроме &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; , которая создает состояние Lua с нуля.</target>
        </trans-unit>
        <trans-unit id="85de206f279ceaa430602580da3ee35a9d16cd8a" translate="yes" xml:space="preserve">
          <source>A program can modify the behavior of the length operator for any value but strings through the &lt;code&gt;__len&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Программа может изменять поведение оператора длины для любого значения, кроме строк, с помощью &lt;code&gt;__len&lt;/code&gt; (см. &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd8bd19d7a0da2968b0e0676ae5bf0fd9c2f4e0b" translate="yes" xml:space="preserve">
          <source>A reference is a unique integer key. As long as you do not manually add integer keys into table &lt;code&gt;t&lt;/code&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; ensures the uniqueness of the key it returns. You can retrieve an object referred by reference &lt;code&gt;r&lt;/code&gt; by calling &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt;. Function &lt;a href=&quot;#luaL_unref&quot;&gt;&lt;code&gt;luaL_unref&lt;/code&gt;&lt;/a&gt; frees a reference and its associated object.</source>
          <target state="translated">Ссылка - это уникальный целочисленный ключ. Пока вы не добавляете вручную целочисленные ключи в таблицу &lt;code&gt;t&lt;/code&gt; , &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; гарантирует уникальность возвращаемого ключа. Вы можете получить объект, на который ссылается ссылка &lt;code&gt;r&lt;/code&gt; , вызвав &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt; . Функция &lt;a href=&quot;#luaL_unref&quot;&gt; &lt;code&gt;luaL_unref&lt;/code&gt; &lt;/a&gt; освобождает ссылку и связанный с ней объект.</target>
        </trans-unit>
        <trans-unit id="5886b914eeefc6fe9c97cf73899590f4453edb42" translate="yes" xml:space="preserve">
          <source>A running coroutine is yieldable if it is not the main thread and it is not inside a non-yieldable C function.</source>
          <target state="translated">Бегущая коруэтина является продуктивной,если она не является основным потоком и не находится внутри непродуктивной функции C.</target>
        </trans-unit>
        <trans-unit id="02104a4bea2c474acf11ad8559dae77d59bc940e" translate="yes" xml:space="preserve">
          <source>A single name can denote a global variable or a local variable (or a function's formal parameter, which is a particular kind of local variable):</source>
          <target state="translated">Одно имя может обозначать глобальную или локальную переменную (или формальный параметр функции,которая является определенным видом локальной переменной):</target>
        </trans-unit>
        <trans-unit id="4794c70aa8c69ef2ec8802a8dbbec4cdd33e83e8" translate="yes" xml:space="preserve">
          <source>A string buffer allows C code to build Lua strings piecemeal. Its pattern of use is as follows:</source>
          <target state="translated">Строковый буфер позволяет C-коду строить строки Lua по частям.Схема его использования выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="f87ecc6b4255bdd2af412051775ae09429630fe0" translate="yes" xml:space="preserve">
          <source>A string describing some compile-time configurations for packages. This string is a sequence of lines:</source>
          <target state="translated">Строка,описывающая некоторые конфигурации во время компиляции пакетов.Эта строка представляет собой последовательность строк:</target>
        </trans-unit>
        <trans-unit id="fec6a000811b19de6807d9f5d778634007385bd8" translate="yes" xml:space="preserve">
          <source>A structure used to carry different pieces of information about a function or an activation record. &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; fills only the private part of this structure, for later use. To fill the other fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; with useful information, call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Структура, используемая для передачи различной информации о функции или записи активации. &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; заполняет только приватную часть этой структуры для дальнейшего использования. Чтобы заполнить другие поля &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; полезной информацией, вызовите &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f70841dbcffb4668b72f4ee9f5d20362ac22ade" translate="yes" xml:space="preserve">
          <source>A table to store loaders for specific modules (see &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Таблица для хранения загрузчиков для определенных модулей (см. &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="04907543b8fecfeecd0da3b12b889da3eb87f79e" translate="yes" xml:space="preserve">
          <source>A table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to control how to load modules.</source>
          <target state="translated">Таблица, используемая &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; для управления загрузкой модулей.</target>
        </trans-unit>
        <trans-unit id="236d800446c3c980d88f62e84b598b19165287ba" translate="yes" xml:space="preserve">
          <source>A table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to control which modules are already loaded. When you require a module &lt;code&gt;modname&lt;/code&gt; and &lt;code&gt;package.loaded[modname]&lt;/code&gt; is not false, &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; simply returns the value stored there.</source>
          <target state="translated">Таблица, используемая &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; ,&lt;/a&gt; чтобы контролировать, какие модули уже загружены. Когда требуется модуль &lt;code&gt;modname&lt;/code&gt; и &lt;code&gt;package.loaded[modname]&lt;/code&gt; не является ложным, &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; просто возвращает значение , хранящееся там.</target>
        </trans-unit>
        <trans-unit id="3862e82890432c457763712f15a7fd6f5e4a1a62" translate="yes" xml:space="preserve">
          <source>A table with exactly one border is called a &lt;em&gt;sequence&lt;/em&gt;. For instance, the table &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; is a sequence, as it has only one border (5). The table &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; has two borders (3 and 5), and therefore it is not a sequence. The table &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; has three borders (0, 3, and 6), so it is not a sequence, too. The table &lt;code&gt;{}&lt;/code&gt; is a sequence with border 0. Note that non-natural keys do not interfere with whether a table is a sequence.</source>
          <target state="translated">Таблица с одной границей называется &lt;em&gt;последовательностью&lt;/em&gt; . Например, таблица &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; является последовательностью, так как у нее только одна граница (5). Таблица &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; имеет две границы (3 и 5), поэтому она не является последовательностью. Таблица &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; имеет три границы (0, 3 и 6), так что это тоже не последовательность. Таблица &lt;code&gt;{}&lt;/code&gt; представляет собой последовательность с границей 0. Обратите внимание, что неестественные ключи не влияют на то, является ли таблица последовательностью.</target>
        </trans-unit>
        <trans-unit id="0d3f40da2d8f70f83b27ea28adbba3891980e807" translate="yes" xml:space="preserve">
          <source>A table with weak keys and strong values is also called an &lt;em&gt;ephemeron table&lt;/em&gt;. In an ephemeron table, a value is considered reachable only if its key is reachable. In particular, if the only reference to a key comes through its value, the pair is removed.</source>
          <target state="translated">Таблица со слабыми ключами и сильными значениями также называется &lt;em&gt;таблицей эфемеронов&lt;/em&gt; . В таблице эфемеронов значение считается достижимым, только если доступен его ключ. В частности, если единственная ссылка на ключ проходит через его значение, пара удаляется.</target>
        </trans-unit>
        <trans-unit id="4654fe97bf7d302a9567895699edd89cbcd9e791" translate="yes" xml:space="preserve">
          <source>A typical traversal looks like this:</source>
          <target state="translated">Типичный обход выглядит так:</target>
        </trans-unit>
        <trans-unit id="56d6e1795249533ab7eb0411e5a66433e31c3e9e" translate="yes" xml:space="preserve">
          <source>A weak table can have weak keys, weak values, or both. A table with weak values allows the collection of its values, but prevents the collection of its keys. A table with both weak keys and weak values allows the collection of both keys and values. In any case, if either the key or the value is collected, the whole pair is removed from the table. The weakness of a table is controlled by the &lt;code&gt;__mode&lt;/code&gt; field of its metatable. If the &lt;code&gt;__mode&lt;/code&gt; field is a string containing the character '&lt;code&gt;k&lt;/code&gt;', the keys in the table are weak. If &lt;code&gt;__mode&lt;/code&gt; contains '&lt;code&gt;v&lt;/code&gt;', the values in the table are weak.</source>
          <target state="translated">Слабая таблица может иметь слабые ключи, слабые значения или и то, и другое. Таблица со слабыми значениями позволяет собирать свои значения, но не позволяет собирать ключи. Таблица со слабыми ключами и слабыми значениями позволяет собирать как ключи, так и значения. В любом случае, если собирается ключ или значение, вся пара удаляется из таблицы. Слабость таблицы контролируется полем &lt;code&gt;__mode&lt;/code&gt; ее метатаблицы. Если поле &lt;code&gt;__mode&lt;/code&gt; представляет собой строку, содержащую символ &amp;laquo; &lt;code&gt;k&lt;/code&gt; &amp;raquo;, ключи в таблице являются слабыми. Если &lt;code&gt;__mode&lt;/code&gt; содержит ' &lt;code&gt;v&lt;/code&gt; ', значения в таблице слабые.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="be7df36d7d8ed1468bab871c0aefed53b43ba4c0" translate="yes" xml:space="preserve">
          <source>Acceptable indices serve to avoid extra tests against the stack top when querying the stack. For instance, a C function can query its third argument without the need to first check whether there is a third argument, that is, without the need to check whether 3 is a valid index.</source>
          <target state="translated">Допустимые индексы служат для того,чтобы избежать дополнительных тестов против вершины стека при запросе стека.Например,функция C может опрашивать свой третий аргумент без необходимости сначала проверять,есть ли третий аргумент,то есть без необходимости проверять,является ли 3 допустимым индексом.</target>
        </trans-unit>
        <trans-unit id="f9bead715d3aed55f00ef8b226e3b3d6b628f98c" translate="yes" xml:space="preserve">
          <source>Accepts any index, or 0, and sets the stack top to this index. If the new top is larger than the old one, then the new elements are filled with &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;index&lt;/code&gt; is 0, then all stack elements are removed.</source>
          <target state="translated">Принимает любой индекс или 0 и устанавливает вершину стека на этот индекс. Если новая вершина больше старой, то новые элементы заполняются &lt;b&gt;нулем&lt;/b&gt; . Если &lt;code&gt;index&lt;/code&gt; равен 0, то все элементы стека удаляются.</target>
        </trans-unit>
        <trans-unit id="fa67d1b55b60391424ed0215f797f8cda588620a" translate="yes" xml:space="preserve">
          <source>Adds the byte &lt;code&gt;c&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Добавляет байт &lt;code&gt;c&lt;/code&gt; в буфер &lt;code&gt;B&lt;/code&gt; (см. &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e90d8fb3354b196fdab7ad34fbe37926f7654b63" translate="yes" xml:space="preserve">
          <source>Adds the string pointed to by &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;l&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). The string can contain embedded zeros.</source>
          <target state="translated">Добавляет строку, &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; &lt;code&gt;s&lt;/code&gt; , длиной &lt;code&gt;l&lt;/code&gt; в буфер &lt;code&gt;B&lt;/code&gt; (см. LuaL_Buffer ). Строка может содержать встроенные нули.</target>
        </trans-unit>
        <trans-unit id="a1554fdc1fb0aa862c71bc7fc397a26d3a4ef58d" translate="yes" xml:space="preserve">
          <source>Adds the value at the top of the stack to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). Pops the value.</source>
          <target state="translated">Добавляет значение наверху стека в буфер &lt;code&gt;B&lt;/code&gt; (см. &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ). Выдвигает значение.</target>
        </trans-unit>
        <trans-unit id="805463d8104725860e0a53e77554865962b221ce" translate="yes" xml:space="preserve">
          <source>Adds the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Добавляет строку с завершающим нулем, на которую указывает &lt;code&gt;s&lt;/code&gt; , в буфер &lt;code&gt;B&lt;/code&gt; (см. &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="71ca21350559a88942a584e333d8d2fdeaeb2968" translate="yes" xml:space="preserve">
          <source>Adds to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;) a string of length &lt;code&gt;n&lt;/code&gt; previously copied to the buffer area (see &lt;a href=&quot;#luaL_prepbuffer&quot;&gt;&lt;code&gt;luaL_prepbuffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Добавляет в буфер &lt;code&gt;B&lt;/code&gt; (см. &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ) строку длины &lt;code&gt;n&lt;/code&gt; , ранее скопированную в область буфера (см. &lt;a href=&quot;#luaL_prepbuffer&quot;&gt; &lt;code&gt;luaL_prepbuffer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a9bf8213e7ff3700b5b856d615911be85fad5679" translate="yes" xml:space="preserve">
          <source>After handling its options, &lt;code&gt;lua&lt;/code&gt; runs the given &lt;em&gt;script&lt;/em&gt;. When called without arguments, &lt;code&gt;lua&lt;/code&gt; behaves as &lt;code&gt;lua -v -i&lt;/code&gt; when the standard input (&lt;code&gt;stdin&lt;/code&gt;) is a terminal, and as &lt;code&gt;lua -&lt;/code&gt; otherwise.</source>
          <target state="translated">После обработки опций &lt;code&gt;lua&lt;/code&gt; запускает данный &lt;em&gt;сценарий&lt;/em&gt; . При вызове без аргументов &lt;code&gt;lua&lt;/code&gt; ведет себя как &lt;code&gt;lua -v -i&lt;/code&gt; , когда стандартный ввод ( &lt;code&gt;stdin&lt;/code&gt; ) является терминалом, и как &lt;code&gt;lua -&lt;/code&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="15063350c6a79260afaac68065c69671ef9eeded" translate="yes" xml:space="preserve">
          <source>Alignment works as follows: For each option, the format gets extra padding until the data starts at an offset that is a multiple of the minimum between the option size and the maximum alignment; this minimum must be a power of 2. Options &quot;&lt;code&gt;c&lt;/code&gt;&quot; and &quot;&lt;code&gt;z&lt;/code&gt;&quot; are not aligned; option &quot;&lt;code&gt;s&lt;/code&gt;&quot; follows the alignment of its starting integer.</source>
          <target state="translated">Выравнивание работает следующим образом: для каждой опции формат получает дополнительное заполнение до тех пор, пока данные не начнутся со смещения, кратного минимальному между размером опции и максимальным выравниванием; этот минимум должен быть степенью 2. Опции &amp;laquo; &lt;code&gt;c&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;z&lt;/code&gt; &amp;raquo; не совпадают; опция &amp;laquo; &lt;code&gt;s&lt;/code&gt; &amp;raquo; следует за выравниванием его начального целого числа.</target>
        </trans-unit>
        <trans-unit id="3f5b4e7445d1ae596693345d80aebb59b269536b" translate="yes" xml:space="preserve">
          <source>All argument expressions are evaluated before the call. A call of the form &lt;code&gt;f{&lt;em&gt;fields&lt;/em&gt;}&lt;/code&gt; is syntactic sugar for &lt;code&gt;f({&lt;em&gt;fields&lt;/em&gt;})&lt;/code&gt;; that is, the argument list is a single new table. A call of the form &lt;code&gt;f'&lt;em&gt;string&lt;/em&gt;'&lt;/code&gt; (or &lt;code&gt;f&quot;&lt;em&gt;string&lt;/em&gt;&quot;&lt;/code&gt; or &lt;code&gt;f[[&lt;em&gt;string&lt;/em&gt;]]&lt;/code&gt;) is syntactic sugar for &lt;code&gt;f('&lt;em&gt;string&lt;/em&gt;')&lt;/code&gt;; that is, the argument list is a single literal string.</source>
          <target state="translated">Все выражения аргументов оцениваются перед вызовом. Вызов формы &lt;code&gt;f{&lt;em&gt;fields&lt;/em&gt;}&lt;/code&gt; является синтаксическим сахаром для &lt;code&gt;f({&lt;em&gt;fields&lt;/em&gt;})&lt;/code&gt; ; то есть список аргументов - это одна новая таблица. Вызов формы &lt;code&gt;f'&lt;em&gt;string&lt;/em&gt;'&lt;/code&gt; (или &lt;code&gt;f&quot;&lt;em&gt;string&lt;/em&gt;&quot;&lt;/code&gt; или &lt;code&gt;f[[&lt;em&gt;string&lt;/em&gt;]]&lt;/code&gt; ) является синтаксическим сахаром для &lt;code&gt;f('&lt;em&gt;string&lt;/em&gt;')&lt;/code&gt; ; то есть список аргументов представляет собой одну буквальную строку.</target>
        </trans-unit>
        <trans-unit id="acc9b360c0f165382f26927b4e5133003a413b44" translate="yes" xml:space="preserve">
          <source>All bitwise operations convert its operands to integers (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;), operate on all bits of those integers, and result in an integer.</source>
          <target state="translated">Все побитовые операции преобразуют его операнды в целые числа (см. &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ), работают со всеми битами этих целых чисел и приводят к целому числу.</target>
        </trans-unit>
        <trans-unit id="f305da96ae003ba3953ef2d24d1bf9f7d1a7db44" translate="yes" xml:space="preserve">
          <source>All conversions from strings to numbers accept both a dot and the current locale mark as the radix character. (The Lua lexer, however, accepts only a dot.)</source>
          <target state="translated">Все преобразования из строк в числа принимают как точку,так и текущую метку локали в качестве символа радиуса.(Лексер Lua,однако,принимает только точку).</target>
        </trans-unit>
        <trans-unit id="e8fc76868f788278527229cf8ae331ac5e9af057" translate="yes" xml:space="preserve">
          <source>All functions and types from the auxiliary library are defined in header file &lt;code&gt;lauxlib.h&lt;/code&gt; and have a prefix &lt;code&gt;luaL_&lt;/code&gt;.</source>
          <target state="translated">Все функции и типы из вспомогательной библиотеки определены в заголовочном файле &lt;code&gt;lauxlib.h&lt;/code&gt; и имеют префикс &lt;code&gt;luaL_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b5a80d9354e5e4fed6af6805ce75ff37321a509" translate="yes" xml:space="preserve">
          <source>All functions in the auxiliary library are built on top of the basic API, and so they provide nothing that cannot be done with that API. Nevertheless, the use of the auxiliary library ensures more consistency to your code.</source>
          <target state="translated">Все функции во вспомогательной библиотеке построены поверх основного API,поэтому они не предоставляют ничего,что нельзя было бы сделать с этим API.Тем не менее,использование вспомогательной библиотеки обеспечивает большую согласованность с вашим кодом.</target>
        </trans-unit>
        <trans-unit id="f6848b784c95c8339b84a72671e794bafd5c29ba" translate="yes" xml:space="preserve">
          <source>All functions in this library are provided inside the &lt;a id=&quot;pdf-debug&quot;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt; table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread.</source>
          <target state="translated">Все функции в этой библиотеке представлены в таблице &lt;a id=&quot;pdf-debug&quot;&gt; &lt;code&gt;debug&lt;/code&gt; &lt;/a&gt; . Все функции, которые работают с потоком, имеют необязательный первый аргумент, который является потоком, над которым нужно работать. По умолчанию всегда используется текущий поток.</target>
        </trans-unit>
        <trans-unit id="8b98fc2da2d38e4cd78c4bb220a6cf5b66fcdbf5" translate="yes" xml:space="preserve">
          <source>All libraries are implemented through the official C API and are provided as separate C modules. Currently, Lua has the following standard libraries:</source>
          <target state="translated">Все библиотеки реализованы через официальное C API и предоставляются в виде отдельных модулей на C.В настоящее время Lua имеет следующие стандартные библиотеки:</target>
        </trans-unit>
        <trans-unit id="10be42d50eaafb61e391ebcac5db4409c7956116" translate="yes" xml:space="preserve">
          <source>All options are handled in order, except &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;-E&lt;/code&gt;. For instance, an invocation like</source>
          <target state="translated">Все параметры обрабатываются по порядку, кроме &lt;code&gt;-i&lt;/code&gt; и &lt;code&gt;-E&lt;/code&gt; . Например, такой вызов, как</target>
        </trans-unit>
        <trans-unit id="1b7b7722940601955048fe77c6f31cf2d41c7761" translate="yes" xml:space="preserve">
          <source>All padding is filled with zeros by &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; (and ignored by &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Все отступы заполняются нулями в &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; (и игнорируются &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c35badbdc9570c80976734173cdf4107df29b353" translate="yes" xml:space="preserve">
          <source>All searchers except the first one (preload) return as the extra value the file name where the module was found, as returned by &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. The first searcher returns no extra value.</source>
          <target state="translated">Все поисковые системы, кроме первого (предварительная загрузка), возвращают в качестве дополнительного значения имя файла, в котором был найден модуль, как это было возвращено &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; &lt;/a&gt; . Первый искатель не возвращает никаких дополнительных значений.</target>
        </trans-unit>
        <trans-unit id="99fdaa228f269a7cd440d59ce3942091cbc2215f" translate="yes" xml:space="preserve">
          <source>All three control expressions are evaluated only once, before the loop starts. They must all result in numbers.</source>
          <target state="translated">Все три управляющих выражения вычисляются только один раз,до начала цикла.Все они должны приводить к цифрам.</target>
        </trans-unit>
        <trans-unit id="08a75b1f27277905293829400b5db953b7bb2d39" translate="yes" xml:space="preserve">
          <source>All values in Lua are &lt;em&gt;first-class values&lt;/em&gt;. This means that all values can be stored in variables, passed as arguments to other functions, and returned as results.</source>
          <target state="translated">Все значения в Lua являются &lt;em&gt;первоклассными&lt;/em&gt; . Это означает, что все значения могут храниться в переменных, передаваться в качестве аргументов другим функциям и возвращаться как результаты.</target>
        </trans-unit>
        <trans-unit id="2bd0e37afd18d9af3189d6b1b6cc7f9956125931" translate="yes" xml:space="preserve">
          <source>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. &lt;code&gt;next&lt;/code&gt; returns the next index of the table and its associated value. When called with &lt;b&gt;nil&lt;/b&gt; as its second argument, &lt;code&gt;next&lt;/code&gt; returns an initial index and its associated value. When called with the last index, or with &lt;b&gt;nil&lt;/b&gt; in an empty table, &lt;code&gt;next&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;. If the second argument is absent, then it is interpreted as &lt;b&gt;nil&lt;/b&gt;. In particular, you can use &lt;code&gt;next(t)&lt;/code&gt; to check whether a table is empty.</source>
          <target state="translated">Позволяет программе перемещаться по всем полям таблицы. Его первый аргумент - это таблица, а второй аргумент - это индекс в этой таблице. &lt;code&gt;next&lt;/code&gt; возвращает следующий индекс таблицы и связанное с ним значение. При вызове с &lt;b&gt;nil в&lt;/b&gt; качестве второго аргумента &lt;code&gt;next&lt;/code&gt; возвращает начальный индекс и связанное с ним значение. При вызове с последним индексом или с &lt;b&gt;nil&lt;/b&gt; в пустой таблице &lt;code&gt;next&lt;/code&gt; возвращает &lt;b&gt;nil&lt;/b&gt; . Если второй аргумент отсутствует, он интерпретируется как &lt;b&gt;ноль&lt;/b&gt; . В частности, вы можете использовать &lt;code&gt;next(t)&lt;/code&gt; чтобы проверить, пуста ли таблица.</target>
        </trans-unit>
        <trans-unit id="1e2a17f106d80620dc6b184a036cc43c0d0d20e9" translate="yes" xml:space="preserve">
          <source>Also as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, this function only loads the chunk; it does not run it.</source>
          <target state="translated">Также как &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; , эта функция загружает только фрагмент; он его не запускает.</target>
        </trans-unit>
        <trans-unit id="333012935d43c77111be49619f3626aed605f1f6" translate="yes" xml:space="preserve">
          <source>Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a standalone language. An interpreter for Lua as a standalone language, called simply &lt;code&gt;lua&lt;/code&gt;, is provided with the standard distribution. The standalone interpreter includes all standard libraries, including the debug library. Its usage is:</source>
          <target state="translated">Хотя Lua был разработан как язык расширения для встраивания в хост-программу C, он также часто используется как автономный язык. Интерпретатор Lua как отдельного языка, называемый просто &lt;code&gt;lua&lt;/code&gt; , входит в стандартный дистрибутив. Автономный интерпретатор включает в себя все стандартные библиотеки, включая библиотеку отладки. Его использование:</target>
        </trans-unit>
        <trans-unit id="f591bdff24ecb3f0d81234f57e546b0357fc181a" translate="yes" xml:space="preserve">
          <source>An access to a global variable &lt;code&gt;x&lt;/code&gt; is equivalent to &lt;code&gt;_ENV.x&lt;/code&gt;. Due to the way that chunks are compiled, &lt;code&gt;_ENV&lt;/code&gt; is never a global name (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="translated">Доступ к глобальной переменной &lt;code&gt;x&lt;/code&gt; эквивалентен &lt;code&gt;_ENV.x&lt;/code&gt; . Из-за способа компиляции &lt;code&gt;_ENV&lt;/code&gt; никогда не является глобальным именем (см. &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3489bcbcdb764986900a0e61314738b50570455a" translate="yes" xml:space="preserve">
          <source>An assignment to a global name &lt;code&gt;x = val&lt;/code&gt; is equivalent to the assignment &lt;code&gt;_ENV.x = val&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="translated">Присвоение глобального имени &lt;code&gt;x = val&lt;/code&gt; эквивалентно присваиванию &lt;code&gt;_ENV.x = val&lt;/code&gt; (см. &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="faeac64cb85287d304252a69d85edf0374894817" translate="yes" xml:space="preserve">
          <source>An integer with the maximum value for an integer.</source>
          <target state="translated">Целое число с максимальным значением для целого числа.</target>
        </trans-unit>
        <trans-unit id="7043af6943c0de40fedd4cee1164e62e2ee3cd11" translate="yes" xml:space="preserve">
          <source>An integer with the minimum value for an integer.</source>
          <target state="translated">Целое число с минимальным значением для целого числа.</target>
        </trans-unit>
        <trans-unit id="29302dcac6eba15dcddc4542a902b42251fa77ed" translate="yes" xml:space="preserve">
          <source>An opaque structure that points to a thread and indirectly (through the thread) to the whole state of a Lua interpreter. The Lua library is fully reentrant: it has no global variables. All information about a state is accessible through this structure.</source>
          <target state="translated">Непрозрачная структура,которая указывает на нить и косвенно (через нить)на все состояние интерпретатора Lua.Библиотека Lua полностью реентерабельная:в ней нет глобальных переменных.Вся информация о состоянии доступна через эту структуру.</target>
        </trans-unit>
        <trans-unit id="3b2afdee2bff80f7fa27a65f139ce4ca79afecee" translate="yes" xml:space="preserve">
          <source>Any byte in a literal string not explicitly affected by the previous rules represents itself. However, Lua opens files for parsing in text mode, and the system file functions may have problems with some control characters. So, it is safer to represent non-text data as a quoted literal with explicit escape sequences for the non-text characters.</source>
          <target state="translated">Любой байт в строке литерала,не затронутый явно предыдущими правилами,представляет себя сам.Тем не менее,Lua открывает файлы для разбора в текстовом режиме,и системные файловые функции могут иметь проблемы с некоторыми управляющими символами.Поэтому безопаснее представлять нетекстовые данные в виде цитируемого литерала с явными экранирующими последовательностями для нетекстовых символов.</target>
        </trans-unit>
        <trans-unit id="0060ede52bc0952daad17758c1e09ebce620eaf5" translate="yes" xml:space="preserve">
          <source>Any change in the weakness of a table may take effect only at the next collect cycle. In particular, if you change the weakness to a stronger mode, Lua may still collect some items from that table before the change takes effect.</source>
          <target state="translated">Любое изменение слабости таблицы может вступить в силу только при следующем цикле сбора.В частности,если вы измените слабость на более сильный режим,Lua все равно может забрать некоторые предметы из этого стола до того,как изменение вступит в силу.</target>
        </trans-unit>
        <trans-unit id="3f738315de077ed686d71d19c5f4cc3874696c9c" translate="yes" xml:space="preserve">
          <source>Any error inside the called function is propagated upwards (with a &lt;code&gt;longjmp&lt;/code&gt;).</source>
          <target state="translated">Любая ошибка внутри вызываемой функции распространяется вверх (с помощью &lt;code&gt;longjmp&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7b037f464e01b904a69f5673d5e1aeced352fda1" translate="yes" xml:space="preserve">
          <source>Any expression enclosed in parentheses always results in only one value. Thus, &lt;code&gt;(f(x,y,z))&lt;/code&gt; is always a single value, even if &lt;code&gt;f&lt;/code&gt; returns several values. (The value of &lt;code&gt;(f(x,y,z))&lt;/code&gt; is the first value returned by &lt;code&gt;f&lt;/code&gt; or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;f&lt;/code&gt; does not return any values.)</source>
          <target state="translated">Любое выражение, заключенное в круглые скобки, всегда дает только одно значение. Таким образом, &lt;code&gt;(f(x,y,z))&lt;/code&gt; всегда является одним значением, даже если &lt;code&gt;f&lt;/code&gt; возвращает несколько значений. (Значение &lt;code&gt;(f(x,y,z))&lt;/code&gt; - это первое значение, возвращаемое &lt;code&gt;f&lt;/code&gt; или &lt;b&gt;nil,&lt;/b&gt; если &lt;code&gt;f&lt;/code&gt; не возвращает никаких значений.)</target>
        </trans-unit>
        <trans-unit id="7a4d95ffedc5bbaa1adc38079189908a5033db52" translate="yes" xml:space="preserve">
          <source>Any format string starts as if prefixed by &quot;&lt;code&gt;!1=&lt;/code&gt;&quot;, that is, with maximum alignment of 1 (no alignment) and native endianness.</source>
          <target state="translated">Любая строка формата начинается с префикса &quot; &lt;code&gt;!1=&lt;/code&gt; &quot;, то есть с максимального выравнивания 1 (без выравнивания) и естественного порядка байтов.</target>
        </trans-unit>
        <trans-unit id="646e2060904f262b44a42847531c18e9dbcd493e" translate="yes" xml:space="preserve">
          <source>Any function in the API that receives stack indices works only with &lt;em&gt;valid indices&lt;/em&gt; or &lt;em&gt;acceptable indices&lt;/em&gt;.</source>
          <target state="translated">Любая функция в API, которая получает индексы стека, работает только с &lt;em&gt;действительными индексами&lt;/em&gt; или &lt;em&gt;допустимыми индексами&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1687626599a587d25400fc4ce2fc6e934da6f356" translate="yes" xml:space="preserve">
          <source>Any function to be callable by Lua must follow the correct protocol to receive its parameters and return its results (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Любая функция, вызываемая Lua, должна следовать правильному протоколу, чтобы получать свои параметры и возвращать результаты (см. &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="185d7a33eb3655abd764787ebf509971ea6392f6" translate="yes" xml:space="preserve">
          <source>Any table used as the value of &lt;code&gt;_ENV&lt;/code&gt; is called an &lt;em&gt;environment&lt;/em&gt;.</source>
          <target state="translated">Любая таблица, используемая в качестве значения &lt;code&gt;_ENV&lt;/code&gt; , называется &lt;em&gt;средой&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c786e87f6aa7c682c7c682888f5d96ee64056b" translate="yes" xml:space="preserve">
          <source>Any variable name is assumed to be global unless explicitly declared as a local (see &lt;a href=&quot;#3.3.7&quot;&gt;&amp;sect;3.3.7&lt;/a&gt;). Local variables are &lt;em&gt;lexically scoped&lt;/em&gt;: local variables can be freely accessed by functions defined inside their scope (see &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;).</source>
          <target state="translated">Предполагается, что любое имя переменной является глобальным, если оно явно не объявлено как локальное (см. &lt;a href=&quot;#3.3.7&quot;&gt;&amp;sect;3.3.7&lt;/a&gt; ). Локальные переменные имеют &lt;em&gt;лексическую область видимости&lt;/em&gt; : к локальным переменным могут свободно обращаться функции, определенные внутри их области видимости (см. &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a78246fd7dee1462777916bec1d99382a25c060e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;f&lt;/code&gt; is the hook function. &lt;code&gt;mask&lt;/code&gt; specifies on which events the hook will be called: it is formed by a bitwise OR of the constants &lt;a id=&quot;pdf-LUA_MASKCALL&quot;&gt;&lt;code&gt;LUA_MASKCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_MASKRET&quot;&gt;&lt;code&gt;LUA_MASKRET&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_MASKLINE&quot;&gt;&lt;code&gt;LUA_MASKLINE&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_MASKCOUNT&quot;&gt;&lt;code&gt;LUA_MASKCOUNT&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;count&lt;/code&gt; argument is only meaningful when the mask includes &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt;. For each event, the hook is called as explained below:</source>
          <target state="translated">Аргумент &lt;code&gt;f&lt;/code&gt; - это функция перехвата. &lt;code&gt;mask&lt;/code&gt; определяет, для каких событий будет вызвана ловушка: она формируется побитовым ИЛИ констант &lt;a id=&quot;pdf-LUA_MASKCALL&quot;&gt; &lt;code&gt;LUA_MASKCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_MASKRET&quot;&gt; &lt;code&gt;LUA_MASKRET&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_MASKLINE&quot;&gt; &lt;code&gt;LUA_MASKLINE&lt;/code&gt; &lt;/a&gt; и &lt;a id=&quot;pdf-LUA_MASKCOUNT&quot;&gt; &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;count&lt;/code&gt; аргументов имеет смысл только , когда маска включает в себя &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt; . Для каждого события хук вызывается, как описано ниже:</target>
        </trans-unit>
        <trans-unit id="fef66cc0524e2056cb5b4bfefd4a25591b35ea85" translate="yes" xml:space="preserve">
          <source>Arguments have the following syntax:</source>
          <target state="translated">Аргументы имеют следующий синтаксис:</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">арифметические операторы</target>
        </trans-unit>
        <trans-unit id="9c834ef6f4ffe0319762efe06a63f2041cc46cbe" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, this function only loads the chunk; it does not run it.</source>
          <target state="translated">Как и &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; , эта функция загружает только чанк; он его не запускает.</target>
        </trans-unit>
        <trans-unit id="88fec743575b609e2abb343864ded003e7d1df35" translate="yes" xml:space="preserve">
          <source>As a special case, the empty capture &lt;code&gt;()&lt;/code&gt; captures the current string position (a number). For instance, if we apply the pattern &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; on the string &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt;, there will be two captures: 3 and 5.</source>
          <target state="translated">В качестве особого случая пустой capture &lt;code&gt;()&lt;/code&gt; захватывает текущую позицию строки (число). Например, если мы применим шаблон &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; к строке &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt; , будет два захвата: 3 и 5.</target>
        </trans-unit>
        <trans-unit id="608b10320a24077d4060bee1b1e8e54c6bf52c0d" translate="yes" xml:space="preserve">
          <source>As a special case, when &lt;code&gt;n&lt;/code&gt; is 0 the function returns the start of the encoding of the character that contains the &lt;code&gt;i&lt;/code&gt;-th byte of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">В качестве особого случая, когда &lt;code&gt;n&lt;/code&gt; равно 0, функция возвращает начало кодировки символа, который содержит &lt;code&gt;i&lt;/code&gt; -й байт числа &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f16f56abca8a29fd824d5c58c8606029f22356" translate="yes" xml:space="preserve">
          <source>As an example of how coroutines work, consider the following code:</source>
          <target state="translated">В качестве примера того,как работают корутины,рассмотрим следующий код:</target>
        </trans-unit>
        <trans-unit id="55fd3c324f7088b1e4e4ef9627852502a3224e79" translate="yes" xml:space="preserve">
          <source>As an example, consider the following definitions:</source>
          <target state="translated">В качестве примера рассмотрим следующие определения:</target>
        </trans-unit>
        <trans-unit id="74222d71219a9516ef23c72ea9fe93b833f10fca" translate="yes" xml:space="preserve">
          <source>As an example, the following function receives a variable number of numeric arguments and returns their average and their sum:</source>
          <target state="translated">В качестве примера,следующая функция получает переменное количество числовых аргументов и возвращает их среднее и сумму:</target>
        </trans-unit>
        <trans-unit id="e53c537a917ff61bdeaf745cd25b581253b587b4" translate="yes" xml:space="preserve">
          <source>As an example, the following loop will iterate over all the words from string &lt;code&gt;s&lt;/code&gt;, printing one per line:</source>
          <target state="translated">В качестве примера следующий цикл будет перебирать все слова из строки &lt;code&gt;s&lt;/code&gt; , печатая по одному в каждой строке:</target>
        </trans-unit>
        <trans-unit id="10342e6eb6b2fd67fdff1919f85d366e227d7fc9" translate="yes" xml:space="preserve">
          <source>As an extension language, Lua has no notion of a &quot;main&quot; program: it works &lt;em&gt;embedded&lt;/em&gt; in a host client, called the &lt;em&gt;embedding program&lt;/em&gt; or simply the &lt;em&gt;host&lt;/em&gt;. (Frequently, this host is the stand-alone &lt;code&gt;lua&lt;/code&gt; program.) The host program can invoke functions to execute a piece of Lua code, can write and read Lua variables, and can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cope with a wide range of different domains, thus creating customized programming languages sharing a syntactical framework.</source>
          <target state="translated">Как язык расширения Lua не имеет понятия &amp;laquo;основная&amp;raquo; программа: он работает &lt;em&gt;встроенным&lt;/em&gt; в хост-клиент, называемый программой &lt;em&gt;встраивания&lt;/em&gt; или просто &lt;em&gt;хостом&lt;/em&gt; . (Часто этот хост является автономной программой &lt;code&gt;lua&lt;/code&gt; .) Хост-программа может вызывать функции для выполнения части кода Lua, может записывать и читать переменные Lua и может регистрировать функции C для вызова кодом Lua. Благодаря использованию функций C, Lua может быть расширен, чтобы справиться с широким спектром различных доменов, тем самым создавая настраиваемые языки программирования, разделяющие синтаксическую структуру.</target>
        </trans-unit>
        <trans-unit id="18e8b25f2432d6d4994bc8412127c9c6a9fd835a" translate="yes" xml:space="preserve">
          <source>As an illustration, consider the following function:</source>
          <target state="translated">В качестве иллюстрации рассмотрим следующую функцию:</target>
        </trans-unit>
        <trans-unit id="f3e9897f2d1040dc7274b7624604db4d8b6ac14f" translate="yes" xml:space="preserve">
          <source>As in most C libraries, the Lua API functions do not check their arguments for validity or consistency. However, you can change this behavior by compiling Lua with the macro &lt;a id=&quot;pdf-LUA_USE_APICHECK&quot;&gt;&lt;code&gt;LUA_USE_APICHECK&lt;/code&gt;&lt;/a&gt; defined.</source>
          <target state="translated">Как и в большинстве библиотек C, функции Lua API не проверяют свои аргументы на достоверность или согласованность. Однако вы можете изменить это поведение, скомпилировав Lua с определенным макросом &lt;a id=&quot;pdf-LUA_USE_APICHECK&quot;&gt; &lt;code&gt;LUA_USE_APICHECK&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24c57582c72da098884fa076ca9862645c6e1334" translate="yes" xml:space="preserve">
          <source>As usual, you can use parentheses to change the precedences of an expression. The concatenation ('&lt;code&gt;..&lt;/code&gt;') and exponentiation ('&lt;code&gt;^&lt;/code&gt;') operators are right associative. All other binary operators are left associative.</source>
          <target state="translated">Как обычно, вы можете использовать круглые скобки для изменения приоритета выражения. Операторы конкатенации (' &lt;code&gt;..&lt;/code&gt; ') и возведения в степень (' &lt;code&gt;^&lt;/code&gt; ') являются правоассоциативными. Все остальные бинарные операторы левоассоциативны.</target>
        </trans-unit>
        <trans-unit id="90c78100181d409a60710e1b3cf4f61c8d6e6ff7" translate="yes" xml:space="preserve">
          <source>As will be discussed in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; and &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;, any reference to a free name (that is, a name not bound to any declaration) &lt;code&gt;var&lt;/code&gt; is syntactically translated to &lt;code&gt;_ENV.var&lt;/code&gt;. Moreover, every chunk is compiled in the scope of an external local variable named &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt;), so &lt;code&gt;_ENV&lt;/code&gt; itself is never a free name in a chunk.</source>
          <target state="translated">Как будет обсуждено в &lt;a href=&quot;#3.2&quot;&gt;&amp;sect; 3.2&lt;/a&gt; и &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt; , любая ссылка на свободное имя (то есть имя не ограничиваясь каким - либо объявление) &lt;code&gt;var&lt;/code&gt; синтаксически переводятся на &lt;code&gt;_ENV.var&lt;/code&gt; . Более того, каждый чанк компилируется в области видимости внешней локальной переменной с именем &lt;code&gt;_ENV&lt;/code&gt; (см. &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt; ), так что &lt;code&gt;_ENV&lt;/code&gt; сам по себе никогда не является свободным именем в чанке.</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="3b37b5372cc754e07c5399ff64d83d0917ca19d3" translate="yes" xml:space="preserve">
          <source>At start-up, Lua initializes this variable with the value of the environment variable &lt;a id=&quot;pdf-LUA_PATH_5_3&quot;&gt;&lt;code&gt;LUA_PATH_5_3&lt;/code&gt;&lt;/a&gt; or the environment variable &lt;a id=&quot;pdf-LUA_PATH&quot;&gt;&lt;code&gt;LUA_PATH&lt;/code&gt;&lt;/a&gt; or with a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;, if those environment variables are not defined. Any &quot;&lt;code&gt;;;&lt;/code&gt;&quot; in the value of the environment variable is replaced by the default path.</source>
          <target state="translated">При запуске Lua инициализирует эту переменную значением переменной среды &lt;a id=&quot;pdf-LUA_PATH_5_3&quot;&gt; &lt;code&gt;LUA_PATH_5_3&lt;/code&gt; &lt;/a&gt; или переменной среды &lt;a id=&quot;pdf-LUA_PATH&quot;&gt; &lt;code&gt;LUA_PATH&lt;/code&gt; &lt;/a&gt; или путем по умолчанию, определенным в &lt;code&gt;luaconf.h&lt;/code&gt; , если эти переменные среды не определены. Любой &quot; &lt;code&gt;;;&lt;/code&gt; &quot; в значении переменной среды заменяется путем по умолчанию.</target>
        </trans-unit>
        <trans-unit id="1c846064774d3fc9a0c20918821eeca9ef19288b" translate="yes" xml:space="preserve">
          <source>At the end of each garbage-collection cycle, the finalizers for objects are called in the reverse order that the objects were marked for finalization, among those collected in that cycle; that is, the first finalizer to be called is the one associated with the object marked last in the program. The execution of each finalizer may occur at any point during the execution of the regular code.</source>
          <target state="translated">В конце каждого цикла сбора мусора финализаторы для объектов вызываются в обратном порядке,в котором объекты были помечены для окончательной доработки,среди объектов,собранных в этом цикле;то есть первым вызываемым финализатором является тот,который связан с объектом,помеченным последним в программе.Выполнение каждого финализатора может произойти в любой момент во время выполнения обычного кода.</target>
        </trans-unit>
        <trans-unit id="7b97861ba9e02b6857fb91f3d5b2a8013e6bffda" translate="yes" xml:space="preserve">
          <source>Auxiliary Library</source>
          <target state="translated">Вспомогательная библиотека</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
          <target state="translated">Основные концепции</target>
        </trans-unit>
        <trans-unit id="8f4cb4f0510bd523b95aae50ed7278eb36070fa4" translate="yes" xml:space="preserve">
          <source>Because Lua has garbage collection, there is no guarantee that the pointer returned by &lt;code&gt;lua_tolstring&lt;/code&gt; will be valid after the corresponding Lua value is removed from the stack.</source>
          <target state="translated">Поскольку Lua имеет сборку мусора, нет гарантии, что указатель, возвращаемый &lt;code&gt;lua_tolstring&lt;/code&gt; , будет действительным после того, как соответствующее значение Lua будет удалено из стека.</target>
        </trans-unit>
        <trans-unit id="4e550731f0f7f512357918c5d533714fe0133257" translate="yes" xml:space="preserve">
          <source>Because Lua is an embedded extension language, all Lua actions start from C code in the host program calling a function from the Lua library. (When you use Lua standalone, the &lt;code&gt;lua&lt;/code&gt; application is the host program.) Whenever an error occurs during the compilation or execution of a Lua chunk, control returns to the host, which can take appropriate measures (such as printing an error message).</source>
          <target state="translated">Поскольку Lua является встроенным языком расширения, все действия Lua начинаются с кода C в основной программе, вызывающей функцию из библиотеки Lua. (Когда вы используете автономный Lua, приложение &lt;code&gt;lua&lt;/code&gt; является главной программой.) Каждый раз, когда возникает ошибка во время компиляции или выполнения блока Lua, управление возвращается хосту, который может принять соответствующие меры (например, распечатать сообщение об ошибке).</target>
        </trans-unit>
        <trans-unit id="0fad2c0ffc739d9f59d3ff44590e127f2bd7b785" translate="yes" xml:space="preserve">
          <source>Because metatables are regular tables, they can contain arbitrary fields, not only the event names defined above. Some functions in the standard library (e.g., &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;) use other fields in metatables for their own purposes.</source>
          <target state="translated">Поскольку метатаблицы являются обычными таблицами, они могут содержать произвольные поля, а не только имена событий, определенные выше. Некоторые функции в стандартной библиотеке (например, &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; ) используют другие поля в метатаблицах для своих целей.</target>
        </trans-unit>
        <trans-unit id="ceef25556ecac12093ede647b1814c0461f552fa" translate="yes" xml:space="preserve">
          <source>Because of the lexical scoping rules, local variables can be freely accessed by functions defined inside their scope. A local variable used by an inner function is called an &lt;em&gt;upvalue&lt;/em&gt;, or &lt;em&gt;external local variable&lt;/em&gt;, inside the inner function.</source>
          <target state="translated">Из-за правил лексической области видимости локальные переменные могут быть доступны для функций, определенных внутри их области видимости. Локальная переменная, используемая внутренней функцией, называется &lt;em&gt;повышающим значением&lt;/em&gt; или &lt;em&gt;внешней локальной переменной&lt;/em&gt; внутри внутренней функции.</target>
        </trans-unit>
        <trans-unit id="100abb5c579b396b2c34374efb4ff5f9d32a765e" translate="yes" xml:space="preserve">
          <source>Because the object being collected must still be used by the finalizer, that object (and other objects accessible only through it) must be &lt;em&gt;resurrected&lt;/em&gt; by Lua. Usually, this resurrection is transient, and the object memory is freed in the next garbage-collection cycle. However, if the finalizer stores the object in some global place (e.g., a global variable), then the resurrection is permanent. Moreover, if the finalizer marks a finalizing object for finalization again, its finalizer will be called again in the next cycle where the object is unreachable. In any case, the object memory is freed only in a GC cycle where the object is unreachable and not marked for finalization.</source>
          <target state="translated">Поскольку собираемый объект все еще должен использоваться финализатором, этот объект (и другие объекты, доступные только через него) должны быть &lt;em&gt;воскрешены&lt;/em&gt; Lua. Обычно это воскрешение является временным, и объектная память освобождается в следующем цикле сборки мусора. Однако, если финализатор сохраняет объект в каком-то глобальном месте (например, в глобальной переменной), то воскрешение будет постоянным. Более того, если финализатор снова помечает финализирующий объект для финализации, его финализатор будет вызываться снова в следующем цикле, когда объект недоступен. В любом случае память объекта освобождается только в цикле сборки мусора, когда объект недоступен и не помечен для завершения.</target>
        </trans-unit>
        <trans-unit id="6d5b47e3e1cfd97e4c1094c7771191d76ffbf4e8" translate="yes" xml:space="preserve">
          <source>Before running any code, &lt;code&gt;lua&lt;/code&gt; collects all command-line arguments in a global table called &lt;code&gt;arg&lt;/code&gt;. The script name goes to index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus its options) go to negative indices. For instance, in the call</source>
          <target state="translated">Перед запуском любого кода &lt;code&gt;lua&lt;/code&gt; собирает все аргументы командной строки в глобальной таблице с именем &lt;code&gt;arg&lt;/code&gt; . Имя скрипта переходит в индекс 0, первый аргумент после имени скрипта переходит в индекс 1 и так далее. Любые аргументы перед именем скрипта (то есть имя интерпретатора плюс его параметры) переходят к отрицательным индексам. Например, в звонке</target>
        </trans-unit>
        <trans-unit id="41d09b228ef66be3a22078c99e4ef2dcb3df78d1" translate="yes" xml:space="preserve">
          <source>Before the assignment, the list of values is &lt;em&gt;adjusted&lt;/em&gt; to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with as many &lt;b&gt;nil&lt;/b&gt;'s as needed. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt;).</source>
          <target state="translated">Перед назначением список значений &lt;em&gt;корректируется&lt;/em&gt; по длине списка переменных. Если значений больше, чем необходимо, лишние значения выбрасываются. Если значений меньше, чем необходимо, список дополняется необходимым количеством &lt;b&gt;nil&lt;/b&gt; . Если список выражений заканчивается вызовом функции, то все значения, возвращаемые этим вызовом, входят в список значений до корректировки (кроме случаев, когда вызов заключен в круглые скобки; см. &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="746907c57e653b279bf39358594d492bc0bfe3b2" translate="yes" xml:space="preserve">
          <source>Before the first assignment to a variable, its value is &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Перед первым присваиванием переменной ее значение равно &lt;b&gt;нулю&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="eceec5af294d53441f5ac4ad61816149f7f14e22" translate="yes" xml:space="preserve">
          <source>Besides the Lua state, the continuation function has two other parameters: the final status of the call plus the context value (&lt;code&gt;ctx&lt;/code&gt;) that was passed originally to &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. (Lua does not use this context value; it only passes this value from the original function to the continuation function.) For &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, the status is the same value that would be returned by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, except that it is &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when being executed after a yield (instead of &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;). For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, the status is always &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when Lua calls the continuation. (For these two functions, Lua will not call the continuation in case of errors, because they do not handle errors.) Similarly, when using &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, you should call the continuation function with &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; as the status. (For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, there is not much point in calling directly the continuation function, because &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; usually does not return.)</source>
          <target state="translated">Помимо состояния Lua, функция продолжения имеет два других параметра: окончательный статус вызова плюс значение контекста ( &lt;code&gt;ctx&lt;/code&gt; ), которое было первоначально &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; . (Lua не использует это значение контекста; он только передает это значение из исходной функции в функцию продолжения.) Для &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; статус - это то же значение, которое было бы возвращено &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; , за исключением того, что это &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; при выполнении после yield (вместо &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; ). Для &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; статус всегда &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;когда Lua вызывает продолжение. (Для этих двух функций Lua не будет вызывать продолжение в случае ошибок, потому что они не обрабатывают ошибки.) Аналогичным образом, при использовании &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; вы должны вызывать функцию продолжения с &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; в качестве статуса. (Для &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; нет особого смысла в прямом вызове функции продолжения, потому что &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; обычно не возвращает.)</target>
        </trans-unit>
        <trans-unit id="178d0c1a22b01e10ab0fe06b4a5afb972b2a24e2" translate="yes" xml:space="preserve">
          <source>Binary operators comprise arithmetic operators (see &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt;), bitwise operators (see &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt;), relational operators (see &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt;), logical operators (see &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt;), and the concatenation operator (see &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt;). Unary operators comprise the unary minus (see &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt;), the unary bitwise NOT (see &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt;), the unary logical &lt;b&gt;not&lt;/b&gt; (see &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt;), and the unary &lt;em&gt;length operator&lt;/em&gt; (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;).</source>
          <target state="translated">Бинарные операторы включают арифметические операторы (см. &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt; ), побитовые операторы (см. &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt; ), реляционные операторы (см. &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt; ), логические операторы (см. &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt; ) и оператор конкатенации (см. &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect; 3.4.6&lt;/a&gt; ). Унарные операторы включают в себя унарный минус (см. &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt; ), унарное побитовое НЕ (см. &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt; ), унарное логическое &lt;b&gt;НЕ&lt;/b&gt; (см. &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt; ) и &lt;em&gt;оператор&lt;/em&gt; унарной &lt;em&gt;длины&lt;/em&gt; (см. &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ) ,</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">Дополнительные операторы</target>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="b864e3b0c9b0957e85741aadf6674e44cf5c2496" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;nargs&lt;/code&gt; and &lt;code&gt;nresults&lt;/code&gt; have the same meaning as in &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;. If there are no errors during the call, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;. However, if there is any error, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; catches it, pushes a single value on the stack (the error object), and returns an error code. Like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; always removes the function and its arguments from the stack.</source>
          <target state="translated">И &lt;code&gt;nargs&lt;/code&gt; , и &lt;code&gt;nresults&lt;/code&gt; имеют то же значение, что и &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; . Если во время вызова ошибок нет, &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; ведет себя точно так же, как &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; . Однако, если есть какая-либо ошибка, &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; перехватывает ее , помещает в стек единственное значение (объект ошибки) и возвращает код ошибки. Как и &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; всегда удаляет функцию и ее аргументы из стека.</target>
        </trans-unit>
        <trans-unit id="3328c9c8f16b59988d2720e58557b3f6a8cdbbb5" translate="yes" xml:space="preserve">
          <source>Both function calls and vararg expressions can result in multiple values. If a function call is used as a statement (see &lt;a href=&quot;#3.3.6&quot;&gt;&amp;sect;3.3.6&lt;/a&gt;), then its return list is adjusted to zero elements, thus discarding all returned values. If an expression is used as the last (or the only) element of a list of expressions, then no adjustment is made (unless the expression is enclosed in parentheses). In all other contexts, Lua adjusts the result list to one element, either discarding all values except the first one or adding a single &lt;b&gt;nil&lt;/b&gt; if there are no values.</source>
          <target state="translated">И вызовы функций, и выражения vararg могут давать несколько значений. Если вызов функции используется как оператор (см. &lt;a href=&quot;#3.3.6&quot;&gt;&amp;sect;3.3.6&lt;/a&gt; ), то его список возврата корректируется до нуля элементов, таким образом отбрасывая все возвращаемые значения. Если выражение используется в качестве последнего (или единственного) элемента списка выражений, корректировка не производится (если выражение не заключено в круглые скобки). Во всех других контекстах Lua подстраивает список результатов к одному элементу, либо отбрасывая все значения, кроме первого, либо добавляя один &lt;b&gt;ноль,&lt;/b&gt; если значений нет.</target>
        </trans-unit>
        <trans-unit id="ef0d7df25b511d8e1f840431681fc99b96959ea0" translate="yes" xml:space="preserve">
          <source>Both right and left shifts fill the vacant bits with zeros. Negative displacements shift to the other direction; displacements with absolute values equal to or higher than the number of bits in an integer result in zero (as all bits are shifted out).</source>
          <target state="translated">Сдвиги вправо и влево заполняют пустые биты нулями.Отрицательные смещения смещаются в другую сторону;смещения с абсолютными значениями,равными или превышающими число битов в целочисленном выражении,приводят к нулю (так как все биты смещаются).</target>
        </trans-unit>
        <trans-unit id="606a21a2a41de7578fb85238576a85c01cff0d09" translate="yes" xml:space="preserve">
          <source>By default this type is &lt;code&gt;long long&lt;/code&gt;, (usually a 64-bit two-complement integer), but that can be changed to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; (usually a 32-bit two-complement integer). (See &lt;code&gt;LUA_INT_TYPE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">По умолчанию этот тип &lt;code&gt;long long&lt;/code&gt; (обычно 64-битное целое число с двумя дополнениями), но его можно изменить на &lt;code&gt;long&lt;/code&gt; или &lt;code&gt;int&lt;/code&gt; (обычно 32-битное целое число с двумя дополнениями). (См. &lt;code&gt;LUA_INT_TYPE&lt;/code&gt; в &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="8d4b756a61274079d48c6b43e4f7a164ad5525c5" translate="yes" xml:space="preserve">
          <source>By default this type is double, but that can be changed to a single float or a long double. (See &lt;code&gt;LUA_FLOAT_TYPE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">По умолчанию это двойной тип, но его можно изменить на одинарное с плавающей запятой или длинное двойное. (См. &lt;code&gt;LUA_FLOAT_TYPE&lt;/code&gt; в &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="29af92c8be46565be89222f77a2f4fb50aaf902e" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;i&lt;/code&gt; is 1 and &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;.</source>
          <target state="translated">По умолчанию &lt;code&gt;i&lt;/code&gt; равно 1, а &lt;code&gt;j&lt;/code&gt; - &lt;code&gt;#list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b94595a9de392a583ea21fcbca5ff4996bbeb4c" translate="yes" xml:space="preserve">
          <source>By default, this area has the size of a pointer to void, but you can recompile Lua with a different size for this area. (See &lt;code&gt;LUA_EXTRASPACE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">По умолчанию эта область имеет размер указателя на void, но вы можете перекомпилировать Lua с другим размером для этой области. (См. &lt;code&gt;LUA_EXTRASPACE&lt;/code&gt; в &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="03114feec4c78056b8ef7cfc58a14ecddceef3d8" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; if the value of its argument &lt;code&gt;v&lt;/code&gt; is false (i.e., &lt;b&gt;nil&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;); otherwise, returns all its arguments. In case of error, &lt;code&gt;message&lt;/code&gt; is the error object; when absent, it defaults to &quot;&lt;code&gt;assertion failed!&lt;/code&gt;&quot;</source>
          <target state="translated">Вызывает &lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; если значение его аргумента &lt;code&gt;v&lt;/code&gt; ложно (т. &lt;b&gt;Е. Nil&lt;/b&gt; или &lt;b&gt;false&lt;/b&gt; ); в противном случае возвращает все свои аргументы. В случае ошибки &lt;code&gt;message&lt;/code&gt; является объектом ошибки; когда отсутствует, по умолчанию используется &quot; &lt;code&gt;assertion failed!&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="1c9a6f6c22d821f1d190cf7b504945ad9b4cbdf3" translate="yes" xml:space="preserve">
          <source>Calls a function in protected mode.</source>
          <target state="translated">Вызов функции в защищенном режиме.</target>
        </trans-unit>
        <trans-unit id="b098c5a2357f0f1bcda94addf0cd58b14d7f56d4" translate="yes" xml:space="preserve">
          <source>Calls a function.</source>
          <target state="translated">Вызовет функцию.</target>
        </trans-unit>
        <trans-unit id="a92585404dfb5c102735b49e368c931de0bcf925" translate="yes" xml:space="preserve">
          <source>Calls a metamethod.</source>
          <target state="translated">Это называется метаметод.</target>
        </trans-unit>
        <trans-unit id="afb856a058891b728039960270f34dcfa7886cb5" translate="yes" xml:space="preserve">
          <source>Calls function &lt;code&gt;f&lt;/code&gt; with the given arguments in &lt;em&gt;protected mode&lt;/em&gt;. This means that any error inside &lt;code&gt;f&lt;/code&gt; is not propagated; instead, &lt;code&gt;pcall&lt;/code&gt; catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, &lt;code&gt;pcall&lt;/code&gt; also returns all results from the call, after this first result. In case of any error, &lt;code&gt;pcall&lt;/code&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error message.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;f&lt;/code&gt; с заданными аргументами в &lt;em&gt;защищенном режиме&lt;/em&gt; . Это означает, что любая ошибка внутри &lt;code&gt;f&lt;/code&gt; не распространяется; вместо этого &lt;code&gt;pcall&lt;/code&gt; перехватывает ошибку и возвращает код состояния. Его первым результатом является код состояния (логическое значение), который является истинным, если вызов завершается успешно без ошибок. В таком случае &lt;code&gt;pcall&lt;/code&gt; также возвращает все результаты вызова после этого первого результата. В случае любой ошибки &lt;code&gt;pcall&lt;/code&gt; возвращает &lt;b&gt;false&lt;/b&gt; плюс сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="d13e849aa5160d3c27d99ea69deec271ee71dd22" translate="yes" xml:space="preserve">
          <source>Calls the ISO C function &lt;code&gt;exit&lt;/code&gt; to terminate the host program. If &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;true&lt;/b&gt;, the returned status is &lt;code&gt;EXIT_SUCCESS&lt;/code&gt;; if &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;false&lt;/b&gt;, the returned status is &lt;code&gt;EXIT_FAILURE&lt;/code&gt;; if &lt;code&gt;code&lt;/code&gt; is a number, the returned status is this number. The default value for &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">Вызывает функцию &lt;code&gt;exit&lt;/code&gt; ISO C для завершения основной программы. Если &lt;code&gt;code&lt;/code&gt; является &lt;b&gt;истинным&lt;/b&gt; , возвращаемый статус &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; ; если &lt;code&gt;code&lt;/code&gt; является &lt;b&gt;ложным&lt;/b&gt; , возвращаемый статус &lt;code&gt;EXIT_FAILURE&lt;/code&gt; ; если &lt;code&gt;code&lt;/code&gt; - это число, возвращаемый статус - это число. Значение по умолчанию для &lt;code&gt;code&lt;/code&gt; - &lt;b&gt;истина&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ce944ae1c348eb980d3cfe553b3502d5679075a6" translate="yes" xml:space="preserve">
          <source>Captures:</source>
          <target state="translated">Captures:</target>
        </trans-unit>
        <trans-unit id="07ae3990eabe4f174acb75467a4a336ef037a4a0" translate="yes" xml:space="preserve">
          <source>Changes the allocator function of a given state to &lt;code&gt;f&lt;/code&gt; with user data &lt;code&gt;ud&lt;/code&gt;.</source>
          <target state="translated">Изменяет функцию распределения заданного состояния на &lt;code&gt;f&lt;/code&gt; с пользовательскими данными &lt;code&gt;ud&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e6cb5ea0746fe0ad7fa97751f92f6157ed314b2" translate="yes" xml:space="preserve">
          <source>Character Class:</source>
          <target state="translated">Класс персонажей:</target>
        </trans-unit>
        <trans-unit id="0a2e61548b9d88afb89262b803b6de8bd1e2b486" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;cond&lt;/code&gt; is true. If it is not, raises an error with a standard message (see &lt;a href=&quot;#luaL_argerror&quot;&gt;&lt;code&gt;luaL_argerror&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Проверяет, истинно ли &lt;code&gt;cond&lt;/code&gt; . Если это не так, &lt;a href=&quot;#luaL_argerror&quot;&gt; &lt;code&gt;luaL_argerror&lt;/code&gt; &lt;/a&gt; ошибку стандартным сообщением (см. LuaL_argerror ).</target>
        </trans-unit>
        <trans-unit id="e06a04dbdce44628706ea99a276e73819504d5ac" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;obj&lt;/code&gt; is a valid file handle. Returns the string &lt;code&gt;&quot;file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is an open file handle, &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is a closed file handle, or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;obj&lt;/code&gt; is not a file handle.</source>
          <target state="translated">Проверяет, является ли &lt;code&gt;obj&lt;/code&gt; допустимым дескриптором файла. Возвращает строку &lt;code&gt;&quot;file&quot;&lt;/code&gt; если &lt;code&gt;obj&lt;/code&gt; является дескриптором открытого файла, &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; если &lt;code&gt;obj&lt;/code&gt; является дескриптором закрытого файла, или &lt;b&gt;nil,&lt;/b&gt; если &lt;code&gt;obj&lt;/code&gt; не является дескриптором файла.</target>
        </trans-unit>
        <trans-unit id="c496e326cea24bf25262cd1109c5d86ac743d694" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;v1&lt;/code&gt; is equal to &lt;code&gt;v2&lt;/code&gt;, without invoking the &lt;code&gt;__eq&lt;/code&gt; metamethod. Returns a boolean.</source>
          <target state="translated">Проверяет, равен ли &lt;code&gt;v1&lt;/code&gt; &lt;code&gt;v2&lt;/code&gt; , без вызова &lt;code&gt;__eq&lt;/code&gt; . Возвращает логическое значение.</target>
        </trans-unit>
        <trans-unit id="71f0115e5d4ddbb6ea3de5ce5156cd7d330a1e43" translate="yes" xml:space="preserve">
          <source>Checks whether the core running the call, the core that created the Lua state, and the code making the call are all using the same version of Lua. Also checks whether the core running the call and the core that created the Lua state are using the same address space.</source>
          <target state="translated">Проверяет,использует ли ядро,выполняющее вызов,ядро,создавшее состояние Lua,и код,выполняющий вызов,одну и ту же версию Lua.Также проверяет,использует ли ядро,выполняющее вызов,и ядро,создавшее состояние Lua,одно и то же адресное пространство.</target>
        </trans-unit>
        <trans-unit id="c7e0b23ddda5a7e9cb9a184dd2fb56f91b2baeb4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; for the encoding of types for &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Проверяет, имеет ли аргумент функции &lt;code&gt;arg&lt;/code&gt; тип &lt;code&gt;t&lt;/code&gt; . См. &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; &lt;/a&gt; для кодировки типов для &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34efff80aa99092adc3395e3a3c3cec54e5e3ae4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a number and returns this number.</source>
          <target state="translated">Проверяет, является ли аргумент функции &lt;code&gt;arg&lt;/code&gt; числом, и возвращает это число.</target>
        </trans-unit>
        <trans-unit id="acb38043b3ab1b3ca9ad57148867e32ff48f49a4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and returns this string.</source>
          <target state="translated">Проверяет, является ли аргумент функции &lt;code&gt;arg&lt;/code&gt; строкой и возвращает эту строку.</target>
        </trans-unit>
        <trans-unit id="fd80c52685065a298a4083d4f4ae27709571e837" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and returns this string; if &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt; fills &lt;code&gt;*l&lt;/code&gt; with the string's length.</source>
          <target state="translated">Проверяет, является ли аргумент функции &lt;code&gt;arg&lt;/code&gt; строкой и возвращает эту строку; если &lt;code&gt;l&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; заполняет &lt;code&gt;*l&lt;/code&gt; длиной строки.</target>
        </trans-unit>
        <trans-unit id="6bda7fb8ccffc0321708f10ba7b5f9fa4d8f642f" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and searches for this string in the array &lt;code&gt;lst&lt;/code&gt; (which must be NULL-terminated). Returns the index in the array where the string was found. Raises an error if the argument is not a string or if the string cannot be found.</source>
          <target state="translated">Проверяет, является ли аргумент функции &lt;code&gt;arg&lt;/code&gt; строкой, и ищет эту строку в массиве &lt;code&gt;lst&lt;/code&gt; (который должен оканчиваться NULL). Возвращает индекс в массиве, в котором была найдена строка. Вызывает ошибку, если аргумент не является строкой или если строка не может быть найдена.</target>
        </trans-unit>
        <trans-unit id="bfaae18ec316bac0d06a7d8b2f1269f7452bb73f" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a userdata of the type &lt;code&gt;tname&lt;/code&gt; (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) and returns the userdata address (see &lt;a href=&quot;#lua_touserdata&quot;&gt;&lt;code&gt;lua_touserdata&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Проверяет, является ли аргумент функции &lt;code&gt;arg&lt;/code&gt; пользовательскими данными типа &lt;code&gt;tname&lt;/code&gt; (см. &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; ) и возвращает адрес пользовательских данных (см. &lt;a href=&quot;#lua_touserdata&quot;&gt; &lt;code&gt;lua_touserdata&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="21c6e89e09e8362727785a70d17dbd46aac6e5d8" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or can be converted to an integer) and returns this integer cast to a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Проверяет, является ли аргумент функции &lt;code&gt;arg&lt;/code&gt; целым числом (или может быть преобразовано в целое число) и возвращает это целочисленное &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; в lua_Integer .</target>
        </trans-unit>
        <trans-unit id="ec6102b1e83850fda1240175c176c9a4d38d5de9" translate="yes" xml:space="preserve">
          <source>Checks whether the function has an argument of any type (including &lt;b&gt;nil&lt;/b&gt;) at position &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">Проверяет, имеет ли функция аргумент любого типа (включая &lt;b&gt;nil&lt;/b&gt; ) в позиции &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a527377dfdcd1435bbaa177dc63f2a6bb39b269" translate="yes" xml:space="preserve">
          <source>Chunks</source>
          <target state="translated">Chunks</target>
        </trans-unit>
        <trans-unit id="b103f8207401db3956a89008862d6396af66ca00" translate="yes" xml:space="preserve">
          <source>Chunks can also be precompiled into binary form; see program &lt;code&gt;luac&lt;/code&gt; and function &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt; for details. Programs in source and compiled forms are interchangeable; Lua automatically detects the file type and acts accordingly (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Чанки также могут быть предварительно скомпилированы в двоичную форму; см. программу &lt;code&gt;luac&lt;/code&gt; и функцию &lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt; для подробностей. Программы в исходной и скомпилированной формах взаимозаменяемы; Lua автоматически определяет тип файла и действует соответствующим образом (см. &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="52566db36dfcd9f2bf9c74284a4bfdd56dc85476" translate="yes" xml:space="preserve">
          <source>Closes &lt;code&gt;file&lt;/code&gt;. Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen.</source>
          <target state="translated">Закрывает &lt;code&gt;file&lt;/code&gt; . Обратите внимание, что файлы автоматически закрываются, когда их дескрипторы собираются сборщиком мусора, но для этого требуется непредсказуемое количество времени.</target>
        </trans-unit>
        <trans-unit id="85fc3e790a7e917db028a531acd7642ab374f383" translate="yes" xml:space="preserve">
          <source>Coercions and Conversions</source>
          <target state="translated">Принуждения и преобразования</target>
        </trans-unit>
        <trans-unit id="226470405b7e44d61ec64752eddb0da20100aa01" translate="yes" xml:space="preserve">
          <source>Compares two Lua values. Returns 1 if the value at index &lt;code&gt;index1&lt;/code&gt; satisfies &lt;code&gt;op&lt;/code&gt; when compared with the value at index &lt;code&gt;index2&lt;/code&gt;, following the semantics of the corresponding Lua operator (that is, it may call metamethods). Otherwise returns 0. Also returns 0 if any of the indices is not valid.</source>
          <target state="translated">Сравнивает два значения Lua. Возвращает 1, если значение в индексе &lt;code&gt;index1&lt;/code&gt; удовлетворяет &lt;code&gt;op&lt;/code&gt; при сравнении со значением в индексе &lt;code&gt;index2&lt;/code&gt; , следуя семантике соответствующего оператора Lua (то есть он может вызывать метаметоды). В противном случае возвращает 0. Также возвращает 0, если какой-либо из индексов недействителен.</target>
        </trans-unit>
        <trans-unit id="372bb0dd29dd69cdea95231ec5f25f17cfbc3df5" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;n&lt;/code&gt; values at the top of the stack, pops them, and leaves the result at the top. If &lt;code&gt;n&lt;/code&gt; is 1, the result is the single value on the stack (that is, the function does nothing); if &lt;code&gt;n&lt;/code&gt; is 0, the result is the empty string. Concatenation is performed following the usual semantics of Lua (see &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt;).</source>
          <target state="translated">Объединяет &lt;code&gt;n&lt;/code&gt; значений наверху стека, выталкивает их и оставляет результат наверху. Если &lt;code&gt;n&lt;/code&gt; равно 1, результатом будет единственное значение в стеке (то есть функция ничего не делает); если &lt;code&gt;n&lt;/code&gt; равно 0, результатом будет пустая строка. Конкатенация выполняется в соответствии с обычной семантикой Lua (см. &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eec037fd21cdbe752cf956ee1da877b809e27461" translate="yes" xml:space="preserve">
          <source>Concatenation</source>
          <target state="translated">Concatenation</target>
        </trans-unit>
        <trans-unit id="398713ac023b450e8c4b5b95b390a7f9a7cf2b57" translate="yes" xml:space="preserve">
          <source>Continuation functions now receive as parameters what they needed to get through &lt;code&gt;lua_getctx&lt;/code&gt;, so &lt;code&gt;lua_getctx&lt;/code&gt; has been removed. Adapt your code accordingly.</source>
          <target state="translated">Функции продолжения теперь получают в качестве параметров то, что им нужно для &lt;code&gt;lua_getctx&lt;/code&gt; через lua_getctx , поэтому &lt;code&gt;lua_getctx&lt;/code&gt; был удален. Адаптируйте свой код соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="49551177d73377982310b6a218929215d8146939" translate="yes" xml:space="preserve">
          <source>Control Structures</source>
          <target state="translated">Контрольные структуры</target>
        </trans-unit>
        <trans-unit id="5ee818a21f2b1465f364481c4e0134cff5f18467" translate="yes" xml:space="preserve">
          <source>Controls the garbage collector.</source>
          <target state="translated">Управляет сборщиком мусора.</target>
        </trans-unit>
        <trans-unit id="7837da47cfdd57111dc0e4c0e5a4d9267fcf8abb" translate="yes" xml:space="preserve">
          <source>Converts a Lua float to a Lua integer. This macro assumes that &lt;code&gt;n&lt;/code&gt; has an integral value. If that value is within the range of Lua integers, it is converted to an integer and assigned to &lt;code&gt;*p&lt;/code&gt;. The macro results in a boolean indicating whether the conversion was successful. (Note that this range test can be tricky to do correctly without this macro, due to roundings.)</source>
          <target state="translated">Преобразует Lua с плавающей точкой в ​​целое число Lua. Этот макрос предполагает, что &lt;code&gt;n&lt;/code&gt; имеет целое значение. Если это значение находится в диапазоне целых чисел Lua, оно преобразуется в целое число и присваивается &lt;code&gt;*p&lt;/code&gt; . Результатом макроса является логическое значение, указывающее, было ли преобразование успешным. (Обратите внимание, что этот тест диапазона может быть сложно выполнить правильно без этого макроса из-за округлений.)</target>
        </trans-unit>
        <trans-unit id="5e3aa93bc10e31bb44d33a41364e25a0f08ad8ca" translate="yes" xml:space="preserve">
          <source>Converts a value at the given index to a C function. That value must be a C function; otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Преобразует значение по заданному индексу в функцию C. Это значение должно быть функцией C; в противном случае возвращает &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d00d889b1b22745925c2a76fb0e196b525544aa3" translate="yes" xml:space="preserve">
          <source>Converts any Lua value at the given index to a C string in a reasonable format. The resulting string is pushed onto the stack and also returned by the function. If &lt;code&gt;len&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the function also sets &lt;code&gt;*len&lt;/code&gt; with the string length.</source>
          <target state="translated">Преобразует любое значение Lua по данному индексу в строку C в разумном формате. Результирующая строка помещается в стек и также возвращается функцией. Если &lt;code&gt;len&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , функция также устанавливает &lt;code&gt;*len&lt;/code&gt; с длиной строки.</target>
        </trans-unit>
        <trans-unit id="116e857e2ca9e12d4b94e18f89755a1be1b5803e" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to a C boolean value (0 or 1). Like all tests in Lua, &lt;a href=&quot;#lua_toboolean&quot;&gt;&lt;code&gt;lua_toboolean&lt;/code&gt;&lt;/a&gt; returns true for any Lua value different from &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt;; otherwise it returns false. (If you want to accept only actual boolean values, use &lt;a href=&quot;#lua_isboolean&quot;&gt;&lt;code&gt;lua_isboolean&lt;/code&gt;&lt;/a&gt; to test the value's type.)</source>
          <target state="translated">Преобразует значение Lua по заданному индексу в логическое значение C (0 или 1). Как и все тесты в Lua, &lt;a href=&quot;#lua_toboolean&quot;&gt; &lt;code&gt;lua_toboolean&lt;/code&gt; &lt;/a&gt; возвращает true для любого значения Lua, отличного от &lt;b&gt;false&lt;/b&gt; и &lt;b&gt;nil&lt;/b&gt; ; в противном случае возвращается false. (Если вы хотите принимать только фактические логические значения, используйте &lt;a href=&quot;#lua_isboolean&quot;&gt; &lt;code&gt;lua_isboolean&lt;/code&gt; &lt;/a&gt; для проверки типа значения.)</target>
        </trans-unit>
        <trans-unit id="d683bc445abde80f362551e45b28ac54bcdd2673" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to a C string. If &lt;code&gt;len&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it sets &lt;code&gt;*len&lt;/code&gt; with the string length. The Lua value must be a string or a number; otherwise, the function returns &lt;code&gt;NULL&lt;/code&gt;. If the value is a number, then &lt;code&gt;lua_tolstring&lt;/code&gt; also &lt;em&gt;changes the actual value in the stack to a string&lt;/em&gt;. (This change confuses &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;lua_tolstring&lt;/code&gt; is applied to keys during a table traversal.)</source>
          <target state="translated">Преобразует значение Lua по заданному индексу в строку C. Если &lt;code&gt;len&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , он устанавливает &lt;code&gt;*len&lt;/code&gt; с длиной строки. Значение Lua должно быть строкой или числом; в противном случае функция возвращает &lt;code&gt;NULL&lt;/code&gt; . Если значение является числом, то &lt;code&gt;lua_tolstring&lt;/code&gt; также &lt;em&gt;изменяет фактическое значение в стеке на строку&lt;/em&gt; . (Это изменение сбивает с толку &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; ,&lt;/a&gt; когда &lt;code&gt;lua_tolstring&lt;/code&gt; применяется к ключам во время обхода таблицы.)</target>
        </trans-unit>
        <trans-unit id="b70c1818d1a487a028f6acabf5e97860ef23c14b" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to the C type &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;). The Lua value must be a number or a string convertible to a number (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;); otherwise, &lt;a href=&quot;#lua_tonumberx&quot;&gt;&lt;code&gt;lua_tonumberx&lt;/code&gt;&lt;/a&gt; returns 0.</source>
          <target state="translated">Преобразует значение Lua по заданному индексу в тип C &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; ). Значение Lua должно быть числом или строкой, конвертируемой в число (см. &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ); в противном случае &lt;a href=&quot;#lua_tonumberx&quot;&gt; &lt;code&gt;lua_tonumberx&lt;/code&gt; &lt;/a&gt; возвращает 0.</target>
        </trans-unit>
        <trans-unit id="15f299b2d961c145de7c7f6e078e5bce8ef3ebc3" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to the signed integral type &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;. The Lua value must be an integer, or a number or string convertible to an integer (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;); otherwise, &lt;code&gt;lua_tointegerx&lt;/code&gt; returns 0.</source>
          <target state="translated">Преобразует значение Lua по заданному индексу в целочисленный тип со &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; . Значение Lua должно быть целым числом, числом или строкой, конвертируемыми в целое число (см. &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; ); в противном случае &lt;code&gt;lua_tointegerx&lt;/code&gt; возвращает 0.</target>
        </trans-unit>
        <trans-unit id="56b8fd88e6e0c138775b719f7a5a3ba451055b5f" translate="yes" xml:space="preserve">
          <source>Converts the acceptable index &lt;code&gt;idx&lt;/code&gt; into an equivalent absolute index (that is, one that does not depend on the stack top).</source>
          <target state="translated">Преобразует допустимый индекс &lt;code&gt;idx&lt;/code&gt; в эквивалентный абсолютный индекс (то есть тот, который не зависит от вершины стека).</target>
        </trans-unit>
        <trans-unit id="e6fb8705a562a080e28f0029fd5720bc4900e0ba" translate="yes" xml:space="preserve">
          <source>Converts the angle &lt;code&gt;x&lt;/code&gt; from degrees to radians.</source>
          <target state="translated">Преобразует угол &lt;code&gt;x&lt;/code&gt; из градусов в радианы.</target>
        </trans-unit>
        <trans-unit id="a9e18c902b7ca6a770ce37f4b1286eab04eed85b" translate="yes" xml:space="preserve">
          <source>Converts the angle &lt;code&gt;x&lt;/code&gt; from radians to degrees.</source>
          <target state="translated">Преобразует угол &lt;code&gt;x&lt;/code&gt; из радиан в градусы.</target>
        </trans-unit>
        <trans-unit id="f0f8e779d171995ba326ae0853150d5a8e164de0" translate="yes" xml:space="preserve">
          <source>Converts the value at the given index to a Lua thread (represented as &lt;code&gt;lua_State*&lt;/code&gt;). This value must be a thread; otherwise, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Преобразует значение по заданному индексу в поток Lua (представленный как &lt;code&gt;lua_State*&lt;/code&gt; ). Это значение должно быть потоком; в противном случае функция возвращает &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa669b19e261e97a900695fc2754e811aa721912" translate="yes" xml:space="preserve">
          <source>Converts the value at the given index to a generic C pointer (&lt;code&gt;void*&lt;/code&gt;). The value can be a userdata, a table, a thread, or a function; otherwise, &lt;code&gt;lua_topointer&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;. Different objects will give different pointers. There is no way to convert the pointer back to its original value.</source>
          <target state="translated">Преобразует значение по данному индексу в универсальный указатель C ( &lt;code&gt;void*&lt;/code&gt; ). Значение может быть пользовательскими данными, таблицей, потоком или функцией; в противном случае &lt;code&gt;lua_topointer&lt;/code&gt; возвращает &lt;code&gt;NULL&lt;/code&gt; . Разные объекты будут давать разные указатели. Невозможно преобразовать указатель обратно в исходное значение.</target>
        </trans-unit>
        <trans-unit id="e5b98b4c46b3b3b87df50590e233197fb42ee19f" translate="yes" xml:space="preserve">
          <source>Converts the zero-terminated string &lt;code&gt;s&lt;/code&gt; to a number, pushes that number into the stack, and returns the total size of the string, that is, its length plus one. The conversion can result in an integer or a float, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). The string may have leading and trailing spaces and a sign. If the string is not a valid numeral, returns 0 and pushes nothing. (Note that the result can be used as a boolean, true if the conversion succeeds.)</source>
          <target state="translated">Преобразует строку &lt;code&gt;s&lt;/code&gt; с завершающим нулем в число, помещает это число в стек и возвращает общий размер строки, то есть ее длину плюс один. Преобразование может дать целое число или число с плавающей запятой в соответствии с лексическими соглашениями Lua (см. &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; ). Строка может иметь начальные и конечные пробелы и знак. Если строка не является допустимым числом, возвращает 0 и ничего не отправляет. (Обратите внимание, что результат может использоваться как логическое значение, истина, если преобразование выполнено успешно.)</target>
        </trans-unit>
        <trans-unit id="afda351611f229d2ffdcdc3ced1f84f41bb44f33" translate="yes" xml:space="preserve">
          <source>Copies the element at index &lt;code&gt;fromidx&lt;/code&gt; into the valid index &lt;code&gt;toidx&lt;/code&gt;, replacing the value at that position. Values at other positions are not affected.</source>
          <target state="translated">Копирует элемент с индексом &lt;code&gt;fromidx&lt;/code&gt; в действительный индекс &lt;code&gt;toidx&lt;/code&gt; , заменяя значение в этой позиции. Значения на других позициях не затронуты.</target>
        </trans-unit>
        <trans-unit id="038697113018f4400bc94f1be4aebad0829b635a" translate="yes" xml:space="preserve">
          <source>Coroutines</source>
          <target state="translated">Coroutines</target>
        </trans-unit>
        <trans-unit id="725136a9add10a0a9d7033c2e6eefd6766658f99" translate="yes" xml:space="preserve">
          <source>Creates a copy of string &lt;code&gt;s&lt;/code&gt; by replacing any occurrence of the string &lt;code&gt;p&lt;/code&gt; with the string &lt;code&gt;r&lt;/code&gt;. Pushes the resulting string on the stack and returns it.</source>
          <target state="translated">Создает копию строки &lt;code&gt;s&lt;/code&gt; , заменяя любое вхождение строки &lt;code&gt;p&lt;/code&gt; строкой &lt;code&gt;r&lt;/code&gt; . Помещает получившуюся строку в стек и возвращает ее.</target>
        </trans-unit>
        <trans-unit id="409211348501f0fceae087d0a64eb7812f2900e2" translate="yes" xml:space="preserve">
          <source>Creates a new Lua state. It calls &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt; with an allocator based on the standard C &lt;code&gt;realloc&lt;/code&gt; function and then sets a panic function (see &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt;) that prints an error message to the standard error output in case of fatal errors.</source>
          <target state="translated">Создает новое состояние Lua. Он вызывает &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; с распределителем на основе стандартных С &lt;code&gt;realloc&lt;/code&gt; функции , а затем устанавливает функцию паники (см &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt; ) , который печатает сообщение об ошибке в стандартный вывод ошибок в случае неисправимых ошибок.</target>
        </trans-unit>
        <trans-unit id="e2e14753be2923d3727ec4c0b2962317308b7a78" translate="yes" xml:space="preserve">
          <source>Creates a new coroutine, with body &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; must be a function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to &lt;code&gt;resume&lt;/code&gt;. Returns the same values returned by &lt;code&gt;resume&lt;/code&gt;, except the first boolean. In case of error, propagates the error.</source>
          <target state="translated">Создает новую сопрограмму с телом &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; должна быть функцией. Возвращает функцию, которая возобновляет работу сопрограммы каждый раз при ее вызове. Любые аргументы, переданные функции, действуют как дополнительные аргументы для &lt;code&gt;resume&lt;/code&gt; . Возвращает те же значения, что и &lt;code&gt;resume&lt;/code&gt; , за исключением первого логического значения. В случае ошибки распространяет ошибку.</target>
        </trans-unit>
        <trans-unit id="05bb83a7ae7bf5c690003996483410c7c3b04c7a" translate="yes" xml:space="preserve">
          <source>Creates a new coroutine, with body &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; must be a function. Returns this new coroutine, an object with type &lt;code&gt;&quot;thread&quot;&lt;/code&gt;.</source>
          <target state="translated">Создает новую сопрограмму с телом &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; должна быть функцией. Возвращает эту новую сопрограмму, объект с типом &lt;code&gt;&quot;thread&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a50f66b26d5dc5b8cc4ba979a4ea976308b32d2" translate="yes" xml:space="preserve">
          <source>Creates a new empty table and pushes it onto the stack. It is equivalent to &lt;code&gt;lua_createtable(L, 0, 0)&lt;/code&gt;.</source>
          <target state="translated">Создает новую пустую таблицу и помещает ее в стек. Это эквивалентно &lt;code&gt;lua_createtable(L, 0, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96db399082b6917880b7df2255e1672897dcd9fd" translate="yes" xml:space="preserve">
          <source>Creates a new empty table and pushes it onto the stack. Parameter &lt;code&gt;narr&lt;/code&gt; is a hint for how many elements the table will have as a sequence; parameter &lt;code&gt;nrec&lt;/code&gt; is a hint for how many other elements the table will have. Lua may use these hints to preallocate memory for the new table. This preallocation is useful for performance when you know in advance how many elements the table will have. Otherwise you can use the function &lt;a href=&quot;#lua_newtable&quot;&gt;&lt;code&gt;lua_newtable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Создает новую пустую таблицу и помещает ее в стек. Параметр &lt;code&gt;narr&lt;/code&gt; указывает, сколько элементов в таблице будет в последовательности; параметр &lt;code&gt;nrec&lt;/code&gt; - подсказка о том, сколько других элементов будет в таблице. Lua может использовать эти подсказки для предварительного выделения памяти для новой таблицы. Это предварительное распределение полезно для повышения производительности, когда вы заранее знаете, сколько элементов будет в таблице. В противном случае вы можете использовать функцию &lt;a href=&quot;#lua_newtable&quot;&gt; &lt;code&gt;lua_newtable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cc85f5dc1d8e4aacd51d81be148d528a2a237f3a" translate="yes" xml:space="preserve">
          <source>Creates a new table and registers there the functions in list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">Создает новую таблицу и регистрирует в ней функции из списка &lt;code&gt;l&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e609328dccbccc7603668252d3543d1885dfb3e" translate="yes" xml:space="preserve">
          <source>Creates a new table with a size optimized to store all entries in the array &lt;code&gt;l&lt;/code&gt; (but does not actually store them). It is intended to be used in conjunction with &lt;a href=&quot;#luaL_setfuncs&quot;&gt;&lt;code&gt;luaL_setfuncs&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#luaL_newlib&quot;&gt;&lt;code&gt;luaL_newlib&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Создает новую таблицу с размером, оптимизированным для хранения всех записей в массиве &lt;code&gt;l&lt;/code&gt; (но фактически не сохраняет их). Он предназначен для использования вместе с &lt;a href=&quot;#luaL_setfuncs&quot;&gt; &lt;code&gt;luaL_setfuncs&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;#luaL_newlib&quot;&gt; &lt;code&gt;luaL_newlib&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c2dc3a7ed086d8ba5b98b47e50da72e0597ad2f" translate="yes" xml:space="preserve">
          <source>Creates a new thread running in a new, independent state. Returns &lt;code&gt;NULL&lt;/code&gt; if it cannot create the thread or the state (due to lack of memory). The argument &lt;code&gt;f&lt;/code&gt; is the allocator function; Lua does all memory allocation for this state through this function (see &lt;a href=&quot;#lua_Alloc&quot;&gt;&lt;code&gt;lua_Alloc&lt;/code&gt;&lt;/a&gt;). The second argument, &lt;code&gt;ud&lt;/code&gt;, is an opaque pointer that Lua passes to the allocator in every call.</source>
          <target state="translated">Создает новый поток, работающий в новом независимом состоянии. Возвращает &lt;code&gt;NULL&lt;/code&gt; , если не может создать поток или состояние (из-за нехватки памяти). Аргумент &lt;code&gt;f&lt;/code&gt; - это функция распределения; Lua выделяет всю память для этого состояния через эту функцию (см. &lt;a href=&quot;#lua_Alloc&quot;&gt; &lt;code&gt;lua_Alloc&lt;/code&gt; &lt;/a&gt; ). Второй аргумент &lt;code&gt;ud&lt;/code&gt; - это непрозрачный указатель, который Lua передает распределителю при каждом вызове.</target>
        </trans-unit>
        <trans-unit id="fd9ec8c11d7ac5415a760ccd09c2fad1db9839cf" translate="yes" xml:space="preserve">
          <source>Creates a new thread, pushes it on the stack, and returns a pointer to a &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt; that represents this new thread. The new thread returned by this function shares with the original thread its global environment, but has an independent execution stack.</source>
          <target state="translated">Создает новый поток, помещает его в стек и возвращает указатель на &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; &lt;/a&gt; , представляющий этот новый поток. Новый поток, возвращаемый этой функцией, разделяет с исходным потоком свою глобальную среду, но имеет независимый стек выполнения.</target>
        </trans-unit>
        <trans-unit id="6e0ca6aea862016d29b1b85fa495b05b651392c7" translate="yes" xml:space="preserve">
          <source>Creates and pushes a traceback of the stack &lt;code&gt;L1&lt;/code&gt;. If &lt;code&gt;msg&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt; it is appended at the beginning of the traceback. The &lt;code&gt;level&lt;/code&gt; parameter tells at which level to start the traceback.</source>
          <target state="translated">Создает и отправляет обратную трассировку стека &lt;code&gt;L1&lt;/code&gt; . Если &lt;code&gt;msg&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; оно добавляется в начало трассировки. Параметр &lt;code&gt;level&lt;/code&gt; сообщает, с какого уровня начать трассировку.</target>
        </trans-unit>
        <trans-unit id="15fe05dc16322e6d58cea2513fabb05e8a458e73" translate="yes" xml:space="preserve">
          <source>Creates and returns a &lt;em&gt;reference&lt;/em&gt;, in the table at index &lt;code&gt;t&lt;/code&gt;, for the object at the top of the stack (and pops the object).</source>
          <target state="translated">Создает и возвращает &lt;em&gt;ссылку&lt;/em&gt; в таблице с индексом &lt;code&gt;t&lt;/code&gt; для объекта в верхней части стека (и выталкивает объект).</target>
        </trans-unit>
        <trans-unit id="9a1d518693f03f77a887add36287621e0ff6c775" translate="yes" xml:space="preserve">
          <source>Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">Удаляет файл (или пустой каталог в системах POSIX) с заданным именем. Если эта функция не работает, она возвращает &lt;b&gt;nil&lt;/b&gt; плюс строку с описанием ошибки и ее код. В противном случае возвращается истина.</target>
        </trans-unit>
        <trans-unit id="7e2e965899d00dbeb421cf187b25cd3fbb127acb" translate="yes" xml:space="preserve">
          <source>Despite the existence of this external &lt;code&gt;_ENV&lt;/code&gt; variable and the translation of free names, &lt;code&gt;_ENV&lt;/code&gt; is a completely regular name. In particular, you can define new variables and parameters with that name. Each reference to a free name uses the &lt;code&gt;_ENV&lt;/code&gt; that is visible at that point in the program, following the usual visibility rules of Lua (see &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;).</source>
          <target state="translated">Несмотря на существование этой внешней переменной &lt;code&gt;_ENV&lt;/code&gt; и перевод свободных имен, &lt;code&gt;_ENV&lt;/code&gt; - полностью обычное имя. В частности, вы можете определять новые переменные и параметры с этим именем. Каждая ссылка на свободное имя использует &lt;code&gt;_ENV&lt;/code&gt; , который виден в этой точке программы, следуя обычным правилам видимости Lua (см. &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="12de5a5770780d211823aca1736624c0440ac4a1" translate="yes" xml:space="preserve">
          <source>Despite the name, the metamethod for this event can be either a function or a table. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as arguments, and the result of the call (adjusted to one value) is the result of the operation. If it is a table, the final result is the result of indexing this table with &lt;code&gt;key&lt;/code&gt;. (This indexing is regular, not raw, and therefore can trigger another metamethod.)</source>
          <target state="translated">Несмотря на название, метаметодом для этого события может быть функция или таблица. Если это функция, она вызывается с &lt;code&gt;table&lt;/code&gt; и &lt;code&gt;key&lt;/code&gt; качестве аргументов, а результат вызова (с поправкой на одно значение) является результатом операции. Если это таблица, окончательный результат - результат индексации этой таблицы с помощью &lt;code&gt;key&lt;/code&gt; . (Это индексирование является обычным, а не исходным, и поэтому может запускать другой метаметод.)</target>
        </trans-unit>
        <trans-unit id="e2dd868cc18f6f74b6780c7bcc3d9948c1df04c3" translate="yes" xml:space="preserve">
          <source>Destroys all objects in the given Lua state (calling the corresponding garbage-collection metamethods, if any) and frees all dynamic memory used by this state. On several platforms, you may not need to call this function, because all resources are naturally released when the host program ends. On the other hand, long-running programs that create multiple states, such as daemons or web servers, will probably need to close states as soon as they are not needed.</source>
          <target state="translated">Уничтожает все объекты в данном состоянии Луа (вызывает соответствующие метаметоды сбора мусора,если таковые имеются)и освобождает всю динамическую память,используемую в этом состоянии.На некоторых платформах нет необходимости вызывать эту функцию,так как все ресурсы естественным образом высвобождаются по окончании работы хостовой программы.С другой стороны,долгосрочные программы,создающие несколько состояний,такие как демоны или веб-серверы,вероятно,должны будут закрыть состояния,как только они не понадобятся.</target>
        </trans-unit>
        <trans-unit id="d6c256480b3e40e037a15bde7dbddae426d6a7cf" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[i] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">Выполняет эквивалент &lt;code&gt;t[i] = v&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - таблица с заданным индексом, а &lt;code&gt;v&lt;/code&gt; - значение наверху стека.</target>
        </trans-unit>
        <trans-unit id="83102ba0627ee415bcdafad8e821cc410f6ca4e8" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[p] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index, &lt;code&gt;p&lt;/code&gt; is encoded as a light userdata, and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">Выполняет эквивалент &lt;code&gt;t[p] = v&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - это таблица с заданным индексом, &lt;code&gt;p&lt;/code&gt; кодируется как легкие пользовательские данные, а &lt;code&gt;v&lt;/code&gt; - это значение наверху стека.</target>
        </trans-unit>
        <trans-unit id="e5e1d7b2dfe0e4b65f51a80784409021aefed2c4" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">Эквивалентно &lt;code&gt;t[k] = v&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - значение по данному индексу, а &lt;code&gt;v&lt;/code&gt; - значение наверху стека.</target>
        </trans-unit>
        <trans-unit id="8b79cf1f60fca53d0de89a3a12255d00973edf92" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index, &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack, and &lt;code&gt;k&lt;/code&gt; is the value just below the top.</source>
          <target state="translated">Эквивалентно &lt;code&gt;t[k] = v&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - значение по данному индексу, &lt;code&gt;v&lt;/code&gt; - значение наверху стека, а &lt;code&gt;k&lt;/code&gt; - значение чуть ниже вершины.</target>
        </trans-unit>
        <trans-unit id="cc3b7a2b7b1afec72c53764dcaa4a8915523e72b" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[n] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">Эквивалентно &lt;code&gt;t[n] = v&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - значение по данному индексу, а &lt;code&gt;v&lt;/code&gt; - значение наверху стека.</target>
        </trans-unit>
        <trans-unit id="054070872d4195e45bf298511993c73d44db5c6e" translate="yes" xml:space="preserve">
          <source>Dumps a function as a binary chunk. Receives a Lua function on the top of the stack and produces a binary chunk that, if loaded again, results in a function equivalent to the one dumped. As it produces parts of the chunk, &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; calls function &lt;code&gt;writer&lt;/code&gt; (see &lt;a href=&quot;#lua_Writer&quot;&gt;&lt;code&gt;lua_Writer&lt;/code&gt;&lt;/a&gt;) with the given &lt;code&gt;data&lt;/code&gt; to write them.</source>
          <target state="translated">Выгружает функцию как двоичный фрагмент. Получает функцию Lua наверху стека и создает двоичный фрагмент, который при повторной загрузке приводит к функции, эквивалентной сброшенной. Как она производит части куска, &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; вызывает функцию &lt;code&gt;writer&lt;/code&gt; (см &lt;a href=&quot;#lua_Writer&quot;&gt; &lt;code&gt;lua_Writer&lt;/code&gt; &lt;/a&gt; ) с заданными &lt;code&gt;data&lt;/code&gt; , чтобы записать их.</target>
        </trans-unit>
        <trans-unit id="c90c7bb6d9829fd16d0afd908f93d4e6040aff4e" translate="yes" xml:space="preserve">
          <source>During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is &lt;a href=&quot;#luaL_addvalue&quot;&gt;&lt;code&gt;luaL_addvalue&lt;/code&gt;&lt;/a&gt;.) After calling &lt;a href=&quot;#luaL_pushresult&quot;&gt;&lt;code&gt;luaL_pushresult&lt;/code&gt;&lt;/a&gt; the stack is back to its level when the buffer was initialized, plus the final string on its top.</source>
          <target state="translated">Во время нормальной работы строковый буфер использует переменное количество слотов стека. Таким образом, при использовании буфера вы не можете предполагать, что знаете, где находится вершина стека. Вы можете использовать стек между последовательными вызовами буферных операций, пока это использование сбалансировано; то есть, когда вы вызываете буферную операцию, стек находится на том же уровне, что и сразу после предыдущей буферной операции. (Единственным исключением из этого правила является &lt;a href=&quot;#luaL_addvalue&quot;&gt; &lt;code&gt;luaL_addvalue&lt;/code&gt; &lt;/a&gt; .) После вызова &lt;a href=&quot;#luaL_pushresult&quot;&gt; &lt;code&gt;luaL_pushresult&lt;/code&gt; &lt;/a&gt; стек возвращается на свой уровень, когда был инициализирован буфер, плюс последняя строка на его вершине.</target>
        </trans-unit>
        <trans-unit id="b76fabdeb134cd6b1444f21660aa818a7b0d8c8f" translate="yes" xml:space="preserve">
          <source>Dynamically links the host program with the C library &lt;code&gt;libname&lt;/code&gt;.</source>
          <target state="translated">Динамически связывает программу хоста с библиотекой C &lt;code&gt;libname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0f3fe6a9590293b6274b20698d15691bfb7be9e" translate="yes" xml:space="preserve">
          <source>Each Lua state has one or more threads, which correspond to independent, cooperative lines of execution. The type &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt; (despite its name) refers to a thread. (Indirectly, through the thread, it also refers to the Lua state associated to the thread.)</source>
          <target state="translated">Каждое состояние Lua имеет один или несколько потоков, которые соответствуют независимым, кооперативным линиям выполнения. Тип &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; &lt;/a&gt; (несмотря на название) относится к потоку. (Косвенно, через поток, это также относится к состоянию Lua, связанному с потоком.)</target>
        </trans-unit>
        <trans-unit id="271d158703dde3ea70b23b6f13cd8c963bd8f8f2" translate="yes" xml:space="preserve">
          <source>Each character in the string &lt;code&gt;what&lt;/code&gt; selects some fields of the structure &lt;code&gt;ar&lt;/code&gt; to be filled or a value to be pushed on the stack:</source>
          <target state="translated">Каждый символ в строке , &lt;code&gt;what&lt;/code&gt; выбирает некоторые поля структуры &lt;code&gt;ar&lt;/code&gt; должны быть заполнены или значение , которое будет в стек:</target>
        </trans-unit>
        <trans-unit id="34ea340a21718b1d5eb33af7ac68465d8a3a932c" translate="yes" xml:space="preserve">
          <source>Each entry in this table is a &lt;em&gt;searcher function&lt;/em&gt;. When looking for a module, &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; calls each of these searchers in ascending order, with the module name (the argument given to &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;) as its sole parameter. The function can return another function (the module &lt;em&gt;loader&lt;/em&gt;) plus an extra value that will be passed to that loader, or a string explaining why it did not find that module (or &lt;b&gt;nil&lt;/b&gt; if it has nothing to say).</source>
          <target state="translated">Каждая запись в этой таблице является &lt;em&gt;функцией поиска&lt;/em&gt; . При поиске модуля &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; вызывает каждый из этих искателей в возрастающем порядке, используя имя модуля (аргумент, указанный для &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; ) в качестве единственного параметра. Функция может возвращать другую функцию ( &lt;em&gt;загрузчик&lt;/em&gt; модуля ) плюс дополнительное значение, которое будет передано этому загрузчику, или строку, объясняющую, почему он не нашел этот модуль (или &lt;b&gt;nil,&lt;/b&gt; если ему нечего сказать).</target>
        </trans-unit>
        <trans-unit id="315546f1f8c7df68b4e7271febe7523458c848c7" translate="yes" xml:space="preserve">
          <source>Each field of the form &lt;code&gt;[exp1] = exp2&lt;/code&gt; adds to the new table an entry with key &lt;code&gt;exp1&lt;/code&gt; and value &lt;code&gt;exp2&lt;/code&gt;. A field of the form &lt;code&gt;name = exp&lt;/code&gt; is equivalent to &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt;. Finally, fields of the form &lt;code&gt;exp&lt;/code&gt; are equivalent to &lt;code&gt;[i] = exp&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; are consecutive integers starting with 1. Fields in the other formats do not affect this counting. For example,</source>
          <target state="translated">Каждое поле формы &lt;code&gt;[exp1] = exp2&lt;/code&gt; добавляет в новую таблицу запись с ключом &lt;code&gt;exp1&lt;/code&gt; и значением &lt;code&gt;exp2&lt;/code&gt; . Поле формы &lt;code&gt;name = exp&lt;/code&gt; эквивалентно &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt; . Наконец, поля формы &lt;code&gt;exp&lt;/code&gt; эквивалентны &lt;code&gt;[i] = exp&lt;/code&gt; , где &lt;code&gt;i&lt;/code&gt; - последовательные целые числа, начинающиеся с 1. Поля в других форматах не влияют на этот подсчет. Например,</target>
        </trans-unit>
        <trans-unit id="5ded60221fcd42af87598bfa3998cbd1f3094a3c" translate="yes" xml:space="preserve">
          <source>Each new thread has this area initialized with a copy of the area of the main thread.</source>
          <target state="translated">В каждом новом потоке эта область инициализируется копией области основного потока.</target>
        </trans-unit>
        <trans-unit id="724adec43f3df4f9471590e57b3efefd102497cf" translate="yes" xml:space="preserve">
          <source>Ensures that the stack has space for at least &lt;code&gt;n&lt;/code&gt; extra slots (that is, that you can safely push up to &lt;code&gt;n&lt;/code&gt; values into it). It returns false if it cannot fulfill the request, either because it would cause the stack to be larger than a fixed maximum size (typically at least several thousand elements) or because it cannot allocate memory for the extra space. This function never shrinks the stack; if the stack already has space for the extra slots, it is left unchanged.</source>
          <target state="translated">Гарантирует, что в стеке есть место как минимум для &lt;code&gt;n&lt;/code&gt; дополнительных слотов (то есть, что вы можете безопасно вставить в него до &lt;code&gt;n&lt;/code&gt; значений). Он возвращает false, если он не может выполнить запрос, либо потому, что это приведет к тому, что стек будет больше фиксированного максимального размера (обычно не менее нескольких тысяч элементов), либо потому, что он не может выделить память для дополнительного пространства. Эта функция никогда не сжимает стек; если в стеке уже есть место для дополнительных слотов, он остается без изменений.</target>
        </trans-unit>
        <trans-unit id="94cdd3c18c2b4719474c53fa6f1b9fb02152a15d" translate="yes" xml:space="preserve">
          <source>Ensures that the value &lt;code&gt;t[fname]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at index &lt;code&gt;idx&lt;/code&gt;, is a table, and pushes that table onto the stack. Returns true if it finds a previous table there and false if it creates a new table.</source>
          <target state="translated">Гарантирует, что значение &lt;code&gt;t[fname]&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - значение индекса &lt;code&gt;idx&lt;/code&gt; , является таблицей, и помещает эту таблицу в стек. Возвращает истину, если находит там предыдущую таблицу, и ложь, если создает новую таблицу.</target>
        </trans-unit>
        <trans-unit id="d2187e2e8c84822845af903355cda0cd820011ab" translate="yes" xml:space="preserve">
          <source>Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word &lt;code&gt;cont&lt;/code&gt; finishes this function, so that the caller continues its execution.</source>
          <target state="translated">Переходит в интерактивный режим с пользователем, выполняя каждую строку, которую вводит пользователь. Используя простые команды и другие средства отладки, пользователь может проверять глобальные и локальные переменные, изменять их значения, оценивать выражения и т. Д. Строка, содержащая только слово &lt;code&gt;cont&lt;/code&gt; , завершает эту функцию, так что вызывающий продолжает ее выполнение.</target>
        </trans-unit>
        <trans-unit id="4bc7c25b89d339e7967419718f888c8e7706661a" translate="yes" xml:space="preserve">
          <source>Environments and the Global Environment</source>
          <target state="translated">Окружающая среда и глобальная окружающая среда</target>
        </trans-unit>
        <trans-unit id="911d3f66ebade1de45eca3fa1b80cbca2b45963a" translate="yes" xml:space="preserve">
          <source>Equality (&lt;code&gt;==&lt;/code&gt;) first compares the type of its operands. If the types are different, then the result is &lt;b&gt;false&lt;/b&gt;. Otherwise, the values of the operands are compared. Strings are compared in the obvious way. Numbers are equal if they denote the same mathematical value.</source>
          <target state="translated">Равенство ( &lt;code&gt;==&lt;/code&gt; ) сначала сравнивает тип своих операндов. Если типы разные, то результат &lt;b&gt;ложный&lt;/b&gt; . В противном случае сравниваются значения операндов. Строки сравниваются очевидным образом. Числа равны, если они обозначают одно и то же математическое значение.</target>
        </trans-unit>
        <trans-unit id="8bba7708d9cd62b79eff18edb05f15a66e6e4fc3" translate="yes" xml:space="preserve">
          <source>Equality comparisons do not convert strings to numbers or vice versa. Thus, &lt;code&gt;&quot;0&quot;==0&lt;/code&gt; evaluates to &lt;b&gt;false&lt;/b&gt;, and &lt;code&gt;t[0]&lt;/code&gt; and &lt;code&gt;t[&quot;0&quot;]&lt;/code&gt; denote different entries in a table.</source>
          <target state="translated">Сравнение на равенство не преобразует строки в числа и наоборот. Таким образом, &lt;code&gt;&quot;0&quot;==0&lt;/code&gt; оценивается как &lt;b&gt;ложь&lt;/b&gt; , а &lt;code&gt;t[0]&lt;/code&gt; и &lt;code&gt;t[&quot;0&quot;]&lt;/code&gt; обозначают разные записи в таблице.</target>
        </trans-unit>
        <trans-unit id="eeb6206afe341a7d07c673213b74b2763b8aad8a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_loadbufferx&quot;&gt;&lt;code&gt;luaL_loadbufferx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;mode&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;#luaL_loadbufferx&quot;&gt; &lt;code&gt;luaL_loadbufferx&lt;/code&gt; &lt;/a&gt; с &lt;code&gt;mode&lt;/code&gt; равным &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5ac0bf4ab4157c76c5229bc6b001f02e1bbdbe" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_loadfilex&quot;&gt;&lt;code&gt;luaL_loadfilex&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;mode&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;#luaL_loadfilex&quot;&gt; &lt;code&gt;luaL_loadfilex&lt;/code&gt; &lt;/a&gt; с &lt;code&gt;mode&lt;/code&gt; равным &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417f3cabd0ae3b21c9200dade7625b6b803e2a8a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt;&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;&lt;/a&gt; with the predefined size &lt;a id=&quot;pdf-LUAL_BUFFERSIZE&quot;&gt;&lt;code&gt;LUAL_BUFFERSIZE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt; &lt;code&gt;luaL_prepbuffsize&lt;/code&gt; &lt;/a&gt; с предопределенным размером &lt;a id=&quot;pdf-LUAL_BUFFERSIZE&quot;&gt; &lt;code&gt;LUAL_BUFFERSIZE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bdbca26c05283a107728b580733fbf5005aa002" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;, except that it receives a &lt;code&gt;va_list&lt;/code&gt; instead of a variable number of arguments.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; &lt;/a&gt; , за исключением того, что он получает &lt;code&gt;va_list&lt;/code&gt; вместо переменного числа аргументов.</target>
        </trans-unit>
        <trans-unit id="048179e8ca8eda05fb0bd3fd434b84a3be42d2f7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tointegerx&quot;&gt;&lt;code&gt;lua_tointegerx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;isnum&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;a href=&quot;#lua_tointegerx&quot;&gt; &lt;code&gt;lua_tointegerx&lt;/code&gt; &lt;/a&gt; с &lt;code&gt;isnum&lt;/code&gt; равным &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eea1358153e9600e250e3541353b60210297af9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;len&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt; с &lt;code&gt;len&lt;/code&gt; , равным &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="859cc0dd8a506649ee3ce18e480ee774adf2690e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tonumberx&quot;&gt;&lt;code&gt;lua_tonumberx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;isnum&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Эквивалентен &lt;a href=&quot;#lua_tonumberx&quot;&gt; &lt;code&gt;lua_tonumberx&lt;/code&gt; &lt;/a&gt; с &lt;code&gt;isnum&lt;/code&gt; равным &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f10e3538e7d3cff0cc3010f6eafa5510d5b4eabf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;file:close()&lt;/code&gt;. Without a &lt;code&gt;file&lt;/code&gt;, closes the default output file.</source>
          <target state="translated">Эквивалент &lt;code&gt;file:close()&lt;/code&gt; . Без &lt;code&gt;file&lt;/code&gt; закрывает выходной файл по умолчанию.</target>
        </trans-unit>
        <trans-unit id="47bb85f8430ddf2501d6a1df9b4dd575ae0b94f6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.input():read(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;io.input():read(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b236c5a9b8def03419e72a62b54cf06568e7ac12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.output():flush()&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;io.output():flush()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4a16ee993787daf20f8abfd04e25a53a52555ae" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.output():write(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt;.</source>
          <target state="translated">Эквивалентно &lt;code&gt;io.output():write(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95841ee72cef3e69b1415de06e904a02c3a22ad7" translate="yes" xml:space="preserve">
          <source>Equivalent to the sequence &lt;a href=&quot;#luaL_addsize&quot;&gt;&lt;code&gt;luaL_addsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_pushresult&quot;&gt;&lt;code&gt;luaL_pushresult&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эквивалентно последовательности &lt;a href=&quot;#luaL_addsize&quot;&gt; &lt;code&gt;luaL_addsize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_pushresult&quot;&gt; &lt;code&gt;luaL_pushresult&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a9197bd8cc7210e1d081737ce79a0004c900ea5" translate="yes" xml:space="preserve">
          <source>Equivalent to the sequence &lt;a href=&quot;#luaL_buffinit&quot;&gt;&lt;code&gt;luaL_buffinit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt;&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Эквивалент последовательности &lt;a href=&quot;#luaL_buffinit&quot;&gt; &lt;code&gt;luaL_buffinit&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt; &lt;code&gt;luaL_prepbuffsize&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">обработка ошибок</target>
        </trans-unit>
        <trans-unit id="efce06d9e3b29a083012c673a0d05df2af20d9a0" translate="yes" xml:space="preserve">
          <source>Even when we use the term &quot;function&quot;, any facility in the API may be provided as a macro instead. Except where stated otherwise, all such macros use each of their arguments exactly once (except for the first argument, which is always a Lua state), and so do not generate any hidden side-effects.</source>
          <target state="translated">Даже когда мы используем термин &quot;функция&quot;,любая подсистема в API может быть предоставлена в виде макроса.За исключением случаев,когда указано иное,все такие макросы используют каждый из своих аргументов ровно один раз (за исключением первого аргумента,который всегда является состоянием Lua),и поэтому не генерируют скрытых побочных эффектов.</target>
        </trans-unit>
        <trans-unit id="876b22e6469bec417ede0947f746abdd3c61cdc3" translate="yes" xml:space="preserve">
          <source>Every value in Lua can have a &lt;em&gt;metatable&lt;/em&gt;. This &lt;em&gt;metatable&lt;/em&gt; is an ordinary Lua table that defines the behavior of the original value under certain special operations. You can change several aspects of the behavior of operations over a value by setting specific fields in its metatable. For instance, when a non-numeric value is the operand of an addition, Lua checks for a function in the field &quot;&lt;code&gt;__add&lt;/code&gt;&quot; of the value's metatable. If it finds one, Lua calls this function to perform the addition.</source>
          <target state="translated">Каждое значение в Lua может иметь &lt;em&gt;метатаблицу&lt;/em&gt; . Эта &lt;em&gt;метатаблица&lt;/em&gt; представляет собой обычную таблицу Lua, которая определяет поведение исходного значения при определенных специальных операциях. Вы можете изменить несколько аспектов поведения операций над значением, задав определенные поля в его метатаблице. Например, когда нечисловое значение является операндом добавления, Lua проверяет функцию в поле &amp;laquo; &lt;code&gt;__add&lt;/code&gt; &amp;raquo; метатаблицы значения. Если он его находит, Lua вызывает эту функцию для выполнения добавления.</target>
        </trans-unit>
        <trans-unit id="34fb3456225dbfac064754a0c940e7ab97d70dab" translate="yes" xml:space="preserve">
          <source>Examples of valid float constants are</source>
          <target state="translated">Примерами действующих констант поплавка являются</target>
        </trans-unit>
        <trans-unit id="dc9054ac99639aca0dedbf9ce85be2d8cb078353" translate="yes" xml:space="preserve">
          <source>Except for the basic and the package libraries, each library provides all its functions as fields of a global table or as methods of its objects.</source>
          <target state="translated">За исключением базовой и пакетной библиотек,каждая библиотека предоставляет все свои функции как поля глобальной таблицы или как методы своих объектов.</target>
        </trans-unit>
        <trans-unit id="a454333e5ab07af66349fc9dcc89eefc63ffc046" translate="yes" xml:space="preserve">
          <source>Exchange values between different threads of the same state.</source>
          <target state="translated">Обмен значениями между различными потоками одного и того же состояния.</target>
        </trans-unit>
        <trans-unit id="8a70a348295e730e4d487448d5bdfd5d0a1f52d4" translate="yes" xml:space="preserve">
          <source>Explicit blocks are useful to control the scope of variable declarations. Explicit blocks are also sometimes used to add a &lt;b&gt;return&lt;/b&gt; statement in the middle of another block (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;).</source>
          <target state="translated">Явные блоки полезны для управления областью объявления переменных. Явные блоки также иногда используются для добавления оператора &lt;b&gt;возврата&lt;/b&gt; в середине другого блока (см. &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6068d6a6087004b84e19a26f762381a6d306ebf7" translate="yes" xml:space="preserve">
          <source>Exponentiation and float division (&lt;code&gt;/&lt;/code&gt;) always convert their operands to floats and the result is always a float. Exponentiation uses the ISO C function &lt;code&gt;pow&lt;/code&gt;, so that it works for non-integer exponents too.</source>
          <target state="translated">Возведение в степень и деление с плавающей запятой ( &lt;code&gt;/&lt;/code&gt; ) всегда преобразует их операнды в числа с плавающей запятой, и результатом всегда является число с плавающей запятой. Возведение в степень использует функцию &lt;code&gt;pow&lt;/code&gt; в соответствии с ISO C , поэтому она работает и для нецелочисленных показателей.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="3403002da8268dbb07086fbb61ed468d09402d3c" translate="yes" xml:space="preserve">
          <source>Expressions are discussed in &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt;.</source>
          <target state="translated">Выражения обсуждаются в п. &lt;a href=&quot;#3.4&quot;&gt;3.4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="952220342168dc20bbaf6ee3888975552b5929df" translate="yes" xml:space="preserve">
          <source>Finish by calling &lt;code&gt;luaL_pushresult(&amp;amp;b)&lt;/code&gt;. This call leaves the final string on the top of the stack.</source>
          <target state="translated">Завершите, вызвав &lt;code&gt;luaL_pushresult(&amp;amp;b)&lt;/code&gt; . Этот вызов оставляет последнюю строку наверху стека.</target>
        </trans-unit>
        <trans-unit id="e24c3abeab89141035172a8f0844d2e645ae86bc" translate="yes" xml:space="preserve">
          <source>Finish by calling &lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt;, where &lt;code&gt;sz&lt;/code&gt; is the total size of the resulting string copied into that space.</source>
          <target state="translated">Закончите, вызвав &lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt; , где &lt;code&gt;sz&lt;/code&gt; - общий размер результирующей строки, скопированной в это пространство.</target>
        </trans-unit>
        <trans-unit id="fa1b0bd32568564210439e9f8bbb29579af4e8f6" translate="yes" xml:space="preserve">
          <source>Finishes the use of buffer &lt;code&gt;B&lt;/code&gt; leaving the final string on the top of the stack.</source>
          <target state="translated">Завершает использование буфера &lt;code&gt;B&lt;/code&gt; , оставляя последнюю строку наверху стека.</target>
        </trans-unit>
        <trans-unit id="9581cd1476458beea36edaaa1aab1a70ddd9b799" translate="yes" xml:space="preserve">
          <source>First &lt;code&gt;require&lt;/code&gt; queries &lt;code&gt;package.preload[modname]&lt;/code&gt;. If it has a value, this value (which must be a function) is the loader. Otherwise &lt;code&gt;require&lt;/code&gt; searches for a Lua loader using the path stored in &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;. If that also fails, it searches for a C loader using the path stored in &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt;. If that also fails, it tries an &lt;em&gt;all-in-one&lt;/em&gt; loader (see &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Сначала &lt;code&gt;require&lt;/code&gt; запросы &lt;code&gt;package.preload[modname]&lt;/code&gt; . Если у него есть значение, это значение (которое должно быть функцией) является загрузчиком. В противном случае &lt;code&gt;require&lt;/code&gt; поиск загрузчика Lua, используя путь, хранящийся в &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; . Если и это не удается, он ищет загрузчик C, используя путь, хранящийся в &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; . Если безуспешна, он пытается в &lt;em&gt;все-в-одном&lt;/em&gt; загрузчик (см &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf6993356b76fa41b8a9a12311a4583412cacf12" translate="yes" xml:space="preserve">
          <source>First declare a variable &lt;code&gt;b&lt;/code&gt; of type &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Сначала объявите переменную &lt;code&gt;b&lt;/code&gt; типа &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2d47a74b914f2999fca9d267f869c38ca08b9e6" translate="yes" xml:space="preserve">
          <source>Floor division (&lt;code&gt;//&lt;/code&gt;) is a division that rounds the quotient towards minus infinity, that is, the floor of the division of its operands.</source>
          <target state="translated">Деление по полу ( &lt;code&gt;//&lt;/code&gt; ) - это деление, при котором частное округляется до минус бесконечности, то есть до минимума деления его операндов.</target>
        </trans-unit>
        <trans-unit id="9578580e96abd6dc66d3f4a9ec50cb8852f521d3" translate="yes" xml:space="preserve">
          <source>Following the IEEE 754 standard, NaN is considered neither smaller than, nor equal to, nor greater than any value (including itself).</source>
          <target state="translated">В соответствии со стандартом IEEE 754,NaN считается не меньше,не равно и не больше любой величины (включая саму себя).</target>
        </trans-unit>
        <trans-unit id="7968a691f0ed611daf368a38173ca221f41fe6c2" translate="yes" xml:space="preserve">
          <source>For C functions, this function uses the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; as a name for all upvalues. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.)</source>
          <target state="translated">Для функций C эта функция использует пустую строку &lt;code&gt;&quot;&quot;&lt;/code&gt; в качестве имени для всех повышающих значений. (Для функций Lua повышающие значения - это внешние локальные переменные, которые использует функция и которые, следовательно, включаются в ее закрытие.)</target>
        </trans-unit>
        <trans-unit id="826bad097a9af03241478f133b816c28a093c4ff" translate="yes" xml:space="preserve">
          <source>For Statement</source>
          <target state="translated">Для заявления</target>
        </trans-unit>
        <trans-unit id="232d13ae76c1a448a0dbe30fce0093b7011c947c" translate="yes" xml:space="preserve">
          <source>For all classes represented by single letters (&lt;code&gt;%a&lt;/code&gt;, &lt;code&gt;%c&lt;/code&gt;, etc.), the corresponding uppercase letter represents the complement of the class. For instance, &lt;code&gt;%S&lt;/code&gt; represents all non-space characters.</source>
          <target state="translated">Для всех классов, представленных одиночными буквами ( &lt;code&gt;%a&lt;/code&gt; , &lt;code&gt;%c&lt;/code&gt; и т. Д.), Соответствующая заглавная буква представляет собой дополнение класса. Например, &lt;code&gt;%S&lt;/code&gt; представляет все непробельные символы.</target>
        </trans-unit>
        <trans-unit id="b277899f2ddc10d7e3dad8301744987f188c3222" translate="yes" xml:space="preserve">
          <source>For an object (table or userdata) to be finalized when collected, you must &lt;em&gt;mark&lt;/em&gt; it for finalization. You mark an object for finalization when you set its metatable and the metatable has a field indexed by the string &quot;&lt;code&gt;__gc&lt;/code&gt;&quot;. Note that if you set a metatable without a &lt;code&gt;__gc&lt;/code&gt; field and later create that field in the metatable, the object will not be marked for finalization.</source>
          <target state="translated">Чтобы объект (таблица или пользовательские данные) был завершен при сборе, вы должны &lt;em&gt;пометить&lt;/em&gt; его для завершения. Вы помечаете объект для завершения, когда устанавливаете его метатаблицу, и метатаблица имеет поле, проиндексированное строкой &amp;laquo; &lt;code&gt;__gc&lt;/code&gt; &amp;raquo;. Обратите внимание, что если вы установите метатаблицу без поля &lt;code&gt;__gc&lt;/code&gt; , а затем создадите это поле в метатаблице, объект не будет помечен для завершения.</target>
        </trans-unit>
        <trans-unit id="21127f5444f9175d599260124aacb43b3cb15bde" translate="yes" xml:space="preserve">
          <source>For call events, &lt;code&gt;event&lt;/code&gt; can be &lt;code&gt;LUA_HOOKCALL&lt;/code&gt;, the normal value, or &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt;, for a tail call; in this case, there will be no corresponding return event.</source>
          <target state="translated">Для событий вызова &lt;code&gt;event&lt;/code&gt; может быть &lt;code&gt;LUA_HOOKCALL&lt;/code&gt; , нормальным значением, или &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt; , для хвостового вызова; в этом случае не будет соответствующего события возврата.</target>
        </trans-unit>
        <trans-unit id="ef19782c3b513548f8d3e4e46e68c607de619e6c" translate="yes" xml:space="preserve">
          <source>For convenience, most query operations in the API do not follow a strict stack discipline. Instead, they can refer to any element in the stack by using an &lt;em&gt;index&lt;/em&gt;: A positive index represents an absolute stack position (starting at 1); a negative index represents an offset relative to the top of the stack. More specifically, if the stack has &lt;em&gt;n&lt;/em&gt; elements, then index 1 represents the first element (that is, the element that was pushed onto the stack first) and index &lt;em&gt;n&lt;/em&gt; represents the last element; index -1 also represents the last element (that is, the element at the top) and index &lt;em&gt;-n&lt;/em&gt; represents the first element.</source>
          <target state="translated">Для удобства большинство операций запросов в API не подчиняются строгой дисциплине стека. Вместо этого они могут ссылаться на любой элемент в стеке с помощью &lt;em&gt;индекса&lt;/em&gt; : положительный индекс представляет собой абсолютную позицию в стеке (начиная с 1); отрицательный индекс представляет собой смещение относительно вершины стека. Более конкретно, если стек имеет &lt;em&gt;n&lt;/em&gt; элементов, то индекс 1 представляет первый элемент (то есть элемент, который был помещен в стек первым), а индекс &lt;em&gt;n&lt;/em&gt; представляет последний элемент; index -1 также представляет последний элемент (то есть элемент вверху), а index &lt;em&gt;-n&lt;/em&gt; представляет первый элемент.</target>
        </trans-unit>
        <trans-unit id="e8e7817ee2d33410b37da66bff2f4abc60fd9f19" translate="yes" xml:space="preserve">
          <source>For convenience, when the opening long bracket is immediately followed by a newline, the newline is not included in the string. As an example, in a system using ASCII (in which '&lt;code&gt;a&lt;/code&gt;' is coded as 97, newline is coded as 10, and '&lt;code&gt;1&lt;/code&gt;' is coded as 49), the five literal strings below denote the same string:</source>
          <target state="translated">Для удобства, когда за открывающей длинной скобкой сразу следует новая строка, она не включается в строку. Например, в системе, использующей ASCII (в которой ' &lt;code&gt;a&lt;/code&gt; ' кодируется как 97, новая строка кодируется как 10, а ' &lt;code&gt;1&lt;/code&gt; ' кодируется как 49), пять литеральных строк ниже обозначают одну и ту же строку:</target>
        </trans-unit>
        <trans-unit id="c75b8f31dba0d91bae695aa013d0381fc16c8094" translate="yes" xml:space="preserve">
          <source>For functions that can be called with acceptable indices, any non-valid index is treated as if it contains a value of a virtual type &lt;a id=&quot;pdf-LUA_TNONE&quot;&gt;&lt;code&gt;LUA_TNONE&lt;/code&gt;&lt;/a&gt;, which behaves like a nil value.</source>
          <target state="translated">Для функций, которые могут быть вызваны с допустимыми индексами, любой недействительный индекс обрабатывается так, как если бы он содержал значение виртуального типа &lt;a id=&quot;pdf-LUA_TNONE&quot;&gt; &lt;code&gt;LUA_TNONE&lt;/code&gt; &lt;/a&gt; , которое ведет себя как значение nil.</target>
        </trans-unit>
        <trans-unit id="a31447203fafe5a4da4338521a4a4fb721154e10" translate="yes" xml:space="preserve">
          <source>For instance, if the path is the string</source>
          <target state="translated">Например,если путь-это строка</target>
        </trans-unit>
        <trans-unit id="ea7d77d2e3991db06f939eac321dd577052affc3" translate="yes" xml:space="preserve">
          <source>For instance, the expression &lt;code&gt;debug.getinfo(1,&quot;n&quot;).name&lt;/code&gt; returns a name for the current function, if a reasonable name can be found, and the expression &lt;code&gt;debug.getinfo(print)&lt;/code&gt; returns a table with all available information about the &lt;a href=&quot;#pdf-print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Например, выражение &lt;code&gt;debug.getinfo(1,&quot;n&quot;).name&lt;/code&gt; возвращает имя для текущей функции, если можно найти &lt;code&gt;debug.getinfo(print)&lt;/code&gt; имя, а выражение debug.getinfo (print) возвращает таблицу со всей доступной информацией о &lt;a href=&quot;#pdf-print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; функция.</target>
        </trans-unit>
        <trans-unit id="f325475ad152d3908d4847a20ea6df37fed2cc91" translate="yes" xml:space="preserve">
          <source>For more details about these options, see &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Дополнительные сведения об этих параметрах см . В разделе &lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="34c0c487495b8d4cfa8ec08b6a774ef30e784f4f" translate="yes" xml:space="preserve">
          <source>For options &quot;&lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, and &quot;&lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &lt;code&gt;n&lt;/code&gt; can be any integer between 1 and 16. All integral options check overflows; &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; checks whether the given value fits in the given size; &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; checks whether the read value fits in a Lua integer.</source>
          <target state="translated">Для опций &amp;laquo; &lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &amp;raquo;, &amp;laquo; &lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &amp;raquo; и &amp;laquo; &lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &amp;raquo; &lt;code&gt;n&lt;/code&gt; может быть любым целым числом от 1 до 16. Все интегральные опции проверяют переполнение; &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; проверяет, подходит ли данное значение заданному размеру; &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; проверяет, соответствует ли прочитанное значение целому числу Lua.</target>
        </trans-unit>
        <trans-unit id="f81592a23f0c3cfdc23fb61def4f995f00f7e4be" translate="yes" xml:space="preserve">
          <source>For the last two cases, &lt;code&gt;size&lt;/code&gt; specifies the size of the buffer, in bytes. The default is an appropriate size.</source>
          <target state="translated">Для последних двух случаев &lt;code&gt;size&lt;/code&gt; указывает размер буфера в байтах. По умолчанию это подходящий размер.</target>
        </trans-unit>
        <trans-unit id="f0c4dd09d2da4ac2d83e7333654eda3bf03b94aa" translate="yes" xml:space="preserve">
          <source>For the unary operators (negation, length, and bitwise NOT), the metamethod is computed and called with a dummy second operand, equal to the first one. This extra operand is only to simplify Lua's internals (by making these operators behave like a binary operation) and may be removed in future versions. (For most uses this extra operand is irrelevant.)</source>
          <target state="translated">Для унарных операторов (отрицание,длина и битовое NOT)метаметод вычисляется и вызывается с помощью фиктивного второго операнда,равного первому.Этот дополнительный операнд служит только для упрощения внутренних операций Луа (заставляя эти операторы вести себя как двоичная операция)и может быть удален в будущих версиях.(Для большинства случаев использования этот дополнительный операнд не имеет значения).</target>
        </trans-unit>
        <trans-unit id="9bee60d752066315e8c5d61073cf8553d9376cba" translate="yes" xml:space="preserve">
          <source>For this function, a caret '&lt;code&gt;^&lt;/code&gt;' at the start of a pattern does not work as an anchor, as this would prevent the iteration.</source>
          <target state="translated">Для этой функции курсор &amp;laquo; &lt;code&gt;^&lt;/code&gt; &amp;raquo; в начале шаблона не работает как якорь, так как это предотвратит итерацию.</target>
        </trans-unit>
        <trans-unit id="399be06d89bf8fe00ffb06cec99c776653b07ce7" translate="yes" xml:space="preserve">
          <source>Format Strings for Pack and Unpack</source>
          <target state="translated">Строки формата для упаковки и распаковки</target>
        </trans-unit>
        <trans-unit id="530d75eed648d882414a993d7c2be06a4295791d" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; has an extra parameter, &lt;code&gt;strip&lt;/code&gt;. Use 0 as the value of this parameter to get the old behavior.</source>
          <target state="translated">Функция &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; имеет дополнительный параметр &lt;code&gt;strip&lt;/code&gt; . Используйте 0 в качестве значения этого параметра, чтобы получить прежнее поведение.</target>
        </trans-unit>
        <trans-unit id="d8cdf10face49f05a0d7bce562c1cbcff9eeec04" translate="yes" xml:space="preserve">
          <source>Function Calls</source>
          <target state="translated">Функциональные вызовы</target>
        </trans-unit>
        <trans-unit id="4b57ecf18e5d2f870512efd9673b84b72878ac94" translate="yes" xml:space="preserve">
          <source>Function Calls as Statements</source>
          <target state="translated">Функция Звонки как заявления</target>
        </trans-unit>
        <trans-unit id="92923ba91494ddefbc1f5287cf60c97558518359" translate="yes" xml:space="preserve">
          <source>Function Definitions</source>
          <target state="translated">Функции Определения</target>
        </trans-unit>
        <trans-unit id="a8675a73106b372729db5f272e24a7c2891c266a" translate="yes" xml:space="preserve">
          <source>Function calls and assignments can start with an open parenthesis. This possibility leads to an ambiguity in Lua's grammar. Consider the following fragment:</source>
          <target state="translated">Вызовы и назначения функций могут начинаться с открытых скобок.Эта возможность приводит к неоднозначности в грамматике Луа.Рассмотрим следующий фрагмент:</target>
        </trans-unit>
        <trans-unit id="723bc3c839b5efbdcf6d6d540aec9e08e9a27818" translate="yes" xml:space="preserve">
          <source>Functions called &lt;code&gt;luaL_check*&lt;/code&gt; always raise an error if the check is not satisfied.</source>
          <target state="translated">Функции &lt;code&gt;luaL_check*&lt;/code&gt; всегда вызывают ошибку, если проверка не выполняется.</target>
        </trans-unit>
        <trans-unit id="5c702d0533cf7bf413cae345667e4f93afbda238" translate="yes" xml:space="preserve">
          <source>Functions that do not need a specific mutable position, but only a value (e.g., query functions), can be called with acceptable indices. An &lt;em&gt;acceptable index&lt;/em&gt; can be any valid index, but it also can be any positive index after the stack top within the space allocated for the stack, that is, indices up to the stack size. (Note that 0 is never an acceptable index.) Except when noted otherwise, functions in the API work with acceptable indices.</source>
          <target state="translated">Функции, которым не нужна конкретная изменяемая позиция, а только значение (например, функции запроса), могут быть вызваны с приемлемыми индексами. &lt;em&gt;Приемлемым индекс&lt;/em&gt; может быть любым допустимым индексом, но она также может быть любым положительным индексом после вершины стека в пределах пространства , выделенного для стека, то есть, индексы до размера стека. (Обратите внимание, что 0 никогда не является приемлемым индексом.) Если не указано иное, функции в API работают с допустимыми индексами.</target>
        </trans-unit>
        <trans-unit id="a1a5aae46bd7798a00126da19dd14418bb7e3eb8" translate="yes" xml:space="preserve">
          <source>Functions to inject/project unsigned integers (&lt;code&gt;lua_pushunsigned&lt;/code&gt;, &lt;code&gt;lua_tounsigned&lt;/code&gt;, &lt;code&gt;lua_tounsignedx&lt;/code&gt;, &lt;code&gt;luaL_checkunsigned&lt;/code&gt;, &lt;code&gt;luaL_optunsigned&lt;/code&gt;) were deprecated. Use their signed equivalents with a type cast.</source>
          <target state="translated">Функции для внедрения / проецирования беззнаковых целых чисел ( &lt;code&gt;lua_pushunsigned&lt;/code&gt; , &lt;code&gt;lua_tounsigned&lt;/code&gt; , &lt;code&gt;lua_tounsignedx&lt;/code&gt; , &lt;code&gt;luaL_checkunsigned&lt;/code&gt; , &lt;code&gt;luaL_optunsigned&lt;/code&gt; ) устарели. Используйте их подписанные эквиваленты с приведением типа.</target>
        </trans-unit>
        <trans-unit id="399c67992893454b594db8a5c3ddb1835002a32d" translate="yes" xml:space="preserve">
          <source>Functions with upvalues have only their number of upvalues saved. When (re)loaded, those upvalues receive fresh instances containing &lt;b&gt;nil&lt;/b&gt;. (You can use the debug library to serialize and reload the upvalues of a function in a way adequate to your needs.)</source>
          <target state="translated">Функции с повышающими значениями сохраняют только их количество повышенных значений. При (повторной) загрузке эти upvalue получают новые экземпляры, содержащие &lt;b&gt;nil&lt;/b&gt; . (Вы можете использовать библиотеку отладки для сериализации и перезагрузки повышающих значений функции способом, соответствующим вашим потребностям.)</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">Сбор мусора</target>
        </trans-unit>
        <trans-unit id="f6855bbf563c59c18fc37154e4af975ae952d5a4" translate="yes" xml:space="preserve">
          <source>Garbage-Collection Metamethods</source>
          <target state="translated">Метаметоды сбора мешков с мусором</target>
        </trans-unit>
        <trans-unit id="313100c75a8533ab565e1eb0ac9c81f85a7c5073" translate="yes" xml:space="preserve">
          <source>Generates a Lua error, using the value at the top of the stack as the error object. This function does a long jump, and therefore never returns (see &lt;a href=&quot;#luaL_error&quot;&gt;&lt;code&gt;luaL_error&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Генерирует ошибку Lua, используя значение в верхней части стека в качестве объекта ошибки. Эта функция делает длинный прыжок и поэтому никогда не возвращает (см. &lt;a href=&quot;#luaL_error&quot;&gt; &lt;code&gt;luaL_error&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c0be169e33a9a31268a5328272fe2fa469b1c7ec" translate="yes" xml:space="preserve">
          <source>Gets information about a local variable of a given activation record or a given function.</source>
          <target state="translated">Получает информацию о локальной переменной данной записи активации или заданной функции.</target>
        </trans-unit>
        <trans-unit id="5cf3ef7371f5378d8e58a5b0757ef77be8111cff" translate="yes" xml:space="preserve">
          <source>Gets information about a specific function or function invocation.</source>
          <target state="translated">Получает информацию об определенной функции или вызове функции.</target>
        </trans-unit>
        <trans-unit id="5d07f6c25730366d5782ddf2124f63eacbe7a041" translate="yes" xml:space="preserve">
          <source>Gets information about the &lt;code&gt;n&lt;/code&gt;-th upvalue of the closure at index &lt;code&gt;funcindex&lt;/code&gt;. It pushes the upvalue's value onto the stack and returns its name. Returns &lt;code&gt;NULL&lt;/code&gt; (and pushes nothing) when the index &lt;code&gt;n&lt;/code&gt; is greater than the number of upvalues.</source>
          <target state="translated">Получает информацию о &lt;code&gt;n&lt;/code&gt; -м повышающем значении закрытия по индексу &lt;code&gt;funcindex&lt;/code&gt; . Он помещает значение upvalue в стек и возвращает его имя. Возвращает &lt;code&gt;NULL&lt;/code&gt; (и ничего не выталкивает), когда индекс &lt;code&gt;n&lt;/code&gt; больше, чем количество повышающих значений.</target>
        </trans-unit>
        <trans-unit id="62c6dfe4bd33a93e8e74cb65c4ff32424b3ecf7b" translate="yes" xml:space="preserve">
          <source>Gets information about the interpreter runtime stack.</source>
          <target state="translated">Получает информацию о стеке времени выполнения интерпретатора.</target>
        </trans-unit>
        <trans-unit id="0b201abab8551378dd82fcd0d47c8bebaab95fa2" translate="yes" xml:space="preserve">
          <source>Gets the real value of &lt;code&gt;table[index]&lt;/code&gt;, without invoking the &lt;code&gt;__index&lt;/code&gt; metamethod. &lt;code&gt;table&lt;/code&gt; must be a table; &lt;code&gt;index&lt;/code&gt; may be any value.</source>
          <target state="translated">Получает реальное значение &lt;code&gt;table[index]&lt;/code&gt; без вызова &lt;code&gt;__index&lt;/code&gt; . &lt;code&gt;table&lt;/code&gt; должен быть столом; &lt;code&gt;index&lt;/code&gt; может иметь любое значение.</target>
        </trans-unit>
        <trans-unit id="91020a88f59d9c8fbc1c662bdb6eda5896f6dbfe" translate="yes" xml:space="preserve">
          <source>Given a list where all elements are strings or numbers, returns the string &lt;code&gt;list[i]..sep..list[i+1] &amp;middot;&amp;middot;&amp;middot; sep..list[j]&lt;/code&gt;. The default value for &lt;code&gt;sep&lt;/code&gt; is the empty string, the default for &lt;code&gt;i&lt;/code&gt; is 1, and the default for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is greater than &lt;code&gt;j&lt;/code&gt;, returns the empty string.</source>
          <target state="translated">Для списка, в котором все элементы являются строками или числами, возвращает &lt;code&gt;list[i]..sep..list[i+1] &amp;middot;&amp;middot;&amp;middot; sep..list[j]&lt;/code&gt; строк [i] .. sep..list [i + 1] &amp;middot;&amp;middot;&amp;middot; sep..list [j] . Значение по умолчанию для &lt;code&gt;sep&lt;/code&gt; - пустая строка, значение по умолчанию для &lt;code&gt;i&lt;/code&gt; - 1, а значение по умолчанию для &lt;code&gt;j&lt;/code&gt; - &lt;code&gt;#list&lt;/code&gt; . Если &lt;code&gt;i&lt;/code&gt; больше &lt;code&gt;j&lt;/code&gt; , возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="b57745f04b18114e4271e54461167a450eab4e48" translate="yes" xml:space="preserve">
          <source>Grows the stack size to &lt;code&gt;top + sz&lt;/code&gt; elements, raising an error if the stack cannot grow to that size. &lt;code&gt;msg&lt;/code&gt; is an additional text to go into the error message (or &lt;code&gt;NULL&lt;/code&gt; for no additional text).</source>
          <target state="translated">Увеличивает размер стека до элементов &lt;code&gt;top + sz&lt;/code&gt; , вызывая ошибку, если стек не может вырасти до этого размера. &lt;code&gt;msg&lt;/code&gt; - это дополнительный текст для сообщения об ошибке (или &lt;code&gt;NULL&lt;/code&gt; ,если дополнительный текст не используется).</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">Вот несколько примеров:</target>
        </trans-unit>
        <trans-unit id="4b1c6bd65c741e8ff2d3bbd3ff2fc22c3d2a47ba" translate="yes" xml:space="preserve">
          <source>Here is a simple implementation for the allocator function. It is used in the auxiliary library by &lt;a href=&quot;#luaL_newstate&quot;&gt;&lt;code&gt;luaL_newstate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Вот простая реализация функции распределителя. Он используется во вспомогательной библиотеке &lt;a href=&quot;#luaL_newstate&quot;&gt; &lt;code&gt;luaL_newstate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1dab51e6891f4e284fffd166a6bd35c869f4cc2" translate="yes" xml:space="preserve">
          <source>Here is the complete syntax of Lua in extended BNF. As usual in extended BNF, {A} means 0 or more As, and [A] means an optional A. (For operator precedences, see &lt;a href=&quot;#3.4.8&quot;&gt;&amp;sect;3.4.8&lt;/a&gt;; for a description of the terminals Name, Numeral, and LiteralString, see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;.)</source>
          <target state="translated">Вот полный синтаксис Lua в расширенном BNF. Как обычно в расширенном BNF, {A} означает 0 или более As, а [A] означает необязательный A. (Приоритеты операторов см. В &lt;a href=&quot;#3.4.8&quot;&gt;&amp;sect;3.4.8&lt;/a&gt; ; описание терминалов Name, Numeral и LiteralString см. В &lt;a href=&quot;#3.1&quot;&gt;&amp;sect; 3.1&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="ded763c4029757dddf3f7027714a4cf075c2d5bd" translate="yes" xml:space="preserve">
          <source>Here it is in C:</source>
          <target state="translated">Вот он в Си:</target>
        </trans-unit>
        <trans-unit id="3f274b8694db69b484f40f23944a016b4fffa6f3" translate="yes" xml:space="preserve">
          <source>Here we list all functions and types from the C API in alphabetical order. Each function has an indicator like this:</source>
          <target state="translated">Здесь перечислены все функции и типы из C API в алфавитном порядке.У каждой функции есть такой индикатор:</target>
        </trans-unit>
        <trans-unit id="759a7b44d9cbdbdff0c6256556529057e71e4bfc" translate="yes" xml:space="preserve">
          <source>Here we list all functions and types from the auxiliary library in alphabetical order.</source>
          <target state="translated">Здесь в алфавитном порядке перечислены все функции и типы из вспомогательной библиотеки.</target>
        </trans-unit>
        <trans-unit id="5ef4637da05a815223e812a542adefe907813773" translate="yes" xml:space="preserve">
          <source>Here we list the incompatibilities that you may find when moving a program from Lua 5.2 to Lua 5.3. You can avoid some incompatibilities by compiling Lua with appropriate options (see file &lt;code&gt;luaconf.h&lt;/code&gt;). However, all these compatibility options will be removed in the future.</source>
          <target state="translated">Здесь мы перечисляем несовместимости, которые могут возникнуть при переносе программы с Lua 5.2 на Lua 5.3. Вы можете избежать некоторых несовместимостей, скомпилировав Lua с соответствующими параметрами (см. Файл &lt;code&gt;luaconf.h&lt;/code&gt; ). Однако в будущем все эти параметры совместимости будут удалены.</target>
        </trans-unit>
        <trans-unit id="6e8633ec37fd0a545b50c273991305c0a0ccd6af" translate="yes" xml:space="preserve">
          <source>Hook functions can yield under the following conditions: Only count and line events can yield; to yield, a hook function must finish its execution calling &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;nresults&lt;/code&gt; equal to zero (that is, with no values).</source>
          <target state="translated">Функции перехвата могут давать результат при следующих условиях: Только события count и line могут давать результат; чтобы уступить, функция-перехватчик должна завершить свое выполнение, вызвав &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; с &lt;code&gt;nresults&lt;/code&gt; , равными нулю (то есть без значений).</target>
        </trans-unit>
        <trans-unit id="57503e65706288b8ec579f8045e20e5c7fc42803" translate="yes" xml:space="preserve">
          <source>Hook functions cannot have continuations, that is, they cannot call &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; with a non-null &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Функции- &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; не могут иметь продолжения, то есть они не могут вызывать lua_yieldk , &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; с ненулевым &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c8d828197edf926fd895a22fd233a53985fe4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;chunk&lt;/code&gt; is a string, the chunk is this string. If &lt;code&gt;chunk&lt;/code&gt; is a function, &lt;code&gt;load&lt;/code&gt; calls it repeatedly to get the chunk pieces. Each call to &lt;code&gt;chunk&lt;/code&gt; must return a string that concatenates with previous results. A return of an empty string, &lt;b&gt;nil&lt;/b&gt;, or no value signals the end of the chunk.</source>
          <target state="translated">Если &lt;code&gt;chunk&lt;/code&gt; - это строка, фрагмент - это эта строка. Если &lt;code&gt;chunk&lt;/code&gt; - это функция, &lt;code&gt;load&lt;/code&gt; вызывает ее несколько раз, чтобы получить фрагменты фрагмента. Каждый вызов &lt;code&gt;chunk&lt;/code&gt; должен возвращать строку, которая объединяется с предыдущими результатами. Возврат пустой строки, &lt;b&gt;nil&lt;/b&gt; или отсутствия значения сигнализирует об окончании фрагмента.</target>
        </trans-unit>
        <trans-unit id="56626a6306a0218f5ebc2bc99df5b09f8b5d3616" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;def&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the function uses &lt;code&gt;def&lt;/code&gt; as a default value when there is no argument &lt;code&gt;arg&lt;/code&gt; or when this argument is &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Если &lt;code&gt;def&lt;/code&gt; не равен &lt;code&gt;NULL&lt;/code&gt; , функция использует &lt;code&gt;def&lt;/code&gt; как значение по умолчанию, когда нет аргумента &lt;code&gt;arg&lt;/code&gt; или когда этот аргумент равен &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d7b55b3722d0d97704dcddb34cbf9bcdade76ec4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is not &quot;&lt;code&gt;*t&lt;/code&gt;&quot;, then &lt;code&gt;date&lt;/code&gt; returns the date as a string, formatted according to the same rules as the ISO C function &lt;code&gt;strftime&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;format&lt;/code&gt; не &amp;laquo; &lt;code&gt;*t&lt;/code&gt; &amp;raquo;, то &lt;code&gt;date&lt;/code&gt; возвращает дату в виде строки, отформатированной в соответствии с теми же правилами, что и функции ISO C &lt;code&gt;strftime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="506e40ff0a74eaa2a16ebe55cc542c656b7d6688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; starts with '&lt;code&gt;!&lt;/code&gt;', then the date is formatted in Coordinated Universal Time. After this optional character, if &lt;code&gt;format&lt;/code&gt; is the string &quot;&lt;code&gt;*t&lt;/code&gt;&quot;, then &lt;code&gt;date&lt;/code&gt; returns a table with the following fields: &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; (0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61), &lt;code&gt;wday&lt;/code&gt; (weekday, 1&amp;ndash;7, Sunday is 1), &lt;code&gt;yday&lt;/code&gt; (day of the year, 1&amp;ndash;366), and &lt;code&gt;isdst&lt;/code&gt; (daylight saving flag, a boolean). This last field may be absent if the information is not available.</source>
          <target state="translated">Если &lt;code&gt;format&lt;/code&gt; начинается с ' &lt;code&gt;!&lt;/code&gt; ', то дата форматируется по всемирному координированному времени. Если после этого необязательного символа &lt;code&gt;format&lt;/code&gt; является строка &amp;laquo; &lt;code&gt;*t&lt;/code&gt; &amp;raquo;, то &lt;code&gt;date&lt;/code&gt; возвращает таблицу со следующими полями: &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; ( 0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61), &lt;code&gt;wday&lt;/code&gt; (день недели, 1&amp;ndash;7, воскресенье - 1), &lt;code&gt;yday&lt;/code&gt; (день года, 1&amp;ndash;366) и &lt;code&gt;isdst&lt;/code&gt; (флаг перехода на летнее время, логическое значение). Это последнее поле может отсутствовать, если информация недоступна.</target>
        </trans-unit>
        <trans-unit id="8190672d8b6e5a23cf38bf7fd250cf0fc81f9304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;funcname&lt;/code&gt; is &quot;&lt;code&gt;*&lt;/code&gt;&quot;, then it only links with the library, making the symbols exported by the library available to other dynamically linked libraries. Otherwise, it looks for a function &lt;code&gt;funcname&lt;/code&gt; inside the library and returns this function as a C function. So, &lt;code&gt;funcname&lt;/code&gt; must follow the &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt; prototype (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Если &lt;code&gt;funcname&lt;/code&gt; - &amp;laquo; &lt;code&gt;*&lt;/code&gt; &amp;raquo;, то он связывается только с библиотекой, делая символы, экспортируемые библиотекой, доступными для других динамически подключаемых библиотек. В противном случае он ищет функцию &lt;code&gt;funcname&lt;/code&gt; внутри библиотеки и возвращает эту функцию как функцию C. Итак, &lt;code&gt;funcname&lt;/code&gt; должно соответствовать прототипу &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; (см. &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3843661cd0d22957a2df1b74e3cc0eae40b47007" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;glb&lt;/code&gt; is true, also stores the module into global &lt;code&gt;modname&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;glb&lt;/code&gt; истинно, также сохраняет модуль в глобальном имени &lt;code&gt;modname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dfd113b7f3930f57215faca9229d63e5a7444d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index&lt;/code&gt; is a number, returns all arguments after argument number &lt;code&gt;index&lt;/code&gt;; a negative number indexes from the end (-1 is the last argument). Otherwise, &lt;code&gt;index&lt;/code&gt; must be the string &lt;code&gt;&quot;#&quot;&lt;/code&gt;, and &lt;code&gt;select&lt;/code&gt; returns the total number of extra arguments it received.</source>
          <target state="translated">Если &lt;code&gt;index&lt;/code&gt; является числом, возвращает все аргументы после аргумента number &lt;code&gt;index&lt;/code&gt; ; отрицательное число индексирует с конца (-1 - последний аргумент). В противном случае &lt;code&gt;index&lt;/code&gt; должен быть строкой &lt;code&gt;&quot;#&quot;&lt;/code&gt; , а &lt;code&gt;select&lt;/code&gt; возвращает общее количество полученных дополнительных аргументов.</target>
        </trans-unit>
        <trans-unit id="9a792f6a10658dfe428995a06ea53ae4d673e447" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isnum&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, its referent is assigned a boolean value that indicates whether the operation succeeded.</source>
          <target state="translated">Если &lt;code&gt;isnum&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , его референту присваивается логическое значение, указывающее, успешно ли выполнена операция.</target>
        </trans-unit>
        <trans-unit id="e15877b81cb8f4644f0e73a139f0b786972779bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, fills the position &lt;code&gt;*l&lt;/code&gt; with the result's length. If the result is &lt;code&gt;NULL&lt;/code&gt; (only possible when returning &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d == NULL&lt;/code&gt;), its length is considered zero.</source>
          <target state="translated">Если &lt;code&gt;l&lt;/code&gt; не &lt;code&gt;NULL&lt;/code&gt; , заполняет позицию &lt;code&gt;*l&lt;/code&gt; длиной результата. Если результатом является &lt;code&gt;NULL&lt;/code&gt; (возможно только при возврате &lt;code&gt;d&lt;/code&gt; и &lt;code&gt;d == NULL&lt;/code&gt; ), его длина считается нулевой.</target>
        </trans-unit>
        <trans-unit id="73f0cbaf64ffcc698ebe789e3bf72282c151d928" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;locale&lt;/code&gt; is the empty string, the current locale is set to an implementation-defined native locale. If &lt;code&gt;locale&lt;/code&gt; is the string &quot;&lt;code&gt;C&lt;/code&gt;&quot;, the current locale is set to the standard C locale.</source>
          <target state="translated">Если &lt;code&gt;locale&lt;/code&gt; является пустой строкой, текущий языковой стандарт установлен на собственный языковой стандарт, определенный реализацией. Если &lt;code&gt;locale&lt;/code&gt; представляет собой строку &amp;laquo; &lt;code&gt;C&lt;/code&gt; &amp;raquo;, текущий языковой стандарт установлен на стандартный языковой стандарт C.</target>
        </trans-unit>
        <trans-unit id="acb78160a1f280ce628830b7a5b6f03f442478bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;message&lt;/code&gt; is present but is neither a string nor &lt;b&gt;nil&lt;/b&gt;, this function returns &lt;code&gt;message&lt;/code&gt; without further processing. Otherwise, it returns a string with a traceback of the call stack. The optional &lt;code&gt;message&lt;/code&gt; string is appended at the beginning of the traceback. An optional &lt;code&gt;level&lt;/code&gt; number tells at which level to start the traceback (default is 1, the function calling &lt;code&gt;traceback&lt;/code&gt;).</source>
          <target state="translated">Если &lt;code&gt;message&lt;/code&gt; присутствует, но не является ни строкой, ни &lt;b&gt;нулем&lt;/b&gt; , эта функция возвращает &lt;code&gt;message&lt;/code&gt; без дальнейшей обработки. В противном случае он возвращает строку с обратной трассировкой стека вызовов. Необязательная строка &lt;code&gt;message&lt;/code&gt; добавляется в начале трассировки. Необязательный номер &lt;code&gt;level&lt;/code&gt; указывает, с какого уровня начать трассировку (по умолчанию 1, функция, вызывающая &lt;code&gt;traceback&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="842cd5b591dfca5b2f8676469b17faefa0a0959f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;modname&lt;/code&gt; is not already present in &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt;, calls function &lt;code&gt;openf&lt;/code&gt; with string &lt;code&gt;modname&lt;/code&gt; as an argument and sets the call result in &lt;code&gt;package.loaded[modname]&lt;/code&gt;, as if that function has been called through &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если имя &lt;code&gt;modname&lt;/code&gt; еще не присутствует в &lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; &lt;/a&gt; , вызывает функцию &lt;code&gt;openf&lt;/code&gt; со строкой имя &lt;code&gt;modname&lt;/code&gt; в качестве аргумента и устанавливает результат вызова в &lt;code&gt;package.loaded[modname]&lt;/code&gt; , как если бы эта функция была вызвана через &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c31adda24a7d148cbbeb4abd1c9efc9a5e0f6cc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msgh&lt;/code&gt; is 0, then the error object returned on the stack is exactly the original error object. Otherwise, &lt;code&gt;msgh&lt;/code&gt; is the stack index of a &lt;em&gt;message handler&lt;/em&gt;. (This index cannot be a pseudo-index.) In case of runtime errors, this function will be called with the error object and its return value will be the object returned on the stack by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если &lt;code&gt;msgh&lt;/code&gt; равно 0, то объект ошибки, возвращаемый в стеке, является в точности исходным объектом ошибки. В противном случае &lt;code&gt;msgh&lt;/code&gt; - это индекс стека &lt;em&gt;обработчика сообщений&lt;/em&gt; . (Этот индекс не может быть псевдо-индексом.) В случае ошибок времени выполнения эта функция будет вызываться с объектом ошибки, и ее возвращаемое значение будет объектом, возвращаемым в стеке &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1820013984578d01f9005b716812fa4d2f636236" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; does not have a metatable, returns &lt;b&gt;nil&lt;/b&gt;. Otherwise, if the object's metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, returns the associated value. Otherwise, returns the metatable of the given object.</source>
          <target state="translated">Если &lt;code&gt;object&lt;/code&gt; не имеет метатаблицы, возвращает &lt;b&gt;ноль&lt;/b&gt; . В противном случае, если метатаблица объекта имеет поле &lt;code&gt;__metatable&lt;/code&gt; , возвращает связанное значение. В противном случае возвращает метатаблицу данного объекта.</target>
        </trans-unit>
        <trans-unit id="8540353902febf7d816e3357366d699709e0ebfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ref&lt;/code&gt; is &lt;a href=&quot;#pdf-LUA_NOREF&quot;&gt;&lt;code&gt;LUA_NOREF&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-LUA_REFNIL&quot;&gt;&lt;code&gt;LUA_REFNIL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_unref&quot;&gt;&lt;code&gt;luaL_unref&lt;/code&gt;&lt;/a&gt; does nothing.</source>
          <target state="translated">Если &lt;code&gt;ref&lt;/code&gt; - &lt;a href=&quot;#pdf-LUA_NOREF&quot;&gt; &lt;code&gt;LUA_NOREF&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#pdf-LUA_REFNIL&quot;&gt; &lt;code&gt;LUA_REFNIL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_unref&quot;&gt; &lt;code&gt;luaL_unref&lt;/code&gt; &lt;/a&gt; ничего не делает.</target>
        </trans-unit>
        <trans-unit id="0ef9686e0e91a6b272fed24ea40a04743ba642b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order.</source>
          <target state="translated">Если &lt;code&gt;repl&lt;/code&gt; является функцией, то эта функция вызывается каждый раз, когда происходит совпадение, со всеми захваченными подстроками, переданными в качестве аргументов по порядку.</target>
        </trans-unit>
        <trans-unit id="acbcb36c3a66c6e9e703f8cba5f8b02711833af9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a string, then its value is used for replacement. The character &lt;code&gt;%&lt;/code&gt; works as an escape character: any sequence in &lt;code&gt;repl&lt;/code&gt; of the form &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt;, with &lt;em&gt;d&lt;/em&gt; between 1 and 9, stands for the value of the &lt;em&gt;d&lt;/em&gt;-th captured substring. The sequence &lt;code&gt;%0&lt;/code&gt; stands for the whole match. The sequence &lt;code&gt;%%&lt;/code&gt; stands for a single &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;repl&lt;/code&gt; - строка, то ее значение используется для замены. Символ &lt;code&gt;%&lt;/code&gt; работает как escape-символ: любая последовательность в &lt;code&gt;repl&lt;/code&gt; в форме &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt; , где &lt;em&gt;d&lt;/em&gt; находится в диапазоне от 1 до 9, обозначает значение &lt;em&gt;d&lt;/em&gt; -й захваченной подстроки. Последовательность &lt;code&gt;%0&lt;/code&gt; обозначает все совпадение. Последовательность &lt;code&gt;%%&lt;/code&gt; обозначает один &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3b705ba3b278873bc97aa05e3303e0da7b4c996" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a table, then the table is queried for every match, using the first capture as the key.</source>
          <target state="translated">Если &lt;code&gt;repl&lt;/code&gt; - это таблица, то таблица запрашивается для каждого совпадения, используя первый захват в качестве ключа.</target>
        </trans-unit>
        <trans-unit id="904a3adc32b5b8e5036d0de4893c822c32415c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, pushes &lt;b&gt;nil&lt;/b&gt; and returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;s&lt;/code&gt; равно &lt;code&gt;NULL&lt;/code&gt; , помещает &lt;b&gt;nil&lt;/b&gt; и возвращает &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0fc40539b156bda0a027e224a170becb69976c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;strip&lt;/code&gt; is true, the binary representation may not include all debug information about the function, to save space.</source>
          <target state="translated">Если &lt;code&gt;strip&lt;/code&gt; имеет значение true, двоичное представление может не включать всю отладочную информацию о функции для экономии места.</target>
        </trans-unit>
        <trans-unit id="6d87b247b5a3a2f34515ba0454eae0564f8d8461" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; has a metamethod &lt;code&gt;__pairs&lt;/code&gt;, calls it with &lt;code&gt;t&lt;/code&gt; as argument and returns the first three results from the call.</source>
          <target state="translated">Если &lt;code&gt;t&lt;/code&gt; имеет &lt;code&gt;__pairs&lt;/code&gt; , вызывает его с аргументом &lt;code&gt;t&lt;/code&gt; и возвращает первые три результата вызова.</target>
        </trans-unit>
        <trans-unit id="aa2adbca5a2a771576b0ebf6701fe853d554fc4c" translate="yes" xml:space="preserve">
          <source>If a weak table is among the resurrected objects in a collection cycle, it may not be properly cleared until the next cycle.</source>
          <target state="translated">Если среди воскресших объектов в цикле сбора находится слабая таблица,то она может быть очищена надлежащим образом только в следующем цикле.</target>
        </trans-unit>
        <trans-unit id="976c050d10a007d84f504f71e351c1274cb11c09" translate="yes" xml:space="preserve">
          <source>If an error happens outside any protected environment, Lua calls a &lt;em&gt;panic function&lt;/em&gt; (see &lt;a href=&quot;#lua_atpanic&quot;&gt;&lt;code&gt;lua_atpanic&lt;/code&gt;&lt;/a&gt;) and then calls &lt;code&gt;abort&lt;/code&gt;, thus exiting the host application. Your panic function can avoid this exit by never returning (e.g., doing a long jump to your own recovery point outside Lua).</source>
          <target state="translated">Если ошибка происходит вне любой защищенной среды, Lua вызывает функцию &lt;em&gt;паники&lt;/em&gt; (см. &lt;a href=&quot;#lua_atpanic&quot;&gt; &lt;code&gt;lua_atpanic&lt;/code&gt; &lt;/a&gt; ), а затем вызывает &lt;code&gt;abort&lt;/code&gt; , таким образом завершая работу хост-приложения. Ваша функция паники может избежать этого выхода, никогда не возвращаясь (например, делая длинный прыжок к вашей собственной точке восстановления вне Lua).</target>
        </trans-unit>
        <trans-unit id="6a7b831a74ddf1c4c96bf3f5226d336731f2c355" translate="yes" xml:space="preserve">
          <source>If present, an initial assignment has the same semantics of a multiple assignment (see &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;). Otherwise, all variables are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Если присутствует, начальное присвоение имеет ту же семантику множественного присвоения (см. &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt; ). В противном случае все переменные инициализируются &lt;b&gt;нулем&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d10ce6dce1cf5ed21ab267244f3f1b4e5f1c53a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;time&lt;/code&gt; argument is present, this is the time to be formatted (see the &lt;a href=&quot;#pdf-os.time&quot;&gt;&lt;code&gt;os.time&lt;/code&gt;&lt;/a&gt; function for a description of this value). Otherwise, &lt;code&gt;date&lt;/code&gt; formats the current time.</source>
          <target state="translated">Если &lt;code&gt;time&lt;/code&gt; аргумент присутствует, это время , чтобы быть отформатированы (см &lt;a href=&quot;#pdf-os.time&quot;&gt; &lt;code&gt;os.time&lt;/code&gt; &lt;/a&gt; функции для описания этого значения). В противном случае &lt;code&gt;date&lt;/code&gt; форматирует текущее время.</target>
        </trans-unit>
        <trans-unit id="445b1cd7605edb6c9a09a49501ea3688f7a25284" translate="yes" xml:space="preserve">
          <source>If the coroutine runs without any errors, &lt;code&gt;resume&lt;/code&gt; returns &lt;b&gt;true&lt;/b&gt; plus any values passed to &lt;code&gt;yield&lt;/code&gt; (when the coroutine yields) or any values returned by the body function (when the coroutine terminates). If there is any error, &lt;code&gt;resume&lt;/code&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error message.</source>
          <target state="translated">Если сопрограмма работает без ошибок, &lt;code&gt;resume&lt;/code&gt; возвращает &lt;b&gt;истину&lt;/b&gt; плюс любые значения, переданные в &lt;code&gt;yield&lt;/code&gt; (когда сопрограмма дает результат), или любые значения, возвращаемые функцией тела (когда сопрограмма завершается). Если есть какая-либо ошибка, &lt;code&gt;resume&lt;/code&gt; возвращает &lt;b&gt;false&lt;/b&gt; плюс сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="d55f1311c7ac9c86cbdbbe5af34159b56481c975" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is a number, returns this number. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">Если аргумент функции &lt;code&gt;arg&lt;/code&gt; является числом, возвращает это число. Если этот аргумент отсутствует или равен &lt;b&gt;нулю&lt;/b&gt; , возвращает &lt;code&gt;d&lt;/code&gt; . В противном случае выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="1d6a415374d2508756a64e53d2de95963256a6b5" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is a string, returns this string. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">Если аргумент функции &lt;code&gt;arg&lt;/code&gt; является строкой, возвращает эту строку. Если этот аргумент отсутствует или равен &lt;b&gt;нулю&lt;/b&gt; , возвращает &lt;code&gt;d&lt;/code&gt; . В противном случае выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="6e17c7a9a9f53d843ebe48aadc33c874ae824510" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or convertible to an integer), returns this integer. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">Если аргумент функции &lt;code&gt;arg&lt;/code&gt; является целым числом (или может быть преобразовано в целое число), возвращает это целое число. Если этот аргумент отсутствует или равен &lt;b&gt;нулю&lt;/b&gt; , возвращает &lt;code&gt;d&lt;/code&gt; . В противном случае выдает ошибку.</target>
        </trans-unit>
        <trans-unit id="f1e13f8872ac6f0a738c6612fcccd3954091bb67" translate="yes" xml:space="preserve">
          <source>If the global variable &lt;a id=&quot;pdf-_PROMPT&quot;&gt;&lt;code&gt;_PROMPT&lt;/code&gt;&lt;/a&gt; contains a string, then its value is used as the prompt. Similarly, if the global variable &lt;a id=&quot;pdf-_PROMPT2&quot;&gt;&lt;code&gt;_PROMPT2&lt;/code&gt;&lt;/a&gt; contains a string, its value is used as the secondary prompt (issued during incomplete statements).</source>
          <target state="translated">Если глобальная переменная &lt;a id=&quot;pdf-_PROMPT&quot;&gt; &lt;code&gt;_PROMPT&lt;/code&gt; &lt;/a&gt; содержит строку, то ее значение используется в качестве подсказки. Точно так же, если глобальная переменная &lt;a id=&quot;pdf-_PROMPT2&quot;&gt; &lt;code&gt;_PROMPT2&lt;/code&gt; &lt;/a&gt; содержит строку, ее значение используется в качестве вторичного приглашения (выдается во время неполных операторов).</target>
        </trans-unit>
        <trans-unit id="69dd50d5154f10c839f6adf50538404208ab3819" translate="yes" xml:space="preserve">
          <source>If the last field in the list has the form &lt;code&gt;exp&lt;/code&gt; and the expression is a function call or a vararg expression, then all values returned by this expression enter the list consecutively (see &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;).</source>
          <target state="translated">Если последнее поле в списке имеет форму &lt;code&gt;exp&lt;/code&gt; , а выражение является вызовом функции или выражением vararg, то все значения, возвращаемые этим выражением, входят в список последовательно (см. &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c2c41a18b7f1f35462130fbee68e6deb46c899ae" translate="yes" xml:space="preserve">
          <source>If the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;tostring&lt;/code&gt; calls the corresponding value with &lt;code&gt;v&lt;/code&gt; as argument, and uses the result of the call as its result.</source>
          <target state="translated">Если метатаблица &lt;code&gt;v&lt;/code&gt; имеет поле &lt;code&gt;__tostring&lt;/code&gt; , то &lt;code&gt;tostring&lt;/code&gt; вызывает соответствующее значение с &lt;code&gt;v&lt;/code&gt; в качестве аргумента и использует результат вызова в качестве своего результата.</target>
        </trans-unit>
        <trans-unit id="03e2a2337d10f7a7f932c47ab9c9e3292e20a274" translate="yes" xml:space="preserve">
          <source>If the object at index &lt;code&gt;obj&lt;/code&gt; has a metatable and this metatable has a field &lt;code&gt;e&lt;/code&gt;, this function calls this field passing the object as its only argument. In this case this function returns true and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns false (without pushing any value on the stack).</source>
          <target state="translated">Если объект с индексом &lt;code&gt;obj&lt;/code&gt; имеет метатаблицу, а эта метатаблица имеет поле &lt;code&gt;e&lt;/code&gt; , эта функция вызывает это поле, передавая объект в качестве единственного аргумента. В этом случае эта функция возвращает истину и помещает в стек значение, возвращенное вызовом. Если нет метатаблицы или метаметода, эта функция возвращает false (без помещения какого-либо значения в стек).</target>
        </trans-unit>
        <trans-unit id="5290383f51a42a73a3f52ae1f2cee8c56a74c3fd" translate="yes" xml:space="preserve">
          <source>If the object at the top of the stack is &lt;b&gt;nil&lt;/b&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; returns the constant &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt;&lt;code&gt;LUA_REFNIL&lt;/code&gt;&lt;/a&gt;. The constant &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt;&lt;code&gt;LUA_NOREF&lt;/code&gt;&lt;/a&gt; is guaranteed to be different from any reference returned by &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если объект наверху стека равен &lt;b&gt;нулю&lt;/b&gt; , &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; возвращает константу &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt; &lt;code&gt;LUA_REFNIL&lt;/code&gt; &lt;/a&gt; . Константа &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt; &lt;code&gt;LUA_NOREF&lt;/code&gt; &lt;/a&gt; гарантированно отличается от любой ссылки, возвращаемой &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="acec67c576442c0c5a9f70f70aebd00845c9de45" translate="yes" xml:space="preserve">
          <source>If the optional second argument &lt;code&gt;close&lt;/code&gt; is true, closes the Lua state before exiting.</source>
          <target state="translated">Если необязательный второй аргумент &lt;code&gt;close&lt;/code&gt; равен true, закрывает состояние Lua перед выходом.</target>
        </trans-unit>
        <trans-unit id="3b0396e6bb027f8d7ab0995f60b457d88ddf9d43" translate="yes" xml:space="preserve">
          <source>If the pattern has captures, then in a successful match the captured values are also returned, after the two indices.</source>
          <target state="translated">Если модель имеет захваты,то при успешном совпадении захваченные значения также возвращаются после двух индексов.</target>
        </trans-unit>
        <trans-unit id="55dfb22871228c3e2bce9a6e070cde79a0f26198" translate="yes" xml:space="preserve">
          <source>If the registry already has the key &lt;code&gt;tname&lt;/code&gt;, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds to this new table the pair &lt;code&gt;__name = tname&lt;/code&gt;, adds to the registry the pair &lt;code&gt;[tname] = new table&lt;/code&gt;, and returns 1. (The entry &lt;code&gt;__name&lt;/code&gt; is used by some error-reporting functions.)</source>
          <target state="translated">Если в реестре уже есть ключ &lt;code&gt;tname&lt;/code&gt; , возвращает 0. В противном случае создает новую таблицу, которая будет использоваться в качестве метатаблицы для пользовательских данных, добавляет в эту новую таблицу пару &lt;code&gt;__name = tname&lt;/code&gt; , добавляет в реестр пару &lt;code&gt;[tname] = new table&lt;/code&gt; и возвращает 1. (Запись &lt;code&gt;__name&lt;/code&gt; используется некоторыми функциями сообщения об ошибках.)</target>
        </trans-unit>
        <trans-unit id="afde979ca5fc178b1fdd97cd1a0eb2a3d73cbc9c" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, its first upvalue is set to the value of the global environment stored at index &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; in the registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). When loading main chunks, this upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Если результирующая функция имеет повышающие значения, ее первое повышающее значение устанавливается на значение глобальной среды, хранящейся в &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; индексом LUA_RIDX_GLOBALS (см. &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; ). При загрузке основных фрагментов это повышающее значение будет переменной &lt;code&gt;_ENV&lt;/code&gt; (см. &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ). Остальные повышающие значения инициализируются &lt;b&gt;нулем&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="275e9e5485299a94935ea18cd6064e91a7392a15" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, the first upvalue is set to the value of &lt;code&gt;env&lt;/code&gt;, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;. (When you load a main chunk, the resulting function will always have exactly one upvalue, the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). However, when you load a binary chunk created from a function (see &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt;), the resulting function can have an arbitrary number of upvalues.) All upvalues are fresh, that is, they are not shared with any other function.</source>
          <target state="translated">Если результирующая функция имеет повышающие значения, первое повышающее значение устанавливается в значение &lt;code&gt;env&lt;/code&gt; , если этот параметр задан, или в значение глобальной среды. Остальные повышающие значения инициализируются &lt;b&gt;нулем&lt;/b&gt; . (Когда вы загружаете основной блок, результирующая функция всегда будет иметь ровно одно повышающее значение, переменную &lt;code&gt;_ENV&lt;/code&gt; (см. &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ). Однако, когда вы загружаете двоичный блок, созданный из функции (см. &lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt; ), результирующая функция может имеют произвольное количество повышающих значений.) Все повышающие значения являются новыми, то есть они не используются ни одной другой функцией.</target>
        </trans-unit>
        <trans-unit id="2440107420c56013ca178ce5e9d33aaab09429e6" translate="yes" xml:space="preserve">
          <source>If the third expression (the step) is absent, then a step of 1 is used.</source>
          <target state="translated">Если третье выражение (шаг)отсутствует,то используется шаг 1.</target>
        </trans-unit>
        <trans-unit id="876e4bd473070df65d9eb13c67cd61272830f8dd" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;x&lt;/code&gt; is convertible to an integer, returns that integer. Otherwise, returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Если значение &lt;code&gt;x&lt;/code&gt; можно преобразовать в целое число, возвращает это целое число. В противном случае возвращает &lt;b&gt;ноль&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="94b7f8b2fd53356736681842c541a85531d3f0c6" translate="yes" xml:space="preserve">
          <source>If the value at the given index has a metatable, the function pushes that metatable onto the stack and returns 1. Otherwise, the function returns 0 and pushes nothing on the stack.</source>
          <target state="translated">Если значение в данном индексе имеет метатрица,функция выталкивает метатрица на стек и возвращает 1.В противном случае функция возвращает 0 и ничего не выталкивает на стек.</target>
        </trans-unit>
        <trans-unit id="9441049c218d493b700b38a8bccd81b0ab58775b" translate="yes" xml:space="preserve">
          <source>If the value at the given index is a full userdata, returns its block address. If the value is a light userdata, returns its pointer. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">Если значение по данному индексу является полными пользовательскими данными, возвращает адрес его блока. Если значение - легкие пользовательские данные, возвращает указатель. В противном случае возвращает &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4632120bcb257e680797b7d6b495d6ae5165f498" translate="yes" xml:space="preserve">
          <source>If the value has a metatable with a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;luaL_tolstring&lt;/code&gt; calls the corresponding metamethod with the value as argument, and uses the result of the call as its result.</source>
          <target state="translated">Если значение имеет метатаблицу с полем &lt;code&gt;__tostring&lt;/code&gt; , то &lt;code&gt;luaL_tolstring&lt;/code&gt; вызывает соответствующий метаметод со значением в качестве аргумента и использует результат вызова в качестве своего результата.</target>
        </trans-unit>
        <trans-unit id="d98fc2205300b7d347d732dbb4a9c377f9f7a2f3" translate="yes" xml:space="preserve">
          <source>If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;nil&lt;/b&gt;, then there is no replacement (that is, the original match is kept in the string).</source>
          <target state="translated">Если значение, возвращаемое запросом таблицы или вызовом функции, является строкой или числом, то оно используется как строка замены; в противном случае, если оно равно &lt;b&gt;false&lt;/b&gt; или &lt;b&gt;nil&lt;/b&gt; , то замены нет (то есть исходное совпадение сохраняется в строке).</target>
        </trans-unit>
        <trans-unit id="ed5b55c4ebb32433c98e6d7ba29a004a9265213b" translate="yes" xml:space="preserve">
          <source>If there are no syntactic errors, returns the compiled chunk as a function; otherwise, returns &lt;b&gt;nil&lt;/b&gt; plus the error message.</source>
          <target state="translated">Если нет синтаксических ошибок, возвращает скомпилированный фрагмент как функцию; в противном случае возвращает &lt;b&gt;ноль&lt;/b&gt; плюс сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="94d76ea95ae9d04310650a4926fa6e03a91eead5" translate="yes" xml:space="preserve">
          <source>If there is any error loading or running the module, or if it cannot find any loader for the module, then &lt;code&gt;require&lt;/code&gt; raises an error.</source>
          <target state="translated">Если возникает какая-либо ошибка при загрузке или запуске модуля, или если он не может найти загрузчик для модуля, тогда &lt;code&gt;require&lt;/code&gt; вызывает ошибку.</target>
        </trans-unit>
        <trans-unit id="0a6dbd64b84e48ca7300b890ff312675543ee0f6" translate="yes" xml:space="preserve">
          <source>If there is no script in the call, the interpreter name goes to index 0, followed by the other arguments. For instance, the call</source>
          <target state="translated">Если в вызове нет скрипта,то имя интерпретатора переходит в индекс 0,за которым следуют остальные аргументы.Например,вызов</target>
        </trans-unit>
        <trans-unit id="2f77907008466a9df684a2c79024f9604e714a0c" translate="yes" xml:space="preserve">
          <source>If this option is given together with option '&lt;code&gt;f&lt;/code&gt;', its table is pushed after the function.</source>
          <target state="translated">Если этот параметр указан вместе с параметром &amp;laquo; &lt;code&gt;f&lt;/code&gt; &amp;raquo;, его таблица помещается после функции.</target>
        </trans-unit>
        <trans-unit id="eda48319758ff6bba8bcf8cb507f6d311265837c" translate="yes" xml:space="preserve">
          <source>If you know beforehand the total size of the resulting string, you can use the buffer like this:</source>
          <target state="translated">Если вы заранее знаете общий размер результирующей строки,вы можете использовать буфер вот так:</target>
        </trans-unit>
        <trans-unit id="0e57af394dbc6d5a626668daa30c3f8e2018059e" translate="yes" xml:space="preserve">
          <source>If you set the step multiplier to a very large number (larger than 10% of the maximum number of bytes that the program may use), the collector behaves like a stop-the-world collector. If you then set the pause to 200, the collector behaves as in old Lua versions, doing a complete collection every time Lua doubles its memory usage.</source>
          <target state="translated">Если задать множитель шага в очень большое число (более 10% от максимального количества байтов,которое может использовать программа),то коллектор ведет себя как стоп-мировой коллектор.Если затем установить паузу в 200,коллектор ведет себя как в старых версиях Lua,делая полную коллекцию каждый раз,когда Lua удваивает использование памяти.</target>
        </trans-unit>
        <trans-unit id="29af696fcc1cdd39d14ec551ccbd633c6f06b895" translate="yes" xml:space="preserve">
          <source>If, after the translation of negative indices, &lt;code&gt;i&lt;/code&gt; is less than 1, it is corrected to 1. If &lt;code&gt;j&lt;/code&gt; is greater than the string length, it is corrected to that length. If, after these corrections, &lt;code&gt;i&lt;/code&gt; is greater than &lt;code&gt;j&lt;/code&gt;, the function returns the empty string.</source>
          <target state="translated">Если после преобразования отрицательных индексов &lt;code&gt;i&lt;/code&gt; меньше 1, оно исправляется до 1. Если &lt;code&gt;j&lt;/code&gt; больше длины строки, оно исправляется до этой длины. Если после этих исправлений &lt;code&gt;i&lt;/code&gt; больше &lt;code&gt;j&lt;/code&gt; , функция возвращает пустую строку.</target>
        </trans-unit>
        <trans-unit id="6e188c4467182589f4f24a348f7b82d5dc4eb843" translate="yes" xml:space="preserve">
          <source>In a conversion from integer to float, if the integer value has an exact representation as a float, that is the result. Otherwise, the conversion gets the nearest higher or the nearest lower representable value. This kind of conversion never fails.</source>
          <target state="translated">При преобразовании из целого числа в плавающий,если целое значение имеет точное представление в виде плавающего числа,то это является результатом.В противном случае преобразование получит ближайшее большее или меньшее отображаемое значение.Такое преобразование никогда не подводит.</target>
        </trans-unit>
        <trans-unit id="97b9aa4de4630491dcb4d24142294547e0b16cc1" translate="yes" xml:space="preserve">
          <source>In a function call, first prefixexp and args are evaluated. If the value of prefixexp has type &lt;em&gt;function&lt;/em&gt;, then this function is called with the given arguments. Otherwise, the prefixexp &quot;call&quot; metamethod is called, having as first parameter the value of prefixexp, followed by the original call arguments (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">При вызове функции оцениваются первые prefixexp и args. Если значение prefixexp имеет тип &lt;em&gt;function&lt;/em&gt; , то эта функция вызывается с заданными аргументами. В противном случае вызывается метаметод prefixexp &quot;call&quot;, имеющий в качестве первого параметра значение prefixexp, за которым следуют исходные аргументы вызова (см. &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="62eebdc1879c0b1be4e46a0d6b0e9bcf316566f7" translate="yes" xml:space="preserve">
          <source>In any case, if the pattern specifies no captures, then it behaves as if the whole pattern was inside a capture.</source>
          <target state="translated">В любом случае,если деталь не указывает никаких захватов,то она ведет себя так,как будто вся деталь находится внутри захвата.</target>
        </trans-unit>
        <trans-unit id="2bb9e40f7423d9d013509578590213e990081254" translate="yes" xml:space="preserve">
          <source>In both cases pushes onto the stack the final value associated with &lt;code&gt;tname&lt;/code&gt; in the registry.</source>
          <target state="translated">В обоих случаях помещает в стек последнее значение, связанное с &lt;code&gt;tname&lt;/code&gt; в реестре.</target>
        </trans-unit>
        <trans-unit id="529481951babb324dab477372f5c6d52890e6006" translate="yes" xml:space="preserve">
          <source>In case of errors this function raises the error, instead of returning an error code.</source>
          <target state="translated">В случае ошибок эта функция поднимает ошибку,а не возвращает код ошибки.</target>
        </trans-unit>
        <trans-unit id="f30334a63968b6ddb7bb2b4604dd500f34422267" translate="yes" xml:space="preserve">
          <source>In case of errors, the stack is not unwound, so you can use the debug API over it. The error object is on the top of the stack.</source>
          <target state="translated">В случае ошибок стек не разворачивается,поэтому можно использовать над ним отладочное API.Объект ошибки находится в верхней части стека.</target>
        </trans-unit>
        <trans-unit id="467db70feecc1c4f6d135a7d76a384db5dda44c8" translate="yes" xml:space="preserve">
          <source>In case of overflows in integer arithmetic, all operations &lt;em&gt;wrap around&lt;/em&gt;, according to the usual rules of two-complement arithmetic. (In other words, they return the unique representable integer that is equal modulo &lt;em&gt;2&lt;sup&gt;64&lt;/sup&gt;&lt;/em&gt; to the mathematical result.)</source>
          <target state="translated">В случае переполнения в целочисленной арифметике все операции &lt;em&gt;циклически повторяются в&lt;/em&gt; соответствии с обычными правилами арифметики с двумя дополнениями. (Другими словами, они возвращают уникальное представимое целое число, равное по модулю &lt;em&gt;2 &lt;sup&gt;64&lt;/sup&gt;&lt;/em&gt; математическому результату.)</target>
        </trans-unit>
        <trans-unit id="af2e9f70152b7436cb1235e5607b1026adf8b4df" translate="yes" xml:space="preserve">
          <source>In case of success, &lt;code&gt;seek&lt;/code&gt; returns the final file position, measured in bytes from the beginning of the file. If &lt;code&gt;seek&lt;/code&gt; fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error.</source>
          <target state="translated">В случае успеха &lt;code&gt;seek&lt;/code&gt; возвращает окончательную позицию файла, измеренную в байтах от начала файла. Если &lt;code&gt;seek&lt;/code&gt; завершается неудачно, он возвращает &lt;b&gt;nil&lt;/b&gt; плюс строку с описанием ошибки.</target>
        </trans-unit>
        <trans-unit id="8ce8027efe413a45818ec783d9d3bd6228742c83" translate="yes" xml:space="preserve">
          <source>In case of success, returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends.</source>
          <target state="translated">В случае успеха возвращает ручку для временного файла.Этот файл открывается в режиме обновления и автоматически удаляется по окончании работы программы.</target>
        </trans-unit>
        <trans-unit id="b6a86eee5d971d25767843d4dbdef34e84774cef" translate="yes" xml:space="preserve">
          <source>In case of success, this function returns &lt;code&gt;file&lt;/code&gt;. Otherwise it returns &lt;b&gt;nil&lt;/b&gt; plus a string describing the error.</source>
          <target state="translated">В случае успеха эта функция возвращает &lt;code&gt;file&lt;/code&gt; . В противном случае возвращается &lt;b&gt;ноль&lt;/b&gt; плюс строка с описанием ошибки.</target>
        </trans-unit>
        <trans-unit id="8c632a9fad5564d87f459215e17e926cda31f0ee" translate="yes" xml:space="preserve">
          <source>In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is not a string but has a metamethod &lt;code&gt;__tostring&lt;/code&gt;, the interpreter calls this metamethod to produce the final message. Otherwise, the interpreter converts the error object to a string and adds a stack traceback to it.</source>
          <target state="translated">В случае незащищенных ошибок в скрипте интерпретатор сообщает об ошибке в стандартный поток ошибок. Если объект ошибки не является строкой, но имеет &lt;code&gt;__tostring&lt;/code&gt; , интерпретатор вызывает этот метаметод для создания окончательного сообщения. В противном случае интерпретатор преобразует объект ошибки в строку и добавляет к нему трассировку стека.</target>
        </trans-unit>
        <trans-unit id="bae459100d0f219cfd74a53f2eb34f96a6176512" translate="yes" xml:space="preserve">
          <source>In interactive mode, Lua repeatedly prompts and waits for a line. After reading a line, Lua first try to interpret the line as an expression. If it succeeds, it prints its value. Otherwise, it interprets the line as a statement. If you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt.</source>
          <target state="translated">В интерактивном режиме Lua многократно подсказывает и ждет строку.После прочтения строки,Lua сначала пытается интерпретировать ее как выражение.Если это удаётся,он печатает своё значение.В противном случае он интерпретирует строку как выражение.Если вы пишете незавершенное выражение,интерпретатор ждет его завершения,выдавая другую подсказку.</target>
        </trans-unit>
        <trans-unit id="08b57c85f9e4681ef2b296b47dfe58462b42111a" translate="yes" xml:space="preserve">
          <source>In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, &lt;code&gt;lua_gettop(L)&lt;/code&gt; returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index &lt;code&gt;lua_gettop(L)&lt;/code&gt;. To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results.</source>
          <target state="translated">Чтобы правильно взаимодействовать с Lua, функция C должна использовать следующий протокол, который определяет способ передачи параметров и результатов: функция C получает свои аргументы из Lua в своем стеке в прямом порядке (первый аргумент помещается первым). Итак, когда функция запускается, &lt;code&gt;lua_gettop(L)&lt;/code&gt; возвращает количество аргументов, полученных функцией. Первый аргумент (если есть) имеет индекс 1, а его последний аргумент - индекс &lt;code&gt;lua_gettop(L)&lt;/code&gt; . Чтобы вернуть значения в Lua, функция C просто помещает их в стек в прямом порядке (первый результат помещается первым) и возвращает количество результатов. Любое другое значение в стеке под результатами будет правильно отброшено Lua. Как и функция Lua, функция C, вызываемая Lua, также может возвращать множество результатов.</target>
        </trans-unit>
        <trans-unit id="1509d2ba42008705f892c900bc91b5bc201ddc1e" translate="yes" xml:space="preserve">
          <source>In the &lt;b&gt;repeat&lt;/b&gt;&amp;ndash;&lt;b&gt;until&lt;/b&gt; loop, the inner block does not end at the &lt;b&gt;until&lt;/b&gt; keyword, but only after the condition. So, the condition can refer to local variables declared inside the loop block.</source>
          <target state="translated">В цикле &lt;b&gt;повторения&lt;/b&gt; - &lt;b&gt;до&lt;/b&gt; внутренний блок не заканчивается ключевым словом &lt;b&gt;до&lt;/b&gt; , а только после условия. Таким образом, условие может относиться к локальным переменным, объявленным внутри блока цикла.</target>
        </trans-unit>
        <trans-unit id="82f098174293e606c23ea050f8d7e73e0153453e" translate="yes" xml:space="preserve">
          <source>In the above code, the new function &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;continuation function&lt;/em&gt; (with type &lt;a href=&quot;#lua_KFunction&quot;&gt;&lt;code&gt;lua_KFunction&lt;/code&gt;&lt;/a&gt;), which should do all the work that the original function was doing after calling &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;. Now, we must inform Lua that it must call &lt;code&gt;k&lt;/code&gt; if the Lua code being executed by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; gets interrupted in some way (errors or yielding), so we rewrite the code as here, replacing &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">В приведенном выше коде новая функция &lt;code&gt;k&lt;/code&gt; является &lt;em&gt;функцией продолжения&lt;/em&gt; (с типом &lt;a href=&quot;#lua_KFunction&quot;&gt; &lt;code&gt;lua_KFunction&lt;/code&gt; &lt;/a&gt; ), которая должна выполнять всю работу, которую выполняла исходная функция после вызова &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; . Теперь мы должны сообщить Lua, что он должен вызвать &lt;code&gt;k&lt;/code&gt; , если код Lua, выполняемый &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; ,&lt;/a&gt; каким-то образом прерывается (ошибки или уступка), поэтому мы переписываем код, как здесь, заменяя &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; на &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="06f49d50825ba7a2c55ba6aba66f792c4da727cd" translate="yes" xml:space="preserve">
          <source>In the first case, the parameter &lt;code&gt;ar&lt;/code&gt; must be a valid activation record that was filled by a previous call to &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; or given as argument to a hook (see &lt;a href=&quot;#lua_Hook&quot;&gt;&lt;code&gt;lua_Hook&lt;/code&gt;&lt;/a&gt;). The index &lt;code&gt;n&lt;/code&gt; selects which local variable to inspect; see &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt;&lt;code&gt;debug.getlocal&lt;/code&gt;&lt;/a&gt; for details about variable indices and names.</source>
          <target state="translated">В первом случае параметр &lt;code&gt;ar&lt;/code&gt; должен быть допустимой записью активации, которая была заполнена предыдущим вызовом &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; или передана в качестве аргумента ловушки (см. &lt;a href=&quot;#lua_Hook&quot;&gt; &lt;code&gt;lua_Hook&lt;/code&gt; &lt;/a&gt; ). Индекс &lt;code&gt;n&lt;/code&gt; выбирает, какую локальную переменную проверять; см. &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt; &lt;code&gt;debug.getlocal&lt;/code&gt; &lt;/a&gt; для получения подробной информации об индексах и именах переменных.</target>
        </trans-unit>
        <trans-unit id="41a440753f8786d13a87f3b118280fbe98ed6aa7" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;ar&lt;/code&gt; must be &lt;code&gt;NULL&lt;/code&gt; and the function to be inspected must be at the top of the stack. In this case, only parameters of Lua functions are visible (as there is no information about what variables are active) and no values are pushed onto the stack.</source>
          <target state="translated">Во втором случае &lt;code&gt;ar&lt;/code&gt; должно быть &lt;code&gt;NULL&lt;/code&gt; , а проверяемая функция должна находиться наверху стека. В этом случае видны только параметры функций Lua (поскольку нет информации о том, какие переменные активны), и никакие значения не помещаются в стек.</target>
        </trans-unit>
        <trans-unit id="431335cf2ea122b520413c8e75c042e2443dd934" translate="yes" xml:space="preserve">
          <source>In this case, all returned values are thrown away. Function calls are explained in &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;.</source>
          <target state="translated">В этом случае все возвращенные значения выбрасываются. &lt;a href=&quot;#3.4.10&quot;&gt;Вызов&lt;/a&gt; функций объясняется в &amp;sect;3.4.10 .</target>
        </trans-unit>
        <trans-unit id="789e39d8c294634d33eb6b9c165293b5343c70b0" translate="yes" xml:space="preserve">
          <source>In words, a border is any (natural) index in a table where a non-nil value is followed by a nil value (or zero, when index 1 is nil).</source>
          <target state="translated">Иными словами,границей является любой (естественный)индекс в таблице,за которым следует нулевое значение (или ноль,если индекс 1 равен нулю).</target>
        </trans-unit>
        <trans-unit id="1d61c65c4df032dfd4680710a9c5e29989e4f8c3" translate="yes" xml:space="preserve">
          <source>In words, if the argument &lt;code&gt;arg&lt;/code&gt; is nil or absent, the macro results in the default &lt;code&gt;dflt&lt;/code&gt;. Otherwise, it results in the result of calling &lt;code&gt;func&lt;/code&gt; with the state &lt;code&gt;L&lt;/code&gt; and the argument index &lt;code&gt;arg&lt;/code&gt; as parameters. Note that it evaluates the expression &lt;code&gt;dflt&lt;/code&gt; only if needed.</source>
          <target state="translated">На словах, если аргумент &lt;code&gt;arg&lt;/code&gt; равен нулю или отсутствует, макрос &lt;code&gt;dflt&lt;/code&gt; значение по умолчанию dflt . В противном случае результатом будет вызов &lt;code&gt;func&lt;/code&gt; с состоянием &lt;code&gt;L&lt;/code&gt; и индексом аргумента &lt;code&gt;arg&lt;/code&gt; в качестве параметров. Обратите внимание, что он оценивает выражение &lt;code&gt;dflt&lt;/code&gt; только в случае необходимости.</target>
        </trans-unit>
        <trans-unit id="67c7955edf181aeadc7e61f0904d3690ad3a91fb" translate="yes" xml:space="preserve">
          <source>Initializes a buffer &lt;code&gt;B&lt;/code&gt;. This function does not allocate any space; the buffer must be declared as a variable (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Инициализация буфера &lt;code&gt;B&lt;/code&gt; . Эта функция не выделяет места; буфер должен быть объявлен как переменная (см. &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0abea9e11cfbbca6718360dab7feca24a7e28d57" translate="yes" xml:space="preserve">
          <source>Inserts element &lt;code&gt;value&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, shifting up the elements &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt;. The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list+1&lt;/code&gt;, so that a call &lt;code&gt;table.insert(t,x)&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; at the end of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Вставляет &lt;code&gt;value&lt;/code&gt; элемента в позицию &lt;code&gt;pos&lt;/code&gt; в &lt;code&gt;list&lt;/code&gt; , сдвигая вверх &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; элементов [pos], list [pos + 1], &amp;middot;&amp;middot;&amp;middot;, list [#list] . Значение по умолчанию для &lt;code&gt;pos&lt;/code&gt; - &lt;code&gt;#list+1&lt;/code&gt; , так что вызов &lt;code&gt;table.insert(t,x)&lt;/code&gt; вставляет &lt;code&gt;x&lt;/code&gt; в конец списка &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3151191ed07199be567c359ddf6e784a4e531a23" translate="yes" xml:space="preserve">
          <source>Inside a C function you can raise an error by calling &lt;a href=&quot;#lua_error&quot;&gt;&lt;code&gt;lua_error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Внутри функции C вы можете вызвать ошибку, вызвав &lt;a href=&quot;#lua_error&quot;&gt; &lt;code&gt;lua_error&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85b166ec01ff2a0e99bcb49337529aa50cdf9ed8" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to handle errors. (Lua will use exceptions if you compile it as C++; search for &lt;code&gt;LUAI_THROW&lt;/code&gt; in the source code for details.) When Lua faces any error (such as a memory allocation error or a type error) it &lt;em&gt;raises&lt;/em&gt; an error; that is, it does a long jump. A &lt;em&gt;protected environment&lt;/em&gt; uses &lt;code&gt;setjmp&lt;/code&gt; to set a recovery point; any error jumps to the most recent active recovery point.</source>
          <target state="translated">Внутренне Lua использует средство C &lt;code&gt;longjmp&lt;/code&gt; для обработки ошибок. (Lua будет использовать исключения, если вы скомпилируете его как C ++; &lt;code&gt;LUAI_THROW&lt;/code&gt; ищите LUAI_THROW в исходном коде.) Когда Lua сталкивается с какой-либо ошибкой (такой как ошибка распределения памяти или ошибка типа), он &lt;em&gt;вызывает&lt;/em&gt; ошибку; то есть делает прыжок в длину. В &lt;em&gt;защищенной среде&lt;/em&gt; для установки точки восстановления используется &lt;code&gt;setjmp&lt;/code&gt; ; при любой ошибке выполняется переход к самой последней активной точке восстановления.</target>
        </trans-unit>
        <trans-unit id="8519c30b2fe0a1d5b4b757f31a04911a4641884f" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to yield a coroutine. Therefore, if a C function &lt;code&gt;foo&lt;/code&gt; calls an API function and this API function yields (directly or indirectly by calling another function that yields), Lua cannot return to &lt;code&gt;foo&lt;/code&gt; any more, because the &lt;code&gt;longjmp&lt;/code&gt; removes its frame from the C stack.</source>
          <target state="translated">Внутри Lua использует средство C &lt;code&gt;longjmp&lt;/code&gt; для создания сопрограммы. Следовательно, если функция C &lt;code&gt;foo&lt;/code&gt; вызывает функцию API, и эта функция API дает результат (прямо или косвенно, вызывая другую функцию, которая дает результат), Lua больше не может вернуться к &lt;code&gt;foo&lt;/code&gt; , потому что &lt;code&gt;longjmp&lt;/code&gt; удаляет свой фрейм из стека C.</target>
        </trans-unit>
        <trans-unit id="ffa29374aa14b1802d3041c63b03777bfa3568ee" translate="yes" xml:space="preserve">
          <source>It is a good practice to add all needed metamethods to a table before setting it as a metatable of some object. In particular, the &lt;code&gt;__gc&lt;/code&gt; metamethod works only when this order is followed (see &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;).</source>
          <target state="translated">Хорошей практикой является добавление всех необходимых метаметодов в таблицу, прежде чем устанавливать ее в качестве метатаблицы какого-либо объекта. В частности, &lt;code&gt;__gc&lt;/code&gt; работает только при соблюдении этого порядка (см. &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1db3cf420aeec740d5b98f3c2218fb5a839f1cb0" translate="yes" xml:space="preserve">
          <source>It is implemented as a macro. The array &lt;code&gt;l&lt;/code&gt; must be the actual array, not a pointer to it.</source>
          <target state="translated">Он реализован как макрос. Массив &lt;code&gt;l&lt;/code&gt; должен быть фактическим массивом, а не указателем на него.</target>
        </trans-unit>
        <trans-unit id="c9afa0ea65ace9886d214c45b938bb7c94f5de0d" translate="yes" xml:space="preserve">
          <source>It is implemented as the following macro:</source>
          <target state="translated">Он реализован в виде следующего макроса:</target>
        </trans-unit>
        <trans-unit id="2562ec974531de3f4ff5f92b1e35fb5384a96e25" translate="yes" xml:space="preserve">
          <source>It returns false if there are no errors or true in case of errors.</source>
          <target state="translated">Возвращает false,если ошибок нет или true в случае ошибок.</target>
        </trans-unit>
        <trans-unit id="53569202de7b24893f55608fc3a251509d5c5ed1" translate="yes" xml:space="preserve">
          <source>Labels and empty statements are called &lt;em&gt;void statements&lt;/em&gt;, as they perform no actions.</source>
          <target state="translated">Этикетки и пустые заявления называются &lt;em&gt;недействительным заявление&lt;/em&gt; , так как они не выполняют никаких действий.</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="34328aff9c833379f4f7362578f7f6f3c35f336b" translate="yes" xml:space="preserve">
          <source>Language constructs will be explained using the usual extended BNF notation, in which {&lt;em&gt;a&lt;/em&gt;} means 0 or more &lt;em&gt;a&lt;/em&gt;'s, and [&lt;em&gt;a&lt;/em&gt;] means an optional &lt;em&gt;a&lt;/em&gt;. Non-terminals are shown like non-terminal, keywords are shown like &lt;b&gt;kword&lt;/b&gt;, and other terminal symbols are shown like &amp;lsquo;&lt;b&gt;=&lt;/b&gt;&amp;rsquo;. The complete syntax of Lua can be found in &lt;a href=&quot;#9&quot;&gt;&amp;sect;9&lt;/a&gt; at the end of this manual.</source>
          <target state="translated">Языковые конструкции будут объяснены с использованием обычной расширенной нотации BNF, в которой { &lt;em&gt;a&lt;/em&gt; } означает 0 или более &lt;em&gt;a&lt;/em&gt; , а [ &lt;em&gt;a&lt;/em&gt; ] означает необязательный &lt;em&gt;a&lt;/em&gt; . &lt;b&gt;Нетерминалы&lt;/b&gt; показаны как &lt;b&gt;нетерминалы&lt;/b&gt; , ключевые слова показаны как &lt;b&gt;kword&lt;/b&gt; , а другие терминальные символы показаны как ' &lt;b&gt;=&lt;/b&gt; '. Полный синтаксис Lua можно найти в &lt;a href=&quot;#9&quot;&gt;&amp;sect;9&lt;/a&gt; в конце этого руководства.</target>
        </trans-unit>
        <trans-unit id="b15777583b377cc227a5505487783a1d631969a6" translate="yes" xml:space="preserve">
          <source>Leaves a copy of the module on the stack.</source>
          <target state="translated">Оставляет копию модуля на стеке.</target>
        </trans-unit>
        <trans-unit id="c282589ab5afc326acf6f1bd9d84cafcef993944" translate="yes" xml:space="preserve">
          <source>Level 0 is the running function, level 1 is the function that called the running function, etc.</source>
          <target state="translated">Уровень 0-выполняющаяся функция,уровень 1-функция,вызывающая выполняющуюся функцию,и т.д.</target>
        </trans-unit>
        <trans-unit id="bd2f93f70d8b01be186bad25b37a58b9b3ce91ea" translate="yes" xml:space="preserve">
          <source>Lexical Conventions</source>
          <target state="translated">Лексические конвенции</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">Лицензия MIT.</target>
        </trans-unit>
        <trans-unit id="63d6bf8afb548c458acc9de58d99159419a5b08e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; returns all the values returned by &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, except the first one (the boolean error code). Unlike &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; does not catch errors; any error is propagated to the caller.</source>
          <target state="translated">Как и &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt; , функция &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; также создает сопрограмму, но вместо того, чтобы возвращать саму сопрограмму, она возвращает функцию, которая при вызове возобновляет сопрограмму. Любые аргументы, переданные этой функции, передаются в &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; как дополнительные аргументы . &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; возвращает все значения, возвращаемые &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; , кроме первого (логический код ошибки). В отличие от &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; не обнаруживает ошибок; любая ошибка передается вызывающему абоненту.</target>
        </trans-unit>
        <trans-unit id="589bb9a9b2f8417c5c99beaf7b463ed9bff7b7a8" translate="yes" xml:space="preserve">
          <source>Like any other reference manual, this document is dry in places. For a discussion of the decisions behind the design of Lua, see the technical papers available at Lua's web site. For a detailed introduction to programming in Lua, see Roberto's book, &lt;em&gt;Programming in Lua&lt;/em&gt;.</source>
          <target state="translated">Как и любое другое справочное руководство, этот документ местами пересох. Для обсуждения решений, лежащих в основе дизайна Lua, см. Технические документы, доступные на веб-сайте Lua. Подробное введение в программирование на Lua см. В книге Роберто &amp;laquo; &lt;em&gt;Программирование на Lua&amp;raquo;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0685b0afda8aac522f92e3eb98e6860f9fdecb1c" translate="yes" xml:space="preserve">
          <source>Like indices, the values of table fields can be of any type. In particular, because functions are first-class values, table fields can contain functions. Thus tables can also carry &lt;em&gt;methods&lt;/em&gt; (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;).</source>
          <target state="translated">Как и индексы, значения полей таблицы могут быть любого типа. В частности, поскольку функции являются первоклассными значениями, поля таблицы могут содержать функции. Таким образом, таблицы могут также содержать &lt;em&gt;методы&lt;/em&gt; (см. &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8afe6c1d451218575629deb4965cb995c2e958ea" translate="yes" xml:space="preserve">
          <source>Like with indexing, the metamethod for this event can be either a function or a table. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; as arguments. If it is a table, Lua does an indexing assignment to this table with the same key and value. (This assignment is regular, not raw, and therefore can trigger another metamethod.)</source>
          <target state="translated">Как и в случае с индексированием, метаметодом для этого события может быть функция или таблица. Если это функция, она вызывается с &lt;code&gt;table&lt;/code&gt; , &lt;code&gt;key&lt;/code&gt; и &lt;code&gt;value&lt;/code&gt; качестве аргументов. Если это таблица, Lua выполняет присвоение индексации этой таблице с тем же ключом и значением. (Это обычное назначение, а не исходное, поэтому оно может запускать другой метаметод.)</target>
        </trans-unit>
        <trans-unit id="5cf4bcbf4e9a4c997d9f25e1a4ebd39ad823de69" translate="yes" xml:space="preserve">
          <source>Literal strings can also be defined using a long format enclosed by &lt;em&gt;long brackets&lt;/em&gt;. We define an &lt;em&gt;opening long bracket of level &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; as an opening square bracket followed by &lt;em&gt;n&lt;/em&gt; equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as &lt;code&gt;[[&lt;/code&gt;, an opening long bracket of level 1 is written as &lt;code&gt;[=[&lt;/code&gt;, and so on. A &lt;em&gt;closing long bracket&lt;/em&gt; is defined similarly; for instance, a closing long bracket of level 4 is written as &lt;code&gt;]====]&lt;/code&gt;. A &lt;em&gt;long literal&lt;/em&gt; starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. It can contain any text except a closing bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. Any kind of end-of-line sequence (carriage return, newline, carriage return followed by newline, or newline followed by carriage return) is converted to a simple newline.</source>
          <target state="translated">Литеральные строки также могут быть определены с использованием длинного формата, заключенного в &lt;em&gt;длинные скобки&lt;/em&gt; . Мы определяем &lt;em&gt;открывающую длинную скобку уровня &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; как открывающую квадратную скобку, за которой следуют &lt;em&gt;n&lt;/em&gt; знаков равенства, за которыми следует еще одна открывающая квадратная скобка. Итак, открывающая длинная скобка уровня 0 записывается как &lt;code&gt;[[&lt;/code&gt; , открывающая длинная скобка уровня 1 записывается как &lt;code&gt;[=[&lt;/code&gt; , и так далее. &lt;em&gt;Закрытия длинный кронштейн&lt;/em&gt; определяется аналогично; например, закрывающая длинная скобка уровня 4 записывается как &lt;code&gt;]====]&lt;/code&gt; . &lt;em&gt;Долго буквальным&lt;/em&gt;начинается с открывающей длинной скобки любого уровня и заканчивается первой закрывающей длинной скобкой того же уровня. Он может содержать любой текст, кроме закрывающей скобки того же уровня. Литералы в этой заключенной в квадратные скобки форме могут занимать несколько строк, не интерпретируют никаких управляющих последовательностей и игнорируют длинные скобки любого другого уровня. Любая последовательность конца строки (возврат каретки, новая строка, возврат каретки с последующим переводом строки или новая строка с последующим возвратом каретки) преобразуется в простой символ новой строки.</target>
        </trans-unit>
        <trans-unit id="e1021ae8c4b84ca4a4e3486abedfb8d10587c094" translate="yes" xml:space="preserve">
          <source>Loads a Lua chunk without running it. If there are no errors, &lt;code&gt;lua_load&lt;/code&gt; pushes the compiled chunk as a Lua function on top of the stack. Otherwise, it pushes an error message.</source>
          <target state="translated">Загружает блок Lua, не запуская его. Если ошибок нет, &lt;code&gt;lua_load&lt;/code&gt; помещает скомпилированный фрагмент как функцию Lua поверх стека. В противном случае выдает сообщение об ошибке.</target>
        </trans-unit>
        <trans-unit id="d5d5fd2502388f4bdbfdc40480095cb9940c91fb" translate="yes" xml:space="preserve">
          <source>Loads a buffer as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the buffer pointed to by &lt;code&gt;buff&lt;/code&gt; with size &lt;code&gt;sz&lt;/code&gt;.</source>
          <target state="translated">Загружает буфер как блок Lua. Эта функция использует &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; для загрузки фрагмента в буфер, на который указывает &lt;code&gt;buff&lt;/code&gt; , размером &lt;code&gt;sz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="014ceb5ba979a3f7460e80adaf03760442d4492f" translate="yes" xml:space="preserve">
          <source>Loads a chunk.</source>
          <target state="translated">Загружает кусок.</target>
        </trans-unit>
        <trans-unit id="8dd06506aefef93d24f715ed25819bedec96323c" translate="yes" xml:space="preserve">
          <source>Loads a file as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the file named &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then it loads from the standard input. The first line in the file is ignored if it starts with a &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">Загружает файл в виде блока Lua. Эта функция использует &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; для загрузки фрагмента в файл с именем &lt;code&gt;filename&lt;/code&gt; . Если &lt;code&gt;filename&lt;/code&gt; имеет &lt;code&gt;NULL&lt;/code&gt; , он загружается из стандартного ввода. Первая строка в файле игнорируется, если она начинается с символа &lt;code&gt;#&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f640ebe64a89ecb5b9bd56467fcc7e3fb5298535" translate="yes" xml:space="preserve">
          <source>Loads a string as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the zero-terminated string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Загружает строку как фрагмент Lua. Эта функция использует &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; для загрузки фрагмента в строке &lt;code&gt;s&lt;/code&gt; с нулевым символом в конце .</target>
        </trans-unit>
        <trans-unit id="601f4f126ff0dc3c88078602ece1575bc60b38da" translate="yes" xml:space="preserve">
          <source>Loads and runs the given file. It is defined as the following macro:</source>
          <target state="translated">Загружает и запускает данный файл.Он определяется как следующий макрос:</target>
        </trans-unit>
        <trans-unit id="41daddb6c30d8daa7aa997ef002e9682aa252572" translate="yes" xml:space="preserve">
          <source>Loads and runs the given string. It is defined as the following macro:</source>
          <target state="translated">Загружает и запускает данную строку.Определяется как следующий макрос:</target>
        </trans-unit>
        <trans-unit id="5754e2c7cbb7348e49d26f5b052dec66fe41474e" translate="yes" xml:space="preserve">
          <source>Loads the given module. The function starts by looking into the &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt; table to determine whether &lt;code&gt;modname&lt;/code&gt; is already loaded. If it is, then &lt;code&gt;require&lt;/code&gt; returns the value stored at &lt;code&gt;package.loaded[modname]&lt;/code&gt;. Otherwise, it tries to find a &lt;em&gt;loader&lt;/em&gt; for the module.</source>
          <target state="translated">Загружает данный модуль. Функция начинается с просмотра таблицы &lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; ,&lt;/a&gt; чтобы определить, &lt;code&gt;modname&lt;/code&gt; ли уже имя мода . Если это так, то &lt;code&gt;require&lt;/code&gt; возвращает значение, хранящееся в &lt;code&gt;package.loaded[modname]&lt;/code&gt; . В противном случае он пытается найти &lt;em&gt;загрузчик&lt;/em&gt; для модуля.</target>
        </trans-unit>
        <trans-unit id="675ad816883ad3050b77c4af165af0c382872da3" translate="yes" xml:space="preserve">
          <source>Local Declarations</source>
          <target state="translated">Местные декларации</target>
        </trans-unit>
        <trans-unit id="e74ccb9aead3e3f9b1bc796bf321e14c551c0f2e" translate="yes" xml:space="preserve">
          <source>Local variables can be declared anywhere inside a block. The declaration can include an initial assignment:</source>
          <target state="translated">Локальные переменные могут быть объявлены в любом месте внутри блока.Объявление может включать в себя начальное задание:</target>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">Логические операторы</target>
        </trans-unit>
        <trans-unit id="f3c2c12151d04fbe64aef12442234645ff418818" translate="yes" xml:space="preserve">
          <source>Looks for the first &lt;em&gt;match&lt;/em&gt; of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds one, then &lt;code&gt;match&lt;/code&gt; returns the captures from the pattern; otherwise it returns &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is returned. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="translated">&lt;a href=&quot;#6.4.1&quot;&gt;Ищет&lt;/a&gt; первое &lt;em&gt;совпадение&lt;/em&gt; с &lt;code&gt;pattern&lt;/code&gt; (см. &amp;sect;6.4.1 ) в строке &lt;code&gt;s&lt;/code&gt; . Если он его находит, то &lt;code&gt;match&lt;/code&gt; возвращает захваченные данные из шаблона; в противном случае возвращается &lt;b&gt;ноль&lt;/b&gt; . Если &lt;code&gt;pattern&lt;/code&gt; указывает захватов, то возвращается все совпадение. Третий необязательный числовой аргумент &lt;code&gt;init&lt;/code&gt; указывает, с чего начать поиск; его значение по умолчанию - 1 и может быть отрицательным.</target>
        </trans-unit>
        <trans-unit id="0531dd8559629f728382a45e8fa0141160f819b2" translate="yes" xml:space="preserve">
          <source>Looks for the first match of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds a match, then &lt;code&gt;find&lt;/code&gt; returns the indices of &lt;code&gt;s&lt;/code&gt; where this occurrence starts and ends; otherwise, it returns &lt;b&gt;nil&lt;/b&gt;. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative. A value of &lt;b&gt;true&lt;/b&gt; as a fourth, optional argument &lt;code&gt;plain&lt;/code&gt; turns off the pattern matching facilities, so the function does a plain &quot;find substring&quot; operation, with no characters in &lt;code&gt;pattern&lt;/code&gt; being considered magic. Note that if &lt;code&gt;plain&lt;/code&gt; is given, then &lt;code&gt;init&lt;/code&gt; must be given as well.</source>
          <target state="translated">&lt;a href=&quot;#6.4.1&quot;&gt;Ищет&lt;/a&gt; первое совпадение с &lt;code&gt;pattern&lt;/code&gt; (см. &amp;sect;6.4.1 ) в строке &lt;code&gt;s&lt;/code&gt; . Если он находит совпадение, то &lt;code&gt;find&lt;/code&gt; возвращает индексы &lt;code&gt;s&lt;/code&gt; , где это вхождение начинается и заканчивается; в противном случае возвращается &lt;b&gt;ноль&lt;/b&gt; . Третий необязательный числовой аргумент &lt;code&gt;init&lt;/code&gt; указывает, с чего начать поиск; его значение по умолчанию - 1 и может быть отрицательным. Значение &lt;b&gt;true&lt;/b&gt; в качестве четвертого необязательного аргумента &lt;code&gt;plain&lt;/code&gt; отключает средства сопоставления с образцом, поэтому функция выполняет простую операцию &amp;laquo;поиска подстроки&amp;raquo;, при этом никакие символы в &lt;code&gt;pattern&lt;/code&gt; не считаются магическими. Обратите внимание, что если задано &lt;code&gt;plain&lt;/code&gt; , то &lt;code&gt;init&lt;/code&gt; необходимо указать init .</target>
        </trans-unit>
        <trans-unit id="b0832074630eb731d7fbe8074de48a90cd9bb220" translate="yes" xml:space="preserve">
          <source>Lua</source>
          <target state="translated">Lua</target>
        </trans-unit>
        <trans-unit id="74935e355c6d4299b6901e869daba41fae3ae4f2" translate="yes" xml:space="preserve">
          <source>Lua 5.3 Reference Manual</source>
          <target state="translated">Lua 5.3 Справочное руководство</target>
        </trans-unit>
        <trans-unit id="e8957a41e15b0eb53aad63ef201700fe8063f094" translate="yes" xml:space="preserve">
          <source>Lua allows multiple assignments. Therefore, the syntax for assignment defines a list of variables on the left side and a list of expressions on the right side. The elements in both lists are separated by commas:</source>
          <target state="translated">Луа допускает множественные назначения.Поэтому синтаксис присваивания определяет список переменных слева и список выражений справа.Элементы в обоих списках разделены запятыми:</target>
        </trans-unit>
        <trans-unit id="1e02808cd690aaf7df864db5c4c452af196be013" translate="yes" xml:space="preserve">
          <source>Lua also converts strings to numbers, whenever a number is expected.</source>
          <target state="translated">Lua также преобразует строки в числа,когда ожидается число.</target>
        </trans-unit>
        <trans-unit id="93377de262ae6c56472bd1d07591e21435ec1e52" translate="yes" xml:space="preserve">
          <source>Lua also defines the constants &lt;a id=&quot;pdf-LUA_MININTEGER&quot;&gt;&lt;code&gt;LUA_MININTEGER&lt;/code&gt;&lt;/a&gt; and &lt;a id=&quot;pdf-LUA_MAXINTEGER&quot;&gt;&lt;code&gt;LUA_MAXINTEGER&lt;/code&gt;&lt;/a&gt;, with the minimum and the maximum values that fit in this type.</source>
          <target state="translated">Lua также определяет константы &lt;a id=&quot;pdf-LUA_MININTEGER&quot;&gt; &lt;code&gt;LUA_MININTEGER&lt;/code&gt; &lt;/a&gt; и &lt;a id=&quot;pdf-LUA_MAXINTEGER&quot;&gt; &lt;code&gt;LUA_MAXINTEGER&lt;/code&gt; &lt;/a&gt; с минимальным и максимальным значениями, подходящими для этого типа.</target>
        </trans-unit>
        <trans-unit id="801090e92a322f968636387436cbfb91aa33b154" translate="yes" xml:space="preserve">
          <source>Lua also has a &lt;b&gt;for&lt;/b&gt; statement, in two flavors (see &lt;a href=&quot;#3.3.5&quot;&gt;&amp;sect;3.3.5&lt;/a&gt;).</source>
          <target state="translated">В Lua также есть оператор &lt;b&gt;for&lt;/b&gt; в двух вариантах (см. &lt;a href=&quot;#3.3.5&quot;&gt;&amp;sect;3.3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3da908593ea7c1cd8a16b5d87a2733072f9be916" translate="yes" xml:space="preserve">
          <source>Lua assumes the following behavior from the allocator function:</source>
          <target state="translated">Луа принимает следующее поведение от функции аллокатора:</target>
        </trans-unit>
        <trans-unit id="ebffede5db745b98cdaa093a245240704c9e96b1" translate="yes" xml:space="preserve">
          <source>Lua can call (and manipulate) functions written in Lua and functions written in C (see &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;). Both are represented by the type &lt;em&gt;function&lt;/em&gt;.</source>
          <target state="translated">Lua может вызывать (и манипулировать) функции, написанные на Lua, и функции, написанные на C (см. &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; ). Оба представлены &lt;em&gt;функцией&lt;/em&gt; типа .</target>
        </trans-unit>
        <trans-unit id="95c6862384367c489829b9fcf5d130d494969aa1" translate="yes" xml:space="preserve">
          <source>Lua code can explicitly generate an error by calling the &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function. If you need to catch errors in Lua, you can use &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; to call a given function in &lt;em&gt;protected mode&lt;/em&gt;.</source>
          <target state="translated">Код Lua может явно генерировать ошибку, вызывая функцию &lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; . Если вам нужно отловить ошибки в Lua, вы можете использовать &lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt; для вызова заданной функции в &lt;em&gt;защищенном режиме&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="55000944726bac35e3a7a8c2c659ce8ea827ae88" translate="yes" xml:space="preserve">
          <source>Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.</source>
          <target state="translated">Lua сочетает в себе простой процедурный синтаксис с мощными конструкциями описания данных,основанными на ассоциативных массивах и расширяемой семантике.Lua динамически набран,выполняется интерпретацией байткода с помощью виртуальной машины,основанной на регистрах,и имеет автоматическое управление памятью с инкрементальным сбором мусора,что делает его идеальным для конфигурирования,написания скриптов и быстрого прототипирования.</target>
        </trans-unit>
        <trans-unit id="8c26f824cf75010655e9550b8fde705425a3784c" translate="yes" xml:space="preserve">
          <source>Lua does not check the consistency of binary chunks. Maliciously crafted binary chunks can crash the interpreter.</source>
          <target state="translated">Луа не проверяет последовательность бинарных кусков.Злонамеренно сделанные двоичные куски могут разбить интерпретатор.</target>
        </trans-unit>
        <trans-unit id="35b65ab36f2f47f5954bb270f0f9be36cfe1a6ba" translate="yes" xml:space="preserve">
          <source>Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;). As such, chunks can define local variables, receive arguments, and return values. Moreover, such anonymous function is compiled as in the scope of an external local variable called &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). The resulting function always has &lt;code&gt;_ENV&lt;/code&gt; as its only upvalue, even if it does not use that variable.</source>
          <target state="translated">Lua обрабатывает фрагмент как тело анонимной функции с переменным числом аргументов (см. &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; ). Таким образом, чанки могут определять локальные переменные, принимать аргументы и возвращать значения. Более того, такая анонимная функция компилируется как в области видимости внешней локальной переменной, называемой &lt;code&gt;_ENV&lt;/code&gt; (см. &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ). Результирующая функция всегда имеет &lt;code&gt;_ENV&lt;/code&gt; в качестве единственного восходящего значения, даже если она не использует эту переменную.</target>
        </trans-unit>
        <trans-unit id="7bb5694782dd5240f5a360755736e520cb7caddd" translate="yes" xml:space="preserve">
          <source>Lua has &lt;em&gt;empty statements&lt;/em&gt; that allow you to separate statements with semicolons, start a block with a semicolon or write two semicolons in sequence:</source>
          <target state="translated">В Lua есть &lt;em&gt;пустые операторы,&lt;/em&gt; которые позволяют разделять операторы точкой с запятой, начинать блок с точки с запятой или последовательно записывать две точки с запятой:</target>
        </trans-unit>
        <trans-unit id="08b67a26f91c4bb6ecbeaabc79499925202576c4" translate="yes" xml:space="preserve">
          <source>Lua has no built-in debugging facilities. Instead, it offers a special interface by means of functions and &lt;em&gt;hooks&lt;/em&gt;. This interface allows the construction of different kinds of debuggers, profilers, and other tools that need &quot;inside information&quot; from the interpreter.</source>
          <target state="translated">Lua не имеет встроенных средств отладки. Вместо этого он предлагает специальный интерфейс с помощью функций и &lt;em&gt;хуков&lt;/em&gt; . Этот интерфейс позволяет создавать различные виды отладчиков, профилировщиков и других инструментов, которым требуется &amp;laquo;внутренняя информация&amp;raquo; интерпретатора.</target>
        </trans-unit>
        <trans-unit id="ab53ba5d8b707a086c1f55306a5e491b7ca0c834" translate="yes" xml:space="preserve">
          <source>Lua implements an incremental mark-and-sweep collector. It uses two numbers to control its garbage-collection cycles: the &lt;em&gt;garbage-collector pause&lt;/em&gt; and the &lt;em&gt;garbage-collector step multiplier&lt;/em&gt;. Both use percentage points as units (e.g., a value of 100 means an internal value of 1).</source>
          <target state="translated">Lua реализует инкрементный сборщик меток и уборок. Он использует два числа , чтобы контролировать свои циклы мусора Коллекция: &lt;em&gt;пауза мусора коллектора&lt;/em&gt; и &lt;em&gt;мусора коллектора шаг множителя&lt;/em&gt; . Оба используют процентные пункты как единицы (например, значение 100 означает внутреннее значение 1).</target>
        </trans-unit>
        <trans-unit id="4be60237bd80620e268374029f3211e510b05c17" translate="yes" xml:space="preserve">
          <source>Lua initializes the C path &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; in the same way it initializes the Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;, using the environment variable &lt;a id=&quot;pdf-LUA_CPATH_5_3&quot;&gt;&lt;code&gt;LUA_CPATH_5_3&lt;/code&gt;&lt;/a&gt;, or the environment variable &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt;&lt;code&gt;LUA_CPATH&lt;/code&gt;&lt;/a&gt;, or a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">Lua инициализирует путь C &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; таким же образом, как он инициализирует путь Lua &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; , используя переменную среды &lt;a id=&quot;pdf-LUA_CPATH_5_3&quot;&gt; &lt;code&gt;LUA_CPATH_5_3&lt;/code&gt; &lt;/a&gt; , или переменную среды &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt; &lt;code&gt;LUA_CPATH&lt;/code&gt; &lt;/a&gt; , или путь по умолчанию, определенный в &lt;code&gt;luaconf.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4714009f33265bf1fc4688da888d62c97c45d7b7" translate="yes" xml:space="preserve">
          <source>Lua initializes this table with four searcher functions.</source>
          <target state="translated">Луа инициализирует эту таблицу четырьмя функциями поиска.</target>
        </trans-unit>
        <trans-unit id="ef9edf704545b26dfa394b151700f2e58198d961" translate="yes" xml:space="preserve">
          <source>Lua is a &lt;em&gt;dynamically typed language&lt;/em&gt;. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type.</source>
          <target state="translated">Lua - это &lt;em&gt;язык&lt;/em&gt; с &lt;em&gt;динамической типизацией&lt;/em&gt; . Это означает, что переменные не имеют типов; только ценности. В языке нет определений типов. Все значения имеют свой собственный тип.</target>
        </trans-unit>
        <trans-unit id="768b1dfa86b0332cedc5bdb9fcc8e17166f9ef47" translate="yes" xml:space="preserve">
          <source>Lua is a case-sensitive language: &lt;code&gt;and&lt;/code&gt; is a reserved word, but &lt;code&gt;And&lt;/code&gt; and &lt;code&gt;AND&lt;/code&gt; are two different, valid names. As a convention, programs should avoid creating names that start with an underscore followed by one or more uppercase letters (such as &lt;a href=&quot;#pdf-_VERSION&quot;&gt;&lt;code&gt;_VERSION&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua - это язык с учетом регистра: &lt;code&gt;and&lt;/code&gt; является зарезервированным словом, но &lt;code&gt;And&lt;/code&gt; и &lt;code&gt;AND&lt;/code&gt; - два разных допустимых имени. По соглашению программы должны избегать создания имен, которые начинаются с подчеркивания, за которым следует одна или несколько заглавных букв (например, &lt;a href=&quot;#pdf-_VERSION&quot;&gt; &lt;code&gt;_VERSION&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5747aeb4d5eff65fa7549c62e63b2802c05d28fa" translate="yes" xml:space="preserve">
          <source>Lua is a free-form language. It ignores spaces (including new lines) and comments between lexical elements (tokens), except as delimiters between names and keywords.</source>
          <target state="translated">Луа-язык свободной формы.Он игнорирует пробелы (включая новые строки)и комментарии между лексическими элементами (лексемы),кроме как в качестве разделителей между именами и ключевыми словами.</target>
        </trans-unit>
        <trans-unit id="10cf3931978ad3da8f2a0c2e42a3bc57db1befcb" translate="yes" xml:space="preserve">
          <source>Lua is a lexically scoped language. The scope of a local variable begins at the first statement after its declaration and lasts until the last non-void statement of the innermost block that includes the declaration. Consider the following example:</source>
          <target state="translated">Луа-это лексически скопированный язык.Область действия локальной переменной начинается с первого утверждения после ее объявления и продолжается до последнего неотвратимого утверждения самого внутреннего блока,который включает в себя объявление.Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="64997c71b569a923ad45e14df6ef4a0a98b01aef" translate="yes" xml:space="preserve">
          <source>Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description.</source>
          <target state="translated">Lua-это мощный,эффективный,легкий,встраиваемый язык сценариев.Он поддерживает процедурное программирование,объектно-ориентированное программирование,функциональное программирование,программирование на основе данных и описание данных.</target>
        </trans-unit>
        <trans-unit id="6525b86788861e011c88cf07f7294dd56f02830d" translate="yes" xml:space="preserve">
          <source>Lua is free software, and is provided as usual with no guarantees, as stated in its license. The implementation described in this manual is available at Lua's official web site, &lt;code&gt;www.lua.org&lt;/code&gt;.</source>
          <target state="translated">Lua является бесплатным программным обеспечением и предоставляется, как обычно, без каких-либо гарантий, как указано в его лицензии. Реализация, описанная в этом руководстве, доступна на официальном веб-сайте &lt;code&gt;www.lua.org&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf89f8ce15263309be1a18939b1bc8b312081d0b" translate="yes" xml:space="preserve">
          <source>Lua is implemented as a library, written in &lt;em&gt;clean C&lt;/em&gt;, the common subset of Standard C and C++. The Lua distribution includes a host program called &lt;code&gt;lua&lt;/code&gt;, which uses the Lua library to offer a complete, standalone Lua interpreter, for interactive or batch use. Lua is intended to be used both as a powerful, lightweight, embeddable scripting language for any program that needs one, and as a powerful but lightweight and efficient stand-alone language.</source>
          <target state="translated">Lua реализован как библиотека, написанная на &lt;em&gt;чистом C&lt;/em&gt; , общем подмножестве Standard C и C ++. Дистрибутив Lua включает хост-программу под названием &lt;code&gt;lua&lt;/code&gt; , которая использует библиотеку Lua для предоставления полного автономного интерпретатора Lua для интерактивного или пакетного использования. Lua предназначен для использования как мощного, легкого, встраиваемого языка сценариев для любой программы, которая в нем нуждается, и как мощный, но легкий и эффективный автономный язык.</target>
        </trans-unit>
        <trans-unit id="766bf2f3607b0c894574e1db0930518cd452197d" translate="yes" xml:space="preserve">
          <source>Lua keeps a distinguished environment called the &lt;em&gt;global environment&lt;/em&gt;. This value is kept at a special index in the C registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). In Lua, the global variable &lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is initialized with this same value. (&lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is never used internally.)</source>
          <target state="translated">Lua поддерживает особую среду, называемую &lt;em&gt;глобальной средой&lt;/em&gt; . Это значение хранится в специальном индексе в реестре C (см. &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; ). В Lua глобальная переменная &lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt; инициализируется этим же значением. ( &lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt; никогда не используется внутри компании.)</target>
        </trans-unit>
        <trans-unit id="50a6344d2469ab6de8e8a3709a57a990d508f2b9" translate="yes" xml:space="preserve">
          <source>Lua performs automatic memory management. This means that you do not have to worry about allocating memory for new objects or freeing it when the objects are no longer needed. Lua manages memory automatically by running a &lt;em&gt;garbage collector&lt;/em&gt; to collect all &lt;em&gt;dead objects&lt;/em&gt; (that is, objects that are no longer accessible from Lua). All memory used by Lua is subject to automatic management: strings, tables, userdata, functions, threads, internal structures, etc.</source>
          <target state="translated">Lua выполняет автоматическое управление памятью. Это означает, что вам не нужно беспокоиться о выделении памяти для новых объектов или ее освобождении, когда объекты больше не нужны. Lua автоматически управляет памятью, запустив &lt;em&gt;сборщик мусора&lt;/em&gt; для сбора всех &lt;em&gt;мертвых объектов&lt;/em&gt; (то есть объектов, которые больше не доступны из Lua). Вся память, используемая Lua, подлежит автоматическому управлению: строки, таблицы, пользовательские данные, функции, потоки, внутренние структуры и т. Д.</target>
        </trans-unit>
        <trans-unit id="ff53c69b14f5a971156b01cea314fe8462f1fb40" translate="yes" xml:space="preserve">
          <source>Lua provides a &lt;em&gt;registry&lt;/em&gt;, a predefined table that can be used by any C code to store whatever Lua values it needs to store. The registry table is always located at pseudo-index &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt;&lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt;&lt;/a&gt;. Any C library can store data into this table, but it must take care to choose keys that are different from those used by other libraries, to avoid collisions. Typically, you should use as key a string containing your library name, or a light userdata with the address of a C object in your code, or any Lua object created by your code. As with variable names, string keys starting with an underscore followed by uppercase letters are reserved for Lua.</source>
          <target state="translated">Lua предоставляет &lt;em&gt;реестр&lt;/em&gt; , предопределенную таблицу, которая может использоваться любым кодом C для хранения любых значений Lua, которые ему необходимо сохранить. Таблица реестра всегда находится по псевдоиндексу &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt; &lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt; &lt;/a&gt; . Любая библиотека C может хранить данные в этой таблице, но она должна позаботиться о том, чтобы выбрать ключи, отличные от ключей, используемых другими библиотеками, чтобы избежать конфликтов. Как правило, вы должны использовать в качестве ключа строку, содержащую имя вашей библиотеки, или легкие пользовательские данные с адресом объекта C в вашем коде, или любого объекта Lua, созданного вашим кодом. Как и в случае с именами переменных, строковые ключи, начинающиеся с подчеркивания, за которым следуют прописные буквы, зарезервированы для Lua.</target>
        </trans-unit>
        <trans-unit id="8aebea72c222a51d9f5c90460286acb8ff7bd836" translate="yes" xml:space="preserve">
          <source>Lua provides some automatic conversions between some types and representations at run time. Bitwise operators always convert float operands to integers. Exponentiation and float division always convert integer operands to floats. All other arithmetic operations applied to mixed numbers (integers and floats) convert the integer operand to a float; this is called the &lt;em&gt;usual rule&lt;/em&gt;. The C API also converts both integers to floats and floats to integers, as needed. Moreover, string concatenation accepts numbers as arguments, besides strings.</source>
          <target state="translated">Lua обеспечивает автоматические преобразования между некоторыми типами и представлениями во время выполнения. Побитовые операторы всегда преобразуют операнды с плавающей запятой в целые числа. Возведение в степень и деление с плавающей запятой всегда преобразует целочисленные операнды в числа с плавающей запятой. Все остальные арифметические операции, применяемые к смешанным числам (целым числам и числам с плавающей запятой), преобразуют целочисленный операнд в число с плавающей запятой; это называется &lt;em&gt;обычным правилом&lt;/em&gt; . C API также при необходимости преобразует целые числа в числа с плавающей запятой и числа с плавающей запятой в целые числа. Более того, конкатенация строк принимает в качестве аргументов числа, помимо строк.</target>
        </trans-unit>
        <trans-unit id="fc88527d32d4eef52fab883602cc5a04e027d076" translate="yes" xml:space="preserve">
          <source>Lua supports an almost conventional set of statements, similar to those in Pascal or C. This set includes assignments, control structures, function calls, and variable declarations.</source>
          <target state="translated">Lua поддерживает почти обычный набор операторов,похожий на тот,что используется в Pascal или C.Этот набор включает в себя назначения,структуры управления,вызовы функций и объявления переменных.</target>
        </trans-unit>
        <trans-unit id="d24c360e7097470e8a9eb4284ea5f5a81791560b" translate="yes" xml:space="preserve">
          <source>Lua supports coroutines, also called &lt;em&gt;collaborative multithreading&lt;/em&gt;. A coroutine in Lua represents an independent thread of execution. Unlike threads in multithread systems, however, a coroutine only suspends its execution by explicitly calling a yield function.</source>
          <target state="translated">Lua поддерживает сопрограммы, также называемые &lt;em&gt;совместной многопоточностью&lt;/em&gt; . Сопрограмма в Lua представляет собой независимый поток выполнения. Однако, в отличие от потоков в многопоточных системах, сопрограмма приостанавливает свое выполнение только путем явного вызова функции yield.</target>
        </trans-unit>
        <trans-unit id="3591c85e3de8f7bdc4a45d500a8261a9e6ec09be" translate="yes" xml:space="preserve">
          <source>Lua supports the following arithmetic operators:</source>
          <target state="translated">Lua поддерживает следующие арифметические операторы:</target>
        </trans-unit>
        <trans-unit id="f0e5bf2dcec5e267f3660839f8aee19d34a65569" translate="yes" xml:space="preserve">
          <source>Lua supports the following bitwise operators:</source>
          <target state="translated">Lua поддерживает следующие битовые операторы:</target>
        </trans-unit>
        <trans-unit id="681beb7c86ad47856fd70c3b7329189c44c67f13" translate="yes" xml:space="preserve">
          <source>Lua supports the following relational operators:</source>
          <target state="translated">Lua поддерживает следующие реляционные операторы:</target>
        </trans-unit>
        <trans-unit id="ea7647f42e558dda5334904038fac1e7ced0aeee" translate="yes" xml:space="preserve">
          <source>Lua treats the continuation function as if it were the original function. The continuation function receives the same Lua stack from the original function, in the same state it would be if the callee function had returned. (For instance, after a &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; the function and its arguments are removed from the stack and replaced by the results from the call.) It also has the same upvalues. Whatever it returns is handled by Lua as if it were the return of the original function.</source>
          <target state="translated">Lua обрабатывает функцию продолжения, как если бы это была исходная функция. Функция продолжения получает тот же стек Lua от исходной функции, в том же состоянии, которое было бы, если бы вызываемая функция вернулась. (Например, после &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; функция и ее аргументы удаляются из стека и заменяются результатами вызова.) Она также имеет те же самые высокие значения. Все, что он возвращает, обрабатывается Lua, как если бы это был возврат исходной функции.</target>
        </trans-unit>
        <trans-unit id="8d18554a7115d65153a0cecb32181cd5cd13b803" translate="yes" xml:space="preserve">
          <source>Lua uses a &lt;em&gt;virtual stack&lt;/em&gt; to pass values to and from C. Each element in this stack represents a Lua value (&lt;b&gt;nil&lt;/b&gt;, number, string, etc.). Functions in the API can access this stack through the Lua state parameter that they receive.</source>
          <target state="translated">Lua использует &lt;em&gt;виртуальный стек&lt;/em&gt; для передачи значений в и из C. Каждый элемент в этом стеке представляет значение Lua ( &lt;b&gt;ноль&lt;/b&gt; , число, строка и т. Д.). Функции в API могут обращаться к этому стеку через параметр состояния Lua, который они получают.</target>
        </trans-unit>
        <trans-unit id="225017af8d199117d297936391565191b16afd75" translate="yes" xml:space="preserve">
          <source>Lua versions can always change the C API in ways that do not imply source-code changes in a program, such as the numeric values for constants or the implementation of functions as macros. Therefore, you should not assume that binaries are compatible between different Lua versions. Always recompile clients of the Lua API when using a new version.</source>
          <target state="translated">Версии Lua всегда могут изменять C API таким образом,чтобы не подразумевать изменения исходного кода программы,например,числовые значения для констант или реализацию функций в виде макросов.Следовательно,не следует предполагать,что двоичные файлы совместимы между различными версиями Lua.Всегда перекомпилируйте клиентов Lua API при использовании новой версии.</target>
        </trans-unit>
        <trans-unit id="d9819702e70f7dce9f1483706cfae2f70bcb9e32" translate="yes" xml:space="preserve">
          <source>Macros to project non-default integer types (&lt;code&gt;luaL_checkint&lt;/code&gt;, &lt;code&gt;luaL_optint&lt;/code&gt;, &lt;code&gt;luaL_checklong&lt;/code&gt;, &lt;code&gt;luaL_optlong&lt;/code&gt;) were deprecated. Use their equivalent over &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt; with a type cast (or, when possible, use &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt; in your code).</source>
          <target state="translated">Макросы для проецирования нестандартных целочисленных типов ( &lt;code&gt;luaL_checkint&lt;/code&gt; , &lt;code&gt;luaL_optint&lt;/code&gt; , &lt;code&gt;luaL_checklong&lt;/code&gt; , &lt;code&gt;luaL_optlong&lt;/code&gt; ) устарели. Используйте их эквивалент &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; с приведением типа (или, если возможно, используйте &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; в своем коде).</target>
        </trans-unit>
        <trans-unit id="b77ee37c1b7bd6807618cb75d302c1c6fbf5df15" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;n1&lt;/code&gt;-th upvalue of the Lua closure &lt;code&gt;f1&lt;/code&gt; refer to the &lt;code&gt;n2&lt;/code&gt;-th upvalue of the Lua closure &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">Сделайте &lt;code&gt;n1&lt;/code&gt; -е повышающее значение замыкания Lua &lt;code&gt;f1&lt;/code&gt; ссылкой на &lt;code&gt;n2&lt;/code&gt; -е повышающее значение замыкания Lua &lt;code&gt;f2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62787e3133e3f8c1540f23ea948a696e338e2fa1" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;n1&lt;/code&gt;-th upvalue of the Lua closure at index &lt;code&gt;funcindex1&lt;/code&gt; refer to the &lt;code&gt;n2&lt;/code&gt;-th upvalue of the Lua closure at index &lt;code&gt;funcindex2&lt;/code&gt;.</source>
          <target state="translated">Сделайте &lt;code&gt;n1&lt;/code&gt; -е восходящее значение закрытия Lua по индексу &lt;code&gt;funcindex1&lt;/code&gt; ссылкой на &lt;code&gt;n2&lt;/code&gt; -е восходящее значение закрытия Lua по индексу &lt;code&gt;funcindex2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0580c95da4f3ceb84abf5c18ee164021809ea4c" translate="yes" xml:space="preserve">
          <source>Metatables and Metamethods</source>
          <target state="translated">Метаматериалы и метаметоды</target>
        </trans-unit>
        <trans-unit id="4feff686bfbdf59cf154d1294db67c187b9f7489" translate="yes" xml:space="preserve">
          <source>Modulo is defined as the remainder of a division that rounds the quotient towards minus infinity (floor division).</source>
          <target state="translated">Модуло определяется как остаток деления,который округляет коэффициент в сторону минус бесконечности (деление на этаж).</target>
        </trans-unit>
        <trans-unit id="71e2b3ce8af16f1677267e51894cb5b57ee61429" translate="yes" xml:space="preserve">
          <source>Moreover, with a &lt;code&gt;count&lt;/code&gt; different from zero, the hook is called also after every &lt;code&gt;count&lt;/code&gt; instructions.</source>
          <target state="translated">Более того, с &lt;code&gt;count&lt;/code&gt; отличным от нуля, ловушка вызывается также после каждой команды &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68a5432576b0a8367df52ec04ef603f754149162" translate="yes" xml:space="preserve">
          <source>Most functions in the API can raise an error, for instance due to a memory allocation error. The documentation for each function indicates whether it can raise errors.</source>
          <target state="translated">Большинство функций в API могут вызвать ошибку,например,из-за ошибки выделения памяти.Документация по каждой функции указывает,может ли она вызвать ошибку.</target>
        </trans-unit>
        <trans-unit id="211349efeacad71bfc6580d063e630f7c7ac8b51" translate="yes" xml:space="preserve">
          <source>Moves elements from table &lt;code&gt;a1&lt;/code&gt; to table &lt;code&gt;a2&lt;/code&gt;, performing the equivalent to the following multiple assignment: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt;. The default for &lt;code&gt;a2&lt;/code&gt; is &lt;code&gt;a1&lt;/code&gt;. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.</source>
          <target state="translated">Перемещает элементы из таблицы &lt;code&gt;a1&lt;/code&gt; в таблицу &lt;code&gt;a2&lt;/code&gt; , выполняя эквивалент следующего множественного присваивания: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt; . Значение по умолчанию для &lt;code&gt;a2&lt;/code&gt; - &lt;code&gt;a1&lt;/code&gt; . Диапазон назначения может перекрываться с диапазоном источника. Количество перемещаемых элементов должно соответствовать целому числу Lua.</target>
        </trans-unit>
        <trans-unit id="7f2bdd0bd3d59fce772f98ee9eb7eb0b3b6d4a93" translate="yes" xml:space="preserve">
          <source>Moves the top element into the given valid index without shifting any element (therefore replacing the value at that given index), and then pops the top element.</source>
          <target state="translated">Перемещает верхний элемент в заданный действительный индекс,не смещая ни одного элемента (таким образом,заменяя значение в этом индексе),а затем всплывает верхний элемент.</target>
        </trans-unit>
        <trans-unit id="4e0c82df95dd4d912151141c645e29919783b9cd" translate="yes" xml:space="preserve">
          <source>Moves the top element into the given valid index, shifting up the elements above this index to open space. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">Перемещает верхний элемент в заданный действующий индекс,сдвигая вверх элементы,находящиеся выше этого индекса,в открытое пространство.Эта функция не может быть вызвана с помощью псевдоиндекса,так как псевдоиндекс не является фактической позицией стека.</target>
        </trans-unit>
        <trans-unit id="53b225abd3f0033a18a8e56044eee89e7ebbd191" translate="yes" xml:space="preserve">
          <source>Name denotes identifiers, as defined in &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;.</source>
          <target state="translated">Имя обозначает идентификаторы, как определено в &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fb92775055c34d37036245800bd4e66793f8802" translate="yes" xml:space="preserve">
          <source>Note that Standard C ensures that &lt;code&gt;free(NULL)&lt;/code&gt; has no effect and that &lt;code&gt;realloc(NULL,size)&lt;/code&gt; is equivalent to &lt;code&gt;malloc(size)&lt;/code&gt;. This code assumes that &lt;code&gt;realloc&lt;/code&gt; does not fail when shrinking a block. (Although Standard C does not ensure this behavior, it seems to be a safe assumption.)</source>
          <target state="translated">Обратите внимание, что стандарт C гарантирует, что &lt;code&gt;free(NULL)&lt;/code&gt; имеет никакого эффекта и что &lt;code&gt;realloc(NULL,size)&lt;/code&gt; эквивалентен &lt;code&gt;malloc(size)&lt;/code&gt; . Этот код предполагает, что при сжатии блока не происходит сбоя &lt;code&gt;realloc&lt;/code&gt; . (Хотя стандарт C не обеспечивает такого поведения, это кажется безопасным предположением.)</target>
        </trans-unit>
        <trans-unit id="7a567518fb3007e639daf24d7ac35ede7aba1d84" translate="yes" xml:space="preserve">
          <source>Note that commands for &lt;code&gt;debug.debug&lt;/code&gt; are not lexically nested within any function and so have no direct access to local variables.</source>
          <target state="translated">Обратите внимание, что команды для &lt;code&gt;debug.debug&lt;/code&gt; лексически не вложены в какую-либо функцию и поэтому не имеют прямого доступа к локальным переменным.</target>
        </trans-unit>
        <trans-unit id="a3819f26854d326b0f73d55f7e4a2133dc45716a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;comp&lt;/code&gt; function must define a strict partial order over the elements in the list; that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.</source>
          <target state="translated">Обратите внимание, что функция &lt;code&gt;comp&lt;/code&gt; должна определять строгий частичный порядок элементов в списке; то есть он должен быть асимметричным и транзитивным. В противном случае невозможна правильная сортировка.</target>
        </trans-unit>
        <trans-unit id="1dab5c0bc6e3b7d33e45552977787711c9e9cd82" translate="yes" xml:space="preserve">
          <source>Note that the code above is &lt;em&gt;balanced&lt;/em&gt;: at its end, the stack is back to its original configuration. This is considered good programming practice.</source>
          <target state="translated">Обратите внимание, что приведенный выше код &lt;em&gt;сбалансирован&lt;/em&gt; : в его конце стек возвращается к своей исходной конфигурации. Это считается хорошей практикой программирования.</target>
        </trans-unit>
        <trans-unit id="f095d9ef1108e5d2ebeb20830f7a9cdf31641d73" translate="yes" xml:space="preserve">
          <source>Note the external, explicit call to the continuation: Lua will call the continuation only if needed, that is, in case of errors or resuming after a yield. If the called function returns normally without ever yielding, &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;) will also return normally. (Of course, instead of calling the continuation in that case, you can do the equivalent work directly inside the original function.)</source>
          <target state="translated">Обратите внимание на внешний явный вызов продолжения: Lua вызовет продолжение только в случае необходимости, то есть в случае ошибок или возобновления после yield. Если вызываемая функция нормально возвращается без каких-либо изменений, &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; (и &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; ) также вернется нормально. (Конечно, вместо вызова продолжения в этом случае вы можете выполнить аналогичную работу непосредственно внутри исходной функции.)</target>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="translated">Обратите внимание на следующее:</target>
        </trans-unit>
        <trans-unit id="143069908049a001ca51a83cef0a8d3fcbe11397" translate="yes" xml:space="preserve">
          <source>Notice that each execution of a &lt;b&gt;local&lt;/b&gt; statement defines new local variables. Consider the following example:</source>
          <target state="translated">Обратите внимание, что каждое выполнение &lt;b&gt;локального&lt;/b&gt; оператора определяет новые локальные переменные. Рассмотрим следующий пример:</target>
        </trans-unit>
        <trans-unit id="fcc164423a09d2953e5486a056f1e10293de0711" translate="yes" xml:space="preserve">
          <source>Notice that, in a declaration like &lt;code&gt;local x = x&lt;/code&gt;, the new &lt;code&gt;x&lt;/code&gt; being declared is not in scope yet, and so the second &lt;code&gt;x&lt;/code&gt; refers to the outside variable.</source>
          <target state="translated">Обратите внимание, что в таком объявлении, как &lt;code&gt;local x = x&lt;/code&gt; , новый объявляемый &lt;code&gt;x&lt;/code&gt; еще не входит в область видимости, и поэтому второй &lt;code&gt;x&lt;/code&gt; относится к внешней переменной.</target>
        </trans-unit>
        <trans-unit id="d213f09117ec25cd2306bbea812a90e0c2b8aabb" translate="yes" xml:space="preserve">
          <source>Now we want to allow the Lua code being run by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; to yield. First, we can rewrite our function like here:</source>
          <target state="translated">Теперь мы хотим разрешить выполнение кода Lua с помощью &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; . Во-первых, мы можем переписать нашу функцию, как здесь:</target>
        </trans-unit>
        <trans-unit id="754d929d0f6f3e09a813d3e11d5cb6448eada594" translate="yes" xml:space="preserve">
          <source>Numerals and literal strings are explained in &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;; variables are explained in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt;; function definitions are explained in &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;; function calls are explained in &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;; table constructors are explained in &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;. Vararg expressions, denoted by three dots ('&lt;code&gt;...&lt;/code&gt;'), can only be used when directly inside a vararg function; they are explained in &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;.</source>
          <target state="translated">Цифры и буквальные строки объяснены в &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; ; переменные объясняются в &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; ; определения функций объяснены в &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; ; вызовы функций объясняются в &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; ; конструкторы таблиц объяснены в &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt; . Выражения Vararg, обозначенные тремя точками (' &lt;code&gt;...&lt;/code&gt; '), могут использоваться только непосредственно внутри функции vararg; они объяснены в &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ef3b305c58fad6f6199b8fc85c384f4f0aec1bf" translate="yes" xml:space="preserve">
          <source>Numeric codes are not necessarily portable across platforms.</source>
          <target state="translated">Цифровые коды не обязательно переносятся между платформами.</target>
        </trans-unit>
        <trans-unit id="b1e9a773eef8de621ab2c2acf9814098928b38f7" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).</source>
          <target state="translated">В системах POSIX эта функция также создает файл с таким именем,чтобы избежать рисков безопасности.(Кто-то другой может создать файл с неправильными разрешениями за время между получением имени и созданием файла).Вы все равно должны открыть файл,чтобы использовать его и удалить (даже если вы его не используете).</target>
        </trans-unit>
        <trans-unit id="b4eb9b31d3cdaa19214342b44ace3c1948a9b1c8" translate="yes" xml:space="preserve">
          <source>On non-POSIX systems, this function may be not thread safe because of its reliance on C function &lt;code&gt;gmtime&lt;/code&gt; and C function &lt;code&gt;localtime&lt;/code&gt;.</source>
          <target state="translated">В системах, отличных от POSIX, эта функция может быть небезопасной для потоков из-за ее зависимости от функции C &lt;code&gt;gmtime&lt;/code&gt; и функции C &lt;code&gt;localtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="087e8ef073a71f75716b2985ce5b0a8533e700f2" translate="yes" xml:space="preserve">
          <source>Once a loader is found, &lt;code&gt;require&lt;/code&gt; calls the loader with two arguments: &lt;code&gt;modname&lt;/code&gt; and an extra value dependent on how it got the loader. (If the loader came from a file, this extra value is the file name.) If the loader returns any non-nil value, &lt;code&gt;require&lt;/code&gt; assigns the returned value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;. If the loader does not return a non-nil value and has not assigned any value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, then &lt;code&gt;require&lt;/code&gt; assigns &lt;b&gt;true&lt;/b&gt; to this entry. In any case, &lt;code&gt;require&lt;/code&gt; returns the final value of &lt;code&gt;package.loaded[modname]&lt;/code&gt;.</source>
          <target state="translated">Как только загрузчик найден, &lt;code&gt;require&lt;/code&gt; вызывает загрузчик с двумя аргументами: имя &lt;code&gt;modname&lt;/code&gt; и дополнительное значение, зависящее от того, как он получил загрузчик. (Если загрузчик был получен из файла, это дополнительное значение является именем файла.) Если загрузчик возвращает любое значение, &lt;code&gt;package.loaded[modname]&lt;/code&gt; nil, &lt;code&gt;require&lt;/code&gt; присваивает возвращенное значение package.loaded [имя модуля] . Если загрузчик не возвращает значение, &lt;code&gt;package.loaded[modname]&lt;/code&gt; nil, и не присвоил никакого значения package.loaded [modname] , то &lt;code&gt;require&lt;/code&gt; присваивает этой записи значение &lt;b&gt;true&lt;/b&gt; . В любом случае &lt;code&gt;require&lt;/code&gt; возвращает окончательное значение &lt;code&gt;package.loaded[modname]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd79eaea9e398294fa6609bcc37919375540b811" translate="yes" xml:space="preserve">
          <source>Only objects that have an explicit construction are removed from weak tables. Values, such as numbers and light C functions, are not subject to garbage collection, and therefore are not removed from weak tables (unless their associated values are collected). Although strings are subject to garbage collection, they do not have an explicit construction, and therefore are not removed from weak tables.</source>
          <target state="translated">Из слабых таблиц удаляются только объекты,имеющие явное построение.Такие значения,как числа и светлые функции C,не подлежат сбору мусора,и поэтому не удаляются из слабых таблиц (если только не собираются связанные с ними значения).Хотя строки подлежат сбору мусора,они не имеют явной конструкции и поэтому не удаляются из слабых таблиц.</target>
        </trans-unit>
        <trans-unit id="b08de619674921c221a144a642faade8131401ce" translate="yes" xml:space="preserve">
          <source>Opens all standard Lua libraries into the given state.</source>
          <target state="translated">Открывает все стандартные библиотеки Lua в данном состоянии.</target>
        </trans-unit>
        <trans-unit id="fed8115b8cb0d575a6d2ddd5024ea0f4b7c2651d" translate="yes" xml:space="preserve">
          <source>Opens the given file name in read mode and returns an iterator function that works like &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; over the opened file. When the iterator function detects the end of file, it returns no values (to finish the loop) and automatically closes the file.</source>
          <target state="translated">Открывает файл с заданным именем в режиме чтения и возвращает функцию итератора, которая работает как &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; поверх открытого файла. Когда функция итератора определяет конец файла, она не возвращает значений (для завершения цикла) и автоматически закрывает файл.</target>
        </trans-unit>
        <trans-unit id="4996bd3a029769976e9b98ed2378b1547c48ce7d" translate="yes" xml:space="preserve">
          <source>Opens the named file and executes its contents as a Lua chunk. When called without arguments, &lt;code&gt;dofile&lt;/code&gt; executes the contents of the standard input (&lt;code&gt;stdin&lt;/code&gt;). Returns all values returned by the chunk. In case of errors, &lt;code&gt;dofile&lt;/code&gt; propagates the error to its caller (that is, &lt;code&gt;dofile&lt;/code&gt; does not run in protected mode).</source>
          <target state="translated">Открывает названный файл и выполняет его содержимое как блок Lua. При вызове без аргументов &lt;code&gt;dofile&lt;/code&gt; выполняет содержимое стандартного ввода ( &lt;code&gt;stdin&lt;/code&gt; ). Возвращает все значения, возвращаемые чанком. В случае ошибок &lt;code&gt;dofile&lt;/code&gt; передает ошибку вызывающей &lt;code&gt;dofile&lt;/code&gt; (то есть dofile не работает в защищенном режиме).</target>
        </trans-unit>
        <trans-unit id="1b77184a8e40f826198903ec77c88ff94fba7356" translate="yes" xml:space="preserve">
          <source>Operator precedence in Lua follows the table below, from lower to higher priority:</source>
          <target state="translated">Приоритет оператора в Lua следует из нижеследующей таблицы,от более низкого к более высокому приоритету:</target>
        </trans-unit>
        <trans-unit id="5d68118be76331913c2ce7bb079ac0bdce1e02a7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;s&lt;/code&gt; expects a string; if its argument is not a string, it is converted to one following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;. If the option has any modifier (flags, width, length), the string argument should not contain embedded zeros.</source>
          <target state="translated">Вариант &lt;code&gt;s&lt;/code&gt; ожидает строку; если его аргумент не является строкой, он преобразуется в аргумент по тем же правилам &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; . Если параметр имеет какой-либо модификатор (флаги, ширина, длина), строковый аргумент не должен содержать встроенных нулей.</target>
        </trans-unit>
        <trans-unit id="87ca1fbe6a8feba28ed3fc6964e861a77643303f" translate="yes" xml:space="preserve">
          <source>Option names in &lt;a href=&quot;#pdf-io.read&quot;&gt;&lt;code&gt;io.read&lt;/code&gt;&lt;/a&gt; do not have a starting '&lt;code&gt;*&lt;/code&gt;' anymore. For compatibility, Lua will continue to accept (and ignore) this character.</source>
          <target state="translated">Имена параметров в &lt;a href=&quot;#pdf-io.read&quot;&gt; &lt;code&gt;io.read&lt;/code&gt; &lt;/a&gt; больше не имеют начального символа &amp;laquo; &lt;code&gt;*&lt;/code&gt; &amp;raquo;. Для совместимости Lua продолжит принимать (и игнорировать) этот символ.</target>
        </trans-unit>
        <trans-unit id="b8e36de59136b88fc2be5c019f1c1af0d901d853" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, and &lt;code&gt;g&lt;/code&gt; all expect a number as argument. Options &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; expect an integer. When Lua is compiled with a C89 compiler, options &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats) do not support any modifier (flags, width, length).</source>
          <target state="translated">Все варианты &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; и &lt;code&gt;g&lt;/code&gt; предполагают число в качестве аргумента. Опции &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; и &lt;code&gt;x&lt;/code&gt; предполагают целое число. Когда Lua компилируется с помощью компилятора C89, параметры &lt;code&gt;A&lt;/code&gt; и &lt;code&gt;a&lt;/code&gt; (шестнадцатеричные числа с плавающей запятой) не поддерживают никаких модификаторов (флаги, ширина, длина).</target>
        </trans-unit>
        <trans-unit id="8a1abeaa4ebe74d5340ad5d927126ab129362a92" translate="yes" xml:space="preserve">
          <source>Otherwise, returns three values: the &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; function, the table &lt;code&gt;t&lt;/code&gt;, and &lt;b&gt;nil&lt;/b&gt;, so that the construction</source>
          <target state="translated">В противном случае возвращает три значения: &lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; функция, таблица &lt;code&gt;t&lt;/code&gt; и &lt;b&gt;nil&lt;/b&gt; , так что конструкция</target>
        </trans-unit>
        <trans-unit id="178c0a8da555da3fb52bb9fe10047627cb505e75" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;ar&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;ar&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; такие же, как в функции &lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea29796519b03e49b8f299281d87fde989109ec" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;n&lt;/code&gt; cannot be greater than the number of upvalues.</source>
          <target state="translated">Параметры &lt;code&gt;funcindex&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; такие же, как в функции &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; , но &lt;code&gt;n&lt;/code&gt; не может быть больше, чем количество повышающих значений.</target>
        </trans-unit>
        <trans-unit id="430e32c1c643e4f1d035c6b28b1a7ed4bf4a0eac" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Параметры &lt;code&gt;funcindex&lt;/code&gt; и &lt;code&gt;n&lt;/code&gt; такие же, как в функции &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed5ec09aef437013e06ea8a8354f4fd26022ed2a" translate="yes" xml:space="preserve">
          <source>Parameters act as local variables that are initialized with the argument values:</source>
          <target state="translated">Параметры действуют как локальные переменные,которые инициализируются значениями аргументов:</target>
        </trans-unit>
        <trans-unit id="448ecaf1d946410d7f3122c5e30729943106812b" translate="yes" xml:space="preserve">
          <source>Pattern Item:</source>
          <target state="translated">Элемент узора:</target>
        </trans-unit>
        <trans-unit id="5da899e9024f2b8d94cc4514fe33d4ff85310e83" translate="yes" xml:space="preserve">
          <source>Pattern:</source>
          <target state="translated">Pattern:</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="8d2dcea1a0ef2ec1d9376ec9b8afe27c3f59c3e3" translate="yes" xml:space="preserve">
          <source>Patterns in Lua are described by regular strings, which are interpreted as patterns by the pattern-matching functions &lt;a href=&quot;#pdf-string.find&quot;&gt;&lt;code&gt;string.find&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.gmatch&quot;&gt;&lt;code&gt;string.gmatch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.gsub&quot;&gt;&lt;code&gt;string.gsub&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-string.match&quot;&gt;&lt;code&gt;string.match&lt;/code&gt;&lt;/a&gt;. This section describes the syntax and the meaning (that is, what they match) of these strings.</source>
          <target state="translated">Шаблоны в Lua описываются обычными строками, которые интерпретируются как шаблоны функциями сопоставления &lt;a href=&quot;#pdf-string.find&quot;&gt; &lt;code&gt;string.find&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.gmatch&quot;&gt; &lt;code&gt;string.gmatch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.gsub&quot;&gt; &lt;code&gt;string.gsub&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#pdf-string.match&quot;&gt; &lt;code&gt;string.match&lt;/code&gt; &lt;/a&gt; . В этом разделе описывается синтаксис и значение (то есть то, что они соответствуют) этих строк.</target>
        </trans-unit>
        <trans-unit id="dc7394297e26f026260d375d7cd96592fbd9339e" translate="yes" xml:space="preserve">
          <source>Performs an arithmetic or bitwise operation over the two values (or one, in the case of negations) at the top of the stack, with the value at the top being the second operand, pops these values, and pushes the result of the operation. The function follows the semantics of the corresponding Lua operator (that is, it may call metamethods).</source>
          <target state="translated">Выполняет арифметическую или побитовую операцию над двумя значениями (или одним,в случае отрицаний)в верхней части стека,при этом значение в верхней части является вторым операндом,выталкивает эти значения и выталкивает результат операции.Функция следует семантике соответствующего оператора Lua (то есть может вызывать метаметоды).</target>
        </trans-unit>
        <trans-unit id="1299b0bc498833db75f9cf0fffff3c4bae0facff" translate="yes" xml:space="preserve">
          <source>Pops &lt;code&gt;n&lt;/code&gt; elements from the stack.</source>
          <target state="translated">Извлекает &lt;code&gt;n&lt;/code&gt; элементов из стека.</target>
        </trans-unit>
        <trans-unit id="fcc747279637a2d8a447881433d9aea7cb9cb559" translate="yes" xml:space="preserve">
          <source>Pops a key from the stack, and pushes a key&amp;ndash;value pair from the table at the given index (the &quot;next&quot; pair after the given key). If there are no more elements in the table, then &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; returns 0 (and pushes nothing).</source>
          <target state="translated">Извлекает ключ из стека и выталкивает пару ключ-значение из таблицы по заданному индексу (&amp;laquo;следующая&amp;raquo; пара после заданного ключа). Если в таблице больше нет элементов, &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt; возвращает 0 (и ничего не отправляет ).</target>
        </trans-unit>
        <trans-unit id="38ce2b2d648784be385652bd2405ecdc4f5fbdbc" translate="yes" xml:space="preserve">
          <source>Pops a table from the stack and sets it as the new metatable for the value at the given index.</source>
          <target state="translated">Выводит таблицу из стека и устанавливает ее в качестве новой метастабилизации для значения в данном индексе.</target>
        </trans-unit>
        <trans-unit id="9e0a9d18a088445b817b9df7884bfcb32d185882" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new value associated to the full userdata at the given index.</source>
          <target state="translated">Выводит значение из стека и устанавливает его в качестве нового значения,связанного с полными пользовательскими данными в данном индексе.</target>
        </trans-unit>
        <trans-unit id="e2b2f785858d2ccd19fa2b3c3174e4f53334d580" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new value of global &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">Извлекает значение из стека и устанавливает его как новое значение глобального &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="6069e3ce33f065015c2dc7cf19747d682b66d1cb" translate="yes" xml:space="preserve">
          <source>Pushes a C function onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type &lt;code&gt;function&lt;/code&gt; that, when called, invokes the corresponding C function.</source>
          <target state="translated">Помещает функцию C в стек. Эта функция получает указатель на функцию C и помещает в стек значение Lua типа &lt;code&gt;function&lt;/code&gt; , которое при вызове вызывает соответствующую функцию C.</target>
        </trans-unit>
        <trans-unit id="225557cebb89115cc93c59763f61b47f6e9246c5" translate="yes" xml:space="preserve">
          <source>Pushes a boolean value with value &lt;code&gt;b&lt;/code&gt; onto the stack.</source>
          <target state="translated">Помещает логическое значение со значением &lt;code&gt;b&lt;/code&gt; в стек.</target>
        </trans-unit>
        <trans-unit id="894000f061d35d3982475e83383dc72799631571" translate="yes" xml:space="preserve">
          <source>Pushes a copy of the element at the given index onto the stack.</source>
          <target state="translated">Выталкивает копию элемента в данном индексе на стек.</target>
        </trans-unit>
        <trans-unit id="b6ff7b2e435c0e0bd4a4dbe8af13548197a7ba1c" translate="yes" xml:space="preserve">
          <source>Pushes a float with value &lt;code&gt;n&lt;/code&gt; onto the stack.</source>
          <target state="translated">Помещает в стек поплавок со значением &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b7c742fb6acbbb7614fff04126bb1d65108509f" translate="yes" xml:space="preserve">
          <source>Pushes a light userdata onto the stack.</source>
          <target state="translated">Выталкивает легкие пользовательские данные на стек.</target>
        </trans-unit>
        <trans-unit id="f9640c606650c6c3b185fb6d556165b919470195" translate="yes" xml:space="preserve">
          <source>Pushes a new C closure onto the stack.</source>
          <target state="translated">Толкает новое закрытие C на стопку.</target>
        </trans-unit>
        <trans-unit id="f1a59444f671b252069eb2dc564dace63fe90d50" translate="yes" xml:space="preserve">
          <source>Pushes a nil value onto the stack.</source>
          <target state="translated">Толкает нулевое значение в стек.</target>
        </trans-unit>
        <trans-unit id="2ac334edd538c29ffe856d049cab16b02559c4e6" translate="yes" xml:space="preserve">
          <source>Pushes an integer with value &lt;code&gt;n&lt;/code&gt; onto the stack.</source>
          <target state="translated">Помещает целое число со значением &lt;code&gt;n&lt;/code&gt; в стек.</target>
        </trans-unit>
        <trans-unit id="ebf2182a4bd44a4ababe6986cdc0d46624511d6f" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a formatted string and returns a pointer to this string. It is similar to the ISO C function &lt;code&gt;sprintf&lt;/code&gt;, but has some important differences:</source>
          <target state="translated">Помещает в стек отформатированную строку и возвращает указатель на эту строку. Она похожа на функцию &lt;code&gt;sprintf&lt;/code&gt; ISO C , но имеет некоторые важные отличия:</target>
        </trans-unit>
        <trans-unit id="e3eb6979dbbec2441c887e7c302c341c3e2193b2" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a string identifying the current position of the control at level &lt;code&gt;lvl&lt;/code&gt; in the call stack. Typically this string has the following format:</source>
          <target state="translated">Помещает в стек строку, определяющую текущую позицию элемента управления на уровне &lt;code&gt;lvl&lt;/code&gt; в стеке вызовов. Обычно эта строка имеет следующий формат:</target>
        </trans-unit>
        <trans-unit id="1400d6038d9c13c6266dab4b80bdcdd7fc31a04b" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the Lua value associated with the full userdata at the given index.</source>
          <target state="translated">Выталкивает в стек значение Lua,связанное с полными пользовательскими данными в данном индексе.</target>
        </trans-unit>
        <trans-unit id="96d78a717bd5f3b49461732d2e8f02559185b11e" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the field &lt;code&gt;e&lt;/code&gt; from the metatable of the object at index &lt;code&gt;obj&lt;/code&gt; and returns the type of pushed value. If the object does not have a metatable, or if the metatable does not have this field, pushes nothing and returns &lt;code&gt;LUA_TNIL&lt;/code&gt;.</source>
          <target state="translated">Помещает в стек поле &lt;code&gt;e&lt;/code&gt; из метатаблицы объекта по индексу &lt;code&gt;obj&lt;/code&gt; и возвращает тип переданного значения. Если у объекта нет метатаблицы или если метатаблица не имеет этого поля, ничего не &lt;code&gt;LUA_TNIL&lt;/code&gt; и возвращает LUA_TNIL .</target>
        </trans-unit>
        <trans-unit id="e6a3ae7b655cf9df13c5b9cf6975aa8b58442402" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) (&lt;b&gt;nil&lt;/b&gt; if there is no metatable associated with that name). Returns the type of the pushed value.</source>
          <target state="translated">Помещает в стек метатаблицу, связанную с именем &lt;code&gt;tname&lt;/code&gt; в реестре (см. &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; ) ( &lt;b&gt;ноль,&lt;/b&gt; если нет метатаблицы, связанной с этим именем). Возвращает тип переданного значения.</target>
        </trans-unit>
        <trans-unit id="3681d4e1cdd569fb3b2f3300755bb4d0cfb69c67" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[i]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Помещает в стек значение &lt;code&gt;t[i]&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - значение по данному индексу. Как и в Lua, эта функция может запускать метаметод для события &quot;index&quot; (см. &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="160cbb51fcadb575239ec804bbd26447a616f853" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;k&lt;/code&gt; is the pointer &lt;code&gt;p&lt;/code&gt; represented as a light userdata. The access is raw; that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</source>
          <target state="translated">Помещает в стек значение &lt;code&gt;t[k]&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - таблица с заданным индексом, а &lt;code&gt;k&lt;/code&gt; - указатель &lt;code&gt;p&lt;/code&gt; , представленный как легкие пользовательские данные. Доступ сырой; то есть он не вызывает &lt;code&gt;__index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ba28c13e89d272d19c50f5e767726525d936e21" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;k&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">Помещает в стек значение &lt;code&gt;t[k]&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - значение по данному индексу, а &lt;code&gt;k&lt;/code&gt; - значение наверху стека.</target>
        </trans-unit>
        <trans-unit id="d433d1f4953100bc2a0c9d7a8e8e092f7c0a5c2a" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Помещает в стек значение &lt;code&gt;t[k]&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - значение по данному индексу. Как и в Lua, эта функция может запускать метаметод для события &quot;index&quot; (см. &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="27c3e32a80e22fb604cbe4557acc820d3c5231a7" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[n]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index. The access is raw, that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</source>
          <target state="translated">Помещает в стек значение &lt;code&gt;t[n]&lt;/code&gt; , где &lt;code&gt;t&lt;/code&gt; - таблица по данному индексу. Доступ является необработанным, то есть не вызывает &lt;code&gt;__index&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3adeb92584bb85f61e3f56627b5522106f4dd7b4" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value of the global &lt;code&gt;name&lt;/code&gt;. Returns the type of that value.</source>
          <target state="translated">Помещает в стек значение глобального &lt;code&gt;name&lt;/code&gt; . Возвращает тип этого значения.</target>
        </trans-unit>
        <trans-unit id="96bb89f8fd253dc6a3b3b23f64ce3135d6817db4" translate="yes" xml:space="preserve">
          <source>Pushes the global environment onto the stack.</source>
          <target state="translated">Выталкивает глобальную окружающую среду в стек.</target>
        </trans-unit>
        <trans-unit id="b8b8e3282a4a6ab4f3ed7c29929c1ea38215b0e1" translate="yes" xml:space="preserve">
          <source>Pushes the string pointed to by &lt;code&gt;s&lt;/code&gt; with size &lt;code&gt;len&lt;/code&gt; onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns. The string can contain any binary data, including embedded zeros.</source>
          <target state="translated">Помещает строку, на которую указывает &lt;code&gt;s&lt;/code&gt; , размером &lt;code&gt;len&lt;/code&gt; в стек. Lua создает (или повторно использует) внутреннюю копию заданной строки, поэтому память в &lt;code&gt;s&lt;/code&gt; может быть освобождена или повторно использована сразу после возврата из функции. Строка может содержать любые двоичные данные, включая встроенные нули.</target>
        </trans-unit>
        <trans-unit id="b6b66a7bc8fe80fa098dee231f5eaec5a6ccedfa" translate="yes" xml:space="preserve">
          <source>Pushes the thread represented by &lt;code&gt;L&lt;/code&gt; onto the stack. Returns 1 if this thread is the main thread of its state.</source>
          <target state="translated">Помещает нить, обозначенную буквой &lt;code&gt;L&lt;/code&gt; , в стек. Возвращает 1, если этот поток является основным потоком своего состояния.</target>
        </trans-unit>
        <trans-unit id="4854f8dce1b3efb397d0da3cc0315b1cfb867e30" translate="yes" xml:space="preserve">
          <source>Pushes the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns.</source>
          <target state="translated">Помещает строку с завершающим нулем, на которую указывает &lt;code&gt;s&lt;/code&gt; , в стек. Lua создает (или повторно использует) внутреннюю копию заданной строки, поэтому память в &lt;code&gt;s&lt;/code&gt; может быть освобождена или повторно использована сразу после возврата из функции.</target>
        </trans-unit>
        <trans-unit id="fc0763820b54eedcf07407cf791911e6a4435f20" translate="yes" xml:space="preserve">
          <source>Raises an error reporting a problem with argument &lt;code&gt;arg&lt;/code&gt; of the C function that called it, using a standard message that includes &lt;code&gt;extramsg&lt;/code&gt; as a comment:</source>
          <target state="translated">Вызывает ошибку, сообщающую о проблеме с аргументом &lt;code&gt;arg&lt;/code&gt; &lt;code&gt;extramsg&lt;/code&gt; его функции C, используя стандартное сообщение, которое включает extramsg в качестве комментария:</target>
        </trans-unit>
        <trans-unit id="2195072e1ce816af3985bb81599b653639e6d200" translate="yes" xml:space="preserve">
          <source>Raises an error. The error message format is given by &lt;code&gt;fmt&lt;/code&gt; plus any extra arguments, following the same rules of &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;. It also adds at the beginning of the message the file name and the line number where the error occurred, if this information is available.</source>
          <target state="translated">Вызывает ошибку. Формат сообщения об ошибке задается &lt;code&gt;fmt&lt;/code&gt; плюс любые дополнительные аргументы, следуя тем же правилам &lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; &lt;/a&gt; . Он также добавляет в начало сообщения имя файла и номер строки, в которой произошла ошибка, если эта информация доступна.</target>
        </trans-unit>
        <trans-unit id="76a33dab1cf51144cd77abed8a485f73ea3a2319" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;file&lt;/code&gt;, according to the given formats, which specify what to read. For each format, the function returns a string or a number with the characters read, or &lt;b&gt;nil&lt;/b&gt; if it cannot read data with the specified format. (In this latter case, the function does not read subsequent formats.) When called without formats, it uses a default format that reads the next line (see below).</source>
          <target state="translated">Читает файл &lt;code&gt;file&lt;/code&gt; соответствии с заданными форматами, которые указывают, что читать. Для каждого формата функция возвращает строку или число с прочитанными символами или &lt;b&gt;nil,&lt;/b&gt; если она не может прочитать данные в указанном формате. (В последнем случае функция не читает последующие форматы.) При вызове без форматов она использует формат по умолчанию, который читает следующую строку (см. Ниже).</target>
        </trans-unit>
        <trans-unit id="19c5c64f58aecd561b0cc1876786dfe7cb5a0fec" translate="yes" xml:space="preserve">
          <source>Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.</source>
          <target state="translated">Получает строку и возвращает копию этой строки со всеми строчными буквами,измененными на прописные.Все остальные символы остаются без изменений.Определение того,что такое строчная буква,зависит от текущей локали.</target>
        </trans-unit>
        <trans-unit id="540aac1cb2574351ee99baa96641925cd5f56a55" translate="yes" xml:space="preserve">
          <source>Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.</source>
          <target state="translated">Получает строку и возвращает копию этой строки со всеми прописными буквами,измененными на строчные.Все остальные символы остаются без изменений.Определение того,что такое заглавная буква,зависит от текущей локали.</target>
        </trans-unit>
        <trans-unit id="b890d3f853acc49ad9cf651903e6eb6cdf33901a" translate="yes" xml:space="preserve">
          <source>Receives a string and returns its length. The empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; has length 0. Embedded zeros are counted, so &lt;code&gt;&quot;a\000bc\000&quot;&lt;/code&gt; has length 5.</source>
          <target state="translated">Получает строку и возвращает ее длину. Пустая строка &lt;code&gt;&quot;&quot;&lt;/code&gt; имеет длину 0. Подсчитываются встроенные нули, поэтому &lt;code&gt;&quot;a\000bc\000&quot;&lt;/code&gt; имеет длину 5.</target>
        </trans-unit>
        <trans-unit id="525f707997f87240ceb1b2b5bdf4cfc009a704fc" translate="yes" xml:space="preserve">
          <source>Receives a value of any type and converts it to a string in a human-readable format. (For complete control of how numbers are converted, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Получает значение любого типа и преобразует его в строку в удобочитаемом формате. (Для полного контроля над преобразованием чисел используйте &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="4a03622d8f97ccec5d5f7daa5dac73af6b7c7028" translate="yes" xml:space="preserve">
          <source>Receives any number of arguments and prints their values to &lt;code&gt;stdout&lt;/code&gt;, using the &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; function to convert each argument to a string. &lt;code&gt;print&lt;/code&gt; is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.write&quot;&gt;&lt;code&gt;io.write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Получает любое количество аргументов и выводит их значения в стандартный &lt;code&gt;stdout&lt;/code&gt; , используя функцию &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; для преобразования каждого аргумента в строку. &lt;code&gt;print&lt;/code&gt; не предназначен для форматированного вывода, а только как быстрый способ показать значение, например, для отладки. Для полного контроля над выводом используйте &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;#pdf-io.write&quot;&gt; &lt;code&gt;io.write&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2cf76b7f314d7be6b1d5b068287552d8871811e" translate="yes" xml:space="preserve">
          <source>Receives zero or more integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences.</source>
          <target state="translated">Получает ноль или несколько целых чисел,преобразует каждое из них в соответствующую последовательность UTF-8 байт и возвращает строку с конкатенцией всех этих последовательностей.</target>
        </trans-unit>
        <trans-unit id="cb0dfce9b4c27c4105f7ed0248bef997f2d2f7bb" translate="yes" xml:space="preserve">
          <source>Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numeric code equal to its corresponding argument.</source>
          <target state="translated">Получает ноль и более целых чисел.Возвращает строку длиной равной количеству аргументов,в которой каждый символ имеет внутренний числовой код,равный его соответствующему аргументу.</target>
        </trans-unit>
        <trans-unit id="ba50e88a283776123b7b75fd12714beb6542b84c" translate="yes" xml:space="preserve">
          <source>Registers all functions in the array &lt;code&gt;l&lt;/code&gt; (see &lt;a href=&quot;#luaL_Reg&quot;&gt;&lt;code&gt;luaL_Reg&lt;/code&gt;&lt;/a&gt;) into the table on the top of the stack (below optional upvalues, see next).</source>
          <target state="translated">Регистрирует все функции в массиве &lt;code&gt;l&lt;/code&gt; (см. &lt;a href=&quot;#luaL_Reg&quot;&gt; &lt;code&gt;luaL_Reg&lt;/code&gt; &lt;/a&gt; ) в таблице наверху стека (ниже необязательных повышающих значений, см. Далее).</target>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="translated">Операторы связи</target>
        </trans-unit>
        <trans-unit id="7d652aafaa213ccec3954206dc0a95e5d151cad3" translate="yes" xml:space="preserve">
          <source>Releases reference &lt;code&gt;ref&lt;/code&gt; from the table at index &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;). The entry is removed from the table, so that the referred object can be collected. The reference &lt;code&gt;ref&lt;/code&gt; is also freed to be used again.</source>
          <target state="translated">Освобождает ссылку &lt;code&gt;ref&lt;/code&gt; из таблицы по индексу &lt;code&gt;t&lt;/code&gt; (см. &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; ). Запись удаляется из таблицы, чтобы можно было собрать упомянутый объект. Ссылка &lt;code&gt;ref&lt;/code&gt; также может быть использована снова.</target>
        </trans-unit>
        <trans-unit id="1f21ed8cdd38e88c74187592dabfbf9189cec444" translate="yes" xml:space="preserve">
          <source>Remember that, whenever an operation needs the length of a table, all caveats about the length operator apply (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). All functions ignore non-numeric keys in the tables given as arguments.</source>
          <target state="translated">Помните, что всякий раз, когда для операции требуется длина таблицы, применяются все предостережения относительно оператора длины (см. &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ). Все функции игнорируют нечисловые ключи в таблицах, указанных в качестве аргументов.</target>
        </trans-unit>
        <trans-unit id="78486a859650e2590601f8f6a90106add4cefb81" translate="yes" xml:space="preserve">
          <source>Removes from &lt;code&gt;list&lt;/code&gt; the element at position &lt;code&gt;pos&lt;/code&gt;, returning the value of the removed element. When &lt;code&gt;pos&lt;/code&gt; is an integer between 1 and &lt;code&gt;#list&lt;/code&gt;, it shifts down the elements &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; and erases element &lt;code&gt;list[#list]&lt;/code&gt;; The index &lt;code&gt;pos&lt;/code&gt; can also be 0 when &lt;code&gt;#list&lt;/code&gt; is 0, or &lt;code&gt;#list + 1&lt;/code&gt;; in those cases, the function erases the element &lt;code&gt;list[pos]&lt;/code&gt;.</source>
          <target state="translated">Удаляет из &lt;code&gt;list&lt;/code&gt; элемент в позиции &lt;code&gt;pos&lt;/code&gt; , возвращая значение удаленного элемента. Когда &lt;code&gt;pos&lt;/code&gt; является целым числом от 1 до &lt;code&gt;#list&lt;/code&gt; , он сдвигает вниз &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; элементов [pos + 1], list [pos + 2], &amp;middot;&amp;middot;&amp;middot;, list [#list] и стирает &lt;code&gt;list[#list]&lt;/code&gt; элементов [#list] ; Индекс &lt;code&gt;pos&lt;/code&gt; также может быть 0, если &lt;code&gt;#list&lt;/code&gt; равен 0, или &lt;code&gt;#list + 1&lt;/code&gt; ; в этих случаях функция стирает &lt;code&gt;list[pos]&lt;/code&gt; элементов [pos] .</target>
        </trans-unit>
        <trans-unit id="11e20bb227ba77f3bb86f13b7935abd6f4634200" translate="yes" xml:space="preserve">
          <source>Removes the element at the given valid index, shifting down the elements above this index to fill the gap. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">Удаляет элемент с заданным действительным индексом,сдвигая вниз элементы выше этого индекса,чтобы заполнить пробел.Эта функция не может быть вызвана с помощью псевдоиндекса,так как псевдоиндекс не является фактической позицией стека.</target>
        </trans-unit>
        <trans-unit id="57bc261321eacee5a6b51aa33ad8b6bdff0d2216" translate="yes" xml:space="preserve">
          <source>Renames the file or directory named &lt;code&gt;oldname&lt;/code&gt; to &lt;code&gt;newname&lt;/code&gt;. If this function fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">Переименовывает файл или каталог с именем &lt;code&gt;oldname&lt;/code&gt; в &lt;code&gt;newname&lt;/code&gt; . Если эта функция не работает, она возвращает &lt;b&gt;nil&lt;/b&gt; плюс строку с описанием ошибки и ее код. В противном случае возвращается истина.</target>
        </trans-unit>
        <trans-unit id="0ce3bd88cc94ffb61167bb8f7b9e843c7604f13b" translate="yes" xml:space="preserve">
          <source>Results are returned using the &lt;b&gt;return&lt;/b&gt; statement (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;). If control reaches the end of a function without encountering a &lt;b&gt;return&lt;/b&gt; statement, then the function returns with no results.</source>
          <target state="translated">Результаты возвращаются с использованием оператора &lt;b&gt;return&lt;/b&gt; (см. &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; ). Если элемент управления достигает конца функции, не встречая оператора &lt;b&gt;возврата&lt;/b&gt; , функция возвращается без результатов.</target>
        </trans-unit>
        <trans-unit id="244c963cdbd920ed3e3a03fe837b76f265d0a0b8" translate="yes" xml:space="preserve">
          <source>Resurrected objects (that is, objects being finalized and objects accessible only through objects being finalized) have a special behavior in weak tables. They are removed from weak values before running their finalizers, but are removed from weak keys only in the next collection after running their finalizers, when such objects are actually freed. This behavior allows the finalizer to access properties associated with the object through weak tables.</source>
          <target state="translated">Восстановленные объекты (т.е.объекты,находящиеся в стадии доработки,и объекты,доступные только через объекты,находящиеся в стадии доработки)имеют особое поведение в слабых таблицах.Они удаляются из слабых значений перед запуском своих финализаторов,но удаляются из слабых ключей только в следующей коллекции после запуска своих финализаторов,когда такие объекты действительно освобождаются.Такое поведение позволяет финализатору получать доступ к свойствам,связанным с объектом,через слабые таблицы.</target>
        </trans-unit>
        <trans-unit id="03118cc39c1e81c1c438cef7d116290590135b5a" translate="yes" xml:space="preserve">
          <source>Returns &quot;&lt;code&gt;integer&lt;/code&gt;&quot; if &lt;code&gt;x&lt;/code&gt; is an integer, &quot;&lt;code&gt;float&lt;/code&gt;&quot; if it is a float, or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;x&lt;/code&gt; is not a number.</source>
          <target state="translated">Возвращает &amp;laquo; &lt;code&gt;integer&lt;/code&gt; &amp;raquo;, если &lt;code&gt;x&lt;/code&gt; является целым числом, &amp;laquo; &lt;code&gt;float&lt;/code&gt; &amp;raquo;, если это число с плавающей запятой, или &lt;b&gt;nil,&lt;/b&gt; если &lt;code&gt;x&lt;/code&gt; не является числом.</target>
        </trans-unit>
        <trans-unit id="ec136d49176b1dfa086d0b59ff735d87f5d8b25c" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given coroutine can yield, and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если данный корутин может давать,и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="36a260eb163a20a6982a495d8fcda57196ae377b" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given index is not valid or if the value at this index is &lt;b&gt;nil&lt;/b&gt;, and 0 otherwise.</source>
          <target state="translated">Возвращает 1, если данный индекс недействителен или если значение этого индекса равно &lt;b&gt;нулю&lt;/b&gt; , и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="8a03c180e8267d605c7828397144f7c543874d2c" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given index is not valid, and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если данный индекс недействителен,и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="4abb71a0bd2d89035111fe1406578f64ee99f1cd" translate="yes" xml:space="preserve">
          <source>Returns 1 if the two values in indices &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt; are primitively equal (that is, without calling the &lt;code&gt;__eq&lt;/code&gt; metamethod). Otherwise returns 0. Also returns 0 if any of the indices are not valid.</source>
          <target state="translated">Возвращает 1 , если два значения индексов &lt;code&gt;index1&lt;/code&gt; и &lt;code&gt;index2&lt;/code&gt; примитивно равно (то есть без вызова &lt;code&gt;__eq&lt;/code&gt; метаметода). В противном случае возвращает 0. Также возвращает 0, если какой-либо из индексов недействителен.</target>
        </trans-unit>
        <trans-unit id="77b6c0faff8f019e54587bee38b27269e8ece2d8" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is &lt;b&gt;nil&lt;/b&gt;, and 0 otherwise.</source>
          <target state="translated">Возвращает 1, если значение данного индекса равно &lt;b&gt;нулю&lt;/b&gt; , и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="acad229e61c0f7b3cf84876f85fd1aed4340fdeb" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a C function, and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение на данном индексе является функцией C,и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="c6d1286ca58fd2bca52facd7ccf6f424aa47dca4" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a boolean, and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение в данном индексе является булевым,и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="04d4d0a8fc1e9ff9c642f37982cd6541f074eaf2" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a function (either C or Lua), and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение в данном индексе является функцией (либо C,либо Lua),и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="85c97cef398c89971e6d5d95362f5833c0efeb94" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a light userdata, and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение в данном индексе является легким пользовательским,и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="293be583246b5c6f5755824ebef65496d84be9b9" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a number or a string convertible to a number, and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение в данном индексе является числом или строкой,конвертируемой в число,и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="1ef629a2e4c4bd109da15d0096305f549d521e11" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a string or a number (which is always convertible to a string), and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение в данном индексе является строкой или числом (которое всегда конвертируется в строку),и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="b24b734f996f24f0d2edcb352efb5d0a8733d485" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a table, and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение по данному индексу является табличным,и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="6452edfae9b54954154513a55afe95f60e75b4fa" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a thread, and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение в данном индексе является нитью,и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="fbf8a110fe7143ca6d907ca070a5c03ffa0f2050" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a userdata (either full or light), and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение в данном индексе является пользовательским (либо полным,либо светлым),и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="83893644ee4437282f1a7daf1d6a53c7e83643da" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is an integer (that is, the value is a number and is represented as an integer), and 0 otherwise.</source>
          <target state="translated">Возвращает 1,если значение в данном индексе является целым числом (то есть значение является числом и представлено в виде целого числа),и 0 в противном случае.</target>
        </trans-unit>
        <trans-unit id="e0d04eca2996cc50939c173c775d0d5f069d8627" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pops nothing) when the index &lt;code&gt;n&lt;/code&gt; is greater than the number of upvalues.</source>
          <target state="translated">Возвращает &lt;code&gt;NULL&lt;/code&gt; (и ничего не выдает ), если индекс &lt;code&gt;n&lt;/code&gt; больше, чем количество повышающих значений.</target>
        </trans-unit>
        <trans-unit id="f56ddb3bc18ad7e4888cfe9050da5f11bd833971" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pops nothing) when the index is greater than the number of active local variables.</source>
          <target state="translated">Возвращает &lt;code&gt;NULL&lt;/code&gt; (и ничего не выдает), если индекс больше, чем количество активных локальных переменных.</target>
        </trans-unit>
        <trans-unit id="57d7205f6585ea512d11e87992ca7441e1e7627e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pushes nothing) when the index is greater than the number of active local variables.</source>
          <target state="translated">Возвращает &lt;code&gt;NULL&lt;/code&gt; (и ничего не отправляет), если индекс больше, чем количество активных локальных переменных.</target>
        </trans-unit>
        <trans-unit id="cfcdfcdeac01eab8c7e33e91fd9027aed705b576" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;udata&lt;/code&gt;.</source>
          <target state="translated">Возвращает &lt;code&gt;udata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95b61d5c1d6df056ea18d8531706d5088a5cc2ec" translate="yes" xml:space="preserve">
          <source>Returns a binary string containing the values &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, etc. packed (that is, serialized in binary form) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">Возвращает двоичную строку, содержащую значения &lt;code&gt;v1&lt;/code&gt; , &lt;code&gt;v2&lt;/code&gt; и т.д., упакованные (то есть сериализованные в двоичной форме) в соответствии со строкой формата &lt;code&gt;fmt&lt;/code&gt; (см. &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="34fa3ab9c6fcc7c0b0e41c857bf1c60b601f5344" translate="yes" xml:space="preserve">
          <source>Returns a boolean, true if and only if integer &lt;code&gt;m&lt;/code&gt; is below integer &lt;code&gt;n&lt;/code&gt; when they are compared as unsigned integers.</source>
          <target state="translated">Возвращает логическое значение true тогда и только тогда, когда целое число &lt;code&gt;m&lt;/code&gt; меньше целого числа &lt;code&gt;n&lt;/code&gt; , когда они сравниваются как целые числа без знака.</target>
        </trans-unit>
        <trans-unit id="83c4b62eb52291289917793f1a6cc1b8ea7a62cf" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;s&lt;/code&gt; in which all (or the first &lt;code&gt;n&lt;/code&gt;, if given) occurrences of the &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) have been replaced by a replacement string specified by &lt;code&gt;repl&lt;/code&gt;, which can be a string, a table, or a function. &lt;code&gt;gsub&lt;/code&gt; also returns, as its second value, the total number of matches that occurred. The name &lt;code&gt;gsub&lt;/code&gt; comes from &lt;em&gt;Global SUBstitution&lt;/em&gt;.</source>
          <target state="translated">Возвращает копию &lt;code&gt;s&lt;/code&gt; , в которой все (или первые &lt;code&gt;n&lt;/code&gt; , если задано) вхождения &lt;code&gt;pattern&lt;/code&gt; (см. &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; ) были заменены заменяющей строкой, указанной в &lt;code&gt;repl&lt;/code&gt; , которая может быть строкой, таблицей или функция. &lt;code&gt;gsub&lt;/code&gt; также возвращает в качестве второго значения общее количество совпадений. Название &lt;code&gt;gsub&lt;/code&gt; происходит от &lt;em&gt;Global SUBstitution&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2ddd8b557487a7047dc27604858d100902c9eec4" translate="yes" xml:space="preserve">
          <source>Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ISO C function &lt;code&gt;sprintf&lt;/code&gt;. The only differences are that the options/modifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt; are not supported and that there is an extra option, &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">Возвращает отформатированную версию своего переменного числа аргументов после описания, данного в его первом аргументе (который должен быть строкой). Строка формата следует тем же правилам, что и функция ISO C &lt;code&gt;sprintf&lt;/code&gt; . Единственные отличия заключаются в том, что параметры / модификаторы &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; и &lt;code&gt;p&lt;/code&gt; не поддерживаются, и есть дополнительная опция &lt;code&gt;q&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e8f9acfbbc61db53d975814a02f1c9aab94a23d" translate="yes" xml:space="preserve">
          <source>Returns a new table with all parameters stored into keys 1, 2, etc. and with a field &quot;&lt;code&gt;n&lt;/code&gt;&quot; with the total number of parameters. Note that the resulting table may not be a sequence.</source>
          <target state="translated">Возвращает новую таблицу со всеми параметрами, хранящимися в ключах 1, 2 и т. Д., И с полем &amp;laquo; &lt;code&gt;n&lt;/code&gt; &amp;raquo; с общим количеством параметров. Обратите внимание, что результирующая таблица может не быть последовательностью.</target>
        </trans-unit>
        <trans-unit id="04445fdc39272b542d188c106147fa8b6a611119" translate="yes" xml:space="preserve">
          <source>Returns a pointer to a raw memory area associated with the given Lua state. The application can use this area for any purpose; Lua does not use it for anything.</source>
          <target state="translated">Возвращает указатель на необработанную область памяти,связанную с данным состоянием Луа.Приложение может использовать эту область для любых целей;Lua не использует ее ни для чего.</target>
        </trans-unit>
        <trans-unit id="4f4330812b83811a6da51b5ddf77a1c753b5a3f8" translate="yes" xml:space="preserve">
          <source>Returns a pointer to the internal copy of the string.</source>
          <target state="translated">Возвращает указатель на внутреннюю копию строки.</target>
        </trans-unit>
        <trans-unit id="110bc8230211fc8ab3a4f90c96eb53b6ace38d6f" translate="yes" xml:space="preserve">
          <source>Returns a string containing a binary representation (a &lt;em&gt;binary chunk&lt;/em&gt;) of the given function, so that a later &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; on this string returns a copy of the function (but with new upvalues). If &lt;code&gt;strip&lt;/code&gt; is a true value, the binary representation may not include all debug information about the function, to save space.</source>
          <target state="translated">Возвращает строку, содержащую двоичное представление ( &lt;em&gt;двоичный фрагмент&lt;/em&gt; ) данной функции, так что более поздняя &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; этой строки возвращает копию функции (но с новыми повышающими значениями). Если &lt;code&gt;strip&lt;/code&gt; - истинное значение, двоичное представление может не включать всю отладочную информацию о функции для экономии места.</target>
        </trans-unit>
        <trans-unit id="7785dcf0d96ed76232f8ceff4782113f5d891ebc" translate="yes" xml:space="preserve">
          <source>Returns a string or a table containing date and time, formatted according to the given string &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">Возвращает строку или таблицу, содержащую дату и время, отформатированные в соответствии с заданным строковым &lt;code&gt;format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e96b629efb1e60f437ca5030afcaedd1ef526018" translate="yes" xml:space="preserve">
          <source>Returns a string that is the concatenation of &lt;code&gt;n&lt;/code&gt; copies of the string &lt;code&gt;s&lt;/code&gt; separated by the string &lt;code&gt;sep&lt;/code&gt;. The default value for &lt;code&gt;sep&lt;/code&gt; is the empty string (that is, no separator). Returns the empty string if &lt;code&gt;n&lt;/code&gt; is not positive.</source>
          <target state="translated">Возвращает строку, которая представляет собой конкатенацию &lt;code&gt;n&lt;/code&gt; копий строки &lt;code&gt;s&lt;/code&gt; , разделенных строкой &lt;code&gt;sep&lt;/code&gt; . Значение по умолчанию для &lt;code&gt;sep&lt;/code&gt; - это пустая строка (то есть без разделителя). Возвращает пустую строку, если &lt;code&gt;n&lt;/code&gt; не положительно.</target>
        </trans-unit>
        <trans-unit id="c23b06e9809db45e6323880c87aa7252a0bafcb4" translate="yes" xml:space="preserve">
          <source>Returns a string that is the string &lt;code&gt;s&lt;/code&gt; reversed.</source>
          <target state="translated">Возвращает строку , которая является строка &lt;code&gt;s&lt;/code&gt; обратной.</target>
        </trans-unit>
        <trans-unit id="fc7ced1cf6bbd4c86f0ee87b0d833bbb93586b07" translate="yes" xml:space="preserve">
          <source>Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.</source>
          <target state="translated">Возвращает строку с именем файла,которая может быть использована для временного файла.Файл должен быть явно открыт перед его использованием и явно удален,когда в нем больше нет необходимости.</target>
        </trans-unit>
        <trans-unit id="41736de9eba1b5a23348a72c73555dbf11b75db2" translate="yes" xml:space="preserve">
          <source>Returns a table with information about a function. You can give the function directly or you can give a number as the value of &lt;code&gt;f&lt;/code&gt;, which means the function running at level &lt;code&gt;f&lt;/code&gt; of the call stack of the given thread: level 0 is the current function (&lt;code&gt;getinfo&lt;/code&gt; itself); level 1 is the function that called &lt;code&gt;getinfo&lt;/code&gt; (except for tail calls, which do not count on the stack); and so on. If &lt;code&gt;f&lt;/code&gt; is a number larger than the number of active functions, then &lt;code&gt;getinfo&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Возвращает таблицу с информацией о функции. Вы можете указать функцию напрямую или вы можете указать число в качестве значения &lt;code&gt;f&lt;/code&gt; , что означает, что функция работает на уровне &lt;code&gt;f&lt;/code&gt; стека вызовов данного потока: уровень 0 - это текущая функция ( сама &lt;code&gt;getinfo&lt;/code&gt; ); уровень 1 - это функция, которая &lt;code&gt;getinfo&lt;/code&gt; (за исключением хвостовых вызовов, которые не учитываются в стеке); и так далее. Если &lt;code&gt;f&lt;/code&gt; больше числа активных функций, то &lt;code&gt;getinfo&lt;/code&gt; возвращает &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="10b30ad1ae8da522aed09e1a02ace7921e1f51a6" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier (as a light userdata) for the upvalue numbered &lt;code&gt;n&lt;/code&gt; from the given function.</source>
          <target state="translated">Возвращает уникальный идентификатор (в виде легких пользовательских данных) для повышенного значения с номером &lt;code&gt;n&lt;/code&gt; из данной функции.</target>
        </trans-unit>
        <trans-unit id="0b3fe57552c933213408135c6244c0db831931eb" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier for the upvalue numbered &lt;code&gt;n&lt;/code&gt; from the closure at index &lt;code&gt;funcindex&lt;/code&gt;.</source>
          <target state="translated">Возвращает уникальный идентификатор для повышенного значения с номером &lt;code&gt;n&lt;/code&gt; из закрытия по индексу &lt;code&gt;funcindex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bee587bfd0df43f919edb6f2e537b30c2fff9e47" translate="yes" xml:space="preserve">
          <source>Returns an address to a space of size &lt;code&gt;sz&lt;/code&gt; where you can copy a string to be added to buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). After copying the string into this space you must call &lt;a href=&quot;#luaL_addsize&quot;&gt;&lt;code&gt;luaL_addsize&lt;/code&gt;&lt;/a&gt; with the size of the string to actually add it to the buffer.</source>
          <target state="translated">Возвращает адрес в пространство размером &lt;code&gt;sz&lt;/code&gt; , где вы можете скопировать строку для добавления в буфер &lt;code&gt;B&lt;/code&gt; (см. &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; ). После копирования строки в это пространство вы должны вызвать &lt;a href=&quot;#luaL_addsize&quot;&gt; &lt;code&gt;luaL_addsize&lt;/code&gt; &lt;/a&gt; с размером строки, чтобы фактически добавить ее в буфер.</target>
        </trans-unit>
        <trans-unit id="791d30f65759aca9bc8c2ab0c81b3414394fb75d" translate="yes" xml:space="preserve">
          <source>Returns an approximation of the amount in seconds of CPU time used by the program.</source>
          <target state="translated">Возвращает аппроксимацию суммы в секундах процессорного времени,используемого программой.</target>
        </trans-unit>
        <trans-unit id="ed3bd9acca66b3345ff64ecf82770701deaf6e39" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, reads the file according to the given formats. When no format is given, uses &quot;&lt;code&gt;l&lt;/code&gt;&quot; as a default. As an example, the construction</source>
          <target state="translated">Возвращает функцию итератора, которая при каждом вызове читает файл в соответствии с заданными форматами. Если формат не указан, по умолчанию используется &amp;laquo; &lt;code&gt;l&lt;/code&gt; &amp;raquo;. Например, конструкция</target>
        </trans-unit>
        <trans-unit id="9502ef377c9031927e39c05f93ef446921a0becd" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, returns the next captures from &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) over the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is produced in each call.</source>
          <target state="translated">Возвращает функцию итератора, которая при каждом вызове возвращает следующие захваты из &lt;code&gt;pattern&lt;/code&gt; (см. &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; ) по строке &lt;code&gt;s&lt;/code&gt; . Если &lt;code&gt;pattern&lt;/code&gt; указывает на захват, то при каждом вызове создается полное совпадение.</target>
        </trans-unit>
        <trans-unit id="ea5fe629e50500647001f1530cb02685325af73a" translate="yes" xml:space="preserve">
          <source>Returns the &quot;length&quot; of the value at the given index as a number; it is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Raises an error if the result of the operation is not an integer. (This case only can happen through metamethods.)</source>
          <target state="translated">Возвращает &amp;laquo;длину&amp;raquo; значения по данному индексу в виде числа; он эквивалентен оператору ' &lt;code&gt;#&lt;/code&gt; ' в Lua (см. &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ). Вызывает ошибку, если результат операции не является целым числом. (Этот случай возможен только с помощью метаметодов.)</target>
        </trans-unit>
        <trans-unit id="db78771d6acbed28111d58cf748f20e4959f1e52" translate="yes" xml:space="preserve">
          <source>Returns the Lua value associated to &lt;code&gt;u&lt;/code&gt;. If &lt;code&gt;u&lt;/code&gt; is not a full userdata, returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">Возвращает значение Lua, связанное с &lt;code&gt;u&lt;/code&gt; . Если &lt;code&gt;u&lt;/code&gt; не является полными пользовательскими данными, возвращается &lt;b&gt;nil&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d1851a04bfd13cc05cd523998c36bdc322db17e1" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of &lt;code&gt;x&lt;/code&gt;. (integer/float)</source>
          <target state="translated">Возвращает абсолютное значение &lt;code&gt;x&lt;/code&gt; . (число / с плавающей точкой)</target>
        </trans-unit>
        <trans-unit id="19e9a2e3f9c2da4b70e14502d18cc907361074e9" translate="yes" xml:space="preserve">
          <source>Returns the address of the version number (a C static variable) stored in the Lua core. When called with a valid &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt;, returns the address of the version used to create that state. When called with &lt;code&gt;NULL&lt;/code&gt;, returns the address of the version running the call.</source>
          <target state="translated">Возвращает адрес номера версии (статической переменной C), хранящейся в ядре Lua. При вызове с допустимым &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; &lt;/a&gt; возвращает адрес версии, использованной для создания этого состояния. При вызове с &lt;code&gt;NULL&lt;/code&gt; возвращает адрес версии, выполняющей вызов.</target>
        </trans-unit>
        <trans-unit id="d492dc5dd4aa5f92735d2073fff7474e1a6b394e" translate="yes" xml:space="preserve">
          <source>Returns the arc cosine of &lt;code&gt;x&lt;/code&gt; (in radians).</source>
          <target state="translated">Возвращает арккосинус &lt;code&gt;x&lt;/code&gt; (в радианах).</target>
        </trans-unit>
        <trans-unit id="f089a8dff08d67188de1f7c5039f149b9fa4a377" translate="yes" xml:space="preserve">
          <source>Returns the arc sine of &lt;code&gt;x&lt;/code&gt; (in radians).</source>
          <target state="translated">Возвращает арксинус &lt;code&gt;x&lt;/code&gt; (в радианах).</target>
        </trans-unit>
        <trans-unit id="94a36782eb1a80f58363dabc61ceebcb41f258d2" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of &lt;code&gt;x&lt;/code&gt; being zero.)</source>
          <target state="translated">Возвращает арктангенс &lt;code&gt;y/x&lt;/code&gt; (в радианах), но использует знаки обоих параметров, чтобы найти квадрант результата. (Он также правильно обрабатывает случай, когда &lt;code&gt;x&lt;/code&gt; равен нулю.)</target>
        </trans-unit>
        <trans-unit id="de4793305a62a7e062a99c696537172768770061" translate="yes" xml:space="preserve">
          <source>Returns the argument with the maximum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;. (integer/float)</source>
          <target state="translated">Возвращает аргумент с максимальным значением в соответствии с оператором Lua &lt;code&gt;&amp;lt;&lt;/code&gt; . (число / с плавающей точкой)</target>
        </trans-unit>
        <trans-unit id="23b18e62742fdde277f18684dd6adb5af258b562" translate="yes" xml:space="preserve">
          <source>Returns the argument with the minimum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;. (integer/float)</source>
          <target state="translated">Возвращает аргумент с минимальным значением в соответствии с оператором Lua &lt;code&gt;&amp;lt;&lt;/code&gt; . (число / с плавающей точкой)</target>
        </trans-unit>
        <trans-unit id="008974cf3ea7a0e47cc66825ae9db754a6215ba2" translate="yes" xml:space="preserve">
          <source>Returns the codepoints (as integers) from all characters in &lt;code&gt;s&lt;/code&gt; that start between byte position &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both included). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. It raises an error if it meets any invalid byte sequence.</source>
          <target state="translated">Возвращает кодовые точки (как целые числа) из всех символов в &lt;code&gt;s&lt;/code&gt; , которые начинаются между байтовой позицией &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;j&lt;/code&gt; (оба включены). По умолчанию для &lt;code&gt;i&lt;/code&gt; установлено значение 1, а для &lt;code&gt;j&lt;/code&gt; - &lt;code&gt;i&lt;/code&gt; . Выдает ошибку, если встречает недопустимую последовательность байтов.</target>
        </trans-unit>
        <trans-unit id="4e9e95635ca72435ec1e4654b329133fcb9b67b6" translate="yes" xml:space="preserve">
          <source>Returns the cosine of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">Возвращает косинус &lt;code&gt;x&lt;/code&gt; (предполагается, что он выражен в радианах).</target>
        </trans-unit>
        <trans-unit id="d63943c503fbdbc9daf70eb8b368eb63c603cce5" translate="yes" xml:space="preserve">
          <source>Returns the current hook count.</source>
          <target state="translated">Возвращает текущее количество крючков.</target>
        </trans-unit>
        <trans-unit id="91adc8b466cf6e5462daa3cdcd2555a890c15635" translate="yes" xml:space="preserve">
          <source>Returns the current hook function.</source>
          <target state="translated">Возвращает текущую функцию крючка.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
