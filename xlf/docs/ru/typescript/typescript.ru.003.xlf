<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes" xml:space="preserve">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target state="translated">Чтобы понять проверку типов с помощью JSX, вы должны сначала понять разницу между внутренними элементами и элементами, основанными на значениях. Учитывая выражение JSX &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt; , &lt;code&gt;expr&lt;/code&gt; может относиться либо к чему-то внутреннему для среды (например, &lt;code&gt;div&lt;/code&gt; или &lt;code&gt;span&lt;/code&gt; в среде DOM), либо к пользовательскому компоненту, который вы создали. Это важно по двум причинам:</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes" xml:space="preserve">
          <source>In order to use JSX you must do two things.</source>
          <target state="translated">Для использования JSX необходимо сделать две вещи.</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target state="translated">Другими словами, &lt;code&gt;x&lt;/code&gt; должен быть равен &lt;code&gt;1&lt;/code&gt; , когда он сравнивается с &lt;code&gt;2&lt;/code&gt; , что означает, что приведенная выше проверка делает недопустимое сравнение.</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes" xml:space="preserve">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target state="translated">Другими словами,TypeScript теперь ловит описанную выше ошибку,которая может быть для некоторых пользователей переломным моментом,но в значительной степени будет полезна.</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes" xml:space="preserve">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target state="translated">Другими словами, нажатие перехода к определению в объявлении из файла &lt;code&gt;.d.ts&lt;/code&gt; , созданного с помощью &lt;code&gt;--declarationMap&lt;/code&gt; , приведет вас к месту исходного файла ( &lt;code&gt;.ts&lt;/code&gt; ), где это объявление было определено, а не к &lt;code&gt;.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes" xml:space="preserve">
          <source>In other words, instead of producing the type</source>
          <target state="translated">Другими словами,вместо того,чтобы производить тип</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes" xml:space="preserve">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target state="translated">В нашем примере мы знали, что все использования &lt;code&gt;x&lt;/code&gt; будут инициализированы, поэтому имеет больше смысла использовать утверждения определенного присваивания, чем ненулевые утверждения.</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes" xml:space="preserve">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target state="translated">В наших примерах мы смогли получить свободный доступ к членам, которые мы объявили в наших программах. Если вы знакомы с классами на других языках, возможно, вы заметили, что в приведенных выше примерах нам не приходилось использовать слово &lt;code&gt;public&lt;/code&gt; для достижения этой цели; например, C # требует, чтобы каждый член был явно помечен как &lt;code&gt;public&lt;/code&gt; чтобы быть видимым. В TypeScript каждый член по умолчанию является &lt;code&gt;public&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes" xml:space="preserve">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target state="translated">В нашем первом примере с использованием интерфейсов TypeScript позволяет нам передавать &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; к чему-то, что ожидало только &lt;code&gt;{ label: string; }&lt;/code&gt; . Мы также только что узнали о дополнительных свойствах и о том, как они полезны при описании так называемых &amp;laquo;пакетов опций&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes" xml:space="preserve">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target state="translated">В нашем последнем примере нам пришлось объявить &lt;code&gt;name&lt;/code&gt; члена, &lt;code&gt;theName&lt;/code&gt; и параметр конструктора theName в классе &lt;code&gt;Octopus&lt;/code&gt; . Это необходимо для того, чтобы значение &lt;code&gt;theName&lt;/code&gt; было доступно после выполнения конструктора &lt;code&gt;Octopus&lt;/code&gt; . &lt;em&gt;Свойства параметров&lt;/em&gt; позволяют создавать и инициализировать член в одном месте. Вот еще одна версия предыдущего класса &lt;code&gt;Octopus&lt;/code&gt; с использованием свойства параметра:</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes" xml:space="preserve">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target state="translated">Играя в пример,можно заметить,что компилятор TypeScript может вычислить тип,даже если у вас есть типы только на одной стороне уравнения:</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes" xml:space="preserve">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target state="translated">В практическом плане,строгий режим нулевой проверки требует,чтобы все файлы при компиляции были нулевыми и неопределенными.</target>
        </trans-unit>
        <trans-unit id="948caf57846c2d397905854f03d5c34bfc0a420b" translate="yes" xml:space="preserve">
          <source>In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes" xml:space="preserve">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target state="translated">В целях, предшествовавших ES2015, наиболее достоверное излучение для таких конструкций, как циклы &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;of&lt;/code&gt; и спреды массива, может быть немного тяжелым. По этой причине TypeScript по умолчанию использует более простое выражение, которое поддерживает только типы массивов и поддерживает итерацию для других типов с &lt;code&gt;--downlevelIteration&lt;/code&gt; флага --downlevelIteration . Более свободный &lt;code&gt;--downlevelIteration&lt;/code&gt; умолчанию без --downlevelIteration работает довольно хорошо; тем не менее, были некоторые общие случаи, когда преобразование спредов массива имело наблюдаемые различия. Например, следующий массив, содержащий спред</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes" xml:space="preserve">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target state="translated">В предыдущих разделах мы создали универсальные функции идентификации, которые работали с различными типами. В этом разделе мы исследуем тип самих функций и способы создания универсальных интерфейсов.</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target state="translated">В предыдущих версиях TypeScript при любых обстоятельствах объединять классы и функции было ошибкой. Теперь внешние классы и функции (классы / функции с модификатором &lt;code&gt;declare&lt;/code&gt; или в файлах &lt;code&gt;.d.ts&lt;/code&gt; ) могут объединяться. Это означает, что теперь вы можете написать следующее:</target>
        </trans-unit>
        <trans-unit id="f22c95046aa4c7055bed172e8f2f4e6828c3f4e5" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, the language didn&amp;rsquo;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;rsquo;t distinct from properties as far as writing and reading to these properties; however, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;because ECMAScript&amp;rsquo;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target state="translated">В предыдущих версиях TypeScript язык не позволял &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;set&lt;/code&gt; аксессоры в окружающем контексте (например, в &lt;code&gt;declare&lt;/code&gt; классов -d или в файлах &lt;code&gt;.d.ts&lt;/code&gt; в целом). Обоснованием было то, что методы доступа не отличаются от свойств в том, что касается записи и чтения этих свойств; однако, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;поскольку предложение полей класса ECMAScript может иметь другое поведение, чем в существующих версиях TypeScript&lt;/a&gt; , мы поняли, что нам нужен способ сообщить об этом различном поведении, чтобы обеспечить соответствующие ошибки в подклассах.</target>
        </trans-unit>
        <trans-unit id="d06dc1f53a697259b064554b5aae5fbdd8fa0f1e" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, this controlled what encoding was used when reading text files from disk. Today, TypeScript assumes UTF-8 encoding, but will correctly detect UTF-16 (BE and LE) or UTF-8 BOMs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target state="translated">В предыдущих версиях TypeScript объединения вызываемых типов можно было вызывать &lt;em&gt;только в&lt;/em&gt; том случае, если они имели идентичные списки параметров.</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes" xml:space="preserve">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target state="translated">В обычном режиме проверки типа выводимый тип &lt;code&gt;z&lt;/code&gt; является &lt;code&gt;any&lt;/code&gt; из-за расширения, но в режиме строгой проверки на нуль предполагаемый тип &lt;code&gt;z&lt;/code&gt; имеет значение &lt;code&gt;null&lt;/code&gt; (и, следовательно, при отсутствии аннотации типа &lt;code&gt;null&lt;/code&gt; является единственным возможным значением для &lt;code&gt;z&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes" xml:space="preserve">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target state="translated">Короче говоря, используя этот общий тип, мы можем моделировать специфическое поведение React для таких вещей, как &lt;code&gt;defaultProps&lt;/code&gt; и, в некоторой степени, &lt;code&gt;propTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e40e3de53767b82c408d32adbf7faeb04be447e" translate="yes" xml:space="preserve">
          <source>In short, what this means is that you&amp;rsquo;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target state="translated">Короче говоря, это означает, что вы сможете соответствующим образом сузить значения из итераторов, работая с ними напрямую.</target>
        </trans-unit>
        <trans-unit id="24b474a2b5b3fe83952a8beed2dac6888a114bac" translate="yes" xml:space="preserve">
          <source>In some cases where no type annotations are present, TypeScript will fall back to a type of &lt;code&gt;any&lt;/code&gt; for a variable when it cannot infer the type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target state="translated">В некоторых случаях,вы можете захотеть загрузить модуль только при определенных условиях.В TypeScript мы можем использовать приведенный ниже шаблон для реализации этого и других расширенных сценариев загрузки,чтобы напрямую вызывать загрузчики модуля,не теряя при этом безопасности типа.</target>
        </trans-unit>
        <trans-unit id="e8107f519ee938815a808bcba6bd65a28adcacb9" translate="yes" xml:space="preserve">
          <source>In some situations, not all type information is available or its declaration would take an inappropriate amount of effort. These may occur for values from code that has been written without TypeScript or a 3rd party library. In these cases, we might want to opt-out of type checking. To do so, we label these values with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes" xml:space="preserve">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target state="translated">В режиме строгой проверки на null компилятор требует, чтобы каждой ссылке на локальную переменную типа, который не включает &lt;code&gt;undefined&lt;/code&gt; , предшествовало присвоение этой переменной во всех возможных предшествующих путях кода.</target>
        </trans-unit>
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target state="translated">В режиме строгой проверки на &lt;code&gt;null&lt;/code&gt; значения null и &lt;code&gt;undefined&lt;/code&gt; &lt;em&gt;не&lt;/em&gt; относятся к домену каждого типа и могут &lt;em&gt;быть&lt;/em&gt; присвоены только себе и &lt;code&gt;any&lt;/code&gt; (единственное исключение - &lt;code&gt;undefined&lt;/code&gt; также может быть присвоено &lt;code&gt;void&lt;/code&gt; ). Итак, тогда как &lt;code&gt;T&lt;/code&gt; и &lt;code&gt;T | undefined&lt;/code&gt; считаются синонимами в обычном режиме проверки типов (поскольку &lt;code&gt;undefined&lt;/code&gt; считается подтипом любого &lt;code&gt;T&lt;/code&gt; ), это разные типы в режиме строгой проверки типов, и только &lt;code&gt;T | undefined&lt;/code&gt; допускает &lt;code&gt;undefined&lt;/code&gt; значения. То же верно и для отношения &lt;code&gt;T&lt;/code&gt; к &lt;code&gt;T | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">В режиме строгой проверки на &lt;code&gt;null&lt;/code&gt; значения null и &lt;code&gt;undefined&lt;/code&gt; находятся не в домене каждого типа и могут быть присвоены только себе и &lt;code&gt;any&lt;/code&gt; (единственное исключение - &lt;code&gt;undefined&lt;/code&gt; также может быть присвоено &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes" xml:space="preserve">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target state="translated">В этом примере мы сначала проверили ли &lt;code&gt;x&lt;/code&gt; был &lt;em&gt;не &lt;/em&gt; &lt;code&gt;E.Foo&lt;/code&gt; . Если эта проверка прошла успешно, то наш &lt;code&gt;||&lt;/code&gt; произойдет короткое замыкание, и тело if будет работать. Однако, если проверка не удалась, то &lt;code&gt;x&lt;/code&gt; может быть &lt;em&gt;только &lt;/em&gt; &lt;code&gt;E.Foo&lt;/code&gt; , поэтому нет смысла проверять , равно ли оно &lt;code&gt;E.Bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb5ff5bf0dceac10cc35060c81ee9faad7242ab" translate="yes" xml:space="preserve">
          <source>In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db5a8c7126c3ff13b89dab79253baece66850d2" translate="yes" xml:space="preserve">
          <source>In the Template section you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548f3708a85b8745e47e7af1b59669e8ecf4cfa7" translate="yes" xml:space="preserve">
          <source>In the above case:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; будет работать нормально, но &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; приведет к ошибке, поскольку он не указан в &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;SelectableControl&lt;/code&gt; содержит все члены &lt;code&gt;Control&lt;/code&gt; , включая свойство частного &lt;code&gt;state&lt;/code&gt; . Поскольку &lt;code&gt;state&lt;/code&gt; является частным членом, только потомки &lt;code&gt;Control&lt;/code&gt; могут реализовать &lt;code&gt;SelectableControl&lt;/code&gt; . Это происходит потому , что только потомки &lt;code&gt;Control&lt;/code&gt; будут иметь &lt;code&gt;state&lt;/code&gt; частный элемент , который берет свое начало в той же декларации, что является требованием для частных пользователей , чтобы быть совместимыми.</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes" xml:space="preserve">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target state="translated">В приведенном выше примере все объявления &lt;code&gt;x&lt;/code&gt; фактически относятся к &lt;em&gt;одному&lt;/em&gt; и тому &lt;em&gt;же &lt;/em&gt; &lt;code&gt;x&lt;/code&gt; , и это совершенно верно. Это часто становится источником ошибок. К счастью, &lt;code&gt;let&lt;/code&gt; декларации не столь снисходительны.</target>
        </trans-unit>
        <trans-unit id="c61ebd05e2312c5e85ecc6cef6e59dba4f593f68" translate="yes" xml:space="preserve">
          <source>In the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, TypeScript will try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf0ee9dcee21963bf1982f4a5b086175197a8510" translate="yes" xml:space="preserve">
          <source>In the above form, the mixin&amp;rsquo;s have no underlying knowledge of the class which can make it hard to create the design you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target state="translated">В приведенном выше &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; совместимы, потому что их структуры не используют аргумент типа дифференцирующим образом. Изменение этого примера путем добавления члена в &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; показывает, как это работает:</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes" xml:space="preserve">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере, если мы действительно хотели, чтобы &lt;code&gt;baz&lt;/code&gt; потенциально был &lt;code&gt;undefined&lt;/code&gt; , мы должны были объявить его с типом &lt;code&gt;boolean | undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes" xml:space="preserve">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target state="translated">В приведенном выше примере переменная &lt;code&gt;a&lt;/code&gt; имеет условный тип, для которого еще не выбрана ветвь. Когда другой фрагмент кода завершает вызов &lt;code&gt;foo&lt;/code&gt; , он заменяет &lt;code&gt;U&lt;/code&gt; на какой-то другой тип, а TypeScript повторно оценивает условный тип, решая, действительно ли он может выбрать ветвь.</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes" xml:space="preserve">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target state="translated">В приведенном ниже коде мы показываем, как можно моделировать миксины в TypeScript. После кода мы разберемся, как это работает.</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes" xml:space="preserve">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target state="translated">В объявлении &lt;code&gt;f2&lt;/code&gt; выше, вывод типа выводит типы &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;[string, boolean]&lt;/code&gt; и &lt;code&gt;void&lt;/code&gt; для &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; и &lt;code&gt;V&lt;/code&gt; соответственно.</target>
        </trans-unit>
        <trans-unit id="8ab389301f78b38cc120b50ad55981dfdf9ab9b4" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;a href=&quot;functions#this&quot;&gt;this&lt;/a&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">В приведенном выше примере объект &lt;code&gt;methods&lt;/code&gt; в аргументе &lt;code&gt;makeObject&lt;/code&gt; имеет контекстный тип, который включает &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; и, следовательно, тип &lt;code&gt;this&lt;/code&gt; в методах внутри объекта &lt;code&gt;methods&lt;/code&gt; - &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; . Обратите внимание, как тип свойства &lt;code&gt;methods&lt;/code&gt; одновременно является целью вывода и источником для &lt;code&gt;this&lt;/code&gt; типа в методах.</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes" xml:space="preserve">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; which is equivalent to &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; which is just &lt;code&gt;&quot;orange&quot;&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере, параметры &lt;code&gt;fruit&lt;/code&gt; и &lt;code&gt;color&lt;/code&gt; пересекаются друг с другом , чтобы новый параметр типа &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; . &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; - это то же самое, что &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; что эквивалентно &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt; . Каждое из этих невозможных пересечений сводится к &lt;code&gt;never&lt;/code&gt; , и у нас остается &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; который просто &lt;code&gt;&quot;orange&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d9dddab39b8eb943f3877822ffa8bdb3bae451" translate="yes" xml:space="preserve">
          <source>In the first &lt;code&gt;length&lt;/code&gt;, T is not necessary; notice that it&amp;rsquo;s only referenced once, so it&amp;rsquo;s not being used to constrain the type of the return value or other parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes" xml:space="preserve">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target state="translated">В следующем примере каждый входной элемент будет распечатан по одному с задержкой 400мс:</target>
        </trans-unit>
        <trans-unit id="d0896b9003166f205cee791b2a20d447c0e588fb" translate="yes" xml:space="preserve">
          <source>In the interests of clarity and brevity, the main content of the Handbook will not explore every edge case or minutiae of the features being covered. You can find more details on particular concepts in the reference articles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes" xml:space="preserve">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target state="translated">В последней строке мы создаем экземпляр класса &lt;code&gt;Greeter&lt;/code&gt; с помощью &lt;code&gt;new&lt;/code&gt; . Это вызывает конструктор, который мы определили ранее, создает новый объект с формой &lt;code&gt;Greeter&lt;/code&gt; и запускает конструктор для его инициализации.</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes" xml:space="preserve">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">В последнем окне выберите &lt;strong&gt;Пустой&lt;/strong&gt; шаблон и нажмите кнопку &lt;em&gt;Создать.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes" xml:space="preserve">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">А пока мы можем назначить условный тип любому другому целевому типу, если каждая ветвь условного выражения может быть назначена этой цели. Итак, в нашем примере выше мы смогли назначить &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; в &lt;code&gt;string | number&lt;/code&gt; поскольку независимо от того, что оценивает условное выражение, известно, что оно является &lt;code&gt;string&lt;/code&gt; или &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa79973a1fa7675ac6793a6ef6bc0254a0e6be8" translate="yes" xml:space="preserve">
          <source>In the near future, we&amp;rsquo;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;rsquo;ll be able to see the same experience on the playground as you&amp;rsquo;d get in your personal editor.</source>
          <target state="translated">В ближайшем будущем мы собираемся обновить образцы игровых площадок, добавив поддержку JSX и доработав автоматическое получение типов, что означает, что вы сможете увидеть на игровой площадке тот же опыт, что и в своем личном редакторе. .</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes" xml:space="preserve">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">В корне проекта, &lt;code&gt;proj&lt;/code&gt; , создайте файл &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes" xml:space="preserve">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target state="translated">В корне проекта создайте файл &lt;code&gt;gulpfile.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes" xml:space="preserve">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target state="translated">В типе объекта модуля экспортированные &lt;code&gt;const&lt;/code&gt; переменные считаются свойствами только для чтения.</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes" xml:space="preserve">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target state="translated">В типе объекта перечисления члены перечисления считаются свойствами,доступными только для чтения.</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">В этих примерах список свойств является &lt;code&gt;keyof T&lt;/code&gt; а результирующий тип является некоторым вариантом &lt;code&gt;T[P]&lt;/code&gt; . Это хороший шаблон для любого общего использования сопоставленных типов. Это потому, что этот вид преобразования является &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;гомоморфным&lt;/a&gt; , что означает, что отображение применяется только к свойствам &lt;code&gt;T&lt;/code&gt; и никаким другим. Компилятор знает, что он может скопировать все существующие модификаторы свойств перед добавлением новых. Например, если &lt;code&gt;Person.name&lt;/code&gt; был доступен только для чтения , &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; будет доступен только для чтения и необязателен.</target>
        </trans-unit>
        <trans-unit id="9c7ec405a4a58ac2e2e3c9c60919a90fae57f264" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes" xml:space="preserve">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше примере &lt;code&gt;g&lt;/code&gt; захватил переменную &lt;code&gt;a&lt;/code&gt; , объявленную в &lt;code&gt;f&lt;/code&gt; . В любой момент, когда &lt;code&gt;g&lt;/code&gt; , значение &lt;code&gt;a&lt;/code&gt; будет привязано к значению &lt;code&gt;a&lt;/code&gt; в &lt;code&gt;f&lt;/code&gt; . Даже если &lt;code&gt;g&lt;/code&gt; вызывается один раз &lt;code&gt;f&lt;/code&gt; делается работает, он будет в состоянии получить доступ и изменять . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes" xml:space="preserve">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target state="translated">В этом случае нам нужно использовать TypeScript, чтобы сообщить любому из наших вызывающих пользователей о способах &lt;code&gt;myCoolFunction&lt;/code&gt; с использованием перегрузок функций.</target>
        </trans-unit>
        <trans-unit id="ca269f81daa4e288c099aeabd210add3bf701ab7" translate="yes" xml:space="preserve">
          <source>In this case, you can tell the TypeScript file resolver to support a number of custom prefixes to find code. This pattern can be used to avoid long relative paths within your codebase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0ee66fa54ed1af4b6530c2bbfb39ea8c9308255" translate="yes" xml:space="preserve">
          <source>In this case, you can use a &lt;code&gt;switch&lt;/code&gt; statement to narrow down which type is represented at runtime:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">В этом примере, если &lt;code&gt;someValue&lt;/code&gt; не равно &lt;code&gt;42&lt;/code&gt; , тогда &lt;code&gt;assert&lt;/code&gt; выдаст &lt;code&gt;AssertionError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target state="translated">В этом примере &lt;code&gt;b?&lt;/code&gt; указывает, что &lt;code&gt;b&lt;/code&gt; не является обязательным, поэтому он может быть &lt;code&gt;undefined&lt;/code&gt; . &lt;code&gt;keepWholeObject&lt;/code&gt; теперь имеет переменную для всего &lt;code&gt;wholeObject&lt;/code&gt; а также свойства &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; , даже если &lt;code&gt;b&lt;/code&gt; не определено.</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target state="translated">В этом примере &lt;code&gt;greeter1&lt;/code&gt; работает так же, как и раньше. Мы создаем экземпляр класса &lt;code&gt;Greeter&lt;/code&gt; и используем этот объект. Мы видели это раньше.</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes" xml:space="preserve">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target state="translated">В этом примере лучший общий тип имеет набор из четырех кандидатов: &lt;code&gt;Animal&lt;/code&gt; , &lt;code&gt;Rhino&lt;/code&gt; , &lt;code&gt;Elephant&lt;/code&gt; и &lt;code&gt;Snake&lt;/code&gt; . Из них &lt;code&gt;Animal&lt;/code&gt; можно выбрать с помощью наилучшего общего алгоритма типа.</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes" xml:space="preserve">
          <source>In this example, the first block creates the following name meanings:</source>
          <target state="translated">В этом примере первый блок создает следующие значения имени:</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes" xml:space="preserve">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target state="translated">В этом примере не существовало пространства имен &lt;code&gt;C&lt;/code&gt; , пока мы не написали для него объявление &lt;code&gt;namespace&lt;/code&gt; . Значение &lt;code&gt;C&lt;/code&gt; как пространства имен не конфликтует со значениями или значениями типа &lt;code&gt;C&lt;/code&gt; , созданными классом.</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes" xml:space="preserve">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">В этом примере у нас есть &lt;code&gt;Animal&lt;/code&gt; и &lt;code&gt;Rhino&lt;/code&gt; , причем &lt;code&gt;Rhino&lt;/code&gt; является подклассом &lt;code&gt;Animal&lt;/code&gt; . У нас также есть новый класс &lt;code&gt;Employee&lt;/code&gt; , который по форме выглядит идентично &lt;code&gt;Animal&lt;/code&gt; . Мы создаем несколько экземпляров этих классов, а затем пытаемся назначить их друг другу, чтобы увидеть, что произойдет. Поскольку &lt;code&gt;Animal&lt;/code&gt; и &lt;code&gt;Rhino&lt;/code&gt; имеют &lt;code&gt;private&lt;/code&gt; сторону своей формы из одного и того же объявления &lt;code&gt;private name: string&lt;/code&gt; в &lt;code&gt;Animal&lt;/code&gt; , они совместимы. Однако это не относится к &lt;code&gt;Employee&lt;/code&gt; . Когда мы пытаемся назначить от &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; мы получаем ошибку, что эти типы несовместимы. Несмотря на то, что у &lt;code&gt;Employee&lt;/code&gt; также есть &lt;code&gt;private&lt;/code&gt; член с именем &lt;code&gt;name&lt;/code&gt; , это не тот, который мы объявили в &lt;code&gt;Animal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target state="translated">В этом примере мы переместим все объекты, связанные с валидатором, в пространство имен, называемое &lt;code&gt;Validation&lt;/code&gt; . Поскольку мы хотим, чтобы интерфейсы и классы здесь были видимы за пределами пространства имен, мы ставим перед ними &lt;code&gt;export&lt;/code&gt; . И наоборот, переменные &lt;code&gt;lettersRegexp&lt;/code&gt; и &lt;code&gt;numberRegexp&lt;/code&gt; являются деталями реализации, поэтому они остаются неэкспортируемыми и не будут видны для кода за пределами пространства имен. В тестовом коде внизу файла нам теперь нужно указать имена типов при использовании вне пространства имен, например &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes" xml:space="preserve">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target state="translated">В этом сгенерированном коде перечисление компилируется в объект, который хранит как прямое ( &lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt; ), так и обратное ( &lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt; ) сопоставления. Ссылки на другие члены перечисления всегда генерируются как доступ к свойствам и никогда не встраиваются.</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target state="translated">В этом руководстве мы предполагаем базовое знакомство с языком TypeScript. Если вы еще этого не сделали, вам следует прочитать &lt;a href=&quot;../basic-types&quot;&gt;Руководство&lt;/a&gt; по TypeScript, чтобы ознакомиться с основными концепциями, особенно с типами и пространствами имен.</target>
        </trans-unit>
        <trans-unit id="daba3c5117e7e15297eb31c7463a628f5e08b0ec" translate="yes" xml:space="preserve">
          <source>In this introduction, I assume you know the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes" xml:space="preserve">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target state="translated">В этом режиме все ссылки на модули и пакеты (например, директивы &lt;code&gt;import&lt;/code&gt; s и &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; ) разрешаются относительно местоположения файла символической ссылки, а не относительно пути, который символическая ссылка разрешается в. Для более конкретного примера, мы будем откладывать в &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;документации на сайте Node.js&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes" xml:space="preserve">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target state="translated">В этом разделе мы опишем различные распространенные ошибки при использовании пространств имен и модулей, а также способы их избежать.</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes" xml:space="preserve">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target state="translated">В этом разделе мы рассмотрим вывод типов в TypeScript. А именно, мы обсудим, где и как выводятся типы.</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes" xml:space="preserve">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target state="translated">В этом простом примере &lt;code&gt;Keys&lt;/code&gt; представляет собой жестко запрограммированный список имен свойств, а тип свойства всегда &lt;code&gt;boolean&lt;/code&gt; , поэтому этот сопоставленный тип эквивалентен записи:</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes" xml:space="preserve">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target state="translated">В этой версии мы добавляем сеттер, который проверяет длину &lt;code&gt;newName&lt;/code&gt; , чтобы убедиться, что она совместима с максимальной длиной поля нашей резервной базы данных. Если это не так, мы выдаем ошибку, уведомляя клиентский код о том, что что-то пошло не так.</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes" xml:space="preserve">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target state="translated">Таким образом,общий тип,у которого указаны аргументы типа,действует точно так же,как и не генерический тип.</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes" xml:space="preserve">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target state="translated">В традиционном объектно-ориентированном коде мы могли бы абстрагироваться от двух типов, создав иерархию типов. Хотя это гораздо более явно, это также немного излишне. Одна из приятных особенностей оригинальной версии &lt;code&gt;padLeft&lt;/code&gt; заключалась в том, что мы могли просто передавать примитивы. Это означало, что использование было простым и кратким. Этот новый подход также не помог бы, если бы мы просто пытались использовать функцию, которая уже существует в другом месте.</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes" xml:space="preserve">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target state="translated">В вашем редакторе введите следующий код JavaScript в &lt;code&gt;greeter.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2065108186f788b7e824c4d623ba210ab88b1c4" translate="yes" xml:space="preserve">
          <source>Include - &lt;code&gt;include&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes" xml:space="preserve">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target state="translated">Включите модули, импортированные с расширением &lt;code&gt;.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">Включение файлов &lt;code&gt;.js&lt;/code&gt; с помощью &lt;code&gt;--allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes" xml:space="preserve">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target state="translated">Включая объявления встроенных типов с помощью &lt;code&gt;--lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes" xml:space="preserve">
          <source>Including declarations in your npm package</source>
          <target state="translated">Включение деклараций в ваш npm-пакет</target>
        </trans-unit>
        <trans-unit id="67c5ad4060ac33b6d094ebba765d48e9ee51b0ef" translate="yes" xml:space="preserve">
          <source>Incremental - &lt;code&gt;incremental&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes" xml:space="preserve">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target state="translated">Добавочный просмотр файлов для составных проектов в &lt;code&gt;--build --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7deed7a63ea26f03a02053b178171e4c34213f53" translate="yes" xml:space="preserve">
          <source>Incremental typing in JavaScript &lt;a href=&quot;jsdoc-supported-types&quot;&gt;via JSDoc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">Типы индексов</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes" xml:space="preserve">
          <source>Index types and index signatures</source>
          <target state="translated">Типы индексов и индексные подписи</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes" xml:space="preserve">
          <source>Indexable Types</source>
          <target state="translated">Индексируемые типы</target>
        </trans-unit>
        <trans-unit id="0adbe17edc35b59357a465c0c0744f9ea42fd3f6" translate="yes" xml:space="preserve">
          <source>Individual library components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes" xml:space="preserve">
          <source>Inference from mapped types</source>
          <target state="translated">Выводы из отображенных типов</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes" xml:space="preserve">
          <source>Inferring the types</source>
          <target state="translated">Информируя о типах</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes" xml:space="preserve">
          <source>Initialize the project</source>
          <target state="translated">Инициализировать проект</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes" xml:space="preserve">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">Инициализирует проект TypeScript и создает файл &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes" xml:space="preserve">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target state="translated">Инициализация объекта с динамическими свойствами может быть небольшой нагрузкой.Возьмем следующий пример:</target>
        </trans-unit>
        <trans-unit id="9c7561073b85798bf28e57100cdf96cfe8bdcf3e" translate="yes" xml:space="preserve">
          <source>Inline Source Map - &lt;code&gt;inlineSourceMap&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424e6831576ffef65176196315c29ac68ac4bf21" translate="yes" xml:space="preserve">
          <source>Inline Sources - &lt;code&gt;inlineSources&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target state="translated">Внутри &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; раздел &lt;code&gt;package.json&lt;/code&gt; файла, добавить &lt;em&gt;глотка&lt;/em&gt; и &lt;em&gt;дель&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes" xml:space="preserve">
          <source>Install ASP.NET Core and TypeScript</source>
          <target state="translated">Установить ядро ASP.NET и скрипт TypeScript</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes" xml:space="preserve">
          <source>Install our dependencies</source>
          <target state="translated">Установить наши зависимости</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes" xml:space="preserve">
          <source>Installing TypeScript</source>
          <target state="translated">Установка TypeScript</target>
        </trans-unit>
        <trans-unit id="98a0fba8620f4d80c37344d00d25fe24a9d88fbd" translate="yes" xml:space="preserve">
          <source>InstanceType&amp;lt;T&amp;gt;</source>
          <target state="translated">InstanceType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">Вместо &lt;code&gt;Object&lt;/code&gt; используйте непримитивный &lt;code&gt;object&lt;/code&gt; тип ( &lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;добавлен в TypeScript 2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="481ebcf06d3a6af9b20dbe32b1d7d942a9bbaeef" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target state="translated">Вместо &lt;code&gt;any&lt;/code&gt; мы можем использовать &lt;em&gt;тип объединения&lt;/em&gt; для параметра &lt;code&gt;padding&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes" xml:space="preserve">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вместо относительно бесполезного типа, такого как &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt; , который могли бы вывести старые версии языка, вывод TypeScript 3.4 позволяет &lt;code&gt;newFn&lt;/code&gt; быть универсальным. Его новый тип - &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7820345e86f733909d6d0cf768d7afc07da46bf5" translate="yes" xml:space="preserve">
          <source>Instead of importing helpers with &lt;a href=&quot;#importHelpers&quot;&gt;&lt;code&gt;importHelpers&lt;/code&gt;&lt;/a&gt;, you can provide implementations in the global scope for the helpers you use and completely turn off emitting of helper functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes" xml:space="preserve">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target state="translated">Вместо того, чтобы работать с любыми и всеми типами, мы хотели бы ограничить эту функцию для работы с любыми и всеми типами, которые также имеют свойство &lt;code&gt;.length&lt;/code&gt; . Пока тип имеет этот член, мы разрешим его, но он должен иметь хотя бы этот член. Для этого мы должны указать наше требование как ограничение на то, чем может быть T.</target>
        </trans-unit>
        <trans-unit id="56c1302b0e9b5a2d049280773df6dd17a03e760a" translate="yes" xml:space="preserve">
          <source>Instead, use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes" xml:space="preserve">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target state="translated">Вместо этого нам нужен способ захвата типа аргумента таким образом, чтобы мы могли также использовать его для обозначения того, что возвращается. Здесь мы будем использовать &lt;em&gt;переменную типа, переменную&lt;/em&gt; особого типа, которая работает с типами, а не со значениями.</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes" xml:space="preserve">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target state="translated">Вместо этого нам нужно передать значения,тип которых имеет все необходимые свойства:</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes" xml:space="preserve">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target state="translated">Вместо этого вам нужно будет напрямую работать со статической стороной класса. В этом примере мы определяем два интерфейса: &lt;code&gt;ClockConstructor&lt;/code&gt; для конструктора и &lt;code&gt;ClockInterface&lt;/code&gt; для методов экземпляра. Затем для удобства мы определяем функцию-конструктор &lt;code&gt;createClock&lt;/code&gt; , которая создает экземпляры переданного ей типа:</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools</source>
          <target state="translated">Интеграция со строительными инструментами</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Babel</source>
          <target state="translated">Интеграция со строительными инструментами:Вавилон</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Browserify</source>
          <target state="translated">Интеграция со строительными инструментами:Просмотреть</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Duo</source>
          <target state="translated">Интеграция со строительными инструментами:Дуэт</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Grunt</source>
          <target state="translated">Интеграция со строительными инструментами:Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Gulp</source>
          <target state="translated">Интеграция со строительными инструментами:Gulp</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Jspm</source>
          <target state="translated">Интеграция со строительными инструментами:Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: MSBuild</source>
          <target state="translated">Интеграция со строительными инструментами:MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: NuGet</source>
          <target state="translated">Интеграция со строительными инструментами:NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Webpack</source>
          <target state="translated">Интеграция со строительными инструментами:Вебпакет</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Mac)</source>
          <target state="translated">IntelliJ IDEA (Mac)</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Windows)</source>
          <target state="translated">IntelliJ IDEA (Windows)</target>
        </trans-unit>
        <trans-unit id="a018a82309e992e850b9031373cff79ce1cccba4" translate="yes" xml:space="preserve">
          <source>Interested in learning more?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes" xml:space="preserve">
          <source>Interfaces Extending Classes</source>
          <target state="translated">Интерфейсы расширяющие классы</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes" xml:space="preserve">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target state="translated">Интерфейсы способны описывать широкий спектр форм,которые могут принимать JavaScript-объекты.Помимо описания объекта со свойствами,интерфейсы также способны описывать типы функций.</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes" xml:space="preserve">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target state="translated">Интерфейсы описывают публичную сторону класса,а не как публичную,так и частную.Это запрещает использовать их для проверки того,что класс также имеет определенные типы для частной стороны экземпляра класса.</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes" xml:space="preserve">
          <source>Interfaces vs. Type Aliases</source>
          <target state="translated">Интерфейсы против псевдонимов типа</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes" xml:space="preserve">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target state="translated">Интерфейсы с дополнительными свойствами записываются так же, как и другие интерфейсы, причем каждое дополнительное свойство обозначается знаком &lt;code&gt;?&lt;/code&gt; в конце названия свойства в объявлении.</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">Типы пересечения</target>
        </trans-unit>
        <trans-unit id="084148d39f0e6339840f9abce4a71b7b8a28568e" translate="yes" xml:space="preserve">
          <source>Intersection and Union types are one of the ways in which you can compose types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes" xml:space="preserve">
          <source>Intersection types</source>
          <target state="translated">Типы пересечения</target>
        </trans-unit>
        <trans-unit id="b78d51b88c1d1feb693e6d11fb2eab9417d88d2e" translate="yes" xml:space="preserve">
          <source>Intersection types are closely related to union types, but they are used very differently. An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a type which is all of &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564a9241fc2a9fe2599b22267f67a36231a5fd3e" translate="yes" xml:space="preserve">
          <source>Intersections</source>
          <target state="translated">Intersections</target>
        </trans-unit>
        <trans-unit id="024b4beab6775314e602953c2f94088fe4678bde" translate="yes" xml:space="preserve">
          <source>Intrinsic String Manipulation Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes" xml:space="preserve">
          <source>Intrinsic elements</source>
          <target state="translated">внутренние элементы</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes" xml:space="preserve">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target state="translated">Внутренние элементы &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; в специальном интерфейсе JSX.IntrinsicElements . По умолчанию, если этот интерфейс не указан, все работает, и внутренние элементы не проверяются на тип. Однако, если этот интерфейс &lt;em&gt;является&lt;/em&gt; присутствует, то имя внутреннего элемента ищется как свойство на &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; интерфейсе. Например:</target>
        </trans-unit>
        <trans-unit id="5929e5c75cee5abeee0333968fe15c20cd3d7eef" translate="yes" xml:space="preserve">
          <source>Intro to the TSConfig Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="7f426c016099b5f664f1e39e6247678f1b9e5312" translate="yes" xml:space="preserve">
          <source>Introduction to the DOM</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes" xml:space="preserve">
          <source>Introduction: Deep Dive</source>
          <target state="translated">Введение:Глубокое погружение</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes" xml:space="preserve">
          <source>Introduction: Find and Install Declaration Files</source>
          <target state="translated">Введение:Поиск и установка файлов декларации</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes" xml:space="preserve">
          <source>Introduction: Library Structures</source>
          <target state="translated">Введение:Библиотечные структуры</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes" xml:space="preserve">
          <source>Introduction: Publish to npm</source>
          <target state="translated">Введение:Публикация в воскресенье</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes" xml:space="preserve">
          <source>Introduction: Sections</source>
          <target state="translated">Введение:Разделы</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes" xml:space="preserve">
          <source>Introduction: Templates</source>
          <target state="translated">Введение:Шаблоны</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes" xml:space="preserve">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target state="translated">Введение:&quot;До&quot; и &quot;Не&quot;.</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target state="translated">Вызов &lt;code&gt;tsc&lt;/code&gt; дважды понесенного более запуск воздушного времени</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target state="translated">Вызов компилятора с параметром &lt;code&gt;--alwaysStrict&lt;/code&gt; вызывает:</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target state="translated">Вызов компилятора с &lt;code&gt;--traceResolution&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92c7543673d428591b536d245bf2f8a34c3f3bdf" translate="yes" xml:space="preserve">
          <source>Is your build output mostly the same as your source input files? Use &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2b2e48ddaed31be99cbca83c7b264785d54b10" translate="yes" xml:space="preserve">
          <source>Isolated Modules - &lt;code&gt;isolatedModules&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54054e6683cbfd13efd0196ccd3001db60a01e75" translate="yes" xml:space="preserve">
          <source>It also ships with a mapped type &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; that makes all properties &lt;code&gt;readonly&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes" xml:space="preserve">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target state="translated">Она также может быть использована в качестве глобальной переменной,но только внутри скрипта.(Сценарий-это файл без импорта и экспорта).</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes" xml:space="preserve">
          <source>It can also be used to create simple namespaces:</source>
          <target state="translated">Его также можно использовать для создания простых пространств имен:</target>
        </trans-unit>
        <trans-unit id="683cf85c60231c18d1e9862199f167cc8ac3cdf5" translate="yes" xml:space="preserve">
          <source>It can be tempting to think that the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; are the same as the lowercase versions recommended above. These types do not refer to the language primitives however, and almost never should be used as a type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38dbabfa59d50143ee85c5c345800b0f340110b" translate="yes" xml:space="preserve">
          <source>It does not change the behavior of your code, or otherwise change the behavior of TypeScript&amp;rsquo;s checking and emitting process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes" xml:space="preserve">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target state="translated">У него нет инициализатора, а предыдущий член перечисления был &lt;em&gt;числовой&lt;/em&gt; константой. В этом случае значением текущего члена перечисления будет значение предыдущего члена перечисления плюс один.</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes" xml:space="preserve">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target state="translated">Распространенным шаблоном является возврат текущего объекта (т. Е. &lt;code&gt;this&lt;/code&gt; ) из метода для создания &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;API свободного стиля&lt;/a&gt; . Например, рассмотрим следующий модуль &lt;code&gt;BasicCalculator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes" xml:space="preserve">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target state="translated">Это ошибка времени компиляции для постоянных выражений перечисления, которые должны оцениваться как &lt;code&gt;NaN&lt;/code&gt; или &lt;code&gt;Infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6c1d1a64c5c77319ef0ca3b0e9b3ec9e20641bd" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and &lt;strong&gt;we recommended modules over namespaces in modern code&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target state="translated">Стоит также отметить,что для приложений Node.js модули являются модулями по умолчанию и рекомендуемым подходом к структурированию вашего кода.</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes" xml:space="preserve">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target state="translated">Ошибкой является ссылка на файл,который не существует.Это ошибка,когда в файле есть ссылка на себя с тройной косой чертой.</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes" xml:space="preserve">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target state="translated">Важно отметить,что вызов функции с слишком большим количеством аргументов является ошибкой.</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes" xml:space="preserve">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target state="translated">Важно отметить, что компилятор &lt;em&gt;не&lt;/em&gt; будет выполнять ни одно из этих преобразований; он просто использует эти части информации, чтобы направлять процесс разрешения импорта модуля в его файл определения.</target>
        </trans-unit>
        <trans-unit id="3789f800d631595c74b86aed0db3fe5327908530" translate="yes" xml:space="preserve">
          <source>It is not a mechanism that &lt;strong&gt;prevents&lt;/strong&gt; a file from being included in the codebase - it simply changes what the &lt;code&gt;include&lt;/code&gt; setting finds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes" xml:space="preserve">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target state="translated">Невозможно использовать объявления &lt;code&gt;infer&lt;/code&gt; в предложениях ограничений для параметров обычного типа:</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes" xml:space="preserve">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target state="translated">Можно определить тип компонента класса. Однако для этого лучше понять два новых термина: &lt;em&gt;тип класса элемента&lt;/em&gt; и &lt;em&gt;тип экземпляра элемента&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes" xml:space="preserve">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">Это первый член в перечислении и у него нет инициализатора, и в этом случае ему присваивается значение &lt;code&gt;0&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target state="translated">Стоит отметить, что если пакет npm уже включает свой файл декларации, как описано в разделе &amp;laquo; &lt;a href=&quot;publishing&quot;&gt;Публикация&amp;raquo;&lt;/a&gt; , загрузка соответствующего пакета &lt;code&gt;@types&lt;/code&gt; не требуется.</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes" xml:space="preserve">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target state="translated">Так уж получилось, что в TypeScript есть что-то, что называется &lt;em&gt;защитой типа&lt;/em&gt; . Защита типа - это некоторое выражение, которое выполняет проверку времени выполнения, гарантирующую тип в некоторой области.</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes" xml:space="preserve">
          <source>It was possible for the implementation files to import the test files</source>
          <target state="translated">Файлы реализации можно было импортировать в тестовые файлы</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target state="translated">Невозможно было построить &lt;code&gt;test&lt;/code&gt; и &lt;code&gt;src&lt;/code&gt; одновременно без &lt;code&gt;src&lt;/code&gt; в имени выходной папки, что вам, вероятно, не нужно.</target>
        </trans-unit>
        <trans-unit id="9c6a38098d06734f39da99f25d9ab37fea049fd8" translate="yes" xml:space="preserve">
          <source>It would be an error to specify &lt;code&gt;rootDir&lt;/code&gt; as &lt;code&gt;core&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;include&lt;/code&gt; as &lt;code&gt;*&lt;/code&gt; because it creates a file (&lt;code&gt;helpers.ts&lt;/code&gt;) that would need to be emitted &lt;em&gt;outside&lt;/em&gt; the &lt;code&gt;outDir&lt;/code&gt; (i.e. &lt;code&gt;../helpers.js&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57b32bfac61e19b63383ba6ca826d555cc838b5" translate="yes" xml:space="preserve">
          <source>It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae1101862749291ae4f393bc2ced9ae6e2e1e04" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;rsquo;re able to do better.</source>
          <target state="translated">Также часто пытаются получить доступ к методу до &lt;code&gt;await&lt;/code&gt; -ing или &lt;code&gt;.then()&lt;/code&gt; -ing &lt;code&gt;Promise&lt;/code&gt; . Это еще один пример среди многих других, когда мы можем добиться большего.</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target state="translated">Также важно отметить, что TypeScript не преобразует ссылки в &lt;code&gt;globalThis&lt;/code&gt; при компиляции в более старые версии ECMAScript. Таким образом, если вы не ориентируетесь на вечнозеленые браузеры (которые уже поддерживают &lt;code&gt;globalThis&lt;/code&gt; ), вы можете вместо этого &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;использовать соответствующий полифилл&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target state="translated">Всегда приятно иметь возможность задокументировать свою конфигурацию! &lt;code&gt;tsconfig.json&lt;/code&gt; теперь принимает однострочные и многострочные комментарии.</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target state="translated">Ошибка при деструкции кортежа за пределами диапазона его элементов:</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target state="translated">В этой ситуации важно не добавлять в начало каждой ссылки, потому что в результате вы получите две копии &lt;code&gt;A&lt;/code&gt; на выходе &lt;code&gt;D&lt;/code&gt; - это может привести к неожиданным результатам.</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">Важно отметить, что awesome-typescript-loader должен запускаться перед любым другим загрузчиком, работающим с файлами &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ffa790ea2c3349ed046c358aae967ad51e1cec" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that ts-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b692de3183276b518dabfb631757e7af1419f734" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to remember that TypeScript uses the same &lt;em&gt;runtime&lt;/em&gt; as JavaScript, so any resources about how to accomplish specific runtime behavior (converting a string to a number, displaying an alert, writing a file to disk, etc.) will always apply equally well to TypeScript programs. Don&amp;rsquo;t limit yourself to TypeScript-specific resources!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target state="translated">API нередко ожидает определенного набора строк для определенных значений. Например, рассмотрим библиотеку пользовательского интерфейса, которая может перемещать элементы по экрану, контролируя &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;laquo;замедление&amp;raquo; анимации.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b18ceff60d615281a03cf2a9ea16d87dd519931" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible you really &lt;em&gt;did&lt;/em&gt; intend to divide a number by an array, perhaps just to see what happens, but most of the time, though, this is a programming mistake. TypeScript&amp;rsquo;s type checker is designed to allow correct programs through while still catching as many common errors as possible. (Later, we&amp;rsquo;ll learn about settings you can use to configure how strictly TypeScript checks your code.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c163602d3325175e90ecde073b2e8d099514998d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth noting that &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file, and that circularity between configuration files is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target state="translated">Стоит отметить, что средство проверки типов не требует, чтобы эти свойства располагались в каком-либо порядке, только чтобы свойства, которые требуются интерфейсу, присутствовали и имели требуемый тип.</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="203e9155620464a525f901cb5421a31b901a89ef" translate="yes" xml:space="preserve">
          <source>Iterators &amp;amp; Generators</source>
          <target state="translated">Итераторы и генераторы</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes" xml:space="preserve">
          <source>Iterators and Generators</source>
          <target state="translated">итераторы и генераторы</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes" xml:space="preserve">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="7aec719645d59e0338990dc21d17c20ab20b5e3a" translate="yes" xml:space="preserve">
          <source>JS Class extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53889159f973b9fcdbf5533d3f8b2fee581e75e1" translate="yes" xml:space="preserve">
          <source>JS Projects Utilizing TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad13379ffbb44dfeef3669b43a6cf7eda0226c2" translate="yes" xml:space="preserve">
          <source>JSDoc Property Modifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196b2a7280a3752416773c234c6662e07ab87209" translate="yes" xml:space="preserve">
          <source>JSDoc Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d193b4e629fd62bb8a4297db587f6b30503894f" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax (&lt;code&gt;[&lt;/code&gt;&lt;code&gt;]&lt;/code&gt;) to express optionality. e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target state="translated">Аннотированные функции JSDoc исключены из этого правила.Используйте синтаксис опциональных параметров JSDoc для выражения необязательности:</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes" xml:space="preserve">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">JSDoc аннотации,украшающие декларацию,будут использованы для установки типа этой декларации.Например:</target>
        </trans-unit>
        <trans-unit id="b57ab1e3e810539c8d1ec0a2a10337c1c2186c67" translate="yes" xml:space="preserve">
          <source>JSDoc annotations come before a declaration will be used to set the type of that declaration. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes" xml:space="preserve">
          <source>JSDoc types are used for type information</source>
          <target state="translated">Для информации о типах используются типы JSDoc</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="200185b1255b1a221ca2903c5a111895d54bee5e" translate="yes" xml:space="preserve">
          <source>JSX - &lt;code&gt;jsx&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a12fc57c5b8ab36078ef438cd9ea85d576a140" translate="yes" xml:space="preserve">
          <source>JSX Factory - &lt;code&gt;jsxFactory&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes" xml:space="preserve">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target state="translated">JSX позволяет вставлять выражения между тегами, заключая выражения в фигурные скобки ( &lt;code&gt;{ }&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes" xml:space="preserve">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target state="translated">Имена и свойства элементов JSX проверяются на соответствие пространству имен &lt;code&gt;JSX&lt;/code&gt; . См. Вики-страницу [[JSX]] для определения пространства имен &lt;code&gt;JSX&lt;/code&gt; для вашей платформы.</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes" xml:space="preserve">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target state="translated">JSX-элементы теперь позволяют передавать аргументы типов в общие компоненты.</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes" xml:space="preserve">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target state="translated">JSX-это встраиваемый XML-подобный синтаксис.Он предназначен для преобразования в полноценный JavaScript,но семантика этого преобразования специфична для реализации.JSX пришел в популярность с библиотекой React,но с тех пор видел другие приложения.TypeScript 1.6 поддерживает встраивание,проверку типов и опциональную компиляцию JSX непосредственно в JavaScript.</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes" xml:space="preserve">
          <source>JSX support</source>
          <target state="translated">JSX поддержка</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes" xml:space="preserve">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target state="translated">Проверка типа JSX управляется определениями в пространстве имен JSX, например &lt;code&gt;JSX.Element&lt;/code&gt; для типа элемента JSX и &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; для встроенных элементов. До TypeScript 2.8 предполагалось, что пространство имен &lt;code&gt;JSX&lt;/code&gt; находится в глобальном пространстве имен и, таким образом, позволяло определять только одно из них в проекте. Начиная с TypeScript 2.8 пространство имен &lt;code&gt;JSX&lt;/code&gt; будет просматриваться в пространстве имен &lt;code&gt;jsxNamespace&lt;/code&gt; (например, &lt;code&gt;React&lt;/code&gt; ), что позволяет использовать несколько фабрик jsx в одной компиляции. Для обратной совместимости глобальное пространство имен &lt;code&gt;JSX&lt;/code&gt; используется в качестве запасного варианта, если в фабричной функции не было определено ни одно из них. В сочетании с файлом &lt;code&gt;@jsx&lt;/code&gt; pragma, каждый файл может иметь свою фабрику JSX.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="0a68962be09173771bec34eb689c44a3c96b2537" translate="yes" xml:space="preserve">
          <source>JavaScript (also known as ECMAScript) started its life as a simple scripting language for browsers. At the time it was invented, it was expected to be used for short snippets of code embedded in a web page &amp;mdash; writing more than a few dozen lines of code would have been somewhat unusual. Due to this, early web browsers executed such code pretty slowly. Over time, though, JS became more and more popular, and web developers started using it to create interactive experiences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d9a3e1ce5dffeacdf5c830a6c6440a69613ddc" translate="yes" xml:space="preserve">
          <source>JavaScript also allows accessing properties which aren&amp;rsquo;t present:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b453322efee2df3d69cc86054aa88030b8bd03" translate="yes" xml:space="preserve">
          <source>JavaScript defines 8 built-in types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c885f8940580133691e264e6c024d89b341481" translate="yes" xml:space="preserve">
          <source>JavaScript does have some limited primitives like &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;, but remember that these operators are still working on the values as they exist in the type-erased output code. For example, &lt;code&gt;typeof (new Car())&lt;/code&gt; will be &lt;code&gt;&quot;object&quot;&lt;/code&gt;, not &lt;code&gt;Car&lt;/code&gt; or &lt;code&gt;&quot;Car&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target state="translated">JavaScript имеет множество различных синтаксисов модулей или соглашений: один в стандарте ECMAScript, тот, который уже поддерживает Node (CommonJS), AMD, System.js и другие! По большей части TypeScript по умолчанию будет автоматически импортировать с использованием синтаксиса модуля ECMAScript, что часто было неприемлемым в некоторых проектах TypeScript с другими настройками компилятора или в проектах Node с простым JavaScript и &lt;code&gt;require&lt;/code&gt; вызовов.</target>
        </trans-unit>
        <trans-unit id="98cdb2f49473d8f457b2b983ae7b2e9569316471" translate="yes" xml:space="preserve">
          <source>JavaScript has boxed equivalents of primitive types that contain the methods that programmers associate with those types. TypeScript reflects this with, for example, the difference between the primitive type &lt;code&gt;number&lt;/code&gt; and the boxed type &lt;code&gt;Number&lt;/code&gt;. The boxed types are rarely needed, since their methods return primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes" xml:space="preserve">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target state="translated">JavaScript по своей сути очень динамичный язык. Нередко одна функция JavaScript возвращает разные типы объектов в зависимости от формы переданных аргументов.</target>
        </trans-unit>
        <trans-unit id="3fa9627af8c315eed2d8a18ed7ec36d91039abb7" translate="yes" xml:space="preserve">
          <source>JavaScript projects can use a &lt;code&gt;jsconfig.json&lt;/code&gt; file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1195a91c56a7095e67e44a18fe31d7c0292fae" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s equality operator (&lt;code&gt;==&lt;/code&gt;) &lt;em&gt;coerces&lt;/em&gt; its arguments, leading to unexpected behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db5a96d3e3aba783d7007c3a17e6f71e51a7e0e" translate="yes" xml:space="preserve">
          <source>JavaScript&amp;rsquo;s modern module syntax is a bit like Haskell&amp;rsquo;s, except that any file with &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is implicitly a module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes" xml:space="preserve">
          <source>Jspm</source>
          <target state="translated">Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes" xml:space="preserve">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target state="translated">Так же, как &amp;laquo;экспорт на верхнем уровне&amp;raquo; снижает трение с потребителями вашего модуля, так и введение экспорта по умолчанию. Если основная цель модуля - разместить один конкретный экспорт, вам следует рассмотреть возможность его экспорта как экспорта по умолчанию. Это упрощает как импорт, так и его фактическое использование. Например:</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes" xml:space="preserve">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target state="translated">Как и в JavaScript, функции могут ссылаться на переменные вне тела функции. Когда они это делают, они говорят, что &lt;em&gt;улавливают&lt;/em&gt; эти переменные. Хотя понимание того, как это работает (и компромиссов при использовании этой техники) выходит за рамки данной статьи, твердое понимание того, как работает этот механизм, является важной частью работы с JavaScript и TypeScript.</target>
        </trans-unit>
        <trans-unit id="f568f7b7378d75e427e395efb94692dbc6539719" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">Так же, как существует взаимно однозначное соответствие между JS-файлами и модулями, TypeScript имеет однозначное соответствие между исходными файлами модулей и их созданными JS-файлами. Одним из следствий этого является то, что невозможно объединить несколько исходных файлов модулей в зависимости от целевой системы модулей. Например, вы не можете использовать &lt;code&gt;outFile&lt;/code&gt; опцию во время ориентации &lt;code&gt;commonjs&lt;/code&gt; или &lt;code&gt;umd&lt;/code&gt; , но с машинопись 1.8 и более поздних версий, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;это можно&lt;/a&gt; использовать &lt;code&gt;outFile&lt;/code&gt; при ориентации &lt;code&gt;amd&lt;/code&gt; или &lt;code&gt;system&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ce9925cfd88bf773f747d79c2d2f37e043fb9f" translate="yes" xml:space="preserve">
          <source>Just as with &lt;code&gt;for / of&lt;/code&gt;, &lt;code&gt;downlevelIteration&lt;/code&gt; will use &lt;code&gt;Symbol.iterator&lt;/code&gt; (if present) to more accurately emulate ES 6 behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes" xml:space="preserve">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target state="translated">Как и в случае с интерфейсом,размещение параметра type на самом классе позволяет нам убедиться,что все свойства класса работают с одним типом.</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes" xml:space="preserve">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target state="translated">Как и в случае всех глобальных загрязнений именного пространства,может быть трудно определить зависимости компонентов,особенно в крупных приложениях.</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes" xml:space="preserve">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target state="translated">Как и интерфейсы,псевдонимы типов также могут быть общими-мы можем просто добавить параметры типа и использовать их в правой части объявления псевдонима:</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes" xml:space="preserve">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target state="translated">Как и пространства имен, модули могут содержать как код, так и объявления. Основное отличие состоит в том, что модули &lt;em&gt;объявляют&lt;/em&gt; свои зависимости.</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes" xml:space="preserve">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target state="translated">Как и строки,символы могут использоваться в качестве ключей к свойствам объектов.</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes" xml:space="preserve">
          <source>Just run:</source>
          <target state="translated">Просто беги:</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; будет включен вместе с другими &lt;code&gt;--strict&lt;/code&gt; режима --strict , что может повлиять на ваш проект. Вы можете установить &lt;code&gt;strictPropertyInitialization&lt;/code&gt; установку на &lt;code&gt;false&lt;/code&gt; в вашем &lt;code&gt;tsconfig.json&lt;/code&gt; &amp;laquo;s &lt;code&gt;compilerOptions&lt;/code&gt; или &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; в командной строке , чтобы отключить эту проверку.</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target state="translated">Имейте в виду, что &lt;code&gt;?.&lt;/code&gt; действует иначе, чем эти операции &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , поскольку &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; будет действовать особым образом с &amp;laquo;ложными&amp;raquo; значениями (например, пустая строка, &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; и, ну, ну, &lt;code&gt;false&lt;/code&gt; ), но это намеренная особенность конструкции. Он не закорачивает действительные данные, такие как &lt;code&gt;0&lt;/code&gt; или пустые строки.</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes" xml:space="preserve">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target state="translated">Имейте в виду, что автоматическое включение важно только в том случае, если вы используете файлы с глобальными объявлениями (в отличие от файлов, объявленных как модули). Если вы, например, используете оператор &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; , TypeScript может по-прежнему просматривать &lt;code&gt;node_modules&lt;/code&gt; и &lt;code&gt;node_modules/@types&lt;/code&gt; чтобы найти пакет &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes" xml:space="preserve">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target state="translated">Имейте в виду, что для простого кода, подобного приведенному выше, вам, вероятно, не следует пытаться &amp;laquo;обойти&amp;raquo; эти проверки. Для более сложных объектных литералов, которые имеют методы и удерживают состояние, вам может потребоваться помнить об этих методах, но большинство ошибок избыточных свойств на самом деле являются ошибками. Это означает, что если вы сталкиваетесь с лишними проблемами проверки свойств для чего-то вроде пакетов опций, вам может потребоваться пересмотреть некоторые объявления типов. В этом случае, если можно передать объект со свойством &lt;code&gt;color&lt;/code&gt; или &lt;code&gt;colour&lt;/code&gt; в &lt;code&gt;createSquare&lt;/code&gt; , вы должны исправить определение &lt;code&gt;SquareConfig&lt;/code&gt; , чтобы это отразить.</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes" xml:space="preserve">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</source>
          <target state="translated">Имейте в виду, что наша поддержка асинхронных итераторов зависит от поддержки &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; во время выполнения. Возможно, вам потребуется полифиллировать &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; , который для простых целей может быть таким простым, как: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target state="translated">Имейте в виду, что члены строкового перечисления &lt;em&gt;вообще не&lt;/em&gt; генерируют обратное отображение.</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes" xml:space="preserve">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target state="translated">Держите устаревший выход консоли в режиме смотреть вместо очистки экрана</target>
        </trans-unit>
        <trans-unit id="652c3d36f013f3eb41d356a2dc9496bad6b87cd2" translate="yes" xml:space="preserve">
          <source>Keeping the same runtime behavior as JavaScript is a foundational promise of TypeScript because it means you can easily transition between the two languages without worrying about subtle differences that might make your program stop working.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="translated">Ключевые концепции</target>
        </trans-unit>
        <trans-unit id="e3f555e673324c6ef7fc096a52a9695768dbceba" translate="yes" xml:space="preserve">
          <source>Keyof Strings Only - &lt;code&gt;keyofStringsOnly&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842ec99d82ed307bd84f2310114874cbd9666b4e" translate="yes" xml:space="preserve">
          <source>Labels are very rare in JavaScript and typically indicate an attempt to write an object literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3366a00a2d7b488f6edaccf084d0f236fe293734" translate="yes" xml:space="preserve">
          <source>Language service plugins are a way to provide additional information to a user based on existing TypeScript files. They can enhance existing messages between TypeScript and an editor, or to provide their own error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes" xml:space="preserve">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target state="translated">Наконец,мы создаем вспомогательную функцию,которая будет делать микширование за нас.Она пройдет через свойства каждого из миксов и скопирует их в цель миксов,заполнив свойства stand-in их реализациями.</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes" xml:space="preserve">
          <source>Lay out the project</source>
          <target state="translated">Выложить проект</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes" xml:space="preserve">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target state="translated">Макет для компиляций с использованием &lt;code&gt;outFile&lt;/code&gt; более гибкий, потому что относительные пути не имеют большого значения. Следует иметь в виду, что обычно вы не хотите использовать &lt;code&gt;prepend&lt;/code&gt; до &amp;laquo;последнего&amp;raquo; проекта - это сократит время сборки и уменьшит количество операций ввода-вывода, необходимых в любой данной сборке. Сам репозиторий TypeScript может служить здесь хорошей ссылкой - у нас есть несколько &amp;laquo;библиотечных&amp;raquo; проектов и несколько проектов &amp;laquo;конечных точек&amp;raquo;; &amp;laquo;Конечные&amp;raquo; проекты сохраняются как можно меньше и включают только те библиотеки, которые им нужны.</target>
        </trans-unit>
        <trans-unit id="a8ce8ab803d2f69beb12ecc965c63513d9c144ec" translate="yes" xml:space="preserve">
          <source>Learn how to use a &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f574e7a40077551e582b33afc9de1c41b4ea1f26" translate="yes" xml:space="preserve">
          <source>Learn how to work in an &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild project&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a698431922622bdba500ba547874a9e36cb868" translate="yes" xml:space="preserve">
          <source>Learn how to write declaration files to describe existing JavaScript. Important for DefinitelyTyped contributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1f5cb90f300e2c9d89b461fd1882c4957ea2a20" translate="yes" xml:space="preserve">
          <source>Learning JavaScript and TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes" xml:space="preserve">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target state="translated">Изучение того, как использовать &lt;code&gt;this&lt;/code&gt; в JavaScript, - своего рода обряд посвящения. Поскольку TypeScript - это надмножество JavaScript, разработчикам TypeScript также необходимо научиться использовать &lt;code&gt;this&lt;/code&gt; и как определять, когда он используется неправильно. К счастью, TypeScript позволяет отловить неправильное использование &lt;code&gt;this&lt;/code&gt; с помощью пары приемов. Если вам нужно узнать, как &lt;code&gt;this&lt;/code&gt; работает в JavaScript, сначала прочтите &amp;laquo; &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Понимание вызова функций JavaScript&amp;raquo;&lt;/a&gt; Иегуды Каца и &amp;laquo;this&amp;raquo; . В статье Иегуды очень хорошо объясняется внутренняя работа &lt;code&gt;this&lt;/code&gt; механизма, поэтому мы рассмотрим здесь только основы.</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target state="translated">Давайте добавим пару интерфейсов к нашему примеру выше, &lt;code&gt;Card&lt;/code&gt; и &lt;code&gt;Deck&lt;/code&gt; , чтобы сделать типы более понятными и удобными для повторного использования:</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target state="translated">Давайте добавим типы в наши простые примеры из ранее:</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target state="translated">Давайте преобразуем простой класс для использования &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;set&lt;/code&gt; . Во-первых, давайте начнем с примера без геттеров и сеттеров.</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target state="translated">Давайте дальше развивать наш образец. Здесь мы используем интерфейс, который описывает объекты, у которых есть поля firstName и lastName. В TypeScript два типа совместимы, если совместима их внутренняя структура. Это позволяет нам реализовать интерфейс, просто имея форму, которая требуется интерфейсу, без явного предложения &lt;code&gt;implements&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target state="translated">Начнем с создания простого веб-приложения с помощью TypeScript.</target>
        </trans-unit>
        <trans-unit id="31f50512e5bac716ad2127f4d6b19108bf103d8e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for a version of &lt;code&gt;padLeft&lt;/code&gt; which uses union types. We could write it with type predicates as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">Вернемся назад и напишем код для версии &lt;code&gt;padLeft&lt;/code&gt; , использующей типы объединения. Мы могли бы написать его с помощью предикатов типа следующим образом:</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target state="translated">Давайте посмотрим на довольно обычную программу и посмотрим, как ссылки на проекты могут помочь нам лучше организовать ее. Представьте, что у вас есть проект с двумя модулями, &lt;code&gt;converter&lt;/code&gt; и &lt;code&gt;units&lt;/code&gt; , и соответствующим тестовым файлом для каждого из них:</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target state="translated">Давайте рассмотрим пример, чтобы лучше понять, как это работает на практике:</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target state="translated">Давайте посмотрим на пример:</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target state="translated">Давайте немного изменим пример, чтобы показать эту разницу:</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">Теперь давайте добавим React и React-DOM вместе с их файлами объявлений в качестве зависимостей к вашему файлу &lt;code&gt;package.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target state="translated">Давайте теперь посмотрим на более сложный пример.</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target state="translated">Давайте предположим , что мы на самом деле предназначены для этой функции работы с массивами &lt;code&gt;T&lt;/code&gt; , а не &lt;code&gt;T&lt;/code&gt; непосредственно. Поскольку мы работаем с массивами, член &lt;code&gt;.length&lt;/code&gt; должен быть доступен. Мы можем описать это так же, как создавали бы массивы других типов:</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt;.</source>
          <target state="translated">Допустим, у нас есть образец приложения, в котором используется модуль &lt;code&gt;typescript&lt;/code&gt; . &lt;code&gt;app.ts&lt;/code&gt; имеет импорт как &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target state="translated">Допустим, мы написали файл модуля &lt;code&gt;foo.d.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target state="translated">Давайте построим это:</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target state="translated">Посмотрим, как это можно использовать.</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target state="translated">Начнем с нового каталога. На данный момент мы назовем его &lt;code&gt;proj&lt;/code&gt; , но вы можете изменить его как хотите.</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target state="translated">Начнем с программы, которую мы будем использовать в качестве примера на этой странице. Мы написали небольшой набор упрощенных валидаторов строк, которые вы могли бы написать для проверки ввода пользователя в форме на веб-странице или для проверки формата файла данных, предоставленного извне.</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target state="translated">Давайте посмотрим на простой пример на основе классов:</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">Давайте посмотрим на пример:</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target state="translated">Давайте посмотрим на простейший отображаемый тип и его части:</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">Давайте посмотрим, что это значит. &lt;code&gt;setTimeout&lt;/code&gt; запустит функцию через некоторое количество миллисекунд, &lt;em&gt;но только&lt;/em&gt; после того, &lt;code&gt;for&lt;/code&gt; цикл for прекратит выполнение; К тому времени, когда цикл &lt;code&gt;for&lt;/code&gt; перестанет выполняться, значение &lt;code&gt;i&lt;/code&gt; равно &lt;code&gt;10&lt;/code&gt; . Таким образом, каждый раз, когда вызывается данная функция, она выводит &lt;code&gt;10&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target state="translated">Возьмем нашу функцию &lt;code&gt;identity&lt;/code&gt; ранее:</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target state="translated">Напишем программу Hello World. В &lt;code&gt;src&lt;/code&gt; создайте файл &lt;code&gt;main.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target state="translated">Напишем наш первый файл TypeScript с помощью React. Сначала создайте файл с именем &lt;code&gt;Hello.tsx&lt;/code&gt; в &lt;code&gt;src/components&lt;/code&gt; и напишите следующее:</target>
        </trans-unit>
        <trans-unit id="2eef507232d254af5e9e59f7ec1b8cab255e33eb" translate="yes" xml:space="preserve">
          <source>Lets explore a TypeScript script that adds a &lt;code&gt;&amp;lt;p&amp;gt;Hello, World!&amp;lt;/p&amp;gt;&lt;/code&gt; element to the &lt;code&gt;#app&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae2739f68fb37ce086c5c2093758c62b36667b3" translate="yes" xml:space="preserve">
          <source>Lets explore a TypeScript script that adds a &lt;code&gt;&amp;lt;p&amp;gt;Hello, World&amp;lt;/p&amp;gt;&lt;/code&gt; element to the &lt;code&gt;#app&lt;/code&gt; element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7305992657ab0909fb4eb83c394c6114c9f6b07" translate="yes" xml:space="preserve">
          <source>Lets you set a base directory to resolve non-absolute module names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes" xml:space="preserve">
          <source>LettersOnlyValidator.ts</source>
          <target state="translated">LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="0282b6f4a590ade8d83152438864b31e1ed6a0e7" translate="yes" xml:space="preserve">
          <source>Lib - &lt;code&gt;lib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes" xml:space="preserve">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target state="translated">Библиотеки также могут использовать &lt;code&gt;this&lt;/code&gt; параметры, чтобы объявить, как будут вызываться обратные вызовы.</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes" xml:space="preserve">
          <source>Library Structures</source>
          <target state="translated">Библиотечные структуры</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes" xml:space="preserve">
          <source>Library Structures: Consuming Dependencies</source>
          <target state="translated">Библиотечные структуры:Потребительские зависимости</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target state="translated">Библиотечные структуры:Зависимость от глобальных библиотек</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Modules</source>
          <target state="translated">Библиотечные структуры:Зависимости от модулей</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target state="translated">Библиотечные структуры:Зависимости от библиотек UMD</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Libraries</source>
          <target state="translated">Библиотечные структуры:Всемирные библиотеки</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Plugin</source>
          <target state="translated">Библиотечные структуры:Глобальный плагин</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes" xml:space="preserve">
          <source>Library Structures: Global-modifying Modules</source>
          <target state="translated">Библиотечные структуры:Модули глобальной модификации</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes" xml:space="preserve">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target state="translated">Библиотечные структуры:Определение видов библиотек</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes" xml:space="preserve">
          <source>Library Structures: Library file layout</source>
          <target state="translated">Библиотечные структуры:Планировка файлов библиотеки</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes" xml:space="preserve">
          <source>Library Structures: Modular Libraries</source>
          <target state="translated">Библиотечные структуры:Модульные библиотеки</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes" xml:space="preserve">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target state="translated">Библиотечные структуры:Плагин модуля или UMD плагин</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes" xml:space="preserve">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target state="translated">Библиотечные структуры:Предотвращение именных конфликтов</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes" xml:space="preserve">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target state="translated">Библиотечные структуры:Влияние ES6 на модульные плагины</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes" xml:space="preserve">
          <source>Library Structures: UMD</source>
          <target state="translated">Библиотечные структуры:УМД</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes" xml:space="preserve">
          <source>Library file layout</source>
          <target state="translated">Макет файла библиотеки</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Лицензия Apache,версия 2.0.</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes" xml:space="preserve">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target state="translated">Как и при уничтожении массивов,можно получить назначение без объявления:</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes" xml:space="preserve">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target state="translated">Как и классы,интерфейсы могут расширять друг друга.Это позволяет копировать элементы одного интерфейса в другой,что дает вам больше гибкости в разделении интерфейсов на компоненты многократного использования.</target>
        </trans-unit>
        <trans-unit id="7d787f38e64660d964087ea17b902351795b7ef8" translate="yes" xml:space="preserve">
          <source>Like most C-descended languages, TypeScript requires declaration of type parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes" xml:space="preserve">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target state="translated">Как и другие специальные JS-проверки поведения,это поведение можно изменить,указав для переменной тип JSDoc.Например:</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes" xml:space="preserve">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target state="translated">Как мы уже упоминали, сообщения об ошибках после преобразования не являются неожиданными. Важно действительно пройти через них один за другим и решить, что делать с ошибками. Часто это законные ошибки, но иногда вам придется объяснять, что вы пытаетесь сделать с TypeScript немного лучше.</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes" xml:space="preserve">
          <source>Likewise, for the return type of a function:</source>
          <target state="translated">Аналогично,для возвращаемого типа функции:</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes" xml:space="preserve">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target state="translated">Аналогичным образом,множественные кандидаты на одну и ту же переменную типа в противоположных позициях приводят к выводу о типе пересечения:</target>
        </trans-unit>
        <trans-unit id="17904ff532be036b7cb87941e7bed2e100c68152" translate="yes" xml:space="preserve">
          <source>Linter Checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="885980150a8aa23ee2581fde57cdd77e524c220a" translate="yes" xml:space="preserve">
          <source>List Emitted Files - &lt;code&gt;listEmittedFiles&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef72f198033a01dd1518070e6ebb3e26bd88d5da" translate="yes" xml:space="preserve">
          <source>List Files - &lt;code&gt;listFiles&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">Список</target>
        </trans-unit>
        <trans-unit id="0a9f639b79fa294ae337e3e6ef448a4796481e4d" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">Список папок, из которых нужно включить определения типов. Подробнее см. &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@Types, &amp;ndash;typeRoots и &amp;ndash;types&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc93386b00a8c2f17516b547e96b3b9822dd074a" translate="yes" xml:space="preserve">
          <source>List of language service plugins to run inside the editor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes" xml:space="preserve">
          <source>List of library files to be included in the compilation.</source>
          <target state="translated">Список файлов библиотеки,которые будут включены в компиляцию.</target>
        </trans-unit>
        <trans-unit id="9230df08537df807ad2117d7fc0d39c84158a446" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#types&quot;&gt;@types, &amp;mdash;typeRoots and &amp;mdash;types&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">Список имен включаемых определений типов. Подробнее см. &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@Types, &amp;ndash;typeRoots и &amp;ndash;types&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes" xml:space="preserve">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Список записей сопоставления путей для имен модулей с местоположениями относительно &lt;code&gt;baseUrl&lt;/code&gt; . См. &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Документацию Module Resolution&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="de64a9e9a2fea78c8d6ba63c5e5b1387423f2076" translate="yes" xml:space="preserve">
          <source>Literal Narrowing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f9843abf3eea470a268920f6429a30a79e8c27" translate="yes" xml:space="preserve">
          <source>Literal Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes" xml:space="preserve">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target state="translated">Расширение буквального типа можно контролировать с помощью явных аннотаций типов. В частности, когда выражение типа литерала выводится для константного местоположения без аннотации типа, эта &lt;code&gt;const&lt;/code&gt; переменная получает вывод расширяющегося типа литерала. Но когда &lt;code&gt;const&lt;/code&gt; местоположение имеет явную аннотацию литерального типа, &lt;code&gt;const&lt;/code&gt; переменная получает нерасширяющий литеральный тип.</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes" xml:space="preserve">
          <source>Loading of types from npm packages</source>
          <target state="translated">Загрузка типов из npm-пакетов</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes" xml:space="preserve">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target state="translated">Местные и импортные типовые декларации теперь конфликтуют.</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes" xml:space="preserve">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target state="translated">Объявления локального класса, интерфейса, перечисления и псевдонима типа теперь могут появляться внутри объявлений функций. Локальные типы имеют блочную область видимости, аналогично переменным, объявленным с помощью &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes" xml:space="preserve">
          <source>Local type declarations</source>
          <target state="translated">Локальные декларации типа</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes" xml:space="preserve">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target state="translated">Локальные типы могут ссылаться на параметры типа ограждения,а локальные классы и интерфейсы сами по себе могут быть общими.Например:</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes" xml:space="preserve">
          <source>Localized diagnostics on the command line</source>
          <target state="translated">Локализованная диагностика в командной строке</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes" xml:space="preserve">
          <source>Locally scoped JSX namespaces</source>
          <target state="translated">Пространства имен JSX с локальным охватом</target>
        </trans-unit>
        <trans-unit id="f24374818cfbd2c002fceb8b97034ee88dd96257" translate="yes" xml:space="preserve">
          <source>Location of default .d.ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes" xml:space="preserve">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes" xml:space="preserve">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target state="translated">Ищите в первой папке localhost,затем скрипты/app.ts.</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes" xml:space="preserve">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target state="translated">Загляните в свой файл &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; . Здесь &lt;code&gt;tsc&lt;/code&gt; авторитетные сопоставления между тегами XML MSBuild и параметрами компилятора tsc .</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes" xml:space="preserve">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes" xml:space="preserve">
          <source>MSBuild Property Name</source>
          <target state="translated">Имя собственности MSBuild</target>
        </trans-unit>
        <trans-unit id="6460830fa61cf6da70e79284adc64a8688cb9f06" translate="yes" xml:space="preserve">
          <source>MSG</source>
          <target state="translated">MSG</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes" xml:space="preserve">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target state="translated">Убедитесь, что модули работают, запустив &lt;code&gt;gulp&lt;/code&gt; и затем протестировав в Node:</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes" xml:space="preserve">
          <source>Make sure to revisit the &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target state="translated">Обязательно посетите раздел &quot; &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Потребление зависимостей&quot;&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes" xml:space="preserve">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target state="translated">Многие разработчики JavaScript хорошо знакомы с этим поведением, но, если вы удивлены, вы определенно не одиноки. Большинство людей ожидают, что результат будет</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes" xml:space="preserve">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target state="translated">Многие сборщики поддерживают автоматическое разделение выходных пакетов на основе этих выражений &lt;code&gt;import&lt;/code&gt; , поэтому рассмотрите возможность использования этой новой функции с &lt;code&gt;esnext&lt;/code&gt; модуля esnext .</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes" xml:space="preserve">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target state="translated">Можно легко избежать многих типичных ошибок в файлах деклараций. В разделе, &lt;a href=&quot;do-s-and-don-ts&quot;&gt;что можно и что нельзя делать,&lt;/a&gt; выявляются типичные ошибки, описываются способы их обнаружения и исправления. Каждый должен прочитать этот раздел, чтобы избежать распространенных ошибок.</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes" xml:space="preserve">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href=&quot;http://expressjs.com/&quot;&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/request/request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Многие популярные библиотеки Node.js входят в семейство модулей, например, &lt;a href=&quot;http://expressjs.com/&quot;&gt; &lt;code&gt;express&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://gulpjs.com/&quot;&gt; &lt;code&gt;gulp&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://github.com/request/request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes" xml:space="preserve">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target state="translated">Многие популярные библиотеки,такие как Express,при импорте выставляют себя в качестве вызываемой функции.Например,типичное использование Express выглядит следующим образом:</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes" xml:space="preserve">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">Часто мы сталкиваемся с написанием файла объявления, когда у нас есть только примеры базовой библиотеки, которые могут нам помочь. В разделе &amp;laquo; &lt;a href=&quot;by-example&quot;&gt;На примере&lt;/a&gt; &amp;raquo; показано множество общих шаблонов API и показано, как писать объявления для каждого из них. Это руководство предназначено для новичков в TypeScript, которые, возможно, еще не знакомы со всеми языковыми конструкциями в TypeScript.</target>
        </trans-unit>
        <trans-unit id="e04dbd57e91d78d0c5bec01a4fe02f73a4ba1540" translate="yes" xml:space="preserve">
          <source>Map Root - &lt;code&gt;mapRoot&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes" xml:space="preserve">
          <source>Mapped Types</source>
          <target state="translated">Отображение типов</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">Картированные типы</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes" xml:space="preserve">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target state="translated">Отображаемые типы создаются путем объединения литеральных типов и вычисления набора свойств для нового типа объекта. Они похожи на &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;понимание списков в Python&lt;/a&gt; , но вместо создания новых элементов в списке они создают новые свойства в типе.</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes" xml:space="preserve">
          <source>Mapped types on tuples and arrays</source>
          <target state="translated">Отображение типов на кортежах и массивах</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes" xml:space="preserve">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target state="translated">Сопоставленные типы поддерживают добавление только для &lt;code&gt;readonly&lt;/code&gt; или &lt;code&gt;?&lt;/code&gt; модификатора сопоставленного свойства, но они не поддерживают возможность &lt;em&gt;удаления&lt;/em&gt; модификаторов. Это имеет значение для &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;гомоморфных отображаемых типов,&lt;/em&gt;&lt;/a&gt; которые по умолчанию сохраняют модификаторы базового типа.</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes" xml:space="preserve">
          <source>Matching behavior</source>
          <target state="translated">Соответствующее поведение</target>
        </trans-unit>
        <trans-unit id="e877b2873e30b35f125ca0ad5fb9dc583519caa0" translate="yes" xml:space="preserve">
          <source>Max Node Module JS Depth - &lt;code&gt;maxNodeModuleJsDepth&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6746fd6ef4bdedacc9e255f7e5c953f3f9081507" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some experienced JavaScript developers, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">Возможно, для некоторых это было легко заметить, но внутренний цикл &lt;code&gt;for&lt;/code&gt; случайно перезапишет переменную &lt;code&gt;i&lt;/code&gt; , потому что &lt;code&gt;i&lt;/code&gt; ссылается на ту же переменную в области функций. Как уже известно опытным разработчикам, подобные ошибки проскальзывают при проверке кода и могут стать бесконечным источником разочарования.</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes" xml:space="preserve">
          <source>Merging Interfaces</source>
          <target state="translated">Слияние интерфейсов</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes" xml:space="preserve">
          <source>Merging Namespaces</source>
          <target state="translated">Слияние имен</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes</source>
          <target state="translated">Слияние именных пространств с классами</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target state="translated">Объединение пространств имен с классами,функциями и переписями</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes" xml:space="preserve">
          <source>Merging ambient class and interface declaration</source>
          <target state="translated">Слияние класса окружающей среды и декларации интерфейса</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes" xml:space="preserve">
          <source>Method Decorators</source>
          <target state="translated">Метод Декораторы</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes" xml:space="preserve">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target state="translated">Методы абстрактного класса, помеченные как абстрактные, не содержат реализации и должны быть реализованы в производных классах. Синтаксис абстрактных методов схож с синтаксисом методов интерфейса. Оба определяют сигнатуру метода без включения тела метода. Однако абстрактные методы должны включать ключевое слово &lt;code&gt;abstract&lt;/code&gt; и могут дополнительно включать модификаторы доступа.</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.Compiler</source>
          <target state="translated">Microsoft.TypeScript.Compiler</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target state="translated">Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript</source>
          <target state="translated">Миграция с JavaScript</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target state="translated">Мигрирую с JavaScript:Ранние преимущества</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target state="translated">Мигрирую с JavaScript:Получение более строгих проверок</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Gulp</source>
          <target state="translated">Мигрирую с JavaScript:Gulp</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target state="translated">Мигрирую с JavaScript:Интеграция со встроенными инструментами</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target state="translated">Мигрирую с JavaScript:Переход к файлам TypeScript</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target state="translated">Мигрирую с JavaScript:Настройка каталогов</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Webpack</source>
          <target state="translated">Мигрирую с JavaScript:Вебпак</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target state="translated">Мигрирую с JavaScript:Устранение ошибок</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target state="translated">Мигрирую с JavaScript:Написание файла конфигурации</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes" xml:space="preserve">
          <source>Minimal project</source>
          <target state="translated">Минимальный проект</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes" xml:space="preserve">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target state="translated">Классы Mixin могут ограничивать типы классов, с которыми они могут смешиваться, путем указания возвращаемого типа сигнатуры конструкции в ограничении для параметра типа. Например, следующая функция &lt;code&gt;WithLocation&lt;/code&gt; реализует фабрику подклассов, которая добавляет метод &lt;code&gt;getLocation&lt;/code&gt; к любому классу, который удовлетворяет интерфейсу &lt;code&gt;Point&lt;/code&gt; (т. Е. Имеет свойства &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; типа &lt;code&gt;number&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes" xml:space="preserve">
          <source>Mixin sample</source>
          <target state="translated">Образец миксина</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="bf3760256feac6cc46ec45ef674425285cde51d6" translate="yes" xml:space="preserve">
          <source>Modern browsers support all ES6 features, so &lt;code&gt;ES6&lt;/code&gt; is a good choice. You might choose to set a lower target if your code is deployed to older environments, or a higher target if your code is guaranteed to run in newer environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b8e599868465369a62573e28c7d5b2c17c8067" translate="yes" xml:space="preserve">
          <source>Modify the html by removing one of the &lt;code&gt;p&lt;/code&gt; tags, but keep the text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes" xml:space="preserve">
          <source>Modular Libraries</source>
          <target state="translated">Модульные библиотеки</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes" xml:space="preserve">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target state="translated">Модульные библиотеки,как правило,имеют,по крайней мере,некоторые из следующих элементов:</target>
        </trans-unit>
        <trans-unit id="680e2cdf724785f8d2fb8c99fb4ac60b980c1748" translate="yes" xml:space="preserve">
          <source>Module - &lt;code&gt;module&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes" xml:space="preserve">
          <source>Module Augmentation</source>
          <target state="translated">Модуль Дополнение</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes" xml:space="preserve">
          <source>Module Resolution</source>
          <target state="translated">Разрешение модуля</target>
        </trans-unit>
        <trans-unit id="3f1f355f5558be61bf0295855b4e35d7e9e193c7" translate="yes" xml:space="preserve">
          <source>Module Resolution - &lt;code&gt;moduleResolution&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes" xml:space="preserve">
          <source>Module Resolution Strategies</source>
          <target state="translated">Стратегии решения модулей</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes" xml:space="preserve">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target state="translated">Идентификаторы модулей допускают расширение &lt;code&gt;.js&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes" xml:space="preserve">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target state="translated">Импорт модулей разрешается по-разному в зависимости от того,является ли ссылка на модуль относительной или нет.</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes" xml:space="preserve">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target state="translated">Загрузчики модулей, такие как SystemJS, обертывают модули CommonJS и выставляют их в качестве импорта ES6 по &lt;code&gt;default&lt;/code&gt; . Это делает невозможным совместное использование файлов определений между реализациями модуля SystemJS и CommonJS, поскольку форма модуля выглядит по-разному в зависимости от загрузчика.</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes" xml:space="preserve">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target state="translated">Улучшение разрешения модулей:BaseUrl,картирование путей,корневые дирса и трассировка</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes" xml:space="preserve">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target state="translated">Тип разрешения модуля не указывается с использованием &lt;strong&gt;NodeJs&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="de70d79767a9e812db99a7c477172374c0a8abe1" translate="yes" xml:space="preserve">
          <source>Module system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e1df43e7e9f83fc7173a7334ad19fcc3cc8e8bc" translate="yes" xml:space="preserve">
          <source>Module: Class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f261737e777673d28880af66138654486e39e3bc" translate="yes" xml:space="preserve">
          <source>Module: Function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2f8f319a1e5fc06c98c20b985a907aed2cafd5" translate="yes" xml:space="preserve">
          <source>Module: Plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="48e09f525757a351dfe7b299e6750c6d122d7d38" translate="yes" xml:space="preserve">
          <source>Modules .d.ts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d8406349015ac16eed554df9f310ef31446573" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">Модули также имеют зависимость от загрузчика модулей (например,CommonJs/Require.js).Для небольшого JS-приложения это может быть неоптимально,но для больших приложений,затраты приходят с долгосрочными преимуществами модульности и ремонтопригодности.Модули обеспечивают лучшее повторное использование кода,более сильную изоляцию и лучшую инструментальную поддержку для комплектации.</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes" xml:space="preserve">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target state="translated">Модули являются декларативными,отношения между модулями задаются на уровне файлов с точки зрения импорта и экспорта.</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes" xml:space="preserve">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target state="translated">Модули выполняются в своей собственной области видимости, а не в глобальной области; это означает, что переменные, функции, классы и т. д., объявленные в модуле, не видны за пределами модуля, если они не экспортируются явно с помощью одной из &lt;a href=&quot;#export&quot;&gt;форм &lt;/a&gt; &lt;code&gt;export&lt;/code&gt; . И наоборот, чтобы использовать переменную, функцию, класс, интерфейс и т. Д., Экспортированные из другого модуля, ее необходимо импортировать с помощью одной из &lt;a href=&quot;#import&quot;&gt;форм &lt;/a&gt; &lt;code&gt;import&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes" xml:space="preserve">
          <source>Modules are now emitted with a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue</source>
          <target state="translated">Модули теперь выдаются с &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; пролог</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes" xml:space="preserve">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target state="translated">Модули автоматически анализируются в строгом режиме.Новый флаг рекомендуется для не-модульного кода.</target>
        </trans-unit>
        <trans-unit id="eb465684cf64b809ea4e18738ce52c8fd9a32f30" translate="yes" xml:space="preserve">
          <source>Modules can contain both code and declarations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes" xml:space="preserve">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target state="translated">Модули могут импортировать типы, объявленные в других модулях. Но немодульные глобальные скрипты не могут получить доступ к типам, объявленным в модулях. Введите типы &lt;code&gt;import&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">Модули импортируют друг друга с помощью загрузчика модулей. Во время выполнения загрузчик модуля отвечает за обнаружение и выполнение всех зависимостей модуля перед его выполнением. Хорошо известными загрузчиками модулей, используемыми в JavaScript, являются загрузчик Node.js для модулей &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; и загрузчик &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; для модулей &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; в веб-приложениях.</target>
        </trans-unit>
        <trans-unit id="252a052c9420d6ecb6b140e66b5a6e193c6c9859" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes" xml:space="preserve">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target state="translated">Модули всегда анализировались в строгом режиме согласно ES6, но для целей, не относящихся к ES6, это не соблюдалось в сгенерированном коде. Начиная с TypeScript 1.8, генерируемые модули всегда находятся в строгом режиме. Это не должно иметь никаких видимых изменений в большей части кода, поскольку TS рассматривает наиболее строгие ошибки режима как ошибки во время компиляции, но это означает, что некоторые вещи, которые раньше молча выходили из строя во время выполнения в вашем коде TS, например, присвоение &lt;code&gt;NaN&lt;/code&gt; , теперь будут громко потерпеть поражение. Вы можете &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;обратиться к статье MDN&lt;/a&gt; о строгом режиме для получения подробного списка различий между строгим режимом и нестрогим режимом.</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes" xml:space="preserve">
          <source>More Accurate Array Spread</source>
          <target state="translated">Более точное распределение массивов</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes" xml:space="preserve">
          <source>More details about defining MSBuild compiler options: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target state="translated">Дополнительные сведения об определении параметров компилятора MSBuild: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Настройка параметров компилятора в проектах MSBuild&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">Более подробную информацию можно найти в &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;диалоговом окне диспетчера пакетов&lt;/a&gt; и &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;использовании ночных сборок с NuGet.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b8c100979f382dfa286c98e3a8ee4186cc2f221" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;https://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target state="translated">Подробнее: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples / jspm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target state="translated">Подробнее: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong / grunt-ts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target state="translated">Подробнее: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis / duo-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target state="translated">Подробнее: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe / gulp-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq/tsify&lt;/a&gt;</source>
          <target state="translated">Подробнее: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq / tsify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">Другие примеры</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes" xml:space="preserve">
          <source>More information is available at &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode documentation&lt;/a&gt;.</source>
          <target state="translated">Дополнительная информация доступна в &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;документации VSCode&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes" xml:space="preserve">
          <source>More information is available at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target state="translated">Дополнительная информация доступна в &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;документации по установке плагина TypeScript для Sublime Text&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes" xml:space="preserve">
          <source>More more details, you can &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;read up on the proposal&lt;/a&gt; and &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;view the original pull request&lt;/a&gt;.</source>
          <target state="translated">Более подробную информацию вы можете &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;прочитать в предложении&lt;/a&gt; и &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;просмотреть исходный запрос на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="752dbfdfe70e9a653727ad54bd026e4e1adbb672" translate="yes" xml:space="preserve">
          <source>More of a gotcha than a constraint. The class expression pattern creates singletons, so they can&amp;rsquo;t be mapped at the type system to support different variable types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87404c3db1a136e631f5512bc31b4108095e74c7" translate="yes" xml:space="preserve">
          <source>More on Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes" xml:space="preserve">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target state="translated">Проще говоря,этот фрагмент кода-то же самое,что написать следующее.</target>
        </trans-unit>
        <trans-unit id="e65b8445ad886f1be93458429fb5dd37c90a50bb" translate="yes" xml:space="preserve">
          <source>More than this, JS has become popular enough to be used outside the context of browsers, such as implementing JS servers using node.js. The &amp;ldquo;run anywhere&amp;rdquo; nature of JS makes it an attractive choice for cross-platform development. There are many developers these days that use &lt;em&gt;only&lt;/em&gt; JavaScript to program their entire stack!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes" xml:space="preserve">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;, and many more.</source>
          <target state="translated">Самые популярные библиотеки теперь доступны в виде пакетов UMD. Примеры включают &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; , &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; , &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt; и многие другие.</target>
        </trans-unit>
        <trans-unit id="94b01864f5579af47acd49be012292e69db8aa02" translate="yes" xml:space="preserve">
          <source>Most programming languages would throw an error when these sorts of errors occur, some would do so during compilation &amp;mdash; before any code is running. When writing small programs, such quirks are annoying but manageable; when writing applications with hundreds or thousands of lines of code, these constant surprises are a serious problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes" xml:space="preserve">
          <source>Moving to TypeScript Files</source>
          <target state="translated">Переход к файлам TypeScript</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes" xml:space="preserve">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target state="translated">Большую часть времени, когда мы говорим об &amp;laquo;одиночных типах&amp;raquo;, мы имеем в виду оба типа членов перечисления, а также числовые / строковые литералы, хотя многие пользователи будут использовать &amp;laquo;одиночные типы&amp;raquo; и &amp;laquo;литеральные типы&amp;raquo; как синонимы.</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes" xml:space="preserve">
          <source>Multi-file namespaces</source>
          <target state="translated">Многофайловые пространства имен</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes" xml:space="preserve">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target state="translated">К декларации можно применять несколько декораторов,как в следующих примерах:</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes" xml:space="preserve">
          <source>Multiple fields</source>
          <target state="translated">Несколько полей</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes" xml:space="preserve">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target state="translated">Несколько файлов с одним и тем же &lt;code&gt;export namespace Foo {&lt;/code&gt; на верхнем уровне (не думайте, что они собираются объединиться в один &lt;code&gt;Foo&lt;/code&gt; !)</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes" xml:space="preserve">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target state="translated">Многообъектные буквальные умозаключения для одного и того же типового параметра аналогичным образом объединяются в один нормализованный тип соединения:</target>
        </trans-unit>
        <trans-unit id="aede1800680b8eed7745689bb8cd192726458952" translate="yes" xml:space="preserve">
          <source>Mutually exclusive with &lt;a href=&quot;#sourceMap&quot;&gt;&lt;code&gt;sourceMap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes" xml:space="preserve">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes" xml:space="preserve">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes" xml:space="preserve">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes" xml:space="preserve">
          <source>MyTestPage.html (excerpt)</source>
          <target state="translated">MyTestPage.html (фрагмент)</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes" xml:space="preserve">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes" xml:space="preserve">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target state="translated">ПРИМЕЧАНИЕ. &lt;em&gt;Дескриптор свойства&lt;/em&gt; не предоставляется в качестве аргумента для декоратора свойств из-за того, как декораторы свойств инициализируются в TypeScript. Это связано с тем, что в настоящее время нет механизма для описания свойства экземпляра при определении членов прототипа, а также нет способа наблюдать или изменять инициализатор для свойства. Возвращаемое значение также игнорируется. Таким образом, декоратор свойств может использоваться только для наблюдения за тем, что свойство с определенным именем было объявлено для класса.</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes" xml:space="preserve">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target state="translated">ПРИМЕЧАНИЕ Декоратор параметров можно использовать только для того,чтобы заметить,что параметр был объявлен по методу.</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes" xml:space="preserve">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target state="translated">ПРИМЕЧАНИЕ Метаданные декоратора являются экспериментальной функцией и могут внести брейк-изменения в будущие релизы.</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes" xml:space="preserve">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target state="translated">ПРИМЕЧАНИЕ Декораторы-это экспериментальная функция,которая может измениться в будущих релизах.</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes" xml:space="preserve">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target state="translated">ПРИМЕЧАНИЕ. Если вы решите вернуть новую функцию конструктора, вы должны позаботиться о сохранении исходного прототипа. Логика, применяющая декораторы во время выполнения, &lt;strong&gt;не&lt;/strong&gt; сделает этого за вас.</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes" xml:space="preserve">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">ПРИМЕЧАНИЕ. &lt;em&gt;Дескриптор свойства&lt;/em&gt; будет &lt;code&gt;undefined&lt;/code&gt; если цель вашего сценария меньше &lt;code&gt;ES5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes" xml:space="preserve">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">ПРИМЕЧАНИЕ. Возвращаемое значение игнорируется, если цель вашего сценария меньше &lt;code&gt;ES5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes" xml:space="preserve">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href=&quot;#metadata&quot;&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target state="translated">ПРИМЕЧАНИЕ. В этом примере требуется библиотека &lt;code&gt;reflect-metadata&lt;/code&gt; . См. Раздел &lt;a href=&quot;#metadata&quot;&gt;Метаданные&lt;/a&gt; для получения дополнительной информации о библиотеке &lt;code&gt;reflect-metadata&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes" xml:space="preserve">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target state="translated">ПРИМЕЧАНИЕ TypeScript не позволяет декорировать методы доступа &lt;code&gt;get&lt;/code&gt; и &lt;code&gt;set&lt;/code&gt; для одного члена. Вместо этого все декораторы для члена должны применяться к первому аксессору, указанному в порядке документа. Это связано с тем, что декораторы применяются к &lt;em&gt;дескриптору свойства&lt;/em&gt; , который объединяет &lt;code&gt;get&lt;/code&gt; доступа get и &lt;code&gt;set&lt;/code&gt; , а не каждое объявление по отдельности.</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href=&quot;#method-decorators&quot;&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target state="translated">ПРИМЕЧАНИЕ. Более подробный пример фабрики декораторов можно увидеть в разделе &amp;laquo; &lt;a href=&quot;#method-decorators&quot;&gt;Декораторы методов&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target state="translated">ПРИМЕЧАНИЕ. Более подробный пример декоратора можно увидеть в разделе &amp;laquo;Декораторы &lt;a href=&quot;#class-decorators&quot;&gt;классов&amp;raquo;&lt;/a&gt; ниже.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes" xml:space="preserve">
          <source>Name and location of the import</source>
          <target state="translated">Название и место импорта</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes" xml:space="preserve">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target state="translated">Назовите файлы с расширением &lt;code&gt;.tsx&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes" xml:space="preserve">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">Назовите свой проект и решение. После нажмите кнопку &lt;em&gt;Создать&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b69558e9b061498c09673bf8df0b367bf33694fd" translate="yes" xml:space="preserve">
          <source>Named types just give a name to a type; for assignability purposes there&amp;rsquo;s no difference between the type alias &lt;code&gt;One&lt;/code&gt; and the interface type &lt;code&gt;Two&lt;/code&gt; below. They both have a property &lt;code&gt;p: string&lt;/code&gt;. (Type aliases behave differently from interfaces with respect to recursive definitions and type parameters, however.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes" xml:space="preserve">
          <source>Namespaced Validators</source>
          <target state="translated">Имена и фамилии валидаторов</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6f67c77b8db69b7cbbe81780dca2a3cd93d34c20" translate="yes" xml:space="preserve">
          <source>Namespaces &amp;amp; Modules</source>
          <target state="translated">Пространства имен и модули</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes" xml:space="preserve">
          <source>Namespaces and Modules</source>
          <target state="translated">Пространства имен и модули</target>
        </trans-unit>
        <trans-unit id="0b0a6e9c59b25d6d7bd54387d9652cfedae85b49" translate="yes" xml:space="preserve">
          <source>Namespaces are a TypeScript-specific way to organize code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes" xml:space="preserve">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target state="translated">Пространства имен достаточно гибкие,чтобы объединиться с другими типами деклараций.Для этого декларация пространства имен должна следовать за декларацией,с которой оно будет сливаться.Полученная декларация имеет свойства обоих типов деклараций.TypeScript использует эту возможность для моделирования некоторых шаблонов в JavaScript,а также в других языках программирования.</target>
        </trans-unit>
        <trans-unit id="3952a1181de40dbd2a06ce80db7e580384e74ec9" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;mdash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">Пространства имен важны, чтобы избежать конфликтов имен в глобальной области. Например, у вас могут быть &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; и &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; - два типа с одним и тем же именем, но в другом пространстве имен. Однако это не проблема с модулями. В модуле нет веских причин иметь два объекта с одинаковым именем. Со стороны потребления потребитель любого данного модуля получает возможность выбрать имя, которое он будет использовать для ссылки на модуль, поэтому случайные конфликты имен невозможны.</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">Пространства имен просто называются объектами JavaScript в глобальном пространстве имен. Это делает пространства имен очень простой конструкцией. Они могут охватывать несколько файлов и могут быть объединены с помощью &lt;code&gt;--outFile&lt;/code&gt; . Пространства имен могут быть хорошим способом структурировать код в веб-приложении, при этом все зависимости включаются в виде тегов &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; на вашу HTML-страницу.</target>
        </trans-unit>
        <trans-unit id="558fb2926bc952cf7a6b78aa83d90ef0f04f4eb8" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abfc41609e10694546f23e6fe8ec31d3b441731d" translate="yes" xml:space="preserve">
          <source>Namespaces in Module Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="8ecb67c30433187282f082e25e52e62490e245cc" translate="yes" xml:space="preserve">
          <source>Narrowing</source>
          <target state="translated">Narrowing</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes" xml:space="preserve">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target state="translated">Встроенные модули ECMAScript 2015 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes" xml:space="preserve">
          <source>Needless Namespacing</source>
          <target state="translated">Бессмысленный шаг имён</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes" xml:space="preserve">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target state="translated">Ни расширения модуля, ни глобальные расширения не могут добавлять новые элементы в область верхнего уровня - они могут только &amp;laquo;исправлять&amp;raquo; существующие объявления.</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes" xml:space="preserve">
          <source>Nested and merged declarations</source>
          <target state="translated">Вложенные и объединенные декларации</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes" xml:space="preserve">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target state="translated">Теперь вложение работает на любом уровне и корректно объединяет файлы.Раньше не было ни того,ни другого.</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target state="translated">Новый - &lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target state="translated">Новый &lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target state="translated">Новое &lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target state="translated">Новое &lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">Новый &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">Новый &lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target state="translated">Новый &lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target state="translated">Новая опция &lt;code&gt;--strict&lt;/code&gt; master</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">Новое &lt;code&gt;.tsx&lt;/code&gt; файла .tsx и оператор &lt;code&gt;as&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target state="translated">Новый &lt;code&gt;jsx: react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target state="translated">Новый &lt;code&gt;unknown&lt;/code&gt; тип топа</target>
        </trans-unit>
        <trans-unit id="3249cca6099abd4cca11ff2add4d8cce20a25fa1" translate="yes" xml:space="preserve">
          <source>New Line - &lt;code&gt;newLine&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes" xml:space="preserve">
          <source>New TypeScript Playground</source>
          <target state="translated">Новая игровая площадка TypeScript</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes" xml:space="preserve">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target state="translated">Новые проверки, добавленные в TypeScript, часто по умолчанию отключены, чтобы избежать поломки существующих проектов. Избегать поломок - это хорошо, но недостатком этой стратегии является усложнение выбора наивысшего уровня безопасности типов, и для этого требуется явное действие согласия в каждой версии TypeScript. С параметром &lt;code&gt;--strict&lt;/code&gt; становится возможным выбрать максимальную безопасность типов, понимая, что новые версии компилятора могут сообщать о дополнительных ошибках по мере добавления улучшенных функций проверки типов.</target>
        </trans-unit>
        <trans-unit id="3f170caead65df254d786032a409a6f6d204bca6" translate="yes" xml:space="preserve">
          <source>Next Steps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes" xml:space="preserve">
          <source>Next we have an example of how to override the constructor.</source>
          <target state="translated">Далее у нас есть пример,как переопределить конструктор.</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes" xml:space="preserve">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target state="translated">Затем мы добавим новую папку и назовем ее &lt;code&gt;scripts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes" xml:space="preserve">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">Затем для каждой переменной типа, представленной &lt;code&gt;infer&lt;/code&gt; (более поздним) объявлением в &lt;code&gt;U&lt;/code&gt; , соберите набор типов-кандидатов путем вывода от &lt;code&gt;T&lt;/code&gt; к &lt;code&gt;U&lt;/code&gt; (используя тот же алгоритм вывода, что и вывод типов для универсальных функций). Для данной переменной &lt;code&gt;infer&lt;/code&gt; типа &lt;code&gt;V&lt;/code&gt; , если какие-либо кандидаты были выведены из ковариантных позиций, тип, выведенный для &lt;code&gt;V&lt;/code&gt; , является объединением этих кандидатов. В противном случае, если какие-либо кандидаты были выведены из противоположных позиций, тип, выведенный для &lt;code&gt;V&lt;/code&gt; , является пересечением этих кандидатов. В противном случае тип, выведенный для &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes" xml:space="preserve">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">Затем, если в вашей версии Visual Studio еще нет последней версии TypeScript, вы можете &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;установить ее&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target state="translated">Затем давайте создадим &lt;code&gt;index.tsx&lt;/code&gt; в &lt;code&gt;src&lt;/code&gt; со следующим источником:</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target state="translated">Затем мы напрямую используем класс. Здесь мы создаем новую переменную под названием &lt;code&gt;greeterMaker&lt;/code&gt; . Эта переменная будет содержать сам класс или, иначе говоря, его функцию-конструктор. Здесь мы используем &lt;code&gt;typeof Greeter&lt;/code&gt; , то есть &amp;laquo;дайте мне тип самого класса &lt;code&gt;Greeter&lt;/code&gt; &amp;raquo;, а не тип экземпляра. Или, точнее, &amp;laquo;дайте мне тип символа с именем &lt;code&gt;Greeter&lt;/code&gt; &amp;raquo;, который является типом функции-конструктора. Этот тип будет содержать все статические члены Greeter вместе с конструктором, который создает экземпляры класса &lt;code&gt;Greeter&lt;/code&gt; . Мы показываем это, используя &lt;code&gt;new&lt;/code&gt; в &lt;code&gt;greeterMaker&lt;/code&gt; , создавая новые экземпляры &lt;code&gt;Greeter&lt;/code&gt; . и вызывая их, как прежде.</target>
        </trans-unit>
        <trans-unit id="d23baf839f3be80e72847391d0e91cd097e57246" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before. It is also good to mention that changing static property is frowned upon, here &lt;code&gt;greeter3&lt;/code&gt; has &lt;code&gt;&quot;Hey there!&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;Hello, there&quot;&lt;/code&gt; on &lt;code&gt;standardGreeting&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; and &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;.</source>
          <target state="translated">Затем мы добавим зависимости времени разработки для &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; и &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target state="translated">Затем мы создадим класс, который будет обрабатывать комбинацию двух миксинов. Давайте посмотрим на это более подробно, чтобы увидеть, как это происходит:</target>
        </trans-unit>
        <trans-unit id="65015e14839407ce052eab7ebecff46c96ec532e" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ve also added the &lt;code&gt;@readonly&lt;/code&gt; modifier to ensure that a property is only ever written to during initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes" xml:space="preserve">
          <source>Nightly Builds</source>
          <target state="translated">Ночные Строения</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">Ночной Билдс:Использование NuGet с MSBuild</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">Ночной Билдс:Использование npm</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes" xml:space="preserve">
          <source>Nightly builds</source>
          <target state="translated">Ночные телосложения</target>
        </trans-unit>
        <trans-unit id="137f56df766041937e987c0af9dc02adfcc4755b" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;main&amp;rdquo; field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2bbc3e501b46e56dd329eeeb31b55fa0b1f266" translate="yes" xml:space="preserve">
          <source>No &amp;ldquo;types&amp;rdquo; field</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947828c2d274f8a21e38e5dd1c59c5dea679fff4" translate="yes" xml:space="preserve">
          <source>No Emit - &lt;code&gt;noEmit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517bdc2dcead288c404ef1a218dadda3060ef0b5" translate="yes" xml:space="preserve">
          <source>No Emit Helpers - &lt;code&gt;noEmitHelpers&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f8de53c793590eccee3c9ce2ed4caeb14a5452" translate="yes" xml:space="preserve">
          <source>No Emit On Error - &lt;code&gt;noEmitOnError&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b1eb323a13015b5221c0cd99fda83cbd652752c" translate="yes" xml:space="preserve">
          <source>No Error Truncation - &lt;code&gt;noErrorTruncation&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8026bb65899345422d9472e2fb88c6be373e8549" translate="yes" xml:space="preserve">
          <source>No Fallthrough Cases In Switch - &lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">Нет Неявно &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">Нет неявной &lt;code&gt;any&lt;/code&gt; для &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa3c1c5d879a76450e09d3b73229dae5a7fb02f8" translate="yes" xml:space="preserve">
          <source>No Implicit Any - &lt;code&gt;noImplicitAny&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c71f4c5d6c858e8b215dbb144dbf6d05414836" translate="yes" xml:space="preserve">
          <source>No Implicit Returns - &lt;code&gt;noImplicitReturns&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5134182dd86f7b3181089a2100da25c6c0bc7cf4" translate="yes" xml:space="preserve">
          <source>No Implicit This - &lt;code&gt;noImplicitThis&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763fcaff914bd4c20f0951a9a84eab99aa002c2b" translate="yes" xml:space="preserve">
          <source>No Implicit Use Strict - &lt;code&gt;noImplicitUseStrict&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b77ce03e2df58d71af1d4f405d9bf1ac7e9005" translate="yes" xml:space="preserve">
          <source>No Lib - &lt;code&gt;noLib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592cae7a1118d335c8f2c20593f693616662691c" translate="yes" xml:space="preserve">
          <source>No Resolve - &lt;code&gt;noResolve&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675ae146fc17269a9c7ab5f87fa461ad1c19cf8e" translate="yes" xml:space="preserve">
          <source>No Strict Generic Checks - &lt;code&gt;noStrictGenericChecks&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e5a62628a8609c8c2ea29d4e598862499087d1" translate="yes" xml:space="preserve">
          <source>No Unused Locals - &lt;code&gt;noUnusedLocals&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c92a5c1d34b1db353f920c96e229f154407160" translate="yes" xml:space="preserve">
          <source>No Unused Parameters - &lt;code&gt;noUnusedParameters&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes" xml:space="preserve">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target state="translated">Отсутствует типа не является подтипом или присваиваемым &lt;code&gt;never&lt;/code&gt; ( за исключением &lt;code&gt;never&lt;/code&gt; сам по себе).</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="5c47793ac8ba8a46e72ec2594c5dca3b16c44344" translate="yes" xml:space="preserve">
          <source>Node 10</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c07c40cb823fe2596e38b4e3bb579fa72706bed" translate="yes" xml:space="preserve">
          <source>Node 12</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b43fdbd3b2c6a5806d127c28acb9f482a0bab1f3" translate="yes" xml:space="preserve">
          <source>Node 14</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f07679d61eb1484f3fbb7f03c094ced47df3b09" translate="yes" xml:space="preserve">
          <source>Nominal Reified Type Systems</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05004c27291ee5258d4639719f948e95da6af52b" translate="yes" xml:space="preserve">
          <source>Non-Goals</source>
          <target state="translated">Non-Goals</target>
        </trans-unit>
        <trans-unit id="116d53de6ee6ef67d2d4805314ad0787f638003a" translate="yes" xml:space="preserve">
          <source>Non-Module Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes" xml:space="preserve">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target state="translated">Нефункциональные члены интерфейсов должны быть уникальными.Если они не уникальны,то должны быть одного типа.Компилятор выдаст ошибку,если оба интерфейса объявят нефункционирующим членом одного и того же имени,но разных типов.</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes" xml:space="preserve">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target state="translated">Негенерические выражения спреда продолжают обрабатываться,как и раньше:Сигнатуры вызовов и конструкций удаляются,сохраняются только неметодные свойства,а для свойств с тем же именем используется тип самого правого свойства.Это контрастирует с типами пересечений,которые соединяют сигнатуры вызова и построения,сохраняют все свойства и пересекают типы свойств с одним и тем же именем.Таким образом,развороты одних и тех же типов могут давать разные результаты при их создании путем инстанцирования родовых типов:</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes" xml:space="preserve">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target state="translated">Негомоморфные типы по сути создают новые свойства, поэтому они не могут копировать модификаторы свойств из любого места.</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards</source>
          <target state="translated">Нулевые и неустановленные защитные устройства</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target state="translated">Ненулевыми и не неопределенные охранники типа могут использовать не &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;===&lt;/code&gt; или &lt;code&gt;!==&lt;/code&gt; оператора для сравнения с &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; , как и в &lt;code&gt;x != null&lt;/code&gt; или &lt;code&gt;x === undefined&lt;/code&gt; . Влияние на типы предметных переменных точно отражает семантику JavaScript (например, операторы двойного равенства проверяют оба значения, независимо от того, какое из них указано, тогда как тройное равенство проверяет только указанное значение).</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes" xml:space="preserve">
          <source>Non-null assertion operator</source>
          <target state="translated">Оператор с нулевым позиционированием</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes" xml:space="preserve">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target state="translated">Неоткрываемые типы не имеют никакого значения и рассматриваются так же,как и их оригинальный тип:</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes" xml:space="preserve">
          <source>Non-unit types as union discriminants</source>
          <target state="translated">Необъединенные типы как профсоюзные дискриминаторы</target>
        </trans-unit>
        <trans-unit id="80660f063a6440a3a7e05a18a3ba076eeaf007e6" translate="yes" xml:space="preserve">
          <source>NonNullable&amp;lt;T&amp;gt;</source>
          <target state="translated">NonNullable&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes" xml:space="preserve">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target state="translated">Обычно компилятор пытается разрешить импорт всех модулей до того, как он начнет процесс компиляции. Каждый раз, когда он успешно разрешает &lt;code&gt;import&lt;/code&gt; в файл, этот файл добавляется к набору файлов, которые компилятор будет обрабатывать позже.</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target state="translated">Обычно &lt;code&gt;tsc&lt;/code&gt; выдает выходные данные ( &lt;code&gt;.js&lt;/code&gt; и &lt;code&gt;.d.ts&lt;/code&gt; ) при наличии синтаксических или типовых ошибок, если не &lt;code&gt;noEmitOnError&lt;/code&gt; . Делать это в системе инкрементальной сборки было бы очень плохо - если бы одна из ваших устаревших зависимостей имела новую ошибку, вы бы увидели ее &lt;em&gt;только один раз,&lt;/em&gt; потому что последующая сборка пропустила бы сборку теперь актуального проекта. По этой причине &lt;code&gt;tsc -b&lt;/code&gt; эффективно действует так, как если бы &lt;code&gt;noEmitOnError&lt;/code&gt; разрешено для всех проектов.</target>
        </trans-unit>
        <trans-unit id="9fd029d8465bd91c3c7282b62d1066fe73ce0eee" translate="yes" xml:space="preserve">
          <source>Normally, TypeScript would return silently on success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes" xml:space="preserve">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href=&quot;mixins&quot;&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target state="translated">Не все слияния разрешены в TypeScript. В настоящее время классы не могут сливаться с другими классами или с переменными. Для получения информации о имитации слияния классов см. Раздел &lt;a href=&quot;mixins&quot;&gt;Mixins в TypeScript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes" xml:space="preserve">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target state="translated">Не все свойства интерфейса могут быть обязательными. Некоторые существуют при определенных условиях или могут не существовать вовсе. Эти необязательные свойства популярны при создании шаблонов, таких как &amp;laquo;пакеты опций&amp;raquo;, когда вы передаете объект функции, которая имеет только несколько заполненных свойств.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes" xml:space="preserve">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target state="translated">Обратите внимание, что любые теги, которые явно не перечислены ниже (например, &lt;code&gt;@async&lt;/code&gt; ), еще не поддерживаются.</target>
        </trans-unit>
        <trans-unit id="8717f9c00739ed6489469366e14a0bc6d63a8887" translate="yes" xml:space="preserve">
          <source>Note if using TypeScript 4.2, prefer &lt;a href=&quot;#explainFiles&quot;&gt;&lt;code&gt;explainFiles&lt;/code&gt;&lt;/a&gt; which offers an explanation of why a file was added too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5feea3e404674922df60252466104fa5c5fc9e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike TypeScript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;@enum&lt;/code&gt; сильно отличается от &lt;code&gt;enum&lt;/code&gt; Typescript и намного проще . Однако, в отличие от перечислений &lt;code&gt;@enum&lt;/code&gt; , @enum может иметь любой тип:</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;@extends&lt;/code&gt; работает только с классами. В настоящее время функция-конструктор не может расширить класс.</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; настолько полезны, что они включены в стандартную библиотеку TypeScript вместе с &lt;code&gt;Pick&lt;/code&gt; и &lt;code&gt;Record&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a8635b5b3c1a94603cc953231075f37144a428de" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;keyof any&lt;/code&gt; represents the type of any value that can be used as an index to an object. In otherwords, &lt;code&gt;keyof any&lt;/code&gt; is currently equal to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;y&lt;/code&gt; имеет дополнительное свойство &lt;code&gt;location&lt;/code&gt; , но это не создает ошибки. При проверке совместимости учитываются только члены целевого типа ( в данном случае &lt;code&gt;Named&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="851055dd6dee2383c5b008f867f0f4cd2bb01af3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;owner&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Pet&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes" xml:space="preserve">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что TypeScript обрабатывает &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; по- разному, чтобы соответствовать семантике JavaScript. &lt;code&gt;string | null&lt;/code&gt; - это другой тип, чем &lt;code&gt;string | undefined&lt;/code&gt; и &lt;code&gt;string | undefined | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d964565fed797b8fe69da21280237178f8dd90d" translate="yes" xml:space="preserve">
          <source>Note that TypeScript will never write an output file to a directory outside of &lt;code&gt;outDir&lt;/code&gt;, and will never skip emitting a file. For this reason, &lt;code&gt;rootDir&lt;/code&gt; also enforces that all files which need to be emitted are underneath the &lt;code&gt;rootDir&lt;/code&gt; path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes" xml:space="preserve">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target state="translated">Обратите внимание, что, как и в случае с &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt; , существующие свойства проекта TypeScript не будут соблюдаться - всеми настройками следует управлять с помощью вашего файла tsconfig.</target>
        </trans-unit>
        <trans-unit id="49f454e4294f1faa6bdcf0d5b1903082b8d7d4af" translate="yes" xml:space="preserve">
          <source>Note that calling a method on a numeric literal requires it to be in parentheses to aid the parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af06da8b751f486668f66523aec780426d9aaf88" translate="yes" xml:space="preserve">
          <source>Note that functions and arrays are objects at runtime, but have their own predicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes" xml:space="preserve">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что глобальные переменные, объявленные с помощью &lt;code&gt;let&lt;/code&gt; и &lt;code&gt;const&lt;/code&gt; , не отображаются в &lt;code&gt;globalThis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target state="translated">Обратите внимание, что если &lt;code&gt;bar&lt;/code&gt; имеет значение &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; , наш код все равно выдает ошибку при доступе к &lt;code&gt;baz&lt;/code&gt; . Точно так же, если &lt;code&gt;baz&lt;/code&gt; имеет значение &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; , мы обнаружим ошибку на сайте вызова. &lt;code&gt;?.&lt;/code&gt; проверяет только, является ли значение &lt;em&gt;слева&lt;/em&gt; от него &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; не какое-либо из последующих свойств.</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target state="translated">Обратите внимание, что в режиме &lt;code&gt;--strictNullChecks&lt;/code&gt; , когда гомоморфный отображаемый тип удаляет &lt;code&gt;?&lt;/code&gt; модификатор из свойства в базовом типе он также удаляет &lt;code&gt;undefined&lt;/code&gt; из типа этого свойства:</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes" xml:space="preserve">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target state="translated">Обратите внимание,что в TypeScript 1.4,при доступе к элементу вне набора известных индексов,вместо него используется союзный тип:</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes" xml:space="preserve">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target state="translated">Обратите внимание, что в этом примере мы добавили значение к &lt;em&gt;статической&lt;/em&gt; стороне &lt;code&gt;C&lt;/code&gt; (его функция-конструктор). Это потому, что мы добавили &lt;em&gt;значение&lt;/em&gt; , а контейнером для всех значений является другое значение (типы содержатся в пространствах имен, а пространства имен содержатся в других пространствах имен).</target>
        </trans-unit>
        <trans-unit id="4521e5d9ffa1f2a7a2398a1ba71b06034b84ba66" translate="yes" xml:space="preserve">
          <source>Note that inference will work in any order, but intellisense will only work left-to-right, so TypeScript prefers to declare &lt;code&gt;map&lt;/code&gt; with the array first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target state="translated">Обратите внимание, что при записи файла глобального объявления можно определить множество типов в глобальной области видимости. Мы настоятельно не рекомендуем этого, поскольку это приводит к возможным неразрешимым конфликтам имен, когда в проекте много файлов объявлений.</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes" xml:space="preserve">
          <source>Note that parentheses are optional for union types.</source>
          <target state="translated">Обратите внимание,что скобки являются необязательными для типов соединений.</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes" xml:space="preserve">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target state="translated">Обратите внимание,что частичное совмещение допустимо до тех пор,пока действуют типы собственности.</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes" xml:space="preserve">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target state="translated">Обратите внимание,что на относительный импорт модулей не влияет настройка baseUrl,так как они всегда разрешаются относительно импортируемых файлов.</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;typings&quot;&lt;/code&gt; field is synonymous with &lt;code&gt;&quot;types&quot;&lt;/code&gt;, and could be used as well.</source>
          <target state="translated">Обратите внимание, что поле &lt;code&gt;&quot;typings&quot;&lt;/code&gt; является синонимом &lt;code&gt;&quot;types&quot;&lt;/code&gt; и также может использоваться.</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece не является частью списка перегрузки, поэтому у нее есть только две перегрузки: одна принимает объект, а другая - число. Вызов &lt;code&gt;pickCard&lt;/code&gt; с любыми другими типами параметров вызовет ошибку.</target>
        </trans-unit>
        <trans-unit id="8e52a12186dadc57595c17ea6c93216559c79848" translate="yes" xml:space="preserve">
          <source>Note that the return type of &lt;code&gt;area&lt;/code&gt; is inferred to be &lt;code&gt;number&lt;/code&gt; because TypeScript knows the function is total. If some variant is not covered, the return type of &lt;code&gt;area&lt;/code&gt; will be &lt;code&gt;number | undefined&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes" xml:space="preserve">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target state="translated">Обратите внимание,что это падение должно происходить только в том случае,если все перегрузки имеют один и тот же тип возврата.</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes" xml:space="preserve">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target state="translated">Обратите внимание,что это не означает,что кортежи представляют собой непреложные массивы,но это подразумеваемая конвенция.</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes" xml:space="preserve">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что это критическое изменение для некоторого кода. Если вам нужно прибегнуть к исходному поведению, при котором кортежи обеспечивают только минимальную длину, вы можете использовать аналогичное объявление, которое явно не определяет свойство &lt;code&gt;length&lt;/code&gt; , возвращаясь к &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes" xml:space="preserve">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target state="translated">Обратите внимание,что этот синтаксис описывает тип,а не член.Если вы хотите добавить членов,вы можете использовать тип пересечения:</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes" xml:space="preserve">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target state="translated">Обратите внимание, что этот вывод с разверткой работает только с гомоморфными отображенными типами. Если отображаемый тип не является гомоморфным, вам придется указать явный параметр типа вашей функции развертывания.</target>
        </trans-unit>
        <trans-unit id="ca498eaf7012359010349b6f8e9e80f634eacb51" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;export default&lt;/code&gt; in your .d.ts files requires &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#esModuleInterop&quot;&gt;&lt;code&gt;esModuleInterop: true&lt;/code&gt;&lt;/a&gt; to work. If you can&amp;rsquo;t have &lt;code&gt;esModuleInterop: true&lt;/code&gt; in your project, such as when you&amp;rsquo;re submitting a PR to Definitely Typed, you&amp;rsquo;ll have to use the &lt;code&gt;export=&lt;/code&gt; syntax instead. This older syntax is harder to use but works everywhere. Here&amp;rsquo;s how the above example would have to be written using &lt;code&gt;export=&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes" xml:space="preserve">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target state="translated">Обратите внимание, что мы не можем добавлять псевдонимы типа ( &lt;code&gt;type s = string;&lt;/code&gt; ) с помощью интерфейса.</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes" xml:space="preserve">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target state="translated">Обратите внимание,что в настоящее время мы поддерживаем только дискриминантные свойства типов строковых литералов.В дальнейшем мы планируем добавить поддержку булевых и числовых типов литералов.</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target state="translated">Обратите внимание, что мы не сделали здесь &lt;code&gt;b&lt;/code&gt; необязательным, потому что типы возврата подписей различаются.</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes" xml:space="preserve">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target state="translated">Обратите внимание, что когда тип кортежа выводится из последовательности параметров, а затем расширяется в список параметров, как в случае с &lt;code&gt;U&lt;/code&gt; , исходные имена параметров используются в раскрытии (однако имена не имеют семантического значения и иначе наблюдаемый).</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes" xml:space="preserve">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target state="translated">Обратите внимание, что при совместном использовании этих флагов TypeScript не обязательно понижать уровень файлов &lt;code&gt;.js&lt;/code&gt; . Если вы просто хотите, чтобы TypeScript создавал файлы &lt;code&gt;.d.ts&lt;/code&gt; , вы можете использовать &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; компилятора --emitDeclarationOnly .</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes" xml:space="preserve">
          <source>Note that while this example uses &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target state="translated">Обратите внимание, что хотя в этом примере используются &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;функциональные компоненты&lt;/a&gt; , мы также могли бы сделать наш пример немного более &lt;em&gt;классным&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="34251a04d5ba8fb11fec4ca7f77a83e669f75693" translate="yes" xml:space="preserve">
          <source>Note, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported</source>
          <target state="translated">Примечание. Последние поддерживаемые цели &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">Примечание. &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; нацелен на последние поддерживаемые &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;функции, предлагаемые ES&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7cb6b652ecb3fc440c1897098d4132f67f5630" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;node&lt;/code&gt; module resolution is the most-commonly used in the TypeScript community and is recommended for most projects. If you are having resolution problems with &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;export&lt;/code&gt;s in TypeScript, try setting &lt;code&gt;moduleResolution: &quot;node&quot;&lt;/code&gt; to see if it fixes the issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b385aa9974c78d1114e7d19ac34ae3cecb189cbb" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;outFile&lt;/code&gt; cannot be used unless &lt;code&gt;module&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt;, or &lt;code&gt;AMD&lt;/code&gt;. This option &lt;em&gt;cannot&lt;/em&gt; be used to bundle CommonJS or ES6 modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes" xml:space="preserve">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target state="translated">Примечание. Избегайте использования &lt;code&gt;Object&lt;/code&gt; в пользу непримитивного типа &lt;code&gt;object&lt;/code&gt; как описано в разделе, &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;что можно и что нельзя делать&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93a51f16eac9cd871496fa3f38f5e48ecd5fea51" translate="yes" xml:space="preserve">
          <source>Note: Error messages only show up in JS codebases with &lt;a href=&quot;tsconfig-json&quot;&gt;a JSConfig&lt;/a&gt; and &lt;a href=&quot;https://www.typescriptlang.org/tsconfig#checkJs&quot;&gt;&lt;code&gt;checkJs&lt;/code&gt;&lt;/a&gt; enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes" xml:space="preserve">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target state="translated">Примечание. Функциональные компоненты ранее назывались функциональными компонентами без сохранения состояния (SFC). Поскольку функциональные компоненты больше не могут считаться не имеющими состояния в последних версиях react, тип &lt;code&gt;SFC&lt;/code&gt; и его псевдоним &lt;code&gt;StatelessComponent&lt;/code&gt; объявлены устаревшими.</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target state="translated">Примечание. Если &lt;code&gt;--lib&lt;/code&gt; не указан, вводится список библиотек по умолчанию. Внедренные библиотеки по умолчанию:</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes" xml:space="preserve">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target state="translated">Примечание. Если имя атрибута не является допустимым идентификатором JS (например, атрибут &lt;code&gt;data-*&lt;/code&gt; ), это не считается ошибкой, если оно не найдено в типе атрибутов элемента.</target>
        </trans-unit>
        <trans-unit id="019f04b9d1d907c729221ba8c0d3f15ea3b9e489" translate="yes" xml:space="preserve">
          <source>Note: In &lt;em&gt;very&lt;/em&gt; old versions of TypeScript namespaces were called &amp;lsquo;Internal Modules&amp;rsquo;, these pre-date JavaScript module systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes" xml:space="preserve">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target state="translated">Замечание:Большинство изменений не требуют установки новой версии плагина VS TypeScript.</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes" xml:space="preserve">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target state="translated">Замечание:Предыдущий синтаксис,определяющий внутренние модули,все еще поддерживается.</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target state="translated">Примечание. Тип &lt;code&gt;Exclude&lt;/code&gt; - это правильная реализация предлагаемого &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;здесь&lt;/a&gt; типа &lt;code&gt;Diff&lt;/code&gt; . Мы использовали имя &lt;code&gt;Exclude&lt;/code&gt; , чтобы избежать нарушения существующего кода, который определяет &lt;code&gt;Diff&lt;/code&gt; , плюс мы считаем, что это имя лучше передает семантику типа.</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Примечание. Тип &lt;code&gt;Exclude&lt;/code&gt; - это правильная реализация предлагаемого &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;здесь&lt;/a&gt; типа &lt;code&gt;Diff&lt;/code&gt; . Мы использовали имя &lt;code&gt;Exclude&lt;/code&gt; , чтобы избежать нарушения существующего кода, который определяет &lt;code&gt;Diff&lt;/code&gt; , плюс мы считаем, что это имя лучше передает семантику типа. Мы не включили тип &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; потому что он тривиально записывается как &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes" xml:space="preserve">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt;).</source>
          <target state="translated">Примечание. Новое поведение добавляется под флагом, чтобы избежать неоправданных разрывов в существующей кодовой базе. &lt;strong&gt;Мы настоятельно рекомендуем применять его как в новых, так и в существующих проектах. &lt;/strong&gt;Для существующих проектов импорт пространства имен ( &lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt; ) необходимо будет преобразовать в импорт по умолчанию ( &lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes" xml:space="preserve">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target state="translated">Примечание. Это изменение &lt;code&gt;__makeTemplateObject&lt;/code&gt; новый помощник по созданию emit , __makeTemplateObject ; если вы используете &lt;code&gt;--importHelpers&lt;/code&gt; с &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt; , обновленный до версии 1.8 или новее.</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes" xml:space="preserve">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;#32964&lt;/a&gt;.</source>
          <target state="translated">Примечание. Этот тип работает правильно, только если включен параметр &lt;code&gt;--strictFunctionTypes&lt;/code&gt; . См. &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;№ 32964&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes" xml:space="preserve">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target state="translated">Примечание. Вы также можете указать &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; индексатор строк для JSX.IntrinsicElements следующим образом:</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes" xml:space="preserve">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target state="translated">Примечание. Вам необходимо настроить свой проект для использования пакетов NuGet. Дополнительные сведения см. В разделе &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Настройка проектов MSBuild для использования NuGet&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes" xml:space="preserve">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</source>
          <target state="translated">Примечание: во-первых, нам нужно убедиться, что наша среда выполнения имеет ECMAScript-совместимое &lt;code&gt;Promise&lt;/code&gt; доступное глобально. Это может включать захват &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;полифилла&lt;/a&gt; для &lt;code&gt;Promise&lt;/code&gt; или использование того, что может быть у вас во время выполнения, на которое вы нацеливаетесь. Нам также необходимо убедиться, что TypeScript знает о существовании &lt;code&gt;Promise&lt;/code&gt; , установив для вашего флага &lt;code&gt;lib&lt;/code&gt; что-то вроде &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; или &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes" xml:space="preserve">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target state="translated">Примечание: если файл декларации, который вы ищете, отсутствует, вы всегда можете вернуть его и помочь следующему разработчику, который его ищет. Подробную информацию см. На &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;странице с рекомендациями&lt;/a&gt; по внесению взносов DefinentyTyped .</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes" xml:space="preserve">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target state="translated">Обратите внимание, как мы полностью отказались от &lt;code&gt;theName&lt;/code&gt; и просто использовали сокращенный параметр &lt;code&gt;readonly name: string&lt;/code&gt; только для чтения в конструкторе для создания и инициализации члена &lt;code&gt;name&lt;/code&gt; . Мы объединили декларации и уступку в одном месте.</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;T&lt;/code&gt; был &lt;code&gt;makeArray&lt;/code&gt; из makeArray в список параметров типа результирующего типа. Это означает, что универсальность аргументов &lt;code&gt;compose&lt;/code&gt; была сохранена, и наш пример &lt;code&gt;makeBoxedArray&lt;/code&gt; будет работать!</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;T&lt;/code&gt; имеет дополнительное ограничение &lt;code&gt;any[]&lt;/code&gt; внутри истинной ветви &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; и поэтому можно ссылаться на тип элемента массива как &lt;code&gt;T[number]&lt;/code&gt; . Также обратите внимание, как условный тип распределяется по типу объединения в последнем примере.</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;createCardPicker&lt;/code&gt; - это функция, которая сама возвращает функцию. Если бы мы попытались запустить пример, мы получили бы ошибку вместо ожидаемого окна предупреждения. Это связано с тем, что &lt;code&gt;this&lt;/code&gt; , который используется в функции, созданной &lt;code&gt;createCardPicker&lt;/code&gt; , будет установлен в &lt;code&gt;window&lt;/code&gt; вместо нашего объекта &lt;code&gt;deck&lt;/code&gt; . Это потому, что мы вызываем &lt;code&gt;cardPicker()&lt;/code&gt; самостоятельно. Вызов синтаксиса верхнего уровня без метода, подобного этому, будет использовать для &lt;code&gt;this&lt;/code&gt; &lt;code&gt;window&lt;/code&gt; . (Примечание: в строгом режиме &lt;code&gt;this&lt;/code&gt; будет &lt;code&gt;undefined&lt;/code&gt; , а не &lt;code&gt;window&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target state="translated">Обратите внимание, что у &lt;code&gt;uglify&lt;/code&gt; есть только один вызов - существуют вызовы &lt;code&gt;buffer&lt;/code&gt; и &lt;code&gt;sourcemaps&lt;/code&gt; чтобы убедиться, что исходные карты продолжают работать. Эти вызовы дают нам отдельный файл исходной карты вместо использования встроенных исходных карт, как раньше. Теперь вы можете запустить Gulp и убедиться, что &lt;code&gt;bundle.js&lt;/code&gt; bundle.js минифицирован в нечитаемый беспорядок:</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes" xml:space="preserve">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target state="translated">Обратите внимание,что Node.js перепрыгнул вверх по каталогу в шагах (4)и (7).</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes" xml:space="preserve">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что TypeScript не только знает, что &lt;code&gt;pet&lt;/code&gt; - это &lt;code&gt;Fish&lt;/code&gt; в ветви &lt;code&gt;if&lt;/code&gt; ; он также знает , что в &lt;code&gt;else&lt;/code&gt; отделении, вы &lt;em&gt;не&lt;/em&gt; имеете &lt;code&gt;Fish&lt;/code&gt; , так что вы должны быть &lt;code&gt;Bird&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes" xml:space="preserve">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target state="translated">Обратите внимание, что, несмотря на наличие ошибок, файл &lt;code&gt;greeter.js&lt;/code&gt; все еще создается. Вы можете использовать TypeScript, даже если в вашем коде есть ошибки. Но в этом случае TypeScript предупреждает, что ваш код, скорее всего, не будет работать должным образом.</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes" xml:space="preserve">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target state="translated">Обратите внимание, что хотя мы использовали синтаксис модуля ES2015, TypeScript выдавал модули CommonJS, которые использует Node. В этом руководстве мы будем придерживаться CommonJS, но вы можете установить &lt;code&gt;module&lt;/code&gt; в объекте параметров, чтобы изменить это.</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes" xml:space="preserve">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target state="translated">Обратите внимание, что наш пример немного изменился. Вместо описания универсальной функции теперь у нас есть сигнатура неуниверсальной функции, которая является частью универсального типа. Когда мы используем &lt;code&gt;GenericIdentityFn&lt;/code&gt; , теперь нам также нужно будет указать соответствующий аргумент типа (здесь: &lt;code&gt;number&lt;/code&gt; ), эффективно блокируя то, что будет использовать базовая сигнатура вызова. Понимание того, когда помещать параметр типа непосредственно в сигнатуру вызова, а когда помещать его в сам интерфейс, будет полезно при описании общих аспектов типа.</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes" xml:space="preserve">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target state="translated">Обратите внимание,что элементы каждой группы поддерживают один и тот же порядок,но сами группы объединяются с более поздними перегрузочными комплектами,упорядоченными первыми.</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes" xml:space="preserve">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;&quot;myString&quot;&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target state="translated">Обратите внимание, что нам не нужно явно передавать тип в угловых скобках ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ); компилятор просто посмотрел на значение &lt;code&gt;&quot;myString&quot;&lt;/code&gt; и установил для &lt;code&gt;T&lt;/code&gt; его тип. Хотя вывод аргументов типа может быть полезным инструментом для того, чтобы код был короче и читабельнее, вам может потребоваться явная передача аргументов типа, как мы делали в предыдущем примере, когда компилятор не может определить тип, что может случиться в более сложных примерах. .</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target state="translated">Обратите внимание, что мы не используем ключевое слово &lt;code&gt;require&lt;/code&gt; ; вместо этого мы назначаем непосредственно из полного имени импортируемого символа. Это похоже на использование &lt;code&gt;var&lt;/code&gt; , но также работает с типом и значениями пространства имен импортированного символа. Важно отметить, что для значений, &lt;code&gt;import&lt;/code&gt; является идеальной отправной точкой справки из исходного символа, так что изменения к совмещенному &lt;code&gt;var&lt;/code&gt; не будет отражен в исходном переменном.</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes" xml:space="preserve">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target state="translated">Обратите внимание, что нам пришлось заключить это утверждение в круглые скобки. JavaScript обычно анализирует &lt;code&gt;{&lt;/code&gt; как начало блока.</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes" xml:space="preserve">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">Обратите внимание, что нам приходилось использовать утверждения типа несколько раз. Было бы намного лучше, если бы после проверки мы могли знать тип &lt;code&gt;pet&lt;/code&gt; в каждой ветке.</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes" xml:space="preserve">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target state="translated">Обратите внимание, что мы установили TypeScript в качестве зависимости от разработки. Мы также могли бы связать TypeScript с глобальной копией с помощью &lt;code&gt;npm link typescript&lt;/code&gt; , но это менее распространенный сценарий.</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes" xml:space="preserve">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что мы указали &lt;code&gt;debug: true&lt;/code&gt; для Browserify. Это заставляет tsify генерировать исходные карты внутри связанного файла JavaScript. Карты исходного кода позволяют отлаживать исходный код TypeScript в браузере вместо встроенного JavaScript. Вы можете проверить , что карты источника работают, открыв отладчик для вашего браузера и положить точку останова внутри &lt;code&gt;main.ts&lt;/code&gt; . Когда вы обновляете страницу, точка останова должна приостановить страницу и позволить вам отладить &lt;code&gt;greet.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;read more about that here&lt;/a&gt;.</source>
          <target state="translated">Обратите внимание, что мы &lt;code&gt;node_modules&lt;/code&gt; файлы из node_modules . Пакеты npm React и React-DOM включают автономные файлы &lt;code&gt;.js&lt;/code&gt; , которые вы можете включить на веб-страницу, и мы ссылаемся на них напрямую, чтобы ускорить работу. Вы можете скопировать эти файлы в другой каталог или разместить их в сети доставки контента (CDN). Facebook делает доступными версии React, размещенные на CDN, и вы можете &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;прочитать об этом здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes" xml:space="preserve">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что, хотя мы не можем использовать &lt;code&gt;name&lt;/code&gt; извне &lt;code&gt;Person&lt;/code&gt; , мы все равно можем использовать его в методе экземпляра &lt;code&gt;Employee&lt;/code&gt; , потому что &lt;code&gt;Employee&lt;/code&gt; является производным от &lt;code&gt;Person&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes" xml:space="preserve">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target state="translated">Обратите внимание, что для приведенных выше аннотаций типов не требуется. Утверждение &lt;code&gt;const&lt;/code&gt; позволяет TypeScript принимать наиболее конкретный тип выражения.</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes" xml:space="preserve">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target state="translated">Обратите внимание , что данный аргумент &lt;code&gt;createSquare&lt;/code&gt; пишется &lt;em&gt; &lt;code&gt;colour&lt;/code&gt; &lt;/em&gt; вместо &lt;code&gt;color&lt;/code&gt; . В простом JavaScript такие вещи тихо не работают.</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target state="translated">Сейчас &lt;code&gt;search&lt;/code&gt; является &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt; . Распространение объекта сложнее, чем распространение массива. Как и при расширении массива, оно происходит слева направо, но в результате все равно остается объект. Это означает, что свойства, которые появляются позже в объекте распространения, перезаписывают свойства, которые появляются раньше. Итак, если мы изменим предыдущий пример так, чтобы он распространялся в конце:</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes" xml:space="preserve">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target state="translated">Теперь TypeScript знает, что &lt;code&gt;createCardPicker&lt;/code&gt; ожидает вызова для объекта &lt;code&gt;Deck&lt;/code&gt; . Это означает, что теперь &lt;code&gt;this&lt;/code&gt; тип &lt;code&gt;Deck&lt;/code&gt; , а не &lt;code&gt;any&lt;/code&gt; , поэтому &lt;code&gt;--noImplicitThis&lt;/code&gt; не вызовет никаких ошибок.</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes" xml:space="preserve">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target state="translated">Теперь измените &lt;code&gt;main.ts&lt;/code&gt; , чтобы обновить страницу:</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes" xml:space="preserve">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target state="translated">Теперь измените код в &lt;code&gt;src/main.ts&lt;/code&gt; , чтобы импортировать &lt;code&gt;sayHello&lt;/code&gt; из &lt;code&gt;greet.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes" xml:space="preserve">
          <source>Now change your gulpfile to the following:</source>
          <target state="translated">Теперь измените свой глотательный файл на следующий:</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes" xml:space="preserve">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">Теперь, если вы аннотируете вызывающий код &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes" xml:space="preserve">
          <source>Now imports to &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target state="translated">Теперь импорт в &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; будет искать в &lt;code&gt;./modules/moduleA&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target state="translated">Теперь давайте посмотрим, как обрабатываются возвращаемые типы, используя две функции, которые отличаются только своим возвращаемым типом:</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target state="translated">Теперь переместим этот проект из Node в браузер. Для этого мы хотим объединить все наши модули в один файл JavaScript. К счастью, это именно то, что делает Browserify. Более того, он позволяет нам использовать модульную систему CommonJS, используемую Node, которая является генератором TypeScript по умолчанию. Это означает, что наши настройки TypeScript и Node будут перенесены в браузер практически без изменений.</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target state="translated">Теперь воспользуемся размеченным объединением:</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes" xml:space="preserve">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target state="translated">Теперь откройте &lt;code&gt;index.html&lt;/code&gt; в своем любимом браузере, и все должно быть готово к использованию! Вы должны увидеть страницу с надписью &amp;laquo;Привет от TypeScript и React!&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes" xml:space="preserve">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target state="translated">Теперь щелкните правой кнопкой мыши &lt;code&gt;gulpfile.js&lt;/code&gt; и выберите &amp;laquo;Обозреватель задач&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes" xml:space="preserve">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target state="translated">Теперь,когда мы объединили наш код с Browserify и tsify,мы можем добавить различные функции в нашу сборку с помощью плагинов браузера.</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target state="translated">Теперь, когда мы напечатали функцию, давайте напишем полный тип функции, посмотрев на каждую часть типа функции.</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes" xml:space="preserve">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target state="translated">Теперь,когда вы создали файл декларации,следуя шагам этого руководства,пришло время опубликовать его в npm.Есть два основных способа опубликовать файлы объявлений в npm:</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes" xml:space="preserve">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target state="translated">Теперь, когда вы знаете, как обернуть свойства типа, следующее, что вам нужно сделать, это развернуть их. К счастью, это довольно просто:</target>
        </trans-unit>
        <trans-unit id="6f30ea04179dac8c71c16f96f3f1582920ec3fad" translate="yes" xml:space="preserve">
          <source>Now the type of the array propagates into the &lt;code&gt;ArrayMetadata&lt;/code&gt; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes" xml:space="preserve">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target state="translated">Теперь, чтобы расширить это, чтобы добавить поддержку ввода с числами в основаниях, отличных от 10, давайте создадим &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes" xml:space="preserve">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target state="translated">Теперь введите в &lt;code&gt;greeter.html&lt;/code&gt; следующее :</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes" xml:space="preserve">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; or &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt;.</source>
          <target state="translated">Теперь мы можем &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; &lt;code&gt;node.d.ts&lt;/code&gt; , а затем загрузить модули, используя &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; или &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes" xml:space="preserve">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target state="translated">Теперь мы можем начать пользоваться некоторыми новыми инструментами, которые предлагает TypeScript. Добавьте аннотацию типа &lt;code&gt;: string&lt;/code&gt; к аргументу функции 'person', как показано здесь:</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes" xml:space="preserve">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target state="translated">Теперь мы можем использовать &lt;code&gt;npm install&lt;/code&gt; для установки пакетов. Сначала установите &lt;code&gt;gulp-cli&lt;/code&gt; глобально (если вы используете систему Unix, вам может потребоваться префикс &lt;code&gt;sudo&lt;/code&gt; для команд &lt;code&gt;npm install&lt;/code&gt; в этом руководстве ).</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target state="translated">Теперь превратим эту папку в пакет npm.</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes" xml:space="preserve">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target state="translated">Теперь, когда вызываются эти &lt;code&gt;never&lt;/code&gt; возвращающиеся функции, TypeScript распознает, что они влияют на граф потока управления, и учитывает их.</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes" xml:space="preserve">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target state="translated">Теперь, когда вы запустите Gulp, он должен запуститься и продолжать работать. Попробуйте изменить код &lt;code&gt;showHello&lt;/code&gt; в &lt;code&gt;main.ts&lt;/code&gt; и сохранить его. Вы должны увидеть следующий результат:</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes" xml:space="preserve">
          <source>Now you can import things that match &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; or &lt;code&gt;&quot;json!*&quot;&lt;/code&gt;.</source>
          <target state="translated">Теперь вы можете импортировать вещи, соответствующие &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; или &lt;code&gt;&quot;json!*&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b80d5fe66868146461ed39d9590423def0cc437" translate="yes" xml:space="preserve">
          <source>Now, for the remainder of the &lt;code&gt;createElement&lt;/code&gt; definition: &lt;code&gt;(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]&lt;/code&gt;. The first argument &lt;code&gt;tagName&lt;/code&gt; is defined as the generic parameter &lt;code&gt;K&lt;/code&gt; . The TypeScript interpreter is smart enough to &lt;em&gt;infer&lt;/em&gt; the generic parameter from this argument. This means that the developer does not actually have to specify the generic parameter when using the method; whatever value is passed to the &lt;code&gt;tagName&lt;/code&gt; argument will be inferred as &lt;code&gt;K&lt;/code&gt; and thus can be used throughout the remainder of the definition. Which is exactly what happens; the return value &lt;code&gt;HTMLElementTagNameMap[K]&lt;/code&gt; takes the &lt;code&gt;tagName&lt;/code&gt; argument and uses it to return the corresponding type. This definition is how the &lt;code&gt;p&lt;/code&gt; variable from the code snippet gets a type of &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. And if the code was &lt;code&gt;document.createElement('a')&lt;/code&gt;, then it would be an element of type &lt;code&gt;HTMLAnchorElement&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes" xml:space="preserve">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes" xml:space="preserve">
          <source>Null and Undefined</source>
          <target state="translated">Null and Undefined</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes" xml:space="preserve">
          <source>Null- and undefined-aware types</source>
          <target state="translated">Нулевой и неопределенный типы</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
          <target state="translated">Шкатурные типы</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes" xml:space="preserve">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target state="translated">Типы, &lt;code&gt;strictNullChecks&lt;/code&gt; значение NULL, имеют значение, только если включена strictNullChecks :</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes" xml:space="preserve">
          <source>Nullish Coalescing</source>
          <target state="translated">Nullish Coalescing</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes" xml:space="preserve">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target state="translated">Нумероподобными свойствами типа объекта являются свойства,объявленные с помощью числового буквального или вычисленного имени свойства числового буквального типа.</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes" xml:space="preserve">
          <source>Numeric Literal Types</source>
          <target state="translated">Числовые буквенные типы</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes" xml:space="preserve">
          <source>Numeric enums</source>
          <target state="translated">Числовые перечисления</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes" xml:space="preserve">
          <source>Numeric enums can be mixed in &lt;a href=&quot;#computed-and-constant-members&quot;&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target state="translated">Числовые перечисления могут быть смешаны с &lt;a href=&quot;#computed-and-constant-members&quot;&gt;вычисляемыми и постоянными членами (см. Ниже)&lt;/a&gt; . Вкратце, перечисления без инициализаторов либо должны быть первыми, либо должны идти после числовых перечислений, инициализированных числовыми константами или другими постоянными членами перечисления. Другими словами, нельзя:</target>
        </trans-unit>
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">числовые разделители</target>
        </trans-unit>
        <trans-unit id="8ec915a9d6271aa88a6e6bab3fe9b7a8d9dc2808" translate="yes" xml:space="preserve">
          <source>OOP in TypeScript</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e96ab681e7258c80946a74a514f141957d53b7" translate="yes" xml:space="preserve">
          <source>OOP programmers are accustomed to being able to query the type of any value, even a generic one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adeb8baadb7619ed1ee71c0d637100cf68745ddb" translate="yes" xml:space="preserve">
          <source>OOP programmers are often surprised by two particular aspects of structural typing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">Распространение и отдых объектов</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">Разрушение объекта</target>
        </trans-unit>
        <trans-unit id="1ccb033a21e86f3dd077314deacc164caf7a1572" translate="yes" xml:space="preserve">
          <source>Object literal type syntax closely mirrors object literal value syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">Буквы объекта открыты</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">Литералы объектов ведут себя так, как если бы у них была индексная подпись &lt;code&gt;[x:string]: any&lt;/code&gt; которая позволяет рассматривать их как открытые карты вместо закрытых объектов.</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">Остатки объектов - это двойные объекты разворотов, поскольку они могут извлекать любые дополнительные свойства, которые не используются при деструктуризации элемента:</target>
        </trans-unit>
        <trans-unit id="e39aafc54b41f807d4c66cedbf76e1c69bb09f15" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">У разброса объектов есть еще несколько удивительных ограничений. Во-первых, он включает только &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;собственные перечислимые свойства объекта&lt;/a&gt; . По сути, это означает, что вы теряете методы при распространении экземпляров объекта:</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">Объекты со свойствами</target>
        </trans-unit>
        <trans-unit id="e74f2b06a5fbe1c04ad866d78d3e98d6af48f45f" translate="yes" xml:space="preserve">
          <source>Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8b413b8349b0d2cda00f56b58728dca71d8f18" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using TypeScript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">Конечно, любой из этих типов может быть объявлен с использованием синтаксиса &lt;code&gt;@typedef&lt;/code&gt; однострочном @typedef :</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">Конечно, поскольку это JavaScript, вы можете просто игнорировать конечные элементы, которые вам не нужны:</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">Конечно, это может показаться неправильным. Если вы откроете этот файл в редакторе с поддержкой TypeScript (или запустите &lt;code&gt;tsc --pretty&lt;/code&gt; ), вы можете увидеть красные волнистые линии на определенных строках. Вы должны думать об этом так же, как о красных волнистых линиях в редакторе, таком как Microsoft Word. TypeScript по-прежнему будет переводить ваш код, так же как Word по-прежнему позволяет печатать ваши документы.</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">Следует отметить, что только параметры и возвращаемый тип составляют тип функции. Захваченные переменные не отражаются в типе. Фактически, захваченные переменные являются частью &amp;laquo;скрытого состояния&amp;raquo; любой функции и не составляют ее API.</target>
        </trans-unit>
        <trans-unit id="58d8c4b2203739a560ee5629e213ae51b2e9cc9a" translate="yes" xml:space="preserve">
          <source>Offers a way to configure the root directory for where declaration files are emitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">Официальный пакет TypeScript NuGet</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">Часто проект имеет несколько целей вывода, например, &lt;code&gt;ES5&lt;/code&gt; и &lt;code&gt;ES2015&lt;/code&gt; , отладка и производство или &lt;code&gt;CommonJS&lt;/code&gt; и &lt;code&gt;System&lt;/code&gt; ; Между этими двумя целями меняется всего несколько параметров конфигурации, и поддержка нескольких файлов &lt;code&gt;tsconfig.json&lt;/code&gt; может стать проблемой .</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">Часто в приложениях Node.js требуется &lt;code&gt;.json&lt;/code&gt; . В TypeScript 2.9 &lt;code&gt;--resolveJsonModule&lt;/code&gt; позволяет импортировать, извлекать типы и &lt;code&gt;.json&lt;/code&gt; файлы .json .</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">Часто модули расширяют другие модули,и частично раскрывают некоторые их возможности.Реэкспорт не импортирует его локально или не вводит локальную переменную.</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">Часто в вашем проекте есть внешние исходные файлы,которые не могут быть написаны в TypeScript.Альтернативно,вы можете быть в середине преобразования базы JS-кода в TS,но все еще хотите связать весь ваш JS-код в один файл с выводом вашего нового TS-кода.</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">Часто вам нужно расширить функциональность модуля. Распространенным шаблоном JS является расширение исходного объекта &lt;em&gt;расширениями&lt;/em&gt; , аналогично тому, как работают расширения JQuery. Как мы упоминали ранее, модули не &lt;em&gt;объединяются,&lt;/em&gt; как объекты глобального пространства имен. Рекомендуемое решение - &lt;em&gt;не&lt;/em&gt; изменять исходный объект, а скорее экспортировать новую сущность, которая предоставляет новые функции.</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">На одной линии:</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">На нескольких линиях:</target>
        </trans-unit>
        <trans-unit id="b121f75269ef9070c6142e71c944032a79d56440" translate="yes" xml:space="preserve">
          <source>On operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on &lt;code&gt;node_modules&lt;/code&gt; and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the of files in &lt;code&gt;node_modules&lt;/code&gt;, whereas there are way fewer directories to track.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">В последней строке фрагмента вы можете видеть, что даже присвоение всего &lt;code&gt;ReadonlyArray&lt;/code&gt; обычному массиву является незаконным. Однако вы все равно можете переопределить его с помощью утверждения типа:</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">Что касается организации, пространства имен удобны для группировки логически связанных объектов и типов в глобальной области. Например, в C # вы найдете все типы коллекций в System.Collections. Организуя наши типы в иерархические пространства имен, мы обеспечиваем хорошее &amp;laquo;обнаружение&amp;raquo; для пользователей этих типов. С другой стороны, модули обязательно уже присутствуют в файловой системе. Мы должны разрешить их по пути и имени файла, поэтому есть логическая схема организации, которую мы можем использовать. У нас может быть папка / collections / generic / со списком в ней.</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">С другой стороны, если вы не можете выразить какую-либо форму с помощью интерфейса и вам нужно использовать тип объединения или кортежа, обычно можно использовать псевдонимы типов.</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">С другой стороны, теперь можно будет вызывать такие методы, как &lt;code&gt;forEach&lt;/code&gt; , но в &lt;code&gt;noImplicitAny&lt;/code&gt; могут возникнуть некоторые проблемы.</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">После определения,мы можем использовать этот интерфейс типа функции,как и другие интерфейсы.Здесь мы показываем,как можно создать переменную типа функции и присвоить ей значение этого же типа.</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">После того, как тип класса установлен, тип экземпляра определяется объединением возвращаемых типов конструкции типа класса или сигнатур вызовов (в зависимости от того, что присутствует). Итак, опять же, в случае класса ES6 тип экземпляра будет типом экземпляра этого класса, а в случае фабричной функции это будет тип значения, возвращаемого функцией.</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">Когда задействовано несколько файлов, нам нужно убедиться, что весь скомпилированный код загружен. Это можно сделать двумя способами.</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">После того, как мы написали универсальную функцию идентификации, мы можем вызвать ее одним из двух способов. Первый способ - передать функции все аргументы, включая аргумент типа:</target>
        </trans-unit>
        <trans-unit id="efd9fd3ef569813fe54f40f7a5348da23bd676a1" translate="yes" xml:space="preserve">
          <source>Once you start thinking of types as sets, certain operations become very natural. For example, in C#, it&amp;rsquo;s awkward to pass around a value that is &lt;em&gt;either&lt;/em&gt; a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt;, because there isn&amp;rsquo;t a single type that represents this sort of value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd09b9672aef2e12094c6286dae7bf22bea682c2" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;re feeling comfortable, you can come back to read &lt;a href=&quot;typescript-in-5-minutes&quot;&gt;TypeScript for JavaScript Programmers&lt;/a&gt;, then start on &lt;a href=&quot;intro&quot;&gt;the handbook&lt;/a&gt; or explore the &lt;a href=&quot;https://www.typescriptlang.org/play#show-examples&quot;&gt;Playground examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">Одним из преимуществ этого является то, что шаблон вызываемого конструктора может быть легко выражен, а также позволяет пространствам имен объединяться с этими объявлениями (поскольку объявления &lt;code&gt;var&lt;/code&gt; не могут объединяться с &lt;code&gt;namespace&lt;/code&gt; s).</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">Одна из распространенных задач - взять существующий тип и сделать каждое из его свойств совершенно необязательным. Допустим, у нас есть &lt;code&gt;Person&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">Одно отличие от предыдущего примера состоит в том, что каждый производный класс, содержащий функцию конструктора, &lt;em&gt;должен&lt;/em&gt; вызывать &lt;code&gt;super()&lt;/code&gt; который будет выполнять конструктор базового класса. Более того, прежде чем мы &lt;em&gt;когда-либо&lt;/em&gt; получим доступ к свойству &lt;code&gt;this&lt;/code&gt; в теле конструктора, мы &lt;em&gt;должны&lt;/em&gt; вызвать &lt;code&gt;super()&lt;/code&gt; . Это важное правило, которое TypeScript будет соблюдать.</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">Одно отличие состоит в том, что интерфейсы создают новое имя, которое используется везде. Псевдонимы типа не создают новое имя - например, в сообщениях об ошибках не будет использоваться псевдоним. В приведенном ниже коде наведение курсора на &lt;code&gt;interfaced&lt;/code&gt; в редакторе покажет, что он возвращает &lt;code&gt;Interface&lt;/code&gt; , но покажет, что &lt;code&gt;aliased&lt;/code&gt; возвращает тип литерала объекта.</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">Единственным исключением из этого правила являются специализированные подписи. Если в сигнатуре есть параметр, тип которого является &lt;em&gt;одним&lt;/em&gt; строковым литералом (например, не объединением строковых литералов), то он будет перемещаться в верхнюю часть своего объединенного списка перегрузки.</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">Последний способ обойти эти проверки, который может быть немного удивительным, - это присвоить объект другой переменной: поскольку &lt;code&gt;squareOptions&lt;/code&gt; не будет подвергаться избыточным проверкам свойств, компилятор не выдаст вам ошибку.</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">Одно большое преимущество в том , что вы будете видеть &lt;em&gt;путь меньше&lt;/em&gt; неявные &lt;code&gt;any&lt;/code&gt; ошибки при работе с &lt;code&gt;--noImplicitAny&lt;/code&gt; . Неявно &lt;code&gt;any&lt;/code&gt; ошибки сообщаются только в том случае, если компилятор не может узнать тип переменной без аннотации типа.</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">Одно из важных различий между внешними и внешними перечислениями заключается в том, что в обычных перечислениях члены, не имеющие инициализатора, будут считаться постоянными, если их предыдущий член перечисления считается постоянным. Напротив, внешний (и неконстантный) член перечисления, у которого нет инициализатора, &lt;em&gt;всегда&lt;/em&gt; считается вычисленным.</target>
        </trans-unit>
        <trans-unit id="7b053fca39618dd4a858f60861664a6e5ed2adab" translate="yes" xml:space="preserve">
          <source>One is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">Один из основных принципов TypeScript заключается в том, что проверка типов фокусируется на &lt;em&gt;форме,&lt;/em&gt; которую имеют значения. Иногда это называют &amp;laquo;утиным типированием&amp;raquo; или &amp;laquo;структурным подтипом&amp;raquo;. В TypeScript интерфейсы выполняют роль именования этих типов и являются мощным способом определения контрактов в вашем коде, а также контрактов с кодом вне вашего проекта.</target>
        </trans-unit>
        <trans-unit id="c757d0f6603eddb47aa6c55cbe608a6509f704fb" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural typing&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">Одно из наиболее распространённых использований интерфейсов в таких языках,как C#и Java,то есть явное принуждение класса к выполнению определённого контракта,также возможно и в TypeScript.</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">Одно или несколько назначений &lt;code&gt;window.someName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48a39bde8026af120315f595a3ebaf87946a36c6" translate="yes" xml:space="preserve">
          <source>One style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added are included in the export.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">Одним из таких примеров является объект,который действует и как функция,и как объект,с дополнительными свойствами:</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">Следует отметить, что &lt;code&gt;const&lt;/code&gt; утверждения можно сразу применить только к простым литеральным выражениям.</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">Выдавать только файлы объявлений '.d.ts'.</target>
        </trans-unit>
        <trans-unit id="7c44d3d53fcf28280aed7f275c80df87912e368d" translate="yes" xml:space="preserve">
          <source>Only emit &lt;code&gt;.d.ts&lt;/code&gt; declaration files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">Откройте &lt;code&gt;greeter.html&lt;/code&gt; в браузере, чтобы запустить ваше первое простое веб-приложение TypeScript!</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">Откройте &lt;strong&gt;зависимости&amp;gt; Управление пакетами NuGet&amp;gt; Обзор. &lt;/strong&gt;Найдите и установите &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; и &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">Откройте файл &lt;code&gt;Startup.cs&lt;/code&gt; и отредактируйте функцию &lt;code&gt;Configure&lt;/code&gt; , чтобы она выглядела следующим образом:</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">Опция &lt;code&gt;--outDir&lt;/code&gt; дублирует входную иерархию в выходной. Компилятор вычисляет корень входных файлов как самый длинный общий путь для всех входных файлов; а затем использует это для репликации всей своей подструктуры в выходных данных.</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">Необязательные переменные предложения &lt;code&gt;catch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">Дополнительная цепочка</target>
        </trans-unit>
        <trans-unit id="7639a6c68ad000bff451144276aba49f18f3a141" translate="yes" xml:space="preserve">
          <source>Optional Global Usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">Дополнительные сценарии загрузки модулей и другие сценарии загрузки дополнительных модулей</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">Дополнительные параметры и параметры отдохновения</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">Дополнительные параметры в обратных вызовах</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">Дополнительные свойства</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">Дополнительные параметры и параметры по умолчанию</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">Необязательная цепочка также включает две другие операции. Во-первых, есть &lt;em&gt;необязательный доступ к элементу,&lt;/em&gt; который действует аналогично &lt;em&gt;доступу&lt;/em&gt; к необязательному свойству, но позволяет нам получать доступ к свойствам, не являющимся идентификаторами (например, произвольным строкам, числам и символам):</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">Необязательная цепочка - это &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;проблема №16&lt;/a&gt; в нашем трекере проблем. Для контекста, с тех пор в системе отслеживания проблем TypeScript было зарегистрировано более 23 000 проблем.</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">Дополнительные свойства класса</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">Дополнительные элементы в типах кортежей</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">Дополнительные элементы в типах кортежей.</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">Дополнительные параметры и свойства</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">Дополнительные параметры и свойства автоматически были &lt;code&gt;undefined&lt;/code&gt; добавлены к типам, даже если их аннотации типов конкретно не включают &lt;code&gt;undefined&lt;/code&gt; . Например, следующие два типа идентичны:</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">Дополнительные свойства и методы теперь могут быть объявлены в классах,аналогично тому,что уже разрешено в интерфейсах.</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">Необязательно: откройте &lt;code&gt;greeter.ts&lt;/code&gt; в Visual Studio или скопируйте код на площадку TypeScript. Вы можете навести указатель мыши на идентификаторы, чтобы увидеть их типы. Обратите внимание, что в некоторых случаях эти типы выводятся автоматически. Повторно введите последнюю строку и посмотрите списки завершения и справку по параметрам, основанные на типах элементов DOM. Наведите курсор на ссылку на функцию приветствия и нажмите F12, чтобы перейти к ее определению. Также обратите внимание, что вы можете щелкнуть правой кнопкой мыши по символу и использовать рефакторинг, чтобы переименовать его.</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">При желании, модуль может обернуть один или несколько модулей и объединить все их экспорты с помощью синтаксиса &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df58492b3818e56d4c38cba029dab1a47423cc16" translate="yes" xml:space="preserve">
          <source>Or a number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c98dcc822443a4b856eb1d3e76f5a1ef879a05c5" translate="yes" xml:space="preserve">
          <source>Or by marking each export individually:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">Или проигнорируйте элементы &quot;следа&quot;,или другие элементы:</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">Или другие элементы:</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">Или нам может понадобиться версия только для чтения:</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">Или вы можете просто использовать неуказанный тип &lt;code&gt;Function&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">Или даже вручную установить все значения в перечислении:</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">Или мы могли бы описать функцию идентификации, используя &lt;code&gt;any&lt;/code&gt; тип:</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">Типы организации</target>
        </trans-unit>
        <trans-unit id="62cda73390e4d48b545b79bfcdb477a68054f2e3" translate="yes" xml:space="preserve">
          <source>Other important TypeScript types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">Другие типы от Closure также работают:</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">Допускаются и другие варианты:</target>
        </trans-unit>
        <trans-unit id="9840b9a741b28ca4c8860ce6d87a0177a3a2e4c4" translate="yes" xml:space="preserve">
          <source>Otherwise</source>
          <target state="translated">Otherwise</target>
        </trans-unit>
        <trans-unit id="f12741a8f50c8d0742198f4cc7b9b0054355cfbe" translate="yes" xml:space="preserve">
          <source>Otherwise &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">В противном случае используйте &lt;code&gt;--keyofStringsOnly&lt;/code&gt; компилятора --keyofStringsOnly, чтобы отключить новое поведение.</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">В противном случае условие зависит от одной или нескольких переменных типа,а условие является отложенным.</target>
        </trans-unit>
        <trans-unit id="2fe09ba85c2f62b83a765f71cc1cff43f6cbaef7" translate="yes" xml:space="preserve">
          <source>Otherwise, these functions accept any arguments and will return &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">В противном случае мы предполагаем, что вы уже используете &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; с &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a8d8f3092b4cff717b9df2b61723845c6880cb0" translate="yes" xml:space="preserve">
          <source>Otherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the &lt;code&gt;@types&lt;/code&gt; organization on npm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">Наш первый интерфейс</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">В нашем пакете есть объявления каждого из них, поэтому любой пользователь нашего пакета &lt;code&gt;browserify-typescript-extension&lt;/code&gt; также должен иметь эти зависимости. По этой причине мы использовали &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; а не &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; , потому что в противном случае нашим потребителям пришлось бы вручную устанавливать эти пакеты. Если бы мы только что написали приложение командной строки и не ожидали, что наш пакет будет использоваться в качестве библиотеки, мы могли бы использовать &lt;code&gt;devDependencies&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9be54203007d8d30f26947bb7d7851872869089d" translate="yes" xml:space="preserve">
          <source>Out - &lt;code&gt;out&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdf8d59b6859bfc492a315ea8318c5d9803cadf" translate="yes" xml:space="preserve">
          <source>Out Dir - &lt;code&gt;outDir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a751e953fed78cf12f40a39506ec48371ed775" translate="yes" xml:space="preserve">
          <source>Out File - &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">Расширение выходного файла</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">Выходной каталог для сгенерированных файлов декларации.</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">Генерация выхода</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">Вне &lt;code&gt;.tsx&lt;/code&gt; файлов, синтаксис утверждения скобки также может быть использован.</target>
        </trans-unit>
        <trans-unit id="c9668372e49b3da9f21e77e4a98e554bc74a9a36" translate="yes" xml:space="preserve">
          <source>Over 20 years after its introduction to the programming community, JavaScript is now one of the most widespread cross-platform languages ever created. Starting as a small scripting language for adding trivial interactivity to webpages, JavaScript has grown to be a language of choice for both frontend and backend applications of every size. While the size, scope, and complexity of programs written in JavaScript has grown exponentially, the ability of the JavaScript language to express the relationships between different units of code has not. Combined with JavaScript&amp;rsquo;s rather peculiar runtime semantics, this mismatch between language and program complexity has made JavaScript development a difficult task to manage at scale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">Общая структура</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">Перегруженная функция</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">Перегруженные функции</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">Перегрузки и обратные вызовы</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3db8119e7d2abacd7ddc5a64f7223117366fcdc7" translate="yes" xml:space="preserve">
          <source>Package.json</source>
          <target state="translated">Package.json</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">Пакеты в &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;рамках&lt;/a&gt; организации @types публикуются автоматически из &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;Определенного &lt;/a&gt;Типа с помощью &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;инструмента публикации типов&lt;/a&gt; . Чтобы опубликовать свои объявления в виде пакета @types, отправьте запрос на перенос по &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;адресу https://github.com/DefinitiTyped/DefinitiTyped&lt;/a&gt; . Вы можете найти более подробную информацию на &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;странице с рекомендациями&lt;/a&gt; по взносам .</target>
        </trans-unit>
        <trans-unit id="84bd5a555866968aa5aa6d7b7d92dc740334b9d1" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">Упаковочные декларации</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">Параметры Декораторы</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">Свойства параметров</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">Свойства параметра объявляются с помощью префикса параметра конструктора с помощью модификатора доступности или только для &lt;code&gt;readonly&lt;/code&gt; , или того и другого. Использование &lt;code&gt;private&lt;/code&gt; для свойства параметра объявляет и инициализирует частный член; аналогично то же самое сделано для &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; и только для &lt;code&gt;readonly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">Объявление параметров с именами, начинающимися с &lt;code&gt;_&lt;/code&gt; , не подлежит проверке неиспользуемых параметров. например:</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">Выполните синтаксический анализ в строгом режиме и выдайте &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; для каждого исходного файла</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">Разбирает весь код в строгом режиме.</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">Частично намерение составных проектов ( &lt;code&gt;tsconfig.json&lt;/code&gt; s с &lt;code&gt;composite&lt;/code&gt; значением &lt;code&gt;true&lt;/code&gt; ) состоит в том, что ссылки между различными проектами могут создаваться постепенно. Таким образом, составные проекты &lt;strong&gt;всегда&lt;/strong&gt; будут создавать файлы &lt;code&gt;.tsbuildinfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b5be6f8582750be194de793f18c152404f2f31a1" translate="yes" xml:space="preserve">
          <source>Pass it an element id string and it will return either &lt;code&gt;HTMLElement&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; . This method introduces one of the most important types, &lt;code&gt;HTMLElement&lt;/code&gt;. It serves as the base interface for every other element interface. For example, the &lt;code&gt;p&lt;/code&gt; variable in the code example is of type &lt;code&gt;HTMLParagraphElement&lt;/code&gt;. Also take note that this method can return &lt;code&gt;null&lt;/code&gt;. This is because the method can&amp;rsquo;t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new &lt;em&gt;optional chaining&lt;/em&gt; operator is used in order to call &lt;code&gt;appendChild&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">Передача &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; вместе с &lt;code&gt;--jsx react&lt;/code&gt; позволяет использовать другую фабрику JSX из &lt;code&gt;React&lt;/code&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">Картирование маршрутов</target>
        </trans-unit>
        <trans-unit id="a3a3e9569fa3eb5fb1f186e97032bcfd280061ac" translate="yes" xml:space="preserve">
          <source>Paths - &lt;code&gt;paths&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">Шаблоны,которые,как известно,НЕ поддерживаются.</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">Заказные заводы JSX</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">Выполните дополнительные проверки, чтобы убедиться, что отдельная компиляция (например, с &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescript&lt;/a&gt; ) будет безопасной.</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">Повышение эффективности</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">Питфоллы пространств имен и модулей</target>
        </trans-unit>
        <trans-unit id="b9fa3258f08647142ce462aa1c6002ef1e1b8662" translate="yes" xml:space="preserve">
          <source>Platform specific</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">Обратите внимание, что компилятор не включает файлы, которые могут быть возможными выходами; например, если входные данные включают &lt;code&gt;index.ts&lt;/code&gt; , то &lt;code&gt;index.d.ts&lt;/code&gt; и &lt;code&gt;index.js&lt;/code&gt; исключаются. Как правило, не рекомендуется размещать рядом друг с другом файлы, различающиеся только расширением.</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">Обратите внимание, что этот комментарий только подавляет сообщения об ошибках, и мы рекомендуем вам использовать его &lt;em&gt;очень осторожно&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">Обратите внимание, что для этого требуется встроенная &lt;code&gt;Symbol.iterator&lt;/code&gt; или &lt;code&gt;Symbol.iterator&lt;/code&gt; во время выполнения для любых значений, не являющихся массивами.</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">Обратите внимание,что ts-loader не единственный загрузчик для typcript.</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&quot;paths&quot;&lt;/code&gt; разрешаются относительно &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; . При установке для &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; значения, отличного от &lt;code&gt;&quot;.&quot;&lt;/code&gt; , т.е. каталог &lt;code&gt;tsconfig.json&lt;/code&gt; , сопоставления должны быть соответственно изменены. Скажем, вы установили &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; в приведенном выше примере, тогда jquery должен быть сопоставлен с &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ee1de1fe598e71ad53be227754dfcb283d7c826" translate="yes" xml:space="preserve">
          <source>Plugins - &lt;code&gt;plugins&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d901da355d2ea7de032bab6160e7791b0cc0d9bd" translate="yes" xml:space="preserve">
          <source>Point-free programming</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6adebfdf8f61c41e82811b81640f526a81d347" translate="yes" xml:space="preserve">
          <source>Point-free programming &amp;mdash; heavy use of currying and function composition &amp;mdash; is possible in JavaScript, but can be verbose. In TypeScript, type inference often fails for point-free programs, so you&amp;rsquo;ll end up specifying type parameters instead of value parameters. The result is so verbose that it&amp;rsquo;s usually better to avoid point-free programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">Полиморфные &lt;code&gt;this&lt;/code&gt; типы</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">Полиморфный этот тип</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">Возможные значения:</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">Postfix equals для типа свойства в типе литерала объекта не указывает необязательное свойство:</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">Предопределенные условные типы</target>
        </trans-unit>
        <trans-unit id="9eee28bfd739e1debf4d3b892d013537ae16da9f" translate="yes" xml:space="preserve">
          <source>Predicate</source>
          <target state="translated">Predicate</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">Подготовка проекта будет включать выходные данные проекта выше выходных данных текущего проекта. Это работает как для файлов &lt;code&gt;.js&lt;/code&gt; ,так и &lt;code&gt;.d.ts&lt;/code&gt; файлов .d.ts , и файлы исходных карт также будут отправлены правильно.</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">Препроцессирование входных файлов</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="3718a89b87a1c09f9d2b2ab9ae6694d53dd18a75" translate="yes" xml:space="preserve">
          <source>Preserve Const Enums - &lt;code&gt;preserveConstEnums&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144537ff5fbb1fe2e7112d7a59fca5f0abb8a715" translate="yes" xml:space="preserve">
          <source>Preserve Symlinks - &lt;code&gt;preserveSymlinks&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e1ce16ca2c523a57cb24a6559708ada861d29c" translate="yes" xml:space="preserve">
          <source>Preserve Watch Output - &lt;code&gt;preserveWatchOutput&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f0d63b565582e80417d45fc9ee92a490e7a966" translate="yes" xml:space="preserve">
          <source>Preserve: &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">Хорошеет &lt;code&gt;--pretty&lt;/code&gt; выход</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; сообщения об ошибках от tsc</target>
        </trans-unit>
        <trans-unit id="7570791dbea8739420c045a800b27168c94bfd74" translate="yes" xml:space="preserve">
          <source>Pretty - &lt;code&gt;pretty&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">Предотвращение именных конфликтов</target>
        </trans-unit>
        <trans-unit id="f3be47e0536b2f1e3942d188698143c3820e4e15" translate="yes" xml:space="preserve">
          <source>Previous versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">Ранее модули CommonJS/AMD/UMD обрабатывались так же,как и модули ES6,что привело к паре проблем.А именно:</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">Ранее ошибка, теперь поддерживается в TypeScript 1.8. Объявления &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; внутри циклов и захваченные в функциях теперь генерируются для правильного соответствия семантике свежести &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">Ранее помеченная как недопустимая комбинация флагов, теперь поддерживается &lt;code&gt;target: es5&lt;/code&gt; и 'module: es6'. Это должно облегчить использование встряхивателей деревьев на основе ES2015, таких как &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;свертка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">Ранее генераторы поддерживались только в том случае, если целью является ES6 / ES2015 или новее. Более того, конструкции, работающие по протоколу Iterator, например &lt;code&gt;for..of&lt;/code&gt; , поддерживались только в том случае, если они работают с массивами для целей ниже ES6 / ES2015.</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">Ранее тип переменной &lt;code&gt;for..in&lt;/code&gt; определялся как &lt;code&gt;any&lt;/code&gt; ; это позволило компилятору игнорировать недопустимые использования в теле &lt;code&gt;for..in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">Раньше было два варианта:</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">Раньше для &lt;code&gt;obj&lt;/code&gt; предполагался тип &lt;code&gt;{}&lt;/code&gt; , и вторая строка впоследствии вызвала ошибку, поскольку казалось, что &lt;code&gt;obj&lt;/code&gt; не имеет свойств. Это явно было не идеально.</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">Раньше для неискаженного объединения не было &lt;em&gt;бы&lt;/em&gt; лишних проверок свойств для его членов, и в результате неправильно набранное свойство &lt;code&gt;name&lt;/code&gt; пропускалось.</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Раньше, если TypeScript не мог определить тип переменной, он выбирал &lt;code&gt;any&lt;/code&gt; тип.</target>
        </trans-unit>
        <trans-unit id="ebc73e847f1b3cd8d1dfb14f901fe12098f69eb7" translate="yes" xml:space="preserve">
          <source>Previously, this document details the &lt;code&gt;HTMLElement&lt;/code&gt; interface extends from &lt;code&gt;Element&lt;/code&gt; which extends from &lt;code&gt;Node&lt;/code&gt;. In the DOM API there is a concept of &lt;em&gt;children&lt;/em&gt; elements. For example in the following HTML, the &lt;code&gt;p&lt;/code&gt; tags are children of the &lt;code&gt;div&lt;/code&gt; element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">Раньше с такой структурой было довольно неудобно работать,если вы использовали один tsconfig файл:</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">Распечатайте справочное сообщение.</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">Печать имен файлов,входящих в состав компиляции.</target>
        </trans-unit>
        <trans-unit id="2c60c8260c586544fdf204a6918f732b286ae58d" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation. This is useful when you are not sure that TypeScript has included a file you expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8836994012dab85127a8b7fc5fd4ab0a0f4d486" translate="yes" xml:space="preserve">
          <source>Print names of files which TypeScript sees as a part of your project and the reason they are part of the compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b896feedfc6257fcbba34c3460737798c67b71a9" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation to the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">Печатайте имена сгенерированных файлов,входящих в состав компиляции.</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">Вывести версию компилятора.</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">До версии 3.3 при сборке составных проектов с использованием &lt;code&gt;--build --watch&lt;/code&gt; эта инфраструктура инкрементного отслеживания файлов фактически не использовалась. Обновление в одном проекте в режиме &lt;code&gt;--build --watch&lt;/code&gt; вызовет полную сборку этого проекта, а не определяет, какие файлы в этом проекте были затронуты.</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">До TypeScript 2.4,в следующем примере</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">До TypeScript 2.4 этот пример был успешным. При связывании типов &lt;code&gt;map&lt;/code&gt; TypeScript будет двунаправленно связывать их параметры (то есть тип &lt;code&gt;f&lt;/code&gt; ). При связывании каждого &lt;code&gt;f&lt;/code&gt; TypeScript также будет двунаправленно связывать тип &lt;em&gt;этих&lt;/em&gt; параметров.</target>
        </trans-unit>
        <trans-unit id="9c8599d61f9484e744e8b2658bec61eec3a61688" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 3.8, you can import a type using &lt;code&gt;import&lt;/code&gt;. With TypeScript 3.8, you can import a type using the &lt;code&gt;import&lt;/code&gt; statement, or using &lt;code&gt;import type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">Частные и охраняемые строители</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">Частные и защищенные члены в классе влияют на их совместимость. Когда экземпляр класса проверяется на совместимость, если целевой тип содержит закрытый член, тогда исходный тип также должен содержать закрытый член, происходящий из того же класса. Точно так же то же самое применимо к экземпляру с защищенным членом. Это позволяет классу быть совместимым по назначению со своим суперклассом, но &lt;em&gt;не&lt;/em&gt; с классами из другой иерархии наследования, которые в остальном имеют ту же форму.</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">Частные и защищенные члены в классах</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">Конфигурация проекта</target>
        </trans-unit>
        <trans-unit id="dff8cdae331a987352af975febbbf5bf3497c075" translate="yes" xml:space="preserve">
          <source>Project Options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">Ссылки на проект</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">Ссылки на проект:Режим построения для TypeScript</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">Ссылки на проект:Caveats</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">Ссылки на проект:Справочные материалы по проектам</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">Ссылки на проект:MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">Ссылки на проект:Общая структура</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">Ссылки на проект:Структурирование для outFiles</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">Ссылки на проект:Структурирование для относительных модулей</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">Ссылки на проект:Что такое ссылка на проект?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">Ссылки на проект:композитный</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">Ссылки на проект:декларацияКарты</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">Ссылки на проект:предоплата с помощью outFile</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">Ссылки на проект:tsc -b Командная строка</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">Ссылки на проекты-это новая возможность в TypeScript 3.0,которая позволяет структурировать ваши программы TypeScript на более мелкие части.</target>
        </trans-unit>
        <trans-unit id="c138392855d638ba9e2bf29899810a7e57e84035" translate="yes" xml:space="preserve">
          <source>Project references are a way to structure your TypeScript programs into smaller pieces. Using Project References can greatly improve build and editor interaction times, enforce logical separation between components, and organize your code in new and improved ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">Ссылки на проекты могут решить все эти проблемы и многое другое.</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">Ссылки на проекты имеют несколько компромиссов,о которых вам следует знать.</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">Поддержка проекта через &lt;code&gt;tsconfig.json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">Свойства выводятся из назначений в телах классов</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">Декларации о свойствах функций</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">Свойства в шаблоне объектной привязки,не имеющие совпадения в литерале объекта,должны иметь значение по умолчанию в шаблоне объектной привязки и автоматически добавляются к типу объект-литерал.</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">Свойства в буквальном объекте,не имеющие совпадения в шаблоне привязки объекта,являются ошибкой.</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">Свойства со значениями по умолчанию в шаблоне привязки объектов становятся необязательными в буквальном значении объекта.</target>
        </trans-unit>
        <trans-unit id="1af723998a3965fbd8fb5f43c4ba52d973f2b4be" translate="yes" xml:space="preserve">
          <source>Properties with relative paths found in the configuration file, which aren&amp;rsquo;t excluded from inheritance, will be resolved relative to the configuration file they originated in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">Декораторы недвижимости</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">Присвоения свойств и не генерические выражения спреда максимально объединяются по обеим сторонам общего выражения спреда.Например:</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">Переименование недвижимости</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">Назначение прототипов</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">Обеспечьте полную поддержку итераций в &lt;code&gt;for..of&lt;/code&gt; , распространении и деструктуризации при ориентации на ES5 или ES3.</target>
        </trans-unit>
        <trans-unit id="d26fd4d0603b6fec3f71df5845863025dd055f63" translate="yes" xml:space="preserve">
          <source>Providing Type Hints in JS via JSDoc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">Публично по умолчанию</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">Государственные,частные и защищенные модификаторы</target>
        </trans-unit>
        <trans-unit id="51ca411182511e3fdf77719b4e3e0c22adc6e606" translate="yes" xml:space="preserve">
          <source>Publish to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">Опубликовать в &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">Публикация в воскресенье</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">Публикации:Зависимости</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">Публикация:Публикация в @типах</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">Публикации:Красные флаги</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">Поставьте точку останова на линии с возвратом.</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">Сводя все вышеперечисленные правила в один пример.</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">Складывая все вместе</target>
        </trans-unit>
        <trans-unit id="c25bd9f882a3a8b49796dbe73c56bf10103c4152" translate="yes" xml:space="preserve">
          <source>Question to ask yourself while looking at a library you are trying to type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61ee9bc98f1490cb74d9856a2bcfdb903bd123" translate="yes" xml:space="preserve">
          <source>Quick introductions based on your background or preference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f6fe9f8c69850190c5d7fab3738cc93bedaed0" translate="yes" xml:space="preserve">
          <source>Raise error on &amp;lsquo;this&amp;rsquo; expressions with an implied &amp;lsquo;any&amp;rsquo; type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Поднимите ошибку в &lt;code&gt;this&lt;/code&gt; выражении с подразумеваемым &lt;code&gt;any&lt;/code&gt; типом.</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Вызывать ошибку в выражениях и объявлениях с подразумеваемым типом &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">Вместо того,чтобы на самом деле выполнять сборку с другими входными опциями и конфигурационными файлами,покажите конечный подразумеваемый конфигурационный файл в выходных данных.</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">При повторной компиляции вы увидите ошибку:</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">Передекларация и Тень</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">Реэкспорт на продление</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">Повторно запустите &lt;code&gt;tsc greeter.ts&lt;/code&gt; , и вы увидите, что сгенерированный JavaScript такой же, как и предыдущий код. Классы в TypeScript - это просто сокращение для того же объектно-ориентированного объекта на основе прототипов, который часто используется в JavaScript.</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">Реагировать и Webpack</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">React &amp;amp; Webpack: добавить файл конфигурации TypeScript</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">React &amp;amp; Webpack: создайте файл конфигурации webpack</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">React &amp;amp; Webpack: инициализировать проект</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React &amp;amp; Webpack: установите наши зависимости</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">React &amp;amp; Webpack: макет проекта</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">React и Webpack: объединяем все вместе</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">React &amp;amp; Webpack: напишите код</target>
        </trans-unit>
        <trans-unit id="7f185bfe20f1f619f8c9bb6aa99786b71328866a" translate="yes" xml:space="preserve">
          <source>React 17 dev transform: &lt;code&gt;&quot;react-jsxdev&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d97070f74a67941c76e5ea64885d0e08627efa5" translate="yes" xml:space="preserve">
          <source>React 17 transform: &lt;code&gt;&quot;react-jsx&quot;&lt;/code&gt;&lt;sup&gt;&lt;a href=&quot;https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4b21d845bd34b4e6b6216731b5271028fb8f60" translate="yes" xml:space="preserve">
          <source>React Namespace - &lt;code&gt;reactNamespace&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee67e7a559cad7f7f0016ea4240d3102eab0e39c" translate="yes" xml:space="preserve">
          <source>React Native</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa58cb746f54f27aa90a8d689bba8023af13c2bb" translate="yes" xml:space="preserve">
          <source>React Native: &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">Реактивная интеграция</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">Конвейер сборки React-native ожидает, что все файлы будут иметь расширения &lt;code&gt;.js&lt;/code&gt; , даже если файл содержит синтаксис JSX. Новое значение &lt;code&gt;--jsx&lt;/code&gt; response &lt;code&gt;react-native&lt;/code&gt; сохранит синтаксис JSX в выходном файле, но даст ему расширение &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ab19aed84f407a0ba739f934e0edb923766280c" translate="yes" xml:space="preserve">
          <source>Read and understand commonly-used TypeScript syntax and patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">Прочтите любые файлы, которые он понимает, в каталоге &lt;code&gt;src&lt;/code&gt; (с &lt;code&gt;include&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bc4702822c3373e5ee67caa1dc26cc74db6df18f" translate="yes" xml:space="preserve">
          <source>Read the full Handbook &lt;a href=&quot;intro&quot;&gt;from start to finish&lt;/a&gt; (30m)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">Свойства и индексные подписи,доступные только для чтения</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">Свойства,доступные только для чтения,могут иметь инициализаторы и могут быть назначены в конструкторах в пределах одной декларации класса,но в противном случае назначение свойств,доступных только для чтения,запрещено.</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">Модификатор только для чтения</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">Свойства только для чтения</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">Готовы? Взгляни:</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">Однако настоящие приложения выглядят как &quot; &lt;code&gt;Readonly&lt;/code&gt; или &quot; &lt;code&gt;Partial&lt;/code&gt; выше. Они основаны на каком-то существующем типе и каким-то образом преобразуют свойства. Вот &lt;code&gt;keyof&lt;/code&gt; и пригодятся типы доступа keyof и indexed:</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">Вспомните,как написать типовое утверждение:</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">Напомним, что Node.js искал файл с именем &lt;code&gt;moduleB.js&lt;/code&gt; , затем подходящий &lt;code&gt;package.json&lt;/code&gt; , а затем &lt;code&gt;index.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">Напомним, что в нашем предыдущем примере с &lt;code&gt;setTimeout&lt;/code&gt; нам пришлось использовать IIFE для захвата состояния переменной для каждой итерации цикла &lt;code&gt;for&lt;/code&gt; . Фактически, мы создавали новую переменную среду для наших захваченных переменных. Это было немного больно, но, к счастью, вам больше никогда не придется делать это в TypeScript.</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="9ef937556efe782b8e9bf8ef16e540c185c5bf00" translate="yes" xml:space="preserve">
          <source>Recommended</source>
          <target state="translated">Recommended</target>
        </trans-unit>
        <trans-unit id="2d40a3d4b23c33dba91182fa7193e3bc8d084647" translate="yes" xml:space="preserve">
          <source>Recommended:</source>
          <target state="translated">Recommended:</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">Красные флаги</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">Красные флаги</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">Перенаправление выходной структуры в каталог.</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="f70cca9ad50ad5b8ed87a8010b088c10db5dda71" translate="yes" xml:space="preserve">
          <source>Reference Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">В ссылочных проектах должен быть включен новый &lt;code&gt;composite&lt;/code&gt; параметр. Этот параметр необходим для того, чтобы TypeScript мог быстро определить, где найти выходные данные проекта, на который имеется ссылка. Включение &lt;code&gt;composite&lt;/code&gt; флага меняет несколько вещей:</target>
        </trans-unit>
        <trans-unit id="4d6f89c160b09f2d6743dec6ea31f5aef184e7a5" translate="yes" xml:space="preserve">
          <source>References - &lt;code&gt;references&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7e105e2839b4e1b747e4c6dae363b4ac3c64d8" translate="yes" xml:space="preserve">
          <source>References to &lt;code&gt;const enum&lt;/code&gt; members</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">Обращение к объектам в пространстве значений как к типам не работает, если объект также не создает тип, например функцию конструктора.</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="af394298cb93f9a4ef6530d4f5256cfb8c8ddc2c" translate="yes" xml:space="preserve">
          <source>Reiterating &lt;a href=&quot;https://www.typescriptlang.org/handbook/basic-types.html&quot;&gt;Basic Types&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">Относительные пути довольно просты. В качестве примера рассмотрим файл, расположенный в &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; , который содержит import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js разрешает этот импорт в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">Относительный и нереляционный импорт модулей</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">Расслабляющие правила декларирования излучают видимость</target>
        </trans-unit>
        <trans-unit id="9811fea8059729e6e608294e42cacce36d4ff09d" translate="yes" xml:space="preserve">
          <source>Released:</source>
          <target state="translated">Released:</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">Помните, что мы упоминали ранее о захвате переменных? Каждое выражение функции, которое мы передаем в &lt;code&gt;setTimeout&lt;/code&gt; , фактически относится к одному &lt;code&gt;i&lt;/code&gt; тому же i из той же области.</target>
        </trans-unit>
        <trans-unit id="4ae2f2f99c6da082f0672c95b34c59cd80c40a24" translate="yes" xml:space="preserve">
          <source>Remove Comments - &lt;code&gt;removeComments&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">Удалите все комментарии, кроме комментариев заголовка с авторским правом, начинающихся с &lt;code&gt;/*!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">Удаляет параметр this из типа функции.</target>
        </trans-unit>
        <trans-unit id="d619a6862a4f7b32d4a58f285cc5c61b509d1673" translate="yes" xml:space="preserve">
          <source>Removes the &lt;a href=&quot;functions#this-parameters&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;/a&gt; parameter from &lt;code&gt;Type&lt;/code&gt;. If &lt;code&gt;Type&lt;/code&gt; has no explicitly declared &lt;code&gt;this&lt;/code&gt; parameter, the result is simply &lt;code&gt;Type&lt;/code&gt;. Otherwise, a new function type with no &lt;code&gt;this&lt;/code&gt; parameter is created from &lt;code&gt;Type&lt;/code&gt;. Generics are erased and only the last overload signature is propagated into the new function type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">Замените содержимое файла &lt;code&gt;tsconfig.json&lt;/code&gt; на:</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">Сообщить об ошибке,если не все кодовые пути в функции возвращают значение.</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">Сообщайте об ошибках для случаев падения в ведомости переключения.</target>
        </trans-unit>
        <trans-unit id="28ff576f8c9a47a52a73ccec4dfa5490f20abc5a" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statements. Ensures that any non-empty case inside a switch statement includes either &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;return&lt;/code&gt;. This means you won&amp;rsquo;t accidentally ship a case fallthrough bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">Сообщайте об ошибках в файлах &lt;code&gt;.js&lt;/code&gt; . Используйте вместе с &lt;code&gt;--allowJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9859c2bfd11829e29389ef6176aef839ff246a67" translate="yes" xml:space="preserve">
          <source>Report errors on unused local variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">Сообщайте об ошибках на неиспользуемых местных жителях.</target>
        </trans-unit>
        <trans-unit id="c070f2ba00c2432442f5870f3f9104c630e23e08" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters in functions.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
