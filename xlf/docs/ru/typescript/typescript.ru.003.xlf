<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">числовые разделители</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">Распространение и отдых объектов</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">Разрушение объекта</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">Буквы объекта открыты</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">Литералы объектов ведут себя так, как если бы у них была индексная подпись &lt;code&gt;[x:string]: any&lt;/code&gt; которая позволяет рассматривать их как открытые карты вместо закрытых объектов.</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">Остатки объектов - это двойные объекты разворотов, поскольку они могут извлекать любые дополнительные свойства, которые не используются при деструктуризации элемента:</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">У разброса объектов есть еще несколько удивительных ограничений. Во-первых, он включает только &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;собственные перечислимые свойства объекта&lt;/a&gt; . По сути, это означает, что вы теряете методы при распространении экземпляров объекта:</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">Объекты со свойствами</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">Конечно, любой из этих типов может быть объявлен с использованием синтаксиса &lt;code&gt;@typedef&lt;/code&gt; однострочном @typedef :</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">Конечно, поскольку это JavaScript, вы можете просто игнорировать конечные элементы, которые вам не нужны:</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">Конечно, это может показаться неправильным. Если вы откроете этот файл в редакторе с поддержкой TypeScript (или запустите &lt;code&gt;tsc --pretty&lt;/code&gt; ), вы можете увидеть красные волнистые линии на определенных строках. Вы должны думать об этом так же, как о красных волнистых линиях в редакторе, таком как Microsoft Word. TypeScript по-прежнему будет переводить ваш код, так же как Word по-прежнему позволяет печатать ваши документы.</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">Следует отметить, что только параметры и возвращаемый тип составляют тип функции. Захваченные переменные не отражаются в типе. Фактически, захваченные переменные являются частью &amp;laquo;скрытого состояния&amp;raquo; любой функции и не составляют ее API.</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">Официальный пакет TypeScript NuGet</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">Часто проект имеет несколько целей вывода, например, &lt;code&gt;ES5&lt;/code&gt; и &lt;code&gt;ES2015&lt;/code&gt; , отладка и производство или &lt;code&gt;CommonJS&lt;/code&gt; и &lt;code&gt;System&lt;/code&gt; ; Между этими двумя целями меняется всего несколько параметров конфигурации, и поддержка нескольких файлов &lt;code&gt;tsconfig.json&lt;/code&gt; может стать проблемой .</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">Часто в приложениях Node.js требуется &lt;code&gt;.json&lt;/code&gt; . В TypeScript 2.9 &lt;code&gt;--resolveJsonModule&lt;/code&gt; позволяет импортировать, извлекать типы и &lt;code&gt;.json&lt;/code&gt; файлы .json .</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">Часто модули расширяют другие модули,и частично раскрывают некоторые их возможности.Реэкспорт не импортирует его локально или не вводит локальную переменную.</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">Часто в вашем проекте есть внешние исходные файлы,которые не могут быть написаны в TypeScript.Альтернативно,вы можете быть в середине преобразования базы JS-кода в TS,но все еще хотите связать весь ваш JS-код в один файл с выводом вашего нового TS-кода.</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">Часто вам нужно расширить функциональность модуля. Распространенным шаблоном JS является расширение исходного объекта &lt;em&gt;расширениями&lt;/em&gt; , аналогично тому, как работают расширения JQuery. Как мы упоминали ранее, модули не &lt;em&gt;объединяются,&lt;/em&gt; как объекты глобального пространства имен. Рекомендуемое решение - &lt;em&gt;не&lt;/em&gt; изменять исходный объект, а скорее экспортировать новую сущность, которая предоставляет новые функции.</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
        <trans-unit id="a82c9a0a2eb97497a86656e3460a340f586d18ec" translate="yes" xml:space="preserve">
          <source>On a single line:</source>
          <target state="translated">На одной линии:</target>
        </trans-unit>
        <trans-unit id="82aef786e3f0d107d8d394b8c34887545af6ea56" translate="yes" xml:space="preserve">
          <source>On multiple lines:</source>
          <target state="translated">На нескольких линиях:</target>
        </trans-unit>
        <trans-unit id="74944d3dcee80b1604d42865751a7ceaa698e35d" translate="yes" xml:space="preserve">
          <source>On the last line of the snippet you can see that even assigning the entire &lt;code&gt;ReadonlyArray&lt;/code&gt; back to a normal array is illegal. You can still override it with a type assertion, though:</source>
          <target state="translated">В последней строке фрагмента вы можете видеть, что даже присвоение всего &lt;code&gt;ReadonlyArray&lt;/code&gt; обычному массиву является незаконным. Однако вы все равно можете переопределить его с помощью утверждения типа:</target>
        </trans-unit>
        <trans-unit id="50c6272b337ca96a2387d10cc66c11dc4b62bb58" translate="yes" xml:space="preserve">
          <source>On the organization front, namespaces are handy for grouping together logically-related objects and types in the global scope. For example, in C#, you&amp;rsquo;re going to find all the collection types in System.Collections. By organizing our types into hierarchical namespaces, we provide a good &amp;ldquo;discovery&amp;rdquo; experience for users of those types. Modules, on the other hand, are already present in a file system, necessarily. We have to resolve them by path and filename, so there&amp;rsquo;s a logical organization scheme for us to use. We can have a /collections/generic/ folder with a list module in it.</source>
          <target state="translated">Что касается организации, пространства имен удобны для группировки логически связанных объектов и типов в глобальной области. Например, в C # вы найдете все типы коллекций в System.Collections. Организуя наши типы в иерархические пространства имен, мы обеспечиваем хорошее &amp;laquo;обнаружение&amp;raquo; для пользователей этих типов. С другой стороны, модули обязательно уже присутствуют в файловой системе. Мы должны разрешить их по пути и имени файла, поэтому есть логическая схема организации, которую мы можем использовать. У нас может быть папка / collections / generic / со списком в ней.</target>
        </trans-unit>
        <trans-unit id="b64cb02da6becca0ce8ee30f0556e39a4da2ddd8" translate="yes" xml:space="preserve">
          <source>On the other hand, if you can&amp;rsquo;t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</source>
          <target state="translated">С другой стороны, если вы не можете выразить какую-либо форму с помощью интерфейса и вам нужно использовать тип объединения или кортежа, обычно можно использовать псевдонимы типов.</target>
        </trans-unit>
        <trans-unit id="c26cd5caaa2a12259da3b89ce4e19ad33c03509f" translate="yes" xml:space="preserve">
          <source>On the other hand, methods like &lt;code&gt;forEach&lt;/code&gt; will now be callable, but under &lt;code&gt;noImplicitAny&lt;/code&gt; there may be some issues.</source>
          <target state="translated">С другой стороны, теперь можно будет вызывать такие методы, как &lt;code&gt;forEach&lt;/code&gt; , но в &lt;code&gt;noImplicitAny&lt;/code&gt; могут возникнуть некоторые проблемы.</target>
        </trans-unit>
        <trans-unit id="5e243af120900864262b36ccd9ddf3da385c8c6b" translate="yes" xml:space="preserve">
          <source>Once defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.</source>
          <target state="translated">После определения,мы можем использовать этот интерфейс типа функции,как и другие интерфейсы.Здесь мы показываем,как можно создать переменную типа функции и присвоить ей значение этого же типа.</target>
        </trans-unit>
        <trans-unit id="92950c589178fe64abd972f4ad963eddae26cb96" translate="yes" xml:space="preserve">
          <source>Once the class type is established, the instance type is determined by the union of the return types of the class type&amp;rsquo;s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.</source>
          <target state="translated">После того, как тип класса установлен, тип экземпляра определяется объединением возвращаемых типов конструкции типа класса или сигнатур вызовов (в зависимости от того, что присутствует). Итак, опять же, в случае класса ES6 тип экземпляра будет типом экземпляра этого класса, а в случае фабричной функции это будет тип значения, возвращаемого функцией.</target>
        </trans-unit>
        <trans-unit id="b659e74e17ccfc36ea3671d29e4bcfb99bcddcac" translate="yes" xml:space="preserve">
          <source>Once there are multiple files involved, we&amp;rsquo;ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.</source>
          <target state="translated">Когда задействовано несколько файлов, нам нужно убедиться, что весь скомпилированный код загружен. Это можно сделать двумя способами.</target>
        </trans-unit>
        <trans-unit id="1344250aecff00dcfaf8dcd7ebd24a106e1cf310" translate="yes" xml:space="preserve">
          <source>Once we&amp;rsquo;ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</source>
          <target state="translated">После того, как мы написали универсальную функцию идентификации, мы можем вызвать ее одним из двух способов. Первый способ - передать функции все аргументы, включая аргумент типа:</target>
        </trans-unit>
        <trans-unit id="1f601e0447efc6c6f5c004e85bc2178722596428" translate="yes" xml:space="preserve">
          <source>One advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since &lt;code&gt;var&lt;/code&gt; declarations can&amp;rsquo;t merge with &lt;code&gt;namespace&lt;/code&gt;s).</source>
          <target state="translated">Одним из преимуществ этого является то, что шаблон вызываемого конструктора может быть легко выражен, а также позволяет пространствам имен объединяться с этими объявлениями (поскольку объявления &lt;code&gt;var&lt;/code&gt; не могут объединяться с &lt;code&gt;namespace&lt;/code&gt; s).</target>
        </trans-unit>
        <trans-unit id="07140e34d3c9cf651017285b583d3f868d3d8fae" translate="yes" xml:space="preserve">
          <source>One common task is to take an existing type and make each of its properties entirely optional. Let&amp;rsquo;s say we have a &lt;code&gt;Person&lt;/code&gt;:</source>
          <target state="translated">Одна из распространенных задач - взять существующий тип и сделать каждое из его свойств совершенно необязательным. Допустим, у нас есть &lt;code&gt;Person&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="11091369cf849b83900d010b927727e1dc480d7a" translate="yes" xml:space="preserve">
          <source>One difference from the prior example is that each derived class that contains a constructor function &lt;em&gt;must&lt;/em&gt; call &lt;code&gt;super()&lt;/code&gt; which will execute the constructor of the base class. What&amp;rsquo;s more, before we &lt;em&gt;ever&lt;/em&gt; access a property on &lt;code&gt;this&lt;/code&gt; in a constructor body, we &lt;em&gt;have&lt;/em&gt; to call &lt;code&gt;super()&lt;/code&gt;. This is an important rule that TypeScript will enforce.</source>
          <target state="translated">Одно отличие от предыдущего примера состоит в том, что каждый производный класс, содержащий функцию конструктора, &lt;em&gt;должен&lt;/em&gt; вызывать &lt;code&gt;super()&lt;/code&gt; который будет выполнять конструктор базового класса. Более того, прежде чем мы &lt;em&gt;когда-либо&lt;/em&gt; получим доступ к свойству &lt;code&gt;this&lt;/code&gt; в теле конструктора, мы &lt;em&gt;должны&lt;/em&gt; вызвать &lt;code&gt;super()&lt;/code&gt; . Это важное правило, которое TypeScript будет соблюдать.</target>
        </trans-unit>
        <trans-unit id="e676ef27b983655b305e7201bc44df325b250ac1" translate="yes" xml:space="preserve">
          <source>One difference is that interfaces create a new name that is used everywhere. Type aliases don&amp;rsquo;t create a new name &amp;mdash; for instance, error messages won&amp;rsquo;t use the alias name. In the code below, hovering over &lt;code&gt;interfaced&lt;/code&gt; in an editor will show that it returns an &lt;code&gt;Interface&lt;/code&gt;, but will show that &lt;code&gt;aliased&lt;/code&gt; returns object literal type.</source>
          <target state="translated">Одно отличие состоит в том, что интерфейсы создают новое имя, которое используется везде. Псевдонимы типа не создают новое имя - например, в сообщениях об ошибках не будет использоваться псевдоним. В приведенном ниже коде наведение курсора на &lt;code&gt;interfaced&lt;/code&gt; в редакторе покажет, что он возвращает &lt;code&gt;Interface&lt;/code&gt; , но покажет, что &lt;code&gt;aliased&lt;/code&gt; возвращает тип литерала объекта.</target>
        </trans-unit>
        <trans-unit id="4a3dab7aa9f91e5908fc981f84a1f4366d2c7377" translate="yes" xml:space="preserve">
          <source>One exception to this rule is specialized signatures. If a signature has a parameter whose type is a &lt;em&gt;single&lt;/em&gt; string literal type (e.g. not a union of string literals), then it will be bubbled toward the top of its merged overload list.</source>
          <target state="translated">Единственным исключением из этого правила являются специализированные подписи. Если в сигнатуре есть параметр, тип которого является &lt;em&gt;одним&lt;/em&gt; строковым литералом (например, не объединением строковых литералов), то он будет перемещаться в верхнюю часть своего объединенного списка перегрузки.</target>
        </trans-unit>
        <trans-unit id="344276576132d21b818f4ba76034843580074fbf" translate="yes" xml:space="preserve">
          <source>One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since &lt;code&gt;squareOptions&lt;/code&gt; won&amp;rsquo;t undergo excess property checks, the compiler won&amp;rsquo;t give you an error.</source>
          <target state="translated">Последний способ обойти эти проверки, который может быть немного удивительным, - это присвоить объект другой переменной: поскольку &lt;code&gt;squareOptions&lt;/code&gt; не будет подвергаться избыточным проверкам свойств, компилятор не выдаст вам ошибку.</target>
        </trans-unit>
        <trans-unit id="42cbeda6b484653b931fc5901c6ad7cbbe7d3da4" translate="yes" xml:space="preserve">
          <source>One great benefit of this is that you&amp;rsquo;ll see &lt;em&gt;way fewer&lt;/em&gt; implicit &lt;code&gt;any&lt;/code&gt; errors when running with &lt;code&gt;--noImplicitAny&lt;/code&gt;. Implicit &lt;code&gt;any&lt;/code&gt; errors are only reported when the compiler is unable to know the type of a variable without a type annotation.</source>
          <target state="translated">Одно большое преимущество в том , что вы будете видеть &lt;em&gt;путь меньше&lt;/em&gt; неявные &lt;code&gt;any&lt;/code&gt; ошибки при работе с &lt;code&gt;--noImplicitAny&lt;/code&gt; . Неявно &lt;code&gt;any&lt;/code&gt; ошибки сообщаются только в том случае, если компилятор не может узнать тип переменной без аннотации типа.</target>
        </trans-unit>
        <trans-unit id="0e93e8c643fb4e61579636fbf572b596e0286726" translate="yes" xml:space="preserve">
          <source>One important difference between ambient and non-ambient enums is that, in regular enums, members that don&amp;rsquo;t have an initializer will be considered constant if its preceding enum member is considered constant. In contrast, an ambient (and non-const) enum member that does not have initializer is &lt;em&gt;always&lt;/em&gt; considered computed.</source>
          <target state="translated">Одно из важных различий между внешними и внешними перечислениями заключается в том, что в обычных перечислениях члены, не имеющие инициализатора, будут считаться постоянными, если их предыдущий член перечисления считается постоянным. Напротив, внешний (и неконстантный) член перечисления, у которого нет инициализатора, &lt;em&gt;всегда&lt;/em&gt; считается вычисленным.</target>
        </trans-unit>
        <trans-unit id="82aa3486d66599c6818535555fcde271410599f0" translate="yes" xml:space="preserve">
          <source>One of TypeScript&amp;rsquo;s core principles is that type checking focuses on the &lt;em&gt;shape&lt;/em&gt; that values have. This is sometimes called &amp;ldquo;duck typing&amp;rdquo; or &amp;ldquo;structural subtyping&amp;rdquo;. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</source>
          <target state="translated">Один из основных принципов TypeScript заключается в том, что проверка типов фокусируется на &lt;em&gt;форме,&lt;/em&gt; которую имеют значения. Иногда это называют &amp;laquo;утиным типированием&amp;raquo; или &amp;laquo;структурным подтипом&amp;raquo;. В TypeScript интерфейсы выполняют роль именования этих типов и являются мощным способом определения контрактов в вашем коде, а также контрактов с кодом вне вашего проекта.</target>
        </trans-unit>
        <trans-unit id="5aea8e823173035ff216b848c6b0d54b8b96fd4c" translate="yes" xml:space="preserve">
          <source>One of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.</source>
          <target state="translated">Одно из наиболее распространённых использований интерфейсов в таких языках,как C#и Java,то есть явное принуждение класса к выполнению определённого контракта,также возможно и в TypeScript.</target>
        </trans-unit>
        <trans-unit id="bd4f8dfdb26e810e57f23fff74f292ac4a329c2e" translate="yes" xml:space="preserve">
          <source>One or more assignments to &lt;code&gt;window.someName&lt;/code&gt;</source>
          <target state="translated">Одно или несколько назначений &lt;code&gt;window.someName&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7eacbc50348f5b3ec9e3e6415d394dd711448525" translate="yes" xml:space="preserve">
          <source>One such example is an object that acts as both a function and an object, with additional properties:</source>
          <target state="translated">Одним из таких примеров является объект,который действует и как функция,и как объект,с дополнительными свойствами:</target>
        </trans-unit>
        <trans-unit id="10e4a65d9bb07088ca61418abc5f5490d598fa30" translate="yes" xml:space="preserve">
          <source>One thing to note is that &lt;code&gt;const&lt;/code&gt; assertions can only be applied immediately on simple literal expressions.</source>
          <target state="translated">Следует отметить, что &lt;code&gt;const&lt;/code&gt; утверждения можно сразу применить только к простым литеральным выражениям.</target>
        </trans-unit>
        <trans-unit id="165c72846ed1b6318be8972010ccbd2b184d8eb7" translate="yes" xml:space="preserve">
          <source>OneTwoThree.ts</source>
          <target state="translated">OneTwoThree.ts</target>
        </trans-unit>
        <trans-unit id="e8b21c7e76c250574a2ed991e3f5c20b47bb2111" translate="yes" xml:space="preserve">
          <source>Only emit &amp;lsquo;.d.ts&amp;rsquo; declaration files.</source>
          <target state="translated">Выдавать только файлы объявлений '.d.ts'.</target>
        </trans-unit>
        <trans-unit id="9c4c4f095c25b9e726d79098915a46e4ea92ff63" translate="yes" xml:space="preserve">
          <source>Open &lt;code&gt;greeter.html&lt;/code&gt; in the browser to run your first simple TypeScript web application!</source>
          <target state="translated">Откройте &lt;code&gt;greeter.html&lt;/code&gt; в браузере, чтобы запустить ваше первое простое веб-приложение TypeScript!</target>
        </trans-unit>
        <trans-unit id="e55b8e4dc396172c8a0dbddfe6ab0a7debd51fb3" translate="yes" xml:space="preserve">
          <source>Open &lt;strong&gt;Dependencies &amp;gt; Manage NuGet Packages &amp;gt; Browse.&lt;/strong&gt; Search and install &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;:</source>
          <target state="translated">Откройте &lt;strong&gt;зависимости&amp;gt; Управление пакетами NuGet&amp;gt; Обзор. &lt;/strong&gt;Найдите и установите &lt;code&gt;Microsoft.AspNetCore.StaticFiles&lt;/code&gt; и &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="064cf8a9bba6348e155ce9b3a0d85c1b0a8dcab6" translate="yes" xml:space="preserve">
          <source>Open up your &lt;code&gt;Startup.cs&lt;/code&gt; file and edit your &lt;code&gt;Configure&lt;/code&gt; function to look like this:</source>
          <target state="translated">Откройте файл &lt;code&gt;Startup.cs&lt;/code&gt; и отредактируйте функцию &lt;code&gt;Configure&lt;/code&gt; , чтобы она выглядела следующим образом:</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="e623b1194b11521281fe95cf75df232d30616550" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;--outDir&lt;/code&gt; duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.</source>
          <target state="translated">Опция &lt;code&gt;--outDir&lt;/code&gt; дублирует входную иерархию в выходной. Компилятор вычисляет корень входных файлов как самый длинный общий путь для всех входных файлов; а затем использует это для репликации всей своей подструктуры в выходных данных.</target>
        </trans-unit>
        <trans-unit id="02e5818137a6801351663f03a49db2886b267ce5" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;catch&lt;/code&gt; clause variables</source>
          <target state="translated">Необязательные переменные предложения &lt;code&gt;catch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1a89356c2e4a69562083736c16549a15a67afd8" translate="yes" xml:space="preserve">
          <source>Optional Chaining</source>
          <target state="translated">Дополнительная цепочка</target>
        </trans-unit>
        <trans-unit id="f7c6bcdff008088c9ae3335f40deda7169b35c83" translate="yes" xml:space="preserve">
          <source>Optional Module Loading and Other Advanced Loading Scenarios</source>
          <target state="translated">Дополнительные сценарии загрузки модулей и другие сценарии загрузки дополнительных модулей</target>
        </trans-unit>
        <trans-unit id="ccaa37d283bc30bfac0d5a680eadb38cfbad3c49" translate="yes" xml:space="preserve">
          <source>Optional Parameters and Rest Parameters</source>
          <target state="translated">Дополнительные параметры и параметры отдохновения</target>
        </trans-unit>
        <trans-unit id="b5c1d49a9a0ded62373bc3f019e8b6f2da7391b2" translate="yes" xml:space="preserve">
          <source>Optional Parameters in Callbacks</source>
          <target state="translated">Дополнительные параметры в обратных вызовах</target>
        </trans-unit>
        <trans-unit id="17315c7bb52dfa3c7be7c978a030acc2e38d91c1" translate="yes" xml:space="preserve">
          <source>Optional Properties</source>
          <target state="translated">Дополнительные свойства</target>
        </trans-unit>
        <trans-unit id="8daa3a8272df293fc9da3c3073a118094fb29854" translate="yes" xml:space="preserve">
          <source>Optional and Default Parameters</source>
          <target state="translated">Дополнительные параметры и параметры по умолчанию</target>
        </trans-unit>
        <trans-unit id="f4d845ae294ad2b99077aef2b25fd789eac70078" translate="yes" xml:space="preserve">
          <source>Optional chaining also includes two other operations. First there&amp;rsquo;s the &lt;em&gt;optional element access&lt;/em&gt; which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):</source>
          <target state="translated">Необязательная цепочка также включает две другие операции. Во-первых, есть &lt;em&gt;необязательный доступ к элементу,&lt;/em&gt; который действует аналогично &lt;em&gt;доступу&lt;/em&gt; к необязательному свойству, но позволяет нам получать доступ к свойствам, не являющимся идентификаторами (например, произвольным строкам, числам и символам):</target>
        </trans-unit>
        <trans-unit id="e5f644471c553673cd2548869c093cbfbd2425d1" translate="yes" xml:space="preserve">
          <source>Optional chaining is &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;issue #16&lt;/a&gt; on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.</source>
          <target state="translated">Необязательная цепочка - это &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/16&quot;&gt;проблема №16&lt;/a&gt; в нашем трекере проблем. Для контекста, с тех пор в системе отслеживания проблем TypeScript было зарегистрировано более 23 000 проблем.</target>
        </trans-unit>
        <trans-unit id="53581f6f206bad7094e8261bd030109f9d53f1b0" translate="yes" xml:space="preserve">
          <source>Optional class properties</source>
          <target state="translated">Дополнительные свойства класса</target>
        </trans-unit>
        <trans-unit id="d957ddf6e5b65d75752d19d7a9dab595722e5998" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types</source>
          <target state="translated">Дополнительные элементы в типах кортежей</target>
        </trans-unit>
        <trans-unit id="d86b65de7272239d11bfd100dd6563cfd8eb06e5" translate="yes" xml:space="preserve">
          <source>Optional elements in tuple types.</source>
          <target state="translated">Дополнительные элементы в типах кортежей.</target>
        </trans-unit>
        <trans-unit id="05631f6c888f7c7fded4cab4a643205c9c4a8938" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties</source>
          <target state="translated">Дополнительные параметры и свойства</target>
        </trans-unit>
        <trans-unit id="a160146910ad98552a493b375e35d6abcb550597" translate="yes" xml:space="preserve">
          <source>Optional parameters and properties automatically have &lt;code&gt;undefined&lt;/code&gt; added to their types, even when their type annotations don&amp;rsquo;t specifically include &lt;code&gt;undefined&lt;/code&gt;. For example, the following two types are identical:</source>
          <target state="translated">Дополнительные параметры и свойства автоматически были &lt;code&gt;undefined&lt;/code&gt; добавлены к типам, даже если их аннотации типов конкретно не включают &lt;code&gt;undefined&lt;/code&gt; . Например, следующие два типа идентичны:</target>
        </trans-unit>
        <trans-unit id="f00301f27003ef54c63e41fcdd1c3d98832e9617" translate="yes" xml:space="preserve">
          <source>Optional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.</source>
          <target state="translated">Дополнительные свойства и методы теперь могут быть объявлены в классах,аналогично тому,что уже разрешено в интерфейсах.</target>
        </trans-unit>
        <trans-unit id="c20ef3af584d28ff7405e7586b97956e1fd873af" translate="yes" xml:space="preserve">
          <source>Optional: Open &lt;code&gt;greeter.ts&lt;/code&gt; in Visual Studio, or copy the code into the TypeScript playground. You can hover over identifiers to see their types. Notice that in some cases these types are inferred automatically for you. Re-type the last line, and see completion lists and parameter help based on the types of the DOM elements. Put your cursor on the reference to the greeter function, and hit F12 to go to its definition. Notice, too, that you can right-click on a symbol and use refactoring to rename it.</source>
          <target state="translated">Необязательно: откройте &lt;code&gt;greeter.ts&lt;/code&gt; в Visual Studio или скопируйте код на площадку TypeScript. Вы можете навести указатель мыши на идентификаторы, чтобы увидеть их типы. Обратите внимание, что в некоторых случаях эти типы выводятся автоматически. Повторно введите последнюю строку и посмотрите списки завершения и справку по параметрам, основанные на типах элементов DOM. Наведите курсор на ссылку на функцию приветствия и нажмите F12, чтобы перейти к ее определению. Также обратите внимание, что вы можете щелкнуть правой кнопкой мыши по символу и использовать рефакторинг, чтобы переименовать его.</target>
        </trans-unit>
        <trans-unit id="591ef5ad63bd713e79f598100ad5e204c2091ef1" translate="yes" xml:space="preserve">
          <source>Optionally, a module can wrap one or more modules and combine all their exports using &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; syntax.</source>
          <target state="translated">При желании, модуль может обернуть один или несколько модулей и объединить все их экспорты с помощью синтаксиса &lt;code&gt;export * from &quot;module&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81b391e677894347f3d7eaa5c625ce0c39681863" translate="yes" xml:space="preserve">
          <source>Or ignore trailing elements, or other elements:</source>
          <target state="translated">Или проигнорируйте элементы &quot;следа&quot;,или другие элементы:</target>
        </trans-unit>
        <trans-unit id="107058d564aa8aab6bd22eaa786593d0b18cee3f" translate="yes" xml:space="preserve">
          <source>Or other elements:</source>
          <target state="translated">Или другие элементы:</target>
        </trans-unit>
        <trans-unit id="7896cec1b378bbc6409139052737322d415d7652" translate="yes" xml:space="preserve">
          <source>Or we might want a readonly version:</source>
          <target state="translated">Или нам может понадобиться версия только для чтения:</target>
        </trans-unit>
        <trans-unit id="6d64af183927ab37ad7e32252f098d1cc8ff662b" translate="yes" xml:space="preserve">
          <source>Or you can just use the unspecified &lt;code&gt;Function&lt;/code&gt; type:</source>
          <target state="translated">Или вы можете просто использовать неуказанный тип &lt;code&gt;Function&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f1ea4c6e412df1aa6cd8260f35271c01fcb8e8a0" translate="yes" xml:space="preserve">
          <source>Or, even manually set all the values in the enum:</source>
          <target state="translated">Или даже вручную установить все значения в перечислении:</target>
        </trans-unit>
        <trans-unit id="a7041e24ae17e49fcab38c7bb31f06d031308b3f" translate="yes" xml:space="preserve">
          <source>Or, we could describe the identity function using the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">Или мы могли бы описать функцию идентификации, используя &lt;code&gt;any&lt;/code&gt; тип:</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="bf83d365be04a72bc8a349cc7a86cd0845dccf80" translate="yes" xml:space="preserve">
          <source>Organizing Types</source>
          <target state="translated">Типы организации</target>
        </trans-unit>
        <trans-unit id="62510ab9b0c9768adbae646ef408d2a62b45617c" translate="yes" xml:space="preserve">
          <source>Other types from Closure also work:</source>
          <target state="translated">Другие типы от Closure также работают:</target>
        </trans-unit>
        <trans-unit id="6c40d3319358591a02a91d9e7d4783872ba163d5" translate="yes" xml:space="preserve">
          <source>Other variants are allowed as well:</source>
          <target state="translated">Допускаются и другие варианты:</target>
        </trans-unit>
        <trans-unit id="b3fdc1e6ff5294bca808cf4bfb8838d0fec37709" translate="yes" xml:space="preserve">
          <source>Otherwise use &lt;code&gt;--keyofStringsOnly&lt;/code&gt; compiler option to disable the new behavior.</source>
          <target state="translated">В противном случае используйте &lt;code&gt;--keyofStringsOnly&lt;/code&gt; компилятора --keyofStringsOnly, чтобы отключить новое поведение.</target>
        </trans-unit>
        <trans-unit id="7336f1cc92c408cb13dba362d46361683cd3d12c" translate="yes" xml:space="preserve">
          <source>Otherwise, the condition depends on one or more type variables and the conditional type is deferred.</source>
          <target state="translated">В противном случае условие зависит от одной или нескольких переменных типа,а условие является отложенным.</target>
        </trans-unit>
        <trans-unit id="9fd652f329cdb87b5184f532624c12babcba184a" translate="yes" xml:space="preserve">
          <source>Otherwise, we assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">В противном случае мы предполагаем, что вы уже используете &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; с &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="784cfa9d141a3fe82c06f16ad3a9456778056b89" translate="yes" xml:space="preserve">
          <source>Our First Interface</source>
          <target state="translated">Наш первый интерфейс</target>
        </trans-unit>
        <trans-unit id="59c2ed6506b42cf80836ee63241f17d49a77bfd7" translate="yes" xml:space="preserve">
          <source>Our package exposes declarations from each of those, so any user of our &lt;code&gt;browserify-typescript-extension&lt;/code&gt; package needs to have these dependencies as well. For that reason, we used &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; and not &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt;, because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used &lt;code&gt;devDependencies&lt;/code&gt;.</source>
          <target state="translated">В нашем пакете есть объявления каждого из них, поэтому любой пользователь нашего пакета &lt;code&gt;browserify-typescript-extension&lt;/code&gt; также должен иметь эти зависимости. По этой причине мы использовали &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; а не &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; , потому что в противном случае нашим потребителям пришлось бы вручную устанавливать эти пакеты. Если бы мы только что написали приложение командной строки и не ожидали, что наш пакет будет использоваться в качестве библиотеки, мы могли бы использовать &lt;code&gt;devDependencies&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="914f3908b7a344c5f4fb4fdf698695b9d2d20039" translate="yes" xml:space="preserve">
          <source>Output File Extension</source>
          <target state="translated">Расширение выходного файла</target>
        </trans-unit>
        <trans-unit id="b1a5505b0f802d6cf6a89204887e3eae4eb65f9a" translate="yes" xml:space="preserve">
          <source>Output directory for generated declaration files.</source>
          <target state="translated">Выходной каталог для сгенерированных файлов декларации.</target>
        </trans-unit>
        <trans-unit id="174bd26cf8c350d1ca94d82023ef88cff0353faa" translate="yes" xml:space="preserve">
          <source>Output generation</source>
          <target state="translated">Генерация выхода</target>
        </trans-unit>
        <trans-unit id="564d5d5acb36c72c6328a222a0d5721ff6fd4eb9" translate="yes" xml:space="preserve">
          <source>Outside of &lt;code&gt;.tsx&lt;/code&gt; files, the angle bracket assertion syntax can also be used.</source>
          <target state="translated">Вне &lt;code&gt;.tsx&lt;/code&gt; файлов, синтаксис утверждения скобки также может быть использован.</target>
        </trans-unit>
        <trans-unit id="fcc1811db5df29bd6fe9b10089bc778dd03521da" translate="yes" xml:space="preserve">
          <source>Overall Structure</source>
          <target state="translated">Общая структура</target>
        </trans-unit>
        <trans-unit id="0774d17a127371d4945391cdeb1d6747883f0446" translate="yes" xml:space="preserve">
          <source>Overloaded Function</source>
          <target state="translated">Перегруженная функция</target>
        </trans-unit>
        <trans-unit id="b8ed2ea3bd4ec728b7aa2051fa7a407dc7fb10f0" translate="yes" xml:space="preserve">
          <source>Overloaded Functions</source>
          <target state="translated">Перегруженные функции</target>
        </trans-unit>
        <trans-unit id="ec5878dd8d899636943fffee6342d476f6713cb3" translate="yes" xml:space="preserve">
          <source>Overloads</source>
          <target state="translated">Overloads</target>
        </trans-unit>
        <trans-unit id="cc20e1a304c06340ae63ba26a34364808dafd65d" translate="yes" xml:space="preserve">
          <source>Overloads and Callbacks</source>
          <target state="translated">Перегрузки и обратные вызовы</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="0577f98176563373436836dd571634165655bf7e" translate="yes" xml:space="preserve">
          <source>Packages under the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt; organization are published automatically from &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;DefinitelyTyped&lt;/a&gt; using the &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;types-publisher tool&lt;/a&gt;. To get your declarations published as an @types package, please submit a pull request to &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;https://github.com/DefinitelyTyped/DefinitelyTyped&lt;/a&gt;. You can find more details in the &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt;.</source>
          <target state="translated">Пакеты в &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;рамках&lt;/a&gt; организации @types публикуются автоматически из &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;Определенного &lt;/a&gt;Типа с помощью &lt;a href=&quot;https://github.com/Microsoft/types-publisher&quot;&gt;инструмента публикации типов&lt;/a&gt; . Чтобы опубликовать свои объявления в виде пакета @types, отправьте запрос на перенос по &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped&quot;&gt;адресу https://github.com/DefinitiTyped/DefinitiTyped&lt;/a&gt; . Вы можете найти более подробную информацию на &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;странице с рекомендациями&lt;/a&gt; по взносам .</target>
        </trans-unit>
        <trans-unit id="6c05990a1953dff830b4e694fd34e78ad2c4e758" translate="yes" xml:space="preserve">
          <source>Packaging dependent declarations</source>
          <target state="translated">Упаковочные декларации</target>
        </trans-unit>
        <trans-unit id="f6dd7817ec1cd36abd644cfdc46d670053a1cd83" translate="yes" xml:space="preserve">
          <source>Parameter Decorators</source>
          <target state="translated">Параметры Декораторы</target>
        </trans-unit>
        <trans-unit id="2952d35fe7891ee81c4489bd1bb320a48758d659" translate="yes" xml:space="preserve">
          <source>Parameter properties</source>
          <target state="translated">Свойства параметров</target>
        </trans-unit>
        <trans-unit id="23d76447f27a661de3ededbf433067f3b57aada4" translate="yes" xml:space="preserve">
          <source>Parameter properties are declared by prefixing a constructor parameter with an accessibility modifier or &lt;code&gt;readonly&lt;/code&gt;, or both. Using &lt;code&gt;private&lt;/code&gt; for a parameter property declares and initializes a private member; likewise, the same is done for &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;protected&lt;/code&gt;, and &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">Свойства параметра объявляются с помощью префикса параметра конструктора с помощью модификатора доступности или только для &lt;code&gt;readonly&lt;/code&gt; , или того и другого. Использование &lt;code&gt;private&lt;/code&gt; для свойства параметра объявляет и инициализирует частный член; аналогично то же самое сделано для &lt;code&gt;public&lt;/code&gt; , &lt;code&gt;protected&lt;/code&gt; и только для &lt;code&gt;readonly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5861a8dac7bb4d916bedc720f28896beb64d2da" translate="yes" xml:space="preserve">
          <source>Parameters declaration with names starting with &lt;code&gt;_&lt;/code&gt; are exempt from the unused parameter checking. e.g.:</source>
          <target state="translated">Объявление параметров с именами, начинающимися с &lt;code&gt;_&lt;/code&gt; , не подлежит проверке неиспользуемых параметров. например:</target>
        </trans-unit>
        <trans-unit id="1d5eb18b61aab05bdced59d235a80d553895747d" translate="yes" xml:space="preserve">
          <source>Parameters&amp;lt;T&amp;gt;</source>
          <target state="translated">Parameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="671f3fae2448bb236314a1b80701d38996bd864d" translate="yes" xml:space="preserve">
          <source>Parse in strict mode and emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; for each source file</source>
          <target state="translated">Выполните синтаксический анализ в строгом режиме и выдайте &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; для каждого исходного файла</target>
        </trans-unit>
        <trans-unit id="fb8f88af978dfcbfd9d18606d5785e56e50c08a4" translate="yes" xml:space="preserve">
          <source>ParseIntBasedZipCodeValidator.ts</source>
          <target state="translated">ParseIntBasedZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="81409c19eb37440fe5909d317bb07700285e2cd5" translate="yes" xml:space="preserve">
          <source>Parses all the code in strict mode.</source>
          <target state="translated">Разбирает весь код в строгом режиме.</target>
        </trans-unit>
        <trans-unit id="f6713be85ff8a869b13ef23f83e9e25ec5b50fe4" translate="yes" xml:space="preserve">
          <source>Part of the intent with composite projects (&lt;code&gt;tsconfig.json&lt;/code&gt;s with &lt;code&gt;composite&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;) is that references between different projects can be built incrementally. As such, composite projects will &lt;strong&gt;always&lt;/strong&gt; produce &lt;code&gt;.tsbuildinfo&lt;/code&gt; files.</source>
          <target state="translated">Частично намерение составных проектов ( &lt;code&gt;tsconfig.json&lt;/code&gt; s с &lt;code&gt;composite&lt;/code&gt; значением &lt;code&gt;true&lt;/code&gt; ) состоит в том, что ссылки между различными проектами могут создаваться постепенно. Таким образом, составные проекты &lt;strong&gt;всегда&lt;/strong&gt; будут создавать файлы &lt;code&gt;.tsbuildinfo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9baf9fd34f2159270424fe0e47e69d1f478939e6" translate="yes" xml:space="preserve">
          <source>Partial&amp;lt;T&amp;gt;</source>
          <target state="translated">Partial&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1acacf2ed7601dbe25241b7869667be2f4398d94" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; along with &lt;code&gt;--jsx react&lt;/code&gt; allows for using a different JSX factory from the default &lt;code&gt;React&lt;/code&gt;.</source>
          <target state="translated">Передача &lt;code&gt;--reactNamespace &amp;lt;JSX factory Name&amp;gt;&lt;/code&gt; вместе с &lt;code&gt;--jsx react&lt;/code&gt; позволяет использовать другую фабрику JSX из &lt;code&gt;React&lt;/code&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="3b536ca4bd24891bd16797247b74cf70cb1d7af1" translate="yes" xml:space="preserve">
          <source>Path mapping</source>
          <target state="translated">Картирование маршрутов</target>
        </trans-unit>
        <trans-unit id="08f69b52b9788ae6bcf8bfd7c8d5cd0f9c96b35d" translate="yes" xml:space="preserve">
          <source>Patterns that are known NOT to be supported</source>
          <target state="translated">Шаблоны,которые,как известно,НЕ поддерживаются.</target>
        </trans-unit>
        <trans-unit id="3ba5e04e0fb30f6bbbfe6f30b3c6d01934f1ea14" translate="yes" xml:space="preserve">
          <source>Per-file JSX factories</source>
          <target state="translated">Заказные заводы JSX</target>
        </trans-unit>
        <trans-unit id="b69b8b40e240a5b2dde72c51f503be50a498cd27" translate="yes" xml:space="preserve">
          <source>Perform additional checks to ensure that separate compilation (such as with &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt;&lt;code&gt;transpileModule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@babel/plugin-transform-typescript&lt;/a&gt;) would be safe.</source>
          <target state="translated">Выполните дополнительные проверки, чтобы убедиться, что отдельная компиляция (например, с &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function&quot;&gt; &lt;code&gt;transpileModule&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-typescript&quot;&gt;@ babel / plugin-transform-typescript&lt;/a&gt; ) будет безопасной.</target>
        </trans-unit>
        <trans-unit id="f1dabf49a10166e79b1f29fd393e4de4f943c1fd" translate="yes" xml:space="preserve">
          <source>Performance Improvements</source>
          <target state="translated">Повышение эффективности</target>
        </trans-unit>
        <trans-unit id="967f5cced0c55dd5104813d8b961e3e82073447f" translate="yes" xml:space="preserve">
          <source>Pick&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Pick&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7dee95ba04b4d77fd014972959587737b540740a" translate="yes" xml:space="preserve">
          <source>Pitfalls of Namespaces and Modules</source>
          <target state="translated">Питфоллы пространств имен и модулей</target>
        </trans-unit>
        <trans-unit id="a68eb230823a2defe94e6d3f9718ef2ec069c259" translate="yes" xml:space="preserve">
          <source>Playground</source>
          <target state="translated">Playground</target>
        </trans-unit>
        <trans-unit id="120335d270554865b243af6b51ed8c05b0d29c22" translate="yes" xml:space="preserve">
          <source>Please note that the compiler does not include files that can be possible outputs; e.g. if the input includes &lt;code&gt;index.ts&lt;/code&gt;, then &lt;code&gt;index.d.ts&lt;/code&gt; and &lt;code&gt;index.js&lt;/code&gt; are excluded. In general, having files that differ only in extension next to each other is not recommended.</source>
          <target state="translated">Обратите внимание, что компилятор не включает файлы, которые могут быть возможными выходами; например, если входные данные включают &lt;code&gt;index.ts&lt;/code&gt; , то &lt;code&gt;index.d.ts&lt;/code&gt; и &lt;code&gt;index.js&lt;/code&gt; исключаются. Как правило, не рекомендуется размещать рядом друг с другом файлы, различающиеся только расширением.</target>
        </trans-unit>
        <trans-unit id="4463cb7b6e22fa9c87c1b09f8e8ea07ce2c6475b" translate="yes" xml:space="preserve">
          <source>Please note that this comment only suppresses the error reporting, and we recommend you use this comments &lt;em&gt;very sparingly&lt;/em&gt;.</source>
          <target state="translated">Обратите внимание, что этот комментарий только подавляет сообщения об ошибках, и мы рекомендуем вам использовать его &lt;em&gt;очень осторожно&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0468af199e7e628b9833d4c2499a87be9fef2421" translate="yes" xml:space="preserve">
          <source>Please note that this requires a native &lt;code&gt;Symbol.iterator&lt;/code&gt; or &lt;code&gt;Symbol.iterator&lt;/code&gt; shim at runtime for any non-array values.</source>
          <target state="translated">Обратите внимание, что для этого требуется встроенная &lt;code&gt;Symbol.iterator&lt;/code&gt; или &lt;code&gt;Symbol.iterator&lt;/code&gt; во время выполнения для любых значений, не являющихся массивами.</target>
        </trans-unit>
        <trans-unit id="562837321f7a755d6cd24864fe1ca99abed6c53c" translate="yes" xml:space="preserve">
          <source>Please note that ts-loader is not the only loader for typescript.</source>
          <target state="translated">Обратите внимание,что ts-loader не единственный загрузчик для typcript.</target>
        </trans-unit>
        <trans-unit id="e4743356c30ff06ccc2c2b0526d63f34b220283d" translate="yes" xml:space="preserve">
          <source>Please notice that &lt;code&gt;&quot;paths&quot;&lt;/code&gt; are resolved relative to &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt;. When setting &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; to another value than &lt;code&gt;&quot;.&quot;&lt;/code&gt;, i.e. the directory of &lt;code&gt;tsconfig.json&lt;/code&gt;, the mappings must be changed accordingly. Say, you set &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; in the above example, then jquery should be mapped to &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;&quot;paths&quot;&lt;/code&gt; разрешаются относительно &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; . При установке для &lt;code&gt;&quot;baseUrl&quot;&lt;/code&gt; значения, отличного от &lt;code&gt;&quot;.&quot;&lt;/code&gt; , т.е. каталог &lt;code&gt;tsconfig.json&lt;/code&gt; , сопоставления должны быть соответственно изменены. Скажем, вы установили &lt;code&gt;&quot;baseUrl&quot;: &quot;./src&quot;&lt;/code&gt; в приведенном выше примере, тогда jquery должен быть сопоставлен с &lt;code&gt;&quot;../node_modules/jquery/dist/jquery&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ead1b84f2b03206f8601dd6f8465bb1307c87f49" translate="yes" xml:space="preserve">
          <source>Polymorphic &lt;code&gt;this&lt;/code&gt; types</source>
          <target state="translated">Полиморфные &lt;code&gt;this&lt;/code&gt; типы</target>
        </trans-unit>
        <trans-unit id="b7ea292a6c4159dcd9f22585ce812663d7d16f67" translate="yes" xml:space="preserve">
          <source>Polymorphic this types</source>
          <target state="translated">Полиморфный этот тип</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">Возможные значения:</target>
        </trans-unit>
        <trans-unit id="554e31701ddcf7160047ee9c5af3bc8fa8c6a72a" translate="yes" xml:space="preserve">
          <source>Postfix equals on a property type in an object literal type doesn&amp;rsquo;t specify an optional property:</source>
          <target state="translated">Postfix equals для типа свойства в типе литерала объекта не указывает необязательное свойство:</target>
        </trans-unit>
        <trans-unit id="ab664bc802e07259299c0ace87c0d6fb9adaa06b" translate="yes" xml:space="preserve">
          <source>Predefined conditional types</source>
          <target state="translated">Предопределенные условные типы</target>
        </trans-unit>
        <trans-unit id="0ca66f1be438badc25b8b5752ef03c58e504484d" translate="yes" xml:space="preserve">
          <source>Prepending a project will include the project&amp;rsquo;s output above the output of the current project. This works for both &lt;code&gt;.js&lt;/code&gt; files and &lt;code&gt;.d.ts&lt;/code&gt; files, and source map files will also be emitted correctly.</source>
          <target state="translated">Подготовка проекта будет включать выходные данные проекта выше выходных данных текущего проекта. Это работает как для файлов &lt;code&gt;.js&lt;/code&gt; ,так и &lt;code&gt;.d.ts&lt;/code&gt; файлов .d.ts , и файлы исходных карт также будут отправлены правильно.</target>
        </trans-unit>
        <trans-unit id="250b55e25eefbff70773c9389bd85b37a64c1d61" translate="yes" xml:space="preserve">
          <source>Preprocessing input files</source>
          <target state="translated">Препроцессирование входных файлов</target>
        </trans-unit>
        <trans-unit id="7cb4715a3e34715298728de107fabd8f250241bb" translate="yes" xml:space="preserve">
          <source>Prettier &lt;code&gt;--pretty&lt;/code&gt; output</source>
          <target state="translated">Хорошеет &lt;code&gt;--pretty&lt;/code&gt; выход</target>
        </trans-unit>
        <trans-unit id="8875ea5f28b04a1dba3fc41f80791c76ff0b7712" translate="yes" xml:space="preserve">
          <source>Prettier error messages from &lt;code&gt;tsc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; сообщения об ошибках от tsc</target>
        </trans-unit>
        <trans-unit id="0b0889dea75b7bf162c4dd45848c6ca53d9ef522" translate="yes" xml:space="preserve">
          <source>Preventing Name Conflicts</source>
          <target state="translated">Предотвращение именных конфликтов</target>
        </trans-unit>
        <trans-unit id="d3f367a0268c7a11de846832dd78b1be0177bcf5" translate="yes" xml:space="preserve">
          <source>Previously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:</source>
          <target state="translated">Ранее модули CommonJS/AMD/UMD обрабатывались так же,как и модули ES6,что привело к паре проблем.А именно:</target>
        </trans-unit>
        <trans-unit id="1d4fe4dbc591edaa8152b6ee157716dc7c7a69dd" translate="yes" xml:space="preserve">
          <source>Previously an error, now supported in TypeScript 1.8. &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; declarations within loops and captured in functions are now emitted to correctly match &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; freshness semantics.</source>
          <target state="translated">Ранее ошибка, теперь поддерживается в TypeScript 1.8. Объявления &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; внутри циклов и захваченные в функциях теперь генерируются для правильного соответствия семантике свежести &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61f97a853643acc2132dd407bb52c28293cf6e2" translate="yes" xml:space="preserve">
          <source>Previously flagged as an invalid flag combination, &lt;code&gt;target: es5&lt;/code&gt; and &amp;lsquo;module: es6&amp;rsquo; is now supported. This should facilitate using ES2015-based tree shakers like &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;rollup&lt;/a&gt;.</source>
          <target state="translated">Ранее помеченная как недопустимая комбинация флагов, теперь поддерживается &lt;code&gt;target: es5&lt;/code&gt; и 'module: es6'. Это должно облегчить использование встряхивателей деревьев на основе ES2015, таких как &lt;a href=&quot;https://github.com/rollup/rollup&quot;&gt;свертка&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="faa74f7ad7771f21799b2755f15db749aa0b46e9" translate="yes" xml:space="preserve">
          <source>Previously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. &lt;code&gt;for..of&lt;/code&gt; were only supported if they operate on arrays for targets below ES6/ES2015.</source>
          <target state="translated">Ранее генераторы поддерживались только в том случае, если целью является ES6 / ES2015 или новее. Более того, конструкции, работающие по протоколу Iterator, например &lt;code&gt;for..of&lt;/code&gt; , поддерживались только в том случае, если они работают с массивами для целей ниже ES6 / ES2015.</target>
        </trans-unit>
        <trans-unit id="8d6c2a15e3d095aa407d66625a136a8551aa98ed" translate="yes" xml:space="preserve">
          <source>Previously the type of a &lt;code&gt;for..in&lt;/code&gt; variable is inferred to &lt;code&gt;any&lt;/code&gt;; that allowed the compiler to ignore invalid uses within the &lt;code&gt;for..in&lt;/code&gt; body.</source>
          <target state="translated">Ранее тип переменной &lt;code&gt;for..in&lt;/code&gt; определялся как &lt;code&gt;any&lt;/code&gt; ; это позволило компилятору игнорировать недопустимые использования в теле &lt;code&gt;for..in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebaf09b657b780c25626ff17cb194ecb5fc7de40" translate="yes" xml:space="preserve">
          <source>Previously there were two options:</source>
          <target state="translated">Раньше было два варианта:</target>
        </trans-unit>
        <trans-unit id="23e202efb0fd224642346517ba263b85cbcde129" translate="yes" xml:space="preserve">
          <source>Previously type &lt;code&gt;{}&lt;/code&gt; was inferred for &lt;code&gt;obj&lt;/code&gt; and the second line subsequently caused an error because &lt;code&gt;obj&lt;/code&gt; would appear to have no properties. That obviously wasn&amp;rsquo;t ideal.</source>
          <target state="translated">Раньше для &lt;code&gt;obj&lt;/code&gt; предполагался тип &lt;code&gt;{}&lt;/code&gt; , и вторая строка впоследствии вызвала ошибку, поскольку казалось, что &lt;code&gt;obj&lt;/code&gt; не имеет свойств. Это явно было не идеально.</target>
        </trans-unit>
        <trans-unit id="6904fbec6e39643bc5d34a20c1cf3e6eba117f94" translate="yes" xml:space="preserve">
          <source>Previously, a non-disciminated union wouldn&amp;rsquo;t have &lt;em&gt;any&lt;/em&gt; excess property checking done on its members, and as a result, the incorrectly typed &lt;code&gt;name&lt;/code&gt; property slipped by.</source>
          <target state="translated">Раньше для неискаженного объединения не было &lt;em&gt;бы&lt;/em&gt; лишних проверок свойств для его членов, и в результате неправильно набранное свойство &lt;code&gt;name&lt;/code&gt; пропускалось.</target>
        </trans-unit>
        <trans-unit id="b72465fae7e40823511074b9719794d968033526" translate="yes" xml:space="preserve">
          <source>Previously, if TypeScript couldn&amp;rsquo;t figure out the type of a variable, it would choose the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Раньше, если TypeScript не мог определить тип переменной, он выбирал &lt;code&gt;any&lt;/code&gt; тип.</target>
        </trans-unit>
        <trans-unit id="9db6c336a1faa6c435e85a6b4d2c798009098564" translate="yes" xml:space="preserve">
          <source>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</source>
          <target state="translated">Раньше с такой структурой было довольно неудобно работать,если вы использовали один tsconfig файл:</target>
        </trans-unit>
        <trans-unit id="4ca4680280d5d8dfe7b7cb9edd9e85d1751a8dc5" translate="yes" xml:space="preserve">
          <source>Print help message.</source>
          <target state="translated">Распечатайте справочное сообщение.</target>
        </trans-unit>
        <trans-unit id="ae5d509d63bcd9fdd20c4fe9f09a64383b22ba2a" translate="yes" xml:space="preserve">
          <source>Print names of files part of the compilation.</source>
          <target state="translated">Печать имен файлов,входящих в состав компиляции.</target>
        </trans-unit>
        <trans-unit id="220c873ce1ef6bbe0f0ef43fc4cd6015a80b747a" translate="yes" xml:space="preserve">
          <source>Print names of generated files part of the compilation.</source>
          <target state="translated">Печатайте имена сгенерированных файлов,входящих в состав компиляции.</target>
        </trans-unit>
        <trans-unit id="e11fa3aee584489ac6535e0339f143acea43fb5c" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s version.</source>
          <target state="translated">Вывести версию компилятора.</target>
        </trans-unit>
        <trans-unit id="23bb025493ad52ae749fb36ab7d38c5792fcafeb" translate="yes" xml:space="preserve">
          <source>Prior to 3.3, building composite projects using &lt;code&gt;--build --watch&lt;/code&gt; actually didn&amp;rsquo;t use this incremental file watching infrastructure. An update in one project under &lt;code&gt;--build --watch&lt;/code&gt; mode would force a full build of that project, rather than determining which files within that project were affected.</source>
          <target state="translated">До версии 3.3 при сборке составных проектов с использованием &lt;code&gt;--build --watch&lt;/code&gt; эта инфраструктура инкрементного отслеживания файлов фактически не использовалась. Обновление в одном проекте в режиме &lt;code&gt;--build --watch&lt;/code&gt; вызовет полную сборку этого проекта, а не определяет, какие файлы в этом проекте были затронуты.</target>
        </trans-unit>
        <trans-unit id="6a5128736476603248154c428e88c700f0590e6b" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, in the following example</source>
          <target state="translated">До TypeScript 2.4,в следующем примере</target>
        </trans-unit>
        <trans-unit id="480d4967754d83dbb3e8d2828c5c21cd16621298" translate="yes" xml:space="preserve">
          <source>Prior to TypeScript 2.4, this example would succeed. When relating the types of &lt;code&gt;map&lt;/code&gt;, TypeScript would bidirectionally relate their parameters (i.e. the type of &lt;code&gt;f&lt;/code&gt;). When relating each &lt;code&gt;f&lt;/code&gt;, TypeScript would also bidirectionally relate the type of &lt;em&gt;those&lt;/em&gt; parameters.</source>
          <target state="translated">До TypeScript 2.4 этот пример был успешным. При связывании типов &lt;code&gt;map&lt;/code&gt; TypeScript будет двунаправленно связывать их параметры (то есть тип &lt;code&gt;f&lt;/code&gt; ). При связывании каждого &lt;code&gt;f&lt;/code&gt; TypeScript также будет двунаправленно связывать тип &lt;em&gt;этих&lt;/em&gt; параметров.</target>
        </trans-unit>
        <trans-unit id="d2ca142f68efb0104a146fa7d73e2068d50895f3" translate="yes" xml:space="preserve">
          <source>Private and Protected Constructors</source>
          <target state="translated">Частные и охраняемые строители</target>
        </trans-unit>
        <trans-unit id="f4b81a5cab787b4701243c836cb9e4bed8b1e31d" translate="yes" xml:space="preserve">
          <source>Private and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but &lt;em&gt;not&lt;/em&gt; with classes from a different inheritance hierarchy which otherwise have the same shape.</source>
          <target state="translated">Частные и защищенные члены в классе влияют на их совместимость. Когда экземпляр класса проверяется на совместимость, если целевой тип содержит закрытый член, тогда исходный тип также должен содержать закрытый член, происходящий из того же класса. Точно так же то же самое применимо к экземпляру с защищенным членом. Это позволяет классу быть совместимым по назначению со своим суперклассом, но &lt;em&gt;не&lt;/em&gt; с классами из другой иерархии наследования, которые в остальном имеют ту же форму.</target>
        </trans-unit>
        <trans-unit id="e91301edc2c04ca7b2fe236a0af7531759595434" translate="yes" xml:space="preserve">
          <source>Private and protected members in classes</source>
          <target state="translated">Частные и защищенные члены в классах</target>
        </trans-unit>
        <trans-unit id="15fd0634ed725b1581380519d93db35711d918e3" translate="yes" xml:space="preserve">
          <source>ProgrammerCalculator.ts</source>
          <target state="translated">ProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="567585a6d21c8b924898dbfb1c1f5b51255b4838" translate="yes" xml:space="preserve">
          <source>Project Configuration</source>
          <target state="translated">Конфигурация проекта</target>
        </trans-unit>
        <trans-unit id="7793a73613168871bf96397b630c7423c4486ca5" translate="yes" xml:space="preserve">
          <source>Project References</source>
          <target state="translated">Ссылки на проект</target>
        </trans-unit>
        <trans-unit id="88f5397c06a7b7e37512d16b9ab11703488d260e" translate="yes" xml:space="preserve">
          <source>Project References: Build Mode for TypeScript</source>
          <target state="translated">Ссылки на проект:Режим построения для TypeScript</target>
        </trans-unit>
        <trans-unit id="754b3c7e71d4817f7d2fea3c257de1bdf3f58125" translate="yes" xml:space="preserve">
          <source>Project References: Caveats</source>
          <target state="translated">Ссылки на проект:Caveats</target>
        </trans-unit>
        <trans-unit id="f6929baa8a0f682ca9e2d3784d0cff5d27cdab03" translate="yes" xml:space="preserve">
          <source>Project References: Caveats for Project References</source>
          <target state="translated">Ссылки на проект:Справочные материалы по проектам</target>
        </trans-unit>
        <trans-unit id="d0bd4d6b0aa124935089e5a1a6357f47ce88863d" translate="yes" xml:space="preserve">
          <source>Project References: MSBuild</source>
          <target state="translated">Ссылки на проект:MSBuild</target>
        </trans-unit>
        <trans-unit id="2d88f084a46bb059f7acb5d62832e90394777d3f" translate="yes" xml:space="preserve">
          <source>Project References: Overall Structure</source>
          <target state="translated">Ссылки на проект:Общая структура</target>
        </trans-unit>
        <trans-unit id="a0c2677e3090197b68e74d61303c68e7ddf04e66" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for outFiles</source>
          <target state="translated">Ссылки на проект:Структурирование для outFiles</target>
        </trans-unit>
        <trans-unit id="810687c4e3229aa8caaccaa1985884772dfd3c9a" translate="yes" xml:space="preserve">
          <source>Project References: Structuring for relative modules</source>
          <target state="translated">Ссылки на проект:Структурирование для относительных модулей</target>
        </trans-unit>
        <trans-unit id="692d23787c48f3266c6f90679b8a1de2796d67f6" translate="yes" xml:space="preserve">
          <source>Project References: What is a Project Reference?</source>
          <target state="translated">Ссылки на проект:Что такое ссылка на проект?</target>
        </trans-unit>
        <trans-unit id="394f18fdbb76c8acbdccddfc544deb4de35c052d" translate="yes" xml:space="preserve">
          <source>Project References: composite</source>
          <target state="translated">Ссылки на проект:композитный</target>
        </trans-unit>
        <trans-unit id="6d41bc9c0f6a331071fce870316ec281371a0d75" translate="yes" xml:space="preserve">
          <source>Project References: declarationMaps</source>
          <target state="translated">Ссылки на проект:декларацияКарты</target>
        </trans-unit>
        <trans-unit id="908cd420bcb700a967b280f8a7dff581392527b2" translate="yes" xml:space="preserve">
          <source>Project References: prepend with outFile</source>
          <target state="translated">Ссылки на проект:предоплата с помощью outFile</target>
        </trans-unit>
        <trans-unit id="64e335b1c5f861587f8782361a5af32ae20dcd21" translate="yes" xml:space="preserve">
          <source>Project References: tsc -b Commandline</source>
          <target state="translated">Ссылки на проект:tsc -b Командная строка</target>
        </trans-unit>
        <trans-unit id="fd7a6c05d7b3d7052f1c042cfc959322d90b11a4" translate="yes" xml:space="preserve">
          <source>Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</source>
          <target state="translated">Ссылки на проекты-это новая возможность в TypeScript 3.0,которая позволяет структурировать ваши программы TypeScript на более мелкие части.</target>
        </trans-unit>
        <trans-unit id="4c6c967b1595e112d0adf09d5676eb35634edcb7" translate="yes" xml:space="preserve">
          <source>Project references can solve all of these problems and more.</source>
          <target state="translated">Ссылки на проекты могут решить все эти проблемы и многое другое.</target>
        </trans-unit>
        <trans-unit id="1b126f1d1bec5fc383003c78a666ee84f0286aac" translate="yes" xml:space="preserve">
          <source>Project references have a few trade-offs you should be aware of.</source>
          <target state="translated">Ссылки на проекты имеют несколько компромиссов,о которых вам следует знать.</target>
        </trans-unit>
        <trans-unit id="d846e8e5c61d018f2fdaece28ac3df9b54800862" translate="yes" xml:space="preserve">
          <source>Project support through &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">Поддержка проекта через &lt;code&gt;tsconfig.json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d66fcc6f48609ad7f0ccc3524762b07b0fb5050" translate="yes" xml:space="preserve">
          <source>Properties are inferred from assignments in class bodies</source>
          <target state="translated">Свойства выводятся из назначений в телах классов</target>
        </trans-unit>
        <trans-unit id="33bbcb8beed2dadd8ed7e8a6d283214d6efdf708" translate="yes" xml:space="preserve">
          <source>Properties declarations on functions</source>
          <target state="translated">Декларации о свойствах функций</target>
        </trans-unit>
        <trans-unit id="2e110b7b4893d92d3e7aa88aa3a301b45ead4967" translate="yes" xml:space="preserve">
          <source>Properties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.</source>
          <target state="translated">Свойства в шаблоне объектной привязки,не имеющие совпадения в литерале объекта,должны иметь значение по умолчанию в шаблоне объектной привязки и автоматически добавляются к типу объект-литерал.</target>
        </trans-unit>
        <trans-unit id="c8c07940eda3231c047d293da9f37f7834dd40cb" translate="yes" xml:space="preserve">
          <source>Properties in the object literal that have no match in the object binding pattern are an error.</source>
          <target state="translated">Свойства в буквальном объекте,не имеющие совпадения в шаблоне привязки объекта,являются ошибкой.</target>
        </trans-unit>
        <trans-unit id="f8cc4919fcb9285716ac09c9df472748a0cd6f09" translate="yes" xml:space="preserve">
          <source>Properties with default values in the object binding pattern become optional in the object literal.</source>
          <target state="translated">Свойства со значениями по умолчанию в шаблоне привязки объектов становятся необязательными в буквальном значении объекта.</target>
        </trans-unit>
        <trans-unit id="3cbcb3278bdf5d0340f45b88be40ef4d53f50ba6" translate="yes" xml:space="preserve">
          <source>Property Decorators</source>
          <target state="translated">Декораторы недвижимости</target>
        </trans-unit>
        <trans-unit id="ce5358cfe7c2a6843f2919f24e964b409bffae5b" translate="yes" xml:space="preserve">
          <source>Property assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:</source>
          <target state="translated">Присвоения свойств и не генерические выражения спреда максимально объединяются по обеим сторонам общего выражения спреда.Например:</target>
        </trans-unit>
        <trans-unit id="832f7d76da1eb3d3ed83c2498cd0b5b699ea5efe" translate="yes" xml:space="preserve">
          <source>Property renaming</source>
          <target state="translated">Переименование недвижимости</target>
        </trans-unit>
        <trans-unit id="28531336563e1f3883b87d858af447e561471bd7" translate="yes" xml:space="preserve">
          <source>Protected</source>
          <target state="translated">Protected</target>
        </trans-unit>
        <trans-unit id="f0e692539cb524363ffe3c3313543515de8c4424" translate="yes" xml:space="preserve">
          <source>Prototype assignment</source>
          <target state="translated">Назначение прототипов</target>
        </trans-unit>
        <trans-unit id="001b7307089ddcafb90fad2dff22ffc7a1e3c62c" translate="yes" xml:space="preserve">
          <source>Provide full support for iterables in &lt;code&gt;for..of&lt;/code&gt;, spread and destructuring when targeting ES5 or ES3.</source>
          <target state="translated">Обеспечьте полную поддержку итераций в &lt;code&gt;for..of&lt;/code&gt; , распространении и деструктуризации при ориентации на ES5 или ES3.</target>
        </trans-unit>
        <trans-unit id="a1146ed26ee333eed6d3996e25afdde504ab9e9b" translate="yes" xml:space="preserve">
          <source>Public by default</source>
          <target state="translated">Публично по умолчанию</target>
        </trans-unit>
        <trans-unit id="df1e7a58b300fcd2018db41d09e99c76f51ccd9c" translate="yes" xml:space="preserve">
          <source>Public, private, and protected modifiers</source>
          <target state="translated">Государственные,частные и защищенные модификаторы</target>
        </trans-unit>
        <trans-unit id="4aeb4ef1d8df7836057d41c034dc834be57b173f" translate="yes" xml:space="preserve">
          <source>Publish to &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</source>
          <target state="translated">Опубликовать в &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1aa195e794b4f66b923622c595d29c04615285a" translate="yes" xml:space="preserve">
          <source>Publish to npm</source>
          <target state="translated">Публикация в воскресенье</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="be0e9506d0fd3f0204f58e0f5b06282be66a0f23" translate="yes" xml:space="preserve">
          <source>Publishing: Dependencies</source>
          <target state="translated">Публикации:Зависимости</target>
        </trans-unit>
        <trans-unit id="ed87f3075dc9e52018557fb97c9010a8f00d2af8" translate="yes" xml:space="preserve">
          <source>Publishing: Publish to @types</source>
          <target state="translated">Публикация:Публикация в @типах</target>
        </trans-unit>
        <trans-unit id="c25e21d552520e10e91602755603035ee2dc11de" translate="yes" xml:space="preserve">
          <source>Publishing: Red flags</source>
          <target state="translated">Публикации:Красные флаги</target>
        </trans-unit>
        <trans-unit id="322bb8d07bb59be9606da97b40f86a36058152ee" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the line with return.</source>
          <target state="translated">Поставьте точку останова на линии с возвратом.</target>
        </trans-unit>
        <trans-unit id="a1b752d5b588559d3c1ab9de849d0678ef2991f1" translate="yes" xml:space="preserve">
          <source>Putting all of the above rules together in an example</source>
          <target state="translated">Сводя все вышеперечисленные правила в один пример.</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">Складывая все вместе</target>
        </trans-unit>
        <trans-unit id="ab61ee9bc98f1490cb74d9856a2bcfdb903bd123" translate="yes" xml:space="preserve">
          <source>Quick introductions based on your background or preference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224762d86a9baf2c769b2d7a923fbcab59d453ee" translate="yes" xml:space="preserve">
          <source>Raise error on &lt;code&gt;this&lt;/code&gt; expressions with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Поднимите ошибку в &lt;code&gt;this&lt;/code&gt; выражении с подразумеваемым &lt;code&gt;any&lt;/code&gt; типом.</target>
        </trans-unit>
        <trans-unit id="36eec16ea1bf9722ff825e6c1dfe6c84e5ad8600" translate="yes" xml:space="preserve">
          <source>Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">Вызывать ошибку в выражениях и объявлениях с подразумеваемым типом &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="374e9f700483653b29a58cc7f00cdaf51ae907b5" translate="yes" xml:space="preserve">
          <source>Rather than actually execute a build with the other input options and config files, show the final implied config file in the output.</source>
          <target state="translated">Вместо того,чтобы на самом деле выполнять сборку с другими входными опциями и конфигурационными файлами,покажите конечный подразумеваемый конфигурационный файл в выходных данных.</target>
        </trans-unit>
        <trans-unit id="8b1872d78c17fd0391a92cf444a735ee5e6bae28" translate="yes" xml:space="preserve">
          <source>Re-compiling, you&amp;rsquo;ll now see an error:</source>
          <target state="translated">При повторной компиляции вы увидите ошибку:</target>
        </trans-unit>
        <trans-unit id="6c315f12f77496f53aa14fdb148faec85d5b7486" translate="yes" xml:space="preserve">
          <source>Re-declarations and Shadowing</source>
          <target state="translated">Передекларация и Тень</target>
        </trans-unit>
        <trans-unit id="fdc685fb106414cf637a1b38813a53d910b18ec9" translate="yes" xml:space="preserve">
          <source>Re-export to extend</source>
          <target state="translated">Реэкспорт на продление</target>
        </trans-unit>
        <trans-unit id="648cfabc9a420f1e968be9f4f509254b2ab2cbc0" translate="yes" xml:space="preserve">
          <source>Re-exporting</source>
          <target state="translated">Re-exporting</target>
        </trans-unit>
        <trans-unit id="eda2bfe47f1cfbe6424bba7d3a76f901f6b42466" translate="yes" xml:space="preserve">
          <source>Re-exports</source>
          <target state="translated">Re-exports</target>
        </trans-unit>
        <trans-unit id="eb5bcada059371623621a43a8e7c9b5feeb2c5ef" translate="yes" xml:space="preserve">
          <source>Re-run &lt;code&gt;tsc greeter.ts&lt;/code&gt; and you&amp;rsquo;ll see the generated JavaScript is the same as the earlier code. Classes in TypeScript are just a shorthand for the same prototype-based OO that is frequently used in JavaScript.</source>
          <target state="translated">Повторно запустите &lt;code&gt;tsc greeter.ts&lt;/code&gt; , и вы увидите, что сгенерированный JavaScript такой же, как и предыдущий код. Классы в TypeScript - это просто сокращение для того же объектно-ориентированного объекта на основе прототипов, который часто используется в JavaScript.</target>
        </trans-unit>
        <trans-unit id="0800d078d61e87e277eaae4d8414a88253e82cf4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack</source>
          <target state="translated">Реагировать и Webpack</target>
        </trans-unit>
        <trans-unit id="c6ad73159db4fbc79a9e826240d2405491564ef3" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Add a TypeScript configuration file</source>
          <target state="translated">React &amp;amp; Webpack: добавить файл конфигурации TypeScript</target>
        </trans-unit>
        <trans-unit id="328cdad5c6c6e56604b6063e3fdaca83a43aa289" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Create a webpack configuration file</source>
          <target state="translated">React &amp;amp; Webpack: создайте файл конфигурации webpack</target>
        </trans-unit>
        <trans-unit id="b99e8dd71da2d3b5ad0aa22f4c73bf525f613bf7" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Initialize the project</source>
          <target state="translated">React &amp;amp; Webpack: инициализировать проект</target>
        </trans-unit>
        <trans-unit id="e79de56f4434ed0a6e8d586e225decedd4a4b91a" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Install our dependencies</source>
          <target state="translated">React &amp;amp; Webpack: установите наши зависимости</target>
        </trans-unit>
        <trans-unit id="a6f634b484a857760fd1fe0c0b8caa1f4ad1a7a4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Lay out the project</source>
          <target state="translated">React &amp;amp; Webpack: макет проекта</target>
        </trans-unit>
        <trans-unit id="70d16f67e5b10f58dde0039090fa1f15716caaa4" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Putting it all together</source>
          <target state="translated">React и Webpack: объединяем все вместе</target>
        </trans-unit>
        <trans-unit id="c1326a95c630b81552ae15e8939b25927eca9f30" translate="yes" xml:space="preserve">
          <source>React &amp;amp; Webpack: Write some code</source>
          <target state="translated">React &amp;amp; Webpack: напишите код</target>
        </trans-unit>
        <trans-unit id="58842bd13325c48a2698202bdb55d3b757360943" translate="yes" xml:space="preserve">
          <source>React integration</source>
          <target state="translated">Реактивная интеграция</target>
        </trans-unit>
        <trans-unit id="3ce4f7210a5cf94a25154fce20154f3f93c9f258" translate="yes" xml:space="preserve">
          <source>React-native build pipeline expects all files to have a &lt;code&gt;.js&lt;/code&gt; extensions even if the file contains JSX syntax. The new &lt;code&gt;--jsx&lt;/code&gt; value &lt;code&gt;react-native&lt;/code&gt; will persevere the JSX syntax in the output file, but give it a &lt;code&gt;.js&lt;/code&gt; extension.</source>
          <target state="translated">Конвейер сборки React-native ожидает, что все файлы будут иметь расширения &lt;code&gt;.js&lt;/code&gt; , даже если файл содержит синтаксис JSX. Новое значение &lt;code&gt;--jsx&lt;/code&gt; response &lt;code&gt;react-native&lt;/code&gt; сохранит синтаксис JSX в выходном файле, но даст ему расширение &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91699c24f2e0a9b9e92adecd16c0b3f7f436f6cb" translate="yes" xml:space="preserve">
          <source>Read in any files it understands in the &lt;code&gt;src&lt;/code&gt; directory (with &lt;code&gt;include&lt;/code&gt;).</source>
          <target state="translated">Прочтите любые файлы, которые он понимает, в каталоге &lt;code&gt;src&lt;/code&gt; (с &lt;code&gt;include&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2a5eba8a5ad07b0a44f5a4a457fdc20c1b7dbf7f" translate="yes" xml:space="preserve">
          <source>Read-only properties and index signatures</source>
          <target state="translated">Свойства и индексные подписи,доступные только для чтения</target>
        </trans-unit>
        <trans-unit id="98f4c7227b38a0bf0e16a93bbf9b95c02d029667" translate="yes" xml:space="preserve">
          <source>Read-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.</source>
          <target state="translated">Свойства,доступные только для чтения,могут иметь инициализаторы и могут быть назначены в конструкторах в пределах одной декларации класса,но в противном случае назначение свойств,доступных только для чтения,запрещено.</target>
        </trans-unit>
        <trans-unit id="7386588f18988cfe9593c3202dc16be85d972e3f" translate="yes" xml:space="preserve">
          <source>Readonly modifier</source>
          <target state="translated">Модификатор только для чтения</target>
        </trans-unit>
        <trans-unit id="097c59114ca50eec3cf0a821be259c50e9b74d04" translate="yes" xml:space="preserve">
          <source>Readonly properties</source>
          <target state="translated">Свойства только для чтения</target>
        </trans-unit>
        <trans-unit id="6d74bc61c8b8b435782687890427a863cef761e7" translate="yes" xml:space="preserve">
          <source>Readonly&amp;lt;T&amp;gt;</source>
          <target state="translated">Readonly&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4699a4a521bfdbbfcae804201e013659f911e1a8" translate="yes" xml:space="preserve">
          <source>Ready? Take a look:</source>
          <target state="translated">Готовы? Взгляни:</target>
        </trans-unit>
        <trans-unit id="0cbc39f65d2c6c44eebf7ed41f07d520bd81bbe9" translate="yes" xml:space="preserve">
          <source>Real applications, however, look like &lt;code&gt;Readonly&lt;/code&gt; or &lt;code&gt;Partial&lt;/code&gt; above. They&amp;rsquo;re based on some existing type, and they transform the properties in some way. That&amp;rsquo;s where &lt;code&gt;keyof&lt;/code&gt; and indexed access types come in:</source>
          <target state="translated">Однако настоящие приложения выглядят как &quot; &lt;code&gt;Readonly&lt;/code&gt; или &quot; &lt;code&gt;Partial&lt;/code&gt; выше. Они основаны на каком-то существующем типе и каким-то образом преобразуют свойства. Вот &lt;code&gt;keyof&lt;/code&gt; и пригодятся типы доступа keyof и indexed:</target>
        </trans-unit>
        <trans-unit id="f1d90148c2f9c29ea449489201d6864609117f05" translate="yes" xml:space="preserve">
          <source>Recall how to write a type assertion:</source>
          <target state="translated">Вспомните,как написать типовое утверждение:</target>
        </trans-unit>
        <trans-unit id="c5d97500640d6a0752241e63626a067412fd2a00" translate="yes" xml:space="preserve">
          <source>Recall that Node.js looked for a file named &lt;code&gt;moduleB.js&lt;/code&gt;, then an applicable &lt;code&gt;package.json&lt;/code&gt;, and then for an &lt;code&gt;index.js&lt;/code&gt;.</source>
          <target state="translated">Напомним, что Node.js искал файл с именем &lt;code&gt;moduleB.js&lt;/code&gt; , затем подходящий &lt;code&gt;package.json&lt;/code&gt; , а затем &lt;code&gt;index.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af653faed29a78b35af6aadab7ff219a754ccd8b" translate="yes" xml:space="preserve">
          <source>Recall that with our earlier &lt;code&gt;setTimeout&lt;/code&gt; example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the &lt;code&gt;for&lt;/code&gt; loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you&amp;rsquo;ll never have to do that again in TypeScript.</source>
          <target state="translated">Напомним, что в нашем предыдущем примере с &lt;code&gt;setTimeout&lt;/code&gt; нам пришлось использовать IIFE для захвата состояния переменной для каждой итерации цикла &lt;code&gt;for&lt;/code&gt; . Фактически, мы создавали новую переменную среду для наших захваченных переменных. Это было немного больно, но, к счастью, вам больше никогда не придется делать это в TypeScript.</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="5838e1d2256d8060aa1b3a66e780f5f99fa40b5e" translate="yes" xml:space="preserve">
          <source>Record&amp;lt;K,T&amp;gt;</source>
          <target state="translated">Record&amp;lt;K,T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="4a41add58030e39fbaf51db74fe2dbb02e5e4ab1" translate="yes" xml:space="preserve">
          <source>Red Flags</source>
          <target state="translated">Красные флаги</target>
        </trans-unit>
        <trans-unit id="34d53f3ab50503026ac59429b75482fa11e6a5b9" translate="yes" xml:space="preserve">
          <source>Red flags</source>
          <target state="translated">Красные флаги</target>
        </trans-unit>
        <trans-unit id="9103e88842d8a8fd8fdef77a63d0bed96f6e7b8c" translate="yes" xml:space="preserve">
          <source>Redirect output structure to the directory.</source>
          <target state="translated">Перенаправление выходной структуры в каталог.</target>
        </trans-unit>
        <trans-unit id="4712f8dca718bd28253a5790647646c3533841da" translate="yes" xml:space="preserve">
          <source>Referenced projects must have the new &lt;code&gt;composite&lt;/code&gt; setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the &lt;code&gt;composite&lt;/code&gt; flag changes a few things:</source>
          <target state="translated">В ссылочных проектах должен быть включен новый &lt;code&gt;composite&lt;/code&gt; параметр. Этот параметр необходим для того, чтобы TypeScript мог быстро определить, где найти выходные данные проекта, на который имеется ссылка. Включение &lt;code&gt;composite&lt;/code&gt; флага меняет несколько вещей:</target>
        </trans-unit>
        <trans-unit id="f716fe211e8cbfb1b5ac185fb3d6bbbbc2b34ab2" translate="yes" xml:space="preserve">
          <source>Referring to objects in the value space as types doesn&amp;rsquo;t work unless the object also creates a type, like a constructor function.</source>
          <target state="translated">Обращение к объектам в пространстве значений как к типам не работает, если объект также не создает тип, например функцию конструктора.</target>
        </trans-unit>
        <trans-unit id="917df91e1730cb55ff8aba76f721651a6b54a840" translate="yes" xml:space="preserve">
          <source>Related</source>
          <target state="translated">Related</target>
        </trans-unit>
        <trans-unit id="0d61ba1d171892a4a7567647b72650543ee4275d" translate="yes" xml:space="preserve">
          <source>Relative paths are fairly straightforward. As an example, let&amp;rsquo;s consider a file located at &lt;code&gt;/root/src/moduleA.js&lt;/code&gt;, which contains the import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js resolves that import in the following order:</source>
          <target state="translated">Относительные пути довольно просты. В качестве примера рассмотрим файл, расположенный в &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; , который содержит import &lt;code&gt;var x = require(&quot;./moduleB&quot;);&lt;/code&gt; Node.js разрешает этот импорт в следующем порядке:</target>
        </trans-unit>
        <trans-unit id="227f526e9deba436f5046f9ae5ceb4b3a9053811" translate="yes" xml:space="preserve">
          <source>Relative vs. Non-relative module imports</source>
          <target state="translated">Относительный и нереляционный импорт модулей</target>
        </trans-unit>
        <trans-unit id="2ff253f328340904e6aa7b404e19bda3c645fe78" translate="yes" xml:space="preserve">
          <source>Relaxing declaration emit visiblity rules</source>
          <target state="translated">Расслабляющие правила декларирования излучают видимость</target>
        </trans-unit>
        <trans-unit id="1d3768a1e142e6e3ef4c29558ba7b7010322ddb0" translate="yes" xml:space="preserve">
          <source>Remember what we mentioned earlier about variable capturing? Every function expression we pass to &lt;code&gt;setTimeout&lt;/code&gt; actually refers to the same &lt;code&gt;i&lt;/code&gt; from the same scope.</source>
          <target state="translated">Помните, что мы упоминали ранее о захвате переменных? Каждое выражение функции, которое мы передаем в &lt;code&gt;setTimeout&lt;/code&gt; , фактически относится к одному &lt;code&gt;i&lt;/code&gt; тому же i из той же области.</target>
        </trans-unit>
        <trans-unit id="f11d0e5af8f40be276413a0572f57b6d8abf9e52" translate="yes" xml:space="preserve">
          <source>Remove all comments except copy-right header comments beginning with &lt;code&gt;/*!&lt;/code&gt;</source>
          <target state="translated">Удалите все комментарии, кроме комментариев заголовка с авторским правом, начинающихся с &lt;code&gt;/*!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64f0b6609e1215f1c7351fcea7e64bd711ee68cd" translate="yes" xml:space="preserve">
          <source>Removes the &amp;lsquo;this&amp;rsquo; parameter from a function type.</source>
          <target state="translated">Удаляет параметр this из типа функции.</target>
        </trans-unit>
        <trans-unit id="458347c4b08c20b7988b89261e9a532ec566adc1" translate="yes" xml:space="preserve">
          <source>Replace the contents of the &lt;code&gt;tsconfig.json&lt;/code&gt; file with:</source>
          <target state="translated">Замените содержимое файла &lt;code&gt;tsconfig.json&lt;/code&gt; на:</target>
        </trans-unit>
        <trans-unit id="bf9bdd295fb0df2de64ff2a20d94e74886937c45" translate="yes" xml:space="preserve">
          <source>Report an error when not all code paths in function return a value.</source>
          <target state="translated">Сообщить об ошибке,если не все кодовые пути в функции возвращают значение.</target>
        </trans-unit>
        <trans-unit id="4bfcecd38bfeff6fffc3ecafa503fe73a31b3529" translate="yes" xml:space="preserve">
          <source>Report errors for fallthrough cases in switch statement.</source>
          <target state="translated">Сообщайте об ошибках для случаев падения в ведомости переключения.</target>
        </trans-unit>
        <trans-unit id="f8c20651b90e6cd8477684950f963b02e2099736" translate="yes" xml:space="preserve">
          <source>Report errors in &lt;code&gt;.js&lt;/code&gt; files. Use in conjunction with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">Сообщайте об ошибках в файлах &lt;code&gt;.js&lt;/code&gt; . Используйте вместе с &lt;code&gt;--allowJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2375f497601629902de6816b8348dc646a011d3" translate="yes" xml:space="preserve">
          <source>Report errors on unused locals.</source>
          <target state="translated">Сообщайте об ошибках на неиспользуемых местных жителях.</target>
        </trans-unit>
        <trans-unit id="4e4da7a34ece0e23f3bacbbf60ec3ad07461c31d" translate="yes" xml:space="preserve">
          <source>Report errors on unused parameters.</source>
          <target state="translated">Сообщайте об ошибках по неиспользуемым параметрам.</target>
        </trans-unit>
        <trans-unit id="d1c09f6c73919c0ebd1abbfd86f69d2cd3437aeb" translate="yes" xml:space="preserve">
          <source>Report module resolution log messages.</source>
          <target state="translated">Сообщения журнала разрешения модуля отчетов.</target>
        </trans-unit>
        <trans-unit id="99bc390ff55a2eb33efc222d7c8bb02d1504d6e7" translate="yes" xml:space="preserve">
          <source>Required type parameters must not follow optional type parameters.</source>
          <target state="translated">Требуемые параметры типа не должны соответствовать дополнительным параметрам типа.</target>
        </trans-unit>
        <trans-unit id="6b52890a8d8bb281f971e8b6c6fc68eebe6bbc98" translate="yes" xml:space="preserve">
          <source>Required&amp;lt;T&amp;gt;</source>
          <target state="translated">Required&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cdc1d535ad72977d21e2597085ca79e9eac4c98a" translate="yes" xml:space="preserve">
          <source>Required, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the &lt;code&gt;arguments&lt;/code&gt; variable that is visible inside every function body.</source>
          <target state="translated">Обязательные, необязательные и стандартные параметры имеют одну общую черту: они говорят об одном параметре за раз. Иногда вам нужно работать с несколькими параметрами как группой или вы можете не знать, сколько параметров в конечном итоге примет функция. В JavaScript вы можете работать с аргументами напрямую, используя переменную &lt;code&gt;arguments&lt;/code&gt; , которая видна внутри каждого тела функции.</target>
        </trans-unit>
        <trans-unit id="bb59a7085d1d1d9d3f072f5c7166cfdbf3c3fa4d" translate="yes" xml:space="preserve">
          <source>Resolve &lt;code&gt;keyof&lt;/code&gt; to string valued property names only (no numbers or symbols).</source>
          <target state="translated">Разрешить &lt;code&gt;keyof&lt;/code&gt; только для имен свойств со строковыми значениями (без цифр или символов).</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">Параметры отдыха</target>
        </trans-unit>
        <trans-unit id="beeb7a77ad3e842a8cb47b5d6131631a494608b1" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types</source>
          <target state="translated">Элементы для отдыха в кортежах</target>
        </trans-unit>
        <trans-unit id="50be0fe30fc10dc88af852c9cb7c36370f77be27" translate="yes" xml:space="preserve">
          <source>Rest elements in tuple types.</source>
          <target state="translated">Элементы для отдыха в кортежах.</target>
        </trans-unit>
        <trans-unit id="387816de015267e69071ea349b674f6e1d757b14" translate="yes" xml:space="preserve">
          <source>Rest parameters with tuple types</source>
          <target state="translated">Параметры покоя с типами кортежей</target>
        </trans-unit>
        <trans-unit id="191ff62bcfa7d34e1a815740c74afda07b8c1e33" translate="yes" xml:space="preserve">
          <source>Results in an output such as:</source>
          <target state="translated">В результате получается такой результат:</target>
        </trans-unit>
        <trans-unit id="69fa7005e9e1a4d2f5ae93f2373b3b809a4f2af9" translate="yes" xml:space="preserve">
          <source>Results in the following generated code:</source>
          <target state="translated">В результате получается следующий сгенерированный код:</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">Результаты:</target>
        </trans-unit>
        <trans-unit id="642d8f2cc4c0bf44f7ec4417fc288bf230277121" translate="yes" xml:space="preserve">
          <source>Return Types of Callbacks</source>
          <target state="translated">Типы обратного вызова</target>
        </trans-unit>
        <trans-unit id="d87cabec32902153d1d79b8b11bc188472a6cc03" translate="yes" xml:space="preserve">
          <source>Return types as inference targets</source>
          <target state="translated">Типы возврата в качестве целей умозаключений</target>
        </trans-unit>
        <trans-unit id="af8759585cf2cfe7a7c8a45a7ecabdbfd11cd2db" translate="yes" xml:space="preserve">
          <source>ReturnType&amp;lt;T&amp;gt;</source>
          <target state="translated">ReturnType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="251cfcc8db7eb197ba54907567e2b369dc7b23af" translate="yes" xml:space="preserve">
          <source>Reusable Types (Interfaces)</source>
          <target state="translated">Типы многоразового использования (интерфейсы)</target>
        </trans-unit>
        <trans-unit id="d6640a4d11aa6f54309d2fb5c213135e2c58c777" translate="yes" xml:space="preserve">
          <source>Reusable Types (Type Aliases)</source>
          <target state="translated">Многоразовые типы (псевдонимы)</target>
        </trans-unit>
        <trans-unit id="221e6da1276e8997b6b6f436b2f947172bae0726" translate="yes" xml:space="preserve">
          <source>Reverse mappings</source>
          <target state="translated">Обратные отображения</target>
        </trans-unit>
        <trans-unit id="9a135d61c072a9901e22aab7a06796f5a0db008c" translate="yes" xml:space="preserve">
          <source>Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript File&lt;/strong&gt; and name the file &lt;code&gt;app.ts&lt;/code&gt;</source>
          <target state="translated">Щелкните &lt;code&gt;scripts&lt;/code&gt; правой кнопкой мыши и выберите &amp;laquo; &lt;strong&gt;Новый элемент&amp;raquo;&lt;/strong&gt; . Затем выберите &lt;strong&gt;TypeScript File&lt;/strong&gt; и назовите файл &lt;code&gt;app.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46718d1e29791accf85fa69e3063268fff2968e4" translate="yes" xml:space="preserve">
          <source>Right click on the &lt;code&gt;wwwroot&lt;/code&gt; folder (if you don&amp;rsquo;t see the folder try building the project) and add a New Item named &lt;code&gt;index.html&lt;/code&gt; inside. Use the following code for &lt;code&gt;index.html &lt;/code&gt;</source>
          <target state="translated">Щелкните правой кнопкой &lt;code&gt;wwwroot&lt;/code&gt; папку wwwroot (если вы не видите папку, попробуйте создать проект) и добавьте внутрь новый элемент с именем &lt;code&gt;index.html&lt;/code&gt; . Используйте следующий код для &lt;code&gt;index.html &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f52ba130a82d88fb66ffcaad9e4d91c2445da38b" translate="yes" xml:space="preserve">
          <source>Right click on the project and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;JavaScript File&lt;/strong&gt; and use the name of &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">Щелкните проект правой кнопкой мыши и выберите &amp;laquo; &lt;strong&gt;Новый элемент&amp;raquo;&lt;/strong&gt; . Затем выберите &lt;strong&gt;файл JavaScript&lt;/strong&gt; и используйте имя &lt;code&gt;gulpfile.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e501a41bf28a9903be39bc35a602a8ca106603f" translate="yes" xml:space="preserve">
          <source>Right-Click -&amp;gt; Manage NuGet Packages</source>
          <target state="translated">Щелкните правой кнопкой мыши -&amp;gt; Управление пакетами NuGet</target>
        </trans-unit>
        <trans-unit id="c8a67c2b7fee671c0d27e33fbdf91828d8346fc3" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;tsc --init&lt;/code&gt; in a directory to create an initial &lt;code&gt;tsconfig.json&lt;/code&gt; in this directory with preset defaults. Optionally pass command line arguments along with &lt;code&gt;--init&lt;/code&gt; to be stored in your initial tsconfig.json on creation.</source>
          <target state="translated">Запустите &lt;code&gt;tsc --init&lt;/code&gt; в каталоге, чтобы создать в этом каталоге начальный &lt;code&gt;tsconfig.json&lt;/code&gt; с предустановленными значениями по умолчанию. При необходимости передайте аргументы командной строки вместе с &lt;code&gt;--init&lt;/code&gt; , которые будут сохранены в исходном файле tsconfig.json при создании.</target>
        </trans-unit>
        <trans-unit id="7418ce51bc901e2c720b082e836bfd88f7024c62" translate="yes" xml:space="preserve">
          <source>Run the application and make sure that it works.</source>
          <target state="translated">Запустите приложение и убедитесь,что оно работает.</target>
        </trans-unit>
        <trans-unit id="7e0fc2451d2efaadd8b864a6b91ae00ff2dca3ac" translate="yes" xml:space="preserve">
          <source>Run the compiler in watch mode. Watch input files and trigger recompilation on changes. The implementation of watching files and directories can be configured using environment variable. See &lt;a href=&quot;configuring-watch&quot;&gt;configuring watch&lt;/a&gt; for more details.</source>
          <target state="translated">Запустите компилятор в режиме наблюдения. Следите за входными файлами и запускайте перекомпиляцию при изменениях. Реализацию просмотра файлов и каталогов можно настроить с помощью переменной окружения. См. Дополнительные сведения о &lt;a href=&quot;configuring-watch&quot;&gt;настройке часов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="541995e6de639764055cf456f41bfe89e00d49e7" translate="yes" xml:space="preserve">
          <source>Run the project</source>
          <target state="translated">Запустить проект</target>
        </trans-unit>
        <trans-unit id="5ea024956a0df9ff6595fe749c1eb6c02cc2dc2f" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;tsc --build&lt;/code&gt; (&lt;code&gt;tsc -b&lt;/code&gt; for short) will do the following:</source>
          <target state="translated">Запуск &lt;code&gt;tsc --build&lt;/code&gt; ( &lt;code&gt;tsc -b&lt;/code&gt; ) сделает следующее:</target>
        </trans-unit>
        <trans-unit id="88a02590b48e29c8ee3a28ec7ba7ee167b44c09c" translate="yes" xml:space="preserve">
          <source>Running your TypeScript web app</source>
          <target state="translated">Запуск вашего веб-приложения TypeScript</target>
        </trans-unit>
        <trans-unit id="e2a41db8c3523e88ee5980c0cbd2788f6889d1f9" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in System.js</source>
          <target state="translated">Образец:Загрузка динамического модуля в System.js</target>
        </trans-unit>
        <trans-unit id="c66144bb0d8421e5d08ae6900d1c0163e2522d70" translate="yes" xml:space="preserve">
          <source>Sample: Dynamic Module Loading in require.js</source>
          <target state="translated">Образец:Динамический модуль Загрузка в require.js</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1e96c4caea76817edca1b37676caff140bf67580" translate="yes" xml:space="preserve">
          <source>Schema can be found at: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</source>
          <target state="translated">Схему можно найти по адресу: &lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;http://json.schemastore.org/tsconfig&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0b92d418e654bbd5c2c48b78244ecce9fb91d09" translate="yes" xml:space="preserve">
          <source>Scoping rules</source>
          <target state="translated">Основные положения</target>
        </trans-unit>
        <trans-unit id="aa7841d9d246c3e95a5b8f479b5b2166bbcd3d3d" translate="yes" xml:space="preserve">
          <source>Search for &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;</source>
          <target state="translated">Найдите &lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="120e80cbcdda984e634ee6ea60b988e7bdcd424d" translate="yes" xml:space="preserve">
          <source>Search for &lt;strong&gt;.NET Core&lt;/strong&gt; in the project search bar</source>
          <target state="translated">Найдите &lt;strong&gt;.NET Core&lt;/strong&gt; в строке поиска проекта</target>
        </trans-unit>
        <trans-unit id="98cc363c0119e35d1c8070755fc4d4c2387aad71" translate="yes" xml:space="preserve">
          <source>Searching</source>
          <target state="translated">Searching</target>
        </trans-unit>
        <trans-unit id="f28a160d3aeb79cc4e72b1bcf1f1cea3eed98229" translate="yes" xml:space="preserve">
          <source>Second, compile your files using &lt;code&gt;--importHelpers&lt;/code&gt;:</source>
          <target state="translated">Во-вторых, скомпилируйте файлы с помощью &lt;code&gt;--importHelpers&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f8a01008852da0be0cb83fb18c9ca0f90e85ba52" translate="yes" xml:space="preserve">
          <source>Second, the Typescript compiler doesn&amp;rsquo;t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.</source>
          <target state="translated">Во-вторых, компилятор Typescript не допускает распространения параметров типа из общих функций. Эта функция ожидается в будущих версиях языка.</target>
        </trans-unit>
        <trans-unit id="f5628af6cbb5e50d058efc6cdab3cec58a0d83b9" translate="yes" xml:space="preserve">
          <source>Secondly, using class fields to specialize properties from base classes also won&amp;rsquo;t work.</source>
          <target state="translated">Во-вторых, использование полей класса для специализации свойств базовых классов также не сработает.</target>
        </trans-unit>
        <trans-unit id="7ff5a6dafd806f6d95302657c480d07703b64604" translate="yes" xml:space="preserve">
          <source>Sections</source>
          <target state="translated">Sections</target>
        </trans-unit>
        <trans-unit id="834c69b9d98efc1c3cec6d026570d3df634c7666" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../project-references&quot;&gt;Project References handbook page&lt;/a&gt; for more documentation.</source>
          <target state="translated">См. Дополнительную документацию на &lt;a href=&quot;../project-references&quot;&gt;странице справочника&lt;/a&gt; по проектам .</target>
        </trans-unit>
        <trans-unit id="187875e55767d20df483d2fe4602ec06611fda25" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Module Resolution&lt;/a&gt; documentation for more details.</source>
          <target state="translated">См. Документацию &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/module-resolution.html&quot;&gt;Module Resolution&lt;/a&gt; для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="62fc6fcffeeb4b12902ccd59524362dbcce28787" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;issue #1256&lt;/a&gt; for more information.</source>
          <target state="translated">См. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1256&quot;&gt;Проблему № 1256&lt;/a&gt; для получения дополнительной информации.</target>
        </trans-unit>
        <trans-unit id="4c1f9292006cbb6b615fc48854ee208dde437f57" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;Type checking JavaScript Files documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Дополнительные сведения см. В &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files&quot;&gt;документации&lt;/a&gt; к файлам JavaScript проверки типов .</target>
        </trans-unit>
        <trans-unit id="fc473e27d9a7d29475aee306accd60b759bc0b30" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;more details on ts-loader here&lt;/a&gt;.</source>
          <target state="translated">Смотрите &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;более подробную информацию о TS-погрузчик здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b638ae7ad48e00c44c5cd48eb83e81ecbbf0a3c9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; documentation for more details.</source>
          <target state="translated">Подробнее &lt;a href=&quot;tsconfig-json&quot;&gt;см.&lt;/a&gt; Документацию tsconfig.json .</target>
        </trans-unit>
        <trans-unit id="73a908746ad2d70ca1399fea9bcf57e61da44b2f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;tsconfig.json wiki page&lt;/a&gt; for more details.</source>
          <target state="translated">См. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/tsconfig.json&quot;&gt;Вики-страницу tsconfig.json&lt;/a&gt; для получения более подробной информации.</target>
        </trans-unit>
        <trans-unit id="077567d6271296de8ad4bd173bc8a26e4ff5d0f2" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information about modules. See the &lt;a href=&quot;namespaces&quot;&gt;Namespaces&lt;/a&gt; documentation for more information about namespaces.</source>
          <target state="translated">См. Документацию по &lt;a href=&quot;modules&quot;&gt;модулям&lt;/a&gt; для получения дополнительной информации о модулях. См. Документацию по &lt;a href=&quot;namespaces&quot;&gt;пространствам имен&lt;/a&gt; для получения дополнительной информации о пространствах имен.</target>
        </trans-unit>
        <trans-unit id="64f2c787a02cbb7afa18cb007db73ea2664f916b" translate="yes" xml:space="preserve">
          <source>See the [[JSX]] wiki page for more information on using JSX in TypeScript.</source>
          <target state="translated">Дополнительную информацию об использовании JSX в TypeScript см.на вики-странице [[JSX]].</target>
        </trans-unit>
        <trans-unit id="cba80f4302feeb955dc9a7f866e6030dfdf9aef8" translate="yes" xml:space="preserve">
          <source>Select &lt;strong&gt;ASP.NET Core Web Application&lt;/strong&gt; and press the &lt;em&gt;Next&lt;/em&gt; button</source>
          <target state="translated">Выберите &lt;strong&gt;веб-приложение ASP.NET Core&lt;/strong&gt; и нажмите кнопку &lt;em&gt;Далее.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed8feffbb3830d15b62b683a32f847857e90712a" translate="yes" xml:space="preserve">
          <source>Semicolon Formatter Option</source>
          <target state="translated">Вариант с запятой</target>
        </trans-unit>
        <trans-unit id="0f34f77f18943b88ab52ee5b7292da7cf41c6f44" translate="yes" xml:space="preserve">
          <source>Semicolon-Aware Code Edits</source>
          <target state="translated">Редактирование кода Semicolon-Aware</target>
        </trans-unit>
        <trans-unit id="bcd9a6570954b6e91fefb181f3610d2793b5661b" translate="yes" xml:space="preserve">
          <source>Sequentially Added Properties</source>
          <target state="translated">Последовательно добавленные свойства</target>
        </trans-unit>
        <trans-unit id="7f05ebe6c7a2fc5869cacffec6b784fde7b8f889" translate="yes" xml:space="preserve">
          <source>Set up the build</source>
          <target state="translated">Установить сборку</target>
        </trans-unit>
        <trans-unit id="40f24e0504d1b14397453f62baee68453ad2fba2" translate="yes" xml:space="preserve">
          <source>Set up the server</source>
          <target state="translated">Установить сервер</target>
        </trans-unit>
        <trans-unit id="c4f87dbe5e7d0d324c8530cef57ba653425df0e3" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;baseUrl&lt;/code&gt; informs the compiler where to find modules. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">Установка &lt;code&gt;baseUrl&lt;/code&gt; сообщает компилятору, где искать модули. Предполагается, что весь импорт модулей с не относительными именами относится к &lt;code&gt;baseUrl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51341becf9d4b848eec8afc734c39a0799738e80" translate="yes" xml:space="preserve">
          <source>Setting a top-level property &lt;code&gt;compileOnSave&lt;/code&gt; signals to the IDE to generate all files for a given tsconfig.json upon saving.</source>
          <target state="translated">Установка свойства верхнего уровня &lt;code&gt;compileOnSave&lt;/code&gt; сигнализирует IDE для создания всех файлов для данного tsconfig.json при сохранении.</target>
        </trans-unit>
        <trans-unit id="53989c11f338fd824665321c75b617ecdf354fe7" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild projects&lt;/a&gt;.</source>
          <target state="translated">Настройка параметров компилятора в &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;проектах MSBuild&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90b8ab6e9c58f23f02ac47d035bce949bcd397b5" translate="yes" xml:space="preserve">
          <source>Setting compiler options in &lt;a href=&quot;tsconfig-json&quot;&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;&lt;/a&gt; files.</source>
          <target state="translated">Установка параметров компилятора в файлах &lt;a href=&quot;tsconfig-json&quot;&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a6795689bb9ea8c8cb6764f05c1f6f935ee04dc" translate="yes" xml:space="preserve">
          <source>Setting the new compiler flag &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a &lt;code&gt;default&lt;/code&gt; export that has the shape of the entire module itself.</source>
          <target state="translated">Установка нового флага компилятора &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; указывает, что загрузчик модуля выполняет какое-то синтетическое создание элемента импорта по умолчанию, не указанное в импортированных .ts или .d.ts. Компилятор сделает вывод о существовании экспорта по &lt;code&gt;default&lt;/code&gt; который имеет форму всего модуля.</target>
        </trans-unit>
        <trans-unit id="2e71f746315f905d8f4bde8180b1dba0027a8422" translate="yes" xml:space="preserve">
          <source>Setting up your Directories</source>
          <target state="translated">Настройте свои директории</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="ba3a6a9b6d048ac70a293087f03215c195461fd9" translate="yes" xml:space="preserve">
          <source>Shadowing should &lt;em&gt;usually&lt;/em&gt; be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.</source>
          <target state="translated">&lt;em&gt;Обычно&lt;/em&gt; следует избегать затенения в интересах написания более четкого кода. Хотя есть некоторые сценарии, в которых это может быть уместно, вам следует руководствоваться здравым смыслом.</target>
        </trans-unit>
        <trans-unit id="274d75123478b9323ff5c010c5717e0dad76caf9" translate="yes" xml:space="preserve">
          <source>Shorthand ambient module declarations</source>
          <target state="translated">Короткое объявление модуля окружающей среды</target>
        </trans-unit>
        <trans-unit id="8f46f045bb2fdc1956a2f236cfedf0e1e227f9e8" translate="yes" xml:space="preserve">
          <source>Shorthand ambient modules</source>
          <target state="translated">Короткие окружающие модули</target>
        </trans-unit>
        <trans-unit id="d63965efaf94e11d119af70827afc578c1c99dd9" translate="yes" xml:space="preserve">
          <source>Show diagnostic information.</source>
          <target state="translated">Показывать диагностическую информацию.</target>
        </trans-unit>
        <trans-unit id="ea62715d57491630afc7339cce6c9e3316b090c6" translate="yes" xml:space="preserve">
          <source>Show verbose diagnostic information</source>
          <target state="translated">Показать многословную диагностическую информацию</target>
        </trans-unit>
        <trans-unit id="cd0e108f1f4412f32e9c055f41ef6dfdceb42a42" translate="yes" xml:space="preserve">
          <source>Similar to a &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive, which serves as a declaration of &lt;em&gt;dependency&lt;/em&gt;, a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive declares a dependency on a package.</source>
          <target state="translated">Подобно директиве &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; , которая служит объявлением &lt;em&gt;зависимости&lt;/em&gt; , директива &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; объявляет зависимость от пакета.</target>
        </trans-unit>
        <trans-unit id="7ee4acd9eb753cecdb4b91f99daa97963b128504" translate="yes" xml:space="preserve">
          <source>Similar to array spread, spreading an object can be handy to get a shallow copy:</source>
          <target state="translated">Как и при распространении по массиву,распространение объекта может быть удобно для получения неглубокой копии:</target>
        </trans-unit>
        <trans-unit id="d647d33af76ba25c85ee64e3adf6ff361ad569ea" translate="yes" xml:space="preserve">
          <source>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.</source>
          <target state="translated">По аналогии с типами соединений и пересечений,условные типы не допускают рекурсивной ссылки на себя.Например,следующая ошибка.</target>
        </trans-unit>
        <trans-unit id="ea6e185bb85cecc9661d326572fea7b76b1b1495" translate="yes" xml:space="preserve">
          <source>Similarly a default import (i.e. &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt;.Most of the CommonJS/AMD/UMD modules available today do not have a &lt;code&gt;default&lt;/code&gt; export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; or &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; are not allowed.</source>
          <target state="translated">Аналогично импорт по умолчанию (т.е. &lt;code&gt;import d from &quot;foo&quot;&lt;/code&gt; ) для модуля CommonJS / AMD / UMD как эквивалент &lt;code&gt;const d = require(&quot;foo&quot;).default&lt;/code&gt; Default . Большинство доступных сегодня модулей CommonJS / AMD / UMD не имеют по &lt;code&gt;default&lt;/code&gt; экспорт, что делает эту модель импорта практически непригодным для импорта не-ES модулей (т.е. CommonJS / AMD / UMD). Например, &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; или &lt;code&gt;import express from &quot;express&quot;&lt;/code&gt; не разрешены.</target>
        </trans-unit>
        <trans-unit id="d85b3b71be4bb5105a2a383a357dfdd56066b345" translate="yes" xml:space="preserve">
          <source>Similarly to how we can use interfaces to describe function types, we can also describe types that we can &amp;ldquo;index into&amp;rdquo; like &lt;code&gt;a[10]&lt;/code&gt;, or &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt;. Indexable types have an &lt;em&gt;index signature&lt;/em&gt; that describes the types we can use to index into the object, along with the corresponding return types when indexing. Let&amp;rsquo;s take an example:</source>
          <target state="translated">Подобно тому, как мы можем использовать интерфейсы для описания типов функций, мы также можем описывать типы, которые мы можем &amp;laquo;индексировать&amp;raquo;, например, &lt;code&gt;a[10]&lt;/code&gt; или &lt;code&gt;ageMap[&quot;daniel&quot;]&lt;/code&gt; . Индексируемые типы имеют &lt;em&gt;подпись индекса,&lt;/em&gt; которая описывает типы, которые мы можем использовать для индексации объекта, а также соответствующие типы возвращаемых данных при индексировании. Возьмем пример:</target>
        </trans-unit>
        <trans-unit id="adb395172c71ccd54b1326d899f4d06456ede0c1" translate="yes" xml:space="preserve">
          <source>Similarly to interfaces, namespaces of the same name will also merge their members. Since namespaces create both a namespace and a value, we need to understand how both merge.</source>
          <target state="translated">Подобно интерфейсам,одноименные пространства имен также объединяют своих членов.Поскольку пространства имен создают как пространство имен,так и значение,нам нужно понять,как оба они объединяются.</target>
        </trans-unit>
        <trans-unit id="59a8554ef56814f4114354c3cfa0c5ed809a9eaa" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;--target ES2017&lt;/code&gt; will instruct the compiler not to transform ES2017-specific features like &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.</source>
          <target state="translated">Точно так же &lt;code&gt;--target ES2017&lt;/code&gt; проинструктирует компилятор не преобразовывать специфичные для ES2017 функции, такие как &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb6eff56def1e9c8faa2f831e045e194b4e3480" translate="yes" xml:space="preserve">
          <source>Similarly, a non-relative import will follow the Node.js resolution logic, first looking up a file, then looking up an applicable folder. So &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">Точно так же не относительный импорт будет следовать логике разрешения Node.js, сначала ища файл, а затем ища подходящую папку. Таким образом, &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; в исходном файле &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; приведет к следующим поискам:</target>
        </trans-unit>
        <trans-unit id="8e9295d32c7a26ac7fc56081bcf2d7aa9d700307" translate="yes" xml:space="preserve">
          <source>Similarly, destructuring can be used in function parameter declarations:</source>
          <target state="translated">Аналогичным образом,деструкцию можно использовать в объявлениях параметров функции:</target>
        </trans-unit>
        <trans-unit id="034cda522b7de683abd945b4a3cdbb3d70d9b104" translate="yes" xml:space="preserve">
          <source>Similarly, namespaces can be used to extend enums with static members:</source>
          <target state="translated">Аналогичным образом,пространства имен могут быть использованы для расширения перечислений со статическими членами:</target>
        </trans-unit>
        <trans-unit id="15a650d9a4ea0756304f469dcbad9a5ff7886ae3" translate="yes" xml:space="preserve">
          <source>Similarly, the global scope can be augmented from modules using a &lt;code&gt;declare global&lt;/code&gt; declarations:</source>
          <target state="translated">Точно так же глобальная область видимости может быть расширена за счет модулей с помощью &lt;code&gt;declare global&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="44c459aed9d0d7b781bc8721c975f3ccca45175e" translate="yes" xml:space="preserve">
          <source>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</source>
          <target state="translated">Точно так же попробуйте убрать все аргументы в пользу приветственного вызова.TypeScript сообщит вам,что вы вызвали эту функцию с неожиданным количеством параметров.В обоих случаях TypeScript может предложить статический анализ,основанный как на структуре вашего кода,так и на предоставленных вами аннотациях типов.</target>
        </trans-unit>
        <trans-unit id="a96df9471d886c6a3944738c14a4e817cb32e52e" translate="yes" xml:space="preserve">
          <source>Similarly, you can merge several different objects. In the following example, &lt;code&gt;merged&lt;/code&gt; will have properties from &lt;code&gt;foo&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt;, and &lt;code&gt;baz&lt;/code&gt;.</source>
          <target state="translated">Точно так же вы можете объединить несколько разных объектов. В следующем примере &lt;code&gt;merged&lt;/code&gt; будет иметь свойства из &lt;code&gt;foo&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e344fea73da74bac69381f07e6bac9722af29f9" translate="yes" xml:space="preserve">
          <source>Similarly, you could write a utility type like &lt;code&gt;Writable&lt;/code&gt; mapped type that strips away &lt;code&gt;readonly&lt;/code&gt;-ness, and that would convert &lt;code&gt;readonly&lt;/code&gt; array containers back to their mutable equivalents.</source>
          <target state="translated">Точно так же вы могли бы написать служебный тип, такой как &lt;code&gt;Writable&lt;/code&gt; mapped type, который удаляет &lt;code&gt;readonly&lt;/code&gt; чтения и конвертирует контейнеры массивов только для &lt;code&gt;readonly&lt;/code&gt; обратно в их изменяемые эквиваленты.</target>
        </trans-unit>
        <trans-unit id="8aacbc2fc90c4a9233935fa887158e588886b733" translate="yes" xml:space="preserve">
          <source>Simple Combinations: One name, multiple meanings</source>
          <target state="translated">Простые комбинации:Одно имя,несколько значений</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">Простой пример</target>
        </trans-unit>
        <trans-unit id="1c315460161fd9403852d4c74317febae46bf2d2" translate="yes" xml:space="preserve">
          <source>SimpleModule.ts</source>
          <target state="translated">SimpleModule.ts</target>
        </trans-unit>
        <trans-unit id="b2ce6f775436f49655c281cba1ff8bd7971a0459" translate="yes" xml:space="preserve">
          <source>Simplified &lt;code&gt;props&lt;/code&gt; type management in React</source>
          <target state="translated">Упрощенная &lt;code&gt;props&lt;/code&gt; управления типа в React</target>
        </trans-unit>
        <trans-unit id="e0d662efaa9ae2f635437fd38e1b30b750f5eb5c" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;keyof&lt;/code&gt; now reflects the presence of a numeric index signature by including type &lt;code&gt;number&lt;/code&gt; in the key type, mapped types such as &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; work correctly when applied to object types with numeric index signatures:</source>
          <target state="translated">Поскольку теперь &lt;code&gt;keyof&lt;/code&gt; отражает наличие подписи числового индекса, включая &lt;code&gt;number&lt;/code&gt; типа в тип ключа, сопоставленные типы, такие как &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; и &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; работают правильно при применении к типам объектов с подписями числовых индексов:</target>
        </trans-unit>
        <trans-unit id="3d0a96b99fe271899593be449688b7fa5ea47eef" translate="yes" xml:space="preserve">
          <source>Since JavaScript automatically terminates the &lt;code&gt;return&lt;/code&gt; statement at the end of the line, the object literal becomes a block.</source>
          <target state="translated">Поскольку JavaScript автоматически завершает оператор &lt;code&gt;return&lt;/code&gt; в конце строки, литерал объекта становится блоком.</target>
        </trans-unit>
        <trans-unit id="cce35890852819c246c89e64575a83cc751e8c48" translate="yes" xml:space="preserve">
          <source>Since declarations in one file can affect type checking in other files, some errors may not be detected when &lt;code&gt;--skipLibCheck&lt;/code&gt; is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.</source>
          <target state="translated">Поскольку объявления в одном файле могут повлиять на проверку типов в других файлах, некоторые ошибки могут не обнаруживаться при &lt;code&gt;--skipLibCheck&lt;/code&gt; . Например, если файл без объявления дополняет тип, объявленный в файле объявления, могут возникнуть ошибки, о которых сообщается только при проверке файла объявления. Однако на практике такие ситуации редки.</target>
        </trans-unit>
        <trans-unit id="91fd691cb7cba41ab5d488469fc7cd906ef14a39" translate="yes" xml:space="preserve">
          <source>Since nullable types are implemented with a union, you need to use a type guard to get rid of the &lt;code&gt;null&lt;/code&gt;. Fortunately, this is the same code you&amp;rsquo;d write in JavaScript:</source>
          <target state="translated">Поскольку типы, допускающие значение NULL, реализованы с помощью объединения, вам нужно использовать защиту типа, чтобы избавиться от &lt;code&gt;null&lt;/code&gt; . К счастью, это тот же код, который вы написали бы на JavaScript:</target>
        </trans-unit>
        <trans-unit id="d7d710dcc7a9a1a3a0ae270f066743ad193628a1" translate="yes" xml:space="preserve">
          <source>Since ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; and the &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.</source>
          <target state="translated">Поскольку диапазоны могут перекрываться, определение того, какое перенаправление применяется, зависит от заказа. Это означает, что в приведенном выше примере, хотя сопоставители &lt;code&gt;&amp;gt;=3.2&lt;/code&gt; и &lt;code&gt;&amp;gt;=3.1&lt;/code&gt; поддерживают TypeScript 3.2 и выше, изменение порядка может иметь другое поведение, поэтому приведенный выше образец не будет эквивалентен следующему.</target>
        </trans-unit>
        <trans-unit id="4f878058a9de82078d9e40fb2687f87811aefbf7" translate="yes" xml:space="preserve">
          <source>Since the above syntax cannot be used in &lt;code&gt;.tsx&lt;/code&gt; files, an alternate type assertion operator should be used: &lt;code&gt;as&lt;/code&gt;. The example can easily be rewritten with the &lt;code&gt;as&lt;/code&gt; operator.</source>
          <target state="translated">Поскольку приведенный выше синтаксис не может использоваться в файлах &lt;code&gt;.tsx&lt;/code&gt; , следует использовать оператор утверждения альтернативного типа: &lt;code&gt;as&lt;/code&gt; . Пример можно легко переписать с помощью оператора &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c94167207ee9c90316742f73b6eca79827716dff" translate="yes" xml:space="preserve">
          <source>Since the class uses &lt;code&gt;this&lt;/code&gt; types, you can extend it and the new class can use the old methods with no changes.</source>
          <target state="translated">Поскольку класс использует &lt;code&gt;this&lt;/code&gt; типы, вы можете расширить его, и новый класс может использовать старые методы без изменений.</target>
        </trans-unit>
        <trans-unit id="3f878409b3dc13d4ef49d4cf4543cf7848bae266" translate="yes" xml:space="preserve">
          <source>Since the stricter checks may uncover previously unreported errors, this is a breaking change in &lt;code&gt;--strict&lt;/code&gt; mode.</source>
          <target state="translated">Поскольку более строгие проверки могут выявить ранее незарегистрированные ошибки, это &lt;code&gt;--strict&lt;/code&gt; изменение в режиме --strict .</target>
        </trans-unit>
        <trans-unit id="21d47d51fa3ee1bdfdfae971aec4e563a10a3e93" translate="yes" xml:space="preserve">
          <source>Since there is no natural syntax for specifying generic type parameters in Javascript, an unspecified type parameter defaults to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Поскольку в Javascript нет естественного синтаксиса для указания параметров универсального типа, для параметра неопределенного типа по умолчанию используется значение &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b322b635e697fa374578b14cb6639ca067a1c956" translate="yes" xml:space="preserve">
          <source>Since there is no way to specify optionality on parameters in pre-ES2015 Javascript, all function parameters in &lt;code&gt;.js&lt;/code&gt; file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.</source>
          <target state="translated">Поскольку в Javascript до ES2015 невозможно указать необязательность для параметров, все параметры функции в файле &lt;code&gt;.js&lt;/code&gt; считаются необязательными. Разрешены вызовы с меньшим количеством аргументов, чем заявленное количество параметров.</target>
        </trans-unit>
        <trans-unit id="1bb189160ac70073ac7ebfc075b0fbe0a1f9844a" translate="yes" xml:space="preserve">
          <source>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</source>
          <target state="translated">Так как это изменение является прерывистым,вам,возможно,понадобится знать обходные пути,которые аналогичны тем,что используются для строгой буквальной проверки объектов:</target>
        </trans-unit>
        <trans-unit id="0c990fd202f278ef0f0d7845a5a9243bf4d29dd3" translate="yes" xml:space="preserve">
          <source>Skip type checking of &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;default library declaration files&lt;/a&gt;.</source>
          <target state="translated">Пропустить проверку типов &lt;a href=&quot;triple-slash-directives#-reference-no-default-libtrue&quot;&gt;файлов объявлений библиотеки&lt;/a&gt; по умолчанию .</target>
        </trans-unit>
        <trans-unit id="12501fd6f728bd1473ea7478cbc5c3dcd63db265" translate="yes" xml:space="preserve">
          <source>Skip type checking of all declaration files (&lt;code&gt;*.d.ts&lt;/code&gt;).</source>
          <target state="translated">Пропустить проверку типа всех файлов объявлений ( &lt;code&gt;*.d.ts&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="65491f46fdafeaf0b665cd04a110e111c9391e5e" translate="yes" xml:space="preserve">
          <source>Smarter Auto-Import Syntax</source>
          <target state="translated">Умный синтаксис авто-импорта</target>
        </trans-unit>
        <trans-unit id="bb1eae075750d4a174787dc1c2252c01719c35af" translate="yes" xml:space="preserve">
          <source>Smarter union type checking</source>
          <target state="translated">Умная проверка типа союза</target>
        </trans-unit>
        <trans-unit id="679bf06653c38306e3510cb4091b394d4e625ab8" translate="yes" xml:space="preserve">
          <source>So far, we&amp;rsquo;ve used &amp;ldquo;compatible&amp;rdquo;, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from &lt;code&gt;any&lt;/code&gt;, and to and from &lt;code&gt;enum&lt;/code&gt; with corresponding numeric values.</source>
          <target state="translated">До сих пор мы использовали термин &amp;laquo;совместимый&amp;raquo;, который не определен в спецификации языка. В TypeScript есть два типа совместимости: подтип и присваивание. Они отличаются только тем, что присваивание расширяет совместимость подтипов с помощью правил, позволяющих присваивать &lt;code&gt;any&lt;/code&gt; и от любого , а также к &lt;code&gt;enum&lt;/code&gt; и от него с соответствующими числовыми значениями.</target>
        </trans-unit>
        <trans-unit id="67ef5716ef1d4255fdfc3266bf74a100eaaddc5f" translate="yes" xml:space="preserve">
          <source>So given the following input, the resulting &lt;code&gt;.js&lt;/code&gt; file will include an import to &lt;code&gt;tslib&lt;/code&gt; and use the &lt;code&gt;__assign&lt;/code&gt; helper from it instead of inlining it.</source>
          <target state="translated">Поэтому , учитывая следующий входной, полученный &lt;code&gt;.js&lt;/code&gt; файл будет включать в себя импорт в &lt;code&gt;tslib&lt;/code&gt; и использовать &lt;code&gt;__assign&lt;/code&gt; помощник из него вместо встраивания его.</target>
        </trans-unit>
        <trans-unit id="186ee8ceb588d6a258ee6dbb023a30a68c051a54" translate="yes" xml:space="preserve">
          <source>So in the above example, if we&amp;rsquo;re importing from &lt;code&gt;&quot;package-name&quot;&lt;/code&gt;, we&amp;rsquo;ll try to resolve from &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (and other relevant paths) when running in TypeScript 3.1. If we import from &lt;code&gt;package-name/foo&lt;/code&gt;, we&amp;rsquo;ll try to look for &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; and &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">Итак, в приведенном выше примере, если мы импортируем из &lt;code&gt;&quot;package-name&quot;&lt;/code&gt; , мы попытаемся разрешить из &lt;code&gt;[...]/node_modules/package-name/ts3.1/index.d.ts&lt;/code&gt; (и других соответствующих paths) при работе в TypeScript 3.1. Если мы импортируем из &lt;code&gt;package-name/foo&lt;/code&gt; , мы попытаемся найти &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo.d.ts&lt;/code&gt; и &lt;code&gt;[...]/node_modules/package-name/ts3.1/foo/index.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0d35f3444ee195674f39dbd3f6a1e50ed4c2a4e" translate="yes" xml:space="preserve">
          <source>So to exclude a file from the compilation, you need to exclude it and &lt;strong&gt;all&lt;/strong&gt; files that have an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive to it.</source>
          <target state="translated">Таким образом, чтобы исключить файл из компиляции, вам нужно исключить его и &lt;strong&gt;все&lt;/strong&gt; файлы, для которых есть директива &lt;code&gt;import&lt;/code&gt; или &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4bc2f7646ea9a289aefdb5e74620f8df8809b70" translate="yes" xml:space="preserve">
          <source>Some examples of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">Некоторые примеры функций, которые &lt;code&gt;never&lt;/code&gt; возвращаются :</target>
        </trans-unit>
        <trans-unit id="dd8e2e31e759369daed94a0bdfbe83bde2d68c4a" translate="yes" xml:space="preserve">
          <source>Some examples of use of functions returning &lt;code&gt;never&lt;/code&gt;:</source>
          <target state="translated">Некоторые примеры использования функций, &lt;code&gt;never&lt;/code&gt; возвращающих :</target>
        </trans-unit>
        <trans-unit id="ac3ff6970ef7ae26b60be3c11566e4ffed69c47e" translate="yes" xml:space="preserve">
          <source>Some examples use the &lt;code&gt;reflect-metadata&lt;/code&gt; library which adds a polyfill for an &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;experimental metadata API&lt;/a&gt;. This library is not yet part of the ECMAScript (JavaScript) standard. However, once decorators are officially adopted as part of the ECMAScript standard these extensions will be proposed for adoption.</source>
          <target state="translated">В некоторых примерах используется библиотека &lt;code&gt;reflect-metadata&lt;/code&gt; которая добавляет полифил для &lt;a href=&quot;https://github.com/rbuckton/ReflectDecorators&quot;&gt;экспериментального API метаданных&lt;/a&gt; . Эта библиотека еще не является частью стандарта ECMAScript (JavaScript). Однако, как только декораторы будут официально приняты как часть стандарта ECMAScript, эти расширения будут предложены для принятия.</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">Несколько примеров:</target>
        </trans-unit>
        <trans-unit id="7d3c07f60789aec8bf6b6718acaa48138f0167f9" translate="yes" xml:space="preserve">
          <source>Some kinds of declarations can be combined across multiple declarations. For example, &lt;code&gt;class C { }&lt;/code&gt; and &lt;code&gt;interface C { }&lt;/code&gt; can co-exist and both contribute properties to the &lt;code&gt;C&lt;/code&gt; types.</source>
          <target state="translated">Некоторые виды объявлений можно объединить в несколько объявлений. Например, &lt;code&gt;class C { }&lt;/code&gt; и &lt;code&gt;interface C { }&lt;/code&gt; могут сосуществовать, и оба вносят свой вклад в свойства типов &lt;code&gt;C&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a1a6bb7e5995629cd2728c008f6bd029c77d013" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable. For example:</source>
          <target state="translated">Некоторые библиотеки предназначены для использования во многих загрузчиках модулей или без загрузки модуля (глобальные переменные). Они известны как модули &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; . Доступ к этим библиотекам можно получить либо с помощью импорта, либо с помощью глобальной переменной. Например:</target>
        </trans-unit>
        <trans-unit id="2bd424c5780b5812c140ab0c2b98f3a8f43528b7" translate="yes" xml:space="preserve">
          <source>Some libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; or &lt;a href=&quot;http://isomorphic.net&quot;&gt;Isomorphic&lt;/a&gt; modules. These libraries can be accessed through either an import or a global variable.</source>
          <target state="translated">Некоторые библиотеки предназначены для использования во многих загрузчиках модулей или без загрузки модуля (глобальные переменные). Они известны как &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; или &lt;a href=&quot;http://isomorphic.net&quot;&gt;изоморфные&lt;/a&gt; модули. Доступ к этим библиотекам можно получить либо с помощью импорта, либо с помощью глобальной переменной.</target>
        </trans-unit>
        <trans-unit id="6d579c1b603ba9bdb7b036601db29274335578ec" translate="yes" xml:space="preserve">
          <source>Some libraries only work in a module loader environment. For example, &lt;code&gt;express&lt;/code&gt; only works in Node.js and must be loaded using the CommonJS &lt;code&gt;require&lt;/code&gt; function.</source>
          <target state="translated">Некоторые библиотеки работают только в среде загрузчика модулей. Например, &lt;code&gt;express&lt;/code&gt; работает только в Node.js и должен быть загружен с помощью функции CommonJS &lt;code&gt;require&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e9585e6951e2664b628f35bed4a5c31cb046a11" translate="yes" xml:space="preserve">
          <source>Some module loaders such as &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; allow non-JavaScript content to be imported. These typically use a prefix or suffix to indicate the special loading semantics. Wildcard module declarations can be used to cover these cases.</source>
          <target state="translated">Некоторые загрузчики модулей, такие как &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#plugin-syntax&quot;&gt;SystemJS&lt;/a&gt; и &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD,&lt;/a&gt; позволяют импортировать содержимое, отличное от JavaScript. Обычно они используют префикс или суффикс для обозначения специальной семантики загрузки. Для таких случаев можно использовать объявления модуля с подстановочными знаками.</target>
        </trans-unit>
        <trans-unit id="57331e67e5143af4a00330fcd39cdc3c6aaaac4d" translate="yes" xml:space="preserve">
          <source>Some of the unique concepts in TypeScript describe the shape of JavaScript objects at the type level. One example that is especially unique to TypeScript is the concept of &amp;lsquo;declaration merging&amp;rsquo;. Understanding this concept will give you an advantage when working with existing JavaScript. It also opens the door to more advanced abstraction concepts.</source>
          <target state="translated">Некоторые уникальные концепции TypeScript описывают форму объектов JavaScript на уровне типа. Одним из примеров, который особенно уникален для TypeScript, является концепция &amp;laquo;слияния деклараций&amp;raquo;. Понимание этой концепции даст вам преимущество при работе с существующим JavaScript. Это также открывает путь к более продвинутым концепциям абстракции.</target>
        </trans-unit>
        <trans-unit id="1e812a000ccfcbfb77656cc54a6fedc23b3ae782" translate="yes" xml:space="preserve">
          <source>Some people find it more aesthetically pleasing to create an object and add properties immediately after like so:</source>
          <target state="translated">Некоторые люди находят более эстетичным создание объекта и добавление свойств сразу после этого:</target>
        </trans-unit>
        <trans-unit id="61d584a25fe1d72715546564a21bd344b92d47a9" translate="yes" xml:space="preserve">
          <source>Some plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.</source>
          <target state="translated">Некоторые плагины добавляют или изменяют экспорт верхнего уровня на существующих модулях.В то время как в CommonJS и других загрузчиках это разрешено,модули ES6 считаются неизменяемыми,и этот шаблон будет невозможен.Так как TypeScript является загрузчиком-диагностикой,то не существует принудительного исполнения этой политики во время компиляции,но разработчики,намеревающиеся перейти на загрузчик модулей ES6,должны знать об этом.</target>
        </trans-unit>
        <trans-unit id="f160ec637dc65ea96bb1d06f7025c1b36e3fe866" translate="yes" xml:space="preserve">
          <source>Some properties should only be modifiable when an object is first created. You can specify this by putting &lt;code&gt;readonly&lt;/code&gt; before the name of the property:</source>
          <target state="translated">Некоторые свойства следует изменять только при первом создании объекта. Вы можете указать это, поставив &lt;code&gt;readonly&lt;/code&gt; перед именем свойства:</target>
        </trans-unit>
        <trans-unit id="14f44373480b1e220dbd6f17d34a63ec1dd688dd" translate="yes" xml:space="preserve">
          <source>Some readers might do a double-take at this example. The variable &lt;code&gt;x&lt;/code&gt; was declared &lt;em&gt;within the &lt;code&gt;if&lt;/code&gt; block&lt;/em&gt;, and yet we were able to access it from outside that block. That&amp;rsquo;s because &lt;code&gt;var&lt;/code&gt; declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we&amp;rsquo;ll go over later on - regardless of the containing block. Some people call this &lt;em&gt;&lt;code&gt;var&lt;/code&gt;-scoping&lt;/em&gt; or &lt;em&gt;function-scoping&lt;/em&gt;. Parameters are also function scoped.</source>
          <target state="translated">Некоторые читатели могут усомниться в этом примере. Переменная &lt;code&gt;x&lt;/code&gt; была объявлена &lt;em&gt;в блоке &lt;code&gt;if&lt;/code&gt; &lt;/em&gt; , но мы смогли получить к ней доступ извне. Это потому, что объявления &lt;code&gt;var&lt;/code&gt; доступны где угодно в пределах их содержащей функции, модуля, пространства имен или глобальной области видимости - все это мы рассмотрим позже - независимо от содержащего блока. Некоторые люди называют это &lt;em&gt; &lt;code&gt;var&lt;/code&gt; -scoping&lt;/em&gt; или &lt;em&gt;function-scoping&lt;/em&gt; . Параметры также зависят от функции.</target>
        </trans-unit>
        <trans-unit id="44fb74208e19d5dbb2c363c2964c86574d508b8b" translate="yes" xml:space="preserve">
          <source>Some teams have set up msbuild-based workflows wherein tsconfig files have the same &lt;em&gt;implicit&lt;/em&gt; graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use &lt;code&gt;msbuild&lt;/code&gt; with &lt;code&gt;tsc -p&lt;/code&gt; along with project references; these are fully interoperable.</source>
          <target state="translated">Некоторые группы настроили рабочие процессы на основе msbuild, в которых файлы tsconfig имеют тот же &lt;em&gt;неявный&lt;/em&gt; порядок графов, что и управляемые проекты, с которыми они связаны. Если ваше решение похоже на это, вы можете продолжать использовать &lt;code&gt;msbuild&lt;/code&gt; с &lt;code&gt;tsc -p&lt;/code&gt; вместе со ссылками на проекты; они полностью совместимы.</target>
        </trans-unit>
        <trans-unit id="7941e42acfe32f9735cd477a7822e4200f3733d0" translate="yes" xml:space="preserve">
          <source>Something to note is that you can still &lt;em&gt;capture&lt;/em&gt; a block-scoped variable before it&amp;rsquo;s declared. The only catch is that it&amp;rsquo;s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won&amp;rsquo;t report this as an error.</source>
          <target state="translated">Следует отметить, что вы все еще можете &lt;em&gt;захватить&lt;/em&gt; переменную с блочной областью видимости до ее объявления. Единственная загвоздка в том, что вызывать эту функцию перед объявлением запрещено. Если ориентироваться на ES2015, современная среда выполнения выдаст ошибку; однако сейчас TypeScript разрешает и не сообщает об этом как об ошибке.</target>
        </trans-unit>
        <trans-unit id="f134bb2233aae7cfa93968aca5ea244823125b9e" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">Иногда модули не находятся непосредственно под &lt;em&gt;baseUrl&lt;/em&gt; . Например, импорт в модуль &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; будет преобразован во время выполнения в &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; . Погрузчики использовать конфигурацию отображения для отображения имен модулей к файлам во время выполнения, см &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs документации&lt;/a&gt; и &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#paths&quot;&gt;SystemJS документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d6951e5cd812b979ec00d7377ad9486c476e4ffe" translate="yes" xml:space="preserve">
          <source>Sometimes modules are not directly located under &lt;em&gt;baseUrl&lt;/em&gt;. Loaders use a mapping configuration to map module names to files at run-time, see &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs documentation&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS documentation&lt;/a&gt;.</source>
          <target state="translated">Иногда модули не находятся непосредственно под &lt;em&gt;baseUrl&lt;/em&gt; . Погрузчики использовать конфигурацию отображения для отображения имен модулей к файлам во время выполнения, см &lt;a href=&quot;http://requirejs.org/docs/api.html#config-paths&quot;&gt;RequireJs документации&lt;/a&gt; и &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/overview.html#map-config&quot;&gt;SystemJS документации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2126d1615e0f1485e19b5a56e2155fedd9cc145" translate="yes" xml:space="preserve">
          <source>Sometimes the project sources from multiple directories at compile time are all combined to generate a single output directory. This can be viewed as a set of source directories create a &amp;ldquo;virtual&amp;rdquo; directory.</source>
          <target state="translated">Иногда исходники проекта из нескольких каталогов во время компиляции объединяются для создания единого выходного каталога. Это можно рассматривать как набор исходных каталогов, создающих &amp;laquo;виртуальный&amp;raquo; каталог.</target>
        </trans-unit>
        <trans-unit id="57ffb77d1046760098ea81054624979437671ba8" translate="yes" xml:space="preserve">
          <source>Sometimes this is not desirable, for instance inputs &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; and &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; would result in output structure mirroring &lt;code&gt;FolderA\FolderB\&lt;/code&gt;. Now if a new file &lt;code&gt;FolderA\3.ts&lt;/code&gt; is added to the input, the output structure will pop out to mirror &lt;code&gt;FolderA\&lt;/code&gt;.</source>
          <target state="translated">Иногда это нежелательно, например, входы &lt;code&gt;FolderA\FolderB\1.ts&lt;/code&gt; и &lt;code&gt;FolderA\FolderB\2.ts&lt;/code&gt; приведут к зеркалированию структуры вывода &lt;code&gt;FolderA\FolderB\&lt;/code&gt; . Теперь, если новый файл &lt;code&gt;FolderA\3.ts&lt;/code&gt; добавлен во входные данные, структура вывода будет &lt;code&gt;FolderA\&lt;/code&gt; зеркало FolderA \ .</target>
        </trans-unit>
        <trans-unit id="1373cee6ce1e5c912f9c7dad28055e7d5d1067f6" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll end up in a situation where you&amp;rsquo;ll know more about a value than TypeScript does. Usually this will happen when you know the type of some entity could be more specific than its current type.</source>
          <target state="translated">Иногда вы попадете в ситуацию, когда вы будете знать о значении больше, чем TypeScript. Обычно это происходит, когда вы знаете, что тип некоторой сущности может быть более конкретным, чем ее текущий тип.</target>
        </trans-unit>
        <trans-unit id="55d18b2ee923c4bc6bb19412ab2b08a75f6ca271" translate="yes" xml:space="preserve">
          <source>Sometimes you&amp;rsquo;ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:</source>
          <target state="translated">Иногда вы полностью перезаписываете объект экспорта. Это обычный шаблон, который люди используют для немедленного вызова своих модулей, как в этом фрагменте:</target>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="a641ebcd0020283fedd21072f7904f9b73d7b789" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate TypeScript files instead of source locations. Use this flag if the sources will be located at run-time in a different location than that at design-time. The location specified will be embedded in the sourceMap to direct the debugger where the source files will be located.</source>
          <target state="translated">Указывает место,где отладчик должен найти файлы TypeScript вместо исходных.Используйте этот флаг,если исходные тексты будут находиться во время исполнения в другом месте,нежели во время проектирования.Указанное место будет встроено в sourceMap,чтобы направить отладчик туда,где будут находиться исходные файлы.</target>
        </trans-unit>
        <trans-unit id="1c2da7a5fc698b5da97db9b13fe3154907aad09d" translate="yes" xml:space="preserve">
          <source>Specifies the location where debugger should locate map files instead of generated locations. Use this flag if the .map files will be located at run-time in a different location than the .js files. The location specified will be embedded in the sourceMap to direct the debugger where the map files will be located. This flag will not create the specified path and generate the map files in that location. Instead, create a post build step that moves the files to the specified path.</source>
          <target state="translated">Указывает место,где отладчик должен располагать картографические файлы вместо сгенерированных местоположений.Используйте этот флаг,если файлы .map будут расположены во время выполнения в другом месте,нежели .js файлы.Указанное место будет встроено в sourceMap,чтобы указать отладчику,где будут находиться картографические файлы.Этот флаг не будет создавать указанный путь и генерировать файлы карты в этом месте.Вместо этого создайте шаг пост-строки,который перемещает файлы по указанному пути.</target>
        </trans-unit>
        <trans-unit id="794dd3dcf9665f5b582a96a912c3cb49b4c72f8a" translate="yes" xml:space="preserve">
          <source>Specifies the object invoked for &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; when targeting &lt;code&gt;&quot;react&quot;&lt;/code&gt; JSX emit.</source>
          <target state="translated">Определяет объект, вызываемый для &lt;code&gt;createElement&lt;/code&gt; и &lt;code&gt;__spread&lt;/code&gt; при нацеливании на &lt;code&gt;&quot;react&quot;&lt;/code&gt; отправку JSX.</target>
        </trans-unit>
        <trans-unit id="87746b728ea4f460f7202426ccc6c557238e85b3" translate="yes" xml:space="preserve">
          <source>Specifies the root directory of input files. Only use to control the output directory structure with &lt;code&gt;--outDir&lt;/code&gt;.</source>
          <target state="translated">Задает корневой каталог входных файлов. Используйте только для управления структурой выходного каталога с помощью &lt;code&gt;--outDir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f3b79249d834c08c2bb8f8527cca3825f4ecc15" translate="yes" xml:space="preserve">
          <source>Specify &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; to disable automatic inclusion of &lt;code&gt;@types&lt;/code&gt; packages.</source>
          <target state="translated">Укажите &lt;code&gt;&quot;types&quot;: []&lt;/code&gt; чтобы отключить автоматическое включение пакетов &lt;code&gt;@types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04e339988f7084fdc3b9871407ec6d486b9796f2" translate="yes" xml:space="preserve">
          <source>Specify ECMAScript target version:</source>
          <target state="translated">Укажите целевую версию ECMAScript:</target>
        </trans-unit>
        <trans-unit id="22bae6477e590560d376f1ca2a920f0f7137f9ff" translate="yes" xml:space="preserve">
          <source>Specify module code generation: &lt;code&gt;&quot;None&quot;&lt;/code&gt;, &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt;, &lt;code&gt;&quot;AMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;UMD&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES6&quot;&lt;/code&gt;, &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;.</source>
          <target state="translated">Укажите генерацию кода модуля: &lt;code&gt;&quot;None&quot;&lt;/code&gt; , &lt;code&gt;&quot;CommonJS&quot;&lt;/code&gt; , &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; , &lt;code&gt;&quot;System&quot;&lt;/code&gt; , &lt;code&gt;&quot;UMD&quot;&lt;/code&gt; , &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; , &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; или &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f17fc5b5e06de09269af8bc9bf5322fe97b5fb06" translate="yes" xml:space="preserve">
          <source>Specify the JSX factory function to use when targeting react JSX emit, e.g. &lt;code&gt;React.createElement&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;.</source>
          <target state="translated">Укажите фабричную функцию JSX для использования при нацеливании на испускание &lt;code&gt;React.createElement&lt;/code&gt; JSX, например React.createElement или &lt;code&gt;h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26252f00b41f16be2c212af5b97551e657c2f43c" translate="yes" xml:space="preserve">
          <source>Specify what file to store incremental build information in.</source>
          <target state="translated">Укажите,в каком файле хранить информацию об инкрементной сборке.</target>
        </trans-unit>
        <trans-unit id="5b0ffc462bd014144a57832b75b37bec6b627992" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--outFile&lt;/code&gt; in conjunction with &lt;code&gt;--module amd&lt;/code&gt; or &lt;code&gt;--module system&lt;/code&gt; will concatenate all modules in the compilation into a single output file containing multiple module closures.</source>
          <target state="translated">Указание &lt;code&gt;--outFile&lt;/code&gt; в сочетании с &lt;code&gt;--module amd&lt;/code&gt; или &lt;code&gt;--module system&lt;/code&gt; объединит все модули в компиляции в один выходной файл, содержащий несколько закрытий модулей.</target>
        </trans-unit>
        <trans-unit id="ecac73aab16df45bc37442b177ade411f7d911ae" translate="yes" xml:space="preserve">
          <source>Specifying the type of &lt;code&gt;this&lt;/code&gt; for functions</source>
          <target state="translated">Указание типа &lt;code&gt;this&lt;/code&gt; для функций</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">Улучшение скорости</target>
        </trans-unit>
        <trans-unit id="57c7cf9d2a0cafdf74f389b4d473eed903a50706" translate="yes" xml:space="preserve">
          <source>Splitting Across Files</source>
          <target state="translated">Разделение файлов по разделам</target>
        </trans-unit>
        <trans-unit id="2bde101117a83786a9fe359d813c1badf4a6b2ee" translate="yes" xml:space="preserve">
          <source>Spread</source>
          <target state="translated">Spread</target>
        </trans-unit>
        <trans-unit id="e52ae13e940c439690285391dab1a0051b0c2e04" translate="yes" xml:space="preserve">
          <source>Spread expressions with tuple types</source>
          <target state="translated">Распространение выражений с типами кортежей</target>
        </trans-unit>
        <trans-unit id="d6ace75d8be9881329b05b54b6dc429938f458c6" translate="yes" xml:space="preserve">
          <source>Stable packages are available here:</source>
          <target state="translated">Стабильные пакеты доступны здесь:</target>
        </trans-unit>
        <trans-unit id="457a8825cdb8efe6f8ed3954625c3f151b370bc9" translate="yes" xml:space="preserve">
          <source>Starting TypeScript 2.9 errors are displayed under &lt;code&gt;--pretty&lt;/code&gt; by default if the output device is applicable for colorful text. TypeScript will check if the output steam has &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt;&lt;code&gt;isTty&lt;/code&gt;&lt;/a&gt; property set.</source>
          <target state="translated">Ошибки &lt;code&gt;--pretty&lt;/code&gt; TypeScript 2.9 по умолчанию отображаются в разделе --pretty , если устройство вывода применимо для цветного текста. TypeScript проверит, установлено &lt;a href=&quot;https://nodejs.org/api/tty.html&quot;&gt; &lt;code&gt;isTty&lt;/code&gt; &lt;/a&gt; свойство isTty для выходного пара .</target>
        </trans-unit>
        <trans-unit id="e1bd71f28dac9f8b9839f2877d980ac89846a470" translate="yes" xml:space="preserve">
          <source>Starting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting &amp;lsquo;commonjs&amp;rsquo;. These &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;rules&lt;/a&gt; attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using &lt;code&gt;--moduleResolution&lt;/code&gt; command line option. Possible values are:</source>
          <target state="translated">Начиная с версии 1.6 компилятор TypeScript будет использовать другой набор правил для разрешения имен модулей при нацеливании на commonjs. Эти &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2338&quot;&gt;правила&lt;/a&gt; пытались смоделировать процедуру поиска модуля, используемую Node. Это фактически означает, что модули узлов могут включать информацию о своих типах, и компилятор TypeScript сможет ее найти. Однако пользователь может переопределить правила разрешения модулей, выбранные компилятором, используя параметр командной строки &lt;code&gt;--moduleResolution&lt;/code&gt; . Возможные значения:</target>
        </trans-unit>
        <trans-unit id="e863c718db915f2f4b58c523e97d4f07d5237232" translate="yes" xml:space="preserve">
          <source>Starting out</source>
          <target state="translated">Начало работы</target>
        </trans-unit>
        <trans-unit id="27ba7e115de3bfd5bf5dc01034bb164d0740a437" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; is a primitive data type, just like &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Начиная с ECMAScript 2015, &lt;code&gt;symbol&lt;/code&gt; является примитивным типом данных, как &lt;code&gt;number&lt;/code&gt; и &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d9af76ba0d605e072032df04742ab0cf02228b" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, JavaScript has a concept of modules. TypeScript shares this concept.</source>
          <target state="translated">Начиная с ECMAScript 2015,JavaScript имеет концепцию модулей.TypeScript разделяет это понятие.</target>
        </trans-unit>
        <trans-unit id="afc8e56cf364b15c88268122ccbfe29a39ca7ca5" translate="yes" xml:space="preserve">
          <source>Starting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.</source>
          <target state="translated">Начиная с ECMAScript 2015,модули являются родной частью языка и должны поддерживаться всеми совместимыми реализациями движков.Таким образом,для новых проектов модулями будет рекомендован механизм организации кода.</target>
        </trans-unit>
        <trans-unit id="51e38a40604a0a2de5e2d000abadb800295b34df" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8, official NuGet packages are available for the Typescript Compiler (&lt;code&gt;tsc.exe&lt;/code&gt;) as well as the MSBuild integration (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; and &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt;).</source>
          <target state="translated">Начиная с TypeScript 1.8, официальные пакеты NuGet доступны для компилятора &lt;code&gt;tsc.exe&lt;/code&gt; ( tsc.exe ), а также для интеграции с MSBuild ( &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; и &lt;code&gt;Microsoft.TypeScript.Tasks.dll&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe907641294d4a842173702363c42ee105d23f56" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 1.8:</source>
          <target state="translated">Начиная с TypeScript 1.8:</target>
        </trans-unit>
        <trans-unit id="667eaed082674a988c7fa4d7c4bc04735599c26c" translate="yes" xml:space="preserve">
          <source>Starting with TypeScript 2.3, the default &lt;code&gt;tsconfig.json&lt;/code&gt; generated by &lt;code&gt;tsc --init&lt;/code&gt; includes a &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; setting in the &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; section. Thus, new projects started with &lt;code&gt;tsc --init&lt;/code&gt; will by default have the highest level of type safety enabled.</source>
          <target state="translated">Начиная с TypeScript 2.3, по умолчанию &lt;code&gt;tsconfig.json&lt;/code&gt; , сгенерированный &lt;code&gt;tsc --init&lt;/code&gt; , включает параметр &lt;code&gt;&quot;strict&quot;: true&lt;/code&gt; в разделе &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; . Таким образом, в новых проектах, запущенных с &lt;code&gt;tsc --init&lt;/code&gt; , по умолчанию будет включен самый высокий уровень безопасности типов.</target>
        </trans-unit>
        <trans-unit id="3b2ba1ad0dec7805611669102a4687a54df4fb4a" translate="yes" xml:space="preserve">
          <source>Statements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;throw&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt; or &lt;code&gt;continue&lt;/code&gt; statements are considered unreachable. Use &lt;code&gt;--allowUnreachableCode&lt;/code&gt; to disable unreachable code detection and reporting.</source>
          <target state="translated">Операторы, которые гарантированно не будут выполнены во время выполнения, теперь правильно помечаются как недостижимые ошибки кода. Например, операторы, следующие за операторами безусловного &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;throw&lt;/code&gt; , &lt;code&gt;break&lt;/code&gt; или &lt;code&gt;continue&lt;/code&gt; , считаются недостижимыми. Используйте &lt;code&gt;--allowUnreachableCode&lt;/code&gt; , чтобы отключить обнаружение недоступного кода и создание отчетов.</target>
        </trans-unit>
        <trans-unit id="5dd52f62e1be6f918ab77a38268c4534241ce617" translate="yes" xml:space="preserve">
          <source>Static Properties</source>
          <target state="translated">Статические свойства</target>
        </trans-unit>
        <trans-unit id="8c4de2a053d6fce41e20676b11e60a8bda4be893" translate="yes" xml:space="preserve">
          <source>Static methods on an exported class have a similar problem - the class itself adds a layer of nesting. Unless it increases expressivity or intent in a clearly useful way, consider simply exporting a helper function.</source>
          <target state="translated">Статические методы на экспортируемом классе имеют аналогичную проблему-сам класс добавляет слой вложенности.Если только это не увеличивает экспрессивность или намерение явно полезным способом,рассмотрим вариант простого экспорта вспомогательной функции.</target>
        </trans-unit>
        <trans-unit id="e056817fe3841123d274840f9970929fd1661955" translate="yes" xml:space="preserve">
          <source>StaticZipCodeValidator.ts</source>
          <target state="translated">StaticZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="876f3e0202ca40dedf2e5ab6577eba1ae637fb53" translate="yes" xml:space="preserve">
          <source>Strategies</source>
          <target state="translated">Strategies</target>
        </trans-unit>
        <trans-unit id="b24ced1a6bde1cad399359d1809b17476b8956ce" translate="yes" xml:space="preserve">
          <source>Strict &lt;code&gt;null&lt;/code&gt; &amp;amp; &lt;code&gt;undefined&lt;/code&gt; Checks</source>
          <target state="translated">Строгие &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; проверки</target>
        </trans-unit>
        <trans-unit id="ba990120d287758ccaffce7420f0d37783310854" translate="yes" xml:space="preserve">
          <source>Strict Class Initialization</source>
          <target state="translated">Строгая классовая инициализация</target>
        </trans-unit>
        <trans-unit id="e8a4e48ac15ba59cbf4a0e834cf82e7a56d1dc79" translate="yes" xml:space="preserve">
          <source>Strict contravariance for callback parameters</source>
          <target state="translated">Строгое противоречие для параметров обратного вызова</target>
        </trans-unit>
        <trans-unit id="8236c998ec2e20c7b6ba2fbd2308a5a59e458fff" translate="yes" xml:space="preserve">
          <source>Strict function types</source>
          <target state="translated">Типы строгих функций</target>
        </trans-unit>
        <trans-unit id="503ce04e3c451abd56d5c6cc0eeb1f004a6a9b01" translate="yes" xml:space="preserve">
          <source>Stricter Generators</source>
          <target state="translated">Более строгие генераторы</target>
        </trans-unit>
        <trans-unit id="ac111df4e339d358e1192621e12afb377c50ec08" translate="yes" xml:space="preserve">
          <source>Stricter Generics</source>
          <target state="translated">Более строгие общие черты</target>
        </trans-unit>
        <trans-unit id="7c1c37e677884ed5162824f92bf4ac0323765899" translate="yes" xml:space="preserve">
          <source>Stricter checking for generic functions</source>
          <target state="translated">Более строгая проверка общих функций</target>
        </trans-unit>
        <trans-unit id="59d7c0445a12d3c38c6410a065795f30dedb9910" translate="yes" xml:space="preserve">
          <source>Stricter object literal assignment checks</source>
          <target state="translated">Более строгие проверки буквального назначения объектов</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="d38945e9d63e72217f1ff6e3be1ea79fbfff3091" translate="yes" xml:space="preserve">
          <source>String Enums</source>
          <target state="translated">Строковые перечню</target>
        </trans-unit>
        <trans-unit id="b9ee8e1a51d8d2f14d5767f34ddd3e68f008e59a" translate="yes" xml:space="preserve">
          <source>String Literal Types</source>
          <target state="translated">Буквальные типы строк</target>
        </trans-unit>
        <trans-unit id="ffa12823a95532beb06727f353cfba4e754b5e99" translate="yes" xml:space="preserve">
          <source>String enums</source>
          <target state="translated">Струнные перечисления</target>
        </trans-unit>
        <trans-unit id="135b4e07f53722d425681f40b44219a30c502379" translate="yes" xml:space="preserve">
          <source>String enums are a similar concept, but have some subtle &lt;a href=&quot;#enums-at-runtime&quot;&gt;runtime differences&lt;/a&gt; as documented below. In a string enum, each member has to be constant-initialized with a string literal, or with another string enum member.</source>
          <target state="translated">Перечисления строк представляют собой аналогичную концепцию, но имеют некоторые тонкие &lt;a href=&quot;#enums-at-runtime&quot;&gt;различия во время выполнения,&lt;/a&gt; как описано ниже. В строковом перечислении каждый член должен быть инициализирован константой строковым литералом или другим строковым членом перечисления.</target>
        </trans-unit>
        <trans-unit id="97ca47845b6de917d6acef338327258499a5fa14" translate="yes" xml:space="preserve">
          <source>String literal types</source>
          <target state="translated">Типы струнных букв</target>
        </trans-unit>
        <trans-unit id="3094f1d45b3a85252ec82b4f2621aa324f1df082" translate="yes" xml:space="preserve">
          <source>String literal types allow you to specify the exact value a string must have. In practice string literal types combine nicely with union types, type guards, and type aliases. You can use these features together to get enum-like behavior with strings.</source>
          <target state="translated">Типы строковых литералов позволяют указать точное значение,которое должна иметь строка.На практике строковые типы литералов прекрасно сочетаются с союзными типами,защитниками типов и псевдонимами типов.Вы можете использовать эти возможности вместе,чтобы получить enum-подобное поведение со строками.</target>
        </trans-unit>
        <trans-unit id="b874e7e8ff440bab9b01a84543e1af14d5b4bb4b" translate="yes" xml:space="preserve">
          <source>String literal types can be used in the same way to distinguish overloads:</source>
          <target state="translated">Типы строковых литералов могут быть использованы таким же образом,чтобы различать перегрузки:</target>
        </trans-unit>
        <trans-unit id="46e91541a55f18468fd6b067383aaa97a9e64cd2" translate="yes" xml:space="preserve">
          <source>String, numeric and boolean literal types (e.g. &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt;) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are &lt;em&gt;always&lt;/em&gt; inferred for &lt;code&gt;const&lt;/code&gt; variables and &lt;code&gt;readonly&lt;/code&gt; properties.</source>
          <target state="translated">Строковые, числовые и логические типы литералов (например, &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;true&lt;/code&gt; ) ранее выводились только при наличии явной аннотации типа. Начиная с TypeScript 2.1, буквенные типы &lt;em&gt;всегда&lt;/em&gt; выводятся для &lt;code&gt;const&lt;/code&gt; переменных и свойств только для &lt;code&gt;readonly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d8fecbc84175a2cda5fcb984cf28bdb9e9fe54b" translate="yes" xml:space="preserve">
          <source>String-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.</source>
          <target state="translated">Свойствами,подобными строковому типу объекта,являются свойства,объявленные с помощью идентификатора,строкового литерала или вычисленного имени свойства типа строкового литерала.</target>
        </trans-unit>
        <trans-unit id="f44c134a9d7c63d1a602a14744e321854b363720" translate="yes" xml:space="preserve">
          <source>StringValidator.ts</source>
          <target state="translated">StringValidator.ts</target>
        </trans-unit>
        <trans-unit id="e9e5d94110d726b2fb48e7030cec7299992b6e0c" translate="yes" xml:space="preserve">
          <source>Structurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).</source>
          <target state="translated">Структурно идентичные,но отличные,классовые типы теперь сохраняются в союзных типах (вместо того,чтобы ликвидировать все,кроме одного).</target>
        </trans-unit>
        <trans-unit id="f188cd9e1081421f05e7530e5be35f73639cddfb" translate="yes" xml:space="preserve">
          <source>Structuring for outFiles</source>
          <target state="translated">Структурирование для outFiles</target>
        </trans-unit>
        <trans-unit id="9790ea759cfc56e0057f75d2b47d5dd9230cb97d" translate="yes" xml:space="preserve">
          <source>Structuring for relative modules</source>
          <target state="translated">Структурирование для относительных модулей</target>
        </trans-unit>
        <trans-unit id="28a732981a8711b19d230aaecb27b43ddf871667" translate="yes" xml:space="preserve">
          <source>Structuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without &lt;code&gt;new&lt;/code&gt; to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.</source>
          <target state="translated">Структурирование модулей для получения точной формы API, которую вы хотите, может быть сложной задачей. Например, нам может потребоваться модуль, который может быть вызван с &lt;code&gt;new&lt;/code&gt; или без него для создания различных типов, имеет множество именованных типов, представленных в иерархии, а также имеет некоторые свойства объекта модуля.</target>
        </trans-unit>
        <trans-unit id="426c20ffe12820a1c17c8b53aa917b10b06fc64e" translate="yes" xml:space="preserve">
          <source>Stylize errors and messages using color and context.</source>
          <target state="translated">Стилизируйте ошибки и сообщения,используя цвет и контекст.</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">Великолепный Текст</target>
        </trans-unit>
        <trans-unit id="89f541951e4630b0519550eb0b55d466b60ae9d9" translate="yes" xml:space="preserve">
          <source>Subtype vs Assignment</source>
          <target state="translated">Подтип против Присвоения</target>
        </trans-unit>
        <trans-unit id="18532a66f85c71ab4aec069080bab114bcb593de" translate="yes" xml:space="preserve">
          <source>Support &amp;lsquo;target : es5&amp;rsquo; with &amp;lsquo;module: es6&amp;rsquo;</source>
          <target state="translated">Поддержка 'target: es5' с 'module: es6'</target>
        </trans-unit>
        <trans-unit id="cf4b3d9e87de6d08216090fd0a299f43489307ab" translate="yes" xml:space="preserve">
          <source>Support &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties with &lt;code&gt;keyof&lt;/code&gt; and mapped types</source>
          <target state="translated">Поддержка свойств с &lt;code&gt;keyof&lt;/code&gt; &lt;code&gt;number&lt;/code&gt; и &lt;code&gt;symbol&lt;/code&gt; с типами keyof и mapped</target>
        </trans-unit>
        <trans-unit id="6d6731f9d93089d17da6ccec6778d165fccc26c7" translate="yes" xml:space="preserve">
          <source>Support JSX in &lt;code&gt;.tsx&lt;/code&gt; files: &lt;code&gt;&quot;react&quot;&lt;/code&gt;, &lt;code&gt;&quot;preserve&quot;&lt;/code&gt;, &lt;code&gt;&quot;react-native&quot;&lt;/code&gt;. See &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt;.</source>
          <target state="translated">Поддержка JSX в файлах &lt;code&gt;.tsx&lt;/code&gt; : &lt;code&gt;&quot;react&quot;&lt;/code&gt; , &lt;code&gt;&quot;preserve&quot;&lt;/code&gt; , &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; нативно &amp;raquo; . См. &lt;a href=&quot;jsx&quot;&gt;JSX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05b310d45d1a230630edd11c6875345ecb5c8f86" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES2016&lt;/code&gt;, &lt;code&gt;--target ES2017&lt;/code&gt; and &lt;code&gt;--target ESNext&lt;/code&gt;</source>
          <target state="translated">Поддержка &lt;code&gt;--target ES2016&lt;/code&gt; , &lt;code&gt;--target ES2017&lt;/code&gt; и &lt;code&gt;--target ESNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b4ca504fdd62c03cb94726f4bcaf5058e435b4" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;--target ES6&lt;/code&gt; with &lt;code&gt;--module&lt;/code&gt;</source>
          <target state="translated">Поддержка &lt;code&gt;--target ES6&lt;/code&gt; с &lt;code&gt;--module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34617739aff3f3e46b1e4ba3a7911e40d6c81ab3" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;UMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; module output</source>
          <target state="translated">Поддержка вывода &lt;code&gt;UMD&lt;/code&gt; и &lt;code&gt;System&lt;/code&gt; модуля</target>
        </trans-unit>
        <trans-unit id="28e272a817a6f695cb0b07fe3c763c51df093f79" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;default&lt;/code&gt; import interop with SystemJS</source>
          <target state="translated">Поддержка взаимодействия импорта по &lt;code&gt;default&lt;/code&gt; с SystemJS</target>
        </trans-unit>
        <trans-unit id="d6916bf8e4e9fcc67b553b85f533341a04a63081" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;defaultProps&lt;/code&gt; in JSX</source>
          <target state="translated">Поддержка &lt;code&gt;defaultProps&lt;/code&gt; в JSX</target>
        </trans-unit>
        <trans-unit id="bddb6099cc8b06729d2beaa2fa82e1cb4963256d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; from CommonJS modules with &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">Поддержка &lt;code&gt;import d from &quot;cjs&quot;&lt;/code&gt; из модулей CommonJS с &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2447881f3dbb81c3d00bf540954383e26e79f16a" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;import.meta&lt;/code&gt;</source>
          <target state="translated">Поддержка &lt;code&gt;import.meta&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b85ac71ca924b44b00a2baf8d735c1f5146eae50" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;new.target&lt;/code&gt;</source>
          <target state="translated">Поддержка &lt;code&gt;new.target&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73d8dfa99384426433e9eb5bd0a25014a68b93dd" translate="yes" xml:space="preserve">
          <source>Support for Mix-in classes</source>
          <target state="translated">Поддержка классов Mix-in</target>
        </trans-unit>
        <trans-unit id="4cd188d2034c82b0cb13c97514a09e1296c575c1" translate="yes" xml:space="preserve">
          <source>Support for UMD module definitions</source>
          <target state="translated">Поддержка определений модулей UMD</target>
        </trans-unit>
        <trans-unit id="3f9527e099215a371571a39ed0291c0f01e1252f" translate="yes" xml:space="preserve">
          <source>Support for decorators when targeting ES3</source>
          <target state="translated">Поддержка декораторов при нацеливании на ES3</target>
        </trans-unit>
        <trans-unit id="773f4a6085e5e29b6090e773de66d818050ad310" translate="yes" xml:space="preserve">
          <source>Support for external helpers library (&lt;code&gt;tslib&lt;/code&gt;)</source>
          <target state="translated">Поддержка библиотеки внешних помощников ( &lt;code&gt;tslib&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="90086da7e4d9c7c72a78d492416302a2bce77eea" translate="yes" xml:space="preserve">
          <source>Support for plain JavaScript files (using &lt;code&gt;allowJS&lt;/code&gt; and optionally &lt;code&gt;checkJs&lt;/code&gt;)</source>
          <target state="translated">Поддержка простых файлов JavaScript (с использованием &lt;code&gt;allowJS&lt;/code&gt; и, возможно, &lt;code&gt;checkJs&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="db578fdb1495d83a80100aad5eef2fff1a254e97" translate="yes" xml:space="preserve">
          <source>Support for spread operator on JSX element children</source>
          <target state="translated">Поддержка оператора спреда на детях JSX-элементов</target>
        </trans-unit>
        <trans-unit id="2653012ad53a3216b4b35967a5d2774aa99160ca" translate="yes" xml:space="preserve">
          <source>Support output to IPC-driven files</source>
          <target state="translated">Поддержка вывода в IPC-управляемых файлов</target>
        </trans-unit>
        <trans-unit id="620a93c5c9f58f502218f8fc7b12158f1027565c" translate="yes" xml:space="preserve">
          <source>Supported JSDoc</source>
          <target state="translated">Поддерживаемый JSDoc</target>
        </trans-unit>
        <trans-unit id="6ec78feed2dab45d29186124c86cf373749a2a02" translate="yes" xml:space="preserve">
          <source>Suppress &lt;code&gt;--noImplicitAny&lt;/code&gt; errors for indexing objects lacking index signatures. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;issue #1232&lt;/a&gt; for more details.</source>
          <target state="translated">Подавить &lt;code&gt;--noImplicitAny&lt;/code&gt; ошибки при индексировании объектов без подписи индекса. Подробнее см. В &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1232#issuecomment-64510362&quot;&gt;выпуске № 1232&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="338998f043c7ad5149421a96548321599b5d11bd" translate="yes" xml:space="preserve">
          <source>Suppress errors in .ts files using &amp;lsquo;// @ts-ignore&amp;rsquo; comments</source>
          <target state="translated">Подавление ошибок в файлах .ts с помощью комментариев '// @ ts-ignore'</target>
        </trans-unit>
        <trans-unit id="8973ef81aed840ec50c9cd093b51f775080b1cf7" translate="yes" xml:space="preserve">
          <source>Suppress excess property checks for object literals.</source>
          <target state="translated">Подавить проверку избыточного имущества для буквенных обозначений объектов.</target>
        </trans-unit>
        <trans-unit id="3585e72f4611a04509e6e0fc987893b8915a495f" translate="yes" xml:space="preserve">
          <source>Symbol-like properties of an object type are those declared using a computed property name of a unique symbol type.</source>
          <target state="translated">Символоподобными свойствами типа объекта являются свойства,объявленные с помощью вычисленного имени свойства уникального символьного типа.</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="53fd75a5e5e2b34489476f4ecd50211e84205baf" translate="yes" xml:space="preserve">
          <source>Symbols are immutable, and unique.</source>
          <target state="translated">Символы неизменны и уникальны.</target>
        </trans-unit>
        <trans-unit id="0bed88fc8e0305dee9b7427dfb28c60dd6df7d7b" translate="yes" xml:space="preserve">
          <source>Symbols can also be combined with computed property declarations to declare object properties and class members.</source>
          <target state="translated">Символы также могут быть объединены с вычисленными объявлениями свойств для объявления свойств объекта и членов класса.</target>
        </trans-unit>
        <trans-unit id="7c6dc245d5de42731e89891927ee10ddf6d43590" translate="yes" xml:space="preserve">
          <source>Symbols: match</source>
          <target state="translated">Символы:совпадение</target>
        </trans-unit>
        <trans-unit id="43536b93399f1c157500ef28d7217046b25bc3c7" translate="yes" xml:space="preserve">
          <source>Symbols: split</source>
          <target state="translated">Символы:раскол</target>
        </trans-unit>
        <trans-unit id="57405c7f4b3b71908ae936ac8bf9b21de6ae98b8" translate="yes" xml:space="preserve">
          <source>System SimpleModule.js</source>
          <target state="translated">Система SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="058f3d3687346d631d12546d9aade907ff39e99c" translate="yes" xml:space="preserve">
          <source>System modules have this flag on by default.</source>
          <target state="translated">По умолчанию системные модули имеют этот флаг.</target>
        </trans-unit>
        <trans-unit id="ab624ca73eb89a17acc6188413b3be19da770c27" translate="yes" xml:space="preserve">
          <source>TS for Functional Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07673a3de2879cfe1db52c3e95c21b5cff20a04e" translate="yes" xml:space="preserve">
          <source>TS for Java/C# Programmers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5625ebb46a7cebb6fe457d6cbe88c67e28246af" translate="yes" xml:space="preserve">
          <source>TS for the New Programmer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3faa3a6af48373d85bf84403340df39a4e0870f" translate="yes" xml:space="preserve">
          <source>TSConfig Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">Содержание</target>
        </trans-unit>
        <trans-unit id="1a428989bd13dceabd89b698d9fa38eb8a0d175c" translate="yes" xml:space="preserve">
          <source>Table of contents</source>
          <target state="translated">Оглавление</target>
        </trans-unit>
        <trans-unit id="f228b75e57f130e745a665c5ce1b42328c6dfd98" translate="yes" xml:space="preserve">
          <source>Tagged template strings in ES3/ES5</source>
          <target state="translated">Помеченные строки шаблонов в ES3/ES5</target>
        </trans-unit>
        <trans-unit id="fab887d80b08c2be61de81a5b5b7c7f5fa4679ed" translate="yes" xml:space="preserve">
          <source>Tagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.</source>
          <target state="translated">Шаблоны с метками-это форма вызова,введенная в ECMAScript 2015.Как и выражения вызова,общие функции могут быть использованы в шаблоне с тегами,а TypeScript будет выводить аргументы типа.</target>
        </trans-unit>
        <trans-unit id="2b4f32e1493a8fa164f90de2c9603dab9f3396aa" translate="yes" xml:space="preserve">
          <source>Tagged union types</source>
          <target state="translated">Отмеченные типы соединений</target>
        </trans-unit>
        <trans-unit id="ef15d77ea17c2fa0aa9a4dc5193a61bfca293a68" translate="yes" xml:space="preserve">
          <source>Take a quick second to guess what the output of the following snippet is:</source>
          <target state="translated">Угадайте на секунду,что получится из следующего фрагмента:</target>
        </trans-unit>
        <trans-unit id="62ec74968326eeada16e680490be28b9d097cf14" translate="yes" xml:space="preserve">
          <source>Targeting ECMAScript 2015 and higher</source>
          <target state="translated">Целевое задание ECMAScript 2015 и выше</target>
        </trans-unit>
        <trans-unit id="2bb2a353dcf3f98e351b8a5bd43ad7b5855fbf44" translate="yes" xml:space="preserve">
          <source>Targeting ES5 and ES3</source>
          <target state="translated">Нацеливание на ES5 и ES3</target>
        </trans-unit>
        <trans-unit id="8ebc171caef41add998a541b54fac3e9f04d8a0f" translate="yes" xml:space="preserve">
          <source>Technically enums can be mixed with string and numeric members, but it&amp;rsquo;s not clear why you would ever want to do so:</source>
          <target state="translated">Технически перечисления можно смешивать со строковыми и числовыми членами, но непонятно, зачем вам это нужно:</target>
        </trans-unit>
        <trans-unit id="3ec1ae061c27325c7ecb543adf91235e22cbc9ed" translate="yes" xml:space="preserve">
          <source>Template</source>
          <target state="translated">Template</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes" xml:space="preserve">
          <source>Template strings</source>
          <target state="translated">Строки шаблона</target>
        </trans-unit>
        <trans-unit id="f25b700ed9f092123a43acb205a6869342cf9dd6" translate="yes" xml:space="preserve">
          <source>Templates</source>
          <target state="translated">Templates</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="c2e85441e7a65630aa9248ad72623a3bd8be6e63" translate="yes" xml:space="preserve">
          <source>Test the page by running gulp and then opening &lt;code&gt;dist/index.html&lt;/code&gt; in a browser. You should see &amp;ldquo;Hello from TypeScript&amp;rdquo; on the page.</source>
          <target state="translated">Проверьте страницу, запустив gulp, а затем открыв &lt;code&gt;dist/index.html&lt;/code&gt; в браузере. Вы должны увидеть &amp;laquo;Привет от TypeScript&amp;raquo; на странице.</target>
        </trans-unit>
        <trans-unit id="516512568426629f66efb194dad6577cd22670ee" translate="yes" xml:space="preserve">
          <source>Test the resulting app</source>
          <target state="translated">Протестируйте полученное приложение</target>
        </trans-unit>
        <trans-unit id="96936a34c6da56cc40a32168338d905fe8a635c6" translate="yes" xml:space="preserve">
          <source>Test.ts</source>
          <target state="translated">Test.ts</target>
        </trans-unit>
        <trans-unit id="13197620f3528b6ac6188ce141c50ce0cda7fc64" translate="yes" xml:space="preserve">
          <source>TestCalculator.ts</source>
          <target state="translated">TestCalculator.ts</target>
        </trans-unit>
        <trans-unit id="cfaf8455cd86f64e0270da345fff974aff74f2d4" translate="yes" xml:space="preserve">
          <source>TestProgrammerCalculator.ts</source>
          <target state="translated">TestProgrammerCalculator.ts</target>
        </trans-unit>
        <trans-unit id="aa824f1aa0454aaae79a599c4caec36b1aa0a833" translate="yes" xml:space="preserve">
          <source>Thanks to work done by &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt;, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in &lt;code&gt;catch&lt;/code&gt; clauses. For example, when using &lt;code&gt;JSON.parse&lt;/code&gt; you may need to wrap calls to the function with a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, but you may not end up using the &lt;code&gt;SyntaxError&lt;/code&gt; that gets thrown when input is erroneous.</source>
          <target state="translated">Благодаря работе, проделанной &lt;a href=&quot;https://github.com/tinganho&quot;&gt;@tinganho&lt;/a&gt; , TypeScript 2.5 реализует новую функцию ECMAScript, которая позволяет пользователям опускать переменную в предложениях &lt;code&gt;catch&lt;/code&gt; . Например, при использовании &lt;code&gt;JSON.parse&lt;/code&gt; вам может потребоваться обернуть вызовы функции с помощью &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; , но вы не можете в конечном итоге использовать &lt;code&gt;SyntaxError&lt;/code&gt; , который генерируется при ошибочном вводе.</target>
        </trans-unit>
        <trans-unit id="e9dd082930f9a8388911a09a5116d64645cb5117" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;@types/&lt;/code&gt; prefix means that we also want to get the declaration files for React and React-DOM. Usually when you import a path like &lt;code&gt;&quot;react&quot;&lt;/code&gt;, it will look inside of the &lt;code&gt;react&lt;/code&gt; package itself; however, not all packages include declaration files, so TypeScript also looks in the &lt;code&gt;@types/react&lt;/code&gt; package as well. You&amp;rsquo;ll see that we won&amp;rsquo;t even have to think about this later on.</source>
          <target state="translated">Этот префикс &lt;code&gt;@types/&lt;/code&gt; означает, что мы также хотим получить файлы объявлений для React и React-DOM. Обычно, когда вы импортируете такой путь, как &lt;code&gt;&quot;react&quot;&lt;/code&gt; , он будет заглядывать внутрь самого &lt;code&gt;react&lt;/code&gt; пакета; однако не все пакеты включают файлы объявлений, поэтому TypeScript также просматривает пакет &lt;code&gt;@types/react&lt;/code&gt; . Вы увидите, что позже нам даже не придется об этом думать.</target>
        </trans-unit>
        <trans-unit id="25b9871704aecadb7cf39ba9a43b9edb9f462ecd" translate="yes" xml:space="preserve">
          <source>That is, in the example:</source>
          <target state="translated">То есть,в примере:</target>
        </trans-unit>
        <trans-unit id="679400f47462964a9c86c95a36308380ba51cbe6" translate="yes" xml:space="preserve">
          <source>That last example isn&amp;rsquo;t actually type-safe.</source>
          <target state="translated">Последний пример на самом деле небезопасен по типу.</target>
        </trans-unit>
        <trans-unit id="f3dd652958b97aac01bd3e5a584afa623f93a34e" translate="yes" xml:space="preserve">
          <source>That might result in dividing &lt;code&gt;undefined&lt;/code&gt;, which is why in &lt;code&gt;strictNullChecks&lt;/code&gt;, the following is an error.</source>
          <target state="translated">Это может привести к разделению &lt;code&gt;undefined&lt;/code&gt; , поэтому в &lt;code&gt;strictNullChecks&lt;/code&gt; следующая ошибка.</target>
        </trans-unit>
        <trans-unit id="47f396705024ea00097d673c1c7caf3642c168b2" translate="yes" xml:space="preserve">
          <source>That was &lt;code&gt;tsconfig.json&lt;/code&gt; automatic inclusion. That does not embed module resolution as discussed above. If the compiler identified a file as a target of a module import, it will be included in the compilation regardless if it was excluded in the previous steps.</source>
          <target state="translated">Это было автоматическое включение &lt;code&gt;tsconfig.json&lt;/code&gt; . Это не включает в себя разрешение модуля, как обсуждалось выше. Если компилятор определил файл как цель импорта модуля, он будет включен в компиляцию независимо от того, был ли он исключен на предыдущих шагах.</target>
        </trans-unit>
        <trans-unit id="fa532e4a22d2340a4675cbed4b144ee69c29ecb7" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;{ done: false, value: number }&lt;/code&gt; nor &lt;code&gt;{ done: true, value: number }&lt;/code&gt;. Why? Because the &lt;code&gt;done&lt;/code&gt; property in &lt;code&gt;S&lt;/code&gt; isn&amp;rsquo;t specific enough - it&amp;rsquo;s &lt;code&gt;boolean&lt;/code&gt; whereas each constituent of &lt;code&gt;T&lt;/code&gt; has a &lt;code&gt;done&lt;/code&gt; property that&amp;rsquo;s specifically &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. That&amp;rsquo;s what we meant by each constituent type being checked in isolation: TypeScript doesn&amp;rsquo;t just union each property together and see if &lt;code&gt;S&lt;/code&gt; is assignable to that. If it did, some bad code could get through like the following:</source>
          <target state="translated">Это потому, что &lt;code&gt;S&lt;/code&gt; нельзя присвоить ни &lt;code&gt;{ done: false, value: number }&lt;/code&gt; ни &lt;code&gt;{ done: true, value: number }&lt;/code&gt; . Зачем? Поскольку свойство &lt;code&gt;done&lt;/code&gt; в &lt;code&gt;S&lt;/code&gt; недостаточно специфично - оно является &lt;code&gt;boolean&lt;/code&gt; тогда как каждая составляющая &lt;code&gt;T&lt;/code&gt; имеет свойство &lt;code&gt;done&lt;/code&gt; , которое определенно &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; . Это то, что мы имели в виду, говоря, что каждый компонентный тип проверяется изолированно: TypeScript не просто объединяет каждое свойство вместе и проверяет, можно ли ему присвоить &lt;code&gt;S&lt;/code&gt; . Если бы это было так, некоторый плохой код мог бы пройти, как показано ниже:</target>
        </trans-unit>
        <trans-unit id="ae1a2d3d73ce13174294793215ee52d989a7c794" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s exactly what TypeScript 3.7 introduces. At the &amp;ldquo;top level&amp;rdquo; of a type alias, TypeScript will defer resolving type arguments to permit these patterns.</source>
          <target state="translated">Это именно то, что представляет собой TypeScript 3.7. На &amp;laquo;верхнем уровне&amp;raquo; псевдонима типа TypeScript откладывает разрешение аргументов типа, чтобы разрешить эти шаблоны.</target>
        </trans-unit>
        <trans-unit id="4335f12ef785a4f02d33cbf4fd5c8f14a1000242" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s not to say that block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.</source>
          <target state="translated">Это не означает, что переменная с областью видимости блока никогда не может быть объявлена ​​с переменной с областью действия функции. Переменная с блочной областью видимости просто должна быть объявлена ​​в совершенно другом блоке.</target>
        </trans-unit>
        <trans-unit id="f54fb341f70cf02ca8c9aeedc3f161af36941bc9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;short-circuiting&amp;rdquo; behavior that optional chains have is limited property accesses, calls, element accesses - it doesn&amp;rsquo;t expand any further out from these expressions. In other words,</source>
          <target state="translated">Поведение опциональных цепочек &amp;laquo;короткого замыкания&amp;raquo; - это ограниченный доступ к свойствам, вызовы, доступ к элементам - он не расширяется дальше от этих выражений. Другими словами,</target>
        </trans-unit>
        <trans-unit id="279685a1fb5d36562f5b58508949f5e1e76e1bfb" translate="yes" xml:space="preserve">
          <source>The 1.1 compiler is typically around 4x faster than any previous release. See &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;this blog post for some impressive charts.&lt;/a&gt;</source>
          <target state="translated">Компилятор 1.1 обычно примерно в 4 раза быстрее, чем любой предыдущий выпуск. См. &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2014/10/06/announcing-typescript-1-1-ctp.aspx&quot;&gt;Этот пост в блоге, чтобы&lt;/a&gt; увидеть впечатляющие графики.</target>
        </trans-unit>
        <trans-unit id="bb3c43076a9f8e3e7ef5a2ac0f5c12ab3be00750" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async Iteration proposal&lt;/a&gt; introduces &amp;ldquo;Async Generators&amp;rdquo;, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via &lt;code&gt;yield*&lt;/code&gt; to either an iterable or async iterable:</source>
          <target state="translated">Предложение &lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async Iteration&lt;/a&gt; представляет &amp;laquo;Асинхронные генераторы&amp;raquo;, которые представляют собой асинхронные функции, которые также можно использовать для получения частичных результатов вычислений. Асинхронные генераторы также могут делегировать вызовы через &lt;code&gt;yield*&lt;/code&gt; на итерацию или асинхронную итерацию:</target>
        </trans-unit>
        <trans-unit id="7f1ed30131b8220c2729612ebb193d0d769356ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; guide helps you understand common library formats and how to write a correct declaration file for each format. If you&amp;rsquo;re editing an existing file, you probably don&amp;rsquo;t need to read this section. Authors of new declaration files must read this section to properly understand how the format of the library influences the writing of the declaration file.</source>
          <target state="translated">Руководство по &lt;a href=&quot;library-structures&quot;&gt;библиотечным структурам&lt;/a&gt; поможет вам понять распространенные форматы библиотек и понять, как написать правильный файл декларации для каждого формата. Если вы редактируете существующий файл, вам, вероятно, не нужно читать этот раздел. Авторы новых файлов деклараций должны прочитать этот раздел, чтобы правильно понять, как формат библиотеки влияет на запись файла декларации.</target>
        </trans-unit>
        <trans-unit id="168fd27f48806216cef1b28e300e7429c8509f10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt; section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.</source>
          <target state="translated">В разделе &amp;laquo; &lt;a href=&quot;publishing&quot;&gt;Публикация&lt;/a&gt; &amp;raquo; объясняется, как публиковать файлы объявлений в пакет npm, и показано, как управлять зависимыми пакетами.</target>
        </trans-unit>
        <trans-unit id="ce97eb39054abf8cf82837da2071a640fc60351d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; property can be omitted, in which case the compiler&amp;rsquo;s defaults are used. See our full list of supported &lt;a href=&quot;compiler-options&quot;&gt;Compiler Options&lt;/a&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; можно не указывать, и в этом случае используются значения по умолчанию компилятора. См. Полный список поддерживаемых &lt;a href=&quot;compiler-options&quot;&gt;параметров компилятора&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e8ffdb01927e70146bd53bb542f82c73b284a32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;files&quot;&lt;/code&gt; property takes a list of relative or absolute file paths. The &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties take a list of glob-like file patterns. The supported glob wildcards are:</source>
          <target state="translated">Свойство &lt;code&gt;&quot;files&quot;&lt;/code&gt; принимает список относительных или абсолютных путей к файлам. В &lt;code&gt;&quot;include&quot;&lt;/code&gt; и &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; свойства взять список Glob-подобных шаблонов файлов. Поддерживаемые подстановочные знаки глобуса:</target>
        </trans-unit>
        <trans-unit id="5722d93ed96ab9d91793fbf0f2e4a3ba0ddbc777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator adds &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; to the type of the right operand depending on which are present in the type of the left operand, and the &lt;code&gt;||&lt;/code&gt; operator removes both &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of the left operand in the resulting union type.</source>
          <target state="translated">Оператор &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; добавляет к типу правого операнда значение &lt;code&gt;null&lt;/code&gt; и / или &lt;code&gt;undefined&lt;/code&gt; в зависимости от того, какие из них присутствуют в типе левого операнда, и &lt;code&gt;||&lt;/code&gt; Оператор удаляет как &lt;code&gt;null&lt;/code&gt; ,так и &lt;code&gt;undefined&lt;/code&gt; из типа левого операнда в результирующем типе объединения.</target>
        </trans-unit>
        <trans-unit id="b4b79995af952725664d6d796fdff7040cdc711f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; флаг</target>
        </trans-unit>
        <trans-unit id="dbed519ddc1c4c5224ed0885756fb408460d0e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--declaration&lt;/code&gt; flag in TypeScript allows us to generate &lt;code&gt;.d.ts&lt;/code&gt; files (declaration files) from TypeScript source files (i.e. &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files). These &lt;code&gt;.d.ts&lt;/code&gt; files are important for a couple of reasons.</source>
          <target state="translated">&lt;code&gt;--declaration&lt;/code&gt; флаг в машинописном позволяет генерировать &lt;code&gt;.d.ts&lt;/code&gt; файлы (декларирование файлов) из исходных файлов машинопись (т.е. &lt;code&gt;.ts&lt;/code&gt; и &lt;code&gt;.tsx&lt;/code&gt; файлы). Эти файлы &lt;code&gt;.d.ts&lt;/code&gt; важны по нескольким причинам.</target>
        </trans-unit>
        <trans-unit id="a0fb7dd8edc5f347ffbf928efce80d73f62bde6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--noResolve&lt;/code&gt; compiler options instructs the compiler not to &amp;ldquo;add&amp;rdquo; any files to the compilation that were not passed on the command line. It will still try to resolve the module to files, but if the file is not specified, it will not be included.</source>
          <target state="translated">В &lt;code&gt;--noResolve&lt;/code&gt; опции компилятора инструктирует компилятор не &amp;laquo;добавить&amp;raquo; файлы к компиляции , которые не были переданы в командной строке. Он по-прежнему будет пытаться преобразовать модуль в файлы, но если файл не указан, он не будет включен.</target>
        </trans-unit>
        <trans-unit id="9d5dd988f9131b75e837bf6bf95d2078c1309d5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--preserveSymlinks&lt;/code&gt; compiler flag</source>
          <target state="translated">В &lt;code&gt;--preserveSymlinks&lt;/code&gt; флаг компилятора</target>
        </trans-unit>
        <trans-unit id="d292c9d31d759812ffbe643f5735affa1b872f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) flag can now take any file path</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; ( &lt;code&gt;-p&lt;/code&gt; сейчас) флаг может взять любой путь к файлу</target>
        </trans-unit>
        <trans-unit id="a4255cfd03965e4b15ab5c96a185655e2dc5c33c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--project&lt;/code&gt; command line option originally could only take paths to a folder containing a &lt;code&gt;tsconfig.json&lt;/code&gt;. Given the different scenarios for build configurations, it made sense to allow &lt;code&gt;--project&lt;/code&gt; to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using &lt;code&gt;tsc&lt;/code&gt; alone without having to perform hacky workarounds like placing &lt;code&gt;tsconfig.json&lt;/code&gt; files in separate directories.</source>
          <target state="translated">&lt;code&gt;--project&lt;/code&gt; параметр командной строки изначально может принимать только путь к папке , содержащей &lt;code&gt;tsconfig.json&lt;/code&gt; . Учитывая различные сценарии конфигураций сборки, имеет смысл разрешить &lt;code&gt;--project&lt;/code&gt; указывать на любой другой совместимый файл JSON. Например, пользователь может захотеть настроить таргетинг на ES2015 с модулями CommonJS для Node 5, а на ES5 с модулями AMD для браузера. Благодаря этой новой работе пользователи могут легко управлять двумя отдельными целями сборки, используя только &lt;code&gt;tsc&lt;/code&gt; , без необходимости выполнять хитрые обходные пути, такие как размещение файлов &lt;code&gt;tsconfig.json&lt;/code&gt; в отдельных каталогах.</target>
        </trans-unit>
        <trans-unit id="b04bf272ea6b6bb26429cf5a5402059fbfa0a766" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--strictNullChecks&lt;/code&gt; flag fixes this: when you declare a variable, it doesn&amp;rsquo;t automatically include &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. You can include them explicitly using a union type:</source>
          <target state="translated">В &lt;code&gt;--strictNullChecks&lt;/code&gt; флаг фиксирует это: когда вы объявляете переменную, она автоматически не включают в себя &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; . Вы можете включить их явно, используя тип объединения:</target>
        </trans-unit>
        <trans-unit id="396ee46179af469e8ce6ffe938facf87a8ca3308" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive is the most common of this group. It serves as a declaration of &lt;em&gt;dependency&lt;/em&gt; between files.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; директива является наиболее распространенной из этой группы. Он служит декларацией &lt;em&gt;зависимости&lt;/em&gt; между файлами.</target>
        </trans-unit>
        <trans-unit id="c5d5fa087679e905484eaa0544e66e00047a3587" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;??&lt;/code&gt; operator can replace uses of &lt;code&gt;||&lt;/code&gt; when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;&lt;code&gt;localStorage&lt;/code&gt;&lt;/a&gt; (if it ever was); however, it has a bug because it uses &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;??&lt;/code&gt; оператор может заменить использование &lt;code&gt;||&lt;/code&gt; при попытке использовать значение по умолчанию. Например, следующий фрагмент кода пытается получить том, который последний раз был сохранен в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt; &lt;code&gt;localStorage&lt;/code&gt; &lt;/a&gt; (если он когда-либо был); однако в нем есть ошибка, потому что он использует &lt;code&gt;||&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33ec4ccdd0a92f0fa626d1020e8655d8d52e57a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enum&lt;/code&gt; tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in Javascript, it does not allow other members.</source>
          <target state="translated">&lt;code&gt;@enum&lt;/code&gt; тег позволяет создать литерал объекта, членами которого являются все указанного типа. В отличие от большинства объектных литералов в Javascript, он не допускает других членов.</target>
        </trans-unit>
        <trans-unit id="729d424ed3a9f5581bf724ec1a232c8c9d867325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When the &lt;code&gt;@enumerable(false)&lt;/code&gt; decorator is called, it modifies the &lt;code&gt;enumerable&lt;/code&gt; property of the property descriptor.</source>
          <target state="translated">&lt;code&gt;@enumerable(false)&lt;/code&gt; декоратор здесь является &lt;a href=&quot;#decorator-factories&quot;&gt;декоратор завод&lt;/a&gt; . Когда &lt;code&gt;@enumerable(false)&lt;/code&gt; декоратор называется, он изменяет &lt;code&gt;enumerable&lt;/code&gt; свойство дескриптора свойств.</target>
        </trans-unit>
        <trans-unit id="2de9fb6766aab19221ef4c23a63fa9469054d5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; decorator here is a &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factory&lt;/a&gt;. When &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; is called, it adds a metadata entry for the property using the &lt;code&gt;Reflect.metadata&lt;/code&gt; function from the &lt;code&gt;reflect-metadata&lt;/code&gt; library. When &lt;code&gt;getFormat&lt;/code&gt; is called, it reads the metadata value for the format.</source>
          <target state="translated">&lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; декоратор вот &lt;a href=&quot;#decorator-factories&quot;&gt;декоратор завод&lt;/a&gt; . Когда &lt;code&gt;@format(&quot;Hello, %s&quot;)&lt;/code&gt; , он добавляет запись метаданных для свойства с &lt;code&gt;Reflect.metadata&lt;/code&gt; функции Reflect.metadata из библиотеки &lt;code&gt;reflect-metadata&lt;/code&gt; . Когда &lt;code&gt;getFormat&lt;/code&gt; , он считывает значение метаданных для формата.</target>
        </trans-unit>
        <trans-unit id="19665d13a52211c67417591d8dd41380ae77c57c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@required&lt;/code&gt; decorator adds a metadata entry that marks the parameter as required. The &lt;code&gt;@validate&lt;/code&gt; decorator then wraps the existing &lt;code&gt;greet&lt;/code&gt; method in a function that validates the arguments before invoking the original method.</source>
          <target state="translated">&lt;code&gt;@required&lt;/code&gt; декоратор добавляет метаданные запись, помечает параметр , как требуется. &lt;code&gt;@validate&lt;/code&gt; декоратор затем оборачивает существующее &lt;code&gt;greet&lt;/code&gt; метод в функции , которая проверяет аргументы перед вызовом оригинального метода.</target>
        </trans-unit>
        <trans-unit id="9608e5840a63db8f977864c74884f8b6002ea58a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; type lets us extract all parameter types of a constructor function type. It produces a tuple type with all the parameter types (or the type &lt;code&gt;never&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is not a function).</source>
          <target state="translated">Тип &lt;code&gt;ConstructorParameters&amp;lt;T&amp;gt;&lt;/code&gt; позволяет нам извлекать все типы параметров из типа функции конструктора. Он создает кортеж со всеми типами параметров (или тип &lt;code&gt;never&lt;/code&gt; , если &lt;code&gt;T&lt;/code&gt; не является функцией).</target>
        </trans-unit>
        <trans-unit id="e4d0252ee699e46769d5a622ff65ea37a30cb18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Iterator&lt;/code&gt; type now allows users to specify the yielded type, the returned type, and the type that &lt;code&gt;next&lt;/code&gt; can accept.</source>
          <target state="translated">Тип &lt;code&gt;Iterator&lt;/code&gt; теперь позволяет пользователям указывать полученный тип, возвращаемый тип и тип, который &lt;code&gt;next&lt;/code&gt; может принять.</target>
        </trans-unit>
        <trans-unit id="7f41c5b21ee9dbf168d5ef4da903752f9e8d385c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Omit&lt;/code&gt; helper type</source>
          <target state="translated">Тип помощника &lt;code&gt;Omit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64a869fe08430ba63b8b26229df6154c69e8f8af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ReadonlyArray&lt;/code&gt; type describes &lt;code&gt;Array&lt;/code&gt;s that can only be read from. Any variable with a reference to a &lt;code&gt;ReadonlyArray&lt;/code&gt; can&amp;rsquo;t add, remove, or replace any elements of the array.</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; типа описывает &lt;code&gt;Array&lt;/code&gt; S , которые могут быть прочитаны только. Любая переменная со ссылкой на &lt;code&gt;ReadonlyArray&lt;/code&gt; не может добавлять, удалять или заменять какие-либо элементы массива.</target>
        </trans-unit>
        <trans-unit id="6368f607a56bb2c916a5b954c6dabe855ebf8589" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; marker interface is simply an empty interface declared in &lt;code&gt;lib.d.ts&lt;/code&gt;. Beyond being recognized in the contextual type of an object literal, the interface acts like any empty interface.</source>
          <target state="translated">&lt;code&gt;ThisType&amp;lt;T&amp;gt;&lt;/code&gt; интерфейс маркера есть просто пустой интерфейс объявлен в &lt;code&gt;lib.d.ts&lt;/code&gt; . Интерфейс не только распознается в контекстном типе литерала объекта, но и действует как любой пустой интерфейс.</target>
        </trans-unit>
        <trans-unit id="eac98c87d76e62726c164fbe787eb6f8c34463c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-dependency&lt;/code&gt; directive can also have an optional &lt;code&gt;name&lt;/code&gt; property; this allows passing an optional name for an amd-dependency:</source>
          <target state="translated">&lt;code&gt;amd-dependency&lt;/code&gt; директива может также иметь дополнительное &lt;code&gt;name&lt;/code&gt; свойства; это позволяет передать необязательное имя для amd-зависимости:</target>
        </trans-unit>
        <trans-unit id="5e27299aa8a8890f9cedcc0ab41fbf05f07fd29d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;amd-module&lt;/code&gt; directive allows passing an optional module name to the compiler:</source>
          <target state="translated">&lt;code&gt;amd-module&lt;/code&gt; директива позволяет передавая имя дополнительного модуля для компилятора:</target>
        </trans-unit>
        <trans-unit id="a057b54c00069469116e2e7ce7d79e2e760309d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation. You might expect &lt;code&gt;Object&lt;/code&gt; to play a similar role, as it does in other languages. However, variables of type &lt;code&gt;Object&lt;/code&gt; only allow you to assign any value to them. You can&amp;rsquo;t call arbitrary methods on them, even ones that actually exist:</source>
          <target state="translated">Тип &lt;code&gt;any&lt;/code&gt; - это мощный способ работы с существующим JavaScript, позволяющий постепенно включать и отключать проверку типов во время компиляции. Вы можете ожидать, что &lt;code&gt;Object&lt;/code&gt; будет играть ту же роль, что и на других языках. Однако переменные типа &lt;code&gt;Object&lt;/code&gt; позволяют только присвоить им любое значение. Вы не можете вызывать для них произвольные методы, даже те, которые действительно существуют:</target>
        </trans-unit>
        <trans-unit id="c0017d222210d0ddb4e497a93705b0979da8a1a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;any&lt;/code&gt; type is also handy if you know some part of the type, but perhaps not all of it. For example, you may have an array but the array has a mix of different types:</source>
          <target state="translated">Тип &lt;code&gt;any&lt;/code&gt; также удобен, если вы знаете какую-то часть типа, но, возможно, не всю его. Например, у вас может быть массив, но он имеет смесь разных типов:</target>
        </trans-unit>
        <trans-unit id="3e134f2fc8f2da81e48dedae85eec0c1c0994e99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; оператор</target>
        </trans-unit>
        <trans-unit id="a3c73e06a99fdb1de9fb8c344fa7c098a7a03b56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt; operator is available in both &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files, and is identical in behavior to the angle-bracket type assertion style.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; оператор доступен в обоих &lt;code&gt;.ts&lt;/code&gt; и &lt;code&gt;.tsx&lt;/code&gt; файлов, и идентичен по поведению на угол скобки стиля утверждение типа.</target>
        </trans-unit>
        <trans-unit id="a3a92cff5154e72c024dab414b5c117b995405f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exclude&lt;/code&gt; list does not support wilcards. It must simply be a list of files and/or directories.</source>
          <target state="translated">Список &lt;code&gt;exclude&lt;/code&gt; не поддерживает символы Wilcards. Это должен быть просто список файлов и / или каталогов.</target>
        </trans-unit>
        <trans-unit id="c3af89dee69149756441c4182df39cc8f0c3f4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export =&lt;/code&gt; syntax specifies a single object that is exported from the module. This can be a class, interface, namespace, function, or enum.</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; синтаксис определяет один объект , который экспортируется из модуля. Это может быть класс, интерфейс, пространство имен, функция или перечисление.</target>
        </trans-unit>
        <trans-unit id="17738861fda178b7ad88eea31d19aa3f7764605b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the &lt;code&gt;extends&lt;/code&gt; clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and &amp;ldquo;class-like&amp;rdquo; expressions to be specified in the &lt;code&gt;extends&lt;/code&gt; clause.</source>
          <target state="translated">Предложение &lt;code&gt;extends&lt;/code&gt; класса ранее требовало указания ссылки на тип. Теперь он принимает выражение, за которым может следовать список аргументов типа. Тип выражения должен быть типом функции конструктора с по крайней мере одной сигнатурой конструкции, которая имеет такое же количество параметров типа, что и количество аргументов типа, указанных в предложении &lt;code&gt;extends&lt;/code&gt; . Тип возвращаемого значения соответствующей сигнатуры конструкции - это базовый тип, от которого наследуется тип экземпляра класса. По сути, это позволяет указывать как реальные классы, так и выражения, подобные классам, в предложении &lt;code&gt;extends&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba2b01f6262a247dc48cefc8edd8183caa3b6800" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extends&lt;/code&gt; is a top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;). &lt;code&gt;extends&lt;/code&gt;&amp;rsquo; value is a string containing a path to another configuration file to inherit from. The path may use Node.js style resolution.</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; является топ-уровня собственности в &lt;code&gt;tsconfig.json&lt;/code&gt; (наряду с &lt;code&gt;compilerOptions&lt;/code&gt; , &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; , и &lt;code&gt;exclude&lt;/code&gt; ). &lt;code&gt;extends&lt;/code&gt; 'value - это строка, содержащая путь к другому файлу конфигурации, от которого требуется наследовать. Путь может использовать разрешение стиля Node.js.</target>
        </trans-unit>
        <trans-unit id="3017f557a2f328b58256e1eb412ef2360a4c4d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-await-of&lt;/code&gt; Statement</source>
          <target state="translated">&lt;code&gt;for-await-of&lt;/code&gt; Заявлении</target>
        </trans-unit>
        <trans-unit id="070a2aede6e683916dcd05d3af0a560d4036508a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for..await..of&lt;/code&gt; statement is only legal within an Async Function or Async Generator.</source>
          <target state="translated">Оператор &lt;code&gt;for..await..of&lt;/code&gt; разрешен только в рамках асинхронной функции или асинхронного генератора.</target>
        </trans-unit>
        <trans-unit id="c1d7afbee8b4e917fda3b9d2fe2dbda01149f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getWidget&lt;/code&gt; function accepts a number and returns a Widget, or accepts a string and returns a Widget array.</source>
          <target state="translated">Функция &lt;code&gt;getWidget&lt;/code&gt; принимает число и возвращает виджет или принимает строку и возвращает массив виджетов.</target>
        </trans-unit>
        <trans-unit id="b90a2540458db7fb3aef294d8c4559c6aab9f51d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;greeter&lt;/code&gt; object can log to a file or display an alert. You can provide LogOptions to &lt;code&gt;.log(...)&lt;/code&gt; and alert options to &lt;code&gt;.alert(...)&lt;/code&gt;</source>
          <target state="translated">Объект &lt;code&gt;greeter&lt;/code&gt; может войти в файл или отобразить предупреждение. Вы можете предоставить LogOptions для &lt;code&gt;.log(...)&lt;/code&gt; и параметры предупреждений для &lt;code&gt;.alert(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21c39d544da86c80cc2e6b131693af3e027fdc76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; operator now acts as a narrowing expression for types.</source>
          <target state="translated">Оператор &lt;code&gt;in&lt;/code&gt; теперь действует как сужающее выражение для типов.</target>
        </trans-unit>
        <trans-unit id="e1dd9f41eb7331354f03e6ddd8b1c9f2a64fbffa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length&lt;/code&gt; property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the &lt;code&gt;length&lt;/code&gt; property in the tuple type &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; is &lt;code&gt;1 | 2 | 3&lt;/code&gt;.</source>
          <target state="translated">Свойство &lt;code&gt;length&lt;/code&gt; кортежа с необязательными элементами представляет собой объединение числовых литералов, представляющих возможные длины. Например, тип &lt;code&gt;length&lt;/code&gt; собственности в типе кортежа &lt;code&gt;[number, string?, boolean?]&lt;/code&gt; является &lt;code&gt;1 | 2 | 3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b63b4343498819e73c1335f4802dd4ecef55b161" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; типа</target>
        </trans-unit>
        <trans-unit id="a9f3d4cb7613ec649d53f0d74013eb6fa4569ec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type has the following characteristics:</source>
          <target state="translated">Тип &lt;code&gt;never&lt;/code&gt; имеет следующие характеристики:</target>
        </trans-unit>
        <trans-unit id="1e1a0ee3128b4be96a4b23dc31c8ff4663ecbf13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type is a subtype of, and assignable to, every type; however, &lt;em&gt;no&lt;/em&gt; type is a subtype of, or assignable to, &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself). Even &lt;code&gt;any&lt;/code&gt; isn&amp;rsquo;t assignable to &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">Тип &lt;code&gt;never&lt;/code&gt; является подтипом любого типа и может быть назначен ему; однако, &lt;em&gt;не&lt;/em&gt; типа не является подтипом, или присваиваемый, &lt;code&gt;never&lt;/code&gt; ( за исключением &lt;code&gt;never&lt;/code&gt; себя). Даже &lt;code&gt;any&lt;/code&gt; не может быть назначен &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c32d1689d5690c0a84ea806da09f9080b457ae29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. For instance, &lt;code&gt;never&lt;/code&gt; is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns; Variables also acquire the type &lt;code&gt;never&lt;/code&gt; when narrowed by any type guards that can never be true.</source>
          <target state="translated">Тип &lt;code&gt;never&lt;/code&gt; представляет собой тип значений, которые никогда не встречаются. Например, &lt;code&gt;never&lt;/code&gt; является типом возвращаемого значения для выражения функции или выражения функции стрелки, которое всегда вызывает исключение или которое никогда не возвращает; Переменные также приобретают тип &lt;code&gt;never&lt;/code&gt; когда сужаются какими-либо защитниками типа, которые никогда не могут быть истинными.</target>
        </trans-unit>
        <trans-unit id="415ee7bd886be7d1a3ff4410f75297e6f875a010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new.target&lt;/code&gt; meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via &lt;code&gt;new&lt;/code&gt;, the value of &lt;code&gt;new.target&lt;/code&gt; is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;new.target&lt;/code&gt; is set to &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; мета-свойство новый синтаксис введен в ES2015. Когда экземпляр конструктора создается с помощью &lt;code&gt;new&lt;/code&gt; , значение &lt;code&gt;new.target&lt;/code&gt; устанавливается как ссылка на функцию конструктора, изначально использовавшуюся для выделения экземпляра. Если функция вызывается, а не &lt;code&gt;new.target&lt;/code&gt; через &lt;code&gt;new&lt;/code&gt; , для new.target устанавливается значение &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19477c8f1cfa1e9c60356444eaaad7d0b42b9b97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are &lt;em&gt;not&lt;/em&gt; widened to &lt;code&gt;any&lt;/code&gt; in strict null checking mode.</source>
          <target state="translated">В &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; типах &lt;em&gt;не&lt;/em&gt; расширены до &lt;code&gt;any&lt;/code&gt; в строгом режиме проверки нулевой.</target>
        </trans-unit>
        <trans-unit id="fa34aa7759f5de219e7583fd1dd7f008d517869c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; elimination is pretty obvious here, but you can use terser operators too:</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; ликвидация является довольно очевидно, но вы можете использовать terser операторы тоже:</target>
        </trans-unit>
        <trans-unit id="3b9cc299e7f4d8fe545c9d49c0fc120f67d07f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; property of each reference can point to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or to the config file itself (which may have any name).</source>
          <target state="translated">Свойство &lt;code&gt;path&lt;/code&gt; каждой ссылки может указывать на каталог, содержащий файл &lt;code&gt;tsconfig.json&lt;/code&gt; , или на сам файл конфигурации (который может иметь любое имя).</target>
        </trans-unit>
        <trans-unit id="c5b3e36b4b2dc53fe86b3370909ee5fca3f8d695" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;preserve&lt;/code&gt; mode will keep JSX expressions as part of the output to be further consumed by another transform step. &lt;em&gt;Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; режим будет держать выражения JSX как часть продукции будет дополнительно потребляться другим преобразование шага. &lt;em&gt;Кроме того, файл будет иметь расширение &lt;code&gt;.jsx&lt;/code&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="854b44746f0abc418eff6be7c3fdd54bb19efc1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;protected&lt;/code&gt; modifier acts much like the &lt;code&gt;private&lt;/code&gt; modifier with the exception that members declared &lt;code&gt;protected&lt;/code&gt; can also be accessed within deriving classes. For example,</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; модификатор действует так же, как &lt;code&gt;private&lt;/code&gt; модификатор с тем исключением , что члены объявляются &lt;code&gt;protected&lt;/code&gt; можно также получить в вытекающих классах. Например,</target>
        </trans-unit>
        <trans-unit id="f60b5b9402d0bcc5b53cc9b4ebead84ff4399b9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">В режиме &lt;code&gt;react&lt;/code&gt; будет &lt;code&gt;React.createElement&lt;/code&gt; , не нужно выполнять преобразование JSX перед использованием, а выходные данные будут иметь расширение файла &lt;code&gt;.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="731bfb54c9c710c3fddba0d525348937d618334a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; properties will appear with correct types on all components</source>
          <target state="translated">В &lt;code&gt;ref&lt;/code&gt; и &lt;code&gt;key&lt;/code&gt; свойства будут отображаться с правильными типами по всем компонентам</target>
        </trans-unit>
        <trans-unit id="3ff4b0ed4771c56a90177b8d4ff4bd3f592871c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ref&lt;/code&gt; property is correctly disallowed on instances of Stateless Function components</source>
          <target state="translated">Свойство &lt;code&gt;ref&lt;/code&gt; правильно запрещено в экземплярах компонентов функции без сохранения состояния.</target>
        </trans-unit>
        <trans-unit id="afd948bd24859b80dd2610380a6c20a8cd87a044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; setting, if not explicitly set, defaults to the directory containing the &lt;code&gt;tsconfig&lt;/code&gt; file</source>
          <target state="translated">Параметр &lt;code&gt;rootDir&lt;/code&gt; , если не установлен явно, по умолчанию соответствует каталогу, содержащему файл &lt;code&gt;tsconfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45854eb3beba23a865f9cbaa14a544abf02a43ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; option (allowing users to switch out of &lt;code&gt;es5&lt;/code&gt; to &lt;code&gt;es3&lt;/code&gt;, &lt;code&gt;es2015&lt;/code&gt;, &lt;code&gt;esnext&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; параметр (позволяя пользователям переключаться из &lt;code&gt;es5&lt;/code&gt; к &lt;code&gt;es3&lt;/code&gt; , &lt;code&gt;es2015&lt;/code&gt; , &lt;code&gt;esnext&lt;/code&gt; и т.д.)</target>
        </trans-unit>
        <trans-unit id="13c27e388b6d0efef978313ee87f8dcb0b62e5dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; тип также полезно с типами пересечений в описании библиотек (например , ember.js) , что паттерны использования Mixin стиля для описания наследования:</target>
        </trans-unit>
        <trans-unit id="6a29d4a5cece065318dd327e82552a8345a8bff7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useDefineForClassFields&lt;/code&gt; Flag and The &lt;code&gt;declare&lt;/code&gt; Property Modifier</source>
          <target state="translated">&lt;code&gt;useDefineForClassFields&lt;/code&gt; Флаг и &lt;code&gt;declare&lt;/code&gt; Модификатор недвижимости</target>
        </trans-unit>
        <trans-unit id="787315c92fdd75d5b219d459cc175e222f5c560e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">&lt;em&gt;Descriptor недвижимости&lt;/em&gt; для члена.</target>
        </trans-unit>
        <trans-unit id="7230f5ad07f661a74fc222478036dbea6b5acfa1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nullish coalescing operator&lt;/em&gt; is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.</source>
          <target state="translated">Оператор &lt;em&gt;объединения с нулевым значением&lt;/em&gt; - это еще одна предстоящая функция ECMAScript, которая идет рука об руку с необязательной цепочкой, и наша команда участвовала в продвижении в TC39.</target>
        </trans-unit>
        <trans-unit id="ffd20aedc2df50b541f11314e29e7f1054d730a5" translate="yes" xml:space="preserve">
          <source>The Async Iteration introduces an &lt;code&gt;AsyncIterator&lt;/code&gt;, which is similar to &lt;code&gt;Iterator&lt;/code&gt;. The difference lies in the fact that the &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt; methods of an &lt;code&gt;AsyncIterator&lt;/code&gt; return a &lt;code&gt;Promise&lt;/code&gt; for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the &lt;code&gt;AsyncIterator&lt;/code&gt; has advanced to the point of yielding a value. An &lt;code&gt;AsyncIterator&lt;/code&gt; has the following shape:</source>
          <target state="translated">Async Iteration представляет &lt;code&gt;AsyncIterator&lt;/code&gt; , который похож на &lt;code&gt;Iterator&lt;/code&gt; . Разница заключается в том, что методы &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;throw&lt;/code&gt; объекта &lt;code&gt;AsyncIterator&lt;/code&gt; возвращают &lt;code&gt;Promise&lt;/code&gt; для результата итерации, а не самого результата. Это позволяет вызывающему абоненту присоединиться к асинхронному уведомлению на время, когда &lt;code&gt;AsyncIterator&lt;/code&gt; продвинулся до точки получения значения. &lt;code&gt;AsyncIterator&lt;/code&gt; имеет следующую форму:</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21db3b675c232e8c920fc5cc57777d2bb7e6f2db" translate="yes" xml:space="preserve">
          <source>The Examples</source>
          <target state="translated">Примеры</target>
        </trans-unit>
        <trans-unit id="ae6a763c1fb39d689bcd8262575ee2c673da8154" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Call Signatures</source>
          <target state="translated">Воздействие ES6 на позывные сигнатуры модулей</target>
        </trans-unit>
        <trans-unit id="4de6669622cba77a38976c0164e1dded39f35909" translate="yes" xml:space="preserve">
          <source>The Impact of ES6 on Module Plugins</source>
          <target state="translated">Воздействие ES6 на модульные плагины</target>
        </trans-unit>
        <trans-unit id="a90186b2913ce2a03f025ed1147a0c7a6b54234e" translate="yes" xml:space="preserve">
          <source>The Iterator protocol also defines the target of some of the ES2015 features like &lt;code&gt;for..of&lt;/code&gt; and spread operator and the array rest in destructuring assignmnets.</source>
          <target state="translated">Протокол Iterator также определяет цель некоторых функций ES2015, таких как &lt;code&gt;for..of&lt;/code&gt; и оператор распространения, а также остаток массива при деструктуризации assignmnets.</target>
        </trans-unit>
        <trans-unit id="e2e893d7917d362f27f157a05f677c2dd16c5bb9" translate="yes" xml:space="preserve">
          <source>The JSX result type</source>
          <target state="translated">Тип результата JSX</target>
        </trans-unit>
        <trans-unit id="7c164a656b844ad909a272419ed0cbe9548f88f5" translate="yes" xml:space="preserve">
          <source>The TypeScript Handbook</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3dc7b38b486965f74bd526d650143ae6a37e3aa" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler has a set of additional flags to &lt;em&gt;inform&lt;/em&gt; the compiler of transformations that are expected to happen to the sources to generate the final output.</source>
          <target state="translated">Компилятор TypeScript имеет набор дополнительных флагов для &lt;em&gt;информирования&lt;/em&gt; компилятора о преобразованиях, которые, как ожидается, произойдут с источниками для генерации окончательного вывода.</target>
        </trans-unit>
        <trans-unit id="bb370c8d075071406b52f5ac647fa7c9d121cf5a" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files.</source>
          <target state="translated">Компилятор TypeScript поддерживает объявление таких сопоставлений с помощью свойства &lt;code&gt;&quot;paths&quot;&lt;/code&gt; в файлах &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="099c380e43d8e6d4992539e165d15f16ea81d572" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler supports the declaration of such mappings using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property in &lt;code&gt;tsconfig.json&lt;/code&gt; files. Here is an example for how to specify the &lt;code&gt;&quot;paths&quot;&lt;/code&gt; property for &lt;code&gt;jquery&lt;/code&gt;.</source>
          <target state="translated">Компилятор TypeScript поддерживает объявление таких сопоставлений с помощью свойства &lt;code&gt;&quot;paths&quot;&lt;/code&gt; в файлах &lt;code&gt;tsconfig.json&lt;/code&gt; . Вот пример того, как указать свойство &lt;code&gt;&quot;paths&quot;&lt;/code&gt; для &lt;code&gt;jquery&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdf835f0a2221bc2f82e0e151055988a09c9c5cd" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will inject design-time type information using the &lt;code&gt;@Reflect.metadata&lt;/code&gt; decorator. You could consider it the equivalent of the following TypeScript:</source>
          <target state="translated">Компилятор TypeScript будет вводить информацию о типе во время разработки с &lt;code&gt;@Reflect.metadata&lt;/code&gt; декоратора @ Reflect.metadata . Вы можете считать его эквивалентом следующего TypeScript:</target>
        </trans-unit>
        <trans-unit id="7a2537884fb59ac700d2d4b7e0b4045bf44ae0d3" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:</source>
          <target state="translated">Компилятор TypeScript будет передавать для...массивов идиоматический JavaScript ES3/ES5 при нацеливании на эти версии:</target>
        </trans-unit>
        <trans-unit id="49b307cc503023513bc14bb0a27ac57aa8f44ce9" translate="yes" xml:space="preserve">
          <source>The TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Artem Tyurin&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;TypeScript playground&lt;/a&gt; which community members have been using more and more. We owe Artem a big thanks for helping out here!</source>
          <target state="translated">Игровая площадка TypeScript получила столь необходимое обновление с новыми удобными функциями! Новая детская площадка в основном форк &lt;a href=&quot;https://github.com/agentcooper&quot;&gt;Артем Тюрин&lt;/a&gt; &amp;laquo;s &lt;a href=&quot;https://github.com/agentcooper/typescript-play&quot;&gt;машинопись площадка&lt;/a&gt; членов сообщества которые уже используют все больше и больше. Огромное спасибо Артему за помощь!</target>
        </trans-unit>
        <trans-unit id="2d3804fe18093dd09b93d92b9795e81df41c7624" translate="yes" xml:space="preserve">
          <source>The TypeSript compiler emits a few helpers like &lt;code&gt;__extends&lt;/code&gt; when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use &lt;code&gt;--noEmitHelpers&lt;/code&gt; to instructs the compiler not to emit them.</source>
          <target state="translated">Компилятор &lt;code&gt;__extends&lt;/code&gt; при необходимости генерирует несколько помощников, например __extends . Помощники генерируются в каждом файле, в котором они упоминаются. Если вы хотите объединить все помощники в одном месте или переопределить поведение по умолчанию, используйте &lt;code&gt;--noEmitHelpers&lt;/code&gt; , чтобы указать компилятору не создавать их.</target>
        </trans-unit>
        <trans-unit id="bae3a8ac10b29ef5dcadb732d1773d84824f8b64" translate="yes" xml:space="preserve">
          <source>The above code will result in an error since you cannot divide a string by a number. The output, when using the &lt;code&gt;preserve&lt;/code&gt; option, looks like:</source>
          <target state="translated">Приведенный выше код приведет к ошибке, поскольку вы не можете разделить строку на число. Вывод при использовании параметра &lt;code&gt;preserve&lt;/code&gt; выглядит так:</target>
        </trans-unit>
        <trans-unit id="973342201d3a8b874193050ad2e2e03771fa9182" translate="yes" xml:space="preserve">
          <source>The above workaround will work as long as you have a common property between &lt;code&gt;squareOptions&lt;/code&gt; and &lt;code&gt;SquareConfig&lt;/code&gt;. In this example, it was the property &lt;code&gt;width&lt;/code&gt;. It will however, fail if the variable does not have any common object property. For example:</source>
          <target state="translated">Вышеупомянутый обходной путь будет работать, если у вас есть общее свойство между &lt;code&gt;squareOptions&lt;/code&gt; и &lt;code&gt;SquareConfig&lt;/code&gt; . В этом примере это &lt;code&gt;width&lt;/code&gt; свойства . Однако он завершится ошибкой, если переменная не имеет общего свойства объекта. Например:</target>
        </trans-unit>
        <trans-unit id="977799dc5b2c7efb8ce07ce9dda596f71ce6d8c4" translate="yes" xml:space="preserve">
          <source>The act of introducing a new name in a more nested scope is called &lt;em&gt;shadowing&lt;/em&gt;. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier &lt;code&gt;sumMatrix&lt;/code&gt; function using &lt;code&gt;let&lt;/code&gt; variables.</source>
          <target state="translated">Акт введения нового имени в более вложенную область действия называется &lt;em&gt;затенением&lt;/em&gt; . Это своего рода палка о двух концах, поскольку он может сам по себе вносить определенные ошибки в случае случайного затенения, а также предотвращать определенные ошибки. Например, представьте, что мы написали нашу предыдущую функцию &lt;code&gt;sumMatrix&lt;/code&gt; , используя переменные &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="464744a1885e10900c594d16946298c68c765f22" translate="yes" xml:space="preserve">
          <source>The advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the &lt;code&gt;color&lt;/code&gt; property in &lt;code&gt;createSquare&lt;/code&gt;, we would get an error message letting us know:</source>
          <target state="translated">Преимущество необязательных свойств заключается в том, что вы можете описывать эти возможно доступные свойства, в то же время предотвращая использование свойств, которые не являются частью интерфейса. Например, если бы мы неправильно набрали имя свойства &lt;code&gt;color&lt;/code&gt; в &lt;code&gt;createSquare&lt;/code&gt; , мы получили бы сообщение об ошибке, сообщающее нам:</target>
        </trans-unit>
        <trans-unit id="d900af77a95ccc3991b5cce004f6567adc959fc3" translate="yes" xml:space="preserve">
          <source>The alternative was to instead rewrite the code so that the language could analyze it, but this isn&amp;rsquo;t convenient.</source>
          <target state="translated">Альтернативой было переписать код, чтобы язык мог его анализировать, но это неудобно.</target>
        </trans-unit>
        <trans-unit id="d7545e67ed0bf67fd6d8743f1b478c94a21cbf7b" translate="yes" xml:space="preserve">
          <source>The answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let&amp;rsquo;s create a list of overloads that describe what our &lt;code&gt;pickCard&lt;/code&gt; accepts and what it returns.</source>
          <target state="translated">Ответ заключается в том, чтобы предоставить несколько типов функций для одной и той же функции в виде списка перегрузок. Этот список будет использоваться компилятором для разрешения вызовов функций. Давайте создадим список перегрузок, которые описывают, что принимает наша &lt;code&gt;pickCard&lt;/code&gt; и что она возвращает.</target>
        </trans-unit>
        <trans-unit id="d87ac95450f1e8dcfc394fcd59a9e3ae182cfb79" translate="yes" xml:space="preserve">
          <source>The argument can be a file path to a valid JSON configuration file, or a directory path to a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">Аргументом может быть путь к допустимому файлу конфигурации JSON или путь к каталогу, содержащему файл &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f45e116d7cf081dd6a210ca6310037f2aa66724" translate="yes" xml:space="preserve">
          <source>The as operator</source>
          <target state="translated">Как оператор</target>
        </trans-unit>
        <trans-unit id="9c9fa406955dab922d6a11f631e81ab8facc3e92" translate="yes" xml:space="preserve">
          <source>The basic rule for TypeScript&amp;rsquo;s structural type system is that &lt;code&gt;x&lt;/code&gt; is compatible with &lt;code&gt;y&lt;/code&gt; if &lt;code&gt;y&lt;/code&gt; has at least the same members as &lt;code&gt;x&lt;/code&gt;. For example:</source>
          <target state="translated">Основное правило для системы структурных типов TypeScript состоит в том, что &lt;code&gt;x&lt;/code&gt; совместим с &lt;code&gt;y&lt;/code&gt; , если &lt;code&gt;y&lt;/code&gt; имеет по крайней мере те же члены, что и &lt;code&gt;x&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="0570ba37489d38960ce7e63c3dda6e93bf075660" translate="yes" xml:space="preserve">
          <source>The caveat is that string-initialized enums can&amp;rsquo;t be reverse-mapped to get the original enum member name. In other words, you can&amp;rsquo;t write &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; to get the string &lt;code&gt;&quot;Red&quot;&lt;/code&gt;.</source>
          <target state="translated">Предостережение заключается в том, что перечисления, инициализированные строкой, не могут быть обратным отображением, чтобы получить исходное имя члена перечисления. Другими словами, вы не можете написать &lt;code&gt;Colors[&quot;RED&quot;]&lt;/code&gt; чтобы получить строку &lt;code&gt;&quot;Red&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="658cc1f5d6e87940c9b68d75f7a3216b7965fa8f" translate="yes" xml:space="preserve">
          <source>The character set of the input files.</source>
          <target state="translated">Набор символов входных файлов.</target>
        </trans-unit>
        <trans-unit id="0d767851eecc9dbc5567854c546874153b473aac" translate="yes" xml:space="preserve">
          <source>The classification can be further customized by changing the font and color settings for the &lt;code&gt;VB XML&lt;/code&gt; color and font settings through &lt;code&gt;Tools&lt;/code&gt;-&amp;gt;&lt;code&gt;Options&lt;/code&gt;-&amp;gt;&lt;code&gt;Environment&lt;/code&gt;-&amp;gt;&lt;code&gt;Fonts and Colors&lt;/code&gt; page.</source>
          <target state="translated">Классификацию можно дополнительно настроить, изменив настройки шрифта и цвета для цвета и настроек шрифта &lt;code&gt;VB XML&lt;/code&gt; через &lt;code&gt;Tools&lt;/code&gt; -&amp;gt; &lt;code&gt;Options&lt;/code&gt; -&amp;gt; &lt;code&gt;Environment&lt;/code&gt; -&amp;gt; &lt;code&gt;Fonts and Colors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e4361985e949137fdbecccf199cbcbfd26cb095" translate="yes" xml:space="preserve">
          <source>The code sample starts with the two classes that will act as our mixins. You can see each one is focused on a particular activity or capability. We&amp;rsquo;ll later mix these together to form a new class from both capabilities.</source>
          <target state="translated">Пример кода начинается с двух классов, которые будут действовать как наши миксины. Вы можете видеть, что каждый из них ориентирован на определенную деятельность или способность. Позже мы смешаем их вместе, чтобы сформировать новый класс из обеих возможностей.</target>
        </trans-unit>
        <trans-unit id="44bfd585b7b25dece832164d759523816acacef3" translate="yes" xml:space="preserve">
          <source>The comment pragma version may be used like so (in TypeScript 2.8):</source>
          <target state="translated">Версия комментария pragma может быть использована подобным образом (в TypeScript 2.8):</target>
        </trans-unit>
        <trans-unit id="94d8762ed85cb39d474ef4b32596ce47c7f9f61a" translate="yes" xml:space="preserve">
          <source>The compiler can usually figure out the type of &lt;code&gt;this&lt;/code&gt; when it has some context to work with. When it doesn&amp;rsquo;t, you can explicitly specify the type of &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;@this&lt;/code&gt;:</source>
          <target state="translated">Компилятор обычно может определить тип &lt;code&gt;this&lt;/code&gt; когда у него есть некоторый контекст для работы. Если это не так, вы можете явно указать тип &lt;code&gt;this&lt;/code&gt; с помощью &lt;code&gt;@this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6ce225c2cdfc4fbbd52bf1bec496704ad8d2e300" translate="yes" xml:space="preserve">
          <source>The compiler checks that &lt;code&gt;manufacturer&lt;/code&gt; and &lt;code&gt;model&lt;/code&gt; are actually properties on &lt;code&gt;Car&lt;/code&gt;. The example introduces a couple of new type operators. First is &lt;code&gt;keyof T&lt;/code&gt;, the &lt;strong&gt;index type query operator&lt;/strong&gt;. For any type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;keyof T&lt;/code&gt; is the union of known, public property names of &lt;code&gt;T&lt;/code&gt;. For example:</source>
          <target state="translated">Компилятор проверяет, что &lt;code&gt;manufacturer&lt;/code&gt; и &lt;code&gt;model&lt;/code&gt; действительно являются свойствами &lt;code&gt;Car&lt;/code&gt; . В примере вводится пара новых операторов типа. Во-первых, это &lt;code&gt;keyof T&lt;/code&gt; , &lt;strong&gt;оператор запроса индексного типа&lt;/strong&gt; . Для любого типа &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;keyof T&lt;/code&gt; является объединением имен известно, общественной собственности &lt;code&gt;T&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="b90080efac3089f68bf9198051529fb93927ad2d" translate="yes" xml:space="preserve">
          <source>The compiler checks that variables are definitely assigned by performing &lt;em&gt;control flow based type analysis&lt;/em&gt;. See later for further details on this topic.</source>
          <target state="translated">Компилятор проверяет, что переменные явно присвоены, путем &lt;em&gt;анализа типов на основе потока управления&lt;/em&gt; . См. Ниже для получения дополнительной информации по этой теме.</target>
        </trans-unit>
        <trans-unit id="709255e2bfcdfd8723f3b039260e513f6811cfd9" translate="yes" xml:space="preserve">
          <source>The compiler detects whether each module is used in the emitted JavaScript. If a module identifier is only ever used as part of a type annotations and never as an expression, then no &lt;code&gt;require&lt;/code&gt; call is emitted for that module. This elision of unused references is a good performance optimization, and also allows for optional loading of those modules.</source>
          <target state="translated">Компилятор определяет, используется ли каждый модуль в выпущенном JavaScript. Если идентификатор модуля не только когда - либо использовали как части типа аннотаций и никогда как выражение, то не &lt;code&gt;require&lt;/code&gt; вызова испускается для этого модуля. Это исключение неиспользуемых ссылок является хорошей оптимизацией производительности, а также допускает дополнительную загрузку этих модулей.</target>
        </trans-unit>
        <trans-unit id="2ee05054ac8f1f0d957bb3db6c7d04411ad1e817" translate="yes" xml:space="preserve">
          <source>The compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a &lt;code&gt;@constructor&lt;/code&gt; tag:</source>
          <target state="translated">Компилятор определяет функции конструктора на основе назначений этого свойства, но вы можете сделать проверку более строгой и предложения лучше, если добавите тег &lt;code&gt;@constructor&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="af8cada3d73e6f631af13e152a9d5e9310d04109" translate="yes" xml:space="preserve">
          <source>The compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.</source>
          <target state="translated">Компилятор выполняет препроцессирование входных файлов для разрешения всех директив ссылки тройной косой черты.В процессе компиляции добавляются дополнительные файлы.</target>
        </trans-unit>
        <trans-unit id="e0152e415fb0baecefa82a34c08f802b9d756e5b" translate="yes" xml:space="preserve">
          <source>The compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:</source>
          <target state="translated">Компилятор будет автоматически заказывать выходной файл на основе ссылочных тегов,присутствующих в файлах.Также можно указать каждый файл по отдельности:</target>
        </trans-unit>
        <trans-unit id="51e223694a5a5e5b0c431a15c4a8fae647f211ab" translate="yes" xml:space="preserve">
          <source>The compiler will generate a simple &lt;code&gt;for&lt;/code&gt; loop for a &lt;code&gt;for..of&lt;/code&gt; loop, for instance:</source>
          <target state="translated">Компилятор сгенерирует простой цикл for &lt;code&gt;for&lt;/code&gt; цикла &lt;code&gt;for..of&lt;/code&gt; , например:</target>
        </trans-unit>
        <trans-unit id="6a0d000ecdfc1359aa72dab512a544de23b44f6d" translate="yes" xml:space="preserve">
          <source>The compiler will now resolve &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; to &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; for tooling purposes, allowing development in a locale agnostic manner without compromising design time support.</source>
          <target state="translated">Теперь компилятор будет разрешать &lt;code&gt;import messages from './#{locale}/messages'&lt;/code&gt; чтобы &lt;code&gt;import messages from './zh/messages'&lt;/code&gt; для инструментальных целей, позволяя разработку независимо от языкового стандарта без ущерба для поддержки времени разработки.</target>
        </trans-unit>
        <trans-unit id="dededb8a14ae234f8b00237dd4d7d5520b09190d" translate="yes" xml:space="preserve">
          <source>The compiler will try to find a &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and then a &lt;code&gt;.d.ts&lt;/code&gt; with the appropriate path. If a specific file could not be found, then the compiler will look for an &lt;em&gt;ambient module declaration&lt;/em&gt;. Recall that these need to be declared in a &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">Компилятор попытается найти &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; , а затем &lt;code&gt;.d.ts&lt;/code&gt; с соответствующим путем. Если конкретный файл найти не удалось, компилятор будет искать объявление &lt;em&gt;внешнего модуля&lt;/em&gt; . Напомним, что их нужно объявить в файле &lt;code&gt;.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ba06dc9850414ee8093ec4891b1423ed7c4b5a5" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file.</source>
          <target state="translated">Сначала загружается конфигурация из базового файла,а затем переопределяется теми,кто находится в наследуемом файле конфигурации.</target>
        </trans-unit>
        <trans-unit id="c7417a4c25a8da7c3b9339e33fd087465dbdf022" translate="yes" xml:space="preserve">
          <source>The configuration from the base file are loaded first, then overridden by those in the inheriting config file. If a circularity is encountered, we report an error.</source>
          <target state="translated">Сначала загружается конфигурация из базового файла,а затем переопределяется теми,кто находится в наследуемом файле конфигурации.При возникновении цикличности мы сообщаем об ошибке.</target>
        </trans-unit>
        <trans-unit id="47cd6d852a954030c68d9ed9204072b9f5e61ecf" translate="yes" xml:space="preserve">
          <source>The constructor of a mixin class (if any) must have a single rest parameter of type &lt;code&gt;any[]&lt;/code&gt; and must use the spread operator to pass those parameters as arguments in a &lt;code&gt;super(...args)&lt;/code&gt; call.</source>
          <target state="translated">Конструктор класса миксина (если есть) должен иметь единственный параметр rest типа &lt;code&gt;any[]&lt;/code&gt; и должен использовать оператор распространения для передачи этих параметров в качестве аргументов в вызове &lt;code&gt;super(...args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c957312c57684bb0a68bd0033e5121474de252b4" translate="yes" xml:space="preserve">
          <source>The core idea of the pattern is that the &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; statement gives us access to the types exposed by the module. The module loader is invoked (through &lt;code&gt;require&lt;/code&gt;) dynamically, as shown in the &lt;code&gt;if&lt;/code&gt; blocks below. This leverages the reference-elision optimization so that the module is only loaded when needed. For this pattern to work, it&amp;rsquo;s important that the symbol defined via an &lt;code&gt;import&lt;/code&gt; is only used in type positions (i.e. never in a position that would be emitted into the JavaScript).</source>
          <target state="translated">Основная идея шаблона состоит в том, что оператор &lt;code&gt;import id = require(&quot;...&quot;)&lt;/code&gt; дает нам доступ к типам, предоставляемым модулем. Загрузчик модуля вызывается (через &lt;code&gt;require&lt;/code&gt; ) динамически, как показано в блоках &lt;code&gt;if&lt;/code&gt; ниже. Это усиливает оптимизацию исключения ссылок, так что модуль загружается только при необходимости. Для того, чтобы этот шаблон работал, важно, чтобы символ, определенный посредством &lt;code&gt;import&lt;/code&gt; использовался только в позициях типа (т.е. никогда в позиции, которая будет передана в JavaScript).</target>
        </trans-unit>
        <trans-unit id="d0b027c450a1f923c0be026c0dfd8a83c77d2420" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;tsconfig.json&lt;/code&gt; would look like:</source>
          <target state="translated">Соответствующий &lt;code&gt;tsconfig.json&lt;/code&gt; будет выглядеть так:</target>
        </trans-unit>
        <trans-unit id="7eeeab936d5101dbe33556330a8a2f0e148d5a0c" translate="yes" xml:space="preserve">
          <source>The declaration merge of &lt;code&gt;Animals&lt;/code&gt; in this example:</source>
          <target state="translated">Объявление слияния &lt;code&gt;Animals&lt;/code&gt; в этом примере:</target>
        </trans-unit>
        <trans-unit id="760e4e7cc5e42234f3bffea21b8ceac9a6ae4124" translate="yes" xml:space="preserve">
          <source>The default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a &lt;code&gt;string&lt;/code&gt; to a &lt;code&gt;number&lt;/code&gt;). This can be undesirable on build servers or other scenarios where only output from a &amp;ldquo;clean&amp;rdquo; build is desired. The new flag &lt;code&gt;noEmitOnError&lt;/code&gt; prevents the compiler from emitting .js code if there were any errors.</source>
          <target state="translated">Поведение по умолчанию для машинописи компилятора является еще испускает .js файлы , если возникают ошибки типа (например, попытка присвоить &lt;code&gt;string&lt;/code&gt; к &lt;code&gt;number&lt;/code&gt; ). Это может быть нежелательно на серверах сборки или в других сценариях, где желателен только вывод из &amp;laquo;чистой&amp;raquo; сборки. Новый флаг &lt;code&gt;noEmitOnError&lt;/code&gt; предотвращает выдачу компилятором кода .js в случае каких-либо ошибок.</target>
        </trans-unit>
        <trans-unit id="ae976d467a2e0b5f5be1f916e987a9fd2c7d4327" translate="yes" xml:space="preserve">
          <source>The default-ed properties are inferred from the &lt;code&gt;defaultProps&lt;/code&gt; property type. If an explicit type annotation is added, e.g. &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; the compiler will not be able to identify which properties have defaults (since the type of &lt;code&gt;defaultProps&lt;/code&gt; include all properties of &lt;code&gt;Props&lt;/code&gt;).</source>
          <target state="translated">Свойства по умолчанию выводятся из типа свойства &lt;code&gt;defaultProps&lt;/code&gt; . Если добавляется явная аннотация типа, например &lt;code&gt;static defaultProps: Partial&amp;lt;Props&amp;gt;;&lt;/code&gt; компилятор не сможет определить, какие свойства имеют значения по умолчанию (поскольку тип &lt;code&gt;defaultProps&lt;/code&gt; включает все свойства &lt;code&gt;Props&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1317688dfc3d42fd33a72fadf087e54e0802397" translate="yes" xml:space="preserve">
          <source>The definite assignment assertion is a feature that allows a &lt;code&gt;!&lt;/code&gt; to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript&amp;rsquo;s analyses cannot detect so.</source>
          <target state="translated">Утверждение определенного присваивания - это функция, которая позволяет &lt;code&gt;!&lt;/code&gt; должны быть размещены после объявлений свойств и переменных экземпляра, чтобы передать TypeScript, что переменная действительно назначена для всех намерений и целей, даже если анализ TypeScript не может этого обнаружить.</target>
        </trans-unit>
        <trans-unit id="5951769f90ddf6ef86202b76f38e00c40c68074c" translate="yes" xml:space="preserve">
          <source>The distributive property of conditional types can conveniently be used to &lt;em&gt;filter&lt;/em&gt; union types:</source>
          <target state="translated">Дистрибутивное свойство условных типов удобно использовать для &lt;em&gt;фильтрации&lt;/em&gt; типов объединения:</target>
        </trans-unit>
        <trans-unit id="6701107cdd8245fa22b60649bbf93c094765f72c" translate="yes" xml:space="preserve">
          <source>The dual of this is &lt;em&gt;indexed access types&lt;/em&gt;, also called &lt;em&gt;lookup types&lt;/em&gt;. Syntactically, they look exactly like an element access, but are written as types:</source>
          <target state="translated">Двойной эффект - это &lt;em&gt;индексированные типы доступа&lt;/em&gt; , также называемые &lt;em&gt;типами поиска&lt;/em&gt; . Синтаксически они выглядят точно так же, как доступ к элементу, но записываются как типы:</target>
        </trans-unit>
        <trans-unit id="f96a7965741a28dd3d210266390299a4c235d519" translate="yes" xml:space="preserve">
          <source>The easiest way to remember whether to use &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; is to ask whether you&amp;rsquo;re using it on a variable or a property. Variables use &lt;code&gt;const&lt;/code&gt; whereas properties use &lt;code&gt;readonly&lt;/code&gt;.</source>
          <target state="translated">Самый простой способ запомнить, использовать ли только &lt;code&gt;readonly&lt;/code&gt; или &lt;code&gt;const&lt;/code&gt; , - это спросить, используете ли вы его для переменной или свойства. Переменные используют &lt;code&gt;const&lt;/code&gt; , тогда как свойства используют только &lt;code&gt;readonly&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77d40241cfaf8a84ae6745611b0a0b930c4e9b68" translate="yes" xml:space="preserve">
          <source>The easiest way to see how interfaces work is to start with a simple example:</source>
          <target state="translated">Самый простой способ увидеть,как работают интерфейсы-начать с простого примера:</target>
        </trans-unit>
        <trans-unit id="36fb664df37642968e73b47232d19c28eafce856" translate="yes" xml:space="preserve">
          <source>The element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.</source>
          <target state="translated">Тип атрибута элемента используется для проверки атрибутов в JSX.Поддерживаются необязательные и требуемые свойства.</target>
        </trans-unit>
        <trans-unit id="f2cb300f34919973f86bda71fcf4a1681bebb7a8" translate="yes" xml:space="preserve">
          <source>The element instance type is interesting because it must be assignable to &lt;code&gt;JSX.ElementClass&lt;/code&gt; or it will result in an error. By default &lt;code&gt;JSX.ElementClass&lt;/code&gt; is &lt;code&gt;{}&lt;/code&gt;, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.</source>
          <target state="translated">Тип экземпляра элемента интересен тем, что он должен быть назначен &lt;code&gt;JSX.ElementClass&lt;/code&gt; , иначе это приведет к ошибке. По умолчанию &lt;code&gt;JSX.ElementClass&lt;/code&gt; равен &lt;code&gt;{}&lt;/code&gt; , но его можно расширить , чтобы ограничить использование JSX только теми типами, которые соответствуют правильному интерфейсу.</target>
        </trans-unit>
        <trans-unit id="0d4e3187b0c64f392d45e58c9337389c5cb0b1e1" translate="yes" xml:space="preserve">
          <source>The ellipsis is also used in the type of the function with rest parameters:</source>
          <target state="translated">Эллипсис также используется в типе функции с параметрами покоя:</target>
        </trans-unit>
        <trans-unit id="d715b5fd0797da50802172129520b9973d9f2c77" translate="yes" xml:space="preserve">
          <source>The enum member is initialized with a constant enum expression. A constant enum expression is a subset of TypeScript expressions that can be fully evaluated at compile time. An expression is a constant enum expression if it is:</source>
          <target state="translated">Член переписи инициализируется постоянным выражением.Константное выражение перечисления-это подмножество выражений TypeScript,которые могут быть полностью обработаны во время компиляции.Выражение является константным выражением перечисления,если оно есть:</target>
        </trans-unit>
        <trans-unit id="d313bf4ae6661330b1b3ab28e64f56b35e82367c" translate="yes" xml:space="preserve">
          <source>The exact factory function used by the &lt;code&gt;jsx: react&lt;/code&gt; compiler option is configurable. It may be set using either the &lt;code&gt;jsxFactory&lt;/code&gt; command line option, or an inline &lt;code&gt;@jsx&lt;/code&gt; comment pragma to set it on a per-file basis. For example, if you set &lt;code&gt;jsxFactory&lt;/code&gt; to &lt;code&gt;createElement&lt;/code&gt;, &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; will emit as &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; instead of &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;.</source>
          <target state="translated">Точная фабричная функция, используемая &lt;code&gt;jsx: react&lt;/code&gt; компилятора jsx: react, настраивается. Его можно установить с помощью &lt;code&gt;jsxFactory&lt;/code&gt; командной строки jsxFactory или встроенного &lt;code&gt;@jsx&lt;/code&gt; комментариев @jsx, чтобы установить его для каждого файла. Например, если вы установите &lt;code&gt;jsxFactory&lt;/code&gt; на &lt;code&gt;createElement&lt;/code&gt; , &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; будет генерировать как &lt;code&gt;createElement(&quot;div&quot;)&lt;/code&gt; вместо &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be983dcb009cbaef6ee420c2ca6026b157bd7e0a" translate="yes" xml:space="preserve">
          <source>The example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both &lt;code&gt;Snake&lt;/code&gt; and &lt;code&gt;Horse&lt;/code&gt; create a &lt;code&gt;move&lt;/code&gt; method that overrides the &lt;code&gt;move&lt;/code&gt; from &lt;code&gt;Animal&lt;/code&gt;, giving it functionality specific to each class. Note that even though &lt;code&gt;tom&lt;/code&gt; is declared as an &lt;code&gt;Animal&lt;/code&gt;, since its value is a &lt;code&gt;Horse&lt;/code&gt;, calling &lt;code&gt;tom.move(34)&lt;/code&gt; will call the overriding method in &lt;code&gt;Horse&lt;/code&gt;:</source>
          <target state="translated">В этом примере также показано, как переопределить методы в базовом классе методами, специализированными для этого подкласса. Здесь и &lt;code&gt;Snake&lt;/code&gt; , и &lt;code&gt;Horse&lt;/code&gt; создают метод &lt;code&gt;move&lt;/code&gt; который отменяет &lt;code&gt;move&lt;/code&gt; от &lt;code&gt;Animal&lt;/code&gt; , придавая ему функциональность, специфичную для каждого класса. Обратите внимание, что даже если &lt;code&gt;tom&lt;/code&gt; объявлен как &lt;code&gt;Animal&lt;/code&gt; , поскольку его значение - &lt;code&gt;Horse&lt;/code&gt; , вызов &lt;code&gt;tom.move(34)&lt;/code&gt; вызовет метод переопределения в &lt;code&gt;Horse&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9309c4e757aa256b16a0bad58b5e33a98c76cbc2" translate="yes" xml:space="preserve">
          <source>The example uses a nested function here because the compiler can&amp;rsquo;t eliminate nulls inside a nested function (except immediately-invoked function expressions). That&amp;rsquo;s because it can&amp;rsquo;t track all calls to the nested function, especially if you return it from the outer function. Without knowing where the function is called, it can&amp;rsquo;t know what the type of &lt;code&gt;name&lt;/code&gt; will be at the time the body executes.</source>
          <target state="translated">В этом примере используется вложенная функция, поскольку компилятор не может исключить значения NULL внутри вложенной функции (за исключением выражений функций, вызываемых немедленно). Это потому, что он не может отслеживать все вызовы вложенной функции, особенно если вы возвращаете ее из внешней функции. Не зная, где вызывается функция, он не может знать, какой тип &lt;code&gt;name&lt;/code&gt; будет во время выполнения тела.</target>
        </trans-unit>
        <trans-unit id="2521d541b8280fcd0c447ab0918ebaaed9adf402" translate="yes" xml:space="preserve">
          <source>The expression for the accessor decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">Выражение для декоратора аксессуара будет вызвано в качестве функции во время выполнения,с тремя следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="0b14168e95c9d9a01df3680215e98fc982e341d6" translate="yes" xml:space="preserve">
          <source>The expression for the class decorator will be called as a function at runtime, with the constructor of the decorated class as its only argument.</source>
          <target state="translated">Выражение для декоратора класса будет вызвано в качестве функции во время выполнения,при этом конструктор декорированного класса будет являться его единственным аргументом.</target>
        </trans-unit>
        <trans-unit id="0d60ee880be94f69fdd4585e45c1d4d2352936ea" translate="yes" xml:space="preserve">
          <source>The expression for the method decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">Выражение для декоратора метода будет вызвано в качестве функции во время выполнения,с тремя следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="5086d420edcd773ac6d732072618188585203199" translate="yes" xml:space="preserve">
          <source>The expression for the parameter decorator will be called as a function at runtime, with the following three arguments:</source>
          <target state="translated">Выражение для декоратора параметра будет вызвано в качестве функции во время выполнения,с тремя следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="edae3f3dc86e86b9a64d098ac85c40b60e98ad47" translate="yes" xml:space="preserve">
          <source>The expression for the property decorator will be called as a function at runtime, with the following two arguments:</source>
          <target state="translated">Выражение для декоратора свойства будет вызвано как функция во время выполнения,с двумя следующими аргументами:</target>
        </trans-unit>
        <trans-unit id="3e0ed5b6c650314a8da3d7c5c7c625309c2ba4c4" translate="yes" xml:space="preserve">
          <source>The expressions for each decorator are evaluated top-to-bottom.</source>
          <target state="translated">Выражения для каждого декоратора оцениваются сверху вниз.</target>
        </trans-unit>
        <trans-unit id="60727c2e253818c6e1394797bce9983cbcfb14d2" translate="yes" xml:space="preserve">
          <source>The factory chosen will also affect where the &lt;code&gt;JSX&lt;/code&gt; namespace is looked up (for type checking information) before falling back to the global one. If the factory is defined as &lt;code&gt;React.createElement&lt;/code&gt; (the default), the compiler will check for &lt;code&gt;React.JSX&lt;/code&gt; before checking for a global &lt;code&gt;JSX&lt;/code&gt;. If the factory is defined as &lt;code&gt;h&lt;/code&gt;, it will check for &lt;code&gt;h.JSX&lt;/code&gt; before a global &lt;code&gt;JSX&lt;/code&gt;.</source>
          <target state="translated">Выбранная фабрика также повлияет на то, где &lt;code&gt;JSX&lt;/code&gt; пространство имен JSX (для информации о проверке типов), прежде чем вернуться к глобальному. Если фабрика определена как &lt;code&gt;React.createElement&lt;/code&gt; (по умолчанию), компилятор проверяет наличие &lt;code&gt;React.JSX&lt;/code&gt; перед проверкой глобального &lt;code&gt;JSX&lt;/code&gt; . Если фабрика определена как &lt;code&gt;h&lt;/code&gt; , она будет проверять наличие &lt;code&gt;h.JSX&lt;/code&gt; перед глобальным &lt;code&gt;JSX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8cbf6331553242a5f0e701d007b43692f6b7d55" translate="yes" xml:space="preserve">
          <source>The first assignment is now an error. Effectively, &lt;code&gt;T&lt;/code&gt; is contravariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in function type parameter positions.</source>
          <target state="translated">Первое присвоение теперь является ошибкой. Фактически, &lt;code&gt;T&lt;/code&gt; контравариантен в &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; потому что он используется только в позициях параметра типа функции.</target>
        </trans-unit>
        <trans-unit id="f83cf7bff16c656834b3e301df968baf4cd1ffca" translate="yes" xml:space="preserve">
          <source>The first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is &lt;em&gt;possibly&lt;/em&gt; sound, whereas strict function types mode makes it an error because it isn&amp;rsquo;t &lt;em&gt;provably&lt;/em&gt; sound. In either mode the third assignment is an error because it is &lt;em&gt;never&lt;/em&gt; sound.</source>
          <target state="translated">Первое присвоение разрешено в режиме проверки типов по умолчанию, но помечено как ошибка в режиме строгих типов функций. Интуитивно понятно, что режим по умолчанию разрешает назначение, потому что он, &lt;em&gt;возможно,&lt;/em&gt; является правильным, тогда как режим строгих типов функций делает его ошибкой, потому что он не является &lt;em&gt;доказуемым&lt;/em&gt; . В любом режиме третье назначение является ошибкой, потому что оно &lt;em&gt;никогда не&lt;/em&gt; звучит.</target>
        </trans-unit>
        <trans-unit id="86d2c2eef081b9efd8e081cbfc7a2eb73c95a9bf" translate="yes" xml:space="preserve">
          <source>The first is that enum members also become types as well! For example, we can say that certain members can &lt;em&gt;only&lt;/em&gt; have the value of an enum member:</source>
          <target state="translated">Во-первых, члены перечисления также становятся типами! Например, мы можем сказать, что определенные члены могут иметь &lt;em&gt;только&lt;/em&gt; значение члена перечисления:</target>
        </trans-unit>
        <trans-unit id="11b6104cea3d7fbf08969b5f72b6d05a84f6d569" translate="yes" xml:space="preserve">
          <source>The first line tells Visual Studio to run the task &amp;lsquo;default&amp;rsquo; after the build finishes. It will also run the &amp;lsquo;clean&amp;rsquo; task when you ask Visual Studio to clean the build.</source>
          <target state="translated">Первая строка указывает Visual Studio запустить задачу по умолчанию после завершения сборки. Он также запустит &amp;laquo;чистую&amp;raquo; задачу, когда вы попросите Visual Studio очистить сборку.</target>
        </trans-unit>
        <trans-unit id="f589b53519dab849472b770ba61a662532e94279" translate="yes" xml:space="preserve">
          <source>The first step to type checking attributes is to determine the &lt;em&gt;element attributes type&lt;/em&gt;. This is slightly different between intrinsic and value-based elements.</source>
          <target state="translated">Первым шагом к проверке типа атрибутов является определение &lt;em&gt;типа атрибутов элемента&lt;/em&gt; . Это немного отличается между внутренними элементами и элементами, основанными на значениях.</target>
        </trans-unit>
        <trans-unit id="58af75a63079336d3af143e1407bc44a6c44b6ef" translate="yes" xml:space="preserve">
          <source>The first thing you may notice in the above is that instead of trying to extend &lt;code&gt;Disposable&lt;/code&gt; and &lt;code&gt;Activatable&lt;/code&gt; in &lt;code&gt;SmartObject&lt;/code&gt; class, we extend them in &lt;code&gt;SmartObject&lt;/code&gt; interface. &lt;code&gt;SmartObject&lt;/code&gt; interface will be mixed into the &lt;code&gt;SmartObject&lt;/code&gt; class due to the &lt;a href=&quot;declaration-merging&quot;&gt;declaration merging&lt;/a&gt;.</source>
          <target state="translated">Первое, что вы можете заметить в приведенном выше, - это то, что вместо того, чтобы пытаться расширить &lt;code&gt;Disposable&lt;/code&gt; и &lt;code&gt;Activatable&lt;/code&gt; в классе &lt;code&gt;SmartObject&lt;/code&gt; , мы расширяем их в интерфейсе &lt;code&gt;SmartObject&lt;/code&gt; . Интерфейс &lt;code&gt;SmartObject&lt;/code&gt; будет смешан с классом &lt;code&gt;SmartObject&lt;/code&gt; из-за &lt;a href=&quot;declaration-merging&quot;&gt;слияния деклараций&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1598a89fa953ba70cfbbf99c377df16fd8ed251e" translate="yes" xml:space="preserve">
          <source>The first type of assertion signature models the way that Node&amp;rsquo;s &lt;code&gt;assert&lt;/code&gt; function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.</source>
          <target state="translated">Первый тип подписи утверждения моделирует способ работы функции &lt;code&gt;assert&lt;/code&gt; Node . Это гарантирует, что любое проверяемое условие должно быть истинным для оставшейся части содержащей области.</target>
        </trans-unit>
        <trans-unit id="e7ac3fa8432f39d89d10777015cb56ae8fd93747" translate="yes" xml:space="preserve">
          <source>The flexibility of &lt;code&gt;rootDirs&lt;/code&gt; is not limited to specifying a list of physical source directories that are logically merged. The supplied array may include any number of ad hoc, arbitrary directory names, regardless of whether they exist or not. This allows the compiler to capture sophisticated bundling and runtime features such as conditional inclusion and project specific loader plugins in a type safe way.</source>
          <target state="translated">Гибкость &lt;code&gt;rootDirs&lt;/code&gt; не ограничивается указанием списка физических исходных каталогов, которые логически объединены. Предоставляемый массив может включать в себя любое количество произвольных произвольных имен каталогов, независимо от того, существуют они или нет. Это позволяет компилятору захватывать сложные функции связывания и выполнения, такие как условное включение и специальные плагины загрузчика проекта, безопасным для типов способом.</target>
        </trans-unit>
        <trans-unit id="6ba8cf088bc4a62237fb1f09825df1931ceb84e4" translate="yes" xml:space="preserve">
          <source>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</source>
          <target state="translated">Следующий пример демонстрирует,как несколько кандидатов на одну и ту же переменную типа в ковариантных позициях приводят к выводу о типе союза:</target>
        </trans-unit>
        <trans-unit id="aa5d6454fbf6bf730c8b327164f77ed6f69baf2e" translate="yes" xml:space="preserve">
          <source>The following is an example of a class decorator (&lt;code&gt;@sealed&lt;/code&gt;) applied to the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">Ниже приведен пример декоратора класса ( &lt;code&gt;@sealed&lt;/code&gt; ), примененного к классу &lt;code&gt;Greeter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="894306209d899f3f7794eaec540a57c394ffa6ed" translate="yes" xml:space="preserve">
          <source>The following is an example of a method decorator (&lt;code&gt;@enumerable&lt;/code&gt;) applied to a method on the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">Ниже приведен пример декоратора метода ( &lt;code&gt;@enumerable&lt;/code&gt; ), применяемого к методу класса &lt;code&gt;Greeter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="56eb8bb77b4d8ce3acb0c50224bfb3b899067f94" translate="yes" xml:space="preserve">
          <source>The following is an example of a parameter decorator (&lt;code&gt;@required&lt;/code&gt;) applied to parameter of a member of the &lt;code&gt;Greeter&lt;/code&gt; class:</source>
          <target state="translated">Ниже приведен пример декоратора параметров ( &lt;code&gt;@required&lt;/code&gt; ), применяемого к параметру члена класса &lt;code&gt;Greeter&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4c9599f42a20eb3b17874db9fbac592989bd9e8c" translate="yes" xml:space="preserve">
          <source>The following is an example of an accessor decorator (&lt;code&gt;@configurable&lt;/code&gt;) applied to a member of the &lt;code&gt;Point&lt;/code&gt; class:</source>
          <target state="translated">Ниже приведен пример декоратора доступа ( &lt;code&gt;@configurable&lt;/code&gt; ), применяемого к члену класса &lt;code&gt;Point&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f1290f593b907ee11da2a865c78e736129d049be" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;foo&lt;/code&gt; contains the number of widgets present.</source>
          <target state="translated">Глобальная переменная &lt;code&gt;foo&lt;/code&gt; содержит количество присутствующих виджетов.</target>
        </trans-unit>
        <trans-unit id="5cf5ea298d71b31d168d1d4cfd5dd7bf5304c883" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;myLib&lt;/code&gt; has a function &lt;code&gt;makeGreeting&lt;/code&gt; for creating greetings, and a property &lt;code&gt;numberOfGreetings&lt;/code&gt; indicating the number of greetings made so far.</source>
          <target state="translated">Глобальная переменная &lt;code&gt;myLib&lt;/code&gt; имеет функцию &lt;code&gt;makeGreeting&lt;/code&gt; для создания приветствий и свойство &lt;code&gt;numberOfGreetings&lt;/code&gt; , указывающее количество сделанных приветствий.</target>
        </trans-unit>
        <trans-unit id="fbf0d9abbae1382a841d6a20a7fd42f5f792dbfd" translate="yes" xml:space="preserve">
          <source>The guide is broken down into the following sections.</source>
          <target state="translated">Руководство разбито на следующие разделы.</target>
        </trans-unit>
        <trans-unit id="152f8cc5510f46a1bacae33a53ef9b6ca874c1fb" translate="yes" xml:space="preserve">
          <source>The inference process is fairly straightforward here because &lt;code&gt;getDisplayName&lt;/code&gt; and &lt;code&gt;getLength&lt;/code&gt; use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like &lt;code&gt;compose&lt;/code&gt; didn&amp;rsquo;t work so well when passed other generic functions.</source>
          <target state="translated">Здесь процесс вывода довольно прост, потому что &lt;code&gt;getDisplayName&lt;/code&gt; и &lt;code&gt;getLength&lt;/code&gt; используют типы, на которые легко ссылаться. Однако в TypeScript 3.3 и ранее универсальные функции, такие как &lt;code&gt;compose&lt;/code&gt; , не работали так хорошо при передаче других универсальных функций.</target>
        </trans-unit>
        <trans-unit id="2bd1d13df309ad7c445be96538c356e69d82dd45" translate="yes" xml:space="preserve">
          <source>The inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:</source>
          <target state="translated">Предполагаемый тип возврата функции может быть типом,объявленным локально внутри функции.Вызовы функции не могут ссылаться на такой локальный тип,но,конечно,могут быть структурно подобраны.Например:</target>
        </trans-unit>
        <trans-unit id="47a1b4c14a30afe92145ea5aeaecb13f79bfbd9a" translate="yes" xml:space="preserve">
          <source>The instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:</source>
          <target state="translated">Сторона экземпляра декларации класса окружающей среды может быть расширена с помощью декларации интерфейса Объект конструктора класса немодифицирован.Например:</target>
        </trans-unit>
        <trans-unit id="0e67711effae647619fb03057e9603bedb94bf60" translate="yes" xml:space="preserve">
          <source>The intent of any function that returns &lt;code&gt;never&lt;/code&gt; is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt;&lt;code&gt;process.exit(...)&lt;/code&gt; in &lt;code&gt;@types/node&lt;/code&gt;&lt;/a&gt; is specified to return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">Цель любой функции, которая &lt;code&gt;never&lt;/code&gt; возвращает, состоит в том, чтобы она никогда не возвращалась. Он указывает на то, что возникло исключение, возникла ошибка остановки или что программа завершилась. Например, &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5299d372a220584e75a031c13b3d555607af13f8/types/node/globals.d.ts#l874&quot;&gt; &lt;code&gt;process.exit(...)&lt;/code&gt; в &lt;code&gt;@types/node&lt;/code&gt; &lt;/a&gt; указано, чтобы &lt;code&gt;never&lt;/code&gt; возвращать .</target>
        </trans-unit>
        <trans-unit id="8083efa15c72562212b03ec1e7d929e3b1bfe6f0" translate="yes" xml:space="preserve">
          <source>The interface &lt;code&gt;LabeledValue&lt;/code&gt; is a name we can now use to describe the requirement in the previous example. It still represents having a single property called &lt;code&gt;label&lt;/code&gt; that is of type &lt;code&gt;string&lt;/code&gt;. Notice we didn&amp;rsquo;t have to explicitly say that the object we pass to &lt;code&gt;printLabel&lt;/code&gt; implements this interface like we might have to in other languages. Here, it&amp;rsquo;s only the shape that matters. If the object we pass to the function meets the requirements listed, then it&amp;rsquo;s allowed.</source>
          <target state="translated">Интерфейс &lt;code&gt;LabeledValue&lt;/code&gt; - это имя, которое мы теперь можем использовать для описания требования в предыдущем примере. Он по-прежнему представляет собой одно свойство, называемое &lt;code&gt;label&lt;/code&gt; которое имеет тип &lt;code&gt;string&lt;/code&gt; . Обратите внимание, что нам не нужно было явно &lt;code&gt;printLabel&lt;/code&gt; что объект, который мы передаем printLabel, реализует этот интерфейс, как это могло бы потребоваться в других языках. Здесь имеет значение только форма. Если объект, который мы передаем функции, соответствует перечисленным требованиям, то это разрешено.</target>
        </trans-unit>
        <trans-unit id="cd1c38f5000220665076a2e98824f2dbc1f3584b" translate="yes" xml:space="preserve">
          <source>The key difference is not in the syntax, but in the semantics, which we&amp;rsquo;ll now dive into.</source>
          <target state="translated">Ключевое различие не в синтаксисе, а в семантике, в которую мы сейчас углубимся.</target>
        </trans-unit>
        <trans-unit id="b1b9a12d68027688efebd6988d804e470eefcb75" translate="yes" xml:space="preserve">
          <source>The last element of a tuple type can be a rest element of the form &lt;code&gt;...X&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, &lt;code&gt;[number, ...string[]]&lt;/code&gt; means tuples with a &lt;code&gt;number&lt;/code&gt; element followed by any number of &lt;code&gt;string&lt;/code&gt; elements.</source>
          <target state="translated">Последний элемент кортежного типа может быть остальным элементом формы &lt;code&gt;...X&lt;/code&gt; , где &lt;code&gt;X&lt;/code&gt; - это тип массива. Элемент rest указывает, что тип кортежа является открытым и может иметь ноль или более дополнительных элементов типа элемента массива. Например, &lt;code&gt;[number, ...string[]]&lt;/code&gt; средства кортежи с &lt;code&gt;number&lt;/code&gt; элемента с последующим любым количеством &lt;code&gt;string&lt;/code&gt; элементов.</target>
        </trans-unit>
        <trans-unit id="d4b0bc795023f6d40258c16a24c570ab3f6de281" translate="yes" xml:space="preserve">
          <source>The layout of your declaration files should mirror the layout of the library.</source>
          <target state="translated">Макет файлов деклараций должен отражать макет библиотеки.</target>
        </trans-unit>
        <trans-unit id="62c6720928ebff15b4528d428a66db79a0e91621" translate="yes" xml:space="preserve">
          <source>The library can then be used as an import within modules:</source>
          <target state="translated">Библиотека затем может быть использована как импорт внутри модулей:</target>
        </trans-unit>
        <trans-unit id="5c400cd4aab73c26b9cba5406e5bfac6b44dcde8" translate="yes" xml:space="preserve">
          <source>The list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.</source>
          <target state="translated">В приведенном ниже списке описано,какие конструкции в настоящее время поддерживаются при использовании аннотаций JSDoc для предоставления информации о типах в JavaScript-файлах.</target>
        </trans-unit>
        <trans-unit id="dfd2bc32d3b21a5f15921128bd3664a23c6123a7" translate="yes" xml:space="preserve">
          <source>The locale to use to show error messages, e.g. en-us.</source>
          <target state="translated">Локаль,используемая для отображения сообщений об ошибках,например,en-us.</target>
        </trans-unit>
        <trans-unit id="745d0c4fae6c29892a03fe80ac17ab71cddad006" translate="yes" xml:space="preserve">
          <source>The majority of this handbook uses &lt;code&gt;let&lt;/code&gt; declarations.</source>
          <target state="translated">В большинстве случаев в этом справочнике используются объявления &lt;code&gt;let&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6da0134724ec18c2aa83421ac5856f5cd2ff92c3" translate="yes" xml:space="preserve">
          <source>The maximum dependency depth to search under node_modules and load JavaScript files. Only applicable with &lt;code&gt;--allowJs&lt;/code&gt;.</source>
          <target state="translated">Максимальная глубина зависимости для поиска в node_modules и загрузки файлов JavaScript. Применимо только с &lt;code&gt;--allowJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="931a11093903bc4e1293ac6a3b67077bc77990a3" translate="yes" xml:space="preserve">
          <source>The meaning is usually the same, or a superset, of the meaning of the tag given at usejsdoc.org. The code below describes the differences and gives some example usage of each tag.</source>
          <target state="translated">Обычно значение тэга,заданного в usejsdoc.org,одно и то же,или суперсет,что и значение тэга.Нижеприведенный код описывает различия и приводит некоторые примеры использования каждого тега.</target>
        </trans-unit>
        <trans-unit id="5ce56ea092f5ec509f61892542f58f563f4f1ba4" translate="yes" xml:space="preserve">
          <source>The module name is resolved the same way as module specifiers in &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;. See &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; for more information. Then the declarations in an augmentation are merged as if they were declared in the same file as the original.</source>
          <target state="translated">Имя модуля разрешается так же, как спецификаторы модуля при &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; . См. &lt;a href=&quot;modules&quot;&gt;Модули&lt;/a&gt; для получения дополнительной информации. Затем объявления в дополнении объединяются, как если бы они были объявлены в том же файле, что и оригинал.</target>
        </trans-unit>
        <trans-unit id="07d6025a4d8631b7d86a3f44337b3b6ce6a9547d" translate="yes" xml:space="preserve">
          <source>The module support in Javascript is much more syntactically forgiving than Typescript&amp;rsquo;s module support. Most combinations of assignments and declarations are supported.</source>
          <target state="translated">Поддержка модулей в Javascript гораздо более проста с синтаксической точки зрения, чем поддержка модулей в Typescript. Поддерживается большинство комбинаций присваиваний и объявлений.</target>
        </trans-unit>
        <trans-unit id="72abf6e26cd87e8f0de9628019db48b91ac42135" translate="yes" xml:space="preserve">
          <source>The most basic datatype is the simple true/false value, which JavaScript and TypeScript call a &lt;code&gt;boolean&lt;/code&gt; value.</source>
          <target state="translated">Самый простой тип данных - это простое значение true / false, которое JavaScript и TypeScript называют &lt;code&gt;boolean&lt;/code&gt; значением.</target>
        </trans-unit>
        <trans-unit id="79f9e1701395e49a979bcc38539774286a14204c" translate="yes" xml:space="preserve">
          <source>The most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.</source>
          <target state="translated">Наиболее впечатляющий результат этой возможности может быть несколько неуловимым:с помощью TypeScript 3.7,пользователи могут писать библиотеки на JavaScript с аннотациями JSDoc и поддерживать пользователей TypeScript.</target>
        </trans-unit>
        <trans-unit id="d479ce4d899b82dead8eec0f18d6751cfd1966b0" translate="yes" xml:space="preserve">
          <source>The motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:</source>
          <target state="translated">Мотивирующим примером является общий шаблон функции,которая принимает обратный вызов и вызывает его с каким-то предсказуемым (для программиста),но неизвестным (для системы типов)количеством аргументов:</target>
        </trans-unit>
        <trans-unit id="a57329ec0396a0060bb3225032730f604a10bd46" translate="yes" xml:space="preserve">
          <source>The name of a module augmentation is resolved using the same set of rules as module specifiers in &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.</source>
          <target state="translated">Имя расширения модуля определяется с использованием того же набора правил, что и спецификаторы модуля в объявлениях &lt;code&gt;import&lt;/code&gt; и &lt;code&gt;export&lt;/code&gt; . Объявления в дополнении модуля объединяются с любыми существующими объявлениями так же, как если бы они были объявлены в одном файле.</target>
        </trans-unit>
        <trans-unit id="89f93191caae9470e60a7d3f09f4c2434d9bcb48" translate="yes" xml:space="preserve">
          <source>The name of the member.</source>
          <target state="translated">Имя члена.</target>
        </trans-unit>
        <trans-unit id="bf6a2b3b69a6eaafe919135aca00082a2b3c554f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--showConfig&lt;/code&gt; flag</source>
          <target state="translated">Новый флаг &lt;code&gt;--showConfig&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b915c8b00bd04df204cf54cb79ae4b4967b8188e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;--strict&lt;/code&gt; compiler option represents the recommended setting of a number of type checking options. Specifically, specifying &lt;code&gt;--strict&lt;/code&gt; corresponds to specifying all of the following options (and may in the future include more options):</source>
          <target state="translated">Новая &lt;code&gt;--strict&lt;/code&gt; компилятора --strict представляет собой рекомендуемую настройку ряда опций проверки типов. В частности, указание &lt;code&gt;--strict&lt;/code&gt; соответствует указанию всех следующих параметров (и в будущем может включать дополнительные параметры):</target>
        </trans-unit>
        <trans-unit id="46ab9ac92f2751e3448564e3b2bbebba0803af30" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-dependency name&lt;/code&gt; property allows passing an optional name for an amd-dependency:</source>
          <target state="translated">Новое свойство &lt;code&gt;amd-dependency name&lt;/code&gt; позволяет передавать необязательное имя для amd-зависимости:</target>
        </trans-unit>
        <trans-unit id="b0b30ce72a1fbb86ba7cb09b3d3773b6f87269d1" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;amd-module name&lt;/code&gt; tag allows passing an optional module name to the compiler:</source>
          <target state="translated">Новый тег &lt;code&gt;amd-module name&lt;/code&gt; позволяет передавать компилятору необязательное имя модуля:</target>
        </trans-unit>
        <trans-unit id="00c1dd0b1d0ca34ff1579a9b55a20060afb63f62" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;protected&lt;/code&gt; modifier in classes works like it does in familiar languages like C++, C#, and Java. A &lt;code&gt;protected&lt;/code&gt; member of a class is visible only inside subclasses of the class in which it is declared:</source>
          <target state="translated">Новый модификатор &lt;code&gt;protected&lt;/code&gt; в классах работает так же, как и в знакомых языках, таких как C ++, C # и Java. &lt;code&gt;protected&lt;/code&gt; член класса виден только внутри подклассов класса , в котором он заявил:</target>
        </trans-unit>
        <trans-unit id="4be0bd15099c0de30a7f92de365d0546b8ad473c" translate="yes" xml:space="preserve">
          <source>The new ES6 keyword &lt;code&gt;let&lt;/code&gt;, now supported in TypeScript, declares a variable with more intuitive &amp;ldquo;block&amp;rdquo; semantics. A &lt;code&gt;let&lt;/code&gt; variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:</source>
          <target state="translated">Новое ключевое слово ES6 &lt;code&gt;let&lt;/code&gt; , теперь поддерживаемое в TypeScript, объявляет переменную с более интуитивной &amp;laquo;блочной&amp;raquo; семантикой. На переменную &lt;code&gt;let&lt;/code&gt; можно ссылаться только после ее объявления, она ограничена синтаксическим блоком, в котором она определена:</target>
        </trans-unit>
        <trans-unit id="631ad33334be4530d47703f4e1d29cda38f087ea" translate="yes" xml:space="preserve">
          <source>The new factory name will be used to call &lt;code&gt;createElement&lt;/code&gt; and &lt;code&gt;__spread&lt;/code&gt; functions.</source>
          <target state="translated">Новое имя фабрики будет использоваться для вызова функций &lt;code&gt;createElement&lt;/code&gt; и &lt;code&gt;__spread&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61ddaaf04d8d0073ea020e3954c9d83ac5bd7ac" translate="yes" xml:space="preserve">
          <source>The new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the &lt;code&gt;!&lt;/code&gt; non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.</source>
          <target state="translated">Новые функции разработаны таким образом, что их можно использовать как в режиме строгой проверки нуля, так и в режиме обычной проверки типа. В частности, &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; типы автоматически удаляются из типов объединения в обычном режиме проверки типов (поскольку они являются подтипами всех других типов), а символ &lt;code&gt;!&lt;/code&gt; Ненулевой оператор выражения утверждения разрешен, но не действует в режиме проверки обычного типа. Таким образом, файлы объявлений, которые обновлены для использования типов, поддерживающих значения null и undefined, могут по-прежнему использоваться в обычном режиме проверки типов для обеспечения обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="c30cd7e33232b4d2a28f205e7ae9088fbd691c02" translate="yes" xml:space="preserve">
          <source>The new handbook which is a work in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6846e96b454262c109940d0e55e3a4611d91414" translate="yes" xml:space="preserve">
          <source>The new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.</source>
          <target state="translated">Новое внедрение также приносит повышение производительности для просмотра в tsserver.Логика наблюдателя была полностью переписана,чтобы быстрее реагировать на изменяющиеся события.</target>
        </trans-unit>
        <trans-unit id="5a00224be7961350e2a8ff419045fdd51b036e82" translate="yes" xml:space="preserve">
          <source>The new module &lt;code&gt;ProgrammerCalculator&lt;/code&gt; exports an API shape similar to that of the original &lt;code&gt;Calculator&lt;/code&gt; module, but does not augment any objects in the original module. Here is a test for our ProgrammerCalculator class:</source>
          <target state="translated">Новый модуль &lt;code&gt;ProgrammerCalculator&lt;/code&gt; экспортирует форму API, аналогичную форме исходного модуля &lt;code&gt;Calculator&lt;/code&gt; , но не увеличивает какие-либо объекты в исходном модуле. Вот тест для нашего класса ProgrammerCalculator:</target>
        </trans-unit>
        <trans-unit id="2225a57adb33f21d4ebaaf566df0e99ffcf91683" translate="yes" xml:space="preserve">
          <source>The new playground now supports many new options including:</source>
          <target state="translated">Новая игровая площадка теперь поддерживает много новых опций,в том числе:</target>
        </trans-unit>
        <trans-unit id="68e11c2fb3a7db4e23da7d9de3e1a26ceae03748" translate="yes" xml:space="preserve">
          <source>The nightlies are available on &lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;www.myget.org&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.myget.org/gallery/typescript-preview&quot;&gt;Ночные клубы&lt;/a&gt; доступны на www.myget.org .</target>
        </trans-unit>
        <trans-unit id="eb8de4c955d33fe91a7e4cbce1b7361bd5b2b3a3" translate="yes" xml:space="preserve">
          <source>The nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.</source>
          <target state="translated">Ночная сборка в настоящее время не включает в себя полную настройку плагина,но мы также работаем над публикацией программы установки на ночной основе.</target>
        </trans-unit>
        <trans-unit id="cfcfc96df71a12a29b5ce210c72d3e03c563d868" translate="yes" xml:space="preserve">
          <source>The old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">Старое поведение остается прежним, если задан каталог - компилятор попытается найти файл в каталоге с именем &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b20ba860bfef9c7687f7310f99a76fe76d3783b" translate="yes" xml:space="preserve">
          <source>The order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads &amp;ldquo;win out&amp;rdquo; over previously created properties.</source>
          <target state="translated">Порядок указания операций распространения определяет, какие свойства в конечном итоге будут в результирующем объекте; свойства в более поздних спредах &amp;laquo;побеждают&amp;raquo; ранее созданные свойства.</target>
        </trans-unit>
        <trans-unit id="e7c876e1891bde60e537d27b5754b63af03257e0" translate="yes" xml:space="preserve">
          <source>The ordinal index of the parameter in the function&amp;rsquo;s parameter list.</source>
          <target state="translated">Порядковый индекс параметра в списке параметров функции.</target>
        </trans-unit>
        <trans-unit id="fb4cf9f813aa96ef2c61a94ad9fdf59d13dba821" translate="yes" xml:space="preserve">
          <source>The other change is that enum types themselves effectively become a &lt;em&gt;union&lt;/em&gt; of each enum member. While we haven&amp;rsquo;t discussed &lt;a href=&quot;advanced-types#union-types&quot;&gt;union types&lt;/a&gt; yet, all that you need to know is that with union enums, the type system is able to leverage the fact that it knows the exact set of values that exist in the enum itself. Because of that, TypeScript can catch silly bugs where we might be comparing values incorrectly. For example:</source>
          <target state="translated">Другое изменение заключается в том, что сами типы перечисления фактически становятся &lt;em&gt;объединением&lt;/em&gt; каждого члена перечисления. Хотя мы еще не обсуждали &lt;a href=&quot;advanced-types#union-types&quot;&gt;типы объединений&lt;/a&gt; , все, что вам нужно знать, это то, что с перечислениями объединений система типов может использовать тот факт, что она знает точный набор значений, которые существуют в самом перечислении. Из-за этого TypeScript может отлавливать глупые ошибки, когда мы можем неправильно сравнивать значения. Например:</target>
        </trans-unit>
        <trans-unit id="87a6d3fa93df1a7b5718c28d49fe2488fc9f01eb" translate="yes" xml:space="preserve">
          <source>The other new ES6 declaration type supported in TypeScript is &lt;code&gt;const&lt;/code&gt;. A &lt;code&gt;const&lt;/code&gt; variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don&amp;rsquo;t want to change the value after its initialization:</source>
          <target state="translated">Другой новый тип объявления ES6, поддерживаемый в TypeScript, - это &lt;code&gt;const&lt;/code&gt; . &lt;code&gt;const&lt;/code&gt; переменная не может быть назначен, и должен быть инициализирован , где она объявлена. Это полезно для объявлений, в которых вы не хотите изменять значение после его инициализации:</target>
        </trans-unit>
        <trans-unit id="e032670f94ed341d763142ae7b65b1fabd05bbb1" translate="yes" xml:space="preserve">
          <source>The other type of assertion signature doesn&amp;rsquo;t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.</source>
          <target state="translated">Другой тип подписи утверждения не проверяет условие, а вместо этого сообщает TypeScript, что конкретная переменная или свойство имеет другой тип.</target>
        </trans-unit>
        <trans-unit id="eda209051691c244644fa70c53c6b169301d940d" translate="yes" xml:space="preserve">
          <source>The popular library D3 defines its functionality in a global object called &lt;code&gt;d3&lt;/code&gt;. Because this library is loaded through a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:</source>
          <target state="translated">Популярная библиотека D3 определяет свои функции в глобальном объекте &lt;code&gt;d3&lt;/code&gt; . Поскольку эта библиотека загружается через &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; (вместо загрузчика модуля), ее объявление использует пространства имен для определения ее формы. Чтобы компилятор TypeScript увидел эту фигуру, мы используем объявление внешнего пространства имен. Например, мы могли бы начать писать так:</target>
        </trans-unit>
        <trans-unit id="38c72ee7b721075b6b228593c6729fd98fa3d861" translate="yes" xml:space="preserve">
          <source>The preceding two types are equivalent to the Typescript types &lt;code&gt;{ [x: string]: number }&lt;/code&gt; and &lt;code&gt;{ [x: number]: any }&lt;/code&gt;. The compiler understands both syntaxes.</source>
          <target state="translated">Предыдущие два типа эквивалентны типам Typescript &lt;code&gt;{ [x: string]: number }&lt;/code&gt; и &lt;code&gt;{ [x: number]: any }&lt;/code&gt; . Компилятор понимает оба синтаксиса.</target>
        </trans-unit>
        <trans-unit id="aa67059f742d5b7173801d752e91479969530cea" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The &lt;code&gt;tsconfig.json&lt;/code&gt; file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">Наличие файла &lt;code&gt;tsconfig.json&lt;/code&gt; в каталоге указывает на то, что каталог является корнем проекта TypeScript. В файле &lt;code&gt;tsconfig.json&lt;/code&gt; указаны корневые файлы и параметры компилятора, необходимые для компиляции проекта. Проект компилируется одним из следующих способов:</target>
        </trans-unit>
        <trans-unit id="088fad3bfe9085a4bf306d60f92061feba8a8ef7" translate="yes" xml:space="preserve">
          <source>The problem with &lt;code&gt;padLeft&lt;/code&gt; is that its &lt;code&gt;padding&lt;/code&gt; parameter is typed as &lt;code&gt;any&lt;/code&gt;. That means that we can call it with an argument that&amp;rsquo;s neither a &lt;code&gt;number&lt;/code&gt; nor a &lt;code&gt;string&lt;/code&gt;, but TypeScript will be okay with it.</source>
          <target state="translated">Проблема с &lt;code&gt;padLeft&lt;/code&gt; заключается в том, что его параметр &lt;code&gt;padding&lt;/code&gt; набирается как &lt;code&gt;any&lt;/code&gt; . Это означает, что мы можем вызвать его с аргументом, который не является ни &lt;code&gt;number&lt;/code&gt; ни &lt;code&gt;string&lt;/code&gt; , но TypeScript с этим согласится.</target>
        </trans-unit>
        <trans-unit id="1bb7381db8810d933065e806b992cda45878627e" translate="yes" xml:space="preserve">
          <source>The process of resolving these package names is similar to the process of resolving module names in an &lt;code&gt;import&lt;/code&gt; statement. An easy way to think of triple-slash-reference-types directives are as an &lt;code&gt;import&lt;/code&gt; for declaration packages.</source>
          <target state="translated">Процесс разрешения этих имен пакетов аналогичен процессу разрешения имен модулей в операторе &lt;code&gt;import&lt;/code&gt; . Директивы типов с тройной косой чертой и ссылочными типами проще всего рассматривать как &lt;code&gt;import&lt;/code&gt; для пакетов объявлений.</target>
        </trans-unit>
        <trans-unit id="aafd5dd1f8eca4eda75bcd1718aa421a44d595dd" translate="yes" xml:space="preserve">
          <source>The process starts with a set of &lt;em&gt;root files&lt;/em&gt;; these are the file names specified on the command-line or in the &lt;code&gt;&quot;files&quot;&lt;/code&gt; list in the &lt;code&gt;tsconfig.json&lt;/code&gt; file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth first manner, in the order they have been seen in the file.</source>
          <target state="translated">Процесс начинается с набора &lt;em&gt;корневых файлов&lt;/em&gt; ; это имена файлов, указанные в командной строке или в списке &lt;code&gt;&quot;files&quot;&lt;/code&gt; в файле &lt;code&gt;tsconfig.json&lt;/code&gt; . Эти корневые файлы предварительно обрабатываются в том же порядке, в котором они указаны. Прежде чем файл будет добавлен в список, все ссылки с тройной косой чертой в нем обрабатываются, и их цели включаются. Ссылки с тройной косой чертой разрешаются сначала в глубину, в том порядке, в котором они были показаны в файле.</target>
        </trans-unit>
        <trans-unit id="17ce755b0cdb23dc9be9ae1982b9a584f1e51772" translate="yes" xml:space="preserve">
          <source>The program should print &amp;ldquo;Hello from TypeScript!&amp;rdquo;.</source>
          <target state="translated">Программа должна напечатать &amp;laquo;Hello from TypeScript!&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="fad1dae24f8de6bb5ace45589ded1976d7ba9b1d" translate="yes" xml:space="preserve">
          <source>The purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.</source>
          <target state="translated">Цель данного руководства-научить вас писать качественный файл определений.Это руководство структурировано таким образом,что в нем показана документация по некоторым API,а также примеры использования этого API и объяснено,как написать соответствующее объявление.</target>
        </trans-unit>
        <trans-unit id="0eccb935e6264e79e73c70e81e21a7c090643b4a" translate="yes" xml:space="preserve">
          <source>The reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the &lt;code&gt;node.d.ts&lt;/code&gt; file that several of the TypeScript samples use is consumed.</source>
          <target state="translated">Тег ссылки здесь позволяет нам найти файл объявления, который содержит объявление для внешнего модуля. Таким образом &lt;code&gt;node.d.ts&lt;/code&gt; файл node.d.ts, который используется в нескольких примерах TypeScript.</target>
        </trans-unit>
        <trans-unit id="71056ddd9a7d7a3d2b766c4d6ec8f63ddc99ad7f" translate="yes" xml:space="preserve">
          <source>The rest of this section assumes &lt;code&gt;typescript@next&lt;/code&gt; is already installed.</source>
          <target state="translated">В оставшейся части этого раздела предполагается, что &lt;code&gt;typescript@next&lt;/code&gt; уже установлен.</target>
        </trans-unit>
        <trans-unit id="f21084484972497bb17b43e1dd1639f1309df4de" translate="yes" xml:space="preserve">
          <source>The result will be a file &lt;code&gt;greeter.js&lt;/code&gt; which contains the same JavaScript that you fed in. We&amp;rsquo;re up and running using TypeScript in our JavaScript app!</source>
          <target state="translated">В результате получится файл &lt;code&gt;greeter.js&lt;/code&gt; , содержащий тот же код JavaScript, который вы ввели . Мы начали использовать TypeScript в нашем приложении JavaScript!</target>
        </trans-unit>
        <trans-unit id="55cd4e9d5c07da56c2642a3c67f20fdea4efaf76" translate="yes" xml:space="preserve">
          <source>The resulting merged declaration of &lt;code&gt;Document&lt;/code&gt; will be the following:</source>
          <target state="translated">Результирующая объединенная декларация &lt;code&gt;Document&lt;/code&gt; будет следующей:</target>
        </trans-unit>
        <trans-unit id="5a7ebfe9ca74c5339d3d3f99e13edb4401f1c213" translate="yes" xml:space="preserve">
          <source>The resulting type of the property.</source>
          <target state="translated">Результирующий тип недвижимости.</target>
        </trans-unit>
        <trans-unit id="fb503a1aeb68c9cb323a5ced50b16d97adf33167" translate="yes" xml:space="preserve">
          <source>The results are then called as functions from bottom-to-top.</source>
          <target state="translated">Затем результаты вызываются как функции снизу вверх.</target>
        </trans-unit>
        <trans-unit id="b9eb08a8c7770e6b9f8872c6109a3df7ec5c1b48" translate="yes" xml:space="preserve">
          <source>The return value of the parameter decorator is ignored.</source>
          <target state="translated">Возвращаемое значение параметра декоратора игнорируется.</target>
        </trans-unit>
        <trans-unit id="ec62e92022db3b095789b1a8bc611f9661c25a8c" translate="yes" xml:space="preserve">
          <source>The right side of the &lt;code&gt;instanceof&lt;/code&gt; needs to be a constructor function, and TypeScript will narrow down to:</source>
          <target state="translated">Правая часть &lt;code&gt;instanceof&lt;/code&gt; должна быть функцией-конструктором, а TypeScript сузится до:</target>
        </trans-unit>
        <trans-unit id="9bdcb387eac602c5c7979ebf6b526180243170a8" translate="yes" xml:space="preserve">
          <source>The same &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote&lt;/a&gt; applies to these modules.</source>
          <target state="translated">Та же &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;сноска&lt;/a&gt; применима к этим модулям.</target>
        </trans-unit>
        <trans-unit id="f7fb9969f8be2dbbfcedab928e0115d7fa79657a" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt;, another TypeScript loader for Webpack. You can read more about the differences between the two &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">То же самое и с &lt;a href=&quot;https://github.com/TypeStrong/ts-loader&quot;&gt;ts-loader&lt;/a&gt; , еще одним загрузчиком TypeScript для Webpack. Вы можете прочитать больше о различиях между ними &lt;a href=&quot;https://github.com/s-panferov/awesome-typescript-loader#differences-between-ts-loader&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00fc4820883d5fd03b19870a02ddabbb40e34c99" translate="yes" xml:space="preserve">
          <source>The same is true for optional properties:</source>
          <target state="translated">То же самое относится и к дополнительным свойствам:</target>
        </trans-unit>
        <trans-unit id="43f24dd384fa12ae0f07c7c778176cd12dddfc84" translate="yes" xml:space="preserve">
          <source>The same rule for assignment is used when checking function call arguments:</source>
          <target state="translated">Такое же правило присваивания используется при проверке аргументов вызова функции:</target>
        </trans-unit>
        <trans-unit id="addbe812d1672c5e4f322e5d5a3556adcb36610e" translate="yes" xml:space="preserve">
          <source>The same sort of tracking is now also done for empty arrays.</source>
          <target state="translated">Такой же способ отслеживания теперь применяется и для пустых массивов.</target>
        </trans-unit>
        <trans-unit id="ccde6d73f9a8b313307d39b074524c1e2e182522" translate="yes" xml:space="preserve">
          <source>The same way that ordinary tuples are types that extend from &lt;code&gt;Array&lt;/code&gt; - a tuple with elements of type &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; tuples are types that extend from &lt;code&gt;ReadonlyArray&lt;/code&gt;. So a &lt;code&gt;readonly&lt;/code&gt; tuple with elements &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;, &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;, &amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; extends from &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Точно так же, как обычные кортежи являются типами, которые расширяются от &lt;code&gt;Array&lt;/code&gt; - кортеж с элементами типа &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; , &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; ,&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; расширяется от &lt;code&gt;Array&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; \| ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; - &lt;code&gt;readonly&lt;/code&gt; кортежей типов , которые простираются от &lt;code&gt;ReadonlyArray&lt;/code&gt; . Таким образом, кортеж только для &lt;code&gt;readonly&lt;/code&gt; с элементами &lt;code&gt;T&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; , &lt;code&gt;T&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; ,&amp;hellip; &lt;code&gt;T&lt;sub&gt;n&lt;/sub&gt;&lt;/code&gt; расширяется от &lt;code&gt;ReadonlyArray&amp;lt; T&lt;sub&gt;1&lt;/sub&gt; \| T&lt;sub&gt;2&lt;/sub&gt; | ... T&lt;sub&gt;n&lt;/sub&gt; &amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="739a9969f90dca0e3b9321fb87d6ba49413bb58c" translate="yes" xml:space="preserve">
          <source>The second assignment is an error, because &lt;code&gt;y&lt;/code&gt; has a required second parameter that &lt;code&gt;x&lt;/code&gt; does not have, so the assignment is disallowed.</source>
          <target state="translated">Второе присвоение является ошибкой, потому что &lt;code&gt;y&lt;/code&gt; имеет обязательный второй параметр, которого нет у &lt;code&gt;x&lt;/code&gt; , поэтому присвоение запрещено.</target>
        </trans-unit>
        <trans-unit id="3f4a4a115d577adebcffab99f90c2599ff896791" translate="yes" xml:space="preserve">
          <source>The second block creates the following name meanings:</source>
          <target state="translated">Второй блок создает следующие значения имени:</target>
        </trans-unit>
        <trans-unit id="e0467e5b0666d2b81ecc53a34087b88185a9207e" translate="yes" xml:space="preserve">
          <source>The second method uses the &lt;code&gt;never&lt;/code&gt; type that the compiler uses to check for exhaustiveness:</source>
          <target state="translated">Второй метод использует тип &lt;code&gt;never&lt;/code&gt; , который компилятор использует для проверки полноты:</target>
        </trans-unit>
        <trans-unit id="49820d40f361e464b077d6cf772f08f976135fd0" translate="yes" xml:space="preserve">
          <source>The second operator is &lt;code&gt;T[K]&lt;/code&gt;, the &lt;strong&gt;indexed access operator&lt;/strong&gt;. Here, the type syntax reflects the expression syntax. That means that &lt;code&gt;person['name']&lt;/code&gt; has the type &lt;code&gt;Person['name']&lt;/code&gt; &amp;mdash; which in our example is just &lt;code&gt;string&lt;/code&gt;. However, just like index type queries, you can use &lt;code&gt;T[K]&lt;/code&gt; in a generic context, which is where its real power comes to life. You just have to make sure that the type variable &lt;code&gt;K extends keyof T&lt;/code&gt;. Here&amp;rsquo;s another example with a function named &lt;code&gt;getProperty&lt;/code&gt;.</source>
          <target state="translated">Второй оператор - &lt;code&gt;T[K]&lt;/code&gt; , &lt;strong&gt;индексированный оператор доступа&lt;/strong&gt; . Здесь синтаксис типа отражает синтаксис выражения. Это означает, что &lt;code&gt;person['name']&lt;/code&gt; имеет тип &lt;code&gt;Person['name']&lt;/code&gt; который в нашем примере является просто &lt;code&gt;string&lt;/code&gt; . Однако, как и запросы индексного типа, вы можете использовать &lt;code&gt;T[K]&lt;/code&gt; в общем контексте, и именно здесь его реальная сила проявляется. Вы просто должны убедиться , что тип переменной &lt;code&gt;K extends keyof T&lt;/code&gt; . Вот еще один пример с функцией с именем &lt;code&gt;getProperty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d22435f751c04c05b24d63f2b79d13b3746e4a00" translate="yes" xml:space="preserve">
          <source>The second part is the return type. We make it clear which is the return type by using a fat arrow (&lt;code&gt;=&amp;gt;&lt;/code&gt;) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn&amp;rsquo;t return a value, you would use &lt;code&gt;void&lt;/code&gt; instead of leaving it off.</source>
          <target state="translated">Вторая часть - это возвращаемый тип. Мы проясняем, какой тип возвращаемого значения используется толстой стрелкой ( &lt;code&gt;=&amp;gt;&lt;/code&gt; ) между параметрами и типом возвращаемого значения. Как упоминалось ранее, это обязательная часть типа функции, поэтому, если функция не возвращает значение, вы должны использовать &lt;code&gt;void&lt;/code&gt; вместо того, чтобы оставлять его отключенным.</target>
        </trans-unit>
        <trans-unit id="e07f825349d9c56d700585b88ad266691534c76a" translate="yes" xml:space="preserve">
          <source>The second reason is when a consumer uses the &amp;ldquo;strict null checking&amp;rdquo; feature of TypeScript. Because unspecified parameters appear as &lt;code&gt;undefined&lt;/code&gt; in JavaScript, it&amp;rsquo;s usually fine to pass an explicit &lt;code&gt;undefined&lt;/code&gt; to a function with optional arguments. This code, for example, should be OK under strict nulls:</source>
          <target state="translated">Вторая причина - это когда потребитель использует функцию TypeScript &amp;laquo;строгая проверка нуля&amp;raquo;. Поскольку неуказанные параметры отображаются в JavaScript как &lt;code&gt;undefined&lt;/code&gt; , обычно нормально передать явное &lt;code&gt;undefined&lt;/code&gt; значение функции с необязательными аргументами. Этот код, например, должен работать со строгими нулевыми значениями:</target>
        </trans-unit>
        <trans-unit id="3fd4b2e06d8d3d430b175e5ddeea0b896410301c" translate="yes" xml:space="preserve">
          <source>The second way is also perhaps the most common. Here we use &lt;em&gt;type argument inference&lt;/em&gt; &amp;ndash; that is, we want the compiler to set the value of &lt;code&gt;T&lt;/code&gt; for us automatically based on the type of the argument we pass in:</source>
          <target state="translated">Второй способ тоже, пожалуй, самый распространенный. Здесь мы используем &lt;em&gt;вывод аргумента типа&lt;/em&gt; - то есть мы хотим, чтобы компилятор автоматически устанавливал значение &lt;code&gt;T&lt;/code&gt; для нас в зависимости от типа аргумента, который мы передаем:</target>
        </trans-unit>
        <trans-unit id="4736ec61bf8078d3ad2a342c635cb7fc5c10d088" translate="yes" xml:space="preserve">
          <source>The second way uses a generic array type, &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Второй способ использует общий тип &lt;code&gt;Array&amp;lt;elemType&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="99b58ef085b8f5cfafe10b2f70b1c603ae679699" translate="yes" xml:space="preserve">
          <source>The simplest form of destructuring is array destructuring assignment:</source>
          <target state="translated">Самой простой формой деструкции является назначение деструкции массива:</target>
        </trans-unit>
        <trans-unit id="81722fee1d2fb56b682b67ac28f4e353808fb7d3" translate="yes" xml:space="preserve">
          <source>The simplest, and perhaps most common, type of declaration merging is interface merging. At the most basic level, the merge mechanically joins the members of both declarations into a single interface with the same name.</source>
          <target state="translated">Самым простым и,пожалуй,наиболее распространенным типом объединения деклараций является слияние интерфейсов.На самом базовом уровне,слияние механически объединяет членов обеих деклараций в один интерфейс с одинаковым именем.</target>
        </trans-unit>
        <trans-unit id="13408208368716d434a2faec6f70e98867378392" translate="yes" xml:space="preserve">
          <source>The snippet above is an example of type inference, explained later in the handbook.</source>
          <target state="translated">Приведенный выше отрывок является примером типового вывода,который будет объяснен позже в руководстве.</target>
        </trans-unit>
        <trans-unit id="f58e24702b78cd5b8941ef478b1489c1cd7b5d65" translate="yes" xml:space="preserve">
          <source>The spread operator also works:</source>
          <target state="translated">Также работает оператор разбрасывания:</target>
        </trans-unit>
        <trans-unit id="306da80508d5bf827e829e72fb7591269adf0a66" translate="yes" xml:space="preserve">
          <source>The spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:</source>
          <target state="translated">Оператор спреда является противоположностью деструкции.Он позволяет распространять массив в другой массив,или объект в другой объект.Например:</target>
        </trans-unit>
        <trans-unit id="f885061b123a3fe063f3c9ed899b1d23df83d618" translate="yes" xml:space="preserve">
          <source>The strategy the compiler is following</source>
          <target state="translated">Стратегия,которой придерживается компилятор</target>
        </trans-unit>
        <trans-unit id="c3d17817e55b210acd9bce6627aec4a4dd9620cb" translate="yes" xml:space="preserve">
          <source>The stricter checking applies to all function types, &lt;em&gt;except&lt;/em&gt; those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;) continue to mostly relate covariantly.</source>
          <target state="translated">Более строгая проверка применяется ко всем типам функций, &lt;em&gt;кроме&lt;/em&gt; тех , которые возникают в объявлениях методов или конструкторов. Методы исключены специально, чтобы гарантировать, что общие классы и интерфейсы (такие как &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; ) в основном связаны ковариантно.</target>
        </trans-unit>
        <trans-unit id="9257c34b0251760de9cf13098d8b8dab286b41c2" translate="yes" xml:space="preserve">
          <source>The string literal union &lt;code&gt;Keys&lt;/code&gt;, which contains the names of properties to iterate over.</source>
          <target state="translated">Строковый литерал union &lt;code&gt;Keys&lt;/code&gt; , который содержит имена свойств для перебора.</target>
        </trans-unit>
        <trans-unit id="712aa4a776f92297417c2dad5e9739407277009b" translate="yes" xml:space="preserve">
          <source>The supported glob wildcards are:</source>
          <target state="translated">Поддерживаемые глобусные wildcards:</target>
        </trans-unit>
        <trans-unit id="727e992e3d1e12337dc7c95d559ff4b4fccf59be" translate="yes" xml:space="preserve">
          <source>The syntax resembles the syntax for index signatures with a &lt;code&gt;for .. in&lt;/code&gt; inside. There are three parts:</source>
          <target state="translated">Синтаксис похож на синтаксис индексных подписей с символом &lt;code&gt;for .. in&lt;/code&gt; внутри. Состоит из трех частей:</target>
        </trans-unit>
        <trans-unit id="42212d0e88124e6c9e85e3c6d2679e2ebfc79e8e" translate="yes" xml:space="preserve">
          <source>The syntax should look familiar if you&amp;rsquo;ve used C# or Java before. We declare a new class &lt;code&gt;Greeter&lt;/code&gt;. This class has three members: a property called &lt;code&gt;greeting&lt;/code&gt;, a constructor, and a method &lt;code&gt;greet&lt;/code&gt;.</source>
          <target state="translated">Синтаксис должен выглядеть знакомым, если вы раньше использовали C # или Java. Мы объявляем новый класс &lt;code&gt;Greeter&lt;/code&gt; . Этот класс состоит из трех членов: свойства, называемого &lt;code&gt;greeting&lt;/code&gt; , конструктора и метода &lt;code&gt;greet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04a97906fd0b03483a7f8d7138ad2f0a923a35cf" translate="yes" xml:space="preserve">
          <source>The template file &lt;a href=&quot;templates/global-d-ts&quot;&gt;&lt;code&gt;global.d.ts&lt;/code&gt;&lt;/a&gt; defines an example library &lt;code&gt;myLib&lt;/code&gt;. Be sure to read the &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;&amp;ldquo;Preventing Name Conflicts&amp;rdquo; footnote&lt;/a&gt;.</source>
          <target state="translated">Файл шаблона &lt;a href=&quot;templates/global-d-ts&quot;&gt; &lt;code&gt;global.d.ts&lt;/code&gt; &lt;/a&gt; определяет пример библиотеки &lt;code&gt;myLib&lt;/code&gt; . Обязательно прочтите &lt;a href=&quot;#preventing-name-conflicts&quot;&gt;сноску &amp;laquo;Предотвращение конфликтов имен&amp;raquo;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5291791ebba8241b8df5e64ba1807928b332ea67" translate="yes" xml:space="preserve">
          <source>The test files import the implementation files and do some testing:</source>
          <target state="translated">Тестовые файлы импортируют файлы реализации и делают некоторые проверки:</target>
        </trans-unit>
        <trans-unit id="1d502ba678972d16c080f4276cf5add29d80b7a4" translate="yes" xml:space="preserve">
          <source>The three interfaces will merge to create a single declaration as so:</source>
          <target state="translated">Три интерфейса будут объединены для создания единой декларации:</target>
        </trans-unit>
        <trans-unit id="ace0f93a6c178ee20b3542e125ca7fdce8f70590" translate="yes" xml:space="preserve">
          <source>The top-level module here &lt;code&gt;Shapes&lt;/code&gt; wraps up &lt;code&gt;Triangle&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt; for no reason. This is confusing and annoying for consumers of your module:</source>
          <target state="translated">Модуль верхнего уровня здесь &lt;code&gt;Shapes&lt;/code&gt; без всякой причины объединяет &lt;code&gt;Triangle&lt;/code&gt; и &lt;code&gt;Square&lt;/code&gt; . Это сбивает с толку и раздражает потребителей вашего модуля:</target>
        </trans-unit>
        <trans-unit id="7b5e597f445939620e293134a759f62224c6c2bd" translate="yes" xml:space="preserve">
          <source>The two biggest changes are the following:</source>
          <target state="translated">Двумя самыми большими изменениями являются следующие:</target>
        </trans-unit>
        <trans-unit id="d3d5cbb8071ba1e4008349316f8601cde19debcd" translate="yes" xml:space="preserve">
          <source>The two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.</source>
          <target state="translated">Два варианта оставили больше для того чтобы быть желанным;связывание помощников в каждом файле было болезненной точкой для клиентов пытающихся держать их размер пакета малым.И не включая помощников,означало,что клиенты должны были поддерживать свою собственную библиотеку помощников.</target>
        </trans-unit>
        <trans-unit id="a8a8ad0b07b6aeac0ba2a5e2ec35773596d69e43" translate="yes" xml:space="preserve">
          <source>The two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only &lt;code&gt;as&lt;/code&gt;-style assertions are allowed.</source>
          <target state="translated">Эти два образца эквивалентны. Использование одного над другим - это в основном выбор предпочтений; однако при использовании TypeScript с JSX разрешены только утверждения &lt;code&gt;as&lt;/code&gt; -style.</target>
        </trans-unit>
        <trans-unit id="9a2b71237e4b11c5e8ec290df36ff6e89dc1089c" translate="yes" xml:space="preserve">
          <source>The type above means when &lt;code&gt;T&lt;/code&gt; is assignable to &lt;code&gt;U&lt;/code&gt; the type is &lt;code&gt;X&lt;/code&gt;, otherwise the type is &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">Типа выше средств , когда &lt;code&gt;T&lt;/code&gt; отнесен к &lt;code&gt;U&lt;/code&gt; типа является &lt;code&gt;X&lt;/code&gt; , в противном случае типа &lt;code&gt;Y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4716786bdfd77dd152da96b6dedb84b8495378a" translate="yes" xml:space="preserve">
          <source>The type checker checks the call to &lt;code&gt;printLabel&lt;/code&gt;. The &lt;code&gt;printLabel&lt;/code&gt; function has a single parameter that requires that the object passed in has a property called &lt;code&gt;label&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Notice that our object actually has more properties than this, but the compiler only checks that &lt;em&gt;at least&lt;/em&gt; the ones required are present and match the types required. There are some cases where TypeScript isn&amp;rsquo;t as lenient, which we&amp;rsquo;ll cover in a bit.</source>
          <target state="translated">Средство проверки типов проверяет вызов &lt;code&gt;printLabel&lt;/code&gt; . Функция &lt;code&gt;printLabel&lt;/code&gt; имеет единственный параметр, который требует, чтобы переданный объект имел свойство, называемое &lt;code&gt;label&lt;/code&gt; &lt;code&gt;string&lt;/code&gt; типа . Обратите внимание, что у нашего объекта на самом деле больше свойств, чем это, но компилятор проверяет только наличие &lt;em&gt;хотя бы&lt;/em&gt; необходимых свойств и соответствие требуемым типам. Бывают случаи, когда TypeScript не такой снисходительный, о чем мы немного поговорим.</target>
        </trans-unit>
        <trans-unit id="498dccd8aaeaa75874785e3ff175fe7c0758db81" translate="yes" xml:space="preserve">
          <source>The type checker previously considered &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; were valid values of &lt;em&gt;every&lt;/em&gt; type and it wasn&amp;rsquo;t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).</source>
          <target state="translated">Средство проверки типов ранее считало, что &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; присваиваются чему-либо. Фактически, &lt;code&gt;null&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; были допустимыми значениями &lt;em&gt;каждого&lt;/em&gt; типа, и их нельзя было специально исключить (и, следовательно, невозможно было обнаружить их ошибочное использование).</target>
        </trans-unit>
        <trans-unit id="86aac0e48da9aea5ed18bd94611504853bd15903" translate="yes" xml:space="preserve">
          <source>The type inferred for a &lt;code&gt;const&lt;/code&gt; variable or &lt;code&gt;readonly&lt;/code&gt; property without a type annotation is the type of the literal initializer. The type inferred for a &lt;code&gt;let&lt;/code&gt; variable, &lt;code&gt;var&lt;/code&gt; variable, parameter, or non-&lt;code&gt;readonly&lt;/code&gt; property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; for numeric literal types, &lt;code&gt;boolean&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; and the containing enum for enum literal types.</source>
          <target state="translated">Тип, выведенный для &lt;code&gt;const&lt;/code&gt; переменной или свойства только для &lt;code&gt;readonly&lt;/code&gt; без аннотации типа, является типом литерального инициализатора. Тип, выведенный для переменной &lt;code&gt;let&lt;/code&gt; , переменной &lt;code&gt;var&lt;/code&gt; , параметра или свойства , не предназначенного только для &lt;code&gt;readonly&lt;/code&gt; с инициализатором и без аннотации типа, является расширенным литеральным типом инициализатора. Если расширенный тип для строкового литерала - это &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; для числовых литеральных типов, &lt;code&gt;boolean&lt;/code&gt; для &lt;code&gt;true&lt;/code&gt; или &lt;code&gt;false&lt;/code&gt; и содержащее перечисление для литеральных типов перечисления.</target>
        </trans-unit>
        <trans-unit id="22d8204ec0e93f58b5995cd3bb24de8809d04802" translate="yes" xml:space="preserve">
          <source>The type information provided works together with the tools to work with JavaScript at application scale. For more examples of what&amp;rsquo;s possible in TypeScript, see the Samples section of the website.</source>
          <target state="translated">Предоставленная информация о типе работает вместе с инструментами для работы с JavaScript в масштабе приложения. Дополнительные примеры возможностей TypeScript см. В разделе &amp;laquo;Примеры&amp;raquo; на веб-сайте.</target>
        </trans-unit>
        <trans-unit id="3d4d8d8ec6a0364ae5c047afca600acdad689a11" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;import.meta&lt;/code&gt; is the global &lt;code&gt;ImportMeta&lt;/code&gt; type which is defined in &lt;code&gt;lib.es5.d.ts&lt;/code&gt;. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.</source>
          <target state="translated">Тип &lt;code&gt;import.meta&lt;/code&gt; является глобальным &lt;code&gt;ImportMeta&lt;/code&gt; типа , который определен в &lt;code&gt;lib.es5.d.ts&lt;/code&gt; . Этот интерфейс чрезвычайно ограничен. Добавление хорошо известных свойств для узла или браузеров требует объединения интерфейсов и, возможно, глобального расширения в зависимости от контекста.</target>
        </trans-unit>
        <trans-unit id="d271ce4998727501be8284a249a40022d27f33d7" translate="yes" xml:space="preserve">
          <source>The type of a variable declared in a &lt;code&gt;for..in&lt;/code&gt; statement is implicitly &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">Тип переменной, объявленной в операторе &lt;code&gt;for..in&lt;/code&gt; , неявно является &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f07be8c188f5eaeef3ae763a9e934f23db56503" translate="yes" xml:space="preserve">
          <source>The type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:</source>
          <target state="translated">Тип генерических функций аналогичен типу не генерических функций,при этом параметры типа перечислены первыми,аналогично декларациям функций:</target>
        </trans-unit>
        <trans-unit id="89b88412f516aaabf8ce78ad994c61d8ed26eb99" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;length&lt;/code&gt; property of a tuple type with a rest element is &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">Типом свойства &lt;code&gt;length&lt;/code&gt; кортежа с остаточным элементом является &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19df0d5bb97d9dc0679c13270f984f724378fbec" translate="yes" xml:space="preserve">
          <source>The type of the &lt;code&gt;x&lt;/code&gt; variable is inferred to be &lt;code&gt;number&lt;/code&gt;. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.</source>
          <target state="translated">Предполагается, что тип переменной &lt;code&gt;x&lt;/code&gt; будет &lt;code&gt;number&lt;/code&gt; . Этот вид вывода имеет место при инициализации переменных и членов, установке значений параметров по умолчанию и определении типов возвращаемых функций.</target>
        </trans-unit>
        <trans-unit id="f6bd4bc2cdf6f5eae310eb7f350c21d93cc10ee9" translate="yes" xml:space="preserve">
          <source>The type parameter type of the &lt;code&gt;extends&lt;/code&gt; expression must be constrained to a mixin constructor type.</source>
          <target state="translated">Тип параметра типа выражения &lt;code&gt;extends&lt;/code&gt; должен быть ограничен типом конструктора микширования.</target>
        </trans-unit>
        <trans-unit id="52c2a6f88c2385c5622c47c84c950cacbd843901" translate="yes" xml:space="preserve">
          <source>The type system enforces that the source function&amp;rsquo;s return type be a subtype of the target type&amp;rsquo;s return type.</source>
          <target state="translated">Система типов требует, чтобы тип возвращаемого значения исходной функции был подтипом типа возвращаемого значения целевого типа.</target>
        </trans-unit>
        <trans-unit id="b936c977ae4cffd22334d0707270bc09672639e5" translate="yes" xml:space="preserve">
          <source>The type variable &lt;code&gt;K&lt;/code&gt;, which gets bound to each property in turn.</source>
          <target state="translated">Переменная типа &lt;code&gt;K&lt;/code&gt; , которая по очереди привязывается к каждому свойству.</target>
        </trans-unit>
        <trans-unit id="7709afd63729fd84f9c850e499018e8fd56d1bb3" translate="yes" xml:space="preserve">
          <source>The types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known &lt;em&gt;intrinsically&lt;/em&gt; whereas components will likely want to specify their own set of attributes.</source>
          <target state="translated">Типы атрибутов, передаваемых в элементе JSX, следует искать по-другому. Внутренние атрибуты элемента должны быть известны &lt;em&gt;внутренне,&lt;/em&gt; тогда как компоненты, вероятно, захотят указать свой собственный набор атрибутов.</target>
        </trans-unit>
        <trans-unit id="09675d7cd4f6ad417e59fbaf95c24d2d47c06712" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.</source>
          <target state="translated">Значение свойства &lt;code&gt;&amp;lt;TypeScriptToolsVersion&amp;gt;1.7&amp;lt;/TypeScriptToolsVersion&amp;gt;&lt;/code&gt; в файле проекта определяет версию компилятора, которая будет использоваться для сборки (1.7 в этом примере). Это позволяет проекту использовать одни и те же версии компилятора на разных машинах.</target>
        </trans-unit>
        <trans-unit id="7e5b2230b8d43ad8c0d99ac55f3f3b2a5f049234" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;extends&lt;/code&gt; must be a string containing a path to another configuration file to inherit from.</source>
          <target state="translated">Значение &lt;code&gt;extends&lt;/code&gt; должно быть строкой, содержащей путь к другому файлу конфигурации для наследования.</target>
        </trans-unit>
        <trans-unit id="23c080d1f546c832664165ecef0024de9c538ba4" translate="yes" xml:space="preserve">
          <source>The variables don&amp;rsquo;t necessarily need to both be block-scoped for TypeScript to tell us that there&amp;rsquo;s a problem.</source>
          <target state="translated">Переменные не обязательно должны иметь блочную область видимости, чтобы TypeScript сообщал нам о проблеме.</target>
        </trans-unit>
        <trans-unit id="0cd2fcb1497f2a79b74d282146de3e0947778826" translate="yes" xml:space="preserve">
          <source>The visibility rules for merged members is the same as described in the &amp;lsquo;Merging Namespaces&amp;rsquo; section, so we must export the &lt;code&gt;AlbumLabel&lt;/code&gt; class for the merged class to see it. The end result is a class managed inside of another class. You can also use namespaces to add more static members to an existing class.</source>
          <target state="translated">Правила видимости для объединенных членов такие же, как описано в разделе &amp;laquo;Объединение пространств имен&amp;raquo;, поэтому мы должны экспортировать класс &lt;code&gt;AlbumLabel&lt;/code&gt; , чтобы объединенный класс его увидел. Конечным результатом является класс, управляемый внутри другого класса. Вы также можете использовать пространства имен для добавления статических членов в существующий класс.</target>
        </trans-unit>
        <trans-unit id="ea042e37fe3dfdb85a33f2ea55e58e9f6f78eed8" translate="yes" xml:space="preserve">
          <source>The watching of directory on platforms that don&amp;rsquo;t support recursive directory watching natively in node, is supported through recursively creating directory watcher for the child directories using different options selected by &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;. Note that on platforms that support native recursive directory watching (e.g windows) the value of this environment variable is ignored.</source>
          <target state="translated">Наблюдение за каталогом на платформах, которые не поддерживают рекурсивное наблюдение за каталогами изначально в узле, поддерживается посредством рекурсивного создания наблюдателя за каталогами для дочерних каталогов с использованием различных параметров, выбранных &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; . Обратите внимание, что на платформах, которые поддерживают собственный рекурсивный просмотр каталогов (например, окна), значение этой переменной среды игнорируется.</target>
        </trans-unit>
        <trans-unit id="4068ca96cef50a182f0293c35312e884e5d6ce44" translate="yes" xml:space="preserve">
          <source>The way that TypeScript decides on whether a version of the compiler &amp;amp; language matches is by using Node&amp;rsquo;s &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;semver ranges&lt;/a&gt;.</source>
          <target state="translated">Способ, которым TypeScript определяет, соответствует ли версия компилятора и языка, - это использование &lt;a href=&quot;https://github.com/npm/node-semver#ranges&quot;&gt;диапазонов семвера&lt;/a&gt; узла .</target>
        </trans-unit>
        <trans-unit id="d504e46325644ee193380b78759d039584245b76" translate="yes" xml:space="preserve">
          <source>The way that this works is that when using &lt;code&gt;allowJs&lt;/code&gt;, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don&amp;rsquo;t necessarily look like their equivalents in TypeScript. When &lt;code&gt;declaration&lt;/code&gt; emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output &lt;code&gt;.d.ts&lt;/code&gt; files.</source>
          <target state="translated">Это работает следующим образом: при использовании &lt;code&gt;allowJs&lt;/code&gt; TypeScript выполняет некоторый анализ с максимальными усилиями для понимания общих шаблонов JavaScript; однако способ, которым некоторые шаблоны выражаются в JavaScript, не обязательно похож на их эквиваленты в TypeScript. Когда &lt;code&gt;.d.ts&lt;/code&gt; &lt;code&gt;declaration&lt;/code&gt; , TypeScript находит лучший способ преобразовать комментарии JSDoc и экспорт CommonJS в допустимые объявления типов и тому подобное в выходных файлах .d.ts .</target>
        </trans-unit>
        <trans-unit id="35913a132bcc3df8c56386f24253f0774dc172fa" translate="yes" xml:space="preserve">
          <source>Then consumed it:</source>
          <target state="translated">Потом съел его:</target>
        </trans-unit>
        <trans-unit id="47406e9f2861c5bd5131ac98ebd0257179f53e80" translate="yes" xml:space="preserve">
          <source>Then install &lt;code&gt;typescript&lt;/code&gt;, &lt;code&gt;gulp&lt;/code&gt; and &lt;code&gt;gulp-typescript&lt;/code&gt; in your project&amp;rsquo;s dev dependencies. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; is a gulp plugin for Typescript.</source>
          <target state="translated">Затем установите &lt;code&gt;typescript&lt;/code&gt; , &lt;code&gt;gulp&lt;/code&gt; и &lt;code&gt;gulp-typescript&lt;/code&gt; в зависимости от разработчика вашего проекта. &lt;a href=&quot;https://www.npmjs.com/package/gulp-typescript&quot;&gt;Gulp-typescript&lt;/a&gt; - это плагин gulp для Typescript.</target>
        </trans-unit>
        <trans-unit id="642ddc2143630564f6b4e561a7568f47369559e5" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;food&lt;/code&gt; property in &lt;code&gt;defaults&lt;/code&gt; overwrites &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt;, which is not what we want in this case.</source>
          <target state="translated">Затем свойство &lt;code&gt;food&lt;/code&gt; по &lt;code&gt;defaults&lt;/code&gt; перезаписывает &lt;code&gt;food: &quot;rich&quot;&lt;/code&gt; , чего мы не хотим в данном случае.</target>
        </trans-unit>
        <trans-unit id="de093b53d785ff2bef7478f5b3a5ab97f6181f86" translate="yes" xml:space="preserve">
          <source>Then, given a type &lt;code&gt;T''&lt;/code&gt; that is an instantiation of &lt;code&gt;T&lt;/code&gt; where all &lt;code&gt;infer&lt;/code&gt; type variables are replaced with the types inferred in the previous step, if &lt;code&gt;T''&lt;/code&gt; is &lt;em&gt;definitely assignable&lt;/em&gt; to &lt;code&gt;U&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;X&lt;/code&gt;. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for &lt;em&gt;all instantiations&lt;/em&gt; of those types.</source>
          <target state="translated">Тогда, учитывая тип &lt;code&gt;T''&lt;/code&gt; , который является конкретизацией &lt;code&gt;T&lt;/code&gt; , где все &lt;code&gt;infer&lt;/code&gt; переменных типа заменяются типами , выведенных в предыдущем шаге, если &lt;code&gt;T''&lt;/code&gt; является &lt;em&gt;определенно назначаемым&lt;/em&gt; для &lt;code&gt;U&lt;/code&gt; , условный тип разрешен к &lt;code&gt;X&lt;/code&gt; . Однозначно назначаемое отношение такое же, как и обычное присваиваемое отношение, за исключением того, что ограничения переменных типа не рассматриваются. Интуитивно понятно, что когда тип определенно может быть назначен другому типу, мы знаем, что он будет назначен для &lt;em&gt;всех экземпляров&lt;/em&gt; этих типов.</target>
        </trans-unit>
        <trans-unit id="177fd68b346fbae5c87bdcc2142e9f97d5a264b8" translate="yes" xml:space="preserve">
          <source>Then, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that &lt;code&gt;C&lt;/code&gt; was defined with &lt;code&gt;b&lt;/code&gt; optional:</source>
          <target state="translated">Затем вам нужно не забыть указать значение по умолчанию для необязательных свойств для деструктурированного свойства вместо основного инициализатора. Помните, что &lt;code&gt;C&lt;/code&gt; был определен с необязательным &lt;code&gt;b&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b08559581092c2fc068a4a49c020c235194dda9a" translate="yes" xml:space="preserve">
          <source>There are also some flags specific to &lt;code&gt;tsc -b&lt;/code&gt;:</source>
          <target state="translated">Также есть несколько специфичных для &lt;code&gt;tsc -b&lt;/code&gt; флагов :</target>
        </trans-unit>
        <trans-unit id="0d87487c8a7e09831fbc5025d0ad575e1d950bdf" translate="yes" xml:space="preserve">
          <source>There are basically three changes here, but they require you to refactor your code a bit.</source>
          <target state="translated">Здесь,по сути,есть три изменения,но они требуют немного рефакторить ваш код.</target>
        </trans-unit>
        <trans-unit id="e6857c6b00d742af1ee133bd685d46d5cba15dc1" translate="yes" xml:space="preserve">
          <source>There are certain cases where TypeScript can&amp;rsquo;t figure out what certain types should be. To be as lenient as possible, it will decide to use the type &lt;code&gt;any&lt;/code&gt; in its place. While this is great for migration, using &lt;code&gt;any&lt;/code&gt; means that you&amp;rsquo;re not getting any type safety, and you won&amp;rsquo;t get the same tooling support you&amp;rsquo;d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the &lt;code&gt;noImplicitAny&lt;/code&gt; option.</source>
          <target state="translated">В некоторых случаях TypeScript не может определить, какими должны быть определенные типы. Чтобы быть максимально снисходительным, он решит использовать вместо него &lt;code&gt;any&lt;/code&gt; шрифт . Хотя это отлично подходит для миграции, используя &lt;code&gt;any&lt;/code&gt; средства, вы не получите никакой безопасности типов и не получите той же инструментальной поддержки, которую получили бы где-либо еще. Вы можете указать TypeScript &lt;code&gt;noImplicitAny&lt;/code&gt; эти местоположения и выдать ошибку с помощью параметра noImplicitAny .</target>
        </trans-unit>
        <trans-unit id="cf3ad7a163a01d342f3e2b293eed57c09a62514b" translate="yes" xml:space="preserve">
          <source>There are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new &lt;em&gt;definite assignment assertion modifiers&lt;/em&gt; for your properties (discussed below).</source>
          <target state="translated">Существуют определенные сценарии, в которых свойства могут быть инициализированы косвенно (возможно, с помощью вспомогательного метода или библиотеки внедрения зависимостей), и в этом случае вы можете использовать новые &lt;em&gt;модификаторы утверждения определенного присваивания&lt;/em&gt; для своих свойств (обсуждаемые ниже).</target>
        </trans-unit>
        <trans-unit id="d8e46f31896dc086f90c6f67b6510c59fb5bf434" translate="yes" xml:space="preserve">
          <source>There are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.</source>
          <target state="translated">Есть несколько видов зависимостей,которые может иметь ваша библиотека.В этом разделе показано,как их импортировать в файл декларации.</target>
        </trans-unit>
        <trans-unit id="f50947aa96622ea69cd6de3461bbbc3baf551e2b" translate="yes" xml:space="preserve">
          <source>There are three templates available for modules, &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Для модулей доступны три шаблона: &lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af6a54de55d95dc1fa9a970327164b2697b39938" translate="yes" xml:space="preserve">
          <source>There are two main ways to get the TypeScript tools:</source>
          <target state="translated">Есть два основных способа получить инструменты TypeScript:</target>
        </trans-unit>
        <trans-unit id="f51afbc91104b11fd815c5a998b7fab8086c5610" translate="yes" xml:space="preserve">
          <source>There are two packages:</source>
          <target state="translated">Есть две упаковки:</target>
        </trans-unit>
        <trans-unit id="b8b3a9273fe6c950960b5b0a5f42744f3ece318c" translate="yes" xml:space="preserve">
          <source>There are two possible module resolution strategies: &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; and &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt;. You can use the &lt;code&gt;--moduleResolution&lt;/code&gt; flag to specify the module resolution strategy. If not specified, the default is &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; for &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; otherwise.</source>
          <target state="translated">Есть две возможные стратегии разрешения модулей: &lt;a href=&quot;#node&quot;&gt;узловая&lt;/a&gt; и &lt;a href=&quot;#classic&quot;&gt;классическая&lt;/a&gt; . Вы можете использовать флаг &lt;code&gt;--moduleResolution&lt;/code&gt; , чтобы указать стратегию разрешения модуля. Если не указано, то по умолчанию &lt;a href=&quot;#classic&quot;&gt;классический&lt;/a&gt; для &lt;code&gt;--module AMD | System | ES2015&lt;/code&gt; или &lt;a href=&quot;#node&quot;&gt;Node в&lt;/a&gt; противном случае.</target>
        </trans-unit>
        <trans-unit id="6d037836fd5889368e676cf82d021109751703c9" translate="yes" xml:space="preserve">
          <source>There are two types of supported index signatures: string and number. It is possible to support both types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a &lt;code&gt;number&lt;/code&gt;, JavaScript will actually convert that to a &lt;code&gt;string&lt;/code&gt; before indexing into an object. That means that indexing with &lt;code&gt;100&lt;/code&gt; (a &lt;code&gt;number&lt;/code&gt;) is the same thing as indexing with &lt;code&gt;&quot;100&quot;&lt;/code&gt; (a &lt;code&gt;string&lt;/code&gt;), so the two need to be consistent.</source>
          <target state="translated">Есть два типа поддерживаемых индексных подписей: строка и число. Можно поддерживать оба типа индексаторов, но тип, возвращаемый числовым индексатором, должен быть подтипом типа, возвращаемого индексатором строк. Это связано с тем, что при индексировании с помощью &lt;code&gt;number&lt;/code&gt; JavaScript фактически преобразует его в &lt;code&gt;string&lt;/code&gt; перед индексированием в объект. Это означает, что индексирование с помощью &lt;code&gt;100&lt;/code&gt; ( &lt;code&gt;number&lt;/code&gt; ) - то же самое, что индексирование с помощью &lt;code&gt;&quot;100&quot;&lt;/code&gt; ( &lt;code&gt;string&lt;/code&gt; ), поэтому они должны быть согласованными.</target>
        </trans-unit>
        <trans-unit id="908cd031750feb81ec4d9c9d32a60c943d9995ba" translate="yes" xml:space="preserve">
          <source>There are two ways to define a value-based element:</source>
          <target state="translated">Существует два способа определения элемента,основанного на значении:</target>
        </trans-unit>
        <trans-unit id="26e25b640ababcffdfc4b06e185fa3e5e4e7f32b" translate="yes" xml:space="preserve">
          <source>There are two ways to do this. The first is to turn on &lt;code&gt;--strictNullChecks&lt;/code&gt; and specify a return type:</source>
          <target state="translated">Есть два способа сделать это. Первый - включить &lt;code&gt;--strictNullChecks&lt;/code&gt; и указать тип возвращаемого значения:</target>
        </trans-unit>
        <trans-unit id="e7659fe4cc582ed4ad5cee6a5865f3aed8b3f631" translate="yes" xml:space="preserve">
          <source>There is a special subset of constant enum members that aren&amp;rsquo;t calculated: literal enum members. A literal enum member is a constant enum member with no initialized value, or with values that are initialized to</source>
          <target state="translated">Существует специальное подмножество постоянных членов перечисления, которые не вычисляются: литеральные члены перечисления. Литеральный член перечисления - это постоянный член перечисления без инициализированного значения или со значениями, которые инициализированы как</target>
        </trans-unit>
        <trans-unit id="b3c75a37225472b5122690bb8c7852d356bbe63d" translate="yes" xml:space="preserve">
          <source>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</source>
          <target state="translated">Существует четко определенный порядок применения декораторами различных деклараций внутри класса:</target>
        </trans-unit>
        <trans-unit id="9b776dda290c6f5398f6b0885c60c8e056b32045" translate="yes" xml:space="preserve">
          <source>There is no template for &lt;code&gt;tsconfig.json&lt;/code&gt; in most project types.</source>
          <target state="translated">В большинстве типов проектов нет шаблона для &lt;code&gt;tsconfig.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8504a07cb4ffd55d7fe6fdeea5cee63d290fd3d8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a specific set of functions that &lt;code&gt;throw&lt;/code&gt; an error if something unexpected happened. They&amp;rsquo;re called &amp;ldquo;assertion&amp;rdquo; functions. As an example, Node.js has a dedicated function for this called &lt;code&gt;assert&lt;/code&gt;.</source>
          <target state="translated">Есть специальный набор функций, которые &lt;code&gt;throw&lt;/code&gt; ошибку, если происходит что-то непредвиденное. Они называются функциями утверждения. Например, в Node.js для этого есть специальная функция, называемая &lt;code&gt;assert&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ea7b067283b1800f3cf1697d8801fcd2967972e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also &lt;em&gt;optional call&lt;/em&gt;, which allows us to conditionally call expressions if they&amp;rsquo;re not &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Также есть &lt;em&gt;необязательный вызов&lt;/em&gt; , который позволяет нам вызывать выражения по условию, если они не &lt;code&gt;null&lt;/code&gt; или &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45675102fd5d070224d9ebb4b617e2cd2622b44e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no built-in up-to-date checking, so you end up always running &lt;code&gt;tsc&lt;/code&gt; twice</source>
          <target state="translated">Нет встроенной проверки актуальности, поэтому вы всегда запускаете &lt;code&gt;tsc&lt;/code&gt; дважды</target>
        </trans-unit>
        <trans-unit id="d45edf5a42ca019d0d64af47b3ea8fd1b0b8bcb9" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;.tsbuildinfo&lt;/code&gt; files can be safely deleted and don&amp;rsquo;t have any impact on our code at runtime - they&amp;rsquo;re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">Эти файлы &lt;code&gt;.tsbuildinfo&lt;/code&gt; можно безопасно удалить, и они не влияют на наш код во время выполнения - они используются исключительно для ускорения компиляции. Мы также можем назвать их как угодно и разместить их где угодно, используя флаг &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79dc017ea8ee6bb3f7c9fc491544134c877f20d3" translate="yes" xml:space="preserve">
          <source>These &lt;em&gt;&lt;code&gt;typeof&lt;/code&gt; type guards&lt;/em&gt; are recognized in two different forms: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; and &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt;, where &lt;code&gt;&quot;typename&quot;&lt;/code&gt; must be &lt;code&gt;&quot;number&quot;&lt;/code&gt;, &lt;code&gt;&quot;string&quot;&lt;/code&gt;, &lt;code&gt;&quot;boolean&quot;&lt;/code&gt;, or &lt;code&gt;&quot;symbol&quot;&lt;/code&gt;. While TypeScript won&amp;rsquo;t stop you from comparing to other strings, the language won&amp;rsquo;t recognize those expressions as type guards.</source>
          <target state="translated">Эти &lt;em&gt;охранники типа &lt;/em&gt;&lt;em&gt; &lt;code&gt;typeof&lt;/code&gt; &lt;/em&gt; распознаются в двух разных формах: &lt;code&gt;typeof v === &quot;typename&quot;&lt;/code&gt; и &lt;code&gt;typeof v !== &quot;typename&quot;&lt;/code&gt; , где &lt;code&gt;&quot;typename&quot;&lt;/code&gt; должно быть &lt;code&gt;&quot;number&quot;&lt;/code&gt; , &lt;code&gt;&quot;string&quot;&lt;/code&gt; , &lt;code&gt;&quot;boolean&quot;&lt;/code&gt; или &lt;code&gt;&quot;symbol&quot;&lt;/code&gt; .&quot; . Хотя TypeScript не остановит вас от сравнения с другими строками, язык не распознает эти выражения как охранники типа.</target>
        </trans-unit>
        <trans-unit id="c89cac30c0863c54c7e154b255e1a2a8a10af609" translate="yes" xml:space="preserve">
          <source>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</source>
          <target state="translated">Они редко пишутся явно,но могут быть полезны при сужении проблем и могут ловить ошибки:</target>
        </trans-unit>
        <trans-unit id="dae12b77565aa4d0e3a64c99a87302ba66d61702" translate="yes" xml:space="preserve">
          <source>These assertion signatures are very similar to writing type predicate signatures:</source>
          <target state="translated">Эти сигнатуры утверждения очень похожи на сигнатуры предикатов типа письма:</target>
        </trans-unit>
        <trans-unit id="2868190107b9e856775b903db102ff1ea2bbe264" translate="yes" xml:space="preserve">
          <source>These could be imported as</source>
          <target state="translated">Они могут быть импортированы как</target>
        </trans-unit>
        <trans-unit id="580c6c93a64a3803a22f4ceb17224a9f774727aa" translate="yes" xml:space="preserve">
          <source>These examples are ordered in approximately increasing order of complexity.</source>
          <target state="translated">Эти примеры упорядочены примерно в порядке возрастания сложности.</target>
        </trans-unit>
        <trans-unit id="51753d058d70c80473068ff593cd4ffa3d3364fb" translate="yes" xml:space="preserve">
          <source>These options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient &amp;ldquo;oh, don&amp;rsquo;t forget to turn on the &lt;code&gt;noImplicitAny&lt;/code&gt; option!&amp;rdquo;.</source>
          <target state="translated">Эти параметры также сохраняются при обмене ссылками на образцы игровых площадок, позволяя пользователям более надежно обмениваться примерами, не &lt;code&gt;noImplicitAny&lt;/code&gt; получателю: &amp;laquo;О, не забудьте включить параметр noImplicitAny !&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="405bb1f92dbe539fc19f70e7ed40ea0eb0528ce7" translate="yes" xml:space="preserve">
          <source>These scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:</source>
          <target state="translated">Эти правила поиска могут привести к нескольким типам ошибок.Одна из проблем,которую они усугубляют,заключается в том,что многократное объявление одной и той же переменной не является ошибкой:</target>
        </trans-unit>
        <trans-unit id="5d8c7bb7c664a99b3f99538dd86cbd5a15a993cd" translate="yes" xml:space="preserve">
          <source>They also serve as a method to order the output when using &lt;code&gt;--out&lt;/code&gt; or &lt;code&gt;--outFile&lt;/code&gt;. Files are emitted to the output file location in the same order as the input after preprocessing pass.</source>
          <target state="translated">Они также служат методом упорядочивания вывода при использовании &lt;code&gt;--out&lt;/code&gt; или &lt;code&gt;--outFile&lt;/code&gt; . Файлы отправляются в расположение выходного файла в том же порядке, что и входные, после этапа предварительной обработки.</target>
        </trans-unit>
        <trans-unit id="a1ff8d1f085eb2bf495023df7ad3553e1c32cab7" translate="yes" xml:space="preserve">
          <source>They also support replacing the &lt;code&gt;exports&lt;/code&gt; object with a custom single object. Default exports are meant to act as a replacement for this behavior; however, the two are incompatible. TypeScript supports &lt;code&gt;export =&lt;/code&gt; to model the traditional CommonJS and AMD workflow.</source>
          <target state="translated">Они также поддерживают замену объекта &lt;code&gt;exports&lt;/code&gt; отдельным настраиваемым объектом. Экспорт по умолчанию призван заменить это поведение; однако они несовместимы. TypeScript поддерживает &lt;code&gt;export =&lt;/code&gt; для моделирования традиционного рабочего процесса CommonJS и AMD.</target>
        </trans-unit>
        <trans-unit id="7e47c0cafef6daabbdf34e9389714c2f70664891" translate="yes" xml:space="preserve">
          <source>They are like &lt;code&gt;let&lt;/code&gt; declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as &lt;code&gt;let&lt;/code&gt;, but you can&amp;rsquo;t re-assign to them.</source>
          <target state="translated">Они похожи на объявления &lt;code&gt;let&lt;/code&gt; , но, как следует из их названия, их значение не может быть изменено после связывания. Другими словами, у них те же правила области действия, что и у &lt;code&gt;let&lt;/code&gt; , но вы не можете переназначить их.</target>
        </trans-unit>
        <trans-unit id="269cb00928fdbd9243a3c0e9855fdf73711ca39b" translate="yes" xml:space="preserve">
          <source>They will rarely have:</source>
          <target state="translated">У них это будет редко:</target>
        </trans-unit>
        <trans-unit id="940ca9be4b3687b9409fbf0f5e6bf12d6da31f65" translate="yes" xml:space="preserve">
          <source>Things to look out for</source>
          <target state="translated">Вещи,на которые стоит обратить внимание</target>
        </trans-unit>
        <trans-unit id="aba97e7fae57c949d932eff408211c64dbd34e1b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;package.json&lt;/code&gt; tells TypeScript to check whether the current version of TypeScript is running. If it&amp;rsquo;s 3.1 or later, it figures out the path you&amp;rsquo;ve imported relative to the package, and reads from the package&amp;rsquo;s &lt;code&gt;ts3.1&lt;/code&gt; folder. That&amp;rsquo;s what that &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; means - if you&amp;rsquo;re familiar with path mapping today, it works exactly like that.</source>
          <target state="translated">Этот &lt;code&gt;package.json&lt;/code&gt; сообщает TypeScript, что нужно проверить, запущена ли текущая версия TypeScript. Если это 3.1 или новее, он определяет путь, который вы импортировали относительно пакета, и считывает его из папки &lt;code&gt;ts3.1&lt;/code&gt; пакета . Вот что означает &lt;code&gt;{ &quot;*&quot;: [&quot;ts3.1/*&quot;] }&lt;/code&gt; - если вы сегодня знакомы с отображением путей, оно работает именно так.</target>
        </trans-unit>
        <trans-unit id="9579349a7f6081ccc0cfa7ee1c3ba7cecdaeb554" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;tsconfig.json&lt;/code&gt; file will &lt;em&gt;only&lt;/em&gt; include &lt;code&gt;./node_modules/@types/node&lt;/code&gt;, &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; and &lt;code&gt;./node_modules/@types/express&lt;/code&gt;. Other packages under &lt;code&gt;node_modules/@types/*&lt;/code&gt; will not be included.</source>
          <target state="translated">Этот файл &lt;code&gt;tsconfig.json&lt;/code&gt; будет включать &lt;em&gt;только &lt;/em&gt; &lt;code&gt;./node_modules/@types/node&lt;/code&gt; , &lt;code&gt;./node_modules/@types/lodash&lt;/code&gt; и &lt;code&gt;./node_modules/@types/express&lt;/code&gt; . Другие пакеты в &lt;code&gt;node_modules/@types/*&lt;/code&gt; не будут включены.</target>
        </trans-unit>
        <trans-unit id="3d382992de7bc0c7358c5e70b64fbab9df6f3d2b" translate="yes" xml:space="preserve">
          <source>This adds the &lt;code&gt;copy-html&lt;/code&gt; task and adds it as a dependency of &lt;code&gt;default&lt;/code&gt;. That means any time &lt;code&gt;default&lt;/code&gt; is run, &lt;code&gt;copy-html&lt;/code&gt; has to run first. We&amp;rsquo;ve also changed &lt;code&gt;default&lt;/code&gt; to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.</source>
          <target state="translated">Это добавляет задачу &lt;code&gt;copy-html&lt;/code&gt; и добавляет ее как зависимость по &lt;code&gt;default&lt;/code&gt; . Это означает, что при каждом запуске по &lt;code&gt;default&lt;/code&gt; сначала должен запускаться &lt;code&gt;copy-html&lt;/code&gt; . Мы также изменили &lt;code&gt;default&lt;/code&gt; по умолчанию для вызова Browserify с помощью плагина tsify вместо gulp-typescript. Удобно, что они оба позволяют нам передавать один и тот же объект параметров компилятору TypeScript.</target>
        </trans-unit>
        <trans-unit id="11d95bac2d09fc97059fde1a2be78410f1aaaa65" translate="yes" xml:space="preserve">
          <source>This also applies to numeric and string literals.</source>
          <target state="translated">Это также относится к числовым и строковым литералам.</target>
        </trans-unit>
        <trans-unit id="adfedec845a057971771ae75a777e3b399a6fbc9" translate="yes" xml:space="preserve">
          <source>This also works in JSDoc comments to refer to types from other modules in &lt;code&gt;.js&lt;/code&gt;:</source>
          <target state="translated">Это также работает в комментариях JSDoc для ссылки на типы из других модулей в &lt;code&gt;.js&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a19ba44e9cf17a28dc6b2832d656e62612a977fa" translate="yes" xml:space="preserve">
          <source>This also works with classes:</source>
          <target state="translated">Это также работает с классами:</target>
        </trans-unit>
        <trans-unit id="7a7e8768f821cc2763fea56792bd65a0c49d075d" translate="yes" xml:space="preserve">
          <source>This asserts the variable &lt;code&gt;bar&lt;/code&gt; to have the type &lt;code&gt;foo&lt;/code&gt;. Since TypeScript also uses angle brackets for type assertions, combining it with JSX&amp;rsquo;s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in &lt;code&gt;.tsx&lt;/code&gt; files.</source>
          <target state="translated">Это утверждает, что переменная &lt;code&gt;bar&lt;/code&gt; имеет тип &lt;code&gt;foo&lt;/code&gt; . Поскольку TypeScript также использует угловые скобки для утверждений типа, объединение их с синтаксисом JSX вызовет определенные трудности при синтаксическом анализе. В результате TypeScript запрещает утверждения типа угловых скобок в файлах &lt;code&gt;.tsx&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="123d0f06d6b292d7403ffa347023235e01b1d1ba" translate="yes" xml:space="preserve">
          <source>This can be used to pipe output between commands as well.</source>
          <target state="translated">Это также может быть использовано для вывода труб между командами.</target>
        </trans-unit>
        <trans-unit id="f4889f2abe4cb3d690ec344d9cb1060645946ee3" translate="yes" xml:space="preserve">
          <source>This can cause quite a bit of fallout for existing code that use inheritance. First of all, &lt;code&gt;set&lt;/code&gt; accessors from base classes won&amp;rsquo;t get triggered - they&amp;rsquo;ll be completely overwritten.</source>
          <target state="translated">Это может вызвать серьезные неудобства для существующего кода, использующего наследование. Во-первых, не будут срабатывать аксессоры &lt;code&gt;set&lt;/code&gt; из базовых классов - они будут полностью перезаписаны.</target>
        </trans-unit>
        <trans-unit id="2cf2abd7a18f1f7062668c3033dddcc6ad2c2d8e" translate="yes" xml:space="preserve">
          <source>This can even be used to enable &lt;code&gt;enum&lt;/code&gt;-like patterns in plain JavaScript code if you choose not to use TypeScript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt; construct.</source>
          <target state="translated">Это можно даже использовать для включения шаблонов, подобных &lt;code&gt;enum&lt;/code&gt; в простом коде JavaScript, если вы решите не использовать конструкцию &lt;code&gt;enum&lt;/code&gt; TypeScript .</target>
        </trans-unit>
        <trans-unit id="13a6f89fe3172b6cbc2af9517a59da3931faf315" translate="yes" xml:space="preserve">
          <source>This can go beyond basic functions with &lt;code&gt;@param&lt;/code&gt; tags too, where the following example:</source>
          <target state="translated">Это может выходить за рамки базовых функций с тегами &lt;code&gt;@param&lt;/code&gt; , где следующий пример:</target>
        </trans-unit>
        <trans-unit id="40d488fa879599b4c63bd3bca5b46fe16933b383" translate="yes" xml:space="preserve">
          <source>This change entails a break in the behavior of extending built-in classes like &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, etc.. Please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;extending built-ins breaking change documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Это изменение влечет за собой нарушение поведения при расширении встроенных классов, таких как &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; и т. Д. Для получения более подробной информации см. &lt;a href=&quot;https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-changes.html#extending-built-ins-like-error-array-and-map-may-no-longer-work&quot;&gt;Документацию&lt;/a&gt; по расширенным встроенным изменениям .</target>
        </trans-unit>
        <trans-unit id="0a82b6976a332dfa14dda6dd898339b3d9c8f2c3" translate="yes" xml:space="preserve">
          <source>This check is a breaking change, but for that reason the checks are very conservative. This error is only issued in &lt;code&gt;if&lt;/code&gt; conditions, and it is not issued on optional properties, if &lt;code&gt;strictNullChecks&lt;/code&gt; is off, or if the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">Эта проверка является критическим изменением, но по этой причине проверки очень консервативны. Эта ошибка выдается только в условиях &lt;code&gt;if&lt;/code&gt; и не выдается для необязательных свойств, если &lt;code&gt;strictNullChecks&lt;/code&gt; отключен, или если функция позже вызывается в теле &lt;code&gt;if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="776023497afd78ba896c5a8759ad07ba14168072" translate="yes" xml:space="preserve">
          <source>This comparison process proceeds recursively, exploring the type of each member and sub-member.</source>
          <target state="translated">Этот процесс сравнения проходит рекурсивно,исследуя тип каждого члена и суб-членов.</target>
        </trans-unit>
        <trans-unit id="a70378c4e2e85fc0285bab20719f721947598d23" translate="yes" xml:space="preserve">
          <source>This config file will include &lt;em&gt;all&lt;/em&gt; packages under &lt;code&gt;./typings&lt;/code&gt;, and no packages from &lt;code&gt;./node_modules/@types&lt;/code&gt;.</source>
          <target state="translated">Этот файл конфигурации будет включать &lt;em&gt;все&lt;/em&gt; пакеты из &lt;code&gt;./typings&lt;/code&gt; и не будет включать пакеты из &lt;code&gt;./node_modules/@types&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d8fdc1796e3b4fc005d6e6e0a36a51b7eee8ba1" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;package.json&lt;/code&gt; file with default values.</source>
          <target state="translated">Это создает файл &lt;code&gt;package.json&lt;/code&gt; со значениями по умолчанию.</target>
        </trans-unit>
        <trans-unit id="2651ac880cf2ead1dcccdb902c01397e29e5f2d0" translate="yes" xml:space="preserve">
          <source>This creates new variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;o.a&lt;/code&gt; and &lt;code&gt;o.b&lt;/code&gt;. Notice that you can skip &lt;code&gt;c&lt;/code&gt; if you don&amp;rsquo;t need it.</source>
          <target state="translated">Это создает новые переменные &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; из &lt;code&gt;o.a&lt;/code&gt; и &lt;code&gt;o.b&lt;/code&gt; . Обратите внимание, что вы можете пропустить &lt;code&gt;c&lt;/code&gt; , если он вам не нужен.</target>
        </trans-unit>
        <trans-unit id="cbec995fccd02fc21b46f9fd4af298cd4d2053ad" translate="yes" xml:space="preserve">
          <source>This creates two new variables named &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. This is equivalent to using indexing, but is much more convenient:</source>
          <target state="translated">Это создает две новые переменные с именами &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;second&lt;/code&gt; . Это эквивалентно использованию индексации, но намного удобнее:</target>
        </trans-unit>
        <trans-unit id="c3290579796b51867665bf805e46b6cb71dde74e" translate="yes" xml:space="preserve">
          <source>This directive allows a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">Эта директива позволяет файлу явно включать существующий встроенный файл &lt;em&gt;lib&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1a906b1f2cf088a2c6bf34b58e9c21658e73cc20" translate="yes" xml:space="preserve">
          <source>This directive instructs the compiler to &lt;em&gt;not&lt;/em&gt; include the default library (i.e. &lt;code&gt;lib.d.ts&lt;/code&gt;) in the compilation. The impact here is similar to passing &lt;code&gt;--noLib&lt;/code&gt; on the command line.</source>
          <target state="translated">Эта директива указывает компилятору &lt;em&gt;не&lt;/em&gt; включать библиотеку по умолчанию (например, &lt;code&gt;lib.d.ts&lt;/code&gt; ) в компиляцию. Воздействие здесь аналогично передаче &lt;code&gt;--noLib&lt;/code&gt; в командной строке.</target>
        </trans-unit>
        <trans-unit id="e85416c60d1e180f7e4e1a690b36612a078e4bd6" translate="yes" xml:space="preserve">
          <source>This directive marks a file as a &lt;em&gt;default library&lt;/em&gt;. You will see this comment at the top of &lt;code&gt;lib.d.ts&lt;/code&gt; and its different variants.</source>
          <target state="translated">Эта директива отмечает файл как &lt;em&gt;библиотеку по умолчанию&lt;/em&gt; . Вы увидите этот комментарий вверху &lt;code&gt;lib.d.ts&lt;/code&gt; и его различных вариантов.</target>
        </trans-unit>
        <trans-unit id="abd1b0ae2b28ffc07ff533b5aa3e34f0a7dbd996" translate="yes" xml:space="preserve">
          <source>This distinction is subtle and important &amp;ndash; here, &lt;code&gt;A.B&lt;/code&gt; is not necessarily a type or a value.</source>
          <target state="translated">Это тонкое и важное различие - здесь &lt;code&gt;A.B&lt;/code&gt; не обязательно является типом или значением.</target>
        </trans-unit>
        <trans-unit id="1ff3a8b47ad881c651ae743e22e2477b1a56f987" translate="yes" xml:space="preserve">
          <source>This example covers a few other features we didn&amp;rsquo;t previously mention. Again, we see the &lt;code&gt;extends&lt;/code&gt; keywords used to create two new subclasses of &lt;code&gt;Animal&lt;/code&gt;: &lt;code&gt;Horse&lt;/code&gt; and &lt;code&gt;Snake&lt;/code&gt;.</source>
          <target state="translated">Этот пример охватывает несколько других функций, о которых мы ранее не упоминали. Снова мы видим ключевые слова &lt;code&gt;extends&lt;/code&gt; , используемые для создания двух новых подклассов &lt;code&gt;Animal&lt;/code&gt; : &lt;code&gt;Horse&lt;/code&gt; и &lt;code&gt;Snake&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="151213ee16168c64e5b83bc91d8ae73927961489" translate="yes" xml:space="preserve">
          <source>This example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, &lt;code&gt;Dog&lt;/code&gt; is a &lt;em&gt;derived&lt;/em&gt; class that derives from the &lt;code&gt;Animal&lt;/code&gt;&lt;em&gt;base&lt;/em&gt; class using the &lt;code&gt;extends&lt;/code&gt; keyword. Derived classes are often called &lt;em&gt;subclasses&lt;/em&gt;, and base classes are often called &lt;em&gt;superclasses&lt;/em&gt;.</source>
          <target state="translated">В этом примере показана самая основная функция наследования: классы наследуют свойства и методы от базовых классов. Здесь &lt;code&gt;Dog&lt;/code&gt; - это &lt;em&gt;производный&lt;/em&gt; класс, производный от &lt;em&gt;базового&lt;/em&gt; класса &lt;code&gt;Animal&lt;/code&gt; с использованием ключевого слова &lt;code&gt;extends&lt;/code&gt; . Производные классы часто называют &lt;em&gt;подклассами&lt;/em&gt; , а базовые классы часто называют &lt;em&gt;суперклассами&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="80d233484614ac1a8184eec3cb1a1f5b233a8926" translate="yes" xml:space="preserve">
          <source>This feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.</source>
          <target state="translated">Эта функция может быть чрезвычайно полезна для больших организаций или проектов с большим количеством распределенных зависимостей.</target>
        </trans-unit>
        <trans-unit id="145fabdb6e03da0d5218bdc18d27ee6b68f3aaae" translate="yes" xml:space="preserve">
          <source>This feature is currently supported in Visual Studio 2015 with TypeScript 1.8.4 and above, and &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;atom-typescript&lt;/a&gt; plugin.</source>
          <target state="translated">Эта функция в настоящее время поддерживается в Visual Studio 2015 с TypeScript 1.8.4 и выше и подключаемым &lt;a href=&quot;https://github.com/TypeStrong/atom-typescript#compile-on-save&quot;&gt;модулем atom-typescript&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e14bf01780560294d3e709ab1eca2529b0526ee5" translate="yes" xml:space="preserve">
          <source>This feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.</source>
          <target state="translated">Эта особенность означает,что типы,которые в противном случае использовались бы просто для намека на неизменяемость компилятора,часто могут быть опущены.</target>
        </trans-unit>
        <trans-unit id="e0a1a44534d41eb6308a076407d6c354572ba0dd" translate="yes" xml:space="preserve">
          <source>This feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you&amp;rsquo;ll be free to take advantage of it no matter what environment you&amp;rsquo;re using.</source>
          <target state="translated">Эта функция поддерживалась до TypeScript 2.1, но только при ориентации на ES6 / ES2015. TypeScript 2.1 предоставляет возможности среды выполнения ES3 и ES5, а это означает, что вы можете свободно использовать его независимо от того, какую среду вы используете.</target>
        </trans-unit>
        <trans-unit id="4256b8036fc24344e27e1a2d98579274cc10c2e9" translate="yes" xml:space="preserve">
          <source>This gives bothPlus the value &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt;. Spreading creates a shallow copy of &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They are not changed by the spread.</source>
          <target state="translated">Это дает bothPlus значение &lt;code&gt;[0, 1, 2, 3, 4, 5]&lt;/code&gt; . Распространение создает неглубокую копию &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;second&lt;/code&gt; . Их не меняет спред.</target>
        </trans-unit>
        <trans-unit id="fe579196df9fee069d4bd852ac7c86cc2a13b998" translate="yes" xml:space="preserve">
          <source>This gives the user a way of describing inner classes.</source>
          <target state="translated">Это дает пользователю возможность описания внутренних классов.</target>
        </trans-unit>
        <trans-unit id="386298615e90cceffaa57d2fad7dceaa3f784476" translate="yes" xml:space="preserve">
          <source>This guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.</source>
          <target state="translated">Это руководство также гарантирует,что библиотека может быть перенесена в UMD без взлома пользователей файла декларации.</target>
        </trans-unit>
        <trans-unit id="c41bd8fce97e1f72ad86c3801d0c1855c4f2bfd0" translate="yes" xml:space="preserve">
          <source>This guide is designed to teach you how to write a high-quality TypeScript Declaration File.</source>
          <target state="translated">Это руководство предназначено для того,чтобы научить вас,как написать высококачественный файл декларации TypeScript.</target>
        </trans-unit>
        <trans-unit id="8afad13e48d5c317fc76b6fb0c7d091ef32c2108" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to wire up TypeScript with &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; and &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt;.</source>
          <target state="translated">Это руководство научит вас &lt;a href=&quot;https://webpack.js.org/&quot;&gt;подключать&lt;/a&gt; TypeScript к &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; и webpack .</target>
        </trans-unit>
        <trans-unit id="bb134067e9aa9299c18b8ce51100d390f03f98ca" translate="yes" xml:space="preserve">
          <source>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types &amp;mdash; &lt;strong&gt;mapped types&lt;/strong&gt;. In a mapped type, the new type transforms each property in the old type in the same way. For example, you can make all properties of a type &lt;code&gt;readonly&lt;/code&gt; or optional. Here are a couple of examples:</source>
          <target state="translated">В JavaScript это происходит достаточно часто, поэтому TypeScript предоставляет способ создания новых типов на основе старых типов - &lt;strong&gt;сопоставленных типов&lt;/strong&gt; . В сопоставленном типе новый тип аналогичным образом преобразует каждое свойство старого типа. Например, вы можете сделать все свойства типа &lt;code&gt;readonly&lt;/code&gt; или необязательными. Вот пара примеров:</target>
        </trans-unit>
        <trans-unit id="a56075c1c437a8f7f7b75ea4c76282bd39cf7b1d" translate="yes" xml:space="preserve">
          <source>This has a very specific meaning: the &lt;code&gt;done&lt;/code&gt; callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the &lt;code&gt;elapsedTime&lt;/code&gt; parameter, but there&amp;rsquo;s no need to make the parameter optional to accomplish this &amp;ndash; it&amp;rsquo;s always legal to provide a callback that accepts fewer arguments.</source>
          <target state="translated">Это имеет очень конкретное значение: обратный вызов &lt;code&gt;done&lt;/code&gt; может быть вызван с 1 аргументом или может быть вызван с 2 аргументами. Автор, вероятно, намеревался сказать, что обратный вызов может не заботиться о параметре &lt;code&gt;elapsedTime&lt;/code&gt; , но для этого нет необходимости делать параметр необязательным - всегда законно предоставлять обратный вызов, который принимает меньше аргументов.</target>
        </trans-unit>
        <trans-unit id="d47bf0bc67be092f1cae46d5237f049154597b89" translate="yes" xml:space="preserve">
          <source>This has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.</source>
          <target state="translated">Это был один из распространенных источников дублирующих ошибок определения.Многочисленные файлы деклараций,определяющие одни и те же члены на интерфейсах.</target>
        </trans-unit>
        <trans-unit id="008c0c2cfe2dcafe3f531baa951507b0d1d186a6" translate="yes" xml:space="preserve">
          <source>This has the same problems we mentioned above - we could easily have misspelled &lt;code&gt;getDistance&lt;/code&gt; and not gotten an error. For this reason, TypeScript has the &lt;code&gt;noImplicitThis&lt;/code&gt; option. When that option is set, TypeScript will issue an error when &lt;code&gt;this&lt;/code&gt; is used without an explicit (or inferred) type. The fix is to use a &lt;code&gt;this&lt;/code&gt;-parameter to give an explicit type in the interface or in the function itself:</source>
          <target state="translated">Это имеет те же проблемы, о которых мы упоминали выше - мы могли легко ошибиться в написании &lt;code&gt;getDistance&lt;/code&gt; и не получить ошибку. По этой причине TypeScript имеет параметр &lt;code&gt;noImplicitThis&lt;/code&gt; . Когда эта опция установлена, машинопись выдаст ошибку , когда &lt;code&gt;this&lt;/code&gt; используется без явного типа (или выведенного). Исправление состоит в том, чтобы использовать параметр &lt;code&gt;this&lt;/code&gt; , чтобы указать явный тип в интерфейсе или в самой функции:</target>
        </trans-unit>
        <trans-unit id="6ef37d4a82df716fb39c511922cd4fd9b3ab58c4" translate="yes" xml:space="preserve">
          <source>This is a breaking change; previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties. Code that assumed values typed with &lt;code&gt;keyof T&lt;/code&gt; were always &lt;code&gt;string&lt;/code&gt;s, will now be flagged as error.</source>
          <target state="translated">Это критическое изменение; ранее оператор &lt;code&gt;keyof&lt;/code&gt; и сопоставленные типы поддерживали только &lt;code&gt;string&lt;/code&gt; именованные свойства. Код, в котором значения, набранные с помощью &lt;code&gt;keyof T&lt;/code&gt; , всегда были &lt;code&gt;string&lt;/code&gt; s, теперь будет помечен как ошибка.</target>
        </trans-unit>
        <trans-unit id="37550d8cfccd82b7f09cb9ee94a9e55bd690b1de" translate="yes" xml:space="preserve">
          <source>This is a pretty literal use of the &lt;code&gt;GenericNumber&lt;/code&gt; class, but you may have noticed that nothing is restricting it to only use the &lt;code&gt;number&lt;/code&gt; type. We could have instead used &lt;code&gt;string&lt;/code&gt; or even more complex objects.</source>
          <target state="translated">Это довольно буквальное использование класса &lt;code&gt;GenericNumber&lt;/code&gt; , но вы могли заметить, что ничто не ограничивает его использованием только &lt;code&gt;number&lt;/code&gt; типа. Вместо этого мы могли бы использовать &lt;code&gt;string&lt;/code&gt; или даже более сложные объекты.</target>
        </trans-unit>
        <trans-unit id="0cbc708221291cf1aa363c4299a6de0178bc9f00" translate="yes" xml:space="preserve">
          <source>This is a reasonable restriction because any use of &lt;code&gt;Foo&lt;/code&gt; would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which would need to be replaced with &lt;code&gt;Foo&lt;/code&gt; which&amp;hellip; well, hopefully you get the idea! In the end, there isn&amp;rsquo;t a type that makes sense in place of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Это разумное ограничение, потому что любое использование &lt;code&gt;Foo&lt;/code&gt; нужно будет заменить на &lt;code&gt;Foo&lt;/code&gt; , которое нужно будет заменить на &lt;code&gt;Foo&lt;/code&gt; , которое нужно будет заменить на &lt;code&gt;Foo&lt;/code&gt; , что ... ну, надеюсь, вы поняли! В конце концов, нет типа, который имел бы смысл вместо &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8060ed060d509f7038e676326653a9e51460e83" translate="yes" xml:space="preserve">
          <source>This is achieved by introducing two new types, &lt;code&gt;CallableFunction&lt;/code&gt; and &lt;code&gt;NewableFunction&lt;/code&gt;, in &lt;code&gt;lib.d.ts&lt;/code&gt;. These types contain specialized generic method declarations for &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In &lt;code&gt;--strictBindCallApply&lt;/code&gt; mode these declarations are used in place of the (very permissive) declarations provided by type &lt;code&gt;Function&lt;/code&gt;.</source>
          <target state="translated">Это достигается за счет введения двух новых типов, &lt;code&gt;CallableFunction&lt;/code&gt; и &lt;code&gt;NewableFunction&lt;/code&gt; , в &lt;code&gt;lib.d.ts&lt;/code&gt; . Эти типы содержат объявления специализированных универсальных методов для &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; для обычных функций и функций-конструкторов соответственно. В объявлениях используются общие параметры отдыха (см. # 24897) для захвата и отражения списков параметров строго типизированным способом. В режиме &lt;code&gt;--strictBindCallApply&lt;/code&gt; эти объявления используются вместо (очень разрешительных) объявлений, предоставляемых типом &lt;code&gt;Function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dbad74ad3287bbe68b69203c6f2782129725610" translate="yes" xml:space="preserve">
          <source>This is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.</source>
          <target state="translated">Это происходит потому,что когда класс реализует интерфейс,проверяется только сторона экземпляра класса.Так как конструктор сидит на статической стороне,то он не включается в данную проверку.</target>
        </trans-unit>
        <trans-unit id="4b6c3dca4167679c5010d6f3fba2e9108213f5e9" translate="yes" xml:space="preserve">
          <source>This is called &amp;ldquo;contextual typing&amp;rdquo;, a form of type inference. This helps cut down on the amount of effort to keep your program typed.</source>
          <target state="translated">Это называется &amp;laquo;контекстной типизацией&amp;raquo;, формой вывода типа. Это помогает сократить количество усилий по поддержанию вашей программы типизированной.</target>
        </trans-unit>
        <trans-unit id="3aa66e1a6cbac680bebe3f7aa3dc555a813d0306" translate="yes" xml:space="preserve">
          <source>This is equivalent to declaring &lt;code&gt;sentence&lt;/code&gt; like so:</source>
          <target state="translated">Это эквивалентно объявлению такого &lt;code&gt;sentence&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b92657e6155d73fb913bca9c2a7e95110494bb4c" translate="yes" xml:space="preserve">
          <source>This is fairly &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;consistent with how other languages treat type aliases&lt;/a&gt;, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.</source>
          <target state="translated">Это довольно &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Recursive_data_type&amp;amp;oldid=913091335#in_type_synonyms&quot;&gt;согласуется с тем, как другие языки обрабатывают псевдонимы типов&lt;/a&gt; , но порождает несколько неожиданных сценариев того, как пользователи используют эту функцию. Например, в TypeScript 3.6 и ранее следующая ошибка вызывает ошибку.</target>
        </trans-unit>
        <trans-unit id="723f96f4f031c1015e42839d7f70baaf5dc4dd7e" translate="yes" xml:space="preserve">
          <source>This is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as &lt;code&gt;namespace&lt;/code&gt;s, types will conflict if they are declared with a type alias declaration (&lt;code&gt;type s = string&lt;/code&gt;), and namespaces never conflict.</source>
          <target state="translated">Это законно до тех пор, пока не возникает конфликта. Общее практическое правило состоит в том, что значения всегда конфликтуют с другими значениями с тем же именем, если они не объявлены как &lt;code&gt;namespace&lt;/code&gt; s, типы будут конфликтовать, если они объявлены с помощью объявления псевдонима &lt;code&gt;type s = string&lt;/code&gt; ( type s = string ), а пространства имен никогда не конфликтуют.</target>
        </trans-unit>
        <trans-unit id="b261fafdaf58d005a713f2cde7159a578a335b74" translate="yes" xml:space="preserve">
          <source>This is no longer the case - TypeScript now infers &lt;code&gt;this&lt;/code&gt; to have a special type called &lt;code&gt;this&lt;/code&gt; whenever inside an instance method of a class. The &lt;code&gt;this&lt;/code&gt; type is written as so, and basically means &amp;ldquo;the type of the left side of the dot in a method call&amp;rdquo;.</source>
          <target state="translated">Это уже не так - TypeScript теперь предполагает, что &lt;code&gt;this&lt;/code&gt; должен иметь специальный тип, называемый &lt;code&gt;this&lt;/code&gt; всякий раз, когда внутри метода экземпляра класса. &lt;code&gt;this&lt;/code&gt; тип записывается так, и в основном означает &amp;laquo;тип слева от точки в вызове метода&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="58590b20aaf8fc85de88a20890a72ce9479b5bd1" translate="yes" xml:space="preserve">
          <source>This is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.</source>
          <target state="translated">Теперь это стандартное решение для проектов MSBuild;это позволяет инкрементальной сборке MSBuild работать,как и ожидалось,так как выходные данные генерируются только на чистых сборках.</target>
        </trans-unit>
        <trans-unit id="94d5f4a5616552cb256911b32b728b92d26e4819" translate="yes" xml:space="preserve">
          <source>This is only enabled if &lt;code&gt;--noImplicitAny&lt;/code&gt; is set.</source>
          <target state="translated">Это &lt;code&gt;--noImplicitAny&lt;/code&gt; только если установлено --noImplicitAny .</target>
        </trans-unit>
        <trans-unit id="d335ad9d283ed57e40045d0665963af63d3174d9" translate="yes" xml:space="preserve">
          <source>This is optimal for consumers. They can name your type whatever they want (&lt;code&gt;t&lt;/code&gt; in this case) and don&amp;rsquo;t have to do any excessive dotting to find your objects.</source>
          <target state="translated">Это оптимально для потребителей. Они могут называть ваш тип как угодно ( в данном случае &lt;code&gt;t&lt;/code&gt; ), и им не нужно чрезмерно расставлять точки, чтобы найти ваши объекты.</target>
        </trans-unit>
        <trans-unit id="98bb0c78662d4345a34d8056d87df00bb4d5a674" translate="yes" xml:space="preserve">
          <source>This is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.</source>
          <target state="translated">Строго говоря,в TypeScript 3.3 это все еще более доступно,и добавление явной типовой аннотации будет работать.</target>
        </trans-unit>
        <trans-unit id="a079a3a6734c4cd08da0e17c421a695ab213a09a" translate="yes" xml:space="preserve">
          <source>This is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.</source>
          <target state="translated">Это странно,потому что технически нет ничего плохого в том,что пользователи всегда могли бы написать то,что было фактически одним и тем же кодом,введя интерфейс.</target>
        </trans-unit>
        <trans-unit id="14f1b6e0e05e87d37ff1f7dd8b578b6eb45b8f85" translate="yes" xml:space="preserve">
          <source>This is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing &lt;code&gt;undefined&lt;/code&gt; in that position is equivalent for most functions.</source>
          <target state="translated">Это необоснованно с точки зрения системы типов, но с точки зрения времени выполнения идея необязательного параметра обычно не применяется, поскольку передача &lt;code&gt;undefined&lt;/code&gt; в этой позиции эквивалентна для большинства функций.</target>
        </trans-unit>
        <trans-unit id="f1a4eb58dc966cceb7143e20830932600b5ea02f" translate="yes" xml:space="preserve">
          <source>This is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don&amp;rsquo;t have to be related besides inheriting from the base class. For example:</source>
          <target state="translated">Это полезно, когда у вас есть большая иерархия наследования, но вы хотите указать, что ваш код работает только с подклассами, имеющими определенные свойства. Подклассы не должны быть связаны, кроме наследования от базового класса. Например:</target>
        </trans-unit>
        <trans-unit id="fbc601dd0ab93d792728208f62b2497f50e502de" translate="yes" xml:space="preserve">
          <source>This kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.iterator&lt;/code&gt; method that returns an &lt;code&gt;Iterator&lt;/code&gt; object.</source>
          <target state="translated">Этот вид итератора полезен для перебора синхронно доступных значений, таких как элементы массива или ключи карты. Объект, поддерживающий итерацию, называется &amp;laquo;итератором&amp;raquo;, если у него есть метод &lt;code&gt;Symbol.iterator&lt;/code&gt; , который возвращает объект &lt;code&gt;Iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee56cf9ba9542ce8a0312b6a94a0d6397c614c45" translate="yes" xml:space="preserve">
          <source>This may seem confusing, but it&amp;rsquo;s actually very convenient as long as we don&amp;rsquo;t excessively overload things. Let&amp;rsquo;s look at some useful aspects of this combining behavior.</source>
          <target state="translated">Это может показаться запутанным, но на самом деле это очень удобно, если мы не перегружаем вещи чрезмерно. Давайте посмотрим на некоторые полезные аспекты этого комбинированного поведения.</target>
        </trans-unit>
        <trans-unit id="242737969d68a63e3722770b6fdc0a0887aa17a9" translate="yes" xml:space="preserve">
          <source>This means that code like the following that was trying to represent JSON&amp;hellip;</source>
          <target state="translated">Это означает, что такой код, как следующий, пытался представить JSON&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9e01eba045901bb9f42a3c7a52e17b1f10e058c3" translate="yes" xml:space="preserve">
          <source>This means that union types and &lt;code&gt;instanceof&lt;/code&gt; properly distinguish between structurally identical classes.</source>
          <target state="translated">Это означает, что типы union и &lt;code&gt;instanceof&lt;/code&gt; правильно различают структурно идентичные классы.</target>
        </trans-unit>
        <trans-unit id="944f762b99fb22d02c5865084d87d43b8946d4d0" translate="yes" xml:space="preserve">
          <source>This means that you can conditionally and lazily import other modules and libraries. For example, here&amp;rsquo;s an &lt;code&gt;async&lt;/code&gt; function that only imports a utility library when it&amp;rsquo;s needed:</source>
          <target state="translated">Это означает, что вы можете условно и лениво импортировать другие модули и библиотеки. Например, вот &lt;code&gt;async&lt;/code&gt; функция, которая импортирует служебную библиотеку только тогда, когда это необходимо:</target>
        </trans-unit>
        <trans-unit id="aa9a3a7f47b92be453ff0b6c4375f9ba7afa10b1" translate="yes" xml:space="preserve">
          <source>This mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.</source>
          <target state="translated">Этот режим добавляет гибкость для смешивания и соответствия способу сторонних библиотек,где глобулы,которые объявляются библиотеками,всегда могут быть потреблены,даже изнутри модулей.</target>
        </trans-unit>
        <trans-unit id="7f33b0a22b86a2f41c336d65267df2bb8cf5e332" translate="yes" xml:space="preserve">
          <source>This model of namespace merging is a helpful starting place, but we also need to understand what happens with non-exported members. Non-exported members are only visible in the original (un-merged) namespace. This means that after merging, merged members that came from other declarations cannot see non-exported members.</source>
          <target state="translated">Эта модель слияния пространств имен является полезным отправным пунктом,но нам также необходимо понять,что происходит с неэкспортируемыми участниками.Неэкспортируемые члены видны только в оригинальном (неуправляемом)пространстве имён.Это означает,что после слияния объединенные члены,которые пришли из других деклараций,не могут видеть неэкспортированных членов.</target>
        </trans-unit>
        <trans-unit id="5dae3ac251886a93244e214f8a5ad7364681d1d0" translate="yes" xml:space="preserve">
          <source>This new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on &lt;code&gt;number[] | string[]&lt;/code&gt; like &lt;code&gt;map&lt;/code&gt; (which is generic) still won&amp;rsquo;t be callable.</source>
          <target state="translated">Это новое поведение срабатывает только тогда, когда не более одного типа в объединении имеет несколько перегрузок и не более одного типа в объединении имеет общую сигнатуру. Это означает методы по &lt;code&gt;number[] | string[]&lt;/code&gt; как &lt;code&gt;map&lt;/code&gt; (который является универсальным) по-прежнему не может быть вызван.</target>
        </trans-unit>
        <trans-unit id="5b0887b7c0dc11302a46adcaa14cce74855a6095" translate="yes" xml:space="preserve">
          <source>This new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.</source>
          <target state="translated">Эта новая релаксация также позволяет рекурсивно ссылаться на псевдонимы типа в кортежах.Следующий код,который раньше был ошибочным,теперь является действительным кодом TypeScript.</target>
        </trans-unit>
        <trans-unit id="73d275a1e3784849d22fea2ec009273ed158e2df" translate="yes" xml:space="preserve">
          <source>This odd-looking pattern is actually pretty common. The &lt;code&gt;i&lt;/code&gt; in the parameter list actually shadows the &lt;code&gt;i&lt;/code&gt; declared in the &lt;code&gt;for&lt;/code&gt; loop, but since we named them the same, we didn&amp;rsquo;t have to modify the loop body too much.</source>
          <target state="translated">Этот странный узор на самом деле довольно распространен. &lt;code&gt;i&lt;/code&gt; в списке параметров фактически тенями &lt;code&gt;i&lt;/code&gt; объявил в &lt;code&gt;for&lt;/code&gt; цикла, но так как мы назвали их так же, мы не должны изменить тело цикла слишком много.</target>
        </trans-unit>
        <trans-unit id="5c7ee90113f636f43404e4d744fd715593d575c9" translate="yes" xml:space="preserve">
          <source>This often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from &lt;code&gt;BasicCalculator&lt;/code&gt;. Imagine a user wanted to start writing a &lt;code&gt;ScientificCalculator&lt;/code&gt;:</source>
          <target state="translated">Это часто открывает очень элегантные способы написания кода; однако возникла проблема с классами, которые хотели &lt;code&gt;BasicCalculator&lt;/code&gt; от BasicCalculator . Представьте, что пользователь хочет написать &lt;code&gt;ScientificCalculator&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="93d9ec6cf3f9136de052694a0e5be31bcf80b6f6" translate="yes" xml:space="preserve">
          <source>This only apply to types with an &lt;em&gt;explicit&lt;/em&gt; string index signature. It is still an error to access unknown properties on a type using &lt;code&gt;.&lt;/code&gt; notation.</source>
          <target state="translated">Это применимо только к типам с &lt;em&gt;явной&lt;/em&gt; подписью индекса строки. По-прежнему возникает ошибка доступа к неизвестным свойствам типа с использованием &lt;code&gt;.&lt;/code&gt; обозначение.</target>
        </trans-unit>
        <trans-unit id="ac04689bd985aaff5480421363910106fc5c181c" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;UseFsEvents&lt;/code&gt; except on failing to create watch using &lt;code&gt;fs.watch&lt;/code&gt;, the fallback watching happens through dynamic polling queues (as explained in &lt;code&gt;DynamicPriorityPolling&lt;/code&gt;)</source>
          <target state="translated">Этот параметр аналогичен &lt;code&gt;UseFsEvents&lt;/code&gt; , за исключением того, что при &lt;code&gt;fs.watch&lt;/code&gt; создания часов с помощью fs.watch отслеживание отката происходит через динамические очереди опроса (как описано в &lt;code&gt;DynamicPriorityPolling&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0aae93fe007c809a7e2e36db92dc9e5b379de835" translate="yes" xml:space="preserve">
          <source>This option watches parent directory of the file with &lt;code&gt;fs.watch&lt;/code&gt; (using file system events) thus being low on CPU but can compromise accuracy.</source>
          <target state="translated">Эта опция наблюдает за родительским каталогом файла с помощью &lt;code&gt;fs.watch&lt;/code&gt; (используя события файловой системы), что снижает нагрузку на ЦП, но может снизить точность.</target>
        </trans-unit>
        <trans-unit id="87694e596c33f73edc99c67b8848fbcbde1e4c9c" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces (previously &amp;ldquo;internal modules&amp;rdquo;) in TypeScript. As we alluded in our note about terminology, &amp;ldquo;internal modules&amp;rdquo; are now referred to as &amp;ldquo;namespaces&amp;rdquo;. Additionally, anywhere the &lt;code&gt;module&lt;/code&gt; keyword was used when declaring an internal module, the &lt;code&gt;namespace&lt;/code&gt; keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.</source>
          <target state="translated">В этом посте описаны различные способы организации кода с использованием пространств имен (ранее &amp;laquo;внутренних модулей&amp;raquo;) в TypeScript. Как мы упоминали в нашем примечании о терминологии, &amp;laquo;внутренние модули&amp;raquo; теперь называются &amp;laquo;пространствами имен&amp;raquo;. Кроме того, в любом месте , где &lt;code&gt;module&lt;/code&gt; ключевого слова используется при объявлении внутреннего модуля, то &lt;code&gt;namespace&lt;/code&gt; ключевых слова могут и должны быть использованы вместо. Это позволяет избежать запутывания новых пользователей, перегружая их терминами с похожими названиями.</target>
        </trans-unit>
        <trans-unit id="67e03678783967eef2733d80436705f614849f7f" translate="yes" xml:space="preserve">
          <source>This post outlines the various ways to organize your code using namespaces and modules in TypeScript. We&amp;rsquo;ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.</source>
          <target state="translated">В этом посте описаны различные способы организации кода с использованием пространств имен и модулей в TypeScript. Мы также рассмотрим некоторые дополнительные темы о том, как использовать пространства имен и модули, и рассмотрим некоторые распространенные ошибки при их использовании в TypeScript.</target>
        </trans-unit>
        <trans-unit id="fd64220fbecc8854d60d2a4f4f20ca94bda2d4e7" translate="yes" xml:space="preserve">
          <source>This presents a simple entry point; e.g. in the TypeScript repo we simply run &lt;code&gt;tsc -b src&lt;/code&gt; to build all endpoints because we list all the subprojects in &lt;code&gt;src/tsconfig.json&lt;/code&gt;</source>
          <target state="translated">Это простая точка входа; например, в &lt;code&gt;tsc -b src&lt;/code&gt; TypeScript мы просто запускаем tsc -b src для создания всех конечных точек, потому что мы перечисляем все подпроекты в &lt;code&gt;src/tsconfig.json&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c2c0f0e97743735b953a624ea594af85aaba20" translate="yes" xml:space="preserve">
          <source>This presents a very good opportunity for destructuring in the consuming code:</source>
          <target state="translated">Это дает очень хорошую возможность для разрушения в потребляющем коде:</target>
        </trans-unit>
        <trans-unit id="90339bda9cc4062b63e151a5bde442af3f17fdf3" translate="yes" xml:space="preserve">
          <source>This quick start guide will teach you how to build TypeScript with &lt;a href=&quot;http://gulpjs.com&quot;&gt;gulp&lt;/a&gt; and then add &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt;, &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;uglify&lt;/a&gt;, or &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; to the gulp pipeline. This guide also shows how to add &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; functionality using &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt;.</source>
          <target state="translated">Это краткое руководство научит вас , как построить машинопись с &lt;a href=&quot;http://gulpjs.com&quot;&gt;глотком&lt;/a&gt; , а затем добавить &lt;a href=&quot;http://browserify.org&quot;&gt;Browserify&lt;/a&gt; , &lt;a href=&quot;http://lisperator.net/uglifyjs/&quot;&gt;уродовать&lt;/a&gt; , или &lt;a href=&quot;https://github.com/substack/watchify&quot;&gt;Watchify&lt;/a&gt; к трубопроводу глотка. В этом руководстве также показано, как добавить функциональность &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; с помощью &lt;a href=&quot;https://github.com/babel/babelify&quot;&gt;Babelify&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4771bc2bab27a199d772c4ea0beb5b94f1557d90" translate="yes" xml:space="preserve">
          <source>This resolution strategy attempts to mimic the &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; module resolution mechanism at runtime. The full Node.js resolution algorithm is outlined in &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;Node.js module documentation&lt;/a&gt;.</source>
          <target state="translated">Эта стратегия разрешения пытается имитировать механизм разрешения модуля &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; во время выполнения. Полный алгоритм разрешения Node.js описан в &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_all_together&quot;&gt;документации модуля Node.js&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4282404c916b4f4b5fe9e3d34bc8423764a9741" translate="yes" xml:space="preserve">
          <source>This results in the generated JS</source>
          <target state="translated">Это приводит к тому,что генерируется JS</target>
        </trans-unit>
        <trans-unit id="ef4b88dc9b6e4d599f0dfab38e9b347bbf2884ea" translate="yes" xml:space="preserve">
          <source>This section assumes some basic knowledge about modules. Please see the &lt;a href=&quot;modules&quot;&gt;Modules&lt;/a&gt; documentation for more information.</source>
          <target state="translated">Этот раздел предполагает некоторые базовые знания о модулях. Дополнительную информацию см. В документации по &lt;a href=&quot;modules&quot;&gt;модулям&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9fb839c0cccd09c3b2a3d1ab1913df898747ff9" translate="yes" xml:space="preserve">
          <source>This should not be confused with the idea that the values they refer to are &lt;em&gt;immutable&lt;/em&gt;.</source>
          <target state="translated">Это не следует путать с идеей, что значения, к которым они относятся, &lt;em&gt;неизменны&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a1f229269d84a6a8939b736e452446c28bdac1e5" translate="yes" xml:space="preserve">
          <source>This simple example shows how the names used during importing and exporting get translated into the module loading code.</source>
          <target state="translated">Этот простой пример показывает,как имена,используемые при импорте и экспорте,транслируются в код загрузки модуля.</target>
        </trans-unit>
        <trans-unit id="c02e5a7acc21e96b7b427fe531770986b2a8029c" translate="yes" xml:space="preserve">
          <source>This tells the compiler for any module import that matches the pattern &lt;code&gt;&quot;*&quot;&lt;/code&gt; (i.e. all values), to look in two locations:</source>
          <target state="translated">Это сообщает компилятору для любого импорта модуля, который соответствует шаблону &lt;code&gt;&quot;*&quot;&lt;/code&gt; (т.е. всем значениям), искать в двух местах:</target>
        </trans-unit>
        <trans-unit id="e28988a9e9ef50dbc6082fe7ec51c8e202185991" translate="yes" xml:space="preserve">
          <source>This treats the classes as interfaces, and only mixes the types behind Disposable and Activatable into the SmartObject type rather than the implementation. This means that we&amp;rsquo;ll have to provide the implementation in class. Except, that&amp;rsquo;s exactly what we want to avoid by using mixins.</source>
          <target state="translated">При этом классы рассматриваются как интерфейсы и смешиваются только типы Disposable и Activatable с типом SmartObject, а не с реализацией. Это означает, что нам придется предоставить реализацию в классе. Только вот этого мы и хотим избежать, используя миксины.</target>
        </trans-unit>
        <trans-unit id="9a9277b80c882b7208b460979a9bd488c375c6cf" translate="yes" xml:space="preserve">
          <source>This used to be TypeScript&amp;rsquo;s default resolution strategy. Nowadays, this strategy is mainly present for backward compatibility.</source>
          <target state="translated">Раньше это была стратегия разрешения TypeScript по умолчанию. В настоящее время эта стратегия используется в основном для обеспечения обратной совместимости.</target>
        </trans-unit>
        <trans-unit id="93fddce73184becc8bb1dcac36b8151b2a00b289" translate="yes" xml:space="preserve">
          <source>This utility does not return a transformed type. Instead, it serves as a marker for a contextual &lt;code&gt;this&lt;/code&gt; type. Note that the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag must be enabled to use this utility.</source>
          <target state="translated">Эта утилита не возвращает преобразованный тип. Вместо этого он служит маркером для контекстного типа &lt;code&gt;this&lt;/code&gt; . Обратите внимание, что для использования этой утилиты необходимо включить флаг &lt;code&gt;--noImplicitThis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af2d32c38013b382c9d64510bcce20de81efb3be" translate="yes" xml:space="preserve">
          <source>This utility is useful for representing assignment expressions that will fail at runtime (i.e. when attempting to reassign properties of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;frozen object&lt;/a&gt;).</source>
          <target state="translated">Эта утилита полезна для представления выражений присваивания, которые не работают во время выполнения (т. Е. При попытке переназначить свойства &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze&quot;&gt;замороженного объекта&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eaff2ada45477df0b05b97a2def6303701764e4e" translate="yes" xml:space="preserve">
          <source>This version of the loop will actually perform the summation correctly because the inner loop&amp;rsquo;s &lt;code&gt;i&lt;/code&gt; shadows &lt;code&gt;i&lt;/code&gt; from the outer loop.</source>
          <target state="translated">Эта версия цикла фактически выполнит суммирование правильно, потому что &lt;code&gt;i&lt;/code&gt; внутреннего цикла затеняет &lt;code&gt;i&lt;/code&gt; от внешнего цикла.</target>
        </trans-unit>
        <trans-unit id="9381442c6d6f687b278f6b0753897426078289bf" translate="yes" xml:space="preserve">
          <source>This works because arrow functions use the outer &lt;code&gt;this&lt;/code&gt;, so you can always pass them to something that expects &lt;code&gt;this: void&lt;/code&gt;. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler&amp;rsquo;s prototype. They are shared between all objects of type Handler.</source>
          <target state="translated">Это работает, потому что стрелочные функции используют внешнее &lt;code&gt;this&lt;/code&gt; , поэтому вы всегда можете передать их тому, что ожидает &lt;code&gt;this: void&lt;/code&gt; . Обратной стороной является то, что для каждого объекта типа Handler создается одна стрелочная функция. С другой стороны, методы создаются только один раз и прикрепляются к прототипу Handler. Они общие для всех объектов типа Handler.</target>
        </trans-unit>
        <trans-unit id="a855814a311b76c2385f1f8fa0122f8b7cb5fd05" translate="yes" xml:space="preserve">
          <source>This works fine in TypeScript too, but the compiler doesn&amp;rsquo;t know about &lt;code&gt;Observable.prototype.map&lt;/code&gt;. You can use module augmentation to tell the compiler about it:</source>
          <target state="translated">Это отлично работает и в TypeScript, но компилятор не знает о &lt;code&gt;Observable.prototype.map&lt;/code&gt; . Вы можете использовать расширение модуля, чтобы сообщить об этом компилятору:</target>
        </trans-unit>
        <trans-unit id="90afc95581c28b0ae5570b6d400541b7e8730c10" translate="yes" xml:space="preserve">
          <source>This works well enough, but we might imagine that &lt;code&gt;SomeType&lt;/code&gt; and &lt;code&gt;SomeVar&lt;/code&gt; were very closely related such that you&amp;rsquo;d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Это работает достаточно хорошо, но мы можем представить, что &lt;code&gt;SomeType&lt;/code&gt; и &lt;code&gt;SomeVar&lt;/code&gt; очень тесно связаны, так что вы хотите, чтобы у них было одно и то же имя. Мы можем использовать комбинирование, чтобы представить эти два разных объекта (значение и тип) под одним и тем же именем &lt;code&gt;Bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8fe51f943aa966ad44227ae1d5f6f6ffe2daa142" translate="yes" xml:space="preserve">
          <source>ThisParameterType</source>
          <target state="translated">ThisParameterType</target>
        </trans-unit>
        <trans-unit id="476185d9e02b1c2446403ce730e896811f7c5c6c" translate="yes" xml:space="preserve">
          <source>ThisType&amp;lt;T&amp;gt;</source>
          <target state="translated">ThisType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="141ee6a2eac7f3e80ad87c7204dbdc726776e142" translate="yes" xml:space="preserve">
          <source>Though not recommended practice, some modules set up some global state that can be used by other modules. These modules may not have any exports, or the consumer is not interested in any of their exports. To import these modules, use:</source>
          <target state="translated">Хотя это и не рекомендуется,некоторые модули устанавливают некоторое глобальное состояние,которое может быть использовано другими модулями.Эти модули могут не иметь никакого экспорта,или потребитель не заинтересован в любом из их экспорта.Для импорта этих модулей,используйте:</target>
        </trans-unit>
        <trans-unit id="459af1bfbb68d7eb9e20b58d77f575123c077dc5" translate="yes" xml:space="preserve">
          <source>Thus, the following calls are equivalent:</source>
          <target state="translated">Таким образом,следующие вызовы эквивалентны:</target>
        </trans-unit>
        <trans-unit id="c479684dc5713300c68d9b67d81ddc804c214909" translate="yes" xml:space="preserve">
          <source>To allow differentiation between returned values and yielded values, TypeScript 3.6 converts the &lt;code&gt;IteratorResult&lt;/code&gt; type to a discriminated union type:</source>
          <target state="translated">Чтобы обеспечить различие между возвращаемыми значениями и полученными значениями, TypeScript 3.6 преобразует тип &lt;code&gt;IteratorResult&lt;/code&gt; в тип размеченного объединения:</target>
        </trans-unit>
        <trans-unit id="b4b29c56482897c2bcedcd82df10d23478983ef9" translate="yes" xml:space="preserve">
          <source>To begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you&amp;rsquo;re building a list of functions in an API or a one-off function to hand off to another function.</source>
          <target state="translated">Для начала, как и в JavaScript, функции TypeScript могут быть созданы как как именованная функция, так и как анонимная функция. Это позволяет вам выбрать наиболее подходящий подход для вашего приложения, независимо от того, создаете ли вы список функций в API или одноразовую функцию для передачи другой функции.</target>
        </trans-unit>
        <trans-unit id="ed7d2301f55dd416668c23e26708f6625cc0b7df" translate="yes" xml:space="preserve">
          <source>To check if &lt;code&gt;x&lt;/code&gt; is assignable to &lt;code&gt;y&lt;/code&gt;, we first look at the parameter list. Each parameter in &lt;code&gt;x&lt;/code&gt; must have a corresponding parameter in &lt;code&gt;y&lt;/code&gt; with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of &lt;code&gt;x&lt;/code&gt; has a corresponding compatible parameter in &lt;code&gt;y&lt;/code&gt;, so the assignment is allowed.</source>
          <target state="translated">Чтобы проверить, можно ли присвоить &lt;code&gt;x&lt;/code&gt; переменной &lt;code&gt;y&lt;/code&gt; , мы сначала смотрим на список параметров. Каждый параметр в &lt;code&gt;x&lt;/code&gt; должен иметь соответствующий параметр в &lt;code&gt;y&lt;/code&gt; совместимого типа. Обратите внимание, что не рассматриваются имена параметров, только их типы. В этом случае каждый параметр &lt;code&gt;x&lt;/code&gt; имеет соответствующий совместимый параметр в &lt;code&gt;y&lt;/code&gt; , поэтому присвоение разрешено.</target>
        </trans-unit>
        <trans-unit id="5aa2d6b34ccb6e986760e69cce9eaf8d194e80e3" translate="yes" xml:space="preserve">
          <source>To check whether &lt;code&gt;y&lt;/code&gt; can be assigned to &lt;code&gt;x&lt;/code&gt;, the compiler checks each property of &lt;code&gt;x&lt;/code&gt; to find a corresponding compatible property in &lt;code&gt;y&lt;/code&gt;. In this case, &lt;code&gt;y&lt;/code&gt; must have a member called &lt;code&gt;name&lt;/code&gt; that is a string. It does, so the assignment is allowed.</source>
          <target state="translated">Чтобы проверить, может ли &lt;code&gt;y&lt;/code&gt; быть присвоено &lt;code&gt;x&lt;/code&gt; , компилятор проверяет каждое свойство &lt;code&gt;x&lt;/code&gt; , чтобы найти соответствующее совместимое свойство в &lt;code&gt;y&lt;/code&gt; . В этом случае &lt;code&gt;y&lt;/code&gt; должен иметь член с именем &lt;code&gt;name&lt;/code&gt; , который является строкой. Это так, поэтому задание разрешено.</target>
        </trans-unit>
        <trans-unit id="75b4fbb1127914ceb3d21cad503d3f7fc1d4e3ca" translate="yes" xml:space="preserve">
          <source>To compile, we must specify a module target on the command line. For Node.js, use &lt;code&gt;--module commonjs&lt;/code&gt;; for require.js, use &lt;code&gt;--module amd&lt;/code&gt;. For example:</source>
          <target state="translated">Для компиляции мы должны указать целевой модуль в командной строке. Для Node.js используйте &lt;code&gt;--module commonjs&lt;/code&gt; ; для require.js используйте &lt;code&gt;--module amd&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="5c92181f23fdc218d3e5f2c8e5c093d3e88dd341" translate="yes" xml:space="preserve">
          <source>To correctly represent the types that can be passed in to a generator from calls to &lt;code&gt;next()&lt;/code&gt;, TypeScript 3.6 also infers certain uses of &lt;code&gt;yield&lt;/code&gt; within the body of a generator function.</source>
          <target state="translated">Чтобы правильно представить типы, которые могут быть переданы генератору из вызовов &lt;code&gt;next()&lt;/code&gt; , TypeScript 3.6 также предполагает определенные варианты использования &lt;code&gt;yield&lt;/code&gt; в теле функции генератора.</target>
        </trans-unit>
        <trans-unit id="4a85275c6424e7d3a9f548f3f9d3fe8015b36051" translate="yes" xml:space="preserve">
          <source>To define a type guard, we simply need to define a function whose return type is a &lt;em&gt;type predicate&lt;/em&gt;:</source>
          <target state="translated">Чтобы определить защиту типа, нам просто нужно определить функцию, возвращаемый тип которой является &lt;em&gt;предикатом типа&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="509608b5d7a3db1a99b623edfaa3336bb28d3b8d" translate="yes" xml:space="preserve">
          <source>To describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.</source>
          <target state="translated">Для описания типа функции с интерфейсом мы присваиваем интерфейсу сигнатуру вызова.Это похоже на объявление функции с указанием только списка параметров и типа возврата.Каждый параметр в списке параметров требует и названия,и типа.</target>
        </trans-unit>
        <trans-unit id="c07e6015d0cdce1868d861847dbd57c18c3fb7ac" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes.</source>
          <target state="translated">Для описания формы библиотек,не написанных в TypeScript,нам необходимо объявить API,которое библиотека раскрывает.</target>
        </trans-unit>
        <trans-unit id="afcbeb02ce03509365825abf4caef8de00c49ba6" translate="yes" xml:space="preserve">
          <source>To describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.</source>
          <target state="translated">Для описания формы библиотек,не написанных в TypeScript,нам необходимо объявить API,которое библиотека раскрывает.Поскольку большинство библиотек JavaScript выставляют только несколько объектов верхнего уровня,пространства имен являются хорошим способом их представления.</target>
        </trans-unit>
        <trans-unit id="0300d21291d54245672afcd6c034804cd6d8f1af" translate="yes" xml:space="preserve">
          <source>To detect the issue around accessors, TypeScript 3.7 will now emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files so that in TypeScript can check for overridden accessors.</source>
          <target state="translated">Чтобы обнаружить проблему, связанную с аксессорами, TypeScript 3.7 теперь будет &lt;code&gt;.d.ts&lt;/code&gt; &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; в файлах .d.ts, чтобы в TypeScript можно было проверять наличие переопределенных аксессоров.</target>
        </trans-unit>
        <trans-unit id="0105ab9a65a074ef9c63d082566ad7bd09908a6d" translate="yes" xml:space="preserve">
          <source>To do so, we&amp;rsquo;ll create an interface that describes our constraint. Here, we&amp;rsquo;ll create an interface that has a single &lt;code&gt;.length&lt;/code&gt; property and then we&amp;rsquo;ll use this interface and the &lt;code&gt;extends&lt;/code&gt; keyword to denote our constraint:</source>
          <target state="translated">Для этого мы создадим интерфейс, описывающий наше ограничение. Здесь мы создадим интерфейс с единственным свойством &lt;code&gt;.length&lt;/code&gt; , а затем воспользуемся этим интерфейсом и ключевым словом &lt;code&gt;extends&lt;/code&gt; для обозначения нашего ограничения:</target>
        </trans-unit>
        <trans-unit id="a28ef11afcbe8d3d69c6a4bf7c61c5a049f90264" translate="yes" xml:space="preserve">
          <source>To do this, you&amp;rsquo;ll need to create a &lt;code&gt;tsconfig.json&lt;/code&gt; which contains a list of your input files as well as all your compilation settings. Simply create a new file in your project root named &lt;code&gt;tsconfig.json&lt;/code&gt; and fill it with the following contents:</source>
          <target state="translated">Для этого вам нужно создать &lt;code&gt;tsconfig.json&lt;/code&gt; , который содержит список ваших входных файлов, а также все ваши настройки компиляции. Просто создайте новый файл в корне вашего проекта с именем &lt;code&gt;tsconfig.json&lt;/code&gt; и заполните его следующим содержимым:</target>
        </trans-unit>
        <trans-unit id="6a7b875dfeed7fc61c9681ef2adf2ce3963acdd1" translate="yes" xml:space="preserve">
          <source>To enable experimental support for decorators, you must enable the &lt;code&gt;experimentalDecorators&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">Чтобы включить экспериментальную поддержку декораторов, необходимо включить &lt;code&gt;experimentalDecorators&lt;/code&gt; компилятора опцию либо в командной строке или в вашем &lt;code&gt;tsconfig.json&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e91510089a97db0cb9eadcf3ab17449eabecd456" translate="yes" xml:space="preserve">
          <source>To enable the recursive type alias patterns described above, the &lt;code&gt;typeArguments&lt;/code&gt; property has been removed from the &lt;code&gt;TypeReference&lt;/code&gt; interface. Users should instead use the &lt;code&gt;getTypeArguments&lt;/code&gt; function on &lt;code&gt;TypeChecker&lt;/code&gt; instances.</source>
          <target state="translated">Чтобы включить описанные выше шаблоны псевдонимов рекурсивного типа, свойство &lt;code&gt;typeArguments&lt;/code&gt; было удалено из интерфейса &lt;code&gt;TypeReference&lt;/code&gt; . Пользователи должны вместо этого использовать &lt;code&gt;getTypeArguments&lt;/code&gt; функцию &lt;code&gt;TypeChecker&lt;/code&gt; экземпляров.</target>
        </trans-unit>
        <trans-unit id="e2363be8e6c6cb5a067aea3d8f64f3d22b30a1c7" translate="yes" xml:space="preserve">
          <source>To enable treating symbols as unique literals a new type &lt;code&gt;unique symbol&lt;/code&gt; is available. &lt;code&gt;unique symbol&lt;/code&gt; is a subtype of &lt;code&gt;symbol&lt;/code&gt;, and are produced only from calling &lt;code&gt;Symbol()&lt;/code&gt; or &lt;code&gt;Symbol.for()&lt;/code&gt;, or from explicit type annotations. The new type is only allowed on &lt;code&gt;const&lt;/code&gt; declarations and &lt;code&gt;readonly static&lt;/code&gt; properties, and in order to reference a specific unique symbol, you&amp;rsquo;ll have to use the &lt;code&gt;typeof&lt;/code&gt; operator. Each reference to a &lt;code&gt;unique symbol&lt;/code&gt; implies a completely unique identity that&amp;rsquo;s tied to a given declaration.</source>
          <target state="translated">Чтобы можно было рассматривать символы как уникальные литералы, доступен &lt;code&gt;unique symbol&lt;/code&gt; нового типа . &lt;code&gt;unique symbol&lt;/code&gt; - это подтип &lt;code&gt;symbol&lt;/code&gt; , который создается только &lt;code&gt;Symbol.for()&lt;/code&gt; вызова &lt;code&gt;Symbol()&lt;/code&gt; или Symbol.for () или явных аннотаций типов. Новый тип разрешен только в объявлениях &lt;code&gt;const&lt;/code&gt; и &lt;code&gt;readonly static&lt;/code&gt; свойствах только для чтения , и для ссылки на конкретный уникальный символ вам придется использовать оператор &lt;code&gt;typeof&lt;/code&gt; . Каждая ссылка на &lt;code&gt;unique symbol&lt;/code&gt; подразумевает полностью уникальную идентичность, привязанную к данному объявлению.</target>
        </trans-unit>
        <trans-unit id="cbf37d6416e66ab0ef9074eb1300931277b42ac8" translate="yes" xml:space="preserve">
          <source>To get more specific, let&amp;rsquo;s build up some motivation and consider the following &lt;code&gt;compose&lt;/code&gt; function:</source>
          <target state="translated">Чтобы быть более конкретным, давайте создадим некоторую мотивацию и рассмотрим следующую функцию &lt;code&gt;compose&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7dd85227b3548e65f6da723dba0b86e37aa0dbf7" translate="yes" xml:space="preserve">
          <source>To get the same code working, we&amp;rsquo;ll need to use a type assertion:</source>
          <target state="translated">Чтобы тот же код работал, нам нужно использовать утверждение типа:</target>
        </trans-unit>
        <trans-unit id="51bcd2ee5a6a2dcd5ba1a0638fe26fb80525ff92" translate="yes" xml:space="preserve">
          <source>To help mitigate the second issue, you can either add an explicit initializer or add a &lt;code&gt;declare&lt;/code&gt; modifier to indicate that a property should have no emit.</source>
          <target state="translated">Чтобы помочь смягчить вторую проблему, вы можете добавить явный инициализатор или добавить модификатор &lt;code&gt;declare&lt;/code&gt; , чтобы указать, что свойство не должно иметь излучения.</target>
        </trans-unit>
        <trans-unit id="13ac7bef7c1c7e11ef81979db1c2f2a81cf19fc2" translate="yes" xml:space="preserve">
          <source>To infer the type of &lt;code&gt;x&lt;/code&gt; in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt;. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.</source>
          <target state="translated">Чтобы определить тип &lt;code&gt;x&lt;/code&gt; в приведенном выше примере, мы должны рассмотреть тип каждого элемента массива. Здесь у нас есть два варианта выбора типа массива: &lt;code&gt;number&lt;/code&gt; и &lt;code&gt;null&lt;/code&gt; . Лучший алгоритм общего типа рассматривает каждый тип кандидата и выбирает тип, совместимый со всеми другими кандидатами.</target>
        </trans-unit>
        <trans-unit id="2cf2e12d1445d0aadb96f230e547df7611323dbd" translate="yes" xml:space="preserve">
          <source>To learn more, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;check out the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать больше, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31116&quot;&gt;ознакомьтесь с исходным запросом на перенос на GitHub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5f3e9b4e4a6af029b4267e885fa3ce255b1ecf" translate="yes" xml:space="preserve">
          <source>To maintain type safety, we can use the &lt;code&gt;typeof&lt;/code&gt; keyword. The &lt;code&gt;typeof&lt;/code&gt; keyword, when used in a type position, produces the type of a value, in this case the type of the module.</source>
          <target state="translated">Для обеспечения безопасности типов мы можем использовать ключевое слово &lt;code&gt;typeof&lt;/code&gt; . &lt;code&gt;typeof&lt;/code&gt; ключевое слово, при использовании в положении типа, производит тип значения, в данном случае тип модуля.</target>
        </trans-unit>
        <trans-unit id="625fea5502d41397c32546a9a0ea50c65ae835db" translate="yes" xml:space="preserve">
          <source>To merge the namespace value, at each declaration site, if a namespace already exists with the given name, it is further extended by taking the existing namespace and adding the exported members of the second namespace to the first.</source>
          <target state="translated">Для объединения значения пространства имён,в каждом сайте декларации,если пространство имён уже существует с заданным именем,оно расширяется путём взятия существующего пространства имён и добавления экспортируемых членов второго пространства имён к первому.</target>
        </trans-unit>
        <trans-unit id="e313e5ed420f9f03b21861d0bbd9027ef02d9b32" translate="yes" xml:space="preserve">
          <source>To merge the namespaces, type definitions from exported interfaces declared in each namespace are themselves merged, forming a single namespace with merged interface definitions inside.</source>
          <target state="translated">Для объединения пространств имен,определения типов экспортируемых интерфейсов,объявленные в каждом пространстве имен,сами объединяются,образуя единое пространство имен с объединенными определениями интерфейсов внутри.</target>
        </trans-unit>
        <trans-unit id="22cc216e31611ca78f1d455f6fccc99b2815b93a" translate="yes" xml:space="preserve">
          <source>To preserve existing functionality, we also add a simple getter that retrieves &lt;code&gt;fullName&lt;/code&gt; unmodified.</source>
          <target state="translated">Чтобы сохранить существующую функциональность, мы также добавляем простой метод получения, который извлекает &lt;code&gt;fullName&lt;/code&gt; без изменений.</target>
        </trans-unit>
        <trans-unit id="f744a2110e26e2b8cb5b64d6c11b34abc0ac07e8" translate="yes" xml:space="preserve">
          <source>To prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.</source>
          <target state="translated">Чтобы доказать себе,что наш аксессуар теперь проверяет длину значений,мы можем попытаться присвоить имя длиннее 10 символов и проверить,что мы получили ошибку.</target>
        </trans-unit>
        <trans-unit id="d0b5bbb81ca0d263287358fac537a9ccf83a25cd" translate="yes" xml:space="preserve">
          <source>To quickly recap what these two approaches look like in JavaScript:</source>
          <target state="translated">Чтобы быстро вспомнить,как эти два подхода выглядят в JavaScript:</target>
        </trans-unit>
        <trans-unit id="e294e29d961a6bb9b93ca330847244995e631e4c" translate="yes" xml:space="preserve">
          <source>To read up more about assertion signatures, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">Чтобы узнать больше о подписях утверждений, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;ознакомьтесь с исходным запросом на перенос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5032cc8bd0b8d34fd39729d94585dfdc34772a96" translate="yes" xml:space="preserve">
          <source>To reiterate why you shouldn&amp;rsquo;t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it&amp;rsquo;s unnecessary to use an additional module layer for exported objects.</source>
          <target state="translated">Чтобы повторить, почему вы не должны пытаться создать пространство имен для содержимого вашего модуля, общая идея пространства имен состоит в том, чтобы обеспечить логическое группирование конструкций и предотвратить конфликты имен. Поскольку сам файл модуля уже представляет собой логическую группу, а его имя верхнего уровня определяется кодом, который его импортирует, нет необходимости использовать дополнительный уровень модуля для экспортируемых объектов.</target>
        </trans-unit>
        <trans-unit id="8f051c1386e5d7793a46792a39ce291a486c3239" translate="yes" xml:space="preserve">
          <source>To specify this relationship to the compiler, use&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt;. &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">Чтобы указать это отношение к компилятору, используйте &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; . &lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; определяет список &lt;em&gt;корней&lt;/em&gt; , содержимое которых, как ожидается, будет объединено во время выполнения. Итак, следуя нашему примеру, файл &lt;code&gt;tsconfig.json&lt;/code&gt; должен выглядеть так:</target>
        </trans-unit>
        <trans-unit id="815547684a56e87f0f61f4eec10d3298c1894627" translate="yes" xml:space="preserve">
          <source>To start off, let&amp;rsquo;s do the &amp;ldquo;hello world&amp;rdquo; of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the &lt;code&gt;echo&lt;/code&gt; command.</source>
          <target state="translated">Для начала займемся &amp;laquo;привет миром&amp;raquo; дженериков: функцией идентификации. Функция идентификации - это функция, которая возвращает обратно все, что было передано. Вы можете думать об этом аналогично команде &lt;code&gt;echo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5b9fe870e7f5bf7070c8d8bb27856dc22fe14ff" translate="yes" xml:space="preserve">
          <source>To start, we&amp;rsquo;re going to structure our project in the following way:</source>
          <target state="translated">Для начала мы собираемся структурировать наш проект следующим образом:</target>
        </trans-unit>
        <trans-unit id="c6351bd2f28ea37dec03ce0f4f1566144d901482" translate="yes" xml:space="preserve">
          <source>To understand the full impact, read &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;the section above on the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag&lt;/a&gt;.</source>
          <target state="translated">Чтобы понять все последствия, прочтите &lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;раздел выше о флаге &lt;code&gt;useDefineForClassFields&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f47b632fb61682e3e1980ea8cfc2ca8c1262d2a4" translate="yes" xml:space="preserve">
          <source>To understand what steps the TS compiler will follow, it is important to shed some light on Node.js modules. Traditionally, imports in Node.js are performed by calling a function named &lt;code&gt;require&lt;/code&gt;. The behavior Node.js takes will differ depending on if &lt;code&gt;require&lt;/code&gt; is given a relative path or a non-relative path.</source>
          <target state="translated">Чтобы понять, какие шаги будет выполнять компилятор TS, важно пролить свет на модули Node.js. Традиционно импорт в Node.js выполняется путем вызова функции с именем &lt;code&gt;require&lt;/code&gt; . Поведение Node.js будет отличаться в зависимости от того, указан ли &lt;code&gt;require&lt;/code&gt; относительный или не относительный путь.</target>
        </trans-unit>
        <trans-unit id="dfa2ee0b72c86bc53820792311112500d3168498" translate="yes" xml:space="preserve">
          <source>To use JSX with React you should use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace appropriately for use with React.</source>
          <target state="translated">Чтобы использовать JSX с React, вы должны использовать &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;типизацию React&lt;/a&gt; . Эти типы определяют пространство имен &lt;code&gt;JSX&lt;/code&gt; , подходящее для использования с React.</target>
        </trans-unit>
        <trans-unit id="4e99d36c2c814e6db91b56c7f1385a2856d73b4a" translate="yes" xml:space="preserve">
          <source>To use JSX-support with React you should use the &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;React typings&lt;/a&gt;. These typings define the &lt;code&gt;JSX&lt;/code&gt; namespace so that TypeScript can correctly check JSX expressions for React. For example:</source>
          <target state="translated">Чтобы использовать JSX-поддержку с React, вы должны использовать &lt;a href=&quot;https://github.com/borisyankov/DefinitelyTyped/tree/master/react&quot;&gt;типизацию React&lt;/a&gt; . Эти типы определяют пространство имен &lt;code&gt;JSX&lt;/code&gt; , чтобы TypeScript мог правильно проверять выражения JSX на React. Например:</target>
        </trans-unit>
        <trans-unit id="8c8d5eec1e67cb76f8e5b9452d73b271fa703953" translate="yes" xml:space="preserve">
          <source>Today, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn&amp;rsquo;t actually UMD.</source>
          <target state="translated">Сегодня самые популярные глобально доступные библиотеки фактически написаны как библиотеки UMD (см. Ниже). Документацию библиотеки UMD трудно отличить от документации глобальной библиотеки. Перед написанием файла глобальной декларации убедитесь, что библиотека на самом деле не UMD.</target>
        </trans-unit>
        <trans-unit id="6fd792937ccf8cb9ce4609174a62036b37620b1a" translate="yes" xml:space="preserve">
          <source>Together (1) and (2) mean that we have to move our call to &lt;code&gt;browserify&lt;/code&gt; out of the &lt;code&gt;default&lt;/code&gt; task. And we have to give the function for &lt;code&gt;default&lt;/code&gt; a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.</source>
          <target state="translated">Вместе (1) и (2) означают , что мы должны двигаться наш призыв к &lt;code&gt;browserify&lt;/code&gt; из &lt;code&gt;default&lt;/code&gt; задачи. И мы должны дать функции по &lt;code&gt;default&lt;/code&gt; имя, поскольку и Watchify, и Gulp должны ее вызывать. Добавление регистрации с помощью (3) необязательно, но очень полезно для отладки вашей установки.</target>
        </trans-unit>
        <trans-unit id="90ffa057dee234ae14145ef7d88d4144f613ba98" translate="yes" xml:space="preserve">
          <source>Together with intersection types, we can make some pretty mind-bending types:</source>
          <target state="translated">Вместе с типами пересечений,мы можем сделать несколько довольно умопомрачительных типов:</target>
        </trans-unit>
        <trans-unit id="fc8a45a8bf9a321fc559be14ce628df7527276e1" translate="yes" xml:space="preserve">
          <source>Too many/too few arguments</source>
          <target state="translated">Слишком много/несколько аргументов</target>
        </trans-unit>
        <trans-unit id="d9b3553c61db15698937a8831d5f65646814ea45" translate="yes" xml:space="preserve">
          <source>ToolsVersion</source>
          <target state="translated">ToolsVersion</target>
        </trans-unit>
        <trans-unit id="2fcfbecfc781cdc6c205a4af08b389fbe5757349" translate="yes" xml:space="preserve">
          <source>Top-level &lt;code&gt;var&lt;/code&gt; statements or &lt;code&gt;function&lt;/code&gt; declarations</source>
          <target state="translated">Операторы &lt;code&gt;var&lt;/code&gt; или объявления &lt;code&gt;function&lt;/code&gt; верхнего уровня</target>
        </trans-unit>
        <trans-unit id="d190cc42b7745bd9ac9a35c4f9aea03a1b699465" translate="yes" xml:space="preserve">
          <source>Tracing module resolution</source>
          <target state="translated">Разрешение модуля трассировки</target>
        </trans-unit>
        <trans-unit id="23fcdfe71b99cac9d947ed514f12d8af78487a21" translate="yes" xml:space="preserve">
          <source>Trade-offs of Modules</source>
          <target state="translated">Компромиссы модулей</target>
        </trans-unit>
        <trans-unit id="53010e4ab65eb0ff069216401ae1c2dcb7276af7" translate="yes" xml:space="preserve">
          <source>Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers will be able to build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.</source>
          <target state="translated">Традиционный JavaScript использует функции и наследование по прототипу для построения компонентов многократного использования,но это может показаться немного неудобным для программистов,которым более удобен объектно-ориентированный подход,при котором классы наследуют функциональность,а объекты строятся из этих классов.Начиная с ECMAScript 2015,также известного как ECMAScript 6,JavaScript-программисты смогут строить свои приложения,используя этот объектно-ориентированный подход на основе классов.В TypeScript мы позволяем разработчикам использовать эти методы сейчас,и компилировать их вплоть до JavaScript,который работает во всех основных браузерах и платформах,не дожидаясь следующей версии JavaScript.</target>
        </trans-unit>
        <trans-unit id="1539cd14df7b42b7daf67ab3a0fb1394a708ce8d" translate="yes" xml:space="preserve">
          <source>Trailing comma in function parameter and argument lists are now allowed. This is an implementation for a &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;Stage-3 ECMAScript proposal&lt;/a&gt; that emits down to valid ES3/ES5/ES6.</source>
          <target state="translated">Завершающая запятая в списках параметров функции и аргументов теперь разрешена. Это реализация для &lt;a href=&quot;https://jeffmo.github.io/es-trailing-function-commas/&quot;&gt;ECMAScript-предложения Stage-3,&lt;/a&gt; которая передается до действительных ES3 / ES5 / ES6.</target>
        </trans-unit>
        <trans-unit id="676e9d1917b5b40fea52df91ac4e9afc970551cb" translate="yes" xml:space="preserve">
          <source>Trailing commas in function parameter and argument lists</source>
          <target state="translated">Трейлинг запятых в списках параметров и аргументов функции</target>
        </trans-unit>
        <trans-unit id="346f219fb82d976707a1e387e3becf3823d4827c" translate="yes" xml:space="preserve">
          <source>Translate newer JavaScript constructs down to an older version like ECMAScript 5 (using &lt;code&gt;target&lt;/code&gt;).</source>
          <target state="translated">Преобразуйте новые конструкции JavaScript в более старую версию, такую ​​как ECMAScript 5 (используя &lt;code&gt;target&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86523d66f5bea3f709bea059e7608d702a785b4a" translate="yes" xml:space="preserve">
          <source>Triple-Slash Directives</source>
          <target state="translated">Директивы с тройной косой чертой</target>
        </trans-unit>
        <trans-unit id="98c8afb6c3de9dfeb15ccf98245b5224564946da" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are &lt;strong&gt;only&lt;/strong&gt; valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.</source>
          <target state="translated">Директивы с тройной косой чертой действительны &lt;strong&gt;только&lt;/strong&gt; в верхней части содержащего их файла. Директиве с тройной косой чертой могут предшествовать только однострочные или многострочные комментарии, включая другие директивы с тройной косой чертой. Если они встречаются после оператора или объявления, они рассматриваются как обычные однострочные комментарии и не имеют особого значения.</target>
        </trans-unit>
        <trans-unit id="694056eae93e31824a823939ec9db90fae068479" translate="yes" xml:space="preserve">
          <source>Triple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.</source>
          <target state="translated">Директивы Triple-slash-это однострочные комментарии,содержащие один XML-тег.Содержимое комментария используется в качестве директив компилятора.</target>
        </trans-unit>
        <trans-unit id="3c8912f7f0f56aa84a0690a0f86c344e802e0ceb" translate="yes" xml:space="preserve">
          <source>Triple-slash references instruct the compiler to include additional files in the compilation process.</source>
          <target state="translated">Ссылки Triple-slash инструктируют компилятор включать дополнительные файлы в процесс компиляции.</target>
        </trans-unit>
        <trans-unit id="c41a2be51027c17da2914785c19c9af65da7231f" translate="yes" xml:space="preserve">
          <source>Tuple</source>
          <target state="translated">Tuple</target>
        </trans-unit>
        <trans-unit id="a78911125d5984a872d05a288f51fc96a8c5d183" translate="yes" xml:space="preserve">
          <source>Tuple destructuring</source>
          <target state="translated">разрушение кортежа</target>
        </trans-unit>
        <trans-unit id="5501f69a4f42fb8e135b4df10c2273778be704fd" translate="yes" xml:space="preserve">
          <source>Tuple types</source>
          <target state="translated">типы кортежей</target>
        </trans-unit>
        <trans-unit id="f4c8d119fb4e608da43d1f1658b2fb16039d3ae4" translate="yes" xml:space="preserve">
          <source>Tuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a &lt;code&gt;string&lt;/code&gt; and a &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">Типы кортежей позволяют выразить массив с фиксированным числом элементов, типы которых известны, но не обязательно должны быть одинаковыми. Например, вы можете представить значение как пару &lt;code&gt;string&lt;/code&gt; и &lt;code&gt;number&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b40c00912c71e3e2a5296ac9e1c04677483c24ca" translate="yes" xml:space="preserve">
          <source>Tuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a &lt;code&gt;string&lt;/code&gt; at position 0 and a &lt;code&gt;number&lt;/code&gt; at position 1:</source>
          <target state="translated">Типы кортежей выражают массив, в котором тип определенных элементов известен, но не обязательно должен быть одинаковым. Например, вы можете представить массив со &lt;code&gt;string&lt;/code&gt; в позиции 0 и &lt;code&gt;number&lt;/code&gt; в позиции 1:</target>
        </trans-unit>
        <trans-unit id="3e80f8a540a40c8de1af1a3e84fbfd7f02d4e041" translate="yes" xml:space="preserve">
          <source>Tuple types now permit a &lt;code&gt;?&lt;/code&gt; postfix on element types to indicate that the element is optional:</source>
          <target state="translated">Типы кортежей теперь разрешают &lt;code&gt;?&lt;/code&gt; постфикс для типов элементов, чтобы указать, что элемент является необязательным:</target>
        </trans-unit>
        <trans-unit id="670c49cda0efba0500f15dd982d4fa2aed2d3f11" translate="yes" xml:space="preserve">
          <source>Tuples in rest parameters and spread expressions</source>
          <target state="translated">Кортежи в параметрах покоя и выражениях спреда</target>
        </trans-unit>
        <trans-unit id="20bb571234709f16dbeaea6bc15866de96b8321d" translate="yes" xml:space="preserve">
          <source>Tuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:</source>
          <target state="translated">Кортежи могут быть разрушены как массивы,а деструктирующие переменные получают типы соответствующих элементов кортежа:</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="96e00fe98faa413635ba213d31572b56fb6e2bb5" translate="yes" xml:space="preserve">
          <source>Type Alias</source>
          <target state="translated">Тип псевдонима</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">псевдонимы типа</target>
        </trans-unit>
        <trans-unit id="a6de4b535fedeaa8890bd890b60fe09f87b5f96a" translate="yes" xml:space="preserve">
          <source>Type Checking</source>
          <target state="translated">Проверка типа</target>
        </trans-unit>
        <trans-unit id="69fccbed8b512e180b2e56eec7bf36107d0fc4af" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files</source>
          <target state="translated">Введите Проверка файлов JavaScript</target>
        </trans-unit>
        <trans-unit id="c9bb3cb2e0b8995f27923c9071e954a24b9a502b" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @enum</source>
          <target state="translated">Введите Проверка файлов JavaScript:@enum</target>
        </trans-unit>
        <trans-unit id="e1907e29cdd514784f2fa3e5a5c0bdf2cc55da0a" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @this</source>
          <target state="translated">Введите Проверка файлов JavaScript:@это</target>
        </trans-unit>
        <trans-unit id="facd96a18391e3f3e7ddd9cef95660e1b7913914" translate="yes" xml:space="preserve">
          <source>Type Checking JavaScript Files: @type</source>
          <target state="translated">Введите Проверка файлов JavaScript:@тип</target>
        </trans-unit>
        <trans-unit id="9e95ef0e2279689ee3c96fd9dc0e3216f9ec17ae" translate="yes" xml:space="preserve">
          <source>Type Compatibility</source>
          <target state="translated">Совместимость с типом</target>
        </trans-unit>
        <trans-unit id="e9dc1ea4bae0ebaf470542aca51daa44cdcc9111" translate="yes" xml:space="preserve">
          <source>Type Compatibility: Enums</source>
          <target state="translated">Совместимость с типом:Перечисления</target>
        </trans-unit>
        <trans-unit id="5ce9a2f030a10c54388849495b66d1858de81a97" translate="yes" xml:space="preserve">
          <source>Type Declarations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165b26b05bf5c16d49e5cf4d678908fdae6f68f4" translate="yes" xml:space="preserve">
          <source>Type Guards</source>
          <target state="translated">Типовые гвардейцы</target>
        </trans-unit>
        <trans-unit id="400e9828133bab9e18749f6f036fd264029f1e6c" translate="yes" xml:space="preserve">
          <source>Type Guards and Differentiating Types</source>
          <target state="translated">Тип охранников и дифференцирующие типы</target>
        </trans-unit>
        <trans-unit id="79b8bfde654e6b575d1b453221740941f040398d" translate="yes" xml:space="preserve">
          <source>Type Inference</source>
          <target state="translated">Типовой вывод</target>
        </trans-unit>
        <trans-unit id="0e2e016dff9c3ffe6b4498005a639ca83394f86e" translate="yes" xml:space="preserve">
          <source>Type aliases are exactly the same as their original types; they are simply alternative names.</source>
          <target state="translated">Псевдонимы типов в точности совпадают с их оригинальными типами;это просто альтернативные имена.</target>
        </trans-unit>
        <trans-unit id="04332612727d798a56e4c9adf1af2f0e95c39d60" translate="yes" xml:space="preserve">
          <source>Type aliases create a new name for a type. Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you&amp;rsquo;d otherwise have to write by hand.</source>
          <target state="translated">Псевдонимы типа создают новое имя для типа. Псевдонимы типов иногда похожи на интерфейсы, но могут называть примитивы, объединения, кортежи и любые другие типы, которые в противном случае вам пришлось бы писать вручную.</target>
        </trans-unit>
        <trans-unit id="74b2b8803d08ed1d0626e3ffe8a2182c1309b352" translate="yes" xml:space="preserve">
          <source>Type aliases have always had a limitation in how they could be &amp;ldquo;recursively&amp;rdquo; referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that&amp;rsquo;s not possible, so the compiler rejects certain recursive aliases like the following:</source>
          <target state="translated">Псевдонимы типов всегда имели ограничение в том, как на них можно ссылаться &amp;laquo;рекурсивно&amp;raquo;. Причина в том, что любое использование псевдонима типа должно иметь возможность заменять себя любым псевдонимом. В некоторых случаях это невозможно, поэтому компилятор отклоняет определенные рекурсивные псевдонимы, например следующие:</target>
        </trans-unit>
        <trans-unit id="ee5f3de7938afc6193f57957cf627bbf0b440e19" translate="yes" xml:space="preserve">
          <source>Type annotations</source>
          <target state="translated">Введите аннотации</target>
        </trans-unit>
        <trans-unit id="771c581ff30572b5e74a273ca4a6cfa2c2dd00e9" translate="yes" xml:space="preserve">
          <source>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</source>
          <target state="translated">Аннотации типа в TypeScript-это легкий способ записи предполагаемого договора функции или переменной.В этом случае мы предполагаем,что функция greeter будет вызываться с одним строковым параметром.Вместо этого можно попробовать изменить вызов greeter на передачу массива:</target>
        </trans-unit>
        <trans-unit id="4c0bd0a7f58c36c032f4bebd542b40c8d83ddd62" translate="yes" xml:space="preserve">
          <source>Type assertion/cast syntax in &lt;code&gt;checkJs&lt;/code&gt;/&lt;code&gt;@ts-check&lt;/code&gt; mode</source>
          <target state="translated">Тип утверждение / приведение синтаксиса в &lt;code&gt;checkJs&lt;/code&gt; / &lt;code&gt;@ts-check&lt;/code&gt; режима</target>
        </trans-unit>
        <trans-unit id="8207094f90fa241c769cf714f68957046cb3e948" translate="yes" xml:space="preserve">
          <source>Type assertions</source>
          <target state="translated">Типовые заявления</target>
        </trans-unit>
        <trans-unit id="9d46ff18751ffb41bab6a1e95fa3947ce8fb07c0" translate="yes" xml:space="preserve">
          <source>Type assertions have two forms. One is the &amp;ldquo;angle-bracket&amp;rdquo; syntax:</source>
          <target state="translated">Утверждения типа имеют две формы. Один из них - это синтаксис &amp;laquo;угловой скобки&amp;raquo;:</target>
        </trans-unit>
        <trans-unit id="252726c38b1deeaec7381a04cf0566bc59bbe5ae" translate="yes" xml:space="preserve">
          <source>Type checking of the &lt;code&gt;instanceof&lt;/code&gt; operator is now based on whether the type of the left operand &lt;em&gt;derives from&lt;/em&gt; the type indicated by the right operand (as opposed to a structural subtype check).</source>
          <target state="translated">Проверка типа оператора &lt;code&gt;instanceof&lt;/code&gt; теперь основана на том, является ли тип левого операнда &lt;em&gt;производным от&lt;/em&gt; типа, указанного правым операндом (в отличие от проверки структурного подтипа).</target>
        </trans-unit>
        <trans-unit id="3986b509fdf26a1e0d932541d6bf318fa2f131c4" translate="yes" xml:space="preserve">
          <source>Type compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:</source>
          <target state="translated">Совместимость типов в TypeScript основана на структурном подтипе.Структурное типирование-это способ соотношения типов,основанный исключительно на их членах.Это контрастирует с номинальным набором.Рассмотрим следующий код:</target>
        </trans-unit>
        <trans-unit id="d40d6a67837031f0abaec956923830758108f84e" translate="yes" xml:space="preserve">
          <source>Type guards and type assertions</source>
          <target state="translated">Типовые ограждения и типовые утверждения</target>
        </trans-unit>
        <trans-unit id="df0459267a3773c5f28373435d5ec35b5af11cce" translate="yes" xml:space="preserve">
          <source>Type guards for dotted names also work with user defined type guard functions and the &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt; operators and do not depend on the &lt;code&gt;--strictNullChecks&lt;/code&gt; compiler option.</source>
          <target state="translated">Защиты типов для имен, разделенных точками, также работают с пользовательскими функциями защиты типов и операторами &lt;code&gt;typeof&lt;/code&gt; и &lt;code&gt;instanceof&lt;/code&gt; и не зависят от &lt;code&gt;--strictNullChecks&lt;/code&gt; компилятора --strictNullChecks .</target>
        </trans-unit>
        <trans-unit id="df87981f3212072661057f255c1414c8249e617d" translate="yes" xml:space="preserve">
          <source>Type guards inferred from &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">Тип охранники выведены из &lt;code&gt;in&lt;/code&gt; операторах</target>
        </trans-unit>
        <trans-unit id="5c04d68c075d1cf49c5039cfaf5a91d9a3af3583" translate="yes" xml:space="preserve">
          <source>Type guards on the common property.</source>
          <target state="translated">Тип охранников на общей территории.</target>
        </trans-unit>
        <trans-unit id="4a16ed7f934fd06b2eab4f404c014b3aa9ede6e0" translate="yes" xml:space="preserve">
          <source>Type guards previously only supported checking local variables and parameters. Type guards now support checking &amp;ldquo;dotted names&amp;rdquo; consisting of a variable or parameter name followed one or more property accesses.</source>
          <target state="translated">Защитники типов ранее поддерживали только проверку локальных переменных и параметров. Защита типов теперь поддерживает проверку &amp;laquo;разделенных точками имен&amp;raquo;, состоящих из имени переменной или параметра, за которым следуют обращения к одному или нескольким свойствам.</target>
        </trans-unit>
        <trans-unit id="a6fec2d2cb8ea42fc5e8b24e33871a744a3803c5" translate="yes" xml:space="preserve">
          <source>Type in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.</source>
          <target state="translated">Введите поля и убедитесь,что точка останова попадает в код TypeScript и что проверка работает корректно.</target>
        </trans-unit>
        <trans-unit id="04a0aaa0033ce536b51805d3619fe260b178891e" translate="yes" xml:space="preserve">
          <source>Type inference also works in &amp;ldquo;the other direction&amp;rdquo; in some cases in TypeScript. This is known as &amp;ldquo;contextual typing&amp;rdquo;. Contextual typing occurs when the type of an expression is implied by its location. For example:</source>
          <target state="translated">В TypeScript в некоторых случаях вывод типов также работает &amp;laquo;в обратном направлении&amp;raquo;. Это известно как &amp;laquo;контекстная типизация&amp;raquo;. Контекстная типизация происходит, когда тип выражения подразумевается его местоположением. Например:</target>
        </trans-unit>
        <trans-unit id="5b50efd50f8efbd22bb877ea81f90fae7f14657c" translate="yes" xml:space="preserve">
          <source>Type inference in conditional types</source>
          <target state="translated">Типовой вывод в условных типах</target>
        </trans-unit>
        <trans-unit id="34f7e0851caaf9f6232cdc334af3947615acc7f1" translate="yes" xml:space="preserve">
          <source>Type parameter inference from contextual types</source>
          <target state="translated">Введите параметр умозаключения из контекстных типов</target>
        </trans-unit>
        <trans-unit id="866c38bce26d304928239997fc8fd61be65a48c4" translate="yes" xml:space="preserve">
          <source>Type parameters as constraints</source>
          <target state="translated">Типовые параметры как ограничения</target>
        </trans-unit>
        <trans-unit id="83cb868a19ad904f84bd14cae43f07e0e83d2688" translate="yes" xml:space="preserve">
          <source>Type widening</source>
          <target state="translated">Расширение типа</target>
        </trans-unit>
        <trans-unit id="3e24ac06d77df39af05bd30d658cb57a3337ea7e" translate="yes" xml:space="preserve">
          <source>Type-checking for &lt;code&gt;globalThis&lt;/code&gt;</source>
          <target state="translated">Проверка типов для &lt;code&gt;globalThis&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="132ee1e5890623f8c51b5d7832771ea869685cc0" translate="yes" xml:space="preserve">
          <source>Type-checking speed-ups</source>
          <target state="translated">Ускорение проверки типа</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="51f19890936977049a98344a575f9d1393582141" translate="yes" xml:space="preserve">
          <source>TypeScript 1.1</source>
          <target state="translated">TypeScript 1.1</target>
        </trans-unit>
        <trans-unit id="b1d54818952af192cd88b3450b54f2603e4f7e6b" translate="yes" xml:space="preserve">
          <source>TypeScript 1.3</source>
          <target state="translated">TypeScript 1.3</target>
        </trans-unit>
        <trans-unit id="4e048202597f480e0a0a50251a2d17601a97331c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.4</source>
          <target state="translated">TypeScript 1.4</target>
        </trans-unit>
        <trans-unit id="f1963162918ae8e217f030a5c747f80a58b5003c" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5</source>
          <target state="translated">TypeScript 1.5</target>
        </trans-unit>
        <trans-unit id="f1a5005d913327706c332f5d05905d598d513f83" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 destructuring declarations and assignments.</source>
          <target state="translated">TypeScript 1.5 добавляет поддержку деклараций и назначений деструкции ES6.</target>
        </trans-unit>
        <trans-unit id="335ed14095b748ea23e413ca55e75e72c5f81c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.</source>
          <target state="translated">В TypeScript 1.5 добавлена поддержка ES6 для...циклов на массивах для ES3/ES5,а также полная поддержка интерфейсов Iterator при таргетировании ES6.</target>
        </trans-unit>
        <trans-unit id="147499580851a581c1ebc7b1eb35e61574c9455f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript&amp;rsquo;s original internal and external module constructs and the constructs can be mixed and matched at will.</source>
          <target state="translated">TypeScript 1.5 поддерживает модули ECMAScript 6 (ES6). Модули ES6 по сути являются внешними модулями TypeScript с новым синтаксисом: модули ES6 - это отдельно загружаемые исходные файлы, которые, возможно, импортируют другие модули и предоставляют ряд доступных извне экспортов. В модулях ES6 есть несколько новых деклараций экспорта и импорта. Рекомендуется обновить библиотеки и приложения TypeScript для использования нового синтаксиса, но это не является обязательным требованием. Новый синтаксис модуля ES6 сосуществует с исходными внутренними и внешними конструкциями модулей TypeScript, и конструкции могут быть смешаны и сопоставлены по желанию.</target>
        </trans-unit>
        <trans-unit id="26a05cf740016ec03540fa113e60b6681f5d2b43" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6</source>
          <target state="translated">TypeScript 1.6</target>
        </trans-unit>
        <trans-unit id="257249ad75fda76652230e9b8ec23343f481d876" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds a new way to narrow a variable type inside an &lt;code&gt;if&lt;/code&gt; block, in addition to &lt;code&gt;typeof&lt;/code&gt; and &lt;code&gt;instanceof&lt;/code&gt;. A user-defined type guard functions is one with a return type annotation of the form &lt;code&gt;x is T&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is a declared parameter in the signature, and &lt;code&gt;T&lt;/code&gt; is any type. When a user-defined type guard function is invoked on a variable in an &lt;code&gt;if&lt;/code&gt; block, the type of the variable will be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6 добавляет новый способ сузить тип переменной внутри блока &lt;code&gt;if&lt;/code&gt; в дополнение к &lt;code&gt;typeof&lt;/code&gt; и &lt;code&gt;instanceof&lt;/code&gt; . Функции защиты определяемого пользователем типа - это функция с аннотацией возвращаемого типа в форме &lt;code&gt;x is T&lt;/code&gt; , где &lt;code&gt;x&lt;/code&gt; - объявленный параметр в подписи, а &lt;code&gt;T&lt;/code&gt; - любой тип. При определенной пользователем функции охранник типа вызывается переменной в , &lt;code&gt;if&lt;/code&gt; блок, тип переменной будет сужен до &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f559afb4f11f75baf94b34b6c1d2a9f3ffb7db7" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for &lt;code&gt;abstract&lt;/code&gt; keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.</source>
          <target state="translated">TypeScript 1.6 добавляет поддержку ключевого слова &lt;code&gt;abstract&lt;/code&gt; для классов и их методов. Абстрактный класс может иметь методы без реализации и не может быть построен.</target>
        </trans-unit>
        <trans-unit id="b5e601692f8167fd347befb7fc0e15d90de2b5e2" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:</source>
          <target state="translated">В TypeScript 1.6 добавлена поддержка выражений класса ES6.В выражении класса имя класса является необязательным и,если оно указано,находится только в области видимости в самом выражении класса.Это похоже на необязательное имя выражения функции.Невозможно ссылаться на тип экземпляра выражения класса вне выражения класса,но тип,конечно,может быть структурно подобран.Например:</target>
        </trans-unit>
        <trans-unit id="d34db5c0571adb17d9dbb4e011e6ce7abf305442" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.</source>
          <target state="translated">В TypeScript 1.6 добавлена поддержка классов,расширяющих произвольное выражение,которое вычисляет функцию конструктора.Это означает,что встроенные типы теперь могут быть расширены в объявлениях классов.</target>
        </trans-unit>
        <trans-unit id="6dc2d923fb5094bd0e7c94f1ead891676ccf6b36" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 adds support for generators when targeting ES6.</source>
          <target state="translated">В TypeScript 1.6 добавлена поддержка генераторов при нацеливании на ES6.</target>
        </trans-unit>
        <trans-unit id="c2708dce6a915f6b14074965fa09a0d65239987f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don&amp;rsquo;t exist in the target type.</source>
          <target state="translated">TypeScript 1.6 применяет более строгие проверки назначения литералов объекта с целью выявления лишних или неправильно написанных свойств. В частности, когда новый литерал объекта присваивается переменной или передается в качестве аргумента для непустого целевого типа, для литерала объекта возникает ошибка указывать свойства, которые не существуют в целевом типе.</target>
        </trans-unit>
        <trans-unit id="75bb78b9b873fbe1d3340640c97864da1f68f446" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces a new &lt;code&gt;.tsx&lt;/code&gt; file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new &lt;code&gt;as&lt;/code&gt; operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:</source>
          <target state="translated">TypeScript 1.6 представляет новое &lt;code&gt;.tsx&lt;/code&gt; файла .tsx . Это расширение выполняет две функции: оно включает JSX внутри файлов TypeScript и делает оператор new &lt;code&gt;as&lt;/code&gt; способом преобразования по умолчанию (устраняя любую двусмысленность между выражениями JSX и оператором преобразования префикса TypeScript). Например:</target>
        </trans-unit>
        <trans-unit id="389c8891386ded2a5990a7399a0c8581f595589d" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces experimental support of &lt;code&gt;async&lt;/code&gt; functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible &lt;code&gt;Promise&lt;/code&gt; implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.</source>
          <target state="translated">TypeScript 1.6 представляет экспериментальную поддержку &lt;code&gt;async&lt;/code&gt; функций при ориентации на ES6. Ожидается, что асинхронные функции будут вызывать асинхронную операцию и ожидать ее результата, не блокируя нормальное выполнение программы. Это достигается за счет использования ES6-совместимой реализации &lt;code&gt;Promise&lt;/code&gt; и преобразования тела функции в совместимую форму для возобновления выполнения после завершения ожидаемой асинхронной операции.</target>
        </trans-unit>
        <trans-unit id="6d3985068c5007795b0f129f437f0236376e44ee" translate="yes" xml:space="preserve">
          <source>TypeScript 1.6 introduces intersection types, the logical complement of union types. A union type &lt;code&gt;A | B&lt;/code&gt; represents an entity that is either of type &lt;code&gt;A&lt;/code&gt; or type &lt;code&gt;B&lt;/code&gt;, whereas an intersection type &lt;code&gt;A &amp;amp; B&lt;/code&gt; represents an entity that is both of type &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt; type &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.6 представляет типы пересечений, логическое дополнение типов объединения. Тип объединения &lt;code&gt;A | B&lt;/code&gt; представляет собой объект , который является либо типа &lt;code&gt;A&lt;/code&gt; или типа &lt;code&gt;B&lt;/code&gt; , в то время как тип пересечения &lt;code&gt;A &amp;amp; B&lt;/code&gt; представляет собой объект , который является оба типа &lt;code&gt;A&lt;/code&gt; &lt;em&gt;и&lt;/em&gt; типа &lt;code&gt;B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5adb28b0e2ffb9129f1f8e6e88f1a6d027c82cfd" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7</source>
          <target state="translated">TypeScript 1.7</target>
        </trans-unit>
        <trans-unit id="b8049d25161330d1dbcbb77bfa401335476ed317" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 adds &lt;code&gt;ES6&lt;/code&gt; to the list of options available for the &lt;code&gt;--module&lt;/code&gt; flag and allows you to specify the module output when targeting &lt;code&gt;ES6&lt;/code&gt;. This provides more flexibility to target exactly the features you want in specific runtimes.</source>
          <target state="translated">TypeScript 1.7 добавляет &lt;code&gt;ES6&lt;/code&gt; в список опций, доступных для флага &lt;code&gt;--module&lt;/code&gt; , и позволяет вам указать вывод модуля при ориентации на &lt;code&gt;ES6&lt;/code&gt; . Это обеспечивает большую гибкость для нацеливания именно на те функции, которые вам нужны в определенных средах выполнения.</target>
        </trans-unit>
        <trans-unit id="372cae9853890909499623bfc1859384ca77ae13" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.</source>
          <target state="translated">TypeScript 1.7 делает проверку шаблонов разрушения с помощью буквенных инициализаторов объектов или массивов менее жесткой и более интуитивной.</target>
        </trans-unit>
        <trans-unit id="3a8e0881b9f6a916c5d699f8a8930f131e755c61" translate="yes" xml:space="preserve">
          <source>TypeScript 1.7 supports upcoming &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;ES7/ES2016 exponentiation operators&lt;/a&gt;: &lt;code&gt;**&lt;/code&gt; and &lt;code&gt;**=&lt;/code&gt;. The operators will be transformed in the output to ES3/ES5 using &lt;code&gt;Math.pow&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.7 поддерживает следующие &lt;a href=&quot;https://github.com/rwaldron/exponentiation-operator&quot;&gt;операторы возведения в степень ES7 / ES2016&lt;/a&gt; : &lt;code&gt;**&lt;/code&gt; и &lt;code&gt;**=&lt;/code&gt; . Операторы будут преобразованы в выводе в ES3 / ES5 с помощью &lt;code&gt;Math.pow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90324bee80eec2d37872bcfe8ebd584d982ffa5e" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8</source>
          <target state="translated">TypeScript 1.8</target>
        </trans-unit>
        <trans-unit id="bf434e8d29bed8fa2f0c97832e4f7465ceae4e51" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows &lt;code&gt;tsconfig.json&lt;/code&gt; files in all project types. This includes ASP.NET v4 projects, &lt;em&gt;Console Application&lt;/em&gt;, and the &lt;em&gt;Html Application with TypeScript&lt;/em&gt; project types. Further, you are no longer limited to a single &lt;code&gt;tsconfig.json&lt;/code&gt; file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.</source>
          <target state="translated">TypeScript 1.8 позволяет &lt;code&gt;tsconfig.json&lt;/code&gt; файлы tsconfig.json во всех типах проектов. Сюда входят проекты ASP.NET v4, &lt;em&gt;консольное приложение&lt;/em&gt; и &lt;em&gt;приложение Html с&lt;/em&gt; типами проектов &lt;em&gt;TypeScript&lt;/em&gt; . Кроме того, вы больше не ограничены одним файлом &lt;code&gt;tsconfig.json&lt;/code&gt; , но можете добавить несколько, и каждый из них будет создан как часть проекта. Это позволяет вам разделять конфигурацию для разных частей вашего приложения без необходимости использовать несколько разных проектов.</target>
        </trans-unit>
        <trans-unit id="523ae0c6d720551553d08e322cbe5f48827a2f11" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 allows users to use the &lt;code&gt;--outFile&lt;/code&gt; argument with special file system entities like named pipes, devices, etc.</source>
          <target state="translated">TypeScript 1.8 позволяет пользователям использовать аргумент &lt;code&gt;--outFile&lt;/code&gt; со специальными объектами файловой системы, такими как именованные каналы, устройства и т. Д.</target>
        </trans-unit>
        <trans-unit id="c4f9c3f076e54a2df1c744ed292a1d25e9395f14" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 extends &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;user-defined type guard functions&lt;/a&gt; to class and interface methods.</source>
          <target state="translated">TypeScript 1.8 расширяет &lt;a href=&quot;typescript-1.6#user-defined-type-guard-functions&quot;&gt;определяемые пользователем функции защиты типов&lt;/a&gt; до методов класса и интерфейса.</target>
        </trans-unit>
        <trans-unit id="c547a86975df477d786c26c38684de89346ada33" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from &lt;code&gt;string | string[]&lt;/code&gt; to &lt;code&gt;string | T&lt;/code&gt;, we reduce the types to &lt;code&gt;string[]&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt;, thus inferring &lt;code&gt;string[]&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">TypeScript 1.8 улучшает вывод типов, включая исходную и целевую стороны, которые являются типами объединения или пересечения. Например, при выводе из &lt;code&gt;string | string[]&lt;/code&gt; в &lt;code&gt;string | T&lt;/code&gt; , мы уменьшаем типы для &lt;code&gt;string[]&lt;/code&gt; и &lt;code&gt;T&lt;/code&gt; , тем самым выводя &lt;code&gt;string[]&lt;/code&gt; для &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f21f8b70d4093a0a0b9a977e3f5e108e10ca93f" translate="yes" xml:space="preserve">
          <source>TypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:</source>
          <target state="translated">TypeScript 1.8 представляет анализ потока управления,чтобы помочь отловить распространенные ошибки,с которыми обычно сталкиваются пользователи.Читайте дальше,чтобы получить более подробную информацию,и проверьте эти ошибки в действии:</target>
        </trans-unit>
        <trans-unit id="316c73dc14076f7eaec6a1b058acbdbcd6b03a9b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0</source>
          <target state="translated">TypeScript 2.0</target>
        </trans-unit>
        <trans-unit id="7ed2b43586705d3525a6d00f06348de23a60d9e8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 adds a new &lt;code&gt;--skipLibCheck&lt;/code&gt; compiler option that causes type checking of declaration files (files with extension &lt;code&gt;.d.ts&lt;/code&gt;) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.</source>
          <target state="translated">TypeScript 2.0 добавляет новый &lt;code&gt;--skipLibCheck&lt;/code&gt; компилятора &lt;code&gt;.d.ts&lt;/code&gt; позволяет пропускать проверку типов файлов объявлений (файлов с расширением .d.ts ). Когда программа включает большие файлы объявлений, компилятор тратит много времени на проверку типов объявлений, которые уже заведомо не содержат ошибок, и время компиляции может быть значительно сокращено за счет пропуска проверок типов файлов объявлений.</target>
        </trans-unit>
        <trans-unit id="5a7e5d59bd5cadb1929863b64869919254d9fa38" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 has two new flags to help you maintain a clean code base. &lt;code&gt;--noUnusedParameters&lt;/code&gt; flags any unused function or method parameters errors. &lt;code&gt;--noUnusedLocals&lt;/code&gt; flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc&amp;hellip; Also, unused private members of a class would be flagged as errors under &lt;code&gt;--noUnusedLocals&lt;/code&gt;.</source>
          <target state="translated">В TypeScript 2.0 есть два новых флага, которые помогут вам поддерживать чистую базу кода. &lt;code&gt;--noUnusedParameters&lt;/code&gt; отмечает любые неиспользуемые ошибки параметров функции или метода. &lt;code&gt;--noUnusedLocals&lt;/code&gt; помечает любые неиспользуемые локальные ( неэкспортированные ) объявления, такие как переменные, функции, классы, импорт и т. д. Кроме того, неиспользуемые частные члены класса будут помечены как ошибки в &lt;code&gt;--noUnusedLocals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc8a687464d96e2157a2c30deb24a3363ed46e0d" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to &lt;code&gt;if&lt;/code&gt; statements and &lt;code&gt;?:&lt;/code&gt; conditional expressions and didn&amp;rsquo;t include effects of assignments and control flow constructs such as &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the &lt;em&gt;narrowed type&lt;/em&gt;) at any given location for a local variable or parameter that is declared to have a union type.</source>
          <target state="translated">TypeScript 2.0 реализует анализ типов на основе потока управления для локальных переменных и параметров. Раньше анализ типов, выполняемый для защиты типов, ограничивался операторами &lt;code&gt;if&lt;/code&gt; и &lt;code&gt;?:&lt;/code&gt; Условными выражениями и не включал эффекты присваиваний и конструкций потока управления, такие как операторы &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;break&lt;/code&gt; . В TypeScript 2.0 средство проверки типов анализирует все возможные потоки управления в операторах и выражениях, чтобы создать наиболее конкретный возможный тип ( &lt;em&gt;суженный тип&lt;/em&gt; ) в любом заданном месте для локальной переменной или параметра, который объявлен как имеющий тип объединения.</target>
        </trans-unit>
        <trans-unit id="b991a7d51345ee804bcdb5d52051777fdcb20357" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to &lt;code&gt;switch&lt;/code&gt; statements.</source>
          <target state="translated">TypeScript 2.0 реализует поддержку помеченных (или размеченных) типов объединения. В частности, компилятор TS теперь поддерживает средства защиты типов, которые сужают типы объединения на основе тестов дискриминантного свойства и, кроме того, расширяют эту возможность для операторов &lt;code&gt;switch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f541e32a97ad0b756a4e358c4745c3b45d62017f" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 introduces a new primitive type &lt;code&gt;never&lt;/code&gt;. The &lt;code&gt;never&lt;/code&gt; type represents the type of values that never occur. Specifically, &lt;code&gt;never&lt;/code&gt; is the return type for functions that never return and &lt;code&gt;never&lt;/code&gt; is the type of variables under type guards that are never true.</source>
          <target state="translated">TypeScript 2.0 &lt;code&gt;never&lt;/code&gt; вводит новый примитивный тип . Тип &lt;code&gt;never&lt;/code&gt; представляет собой тип значений, которые никогда не встречаются. В частности, &lt;code&gt;never&lt;/code&gt; является возвращаемым типом для функций, которые никогда не возвращаются, и &lt;code&gt;never&lt;/code&gt; является типом переменных в рамках защиты типов, которые никогда не являются истинными.</target>
        </trans-unit>
        <trans-unit id="c6947ff29cc72002ee0d4fa4f9ecea90ea690c25" translate="yes" xml:space="preserve">
          <source>TypeScript 2.0 provides a set of additional module resolution knops to &lt;em&gt;inform&lt;/em&gt; the compiler where to find declarations for a given module.</source>
          <target state="translated">TypeScript 2.0 предоставляет набор дополнительных кнопок разрешения модуля, чтобы &lt;em&gt;сообщить&lt;/em&gt; компилятору, где найти объявления для данного модуля.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
